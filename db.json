{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/vno/source/js/main.js","path":"js/main.js","modified":0},{"_id":"themes/vno/source/js/insight.js","path":"js/insight.js","modified":0},{"_id":"themes/vno/source/js/embed.js","path":"js/embed.js","modified":0},{"_id":"themes/vno/source/js/APlayer.min.js","path":"js/APlayer.min.js","modified":0},{"_id":"themes/vno/source/images/show/list.jpeg","path":"images/show/list.jpeg","modified":0},{"_id":"themes/vno/source/images/show/home.png","path":"images/show/home.png","modified":0},{"_id":"themes/vno/source/images/show/google-analytics.jpeg","path":"images/show/google-analytics.jpeg","modified":0},{"_id":"themes/vno/source/images/show/baidu_tongji.jpeg","path":"images/show/baidu_tongji.jpeg","modified":0},{"_id":"themes/vno/source/images/show/article.jpeg","path":"images/show/article.jpeg","modified":0},{"_id":"themes/vno/source/images/background-cover.jpg","path":"images/background-cover.jpg","modified":0},{"_id":"themes/vno/source/images/avatar.png","path":"images/avatar.png","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/vno/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0},{"_id":"themes/vno/source/css/vno.styl","path":"css/vno.styl","modified":0},{"_id":"themes/vno/source/css/tomorrow.css","path":"css/tomorrow.css","modified":0},{"_id":"themes/vno/source/css/search.styl","path":"css/search.styl","modified":0},{"_id":"source/music/mzr/mzr.ogg","path":"music/mzr/mzr.ogg","modified":0},{"_id":"source/music/mzr/mzr.lrc","path":"music/mzr/mzr.lrc","modified":0},{"_id":"source/music/mzr/mzr.jpg","path":"music/mzr/mzr.jpg","modified":0},{"_id":"source/images/zyz.png","path":"images/zyz.png","modified":0}],"Cache":[{"_id":"source/_posts/20160319-candy.md","shasum":"f13122a5162f37bd168bbe581916353a80bf96ce","modified":1462959204410},{"_id":"source/_posts/20160318-color.md","shasum":"4ba75ba58df47c2827d754b7cd1403c2e5a4fe5f","modified":1462959204410},{"_id":"source/_posts/20160319-set.md","shasum":"e7eb9c83dfd79c39fa6ab6288487d7451fd8be9f","modified":1462959204410},{"_id":"source/_posts/acam-notes/acam.svg","shasum":"443fe0f8ed15e6b9ef1aadeadef650b8ff57e031","modified":1481071571494},{"_id":"source/_posts/20160331-naive.md","shasum":"3ff152e74585ff685591863055fd944851352fd7","modified":1462959204420},{"_id":"source/_posts/acam-notes/acam2.svg","shasum":"02f0702387bd40ee0980ea1da05b2eff5fd05ec8","modified":1481071560998},{"_id":"source/_posts/20160404-theory.md","shasum":"e65366ddf744b97ea3c4e04212ea7f53221f1abe","modified":1477351973565},{"_id":"source/_posts/20160527-array.md","shasum":"a76262669f5104a91a95a469b2389802a606aaf0","modified":1464365684525},{"_id":"source/_posts/acam-notes.md","shasum":"d79024fb77cca744030dc564c1040c1badc7d015","modified":1483340624787},{"_id":"source/_posts/ahoi2008-meet.md","shasum":"e0b091db3a703654300269a5e26b61cc9b345c43","modified":1462959204420},{"_id":"source/_posts/ahoi2013-diff.md","shasum":"7bc65d01071dd6e1b407a23fe06febf89aae7bf0","modified":1475155507464},{"_id":"source/_posts/ahoi2013-homework.md","shasum":"c1885a83afeacf0ec2651d2dffc4433d66c71f46","modified":1483067289067},{"_id":"source/_posts/ahoi2014-story.md","shasum":"2612b109cd4041278c1c642edf3bdfd804a3abe1","modified":1482631025190},{"_id":"source/_posts/at-the-cross-of-time/mzr.lrc","shasum":"25283ad79892beb5c83c43d981fdd32fbee30466","modified":1472609600778},{"_id":"source/_posts/apio2009-atm.md","shasum":"4c8b22e60777afe7205ce9a900eb1a02256c28e8","modified":1462959204420},{"_id":"source/_posts/apio2010-commando.md","shasum":"8fa94fab900ebf9c22c4f8323b5ae51a80ba6041","modified":1477351986840},{"_id":"source/_posts/apio2012-dispatching.md","shasum":"05ea59ac8e5545546d5a6b9b363e0f91045dd1cb","modified":1483518413539},{"_id":"source/_posts/at-the-cross-of-time.md","shasum":"6a69e0576d4becf6c64d697f64b1600684f86600","modified":1483160692357},{"_id":"source/_posts/bigint-template.md","shasum":"934fda5bea22b36e0606b10d33bc5df2f37d2487","modified":1462959204420},{"_id":"source/_posts/bsgs-notes.md","shasum":"dc43f79b94f595c467266a940e86648458828d19","modified":1483361263572},{"_id":"source/_posts/bzoj-1001.md","shasum":"72d9592ee87d155d313e7f628a8cebfae4aea2da","modified":1462959204420},{"_id":"source/_posts/bzoj-1008.md","shasum":"9e33d15285f7e920f9c945333df08bcb7bcc2c21","modified":1462959204420},{"_id":"source/_posts/bzoj-1176.md","shasum":"15b02ad8dd8e0ee24c61c6b0a165b2207065e63c","modified":1466431866375},{"_id":"source/_posts/bzoj-1251.md","shasum":"c08cd8320d570bccf0d3bc1be414e62b28b8a4da","modified":1462959204420},{"_id":"source/_posts/bzoj-1334.md","shasum":"abdb171b4bac613dca99191ef1801a96a998caec","modified":1477351995812},{"_id":"source/_posts/bzoj-1468.md","shasum":"0b82120a77b6175dff7f5aa518b23484188ffa05","modified":1466071797460},{"_id":"source/_posts/bzoj-1477.md","shasum":"c595afe04efabe234f97173104721f64efdbd233","modified":1462959204420},{"_id":"source/_posts/bzoj-1585.md","shasum":"8fbfb910f2698f366ee666295c4d8d6749d22046","modified":1466583292252},{"_id":"source/_posts/bzoj-1597.md","shasum":"90b890eb6f1937eeca51175e70935f65f36ff154","modified":1477352334716},{"_id":"source/_posts/bzoj-1692.md","shasum":"7d031362d6e4cdaaa6bba2b6eb13706db8dc7efb","modified":1475156754344},{"_id":"source/_posts/bzoj-1706.md","shasum":"ab608ab18d6e990d5f08f0969c5102b3c699b970","modified":1475882328043},{"_id":"source/_posts/bzoj-1711.md","shasum":"625edc5f73eabf5673add401b9f8242356034202","modified":1475917486235},{"_id":"source/_posts/bzoj-1718.md","shasum":"ad23023b9d8804f44d542853b60d229f222aefb0","modified":1483234239897},{"_id":"source/_posts/bzoj-1756.md","shasum":"60bf2403886143b533d0a969f90c410a8550b425","modified":1462959204420},{"_id":"source/_posts/bzoj-2038.md","shasum":"f2168817f10ce4efdc4e11ddb87533de4e0ba411","modified":1462959204420},{"_id":"source/_posts/bzoj-2120.md","shasum":"4a9e78ff7483870d8bc9e453e382f61d37c00eeb","modified":1483062399370},{"_id":"source/_posts/bzoj-2127.md","shasum":"5f423860c93ca99cf0134ec7057af3a5caa1cf77","modified":1466583936327},{"_id":"source/_posts/bzoj-2132.md","shasum":"f09e494406452a281f11baad78e64b72692cced6","modified":1466672219417},{"_id":"source/_posts/bzoj-2143.md","shasum":"3fb8100c81c0111db2d10080b9786aa065ae6b10","modified":1465888560611},{"_id":"source/_posts/bzoj-2152.md","shasum":"d123e9e36bf39b483ec5daf21b61b81649bb5640","modified":1466071815564},{"_id":"source/_posts/bzoj-2194.md","shasum":"28422db536e022d9d404eb6714a6ead40b23f7d2","modified":1465651961781},{"_id":"source/_posts/bzoj-2296.md","shasum":"23212b789066f8b9bd854f2cb7b3ddea6585ec9e","modified":1462959204420},{"_id":"source/_posts/bzoj-2438.md","shasum":"a91564720a619f94894f8572d4551a53c46faebd","modified":1466843509077},{"_id":"source/_posts/bzoj-2442.md","shasum":"09e6f50360804dfd5882d273bbb6300f2da95aa0","modified":1477352012360},{"_id":"source/_posts/bzoj-2456.md","shasum":"021110d045d68e07f7e18e35ac8d3940b7836493","modified":1466172511587},{"_id":"source/_posts/bzoj-2683/cdq.png","shasum":"a95d0b02b915f092df6656298add0f0fc9662341","modified":1462955792540},{"_id":"source/_posts/bzoj-2462.md","shasum":"1732c3114d698e1c3d622c6b1a3d172100e0812c","modified":1473810063694},{"_id":"source/_posts/bzoj-2565.md","shasum":"6b64b4a04fbecc398f804a429813f19ef8bfd5d8","modified":1483345804649},{"_id":"source/_posts/bzoj-2580.md","shasum":"a73e63accb968c9992ae4c7e289994fcdbd507d5","modified":1474154745766},{"_id":"source/_posts/bzoj-2683.md","shasum":"926ec2d1b7000c24c1edd22d197180164cac76a8","modified":1466431930441},{"_id":"source/_posts/bzoj-2716.md","shasum":"fe2aec385e2971d42f1097e916fe964445aa424d","modified":1466824130905},{"_id":"source/_posts/bzoj-2820.md","shasum":"b893e9bbcea214b41bef4c502d833a930d123fdb","modified":1462959204420},{"_id":"source/_posts/bzoj-3156.md","shasum":"476a683d45bb01c6c6cca9af75e5f0c6f6c74734","modified":1477352022972},{"_id":"source/_posts/bzoj-3196.md","shasum":"154610a47819f898caa851b5b48c827183e00664","modified":1483340701203},{"_id":"source/_posts/bzoj-3230.md","shasum":"5882c46621fd0d914caa25ee49de7f163964c7b9","modified":1475191571909},{"_id":"source/_posts/bzoj-3262.md","shasum":"ad61bcd01d1a0afdc44e0e038123ff32c86a2e76","modified":1466341000696},{"_id":"source/_posts/bzoj-3275.md","shasum":"a14dc375463cfb3df8cc97d3adf5b78c7ca85456","modified":1464016159116},{"_id":"source/_posts/bzoj-3277.md","shasum":"07b57370422ef563976726932df98adac3478691","modified":1475192434037},{"_id":"source/_posts/bzoj-3438.md","shasum":"7fa24e4ae32a471e08cf89604521923861bd42e8","modified":1466493507214},{"_id":"source/_posts/bzoj-3511.md","shasum":"a69c5a7b074d933e3eb29d1b2c8a24645520728d","modified":1462959204420},{"_id":"source/_posts/bzoj-3697.md","shasum":"3560e2748c810aec86cc770aab1371f8f33698a6","modified":1474808740919},{"_id":"source/_posts/bzoj-3796.md","shasum":"d964d550ff1177bfbb1d19991f600624ab25824c","modified":1475192923083},{"_id":"source/_posts/bzoj-3894.md","shasum":"9cf338b78641a5cc1eb027d84506a587d7c9267d","modified":1466583943359},{"_id":"source/_posts/bzoj-3940.md","shasum":"34e3c58a8bed87be2046f4b4da66f095f3353edd","modified":1473810460840},{"_id":"source/_posts/bzoj-4145.md","shasum":"1383833b1739216df566d16f25ab76e377e728a8","modified":1477352032208},{"_id":"source/_posts/bzoj-3280.md","shasum":"f379b4a1212f7781164d71625d49ad3124d1b523","modified":1473508473657},{"_id":"source/_posts/bzoj-4247.md","shasum":"ecb5c5706b743d62fd19c3bcc03f4638b94e2be3","modified":1477352045720},{"_id":"source/_posts/bzoj-4318.md","shasum":"0004fbf6e758b707f24a98c3929912894626bdd0","modified":1464696387692},{"_id":"source/_posts/bzoj-4403.md","shasum":"0e503e9c28ace534c15b2b47576add9bd4027af5","modified":1462959204420},{"_id":"source/_posts/ceoi2004-two.md","shasum":"99ab98de7fb06f9fdfca038c023d4ff8f74f8755","modified":1477352054116},{"_id":"source/_posts/ceoi2008-order.md","shasum":"96b1a7c05854b6da645d341d870b6c958cac73a5","modified":1466582878396},{"_id":"source/_posts/cf-628d.md","shasum":"5bd19c9ec8ea646e78edcf23d15218c6060e1b47","modified":1477352319769},{"_id":"source/_posts/cf-716e.md","shasum":"521e9813b06b325fb88c8273b293ed5926b3365c","modified":1483340590680},{"_id":"source/_posts/cf-716e/example.svg","shasum":"a1d6731f2ef7e43ae48e27345954c6cb24a216b0","modified":1474439170788},{"_id":"source/_posts/bzoj-3289.md","shasum":"badb63442e7d4e0a8200f1e8cce98b2c16ee351d","modified":1483065935781},{"_id":"source/_posts/codevs-1345.md","shasum":"58546572e0bb94b562f55fdbf6649287a3107656","modified":1477352064784},{"_id":"source/_posts/chairman-tree-notes.md","shasum":"8be4f4b6d283778a78c6dc87d141029f34f57d51","modified":1462972004900},{"_id":"source/_posts/coci2015-divljak.md","shasum":"75aee7f3216c123eb41de62a2a657cf6fb2a9601","modified":1474239668919},{"_id":"source/_posts/codevs-1563.md","shasum":"90f4dda98f3aed528734d91eaa918ea58ad5d67d","modified":1466518742060},{"_id":"source/_posts/codevs-2822.md","shasum":"a5f2981e80882ae575f7c28d9552bddbe717915a","modified":1462959204420},{"_id":"source/_posts/codevs-2598.md","shasum":"9f5c7bea72bdd82e3f05c5e6284e8dd8e0aed8e8","modified":1477352072459},{"_id":"source/_posts/codevs-3269-monotone-queue.md","shasum":"b445e3b6240f19aae1b165e94fb3e2fa17162499","modified":1477352123283},{"_id":"source/_posts/codevs-3168-3162.md","shasum":"aafdf6bc35f4dcda18d9f89de0ae2ecb8c75c2c4","modified":1477352102283},{"_id":"source/_posts/cogs-14.md","shasum":"df074c69b9f8cacedba8ccea146ac644e8201397","modified":1462959204420},{"_id":"source/_posts/cogs-396.md","shasum":"fbfd2fc22b9c83aa16792fa61d51d702b53461f7","modified":1462959204430},{"_id":"source/_posts/cogs-439.md","shasum":"2426244914406bd35b753d445bb5fcd3e01a5c30","modified":1462959204430},{"_id":"source/_posts/cogs-727.md","shasum":"d3f3d51ba288685a52479e3847f4e84885fcdb3e","modified":1462959204430},{"_id":"source/_posts/codevs-3269.md","shasum":"b276f70ecd368aa72d5c1a48b680f475818b0d47","modified":1477352115991},{"_id":"source/_posts/cogs-728.md","shasum":"c7fa068adf3bf1f5f5b4add16374b265ef21ca11","modified":1462959204430},{"_id":"source/_posts/cogs-729.md","shasum":"bb45c57f781ff5c8eb0e87b3edadf7b206b81c01","modified":1462959204430},{"_id":"source/_posts/cogs-734.md","shasum":"4a748f8ae51d4d1990b89ac8081e53d74fbc183c","modified":1462959204430},{"_id":"source/_posts/cogs-731.md","shasum":"f16c01e7c3da8aa233df4daee546f3024726d239","modified":1477352304985},{"_id":"source/_posts/cogs-739.md","shasum":"4eb4f215432d85cc7bd93a357ee70d326f314504","modified":1462959204430},{"_id":"source/_posts/cogs-738.md","shasum":"01a88085f9e1823b8fc63e04a617b85fc1551ade","modified":1462959204430},{"_id":"source/_posts/cogs-740.md","shasum":"e90060c6feb6273cd400258627f141214574dd8f","modified":1462959204430},{"_id":"source/_posts/cogs-741.md","shasum":"91a8b62bd42e7be33d94ae1a9624d5a0d7c2c9a3","modified":1462959204430},{"_id":"source/_posts/cogs-746.md","shasum":"aa46c716f60453fdbbfa4ff4ccdca515e90e25ae","modified":1462959204430},{"_id":"source/_posts/cogs-742.md","shasum":"dc5b03c9e8b857ea345e0f906692847cc7c2508b","modified":1462959204430},{"_id":"source/_posts/cqoi2011-inverse.md","shasum":"5e6e7e3d0c82e5814f994d8468de30766070c55b","modified":1466431853556},{"_id":"source/_posts/combinatorics-notes.md","shasum":"f3e5e1bf1d06c126032426103df6f1990368ad07","modified":1462959204430},{"_id":"source/_posts/cqoi2016-cuts.md","shasum":"96b727a740bc374fefd4b8ca7d1c09b5f20648c4","modified":1462959204430},{"_id":"source/_posts/cqoi2016-number.md","shasum":"bae7a7e7008769b1bd14b496961ce95efd9f76c7","modified":1477352136359},{"_id":"source/_posts/ctsc1997-course.md","shasum":"48f7051612c8843ce79049b59c0fb88b0fbf557c","modified":1477352275933},{"_id":"source/_posts/ctsc1999-home.md","shasum":"978baaae9dd654467febabfa562eea00beb02859","modified":1462959204430},{"_id":"source/_posts/derangement-number.md","shasum":"1d85fe52fcf017157eeffc96e660b029b83cb31f","modified":1462959204430},{"_id":"source/_posts/ctsc-apio-2016.md","shasum":"b8a08df409b774cf281797e8a8dc95e01de5624a","modified":1479656971201},{"_id":"source/_posts/dinic-notes.md","shasum":"ec041e36d2aa97dad861d9851524cb01f3b5ed1a","modified":1482585228817},{"_id":"source/_posts/docker-sandbox-judger.md","shasum":"8a5895d636752944fc5f8b83c17dd594f7209331","modified":1481635493048},{"_id":"source/_posts/euler-circuit-notes.md","shasum":"22b4a062c5e61d3c1b2dec0e4c976346fd753e8f","modified":1483339121747},{"_id":"source/_posts/edmonds-karp-notes.md","shasum":"edba11cb82da34ac8af87a4462724abe868e94e5","modified":1482635144773},{"_id":"source/_posts/euler-sieve.md","shasum":"bdd661e2b3f1d99f802c6179a97c7c31dd4f883d","modified":1462959204440},{"_id":"source/_posts/fft-notes.md","shasum":"b36068745daabad1be6474be5e84e86c38fceee7","modified":1482474049497},{"_id":"source/_posts/fft-to-ntt.md","shasum":"1876bb4ba0acf94f95333a06dfdaa8eae3f51cd8","modified":1466170692116},{"_id":"source/_posts/fjoi2007-wheel.md","shasum":"62ed81583cf9b21d3798a0f89b3e4d4fe56ac776","modified":1476696387229},{"_id":"source/_posts/geometry-notes/1.ggb","shasum":"4e6d9a8a63ed9c440f40708c3d25a8b78eda515d","modified":1483666187955},{"_id":"source/_posts/geometry-notes/2.ggb","shasum":"661074f4858099ec573c4f9b145331bf3a0220f0","modified":1483668465407},{"_id":"source/_posts/geometry-notes/3.ggb","shasum":"0463664a0f02fc6736b06b234b660eb85e33c9e8","modified":1483670035666},{"_id":"source/_posts/geometry-notes/4.ggb","shasum":"e83654c63399e2af73b4d567a62ab55419c3b1d1","modified":1483672012782},{"_id":"source/_posts/geometry-notes/5.ggb","shasum":"6c347a3c0dd1ef65cf4671cfefe6c8e4c9ec3c65","modified":1483672862394},{"_id":"source/_posts/geometry-notes/6.ggb","shasum":"4f8d2e7c8949a912625f9d6dfb1e375d6dbda0c9","modified":1483688801569},{"_id":"source/_posts/geometry-notes.md","shasum":"3e5f73afc014f1fe837cb2b2ad0d6080657bab9a","modified":1483692199588},{"_id":"source/_posts/gnu-debugger.md","shasum":"a39a3556d1965b8fc4ce3404e23c4aa5587ceca1","modified":1462959204440},{"_id":"source/_posts/haoi2006-cow.md","shasum":"de4e6dcca3e29acdc131063a61ca1f8fd1ee3be1","modified":1462959204440},{"_id":"source/_posts/haoi2006-sequence/2.svg","shasum":"57a7cee258306ed3073e46a9e0e79f6485c8f100","modified":1481071191582},{"_id":"source/_posts/haoi2006-sequence/1.svg","shasum":"0337ba40ba7e2733cc657b79636f5f06e5f7c9a3","modified":1481071178527},{"_id":"source/_posts/haoi2007-ant.md","shasum":"2bd734af13a13d0361dc29d13a63b5120df22f8b","modified":1481619427004},{"_id":"source/_posts/haoi2006-sequence.md","shasum":"deabe14357855cd51e4690ddabaea2eb1e1933f4","modified":1481070972380},{"_id":"source/_posts/haoi2007-cover.md","shasum":"c3892255d5e8a099d5b5ca12afd35abdb7822642","modified":1481618244905},{"_id":"source/_posts/haoi2007-lis.md","shasum":"d559fad8378784179e8605eec1b0c70c6f75e34c","modified":1480580725224},{"_id":"source/_posts/haoi2008-candy.md","shasum":"e408ba8c0c27c36c3fa2606474560055131c2412","modified":1479021877454},{"_id":"source/_posts/haoi2007-square.md","shasum":"a4a760a50dd8df40925bed1f51856373fcfccc64","modified":1480634217457},{"_id":"source/_posts/haoi2007-separation.md","shasum":"4b6aaca21dcf4324d4d22dd6983c52d1d1411709","modified":1480895559695},{"_id":"source/_posts/haoi2008-coins.md","shasum":"b2a5b3bebb8b9bd49ac5e76691ae32acd10e19bd","modified":1479006702698},{"_id":"source/_posts/haoi2008-move.md","shasum":"f276822ba6612d78a2b2a3fb307a73134e8f61eb","modified":1481620097277},{"_id":"source/_posts/haoi2008-cir.md","shasum":"268b031e4e51141293fed8dc35b778c0e9d6c01f","modified":1479005811312},{"_id":"source/_posts/haoi2008-name.md","shasum":"55056d53974b62ac7ba9c4daa55fb46bf2d7b125","modified":1477352144055},{"_id":"source/_posts/haoi2008-stick.md","shasum":"76f7a22c09f8394f2aff8a2f54bd36ce570a048c","modified":1479007911164},{"_id":"source/_posts/haoi2008-rank.md","shasum":"71444692107dffe7bcdb1a3aac4d63117c922c61","modified":1481620085081},{"_id":"source/_posts/haoi2011-problemb.md","shasum":"80f9d8191d53d49067ee4e5c654cdc60a8a53384","modified":1462959204440},{"_id":"source/_posts/haoi2015-t2.md","shasum":"b46b9260d7c4fd96c6f56b7faf8eb10a7507fc55","modified":1473500685141},{"_id":"source/_posts/hdu-2089.md","shasum":"52c4b8de67b50c5f4addd2d422c958164ed2e5fd","modified":1477352153582},{"_id":"source/_posts/haoi2016-chain.md","shasum":"b722f46a179a7fd0fd2293235b225a75c3343ef2","modified":1462959204440},{"_id":"source/_posts/bzoj-3365.md","shasum":"3bfab6ccaa5e2dfd1fa3a6a4d65d68fb96a5b22a","modified":1466071781441},{"_id":"source/_posts/heoi2013-bag.md","shasum":"3d3544eca469964d0c67c98cc605e76bd654a445","modified":1477352200514},{"_id":"source/_posts/hdu-5632.md","shasum":"e8b90a7fda59235e4c0a7de7416e0f6bd2c2eaa9","modified":1477352162698},{"_id":"source/_posts/hdu-5906.md","shasum":"de080c085c1e5d051fc64319167bb951836391dc","modified":1475229652455},{"_id":"source/_posts/here-the-best-sight.md","shasum":"3637d1d214c07759c6d10333012d67e75f74f297","modified":1483314452149},{"_id":"source/_posts/hnoi2004-language.md","shasum":"7c4a81764969730a17d818d80444428dc84d8179","modified":1473723911171},{"_id":"source/_posts/hnoi2004-pet.md","shasum":"b2bda3d66ff145436b7eab827120e72edbae6c57","modified":1462959204440},{"_id":"source/_posts/hnoi2008-cards.md","shasum":"a99c6c4f9bbf046575f4cf52eae0fdb272c1cc59","modified":1476673417128},{"_id":"source/_posts/hnoi2008-gt.md","shasum":"51d30d56860cf265cf1a21586d14ed5b7371d2e1","modified":1475880765853},{"_id":"source/_posts/hnoi2008-kingdom.md","shasum":"630ff7a9fe9730a54e7fb2af393bb3975bc30b87","modified":1476696323487},{"_id":"source/_posts/hnoi2008-toy.md","shasum":"26405e1e114faeb135c6a647611853b9a3e34811","modified":1477352187662},{"_id":"source/_posts/hnoi2008-tree.md","shasum":"ba8997bd556bb160cc33b8978d55000e45c34b6e","modified":1476673607260},{"_id":"source/_posts/hnoi2010-chorus.md","shasum":"ef16ed9ed60a26fb7296c92f5456aff90b98849d","modified":1477352209310},{"_id":"source/_posts/hnoi2012-mine.md","shasum":"cce8a25d8ba4f48806c8b10b6ea947912bb72964","modified":1473292401367},{"_id":"source/_posts/hnoi2016-network.md","shasum":"701e1dfb9e177e0b4857e359cc2b2e32392fd4cd","modified":1462959589490},{"_id":"source/_posts/hnoi2016-multiple.md","shasum":"5f8819ca3130cd4e04f7c49a5ff3c52b50fe67a9","modified":1462959204440},{"_id":"source/_posts/hnoi2016-sequence.md","shasum":"584e140ef6c2aefe78304fcedce69218d3c90d55","modified":1462959204440},{"_id":"source/_posts/hdu-5642.md","shasum":"65de14e383af7e37e49ab3a7c18f8acacab2f00e","modified":1477352172278},{"_id":"source/_posts/jsoi2007-cipher.md","shasum":"72d59d69cd1774e5ff8550950b7787d1c5245fae","modified":1475154361131},{"_id":"source/_posts/jsoi2007-generator.md","shasum":"389a27109369808043d691bfce41bc3fa3b5b754","modified":1473636489303},{"_id":"source/_posts/jsoi2007-mahjong.md","shasum":"7168f1c1c3915f6bdfbe63ab8fb1ad6eacd8e872","modified":1478997155260},{"_id":"source/_posts/ioi2008-island.md","shasum":"c556010ee83873a588f35bf672275d3f03fd55de","modified":1477402349876},{"_id":"source/_posts/hnoi2016-tree.md","shasum":"d8e0634d20447cf11e6a3dc092629df943442b65","modified":1473486695350},{"_id":"source/_posts/jsoi2007-repair.md","shasum":"b471ddac6cf3614bf4c70f7422bdc0c88a77fb79","modified":1479000357614},{"_id":"source/_posts/jsoi2008-dotr.md","shasum":"b0d21a9fcaf6e34cd3a1d55b6f4db4914e7165f7","modified":1477352221646},{"_id":"source/_posts/jsoi2008-award.md","shasum":"8ac08f0cbca053ae3a9af3c3f8c7a333149e1ef9","modified":1476798062436},{"_id":"source/_posts/jsoi2008-maxnumber.md","shasum":"973b88d1287688eef3d8f99363a1db35399213db","modified":1462959204440},{"_id":"source/_posts/jsoi2008-prefix.md","shasum":"9d1e1e5bfc935b12dd2477dc09b31eeeda7651b8","modified":1476796235311},{"_id":"source/_posts/jsoi2008-starwar.md","shasum":"44f26d7aea8467915a733921932eb627c32c8657","modified":1476796800814},{"_id":"source/_posts/jsoi2009-game.md","shasum":"7e3bcdfbc619bd881e671216285cd1649f62b87a","modified":1462959204440},{"_id":"source/_posts/jsoi2016-flight.md","shasum":"9f52be4f9cddedb2ab7e6737ce2f387faa9147e6","modified":1462959238400},{"_id":"source/_posts/jsoi2009-game2.md","shasum":"982f4ff3511ef0b4262c197d007eafe92667d97e","modified":1474191031290},{"_id":"source/_posts/jsoi2016-light.md","shasum":"58533f261da20e6409234f6aee1ea40049a1f35f","modified":1462959204440},{"_id":"source/_posts/kmp-notes.md","shasum":"51550012962150b1d7c7bbfdce5f8275cd654ec1","modified":1483235057894},{"_id":"source/_posts/link-cut-tree-notes.md","shasum":"d0dd589310e783f3cc72f2d4a558396dde355f78","modified":1462959204440},{"_id":"source/_posts/manacher-notes/1.svg","shasum":"689f9a1a16fa6bebbe71921fe95a95791af6d03a","modified":1483355976711},{"_id":"source/_posts/manacher-notes.md","shasum":"5de4e5b4d8a9f65229dad35bfe02866aa9375749","modified":1483359315263},{"_id":"source/_posts/manacher-notes/2.svg","shasum":"9846f2acbe071d16813087471c83561141070942","modified":1483356000303},{"_id":"source/_posts/mo-algorithm-notes.md","shasum":"04963d986f2cbd596dfc9d92c1efdbb209e3afb7","modified":1462959204440},{"_id":"source/_posts/manacher-notes/3.svg","shasum":"2c61c2f78699f473f9c9758f7ed9fe4984ee1b97","modified":1483356016587},{"_id":"source/_posts/minimum-spanning-tree-notes.md","shasum":"5e376a19420ba0d04fbfc86ffb85254f8f33b464","modified":1462959204440},{"_id":"source/_posts/monotone-queue-notes.md","shasum":"fc7a11f33c6b9f425dde2c3b3c901e7018aca151","modified":1462959204440},{"_id":"source/_posts/mul-inverse.md","shasum":"88b06571986b29765bc702445e03c7db387ed3b1","modified":1462959204450},{"_id":"source/_posts/node-devide-notes.md","shasum":"125c398ee1be3445dbbc96b8e724e9ac97c3b9d9","modified":1466152641034},{"_id":"source/_posts/node-devide-notes/tree1.svg","shasum":"4de32d5e3b22eb531886d0f9f475f2a9982ee471","modified":1481071614437},{"_id":"source/_posts/ioi2011-race.md","shasum":"e656c8dc53b1d87d99f3d3e9ef8425949a54dde0","modified":1466078515927},{"_id":"source/_posts/node-devide-notes/tree2.svg","shasum":"407c61fdd3d63b87c5678d80c9b6213781d2cb1f","modified":1481071624189},{"_id":"source/_posts/noi2003-editor.md","shasum":"6d6ccf7f089180de540cb75879f4589b5c1e8ee4","modified":1462959204450},{"_id":"source/_posts/noi2006-profit.md","shasum":"cdf389673d9a8babd630e8c5bc247670b695bff4","modified":1462959204450},{"_id":"source/_posts/noi2008-candy/2.ggb","shasum":"b72de255a5a79e92a5a220da592cc30818579ca7","modified":1482481329150},{"_id":"source/_posts/noi2008-candy/1.svg","shasum":"487bedd4ee907b6af27bc2dff608d7084da67f46","modified":1482459268920},{"_id":"source/_posts/noi2008-candy/3.ggb","shasum":"7155350e293077d4fd36bd65715ea693ed339c80","modified":1482480473665},{"_id":"source/_posts/noi2008-candy/2.svg","shasum":"84a22ca72f6e0ff90dfce05b56f44e7ab66f3cc9","modified":1482480535076},{"_id":"source/_posts/noi2008-candy/4.ggb","shasum":"0c851a79d13d36a0bc06c1360ec5ca3b48e301a2","modified":1482481843625},{"_id":"source/_posts/noi2002-galaxy.md","shasum":"0b62ae091bdecd684968bd8eb0707890d71eeac1","modified":1462959204450},{"_id":"source/_posts/noi2008-candy/5.ggb","shasum":"e80d5ff3511748769937e358ca9f213db78a3adc","modified":1482482981048},{"_id":"source/_posts/noi2008-candy/6.ggb","shasum":"b968f70e6224debb5e16b9ea4a1e39ebc2de4834","modified":1482484170031},{"_id":"source/_posts/noi2008-candy/7.ggb","shasum":"fbf0ec7e19ee13b534e9aa66ded3170ec449261e","modified":1482484224546},{"_id":"source/_posts/noi2004-cashier.md","shasum":"0504fdf9c3754c9f1fa1b1be8befc3dcf0852794","modified":1462959204450},{"_id":"source/_posts/noi2008-candy.md","shasum":"ab7d37baeb1d12378e115a08a1d4a97c39af3e1d","modified":1482487256316},{"_id":"source/_posts/noi2011-type.md","shasum":"f84650491029914e9de402d6433b478d1caa32f0","modified":1473638033794},{"_id":"source/_posts/noi2012-random.md","shasum":"b0e78167c2a4168496fe6b70a1dc8d3b45962352","modified":1475883407010},{"_id":"source/_posts/noi2014-forest.md","shasum":"692c2d383b68f8c65f1a2b45c37cb788e7f76f47","modified":1468252483005},{"_id":"source/_posts/noi2014-sleep.md","shasum":"32c222899af7ba614509f0b5cb66bc0867154960","modified":1462959204450},{"_id":"source/_posts/noi2014-zoo.md","shasum":"48d488c5c348640989a59b2c84c2a60d8273ce10","modified":1468251707623},{"_id":"source/_posts/noi2015-dinner.md","shasum":"afbaf06fc29fcc73760e96692f67d386e51f7ffe","modified":1477352235002},{"_id":"source/_posts/noi2015-epic.md","shasum":"d9f2c20735718a4f922f1b7f0bf394fcbeb992a8","modified":1467336511308},{"_id":"source/_posts/noi2015-manager.md","shasum":"b718da5118bf865669f6505c4ac9acdba8339316","modified":1462959204450},{"_id":"source/_posts/noi2015-farm.md","shasum":"419b248d8bb0e510213977f23d5ef46b98526c8c","modified":1478001561067},{"_id":"source/_posts/noi2015-prog.md","shasum":"1f738de912a1b38d8bfc2d497e1b9c54236a13a4","modified":1478606807659},{"_id":"source/_posts/noi2015-savour.md","shasum":"05ae6befa30e37183474e5a856a8fd2b95741b93","modified":1467336519440},{"_id":"source/_posts/noi2016-excellent.md","shasum":"8d8033bffd7cc40a8a474d5914ff17c626524fc7","modified":1473118923830},{"_id":"source/_posts/noi2016-grid.md","shasum":"f86421c87bea57c995b00231fffadfd4fd54cecb","modified":1473638069201},{"_id":"source/_posts/noi2016-interval.md","shasum":"5e22b8b0f979a24af64e88dcc5ebbf8a75bddf16","modified":1473118751830},{"_id":"source/_posts/noip2000-cheng-ji-zui-da.md","shasum":"f98039cfa065e1662575945a0b1a582ec2ad2689","modified":1477351910525},{"_id":"source/_posts/noip2003-game.md","shasum":"6f382752e06de918287ed053ba5cc20db51b633a","modified":1477351904205},{"_id":"source/_posts/noip2006-energy.md","shasum":"2a1c5d16824f3e06c23b5f7cd692b187863a66bd","modified":1477351922329},{"_id":"source/_posts/noip2006-budget.md","shasum":"b350f36da264bb5fd90a5fee23019284efa9918c","modified":1477351822210},{"_id":"source/_posts/noip2010-flow.md","shasum":"7133e4ca1632ebbafbebee02cc749908e81af1f6","modified":1479029018684},{"_id":"source/_posts/noip2010-prison.md","shasum":"1c89f4fba3f01bec85a06ce8e5309a7e6d50f733","modified":1462959204450},{"_id":"source/_posts/noip2012-blockade.md","shasum":"dcbb2b7c28da18c0a662a6fd251f8d893461d8a4","modified":1479030258333},{"_id":"source/_posts/noip2012-classrooms.md","shasum":"3ec63cd7cf2caa054464e41e0e8428d52c234021","modified":1475917451595},{"_id":"source/_posts/noip2012-drive.md","shasum":"e7df25f732858eea47e4ebbb206e9cc30ab5d277","modified":1479028462387},{"_id":"source/_posts/noip2012-mod.md","shasum":"0fb6c0ef73a261e10a1b23b235c0492a247c1362","modified":1462959204450},{"_id":"source/_posts/noip2013-flower.md","shasum":"eac451fe25287a373570518cfab3666459c602ac","modified":1479026565336},{"_id":"source/_posts/noip2013-match.md","shasum":"a3b515c40a4d08f8abef8c1b26e0923df31b8d56","modified":1479024938455},{"_id":"source/_posts/noip2013-puzzle.md","shasum":"15b7b800cabdda94234aff34e9591e22974a4383","modified":1479033358177},{"_id":"source/_posts/noip2015-substring.md","shasum":"8132adb345d5966190126eb464240285ca345188","modified":1478069428453},{"_id":"source/_posts/noip2015-transport.md","shasum":"65287e79098fc97ed2f63ad521889c0e5cb853a5","modified":1476882449463},{"_id":"source/_posts/noip2016-angrybirds.md","shasum":"d4b424e95af568e449f201378bcccca21ffc3973","modified":1480425733905},{"_id":"source/_posts/noip2016-classroom.md","shasum":"a4730715dec75b04f15ebf35c7fc3e7c803c1a81","modified":1480404993407},{"_id":"source/_posts/noip2016-running/linear-backward1.svg","shasum":"f11ad00d6b6d9c4a9dbcdd756a54ac9f98aae87c","modified":1480402071309},{"_id":"source/_posts/noip2016-running/linear-forward1.svg","shasum":"21d1e9f4c290ba36e95ca3d1a3f03108f7e7d08c","modified":1480401570576},{"_id":"source/_posts/noip2016-earthworm.md","shasum":"1b2fcb76d67ccbceab9b7a4fccbdd8d36e25f77c","modified":1480425082980},{"_id":"source/_posts/noip2016-running/linear-forward2.svg","shasum":"d828849ead2a7f7a3ac34250ec3e468dd053fe4c","modified":1480401597915},{"_id":"source/_posts/noip2016-running.md","shasum":"4314316adc4ca81526daf243a8365e04f7224136","modified":1480404979183},{"_id":"source/_posts/noip2016-problem.md","shasum":"3f2bfceef09b7568444107ae65ed6222db1f5f29","modified":1480425142493},{"_id":"source/_posts/noip2015-landlords.md","shasum":"383d0be32afdf22cbb8c522fea4ae2fcde6b7676","modified":1476865979622},{"_id":"source/_posts/noip2016-toy.md","shasum":"5b73c18d444e50a23f5352203f26632af2830c2c","modified":1480404968883},{"_id":"source/_posts/noip2016.md","shasum":"a9273f495144f13620fd53d5e847c9f596becd2d","modified":1479656914658},{"_id":"source/_posts/non-recursion-dfs-with-stack.md","shasum":"77777eea132ddbbc8f0201f6438267a80a414656","modified":1462959204450},{"_id":"source/_posts/npm-debug.log","shasum":"881c868bf599dd4f4753f8b868bec0bb7a2a6f51","modified":1466824292761},{"_id":"source/_posts/number-theory-notes-1.md","shasum":"06a1c30f28a21e76f65bc5afc0d9766231d8af32","modified":1462959204450},{"_id":"source/_posts/poi2000-wir.md","shasum":"c7d42107d0fdf656828fda727b7c0207494f9dd3","modified":1473724314323},{"_id":"source/_posts/poi2005-kos.md","shasum":"7d2d41ca023967051b7c5e8262484cff78a75009","modified":1466591154146},{"_id":"source/_posts/poi2006-szk.md","shasum":"6eb519b750b4996e46308708f4676ef24bf623d3","modified":1466590859112},{"_id":"source/_posts/poi2008-blo.md","shasum":"60d3bdf871aedf1869912848eea175276493eff6","modified":1473332288939},{"_id":"source/_posts/poj-1737.md","shasum":"09c4fec6b5a83f1b9b7b8161b0aab0ac1b24cbc3","modified":1462959204450},{"_id":"source/_posts/poj-2728.md","shasum":"732694ea57c6eef6f36cb28708d0072913ef8f1e","modified":1462959204450},{"_id":"source/_posts/poj-3630.md","shasum":"ea594cc176ecbf8a9af0643bee8b1f4f4622b467","modified":1483326617944},{"_id":"source/_posts/poj-3461.md","shasum":"226bd4eac18f3439dc754c946c995894cb74d640","modified":1462959204450},{"_id":"source/_posts/rmq-template.md","shasum":"373e730b68daa4c8c75ba4b493c6fc8b173439d5","modified":1483235157252},{"_id":"source/_posts/scoi2003-fold.md","shasum":"3aa6ac1189749d23245e8d9aa80da44c17eecd51","modified":1477351878502},{"_id":"source/_posts/scoi2005-royal.md","shasum":"654ad9f1b238ea866ff1badedef6ad582903c1a7","modified":1483068824830},{"_id":"source/_posts/scoi2007-lizard.md","shasum":"bbe131ab41e3ad9d89f12e81969a7c251c3d358e","modified":1472910683260},{"_id":"source/_posts/scoi2007-repair.md","shasum":"e5cd2d95c22fd64d8f4362732d747292a4e17240","modified":1462959204450},{"_id":"source/_posts/scoi2009-cake.md","shasum":"8573193bdcfc4f2a85224fd1791b00d1b91af94e","modified":1478956661779},{"_id":"source/_posts/scoi2009-game.md","shasum":"dd4f8b3206e56636eb53b7507b3b7c8ba0994438","modified":1478998078148},{"_id":"source/_posts/scoi2009-paint.md","shasum":"6650628febe53de448522a2028b19752256ee9bb","modified":1477351841406},{"_id":"source/_posts/scoi2009-windy.md","shasum":"227dc0a7195a3a327f2e3f5788dee664da2a3d83","modified":1477351833902},{"_id":"source/_posts/scoi2010-game.md","shasum":"81be4ae0bb7c1120e220a5177bea4877d19780f3","modified":1462959204450},{"_id":"source/_posts/scoi2011-candy.md","shasum":"3037949e9f52b0faac3b2ca5b4d7f40e64147dad","modified":1462959204450},{"_id":"source/_posts/scoi2015-flag.md","shasum":"d2273c0aa7434ce104123d934eed5ebc76ce7874","modified":1462959204450},{"_id":"source/_posts/scoi2012-name.md","shasum":"56ed15710897916cb0855611a326acf53bc7bb96","modified":1475155718840},{"_id":"source/_posts/scoi2015-light.md","shasum":"6f50e8af86425d00844a560e71538656754f9f6f","modified":1477351887454},{"_id":"source/_posts/scoi2015-matrix.md","shasum":"81f28e7cad4caf2a53201684e2eebc1961e7e42e","modified":1462959204450},{"_id":"source/_posts/scoi2015-message.md","shasum":"eaba94296389b994b29a45744ad81674723c1e31","modified":1462959204450},{"_id":"source/_posts/scoi2015-password.md","shasum":"ba24fd5191837df620e52e49246f6481006b0610","modified":1462959204450},{"_id":"source/_posts/sdoi2008-cave.md","shasum":"0665e52de3f255cafac2bdc5b5c8f9ee23deee5c","modified":1462959204450},{"_id":"source/_posts/sdoi2008-interval.md","shasum":"6d7c73c685e299bcefb7bb93dd4efa340d1ac0c6","modified":1472823498227},{"_id":"source/_posts/sdoi2009-run.md","shasum":"239f7f7943172b90055db3a73dc898ba4a248a13","modified":1466511891867},{"_id":"source/_posts/sdoi2010-goblin.md","shasum":"88700569b1ba9e8abf8a695bd17b762252927cb3","modified":1466409035404},{"_id":"source/_posts/sdoi2010-starrace.md","shasum":"7cdfa2fbc6b5703175d491f81869e84382baf68c","modified":1462959204450},{"_id":"source/_posts/sdoi2011-calc.md","shasum":"8bc38c373e311a2ca92f3f7ce36654a436d31f21","modified":1465790863358},{"_id":"source/_posts/sdoi2013-rforest.md","shasum":"a16ac45bc3f7d66afd0d348d8c30f9c4776906e5","modified":1476869061064},{"_id":"source/_posts/sdoi2016-game/line.png","shasum":"30c24e553938d2c27b55779527825b2577088a7c","modified":1462955792590},{"_id":"source/_posts/sdoi2016-game/tree.png","shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86","modified":1462955792590},{"_id":"source/_posts/sdoi2014-journey.md","shasum":"2e11f80c5309333604309cd252acb87bcb39b70e","modified":1472823755641},{"_id":"source/_posts/sdoi2015-sequence.md","shasum":"2fe794b7d355bc493c80053ec8841812042c7acf","modified":1466170749686},{"_id":"source/_posts/sdoi2015-war.md","shasum":"4a6a234666ff45ea7c5069e6630519b646dac882","modified":1462959204460},{"_id":"source/_posts/sdoi2016-game.md","shasum":"f4688c431daa3a3b77b8ac3ec53c43f27ffb63de","modified":1462959204460},{"_id":"source/_posts/sdoi2016-incantation.md","shasum":"1152f86db800b686d790898d6b9193c7d8712bbe","modified":1462959204460},{"_id":"source/_posts/sdoi2016-journey.md","shasum":"9a67291ff2e3d19a6acb34043bd649423974380f","modified":1477351780335},{"_id":"source/_posts/sdoi2016-pair.md","shasum":"9a707c8f327534044dac4b013a285184edd7d349","modified":1462959204460},{"_id":"source/_posts/sdoi2016-permutation.md","shasum":"ac94de60fa9ed03ece26c466ef20698e935d6752","modified":1462959204460},{"_id":"source/_posts/sdoi2016-round1.md","shasum":"7e92ad517aff81a72afd6c6b393a7248ca7243d0","modified":1479656964533},{"_id":"source/_posts/sdoi2016-table.md","shasum":"4069652db069ab71e8a3b733a02022472201dad6","modified":1473486856729},{"_id":"source/_posts/shoi2007-tree.md","shasum":"408976b299bfef93fe74cfd816dc427929e313c2","modified":1466824073211},{"_id":"source/_posts/shoi2007-vote.md","shasum":"600f0630bbe939bdf9bbc2c5c7809382a204b070","modified":1466492665384},{"_id":"source/_posts/shoi2008-cactus.md","shasum":"865ec5c6af46e9aa3d97d2a0cf1871b06e2e5c85","modified":1477440165110},{"_id":"source/_posts/shoi2008-debt.md","shasum":"a270d590220f6e71746789e95b9d3acd767c82fe","modified":1476862555225},{"_id":"source/_posts/shoi2008-john.md","shasum":"49c7e0d140440d5228ceb897df0f2069fd83c12d","modified":1476863627059},{"_id":"source/_posts/shoi2008-traffic.md","shasum":"93cb98cb139e4fb449aa59256b5f6fee89ac2783","modified":1476858627266},{"_id":"source/_posts/splay-notes-1.md","shasum":"b16bea4ec04052dc118bc0ff0450825ee17f600c","modified":1482823752333},{"_id":"source/_posts/splay-notes-2.md","shasum":"b7c1615a96dfff66ea8c6337d06c966a9223f69e","modified":1462959204460},{"_id":"source/_posts/splay-notes-3.md","shasum":"c2bcc200273ea0ae8fdaccd19a253f1ea35b3fdf","modified":1482823760009},{"_id":"source/_posts/shoi2008-hannoi.md","shasum":"087cf760e04d33e7a17df8e17d40f105d28f287c","modified":1476861861733},{"_id":"source/_posts/splay-template.md","shasum":"b51720515a4e010b66a63b26b677fab25b9d5e62","modified":1483235099547},{"_id":"source/_posts/spoj-694.md","shasum":"4c02dff2a042a9c83e811f5f8536a361d53d798e","modified":1462959204460},{"_id":"source/_posts/stl-in-oi.md","shasum":"34b0cdda3523f9d31ebf2e404ddd59f27d146eaf","modified":1468498796795},{"_id":"source/_posts/system-of-difference-constraints-notes.md","shasum":"cda796649d3175c93146609b99ba4e753d04c995","modified":1462959204460},{"_id":"source/_posts/tarjan-bcc-notes.md","shasum":"126b12e82af1585be249327804f1e64777c063fe","modified":1483235108131},{"_id":"source/_posts/tarjan-cut-notes.md","shasum":"66e536a386baec6af66bf283422488d359b79810","modified":1483235120015},{"_id":"source/_posts/suffix-array-notes.md","shasum":"a14a772250ef5d85308f76c1d08deb2199a705a1","modified":1462959204460},{"_id":"source/_posts/tarjan-scc-notes.md","shasum":"6f64d3531832684226875728ab1bbc4b0995caa5","modified":1482286100826},{"_id":"source/_posts/the-ever-heart.md","shasum":"d47eba0859f7f36dc4052ee73e4d91d2ca9a5234","modified":1483160547733},{"_id":"source/_posts/tree-chain-split-notes/1.svg","shasum":"0cb9b692551b4a57c404a90123f7de48afb98f9a","modified":1482885237906},{"_id":"source/_posts/tjoi2013-lis.md","shasum":"85be6ae0b508baeb46540ffdd5ca250a522254ef","modified":1475883934938},{"_id":"source/_posts/tjoi2013-word.md","shasum":"03f1e85afbb5ba3e61596010715915b24de43fc8","modified":1475883942222},{"_id":"source/_posts/tjoi2015-chessboard.md","shasum":"4755bd1f5c721d893b8e31e3c8ce619ae45ea26f","modified":1477351756791},{"_id":"source/_posts/tree-chain-split-notes.md","shasum":"3364e054e39c199112cf81ca02fac0f5312d3878","modified":1483235130759},{"_id":"source/_posts/uva-10253.md","shasum":"af4062ce79c9b4f080fe3c35d3be71ef13d0b36d","modified":1462959204460},{"_id":"source/_posts/tyvj-3317.md","shasum":"229a79bbeb50f8efbcf84fea34aec24e3b27dccc","modified":1477351673532},{"_id":"source/_posts/uva-11021.md","shasum":"5c1c140b3d2a9dc0fa068195ae0ff3a51aaf3e4d","modified":1477351734763},{"_id":"source/_posts/uva-11375.md","shasum":"3ca8e6535aab2844777ae95ec8b8e10b2864f8f4","modified":1462959204460},{"_id":"source/_posts/uva-11538/cells.png","shasum":"3a162829c312a17639950c3620cd70799ed94a49","modified":1462955792600},{"_id":"source/_posts/uva-11137.md","shasum":"ab64769680e30fc5456f896dcd7413b5ec7474a2","modified":1477351709280},{"_id":"source/_posts/uva-11174.md","shasum":"343cb90133d9be62c263c27db889c0bf2945b918","modified":1462959204460},{"_id":"source/_posts/uva-11361.md","shasum":"4c2e014fa4d70f2eb75c75e8139fad18fe3c63d5","modified":1477351724619},{"_id":"source/_posts/uva-11538.md","shasum":"030938457fbe7ab2d5aec2148b7c03acfdf9513b","modified":1462959204460},{"_id":"source/_posts/uva-11806.md","shasum":"e7fe9a9f6f7bb8d32286243d4238f189b9d70734","modified":1462959204470},{"_id":"source/_posts/uva-1362.md","shasum":"6ed0875d87e133e428f77a35f3f4f075b29d3e37","modified":1477351694088},{"_id":"source/_posts/zjoi2004-swamp.md","shasum":"6a255e50f4f5448b3a92fe288954862926e5aa99","modified":1475881729487},{"_id":"source/_posts/virtualbox-archlinux.md","shasum":"920b51fe7f50d524a368c55db06a84cba0f3df1e","modified":1462959204470},{"_id":"source/_posts/zjoi2006-trans.md","shasum":"725146000e1f996a32a1e672e19cb60fc8d7c05f","modified":1464010935316},{"_id":"source/_posts/zjoi2007-chess.md","shasum":"5109dc27f895c80dda495b98392f2e9e51138dc4","modified":1481621022469},{"_id":"source/_posts/zjoi2007-semi.md","shasum":"34804692730f5a3da0032440deb294157e8f37e9","modified":1472946674898},{"_id":"source/_posts/zjoi2007-storage.md","shasum":"67989e9cadbec2172cf844d64d62fd421a57370e","modified":1477351684936},{"_id":"source/_posts/zjoi2008-antbuster.md","shasum":"31c4b1b566f5c4319586c929f4af12c72ea89a3d","modified":1464010030156},{"_id":"source/_posts/zjoi2008-bnb.md","shasum":"ac858ed7f59d732e10122e77ade78baa597169a1","modified":1479002028968},{"_id":"source/_posts/zjoi2008-party.md","shasum":"65c92b713af1a524097ff448a1df0ad004ebcc0b","modified":1479003183231},{"_id":"source/_posts/zjoi2009-ws.md","shasum":"a8570e70c6c8cbe1db3c9fcd61a57d73338e3305","modified":1466677416289},{"_id":"source/_posts/zjoi2014-force.md","shasum":"fc88dcd64579695a98932f026cacac9d956141d8","modified":1465695038354},{"_id":"source/about-me.md","shasum":"64fcf2735c0c1b62e25355489c4cf4fa6994a922","modified":1463747969758},{"_id":"source/friends.md","shasum":"1d4316c140821c23d82933c2cc4352c57ab61bcb","modified":1476539032349},{"_id":"source/_posts/zjoi2010-network.md","shasum":"48bcc635e268cf66d01d9c129388be804bcc8413","modified":1466470152142},{"_id":"source/images/zyz.png","shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5","modified":1483234068708},{"_id":"source/_posts/noip2014-bird.md","shasum":"76874bf8cf59797f6fd23a6c0dcfa3fc25d228c3","modified":1478606832691},{"_id":"source/_posts/noip2014-equation.md","shasum":"32741b3c9a8437f91b273e1ea4979fe4e6937319","modified":1476865586067},{"_id":"source/tags/index.md","shasum":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1473486143025},{"_id":"source/music/mzr/mzr.lrc","shasum":"25283ad79892beb5c83c43d981fdd32fbee30466","modified":1483160238246},{"_id":"source/_posts/geometry-notes/1.svg","shasum":"975b2287b4c1a2f034bd98d93b7676eb974103cc","modified":1483666174907},{"_id":"source/_posts/docker-sandbox-judger/image.svg","shasum":"6636e4b99b06e88091fecbf1f184ead8c7159475","modified":1481634563080},{"_id":"source/_posts/geometry-notes/2.svg","shasum":"a9e92363b3f901f6ebc2b9ca6316d42c038e0575","modified":1483668472683},{"_id":"source/_posts/geometry-notes/3.svg","shasum":"080c446dbf929c29e276207b0665f8a0dfd292ed","modified":1483670049915},{"_id":"source/_posts/geometry-notes/4.svg","shasum":"daa7364dd8c0c14481807f25ae5f051f31552a7f","modified":1483670736855},{"_id":"source/_posts/geometry-notes/5.svg","shasum":"5f407ad7db6976704949a6a62783f8c86e304e0c","modified":1483672867806},{"_id":"source/_posts/geometry-notes/6.svg","shasum":"c90aeef41c91b50d5e65019f0f686a617859af7f","modified":1483684733585},{"_id":"source/_posts/noi2008-candy/3.svg","shasum":"b23b45b08ec89efce951bb74993a3552785b2fb6","modified":1482480485177},{"_id":"source/_posts/noi2008-candy/4.svg","shasum":"f43da416f15c7ff2e1561e1a3bac7394a9a054fd","modified":1482481865556},{"_id":"source/_posts/noi2008-candy/6.svg","shasum":"4a8fc6c8636aa2eb311e7c4c87a5a165d7f4ea38","modified":1482484174887},{"_id":"source/_posts/noi2008-candy/7.svg","shasum":"249b838061bf13e3da200bd47bb42bd83c594799","modified":1482484231342},{"_id":"source/_posts/noi2008-candy/5.svg","shasum":"faf0ef012b9602fc7d191eefb46096c6703ed3c3","modified":1482482996268},{"_id":"source/_posts/virtualbox-archlinux/port.png","shasum":"bb684dd8b616413e3e0e27c5efce118249a54113","modified":1462955792600},{"_id":"themes/vno/LICENSE","shasum":"8c84b7a07cef17ed42b549a47eefd71bb97ae698","modified":1482498872106},{"_id":"themes/vno/README.md","shasum":"91538bc2b7ae1d0d8d8046020a5cee7fc8b7b087","modified":1482498872106},{"_id":"themes/vno/_config.yml","shasum":"a502619f85676ebdc941b355f55fd890e903c9fe","modified":1482544263701},{"_id":"themes/vno/layout/_partial/baidu_tongji.ejs","shasum":"95884538b96d25aa73856e2f064832eec09810bd","modified":1482498872106},{"_id":"themes/vno/layout/_partial/comments.ejs","shasum":"d7c4951e8ce9e03314cd809c4611f2637d12589b","modified":1482501390480},{"_id":"themes/vno/layout/_partial/date.ejs","shasum":"7acd28543c62c6a4cdd9a3e49bd1fb77f0e9ab78","modified":1482498872106},{"_id":"themes/vno/layout/_partial/footer.ejs","shasum":"3c4ea282363f11fe290e28708a6695416a46bd04","modified":1482502042236},{"_id":"themes/vno/layout/_partial/google_analytics.ejs","shasum":"eddc6b239bf82409856431d8f0bb5ad8d52ab464","modified":1482498872106},{"_id":"themes/vno/layout/_partial/head.ejs","shasum":"d3359c076ca17347dff55a7338843b6b1eb81002","modified":1483160415238},{"_id":"themes/vno/layout/_partial/read-more.ejs","shasum":"05d8dc3a01f8683d61127c73bf20ecb00aeacf33","modified":1483161088773},{"_id":"themes/vno/layout/_partial/search.ejs","shasum":"3ad5a4803ad303a9fe7e1575b05953cf5c2dd071","modified":1482545066731},{"_id":"themes/vno/layout/_partial/side-panel.ejs","shasum":"132dcac09cd07c75e43c8bd7e20830515c7a716a","modified":1482581529877},{"_id":"themes/vno/layout/_partial/social.ejs","shasum":"f323157fa9460cb0ec16a1e79ce3e5b6fd6f74bf","modified":1482544016110},{"_id":"themes/vno/layout/_partial/tags.ejs","shasum":"ffcc2844bf1fae8a766e807c316129774bd4ad43","modified":1482498872106},{"_id":"themes/vno/layout/index.ejs","shasum":"e9fb32f778c61145bb1d79fabc9649f876b9bac1","modified":1482499895830},{"_id":"themes/vno/layout/layout.ejs","shasum":"8786e69cf8d5b1b0eadb4637ff908d5ee89e41e9","modified":1482502057561},{"_id":"themes/vno/layout/page.ejs","shasum":"1953ea9eb7c6cb55b137b7d18c5a374f7489d333","modified":1482498872106},{"_id":"themes/vno/layout/post.ejs","shasum":"611286b31e724d59dbbc9723e034b55e3f392f83","modified":1482498872106},{"_id":"themes/vno/source/css/_partial/highlight.styl","shasum":"36eefe6332b86b66023a9884b754d305235846b4","modified":1482498872106},{"_id":"themes/vno/source/css/_variables.styl","shasum":"8d7e3e75cf2e2806ba2aacde9ef9c3626929e3e2","modified":1482498872106},{"_id":"themes/vno/source/css/_animate.styl","shasum":"a2f854fbdc52a5657dd5e2b95cc96c0da32f3ea2","modified":1482498872106},{"_id":"themes/vno/source/css/search.styl","shasum":"b7e15b4f28f46ff39b1bdbc7ed960135094c0cfd","modified":1482544454789},{"_id":"themes/vno/source/css/tomorrow.css","shasum":"5d7e34a8cf77a0e2ec66ce04139da68026fca564","modified":1482500054623},{"_id":"themes/vno/source/css/vno.styl","shasum":"ea3c987f04cd6cb96fe623d6fbc6e5875ecb31eb","modified":1483685870326},{"_id":"themes/vno/source/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1482498872106},{"_id":"themes/vno/source/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1482498872106},{"_id":"source/music/mzr/mzr.jpg","shasum":"501f497a8efb64ab462205f7e287e6082e31edb1","modified":1483160238246},{"_id":"themes/vno/source/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1482498872110},{"_id":"themes/vno/source/js/APlayer.min.js","shasum":"5d040dc50af42fec45538a10a7f826e739935278","modified":1482543668791},{"_id":"themes/vno/source/js/insight.js","shasum":"5c5a7ae896ea82682fab0c15405b0880bfa34eca","modified":1482544937012},{"_id":"themes/vno/source/js/main.js","shasum":"43e748aeb132037e27b27d8d1279a4b838d97b38","modified":1482498872118},{"_id":"themes/vno/source/js/embed.js","shasum":"6738e9ee67e520f907e337253beca62c8f0544f7","modified":1482498872118},{"_id":"source/_posts/bzoj-3196/lemon.png","shasum":"e62be8509a73535096deea0debc3c04ca6c39445","modified":1483340682862},{"_id":"themes/vno/source/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1482498872110},{"_id":"themes/vno/source/images/show/google-analytics.jpeg","shasum":"b10396a3162402ea2ff4b42b7b44b518450466e6","modified":1482498872114},{"_id":"themes/vno/source/images/background-cover.jpg","shasum":"0b04e9bf7e89377952702a0be54569596770f49c","modified":1482498872110},{"_id":"themes/vno/source/images/show/article.jpeg","shasum":"1156f794ea83eae2e5fa485ee5bd3b5b314c957a","modified":1482498872114},{"_id":"themes/vno/source/images/show/baidu_tongji.jpeg","shasum":"76ecad909b266c2c557daaff1f65f7e6ec2135d5","modified":1482498872114},{"_id":"source/_posts/virtualbox-archlinux/share.png","shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8","modified":1462955792610},{"_id":"themes/vno/source/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1482498872110},{"_id":"source/_posts/splay-notes-1/splay.png","shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13","modified":1462955792590},{"_id":"themes/vno/source/images/show/list.jpeg","shasum":"a49bee3ced7097084cee0b6cd67c935d3cb086ef","modified":1482498872118},{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426","modified":1462955792600},{"_id":"source/_posts/virtualbox-archlinux/network.png","shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2","modified":1462955792600},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426","modified":1462955792610},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d","modified":1462955792610},{"_id":"source/_posts/here-the-best-sight/2.jpg","shasum":"b557d0ca16ee0595cbd2731d629828e98fd9af7b","modified":1483311790395},{"_id":"themes/vno/source/images/avatar.png","shasum":"c85cb21d1859376a4178d0e5124a441345dd2ebd","modified":1482500250158},{"_id":"source/_posts/here-the-best-sight/3.jpg","shasum":"a00028f85e592bdae7f485279a7bca5c385c394d","modified":1483311812736},{"_id":"source/_posts/here-the-best-sight/1.jpg","shasum":"97aca77cc57d470bae56c2c8199a86af57b1c010","modified":1483311789311},{"_id":"themes/vno/source/images/show/home.png","shasum":"90bd2baeb8dfcfd9542cd689766d2bc88ef95ca1","modified":1482498872118},{"_id":"source/music/mzr/mzr.ogg","shasum":"44bf915b81c4f93e626182f05442af6ff7a95f52","modified":1483160238262},{"_id":"public/js/main.js","modified":1483685905903,"shasum":"43e748aeb132037e27b27d8d1279a4b838d97b38"},{"_id":"public/js/insight.js","modified":1483685905926,"shasum":"5c5a7ae896ea82682fab0c15405b0880bfa34eca"},{"_id":"public/js/embed.js","modified":1483685905930,"shasum":"6738e9ee67e520f907e337253beca62c8f0544f7"},{"_id":"public/js/APlayer.min.js","modified":1483685905932,"shasum":"5d040dc50af42fec45538a10a7f826e739935278"},{"_id":"public/images/show/list.jpeg","modified":1483685905941,"shasum":"a49bee3ced7097084cee0b6cd67c935d3cb086ef"},{"_id":"public/images/show/home.png","modified":1483685905949,"shasum":"90bd2baeb8dfcfd9542cd689766d2bc88ef95ca1"},{"_id":"public/images/show/google-analytics.jpeg","modified":1483685905961,"shasum":"b10396a3162402ea2ff4b42b7b44b518450466e6"},{"_id":"public/images/show/baidu_tongji.jpeg","modified":1483685905969,"shasum":"76ecad909b266c2c557daaff1f65f7e6ec2135d5"},{"_id":"public/images/show/article.jpeg","modified":1483685905979,"shasum":"1156f794ea83eae2e5fa485ee5bd3b5b314c957a"},{"_id":"public/images/background-cover.jpg","modified":1483685905998,"shasum":"0b04e9bf7e89377952702a0be54569596770f49c"},{"_id":"public/images/avatar.png","modified":1483685906011,"shasum":"c85cb21d1859376a4178d0e5124a441345dd2ebd"},{"_id":"public/fonts/fontawesome-webfont.woff","modified":1483685906019,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/fonts/fontawesome-webfont.ttf","modified":1483685906022,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/fonts/fontawesome-webfont.svg","modified":1483685906035,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/fonts/fontawesome-webfont.eot","modified":1483685906038,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/fonts/FontAwesome.otf","modified":1483685906044,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/css/vno.css","modified":1483685906855,"shasum":"7958cc03fd844d7f696c965e57c3ab93e687871d"},{"_id":"public/css/tomorrow.css","modified":1483685907028,"shasum":"5d7e34a8cf77a0e2ec66ce04139da68026fca564"},{"_id":"public/css/search.css","modified":1483685907066,"shasum":"ad0ccc87abd4fccb83275745cc9eff3d8a9fc508"},{"_id":"public/music/mzr/mzr.ogg","modified":1483685907095,"shasum":"44bf915b81c4f93e626182f05442af6ff7a95f52"},{"_id":"public/music/mzr/mzr.lrc","modified":1483685907109,"shasum":"25283ad79892beb5c83c43d981fdd32fbee30466"},{"_id":"public/music/mzr/mzr.jpg","modified":1483685907111,"shasum":"501f497a8efb64ab462205f7e287e6082e31edb1"},{"_id":"public/images/zyz.png","modified":1483685907113,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"public/virtualbox-archlinux/hotkey.png","modified":1483685907115,"shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426"},{"_id":"public/virtualbox-archlinux/network.png","modified":1483685907119,"shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2"},{"_id":"public/virtualbox-archlinux/port.png","modified":1483685907122,"shasum":"bb684dd8b616413e3e0e27c5efce118249a54113"},{"_id":"public/virtualbox-archlinux/screenfetch.png","modified":1483685907147,"shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d"},{"_id":"public/virtualbox-archlinux/share.png","modified":1483685907154,"shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8"},{"_id":"public/virtualbox-archlinux/terminal.png","modified":1483685907157,"shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426"},{"_id":"public/uva-11538/cells.png","modified":1483685907163,"shasum":"3a162829c312a17639950c3620cd70799ed94a49"},{"_id":"public/tree-chain-split-notes/1.svg","modified":1483685907165,"shasum":"0cb9b692551b4a57c404a90123f7de48afb98f9a"},{"_id":"public/splay-notes-1/splay.png","modified":1483685907171,"shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13"},{"_id":"public/sdoi2016-game/line.png","modified":1483685907180,"shasum":"30c24e553938d2c27b55779527825b2577088a7c"},{"_id":"public/sdoi2016-game/tree.png","modified":1483685907182,"shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86"},{"_id":"public/noip2016-running/linear-backward1.svg","modified":1483685907183,"shasum":"f11ad00d6b6d9c4a9dbcdd756a54ac9f98aae87c"},{"_id":"public/noip2016-running/linear-forward1.svg","modified":1483685907186,"shasum":"21d1e9f4c290ba36e95ca3d1a3f03108f7e7d08c"},{"_id":"public/noip2016-running/linear-forward2.svg","modified":1483685907188,"shasum":"d828849ead2a7f7a3ac34250ec3e468dd053fe4c"},{"_id":"public/noi2008-candy/1.svg","modified":1483685907191,"shasum":"487bedd4ee907b6af27bc2dff608d7084da67f46"},{"_id":"public/noi2008-candy/2.ggb","modified":1483685907195,"shasum":"b72de255a5a79e92a5a220da592cc30818579ca7"},{"_id":"public/noi2008-candy/2.svg","modified":1483685907197,"shasum":"84a22ca72f6e0ff90dfce05b56f44e7ab66f3cc9"},{"_id":"public/noi2008-candy/3.ggb","modified":1483685907204,"shasum":"7155350e293077d4fd36bd65715ea693ed339c80"},{"_id":"public/noi2008-candy/3.svg","modified":1483685907207,"shasum":"b23b45b08ec89efce951bb74993a3552785b2fb6"},{"_id":"public/noi2008-candy/4.ggb","modified":1483685907210,"shasum":"0c851a79d13d36a0bc06c1360ec5ca3b48e301a2"},{"_id":"public/noi2008-candy/4.svg","modified":1483685907211,"shasum":"f43da416f15c7ff2e1561e1a3bac7394a9a054fd"},{"_id":"public/noi2008-candy/5.ggb","modified":1483685907212,"shasum":"e80d5ff3511748769937e358ca9f213db78a3adc"},{"_id":"public/noi2008-candy/5.svg","modified":1483685907213,"shasum":"faf0ef012b9602fc7d191eefb46096c6703ed3c3"},{"_id":"public/noi2008-candy/6.ggb","modified":1483685907214,"shasum":"b968f70e6224debb5e16b9ea4a1e39ebc2de4834"},{"_id":"public/noi2008-candy/6.svg","modified":1483685907216,"shasum":"4a8fc6c8636aa2eb311e7c4c87a5a165d7f4ea38"},{"_id":"public/noi2008-candy/7.ggb","modified":1483685907217,"shasum":"fbf0ec7e19ee13b534e9aa66ded3170ec449261e"},{"_id":"public/noi2008-candy/7.svg","modified":1483685907219,"shasum":"249b838061bf13e3da200bd47bb42bd83c594799"},{"_id":"public/node-devide-notes/tree1.svg","modified":1483685907220,"shasum":"4de32d5e3b22eb531886d0f9f475f2a9982ee471"},{"_id":"public/node-devide-notes/tree2.svg","modified":1483685907225,"shasum":"407c61fdd3d63b87c5678d80c9b6213781d2cb1f"},{"_id":"public/manacher-notes/1.svg","modified":1483685907228,"shasum":"689f9a1a16fa6bebbe71921fe95a95791af6d03a"},{"_id":"public/manacher-notes/2.svg","modified":1483685907229,"shasum":"9846f2acbe071d16813087471c83561141070942"},{"_id":"public/manacher-notes/3.svg","modified":1483685907231,"shasum":"2c61c2f78699f473f9c9758f7ed9fe4984ee1b97"},{"_id":"public/here-the-best-sight/1.jpg","modified":1483685907241,"shasum":"97aca77cc57d470bae56c2c8199a86af57b1c010"},{"_id":"public/here-the-best-sight/2.jpg","modified":1483685907251,"shasum":"b557d0ca16ee0595cbd2731d629828e98fd9af7b"},{"_id":"public/here-the-best-sight/3.jpg","modified":1483685907262,"shasum":"a00028f85e592bdae7f485279a7bca5c385c394d"},{"_id":"public/haoi2006-sequence/1.svg","modified":1483685907266,"shasum":"0337ba40ba7e2733cc657b79636f5f06e5f7c9a3"},{"_id":"public/haoi2006-sequence/2.svg","modified":1483685907269,"shasum":"57a7cee258306ed3073e46a9e0e79f6485c8f100"},{"_id":"public/geometry-notes/1.ggb","modified":1483685907271,"shasum":"4e6d9a8a63ed9c440f40708c3d25a8b78eda515d"},{"_id":"public/geometry-notes/1.svg","modified":1483685907281,"shasum":"975b2287b4c1a2f034bd98d93b7676eb974103cc"},{"_id":"public/geometry-notes/2.ggb","modified":1483685907282,"shasum":"661074f4858099ec573c4f9b145331bf3a0220f0"},{"_id":"public/geometry-notes/2.svg","modified":1483685907284,"shasum":"a9e92363b3f901f6ebc2b9ca6316d42c038e0575"},{"_id":"public/geometry-notes/3.ggb","modified":1483685907285,"shasum":"0463664a0f02fc6736b06b234b660eb85e33c9e8"},{"_id":"public/geometry-notes/3.svg","modified":1483685907289,"shasum":"080c446dbf929c29e276207b0665f8a0dfd292ed"},{"_id":"public/geometry-notes/4.ggb","modified":1483685907297,"shasum":"e83654c63399e2af73b4d567a62ab55419c3b1d1"},{"_id":"public/geometry-notes/4.svg","modified":1483685907298,"shasum":"daa7364dd8c0c14481807f25ae5f051f31552a7f"},{"_id":"public/geometry-notes/5.ggb","modified":1483685907299,"shasum":"6c347a3c0dd1ef65cf4671cfefe6c8e4c9ec3c65"},{"_id":"public/geometry-notes/5.svg","modified":1483685907308,"shasum":"5f407ad7db6976704949a6a62783f8c86e304e0c"},{"_id":"public/geometry-notes/6.ggb","modified":1483692227135,"shasum":"4f8d2e7c8949a912625f9d6dfb1e375d6dbda0c9"},{"_id":"public/geometry-notes/6.svg","modified":1483685907315,"shasum":"c90aeef41c91b50d5e65019f0f686a617859af7f"},{"_id":"public/docker-sandbox-judger/image.svg","modified":1483685907317,"shasum":"6636e4b99b06e88091fecbf1f184ead8c7159475"},{"_id":"public/cf-716e/example.svg","modified":1483685907328,"shasum":"a1d6731f2ef7e43ae48e27345954c6cb24a216b0"},{"_id":"public/bzoj-3196/lemon.png","modified":1483685907331,"shasum":"e62be8509a73535096deea0debc3c04ca6c39445"},{"_id":"public/bzoj-2683/cdq.png","modified":1483685907335,"shasum":"a95d0b02b915f092df6656298add0f0fc9662341"},{"_id":"public/at-the-cross-of-time/mzr.lrc","modified":1483685907336,"shasum":"25283ad79892beb5c83c43d981fdd32fbee30466"},{"_id":"public/acam-notes/acam.svg","modified":1483685907338,"shasum":"443fe0f8ed15e6b9ef1aadeadef650b8ff57e031"},{"_id":"public/acam-notes/acam2.svg","modified":1483685907339,"shasum":"02f0702387bd40ee0980ea1da05b2eff5fd05ec8"},{"_id":"public/tags/index.html","modified":1483685907431,"shasum":"410b3ecf410fcc7ffca30836a378b80679730b02"},{"_id":"public/friends/index.html","modified":1483685907454,"shasum":"0540d625163c7f61deee5d60903ba56318da704b"},{"_id":"public/about-me/index.html","modified":1483685907488,"shasum":"868406c808128b3842553d53eab276ed589be081"},{"_id":"public/geometry-notes/index.html","modified":1483692227720,"shasum":"3ffa7f9d68e57efc15ef49c3537477f697cc868f"},{"_id":"public/apio2012-dispatching/index.html","modified":1483692227792,"shasum":"b8425f24d5b747dd276c72dc7ef6daaabdd07b30"},{"_id":"public/manacher-notes/index.html","modified":1483685907752,"shasum":"695c7100f043ceea76a7a8a3f7e76b2c3f84d9e2"},{"_id":"public/bzoj-2565/index.html","modified":1483685907815,"shasum":"ca9ddcade0b1f3a52285690839180fadc71044a1"},{"_id":"public/poj-3630/index.html","modified":1483685907844,"shasum":"2d026ea11f39f93b824d8c3b32ca32c1072e4169"},{"_id":"public/here-the-best-sight/index.html","modified":1483685907893,"shasum":"4b3c55a70bc136c6d95395bb3cd9c82520d640a3"},{"_id":"public/euler-circuit-notes/index.html","modified":1483685907946,"shasum":"d4f44df264e6e8c99eb8cbd75349f472e9a5d8ca"},{"_id":"public/bzoj-1718/index.html","modified":1483685907995,"shasum":"854eede5328136d411efb917b4266a067acaf85f"},{"_id":"public/tarjan-bcc-notes/index.html","modified":1483685908029,"shasum":"0b28c0da25868c992b52935cce58054f6a413edb"},{"_id":"public/the-ever-heart/index.html","modified":1483685908075,"shasum":"6cb16381efb42d52cdaf08668e34d32a0ad293b0"},{"_id":"public/scoi2005-royal/index.html","modified":1483685908115,"shasum":"982161e897c1b5a119b4351881f175f3e2f5e992"},{"_id":"public/ahoi2013-homework/index.html","modified":1483685908170,"shasum":"741a09539f9fe922307f4f3a234d5926496842c7"},{"_id":"public/bzoj-3289/index.html","modified":1483685908224,"shasum":"0fcca4eba15f1e2aafaea8008193266cc3b96731"},{"_id":"public/bzoj-2120/index.html","modified":1483685908274,"shasum":"9604662b888b2951ff70368c93ebde8eeb7de4ac"},{"_id":"public/rmq-template/index.html","modified":1483685908316,"shasum":"6a293f7e1e1e35077d47a901b09deb1542ac22d9"},{"_id":"public/splay-template/index.html","modified":1483685908377,"shasum":"d4aa9d1e9958e9cf2bb5d6f990c1154028b3e3d5"},{"_id":"public/noi2008-candy/index.html","modified":1483685908476,"shasum":"c9c11c93ca13412b115e880f204ca4748f1ce319"},{"_id":"public/docker-sandbox-judger/index.html","modified":1483685908499,"shasum":"dee22cba80deef5266b4e48570273b1c4b8ddf7b"},{"_id":"public/zjoi2007-chess/index.html","modified":1483685908561,"shasum":"408abd5b21865a333db9f788f0ec2ee29a9cb818"},{"_id":"public/haoi2008-rank/index.html","modified":1483685908613,"shasum":"6758c4accf028ed78fd2dcf3a6f1dc6fe6f88975"},{"_id":"public/haoi2008-move/index.html","modified":1483685908665,"shasum":"ba1c2bf85369c8b8253a1f602b83c4d0e362e6cc"},{"_id":"public/haoi2007-ant/index.html","modified":1483685908714,"shasum":"03422b1d629d950adcb264c6db98a21ad6800569"},{"_id":"public/haoi2007-cover/index.html","modified":1483685908759,"shasum":"7386aacc93dbb96abf7f78780f3d6345d2956f9b"},{"_id":"public/haoi2006-sequence/index.html","modified":1483685908834,"shasum":"65512e223619df0bbd490eac3b2504f6b49709db"},{"_id":"public/haoi2007-separation/index.html","modified":1483685908917,"shasum":"a39aab260cf6b767e9e73fee8a86dcad02175896"},{"_id":"public/haoi2007-square/index.html","modified":1483685908976,"shasum":"21dbd3a0659c6be6f2a1d4b5d356b0d2f629a554"},{"_id":"public/haoi2007-lis/index.html","modified":1483685909039,"shasum":"f6fc31b1a91db079fd90ca898005db94ef168f4e"},{"_id":"public/noip2016-angrybirds/index.html","modified":1483685909092,"shasum":"ff75d2de86dc8eff7c3fbd757c8d0210d961d409"},{"_id":"public/noip2016-earthworm/index.html","modified":1483685909150,"shasum":"d75aa75b6c8f0059b63a3d97039d85f9d3a725a7"},{"_id":"public/noip2016-problem/index.html","modified":1483685909201,"shasum":"6f37214a74ce1d16e1cf280a7a163d544db595fc"},{"_id":"public/noip2016-classroom/index.html","modified":1483685909273,"shasum":"fda5186b7ce8f9820d3dacc08bff6c6f5ab9d368"},{"_id":"public/noip2016-running/index.html","modified":1483685909375,"shasum":"3a28034db15237c0c207a0f54983d2d3a807e023"},{"_id":"public/noip2016-toy/index.html","modified":1483685909406,"shasum":"3e616b230e4054ab6672e57dc15234667c282205"},{"_id":"public/noip2016/index.html","modified":1483685909458,"shasum":"7ece4905815519bf7bd65db282416b51311fbbf9"},{"_id":"public/noip2012-blockade/index.html","modified":1483685909530,"shasum":"da97ad615673897e1e01f71fc4a545ebb53ba0ec"},{"_id":"public/noip2010-flow/index.html","modified":1483685909581,"shasum":"731b241c1b8b512d874aa57a75b622f324d6ea9f"},{"_id":"public/noip2012-drive/index.html","modified":1483685909656,"shasum":"8988bb225181c6b51d4a5fe1eae07c25e5a6d4a5"},{"_id":"public/noip2013-puzzle/index.html","modified":1483685909729,"shasum":"9ab0065cdc52942b010110d998033904971aebf4"},{"_id":"public/haoi2008-candy/index.html","modified":1483685909790,"shasum":"c877efdc61b6cb337afe702e2df9df0ebbbab633"},{"_id":"public/haoi2008-stick/index.html","modified":1483685909861,"shasum":"b00d4b9741170eaa1a6e700d796d16c73d58c40c"},{"_id":"public/haoi2008-coins/index.html","modified":1483685909913,"shasum":"f7f76c3c3db28e6a2fc47bcd698ebe16de89319d"},{"_id":"public/haoi2008-cir/index.html","modified":1483685909971,"shasum":"7392ced8b6af84b08ecc3a5faf516b0c7bc315b8"},{"_id":"public/zjoi2008-party/index.html","modified":1483685910004,"shasum":"4c4f8df892c348cab3171245aec3227b025bb748"},{"_id":"public/zjoi2008-bnb/index.html","modified":1483685910047,"shasum":"3e89e11bc1a9fd86bd3942ad6371c8a502d812c6"},{"_id":"public/jsoi2007-repair/index.html","modified":1483685910095,"shasum":"70c124070713dafee1f5d094282dac64c42a3d9c"},{"_id":"public/jsoi2007-mahjong/index.html","modified":1483685910142,"shasum":"9791f5ea69ed2f19ce3093639141801d5de518c2"},{"_id":"public/scoi2009-game/index.html","modified":1483685910201,"shasum":"1b98a6aca871b3d492227bf557fb8d99950bcb12"},{"_id":"public/scoi2009-cake/index.html","modified":1483685910258,"shasum":"397166f34576d41da11b6f68cdd1d02b7c7d5995"},{"_id":"public/shoi2008-cactus/index.html","modified":1483685910321,"shasum":"02ff778f519962728ed828c9f9d1db46a15b9941"},{"_id":"public/ioi2008-island/index.html","modified":1483685910418,"shasum":"6ed50adb26a69e14a369342a398f875af57d2e14"},{"_id":"public/noip2015-transport/index.html","modified":1483685910487,"shasum":"23d8c5a39141a34e5f6d5ef8ee588e145ad99cba"},{"_id":"public/noip2015-substring/index.html","modified":1483685910535,"shasum":"27186de46e75a0370338c692ab39ca99a30f1792"},{"_id":"public/noip2015-landlords/index.html","modified":1483685910611,"shasum":"7ca1178ddb8ec7bea6a7a2946b331a95bca8e15e"},{"_id":"public/noip2014-equation/index.html","modified":1483685910669,"shasum":"821162e63092de24136885ffb323edb064ca6933"},{"_id":"public/shoi2008-john/index.html","modified":1483685910713,"shasum":"e572b6862ae091b5cd3d20694db70250cb95a11e"},{"_id":"public/shoi2008-debt/index.html","modified":1483685910777,"shasum":"0dfdcd74c54c71ed18fc4816aa494c335bd05863"},{"_id":"public/shoi2008-hannoi/index.html","modified":1483685910838,"shasum":"e26d8ffbc2697b75c458dce4737d52bd951a13ab"},{"_id":"public/shoi2008-traffic/index.html","modified":1483685910900,"shasum":"311050117846dc94585bbafdae963465e95eab1d"},{"_id":"public/jsoi2008-award/index.html","modified":1483685910980,"shasum":"e839a59dc384be93329620f08e27634eecabdbbd"},{"_id":"public/jsoi2008-starwar/index.html","modified":1483685911028,"shasum":"7c785540d04bbabddc8bd8bc75ee9849f2474a64"},{"_id":"public/jsoi2008-prefix/index.html","modified":1483685911088,"shasum":"3453943359bfe9cd84daff7b617705eedd3211ec"},{"_id":"public/hnoi2008-kingdom/index.html","modified":1483685911127,"shasum":"fd14385fd5eb21cdf748bf1fae48afc27db751f2"},{"_id":"public/hnoi2008-cards/index.html","modified":1483685911175,"shasum":"da7d42bf823cdcfb4ed6989dc16f151761efdb11"},{"_id":"public/fjoi2007-wheel/index.html","modified":1483685911229,"shasum":"5a9e88d739f97d287b79f5585a92725698375922"},{"_id":"public/noip2013-flower/index.html","modified":1483685911276,"shasum":"b6471ecaa64a946ebb8aabecb18330eb313dae21"},{"_id":"public/noip2013-match/index.html","modified":1483685911333,"shasum":"669dbfec3d748ea2bb1c5204f3336e7765492383"},{"_id":"public/hnoi2008-tree/index.html","modified":1483685911386,"shasum":"a48cb814ffa31d3d2f2e4c0167e357b6e21d9185"},{"_id":"public/noip2014-bird/index.html","modified":1483685911460,"shasum":"510956965dd852543ab4b720f2e7e90c1c80e917"},{"_id":"public/noip2012-classrooms/index.html","modified":1483685911515,"shasum":"e1427f64e0b394aac304a08385e087051823e710"},{"_id":"public/tjoi2015-chessboard/index.html","modified":1483685911576,"shasum":"1c6f0509020dc8ccb84464d915ca8d768d9ad79b"},{"_id":"public/noi2012-random/index.html","modified":1483685911623,"shasum":"d5d9a2eef40b72e4691c0ebfda69177af357298a"},{"_id":"public/bzoj-1706/index.html","modified":1483685911678,"shasum":"f2bbbd17d958906b943664e71b90043dc9d895af"},{"_id":"public/zjoi2004-swamp/index.html","modified":1483685911734,"shasum":"e07a850f405d1bc23acaf04a4b0695937d5848ca"},{"_id":"public/hnoi2008-gt/index.html","modified":1483685911776,"shasum":"6b4d8919954962838f28f3a8a46e2e4527a6d5b0"},{"_id":"public/hdu-5906/index.html","modified":1483685911860,"shasum":"344cf7bdf2f4660673324af8eba2c398d077d98c"},{"_id":"public/bzoj-3796/index.html","modified":1483685911950,"shasum":"23645533c048c4befa83a0d3f6cdc15328c17c93"},{"_id":"public/bzoj-3277/index.html","modified":1483685912027,"shasum":"4bfbb79d8cafad29f08896211dbf35789968bf14"},{"_id":"public/bzoj-3230/index.html","modified":1483685912095,"shasum":"b2346aa764307adbcaa24cc2603b19d6f9870ba9"},{"_id":"public/bzoj-1692/index.html","modified":1483685912159,"shasum":"b6a180c27a1c13ca59113ce06bab97792e8e7a71"},{"_id":"public/scoi2012-name/index.html","modified":1483685912224,"shasum":"61eea3e4a4172c28877e34b674f677f2da4ee7cf"},{"_id":"public/ahoi2013-diff/index.html","modified":1483685912286,"shasum":"68d05a1e943963089f870ee16754b77ca92a0c13"},{"_id":"public/jsoi2007-cipher/index.html","modified":1483685912340,"shasum":"3962779e8401057b1607ea2aa9d1ff3536be76b9"},{"_id":"public/cf-716e/index.html","modified":1483685912403,"shasum":"9fe375e3769864017c19f7cab3a850dde49a5aa9"},{"_id":"public/acam-notes/index.html","modified":1483685912475,"shasum":"7aad9f8cffcd49fde6659cda1638a5ede9800956"},{"_id":"public/jsoi2009-game2/index.html","modified":1483685912560,"shasum":"4c38f3157cfcfb0251bfb3ae792a42c551501ae5"},{"_id":"public/bzoj-3881/index.html","modified":1483685912622,"shasum":"da8bc96479702f0942761a8a82e95b55d64a0f96"},{"_id":"public/bzoj-2580/index.html","modified":1483685912684,"shasum":"35fee2ce2ed10b1ce628f70474a5f4cb69307072"},{"_id":"public/bzoj-3940/index.html","modified":1483685912728,"shasum":"e743095619a3c5a42b4130812b5b973707433b08"},{"_id":"public/bzoj-2462/index.html","modified":1483685912785,"shasum":"56f9f57d3dc333af2aa936391fbed43db0ef7517"},{"_id":"public/poi2000-wir/index.html","modified":1483685912832,"shasum":"360831de33dfe9dd93e37a63aa19e23603e511a7"},{"_id":"public/hnoi2004-language/index.html","modified":1483685912882,"shasum":"058bfd7bb6d4b46bfb56d52de687ffb5399f3bfd"},{"_id":"public/noi2011-type/index.html","modified":1483685912942,"shasum":"f825d8e8c9c443fb1cc77b961d9acf72fb623c88"},{"_id":"public/jsoi2007-generator/index.html","modified":1483685913013,"shasum":"27f42fe7ee59e6ad0572ee8d9bd7938a41c5af43"},{"_id":"public/tjoi2013-word/index.html","modified":1483685913066,"shasum":"f0486330abf5cd70b46d0183a571be48bd8eeb28"},{"_id":"public/tarjan-cut-notes/index.html","modified":1483685913135,"shasum":"883c7ec67954462db84d0c98490ac63ea24f517b"},{"_id":"public/noi2016-grid/index.html","modified":1483685913215,"shasum":"802085464f26b9c300180e04ea4fb27f7ebf04b7"},{"_id":"public/poi2008-blo/index.html","modified":1483685913279,"shasum":"dfef5d98a7b6d23a87573c641f71290bea68e39b"},{"_id":"public/hnoi2012-mine/index.html","modified":1483685913333,"shasum":"bcade75ca60c06276d47f05e11d2e950a2f05512"},{"_id":"public/noi2016-excellent/index.html","modified":1483685913391,"shasum":"657b57eb3b8b3b4074831dcc82b5f5f9b515208f"},{"_id":"public/noi2016-interval/index.html","modified":1483685913444,"shasum":"4fc06624ff43cb889160b0479762a72d9dcb2696"},{"_id":"public/sdoi2013-rforest/index.html","modified":1483685913521,"shasum":"85a90ba531c861e1237b2571bec1f3db1cd9ea8e"},{"_id":"public/zjoi2007-semi/index.html","modified":1483685913605,"shasum":"f077564aaa0dd862a317d113868142e8ff85c5cf"},{"_id":"public/bzoj-3280/index.html","modified":1483685913662,"shasum":"b133c4c1ef181ec6facf31287a3b29b815fb8146"},{"_id":"public/scoi2007-lizard/index.html","modified":1483685913724,"shasum":"fbcad42dc155796064921d60c20fb937373a26f2"},{"_id":"public/sdoi2014-journey/index.html","modified":1483685913786,"shasum":"0a13a6f1ea43cbe3cb32898de9e085682bd3233a"},{"_id":"public/sdoi2008-interval/index.html","modified":1483685913839,"shasum":"0c1d7e5354fbef0af865854b353b5fedad82c70c"},{"_id":"public/at-the-cross-of-time/index.html","modified":1483685913893,"shasum":"9091cd6b0dae37ffdcd3b8e699c07a29f7ee1cb5"},{"_id":"public/noi2014-forest/index.html","modified":1483685913954,"shasum":"109c812a527dedab7545f35d12d21b9e1f6bb718"},{"_id":"public/noi2014-zoo/index.html","modified":1483685913996,"shasum":"0a07715c26080065bdddf1a11a17bcf9cc16f095"},{"_id":"public/bzoj-4145/index.html","modified":1483685914039,"shasum":"c9c44a2acbafd770ec0f67c1a2426e354db2e693"},{"_id":"public/bzoj-4247/index.html","modified":1483685914089,"shasum":"e624973e2c093ef9563410ef746efcdf102b5fd4"},{"_id":"public/jsoi2008-dotr/index.html","modified":1483685914150,"shasum":"858014b5062702a934e292cd6b844943504e31d1"},{"_id":"public/heoi2013-bag/index.html","modified":1483685914200,"shasum":"72452eb8c0171a2eb421d693d21618bde15b2546"},{"_id":"public/scoi2009-paint/index.html","modified":1483685914235,"shasum":"55d239cf64335f5593ea3acdfdc377420e34415d"},{"_id":"public/bzoj-1334/index.html","modified":1483685914277,"shasum":"c0f07df9482c94ec5e8ed6a0b8048692406ed801"},{"_id":"public/hnoi2010-chorus/index.html","modified":1483685914335,"shasum":"23cf92ad01a43ce80a24a1379bc10e9b4d3697b9"},{"_id":"public/scoi2003-fold/index.html","modified":1483685914376,"shasum":"159b3a958ad2049943dad8df0f7ff66472fa2548"},{"_id":"public/haoi2008-name/index.html","modified":1483685914421,"shasum":"525ea45247a8686f68f0c3ad81dbbbd10dc6fb79"},{"_id":"public/noi2015-dinner/index.html","modified":1483685914490,"shasum":"b263717a89a96ab772bdfdae31586d6a4e5a5de7"},{"_id":"public/noi2015-epic/index.html","modified":1483685914540,"shasum":"3b1df4ebd4b3944d20c7d71e665bc889dc6355dc"},{"_id":"public/noi2015-farm/index.html","modified":1483685914677,"shasum":"6c62137de0b70e6e22275a82998430da05a998c0"},{"_id":"public/noi2015-savour/index.html","modified":1483685914758,"shasum":"6ffa7e7cbe6ebb2ba41f6f7dcfbcac03739455ff"},{"_id":"public/bzoj-2438/index.html","modified":1483685914806,"shasum":"bd531cc4ccfe7cc6b9e3e799120e0d1c36860fb2"},{"_id":"public/bzoj-2716/index.html","modified":1483685914867,"shasum":"11c261802db2ffd3d5b33b5891155535da3b25a7"},{"_id":"public/shoi2007-tree/index.html","modified":1483685914909,"shasum":"7f167e9499f9f28debd855fd224db3a57d2c3042"},{"_id":"public/zjoi2009-ws/index.html","modified":1483685914964,"shasum":"faa24cbd4de0ddfbc4b2db7b956e56d5c479a03e"},{"_id":"public/bzoj-2132/index.html","modified":1483685915019,"shasum":"89e9b691ceed208356e36b9e14327afd4d20342e"},{"_id":"public/poi2005-kos/index.html","modified":1483685915074,"shasum":"0ae67510404b91f4a6af64ae9f7a5148feec8fa9"},{"_id":"public/poi2006-szk/index.html","modified":1483685915137,"shasum":"f1c8bcef3d0cc1c14dc4212bc230dde0b7c8bf87"},{"_id":"public/bzoj-1585/index.html","modified":1483685915209,"shasum":"2300926f1baf30cef859e7802a4da767ef491f45"},{"_id":"public/ceoi2008-order/index.html","modified":1483685915260,"shasum":"4c6d70f193530915d0f98300752764f9ca01964b"},{"_id":"public/bzoj-1711/index.html","modified":1483685915315,"shasum":"b948ab2e0afe6f971a06927773e7437f1c03d677"},{"_id":"public/sdoi2009-run/index.html","modified":1483685915364,"shasum":"4592810d0c1cc1b92d3092d300a0042aa723d18d"},{"_id":"public/bzoj-3894/index.html","modified":1483685915425,"shasum":"6a976e587873a4f770e897096e9e816c002b8ae5"},{"_id":"public/bzoj-2127/index.html","modified":1483685915485,"shasum":"bbf7a9adf63af6dfdae2260fbdacaee4b8e762ae"},{"_id":"public/bzoj-3438/index.html","modified":1483685915558,"shasum":"cd8fda3ceb01b596c2e4984dbf1107774cece3b1"},{"_id":"public/shoi2007-vote/index.html","modified":1483685915613,"shasum":"5b8bda00befd435db8686fa6f7bc6017bb47b8ff"},{"_id":"public/zjoi2010-network/index.html","modified":1483685915675,"shasum":"c4009ea95c0a287715b1e5051eaa0d670f6b8da9"},{"_id":"public/cqoi2011-inverse/index.html","modified":1483685915732,"shasum":"3dd8720aa2089ed898f0281827350418324047dc"},{"_id":"public/bzoj-1176/index.html","modified":1483685915789,"shasum":"fd2d282f105ab68c75a0fc3e6fb431cfb2c2e3d2"},{"_id":"public/sdoi2010-goblin/index.html","modified":1483685915838,"shasum":"dc9e64153470fa8006a4cedbe7b0279fb545aad1"},{"_id":"public/bzoj-3262/index.html","modified":1483685915896,"shasum":"9b8a2990ef8a013a1dbec32d3da5ce164714d837"},{"_id":"public/bzoj-3196/index.html","modified":1483685916005,"shasum":"cde4e7815a852c695352967f4a46aeddf71a32eb"},{"_id":"public/bzoj-2456/index.html","modified":1483685916050,"shasum":"546f6aa448e8ce3bf9180be002913caee106e983"},{"_id":"public/fft-to-ntt/index.html","modified":1483685916137,"shasum":"3cbc79e6c8def9f2c06597e89679d8acbd8c8608"},{"_id":"public/node-devide-notes/index.html","modified":1483685916203,"shasum":"f0ce788cd3b51b274e14d76f6af8273c1ea2efae"},{"_id":"public/ioi2011-race/index.html","modified":1483685916263,"shasum":"b7fac89903d87f994fa6d33d69dd864f43283368"},{"_id":"public/bzoj-3365/index.html","modified":1483685916317,"shasum":"78e9a5bdade5642ff159f345cf8ea77edb4f0219"},{"_id":"public/bzoj-3697/index.html","modified":1483685916375,"shasum":"ef974dd262dc7d3a77a55ece4792d82a82a09129"},{"_id":"public/bzoj-2152/index.html","modified":1483685916442,"shasum":"3e798bc47c1c5a82289efaf24169aff785e97bb8"},{"_id":"public/bzoj-1468/index.html","modified":1483685916498,"shasum":"938e2ec73034f8004ad73aa3602600f1413f220c"},{"_id":"public/sdoi2011-calc/index.html","modified":1483685916552,"shasum":"442ceb07d5040ac44dc72d4e287262dd11e2b3e1"},{"_id":"public/bsgs-notes/index.html","modified":1483685916621,"shasum":"00943eab5ce4e2e5d9883e463ab83b08aa1d3772"},{"_id":"public/sdoi2015-sequence/index.html","modified":1483685916700,"shasum":"3b72fd425a451b9a0a23c1d40b90eb441de467e1"},{"_id":"public/zjoi2014-force/index.html","modified":1483685916781,"shasum":"9cb4ab20697a481a2fe2b3a4d1f430808ae1bd11"},{"_id":"public/bzoj-2194/index.html","modified":1483685916839,"shasum":"13f57b0b170f081f868b55fe3a8ac770148657a1"},{"_id":"public/fft-notes/index.html","modified":1483685917003,"shasum":"40918ddfc95a6286efaeb7534da8804858601ae9"},{"_id":"public/uva-11021/index.html","modified":1483685917058,"shasum":"936c71ded1fc5233d5646feec9d69cd4dccb66fe"},{"_id":"public/bzoj-4318/index.html","modified":1483685917106,"shasum":"d3d658c3784c04535a220395cdfb2509e79ff667"},{"_id":"public/20160527-array/index.html","modified":1483685917164,"shasum":"09dc5303544bc0ee1c8bec67fd907c26850c9aa1"},{"_id":"public/bzoj-3275/index.html","modified":1483685917226,"shasum":"5f74e83bf7f5c953e769a82bab5729a18c79c971"},{"_id":"public/zjoi2006-trans/index.html","modified":1483685917281,"shasum":"d99ac6e826bb7a2c8c2a959113aa7ea5a08fec96"},{"_id":"public/zjoi2008-antbuster/index.html","modified":1483685917356,"shasum":"2bc76817d4c127a3e487cac4e774b9f1bafeed7f"},{"_id":"public/bzoj-3156/index.html","modified":1483685917419,"shasum":"ffd8f851d1ab154068b02e653616049eb2a346a0"},{"_id":"public/ceoi2004-two/index.html","modified":1483685917460,"shasum":"44a51deaf287517c8029bb3c8c5ff03c3cb02aab"},{"_id":"public/bzoj-1597/index.html","modified":1483685917523,"shasum":"bba0d88a7f6040fbb78ef1fc4ff9dd283e18158d"},{"_id":"public/zjoi2007-storage/index.html","modified":1483685917584,"shasum":"e35cd2655626931e29a5845a54a189dbc8cf74be"},{"_id":"public/apio2010-commando/index.html","modified":1483685917652,"shasum":"bd65669101a13987511df68e780b4b64949bbbb7"},{"_id":"public/hdu-5632/index.html","modified":1483685917704,"shasum":"8e1df5bf9331e79a0d95df9dbb0aa37e1bb7e43f"},{"_id":"public/scoi2009-windy/index.html","modified":1483685917762,"shasum":"414075638b67d6aabb60a773a87d315b68c33a85"},{"_id":"public/cf-628d/index.html","modified":1483685917835,"shasum":"d17f47932421d04679d3a82c03b7152a0efc963d"},{"_id":"public/hdu-2089/index.html","modified":1483685917884,"shasum":"5f7a03460c6c653ee11a31b398d04d600439e70b"},{"_id":"public/hdu-5642/index.html","modified":1483685917945,"shasum":"6a4e7e3ea4bbc6c1e2bb083d2c7f6bd1d9e5cd84"},{"_id":"public/chairman-tree-notes/index.html","modified":1483685918013,"shasum":"cf2288639633fdb37b520ea473c9359ee10d8e7a"},{"_id":"public/hnoi2016-tree/index.html","modified":1483685918102,"shasum":"f125b655df31894a7cca1c295f02b0331701a4b7"},{"_id":"public/hnoi2016-network/index.html","modified":1483685918188,"shasum":"42e47df7d588d62b758a442494a918d75221e7a1"},{"_id":"public/hnoi2016-multiple/index.html","modified":1483685918260,"shasum":"869522c782d167aa68a30fd225fbdfd22066dfc4"},{"_id":"public/ctsc-apio-2016/index.html","modified":1483685918303,"shasum":"6468d15d5df43d54e25182e0ad58493955b8eb72"},{"_id":"public/mo-algorithm-notes/index.html","modified":1483685918369,"shasum":"0bde484291252493e73461e708892d41431ca0c1"},{"_id":"public/hnoi2016-sequence/index.html","modified":1483685918481,"shasum":"fd678751feaf14511a9aaae14aee9588fe20c8fb"},{"_id":"public/haoi2016-chain/index.html","modified":1483685918537,"shasum":"d1106b0437251ddae511696abf02ae730500cb4e"},{"_id":"public/jsoi2009-game/index.html","modified":1483685918634,"shasum":"aec091d85ad8b5ebafffaa3f1d9d373bb8125b90"},{"_id":"public/hnoi2008-toy/index.html","modified":1483685918711,"shasum":"388433cb1203b0de5a12286286ae8769fb75d22a"},{"_id":"public/jsoi2016-flight/index.html","modified":1483685918803,"shasum":"d867689ba8ffe115f64dc02ae8b86a3914d5c670"},{"_id":"public/cqoi2016-number/index.html","modified":1483685918883,"shasum":"844b7a0e7515243c9d4f8523391c07336c269306"},{"_id":"public/cqoi2016-cuts/index.html","modified":1483685918972,"shasum":"bbf187091128be2d9213b83b803a89150e54efd5"},{"_id":"public/jsoi2016-light/index.html","modified":1483685919050,"shasum":"ca7fe55c4689aaaa901aa71a7f8d171603fb5cdd"},{"_id":"public/sdoi2016-table/index.html","modified":1483685919180,"shasum":"bfcff2f330ec7cd80ddaf7393a0d36256f227095"},{"_id":"public/sdoi2016-journey/index.html","modified":1483685919272,"shasum":"696dfa581e5162b907851cf9f7d319f809fb6a91"},{"_id":"public/sdoi2016-game/index.html","modified":1483685919425,"shasum":"200ce15f2a2cc5e2b538a4ccbce5214cc03a92d2"},{"_id":"public/derangement-number/index.html","modified":1483685919476,"shasum":"d80928d0c80627cfec2f1f1cf1a8a7b72bdbca7b"},{"_id":"public/mul-inverse/index.html","modified":1483685919597,"shasum":"a737cae832c239a8b32ba6eb6e326d6c454c529b"},{"_id":"public/sdoi2016-permutation/index.html","modified":1483685919661,"shasum":"9ad821723552105723d608f294961c9f7c75c15b"},{"_id":"public/sdoi2016-incantation/index.html","modified":1483685919728,"shasum":"2bbb5199db0fa5db5f861498cc2ac9617a025d3d"},{"_id":"public/spoj-694/index.html","modified":1483685919777,"shasum":"8e875d53a77c7bb16270e564f656621f51290e2e"},{"_id":"public/suffix-array-notes/index.html","modified":1483685919877,"shasum":"9ab22ce4107406e57ed2e83765c9438b148df9ca"},{"_id":"public/sdoi2016-round1/index.html","modified":1483685919912,"shasum":"f347c98f65f630d200d17e848beccd34c3a1d8dd"},{"_id":"public/poj-3461/index.html","modified":1483685919982,"shasum":"0de2560e06798a269f62b96ef5b8be0f5ba60b34"},{"_id":"public/sdoi2016-pair/index.html","modified":1483685920063,"shasum":"e739ac2e84da992d83c66ab9ab3f725c9c79524a"},{"_id":"public/bzoj-4403/index.html","modified":1483685920108,"shasum":"f182748116e91c727091cb2792523bdd85ae5c39"},{"_id":"public/ahoi2014-story/index.html","modified":1483685920166,"shasum":"141b409ff05a6b1e998954dbefe5df0a6c3a72e9"},{"_id":"public/non-recursion-dfs-with-stack/index.html","modified":1483685920215,"shasum":"3d5bb871a2430c6a4e43a5ee63d0fc182f3fb225"},{"_id":"public/euler-sieve/index.html","modified":1483685920287,"shasum":"a67c5962b34335a25f1899e41fa5d1cff33977c1"},{"_id":"public/haoi2011-problemb/index.html","modified":1483685920351,"shasum":"32f7f38696939cee8a84483ece5a015a392b2d9a"},{"_id":"public/bzoj-2820/index.html","modified":1483685920425,"shasum":"37d92135414a3728498b1ffd63259709631efa27"},{"_id":"public/bzoj-3511/index.html","modified":1483685920493,"shasum":"35c03fecbafe21273b4a04a02f1bc87a8fc217b7"},{"_id":"public/bzoj-1008/index.html","modified":1483685920532,"shasum":"4893d28979ca1bb65c00f5880037e4a51a2b2e5a"},{"_id":"public/20160404-theory/index.html","modified":1483685920618,"shasum":"678cf411fd557218f5a96f725dde89881ac9714f"},{"_id":"public/tjoi2013-lis/index.html","modified":1483685920667,"shasum":"5734c30d5b914a944110dc1accf6260fddd7d0bb"},{"_id":"public/bzoj-1001/index.html","modified":1483685920726,"shasum":"91bad0eaa01ae8ba50b9b912d7103b5c3ef41f2e"},{"_id":"public/noi2014-sleep/index.html","modified":1483685920771,"shasum":"eaa64f14c0b38b9c21d1c2a89ae91275f1bf5aae"},{"_id":"public/haoi2015-t2/index.html","modified":1483685920830,"shasum":"d7da5f1845d0d3c821bd446aaf00b4da54e0c4b3"},{"_id":"public/bzoj-2296/index.html","modified":1483685920863,"shasum":"91f71bc21effde1c3c62acb17f505994ce6ed91d"},{"_id":"public/bzoj-2038/index.html","modified":1483685920928,"shasum":"164e631a574b24dc5d90a79b73f93c0b49d89ff7"},{"_id":"public/20160331-naive/index.html","modified":1483685920991,"shasum":"ae132b0590223beb8582b81f6349f7b27eb6ec5f"},{"_id":"public/scoi2015-password/index.html","modified":1483685921059,"shasum":"dfe498484e4a4223b96d0cb79833b488aaacff09"},{"_id":"public/scoi2015-light/index.html","modified":1483685921124,"shasum":"ef0d8131f80d397a4a00449be392a45f5b625f0a"},{"_id":"public/bzoj-2143/index.html","modified":1483685921185,"shasum":"c1d4278c59b9bf787aecb9a0aa3717a1cd36200d"},{"_id":"public/scoi2015-flag/index.html","modified":1483685921240,"shasum":"3924bb4756eff80efe003c50b688ae018c701090"},{"_id":"public/scoi2015-message/index.html","modified":1483685921300,"shasum":"9c898792a34a8246feba93ecaa815bd831734fd0"},{"_id":"public/scoi2015-matrix/index.html","modified":1483685921351,"shasum":"ef9196f3d30dde48770a4bd03e5a860e4a89809f"},{"_id":"public/20160318-color/index.html","modified":1483685921420,"shasum":"813baffc75ecf4b84b5d94dc2ced53ec7f3ebc9b"},{"_id":"public/20160319-candy/index.html","modified":1483685921467,"shasum":"d4ed9bf0e0f5188184988b22088a9ebece606226"},{"_id":"public/20160319-set/index.html","modified":1483685921536,"shasum":"6a112490854b99aa54dbeddc0cbc4d194cc60d39"},{"_id":"public/sdoi2008-cave/index.html","modified":1483685921581,"shasum":"96c7aad0a59694eddc9314fd20ab3c0f6093d1db"},{"_id":"public/combinatorics-notes/index.html","modified":1483685921652,"shasum":"e4a7f1769d1251b04af2605585bc1f131e7fcecc"},{"_id":"public/uva-10253/index.html","modified":1483685921693,"shasum":"23e73adc469faf0a96a163b79be2ec59498a1ad0"},{"_id":"public/uva-11361/index.html","modified":1483685921755,"shasum":"cb70110f8d5b2b9da65acb610fc11fe5991f099d"},{"_id":"public/bigint-template/index.html","modified":1483685921800,"shasum":"4ffed62f67be074489bd227b597214bdc1e2d447"},{"_id":"public/uva-1362/index.html","modified":1483685921840,"shasum":"f9e9663d1d8d66cfc00efd9865e74f756d95f2b8"},{"_id":"public/poj-1737/index.html","modified":1483685921904,"shasum":"c76200acd4ca77df75096ebd5b00bf1399645b42"},{"_id":"public/uva-11174/index.html","modified":1483685921950,"shasum":"2917062136de17541273325be8861093fd199b4c"},{"_id":"public/uva-11137/index.html","modified":1483685921998,"shasum":"55bb702ebb08ecfe21a5c3fe21333dfd1507f14b"},{"_id":"public/uva-11375/index.html","modified":1483685922040,"shasum":"f3ca5b41cd1c036fbef8100e7b2f11e48b9f2cad"},{"_id":"public/uva-11538/index.html","modified":1483685922101,"shasum":"58a4553eff7993cec63e484bae59307bc6134fc2"},{"_id":"public/uva-11806/index.html","modified":1483685922149,"shasum":"124b001d7200c1c66fea03d47b0993f69227d229"},{"_id":"public/poj-2728/index.html","modified":1483685922198,"shasum":"d8b1e527de1a7c2d0120c1adf20906926ab36978"},{"_id":"public/apio2009-atm/index.html","modified":1483685922258,"shasum":"a118ac52e0cb47b08fd234cab713553159894645"},{"_id":"public/noi2006-profit/index.html","modified":1483685922312,"shasum":"2ed44578252a5df75242dbceede2376f2a086b44"},{"_id":"public/scoi2007-repair/index.html","modified":1483685922373,"shasum":"2dfb6c2f7b6d86bd5b89039f96963dc7acdbc69a"},{"_id":"public/ahoi2008-meet/index.html","modified":1483685922428,"shasum":"11b25cde51425577a4cbe80a5fe6f5fb7790a531"},{"_id":"public/scoi2010-game/index.html","modified":1483685922479,"shasum":"8dbd46bdc618cf17c9cb34802857cc75b9d00986"},{"_id":"public/virtualbox-archlinux/index.html","modified":1483685922508,"shasum":"62c9af694c37c7a8922ee515d5c4f554eab6dbcc"},{"_id":"public/noi2003-editor/index.html","modified":1483685922596,"shasum":"4b7ed7cb98354a1a512d01444b0d1cc35422d73c"},{"_id":"public/scoi2011-candy/index.html","modified":1483685922652,"shasum":"2d68397b1fb21b1f0266068851387b0143dc9b27"},{"_id":"public/haoi2006-cow/index.html","modified":1483685922704,"shasum":"535e4e63b3c270804185b98c5bc639aa9f1b1195"},{"_id":"public/codevs-2822/index.html","modified":1483685922749,"shasum":"c1e2ee7ecfde006a9477468afb89e4edf8b760d8"},{"_id":"public/tarjan-scc-notes/index.html","modified":1483685922815,"shasum":"1c92cae4765503d201cf2da6fcc980f28add76c0"},{"_id":"public/sdoi2010-starrace/index.html","modified":1483685922868,"shasum":"7067973c3c3164263a555e82f9f04b5c0eb89744"},{"_id":"public/sdoi2015-war/index.html","modified":1483685922924,"shasum":"d143d184cbefab21a07a565e4a05f5c38672ecc1"},{"_id":"public/cogs-741/index.html","modified":1483685922974,"shasum":"4e462a8d46acf30d2eba79524bdff53001246d86"},{"_id":"public/cogs-740/index.html","modified":1483685923028,"shasum":"58d12a5a6f8b747604c125bc0247612629311b7b"},{"_id":"public/ctsc1999-home/index.html","modified":1483685923073,"shasum":"7847dbff9fccf1dbafc4f489f807f8b95aa14d5a"},{"_id":"public/cogs-742/index.html","modified":1483685923133,"shasum":"2ec28349a095e3d6427849d6da669e6b51e31ebb"},{"_id":"public/cogs-739/index.html","modified":1483685923183,"shasum":"49d6fe3f18d37bfe467b60f714ed274050990114"},{"_id":"public/jsoi2008-maxnumber/index.html","modified":1483685923231,"shasum":"bc89b7c40afd2a4c1a64d39dfadc1cdb6d6c5f6e"},{"_id":"public/edmonds-karp-notes/index.html","modified":1483685923282,"shasum":"d643e07ae3b0fc5498c1d5d39a5ee4f1c3a425c7"},{"_id":"public/noip2010-prison/index.html","modified":1483685923325,"shasum":"b53efc325b64cd404dbbd04921bc0c100c706a42"},{"_id":"public/cogs-746/index.html","modified":1483685923378,"shasum":"14180f365d70262f611ca2accecef4b08685292c"},{"_id":"public/cogs-738/index.html","modified":1483685923433,"shasum":"140053547f98d2d4737566a582a0ebaf9e26689a"},{"_id":"public/cogs-734/index.html","modified":1483685923485,"shasum":"1963c29efe5c58d65f3128bd823cda0855a89039"},{"_id":"public/cogs-439/index.html","modified":1483685923532,"shasum":"c5f208b1e2e8c9e03e6b1c20960edc1e3c756bc4"},{"_id":"public/cogs-727/index.html","modified":1483685923596,"shasum":"d2d7420f27cd01a58b13b9a9cb87f253c82f18bc"},{"_id":"public/cogs-731/index.html","modified":1483685923658,"shasum":"41dd07e6faf29435671a81791e4ee42812b85946"},{"_id":"public/cogs-729/index.html","modified":1483685923709,"shasum":"63ab68028c211526f2376c35869a9169dcba0507"},{"_id":"public/cogs-396/index.html","modified":1483685923736,"shasum":"e8e4a94675ca392a66b57337e6cbf8172d517577"},{"_id":"public/cogs-728/index.html","modified":1483685923784,"shasum":"8c8aaee154217d9b8176a307eedd97b58e9a379a"},{"_id":"public/cogs-14/index.html","modified":1483685923840,"shasum":"c8071dc7daa839c06e7533a8a9b47949692d0fd9"},{"_id":"public/bzoj-2683/index.html","modified":1483685923888,"shasum":"0ef3a4e613af067b48c32df77796608fe653bdf2"},{"_id":"public/codevs-1563/index.html","modified":1483685923925,"shasum":"98bc64a3922b9f556dc2107321e188c6a8df452d"},{"_id":"public/gnu-debugger/index.html","modified":1483685923976,"shasum":"4cd024be756c5bb5d0eb899de78de2f952a39019"},{"_id":"public/dinic-notes/index.html","modified":1483685924018,"shasum":"8057b8669fe195079661db84354d059ca93c3040"},{"_id":"public/bzoj-1756/index.html","modified":1483685924074,"shasum":"adfd8486233e2a645799a9667f7bc527634e67f2"},{"_id":"public/noi2004-cashier/index.html","modified":1483685924128,"shasum":"b639f98b3224eb67e9e0c46bb91497268e5ed58f"},{"_id":"public/bzoj-1477/index.html","modified":1483685924190,"shasum":"dacc9cd3c070b0af0b13cf7dccfcfc83b26bfd43"},{"_id":"public/noi2015-manager/index.html","modified":1483685924245,"shasum":"992649ce8ac57e90613a95d5cf088afdf8e70419"},{"_id":"public/noi2015-prog/index.html","modified":1483685924299,"shasum":"78fa8ebcc31fe993a23e2e2536258597bf673ab9"},{"_id":"public/number-theory-notes-1/index.html","modified":1483685924363,"shasum":"de36553a9a2d9d4db6df63f9e13362cf5f579f1a"},{"_id":"public/noip2012-mod/index.html","modified":1483685924411,"shasum":"234458098cf4afcd4a35b98b183598fa0c2601fe"},{"_id":"public/link-cut-tree-notes/index.html","modified":1483685924465,"shasum":"1116d6500a7e419ab15f1901fe801478fbc38570"},{"_id":"public/splay-notes-3/index.html","modified":1483685924537,"shasum":"fe5a46a24ea07cd3f95974776b1f8f0c6afee736"},{"_id":"public/bzoj-1251/index.html","modified":1483685924594,"shasum":"b73379f078f5de4db21e98df69e87555843163d6"},{"_id":"public/noip2006-budget/index.html","modified":1483685924645,"shasum":"4050860a5925aca115aa2c08d6f2df51ba3e1211"},{"_id":"public/bzoj-2442/index.html","modified":1483685924694,"shasum":"282d17f0ed510285d77247bd182fbb65705c0e0c"},{"_id":"public/codevs-3269-monotone-queue/index.html","modified":1483685924754,"shasum":"40ccd5c95274427b15eea41c26bf135b402763b4"},{"_id":"public/monotone-queue-notes/index.html","modified":1483685924795,"shasum":"2af0468d5cf1ed86d0725a24c0223caad10ad9a4"},{"_id":"public/codevs-1345/index.html","modified":1483685924835,"shasum":"fb82fd76576b6df48d5f1bcb77e0b7589d10a0f9"},{"_id":"public/noip2003-game/index.html","modified":1483685924887,"shasum":"3d6d0d2482212d65a074f4ac70bcba69d7a05794"},{"_id":"public/noip2006-energy/index.html","modified":1483685924930,"shasum":"38bb3df8a278e228af287b2c40265cdd829a91f7"},{"_id":"public/tyvj-3317/index.html","modified":1483685924971,"shasum":"49025df4a66bdd02d924393cf856d13a36eb05d6"},{"_id":"public/codevs-2598/index.html","modified":1483685925017,"shasum":"5acaa3ee012c5f5b84c1b14636b187bf22d5345b"},{"_id":"public/noip2000-cheng-ji-zui-da/index.html","modified":1483685925052,"shasum":"2ecd113073b3139a21ab46b33f9b0c1187ba3486"},{"_id":"public/ctsc1997-course/index.html","modified":1483685925096,"shasum":"0a5d37508d467716abc8db5f61bfda0fbb14bc47"},{"_id":"public/codevs-3168-3162/index.html","modified":1483685925164,"shasum":"0b9644da27f7ae193b10b658e2c3589049aff3dc"},{"_id":"public/minimum-spanning-tree-notes/index.html","modified":1483685925241,"shasum":"baaffc4a9d92d2e6e7392623bc822e70afc3d025"},{"_id":"public/system-of-difference-constraints-notes/index.html","modified":1483685925283,"shasum":"19f60ca0b1ad7e92aa5a87e3a1086e50d64ce4ea"},{"_id":"public/kmp-notes/index.html","modified":1483685925331,"shasum":"ef69e3d4a698edd062a241c4585d8b1908c40350"},{"_id":"public/tree-chain-split-notes/index.html","modified":1483685925400,"shasum":"b1f15cb46cc55338fbd48025342a81fee873726f"},{"_id":"public/stl-in-oi/index.html","modified":1483685925465,"shasum":"cc839bb30687e0efe2a8ffddc847107f39647608"},{"_id":"public/splay-notes-2/index.html","modified":1483685925541,"shasum":"b36ec0669cc1403daac8e9d080223855e4524840"},{"_id":"public/splay-notes-1/index.html","modified":1483685925620,"shasum":"e2b159a3b9415a11d3b1d4a39675d17e797733c6"},{"_id":"public/hnoi2004-pet/index.html","modified":1483685925660,"shasum":"8dd1b00ed38f7dc0da875c6f5ff06c289fc26d44"},{"_id":"public/codevs-3269/index.html","modified":1483685925712,"shasum":"bceda8fedd8fa24f3d71d7c4a9a4e2c949ad7154"},{"_id":"public/noi2002-galaxy/index.html","modified":1483685925762,"shasum":"ba9580fa2c4a9c59b920c6aa5b50f1da3758af2b"},{"_id":"public/archives/index.html","modified":1483692242933,"shasum":"a82c6038465156c13dccbfc6cb041fcf33c57b67"},{"_id":"public/archives/page/2/index.html","modified":1483685925870,"shasum":"4ed40b6eaf361cdf8efc2b1cf9367159cc421e3b"},{"_id":"public/archives/page/3/index.html","modified":1483685925934,"shasum":"755bb4167ae55d5e8bff10330b594741ee2725df"},{"_id":"public/archives/page/4/index.html","modified":1483685926005,"shasum":"412c77592707c93a9946d47b76e9c456bd29a3bf"},{"_id":"public/archives/page/5/index.html","modified":1483685926056,"shasum":"114015069f3b91467c9749437bd77b221173eea5"},{"_id":"public/archives/page/6/index.html","modified":1483685926108,"shasum":"1b4c87777d6c58db99e8acd89eaa36300f86d8b4"},{"_id":"public/archives/page/7/index.html","modified":1483685926154,"shasum":"01800b222239fad3d295b3ac004861160af8282f"},{"_id":"public/archives/page/8/index.html","modified":1483685926214,"shasum":"5bae8ce4b05d83bdb0ce2a29a9e769f93fe6c528"},{"_id":"public/archives/page/9/index.html","modified":1483685926268,"shasum":"dd3833c6148950f2a9bae571b0091c1943bd0c11"},{"_id":"public/archives/page/10/index.html","modified":1483685926327,"shasum":"2bdfdbf854620e6be6e391a6980cea83b94ece8a"},{"_id":"public/archives/page/11/index.html","modified":1483685926394,"shasum":"0c20435cc0d0e48dace6b70ae43763743bfc51af"},{"_id":"public/archives/page/12/index.html","modified":1483685926436,"shasum":"ac350f0404d21d153123dab5c1ee2ccb7d3ee9d9"},{"_id":"public/archives/page/13/index.html","modified":1483685926501,"shasum":"fa51d6f8cc097d6484f5fde7bcbb4d58b44c506f"},{"_id":"public/archives/page/14/index.html","modified":1483685926554,"shasum":"10676d8d710fda3fc49c5a0164efc8d2fcae1352"},{"_id":"public/archives/page/15/index.html","modified":1483685926605,"shasum":"fccbcb1069b6c7f5e2c6eb5aee1d256f3c18a185"},{"_id":"public/archives/page/16/index.html","modified":1483685926662,"shasum":"f3cd0839e71bebae0b2d86ffe22b89c01f44f8c1"},{"_id":"public/archives/page/17/index.html","modified":1483685926720,"shasum":"25f1787309af285062b60db823e887eab2d1c57b"},{"_id":"public/archives/page/18/index.html","modified":1483685926776,"shasum":"65ff147c97a512946008d696386b2d7bca6720c4"},{"_id":"public/archives/page/19/index.html","modified":1483685926854,"shasum":"83ea1f56474347a89a1ad5370a32ebd833b31905"},{"_id":"public/archives/page/20/index.html","modified":1483685926904,"shasum":"31ca780de76768b6fa519e9577314372261d3f9c"},{"_id":"public/archives/page/21/index.html","modified":1483685926961,"shasum":"bf7a995f91cc6a6689d31af2f1f2e70511912fd4"},{"_id":"public/archives/page/22/index.html","modified":1483685927017,"shasum":"41bc73b1e022ba09e0ec8714f84d443da3f54f67"},{"_id":"public/archives/page/23/index.html","modified":1483685927069,"shasum":"0e38ead6e59208b3d60032ae998838831218de56"},{"_id":"public/archives/page/24/index.html","modified":1483685927113,"shasum":"658181c668fa5390e7d64c36f51865798e680251"},{"_id":"public/archives/page/25/index.html","modified":1483685927159,"shasum":"2a8fd808e28a84e73a81044411cdb85bee2b9982"},{"_id":"public/archives/page/26/index.html","modified":1483685927207,"shasum":"dfbe84de3bbe51f3c64587ac679f00a1ff5d2709"},{"_id":"public/archives/page/27/index.html","modified":1483685927244,"shasum":"d48d4654f78462a81fecb38def2ecd71f180d382"},{"_id":"public/archives/page/28/index.html","modified":1483685927286,"shasum":"3a9964d74f8044edf110f95506178a0b60fc24cd"},{"_id":"public/archives/page/29/index.html","modified":1483685927355,"shasum":"62ad3df17ca39aed0b09db5a7dcf084bc7b945b7"},{"_id":"public/archives/page/30/index.html","modified":1483685927390,"shasum":"ae67f4cc098ce4de44ddab0ba9d709174761f63e"},{"_id":"public/archives/page/31/index.html","modified":1483685927414,"shasum":"f1c6e14b1007d3bd8dea88cd370aec968ff69e4f"},{"_id":"public/archives/2015/index.html","modified":1483685927447,"shasum":"c9e7932ed245f3f36c7b05fd1a0f2e0a906221ca"},{"_id":"public/archives/2015/11/index.html","modified":1483685927476,"shasum":"cfc863b7692ee6fd91c83a956acf98339705a79a"},{"_id":"public/archives/2015/12/index.html","modified":1483685927502,"shasum":"90a7c07ad0e26cf63da63c5d26b7a34c589bcc44"},{"_id":"public/archives/2016/index.html","modified":1483685927551,"shasum":"ebf395cb3d1d85c657361e4af4ec83796eb23c7a"},{"_id":"public/archives/2016/page/2/index.html","modified":1483685927619,"shasum":"3b8b2aaa90decf382c3f3218e18ddcba9cd573f6"},{"_id":"public/archives/2016/page/3/index.html","modified":1483685927677,"shasum":"8a1cadab97b047d799ba75cfee91f6b362a0cebf"},{"_id":"public/archives/2016/page/4/index.html","modified":1483685927740,"shasum":"2b21e32cb26383bda0b96ec051aad47980ff4f96"},{"_id":"public/archives/2016/page/5/index.html","modified":1483685927781,"shasum":"4bd1880e6d0a10cacd9bbc33d119feae2d256462"},{"_id":"public/archives/2016/page/6/index.html","modified":1483685927851,"shasum":"8ca2c33cf4c0a05b8bc8649ab12c4fce47df24fa"},{"_id":"public/archives/2016/page/7/index.html","modified":1483685927907,"shasum":"e44c6450b29e4a3ab182de869fe01ef0c5741a54"},{"_id":"public/archives/2016/page/8/index.html","modified":1483685927966,"shasum":"bd81f6112641a4f16745402a22ec51070c5942e6"},{"_id":"public/archives/2016/page/9/index.html","modified":1483685928011,"shasum":"a7fe552379afcd38375da89c022ca31cc41dc234"},{"_id":"public/archives/2016/page/10/index.html","modified":1483685928077,"shasum":"68e22888da50c448b1a87e1450a370d145a409ab"},{"_id":"public/archives/2016/page/11/index.html","modified":1483685928118,"shasum":"19ed7ede5bbe4ec7ca1ba3f2524548460e7f7b9d"},{"_id":"public/archives/2016/page/12/index.html","modified":1483685928173,"shasum":"e000c36be8d9e82bbbc8d0d488f044228f70df78"},{"_id":"public/archives/2016/page/13/index.html","modified":1483685928231,"shasum":"4140536f1cfe971f25790d484a2ab87f3250cf0e"},{"_id":"public/archives/2016/page/14/index.html","modified":1483685928285,"shasum":"1cffadde42ad0865a8ce044f1fc52a8eb3674ce8"},{"_id":"public/archives/2016/page/15/index.html","modified":1483685928347,"shasum":"028d59e119135d5d4d84cee815d69518a7707bc2"},{"_id":"public/archives/2016/page/16/index.html","modified":1483685928404,"shasum":"529c62c1fb27c0869e671be49c58d6cf39f029e3"},{"_id":"public/archives/2016/page/17/index.html","modified":1483685928458,"shasum":"16d4e75c0d6451f5a89b1cb937f6258e65fb0fba"},{"_id":"public/archives/2016/page/18/index.html","modified":1483685928526,"shasum":"47c951393f5174a855c47efeedcf361f8844ab02"},{"_id":"public/archives/2016/page/19/index.html","modified":1483685928587,"shasum":"5e8d6ecd9e34aa65f4980b31249655bb3c2fef58"},{"_id":"public/archives/2016/page/20/index.html","modified":1483685928635,"shasum":"0f2d184a1c6b724f97889eb253dad597b293cfeb"},{"_id":"public/archives/2016/page/21/index.html","modified":1483685928705,"shasum":"e1af7cbf98e8e8e09ceecc91526625a5493a6658"},{"_id":"public/archives/2016/page/22/index.html","modified":1483685928745,"shasum":"f47d2c242dfe91cfde6c0fed4ba4d770fbd918e3"},{"_id":"public/archives/2016/page/23/index.html","modified":1483685928800,"shasum":"619cd3ac9aa00c93be2fe2b96276b9b76a89e8e5"},{"_id":"public/archives/2016/page/24/index.html","modified":1483685928852,"shasum":"a06a6947de9e34d5debebadd198c3a68066af092"},{"_id":"public/archives/2016/page/25/index.html","modified":1483685928897,"shasum":"f3d5238ca8c865016431625f8909daeecc754e07"},{"_id":"public/archives/2016/page/26/index.html","modified":1483685928963,"shasum":"e050fb4618ff6a503e64b720a6571c0181f29b5f"},{"_id":"public/archives/2016/page/27/index.html","modified":1483685929000,"shasum":"bfd581636ec21bee95ec5b86f9c92049c5fc2d1d"},{"_id":"public/archives/2016/page/28/index.html","modified":1483685929043,"shasum":"94cc38972e7881b6df05bc3b669599106a3264f1"},{"_id":"public/archives/2016/page/29/index.html","modified":1483685929087,"shasum":"85f91182cccca37cc9c94156bb8c1e70074bbe68"},{"_id":"public/archives/2016/01/index.html","modified":1483685929126,"shasum":"e7634eea08fec2a1f108a7bd2d90257f420e5c08"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1483685929162,"shasum":"fc7f3956f7d74ad0647c8d7c9132bccfc82480af"},{"_id":"public/archives/2016/01/page/3/index.html","modified":1483685929188,"shasum":"8f25e6a2187ca9be5cca0d4d35d42b4147e5db44"},{"_id":"public/archives/2016/02/index.html","modified":1483685929243,"shasum":"1dd1875fee8d1d35151275bfb94139cb1585af74"},{"_id":"public/archives/2016/02/page/2/index.html","modified":1483685929284,"shasum":"8d180e1211e5fd597539381c917502d6ccbbf9f7"},{"_id":"public/archives/2016/02/page/3/index.html","modified":1483685929311,"shasum":"c45507406bf35ffadebb3494d854f7d99b5eda03"},{"_id":"public/archives/2016/03/index.html","modified":1483685929371,"shasum":"3181d789b7debe1aa13ba388dfc5125bd18c8cf8"},{"_id":"public/archives/2016/03/page/2/index.html","modified":1483685929403,"shasum":"79c4a2709b4cbb7a92fdbf941aa1b00c81aaaf4b"},{"_id":"public/archives/2016/03/page/3/index.html","modified":1483685929468,"shasum":"1456da287e285d392ec664668a2037f441480735"},{"_id":"public/archives/2016/03/page/4/index.html","modified":1483685929487,"shasum":"83f69a7a1cec817142b300db6f51afe270977eb7"},{"_id":"public/archives/2016/04/index.html","modified":1483685929549,"shasum":"07e254a604e7f592c6c91e5008b15e4c6b5181a8"},{"_id":"public/archives/2016/04/page/2/index.html","modified":1483685929609,"shasum":"17ed40c03ed05baacb7c24b691c51354c7c5ce6d"},{"_id":"public/archives/2016/04/page/3/index.html","modified":1483685929660,"shasum":"f9a6d95af02dd249a0646798066c57e08f4a5d58"},{"_id":"public/archives/2016/04/page/4/index.html","modified":1483685929709,"shasum":"efd68c909c3dbe236211f90c4e917bdd08203294"},{"_id":"public/archives/2016/05/index.html","modified":1483685929760,"shasum":"9274f58901a25eff2da2c18ff781dce44f0a7e30"},{"_id":"public/archives/2016/05/page/2/index.html","modified":1483685929819,"shasum":"f73da9b69df99b0858a79e7dd233efe6e1bea4ea"},{"_id":"public/archives/2016/05/page/3/index.html","modified":1483685929834,"shasum":"d0d05d091fa7437e187f2209a8e55a329a4e202c"},{"_id":"public/archives/2016/06/index.html","modified":1483685929892,"shasum":"953c1f0448d5865535b9c6c651f04bd37eed5aae"},{"_id":"public/archives/2016/06/page/2/index.html","modified":1483685929962,"shasum":"a2c801b328f41294f09ff98efdd9f06b351b8905"},{"_id":"public/archives/2016/06/page/3/index.html","modified":1483685930022,"shasum":"216657d2bf18532fb0e9cc53f62fa5284f630ec2"},{"_id":"public/archives/2016/06/page/4/index.html","modified":1483685930079,"shasum":"45cb793493ab392e76dc357c50b9d110cd840722"},{"_id":"public/archives/2016/07/index.html","modified":1483685930124,"shasum":"f30de7cf0d74ad1c3a99c3d46ba5994077877fac"},{"_id":"public/archives/2016/07/page/2/index.html","modified":1483685930143,"shasum":"597b228b8533adb05cf08b90e7b7d89303db5ef9"},{"_id":"public/archives/2016/08/index.html","modified":1483685930177,"shasum":"17bdc1ae7ac17dafc827240f3c3c858d654bdc91"},{"_id":"public/archives/2016/09/index.html","modified":1483685930234,"shasum":"16f665725de5a55ec3bbc1caf1e46b491180e0a2"},{"_id":"public/archives/2016/09/page/2/index.html","modified":1483685930285,"shasum":"2d5296b842af65cf4c49706335993ed9da034bb1"},{"_id":"public/archives/2016/09/page/3/index.html","modified":1483685930349,"shasum":"dfec585900d0d9827f02f52c072faa54433fcb05"},{"_id":"public/archives/2016/09/page/4/index.html","modified":1483685930366,"shasum":"2add6eb9d82b5ba039c0f9e48a32589f83e6e00b"},{"_id":"public/archives/2016/10/index.html","modified":1483685930419,"shasum":"617018b9545bb56e31edc4ee55a506aa90feabc9"},{"_id":"public/archives/2016/10/page/2/index.html","modified":1483685930482,"shasum":"7af6c1d715aef280ef23229126743db4c108251a"},{"_id":"public/archives/2016/10/page/3/index.html","modified":1483685930522,"shasum":"50147deef5c18b6eb56a1355027d95b612c3ba8b"},{"_id":"public/archives/2016/11/index.html","modified":1483685930596,"shasum":"d842fef76b0ce7fcece5b7ca005f74214007ee55"},{"_id":"public/archives/2016/11/page/2/index.html","modified":1483685930656,"shasum":"32f9491ebcdd5f7c2ef2d90539661423c7c20715"},{"_id":"public/archives/2016/11/page/3/index.html","modified":1483685930669,"shasum":"7b53c79b9cfe8e50265761700cd5db9884fbb36c"},{"_id":"public/archives/2016/12/index.html","modified":1483685930720,"shasum":"d444b39d3c91b715f778685fb4093f40a03a0216"},{"_id":"public/archives/2016/12/page/2/index.html","modified":1483685930763,"shasum":"d52799d253900fdcecf280fc1a27f5cc4b5152fe"},{"_id":"public/archives/2017/index.html","modified":1483692246692,"shasum":"4e7082e5b76ee9b63c6cbc997509876c08d37fa0"},{"_id":"public/archives/2017/01/index.html","modified":1483692246721,"shasum":"4e7082e5b76ee9b63c6cbc997509876c08d37fa0"},{"_id":"public/categories/oi/index.html","modified":1483692246763,"shasum":"94e62f32203ddf7f44d8c738aa1766d8f763457b"},{"_id":"public/categories/oi/page/2/index.html","modified":1483685930950,"shasum":"a1b6c376d3e4e89a02851b0e812ed8d917420301"},{"_id":"public/categories/oi/page/3/index.html","modified":1483685931014,"shasum":"2bed0807fe4124bc81c49c5fe849be51b5d410c2"},{"_id":"public/categories/oi/page/4/index.html","modified":1483685931092,"shasum":"8b6b8fdd14c3966302ca6f0452e2cead1c5dd693"},{"_id":"public/categories/oi/page/5/index.html","modified":1483685931142,"shasum":"5df9d78aa0f0d8b99287a2a489c92341cc7f88e4"},{"_id":"public/categories/oi/page/6/index.html","modified":1483685931193,"shasum":"e025f42fe788f09531c7c44bcf966c0c2c3ee74a"},{"_id":"public/categories/oi/page/7/index.html","modified":1483685931248,"shasum":"28bb88c3606dd2c137af3c88c2bb9956f61f053d"},{"_id":"public/categories/oi/page/8/index.html","modified":1483685931297,"shasum":"47daf56e5453231bcbbbc0841f5e78f74586d2a4"},{"_id":"public/categories/oi/page/9/index.html","modified":1483685931358,"shasum":"60f548f816baeb888a1d3f0c9bd2069c9a16c9a1"},{"_id":"public/categories/oi/page/10/index.html","modified":1483685931418,"shasum":"af246fd0f45ac28e717ecddcdf75433a6c1dd299"},{"_id":"public/categories/oi/page/11/index.html","modified":1483685931475,"shasum":"699442f396b76b81d516145fc9246e62e4c6e69c"},{"_id":"public/categories/oi/page/12/index.html","modified":1483685931525,"shasum":"d5fa63d530865d37632d95b6d5950944f6e6029e"},{"_id":"public/categories/oi/page/13/index.html","modified":1483685931584,"shasum":"72da4b385229987290eec867d85017c3b55d8ed4"},{"_id":"public/categories/oi/page/14/index.html","modified":1483685931637,"shasum":"b0e1ff3cafb261eb01a0963ab84afaf4826581b2"},{"_id":"public/categories/oi/page/15/index.html","modified":1483685931692,"shasum":"7c16694b8104921788df0a70ec9a23c63b953e63"},{"_id":"public/categories/oi/page/16/index.html","modified":1483685931744,"shasum":"4884ba168a41c8690cf42092bbdc3beaaa79173c"},{"_id":"public/categories/oi/page/17/index.html","modified":1483685931800,"shasum":"4c0e4a9e1430a62e7a3a5b4c1029640f4ce63ba2"},{"_id":"public/categories/oi/page/18/index.html","modified":1483685931860,"shasum":"45ec9af2450ea787d62c338bfafe8c03fa60012d"},{"_id":"public/categories/oi/page/19/index.html","modified":1483685931925,"shasum":"753bf086d1d2ae146e7cbab270ff601caff62d9a"},{"_id":"public/categories/oi/page/20/index.html","modified":1483685931981,"shasum":"ff18edff13227e89e691426f5838e2f303883909"},{"_id":"public/categories/oi/page/21/index.html","modified":1483685932042,"shasum":"c5ec7eaf3daf16cf5ea8541d19332a45c9fafa78"},{"_id":"public/categories/oi/page/22/index.html","modified":1483685932101,"shasum":"7a14afdf291c3628cd6bfedf273f8a273c486efa"},{"_id":"public/categories/oi/page/23/index.html","modified":1483685932157,"shasum":"65b2d2014623fb48247a80353412d1afd3566e85"},{"_id":"public/categories/oi/page/24/index.html","modified":1483685932208,"shasum":"906c101cf8b5305bb9ab149925f96f1130f8174a"},{"_id":"public/categories/oi/page/25/index.html","modified":1483685932249,"shasum":"6b1a03f7cd9e132f2a3949ab37e5e2615733f239"},{"_id":"public/categories/oi/page/26/index.html","modified":1483685932298,"shasum":"eb06861a7213c717152fd3c3a2a56b7225b2bb29"},{"_id":"public/categories/oi/page/27/index.html","modified":1483685932342,"shasum":"901bea21ce13acdca42e294821589405e0286750"},{"_id":"public/categories/oi/page/28/index.html","modified":1483685932384,"shasum":"3928ba492e5e5a0d70245ee6a537d6123baac367"},{"_id":"public/categories/oi/page/29/index.html","modified":1483685932432,"shasum":"87fd4199b88c272d87b5ce529866c5f1010dc418"},{"_id":"public/categories/oi/page/30/index.html","modified":1483685932459,"shasum":"429c63cbf898d9abf616c7fa4a4a1f9e697572dd"},{"_id":"public/categories/geek/index.html","modified":1483685932483,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/categories/diary/index.html","modified":1483685932511,"shasum":"f00725f23009a2257e3a60a5eda6a1ec660f8c99"},{"_id":"public/atom.xml","modified":1483692249800,"shasum":"6038a86a7f395c232643837b1c29bafc6d27a9c4"},{"_id":"public/index.html","modified":1483692248449,"shasum":"873956b22dcad6bb5300635f8d703fa549115b20"},{"_id":"public/page/2/index.html","modified":1483685932645,"shasum":"a2cc90e45ddc316ca2e5fb9f018de023853bf49e"},{"_id":"public/page/3/index.html","modified":1483685932715,"shasum":"f241e980b405105c68112ab35c5ace74a7bd4534"},{"_id":"public/page/4/index.html","modified":1483685932782,"shasum":"ffa17743e97601850e93a69da5c8721644d3475d"},{"_id":"public/page/5/index.html","modified":1483685932833,"shasum":"6d71822f97b6edf76bb7509fed2cc112711d1178"},{"_id":"public/page/6/index.html","modified":1483685932885,"shasum":"d1720dfea77771abb2e8242169d7f76bd9b4e0a4"},{"_id":"public/page/7/index.html","modified":1483685932929,"shasum":"23bb32c9e089d6ba7d80e09bdad92df74f79b36a"},{"_id":"public/page/8/index.html","modified":1483685932984,"shasum":"18635cdaaa89d5f601edcfbe73e6945fdf58fdf9"},{"_id":"public/page/9/index.html","modified":1483685933030,"shasum":"d06c73dbdfe5bbd7c80cfc198b91ba7c4d8dfad6"},{"_id":"public/page/10/index.html","modified":1483685933091,"shasum":"09fd7b5b43835e44750492386bdbc165857cbc23"},{"_id":"public/page/11/index.html","modified":1483685933143,"shasum":"1c557f009285b8e91e273cba647c4858dfeee68a"},{"_id":"public/page/12/index.html","modified":1483685933205,"shasum":"39cd45995c10a6848d58f199babd86993deb6868"},{"_id":"public/page/13/index.html","modified":1483685933259,"shasum":"a718491eeb515ce1c774f10aa6f89d6d9500d174"},{"_id":"public/page/14/index.html","modified":1483685933316,"shasum":"9e417fed068e31c4e2457cadafb7b933eb220655"},{"_id":"public/page/15/index.html","modified":1483685933363,"shasum":"fc41c575fe1701c9b1f5c2e4a656f44e69beb19d"},{"_id":"public/page/16/index.html","modified":1483685933415,"shasum":"b668fe4e732e800635a17803be440553780b38bc"},{"_id":"public/page/17/index.html","modified":1483685933477,"shasum":"0485aabf4db54d236d155b93461fa206766968fc"},{"_id":"public/page/18/index.html","modified":1483685933533,"shasum":"26bfdd74addd417231e6adf72f4b7411f47a3e34"},{"_id":"public/page/19/index.html","modified":1483685933603,"shasum":"3f391462e301a757bbc98ed36e3d5716ee1e9728"},{"_id":"public/page/20/index.html","modified":1483685933648,"shasum":"01346edc6463c93f4b0e7eae83a8fecba9549f28"},{"_id":"public/page/21/index.html","modified":1483685933711,"shasum":"2cf8b257295a1a863bf9944ed81ef640bd583ed4"},{"_id":"public/page/22/index.html","modified":1483685933771,"shasum":"0b50d295fdc58e9986d12c599196cb685892b322"},{"_id":"public/page/23/index.html","modified":1483685933828,"shasum":"045130cd2f48e97ad7f9a06fbfae9737dff6c6a2"},{"_id":"public/page/24/index.html","modified":1483685933873,"shasum":"bd9847c7254040718c6f9d161f221ac8f7365bba"},{"_id":"public/page/25/index.html","modified":1483685933934,"shasum":"c8f0b496691c4e8f6b9ae8217c066575c2ad723d"},{"_id":"public/page/26/index.html","modified":1483685933974,"shasum":"dcf364262e80e7f78958ea448475f5ce4e1b4156"},{"_id":"public/page/27/index.html","modified":1483685934018,"shasum":"964eaaafe48d9afc8e6b53b562ac97a0d8223eef"},{"_id":"public/page/28/index.html","modified":1483685934067,"shasum":"f7f55a32a9bc1b7531562c651c00ba4f5db078c1"},{"_id":"public/page/29/index.html","modified":1483685934107,"shasum":"2b21b00a3a0048c6e76acdeaf650aa77a2714e9a"},{"_id":"public/page/30/index.html","modified":1483685934139,"shasum":"e6a1465170dbeb08a50dc94672e1ac51476f1f07"},{"_id":"public/page/31/index.html","modified":1483685934167,"shasum":"ec97cf2afc545773351693c562003bb916c88ac0"},{"_id":"public/content.json","modified":1483692249821,"shasum":"fc2190cbee645774a7a8dbf7b020da5399820c6a"},{"_id":"public/sitemap.xml","modified":1483692249833,"shasum":"9b32b357d4669bd99de57206b4cc370a13fc99d2"},{"_id":"public/tag/安徽集训/index.html","modified":1483685934274,"shasum":"5f58435b690bc9d3492c38a13cef9c169684f71a"},{"_id":"public/tag/安徽集训/page/2/index.html","modified":1483685934297,"shasum":"beea4828671a18f19504d6cea8a5f312cc6a043f"},{"_id":"public/tag/树链剖分/index.html","modified":1483685934363,"shasum":"b14e8e3b2a67b9736ab2de036118b51913542f85"},{"_id":"public/tag/树链剖分/page/2/index.html","modified":1483685934376,"shasum":"a11857621c4a59a216a20b608ebae8b7f4c2beb7"},{"_id":"public/tag/线段树/index.html","modified":1483685934434,"shasum":"69f08884747f46a06869ae1d39dd44e72eacb248"},{"_id":"public/tag/数据结构/index.html","modified":1483685934485,"shasum":"d8a7a977255a8e4970b83bb9ce8cde0bf2921550"},{"_id":"public/tag/数据结构/page/2/index.html","modified":1483685934542,"shasum":"b35c14ad6f39d732a24e88fd79b7730aafb57878"},{"_id":"public/tag/数据结构/page/3/index.html","modified":1483685934599,"shasum":"2c51bbc9892e5a5994757b26a9b12cfc7be5285d"},{"_id":"public/tag/数据结构/page/4/index.html","modified":1483685934643,"shasum":"6b1a8bd4a41ede5ef1d3f9a898d7eb8fa2e34f34"},{"_id":"public/tag/数据结构/page/5/index.html","modified":1483685934660,"shasum":"a3ad6b72bbafcd1cefa5731ee11d3afa6c1a6b84"},{"_id":"public/tag/高级数据结构/index.html","modified":1483685934718,"shasum":"e02a01459c60b28bcdf7584d0e1413bd8d64a8dd"},{"_id":"public/tag/高级数据结构/page/2/index.html","modified":1483685934742,"shasum":"8dd9bcc0bffb082e9b81271ef1d9f10b7db58f9b"},{"_id":"public/tag/bzoj/index.html","modified":1483685934800,"shasum":"2b1946dd9c9e31241359636304a773fd4030c0ad"},{"_id":"public/tag/bzoj/page/2/index.html","modified":1483685934874,"shasum":"4ef14b66ee955cc6d3687050b005feeb9c4d7ca8"},{"_id":"public/tag/bzoj/page/3/index.html","modified":1483685934932,"shasum":"2ea169ffe7bcde40ad00e74c77e1a9b88c3d5966"},{"_id":"public/tag/bzoj/page/4/index.html","modified":1483685934995,"shasum":"227ebebeac21bfbda314424d4ddc3b5405abd6ad"},{"_id":"public/tag/bzoj/page/5/index.html","modified":1483685935050,"shasum":"ccc33cbd31be46abcf877c641b701c57d2cee199"},{"_id":"public/tag/bzoj/page/6/index.html","modified":1483685935108,"shasum":"e2f0122e9fb93250dd7e6140c5cdf6ff2b4c2600"},{"_id":"public/tag/bzoj/page/7/index.html","modified":1483685935177,"shasum":"f40131614430737577006035f596a773d08beb81"},{"_id":"public/tag/bzoj/page/8/index.html","modified":1483685935247,"shasum":"68460ebff5090ba216bad990ffe400bc9d79a0db"},{"_id":"public/tag/bzoj/page/9/index.html","modified":1483685935322,"shasum":"15ed6a1187b37219a3e0be211ed4434ee2ba82df"},{"_id":"public/tag/bzoj/page/10/index.html","modified":1483685935387,"shasum":"a2e29aca98974c28ce6502f51f86c5ee90b2ae7c"},{"_id":"public/tag/bzoj/page/11/index.html","modified":1483685935462,"shasum":"117efef84536a855a5438cc9fe5c4b0bd1d05fc1"},{"_id":"public/tag/bzoj/page/12/index.html","modified":1483685935527,"shasum":"98e35c082eb165b698495995773446c473d9572d"},{"_id":"public/tag/bzoj/page/13/index.html","modified":1483685935609,"shasum":"29eba364c559322a60b113c9e95416f4e5333df1"},{"_id":"public/tag/bzoj/page/14/index.html","modified":1483685935687,"shasum":"d1b0af5b56d29f88e0563de6f545f82863898319"},{"_id":"public/tag/bzoj/page/15/index.html","modified":1483685935782,"shasum":"3b2ea1e57ee327b79a7914b889904722e85e22a2"},{"_id":"public/tag/bzoj/page/16/index.html","modified":1483685935872,"shasum":"1db334bb47846fb720381d83c41942afce50645b"},{"_id":"public/tag/bzoj/page/17/index.html","modified":1483685935954,"shasum":"33b15519bd6d0010eb09203897d585c0f8b432c7"},{"_id":"public/tag/bzoj/page/18/index.html","modified":1483685936022,"shasum":"9f454a75d1d7ad2c9a128174b18113f61a71fccd"},{"_id":"public/tag/bzoj/page/19/index.html","modified":1483685936078,"shasum":"2a5407d3d6e54e058106885705b8efd5f835806a"},{"_id":"public/tag/zjoi/index.html","modified":1483685936157,"shasum":"813ee49ba031180c8b69bd35184f04b700137b04"},{"_id":"public/tag/zjoi/page/2/index.html","modified":1483685936182,"shasum":"574979e328d79b68e88abd5728af8b823db46334"},{"_id":"public/tag/fft/index.html","modified":1483685936245,"shasum":"71eb8470923c246ba2bdcd4cc034d3419111f4dc"},{"_id":"public/tag/数学/index.html","modified":1483692251405,"shasum":"2a2177d6894e3166042b8b0555201cf5ef786366"},{"_id":"public/tag/数学/page/2/index.html","modified":1483685936391,"shasum":"265145c88971b0521dc0c3d09c0dc57b313f5c93"},{"_id":"public/tag/数学/page/3/index.html","modified":1483685936494,"shasum":"4d0f86012573fee5b898361592b966bb30ffcea1"},{"_id":"public/tag/数学/page/4/index.html","modified":1483685936570,"shasum":"d598d47b11afade1cf2ab0bf9b299a44790af6d8"},{"_id":"public/tag/数学/page/5/index.html","modified":1483685936587,"shasum":"993a46505e2316b26d32aca319ab94f42bd61f2c"},{"_id":"public/tag/网络流/index.html","modified":1483685936687,"shasum":"0051d8c18fbb9ca3aa442c13e1e212df3f88bdee"},{"_id":"public/tag/网络流/page/2/index.html","modified":1483685936832,"shasum":"e9bad10585de329b81e030722927d22c122a7dcc"},{"_id":"public/tag/网络流/page/3/index.html","modified":1483685936910,"shasum":"88c94ce494df25bdba624433e62ba2b0d96adfb0"},{"_id":"public/tag/网络流/page/4/index.html","modified":1483685936965,"shasum":"c89da73ec53c1579d0f8bbbfc18da5a70a752e0c"},{"_id":"public/tag/网络流/page/5/index.html","modified":1483685936996,"shasum":"62f7cdd373fd541afa1f10a6322906422a6a59d8"},{"_id":"public/tag/dinic/index.html","modified":1483685937048,"shasum":"3c61ed769dbd7d17938e667d500276191c1dfbac"},{"_id":"public/tag/dinic/page/2/index.html","modified":1483685937110,"shasum":"70d0336200615b0834ecd765609591456bb6a587"},{"_id":"public/tag/dinic/page/3/index.html","modified":1483685937159,"shasum":"727fc956545747c25ee52d3f99332ff0d5485e15"},{"_id":"public/tag/dinic/page/4/index.html","modified":1483685937179,"shasum":"311f259db5bc5ca33d12e17889d4b1dc9acdb6bf"},{"_id":"public/tag/费用流/index.html","modified":1483685937241,"shasum":"11ea6aaa7d227ac7aeb198ea1ee38783082cc474"},{"_id":"public/tag/费用流/page/2/index.html","modified":1483685937258,"shasum":"27a2f3d2f8da661d04346ecec27c0a290d7de608"},{"_id":"public/tag/edmonds-karp/index.html","modified":1483685937323,"shasum":"ba291313b5aa4cc8d33c56d2aa129cfab3511dd7"},{"_id":"public/tag/edmonds-karp/page/2/index.html","modified":1483685937341,"shasum":"27a2f3d2f8da661d04346ecec27c0a290d7de608"},{"_id":"public/tag/最小割/index.html","modified":1483685937410,"shasum":"b9a7ff1c9b7bc6de65d929349a812a462eb812bf"},{"_id":"public/tag/最小割/page/2/index.html","modified":1483685937455,"shasum":"c10e74d68b470c531474b0771509011aa1b345e8"},{"_id":"public/tag/dp/index.html","modified":1483685937514,"shasum":"e2d8fe5f87a937ccd7d2f5533d0439e200419bd2"},{"_id":"public/tag/dp/page/2/index.html","modified":1483685937587,"shasum":"86c033bf6660ba0c069d953d92c0f8a566b8a1ad"},{"_id":"public/tag/dp/page/3/index.html","modified":1483685937633,"shasum":"14a3fca6f2d7eca0daa6d5134dc95d49ddb5142d"},{"_id":"public/tag/dp/page/4/index.html","modified":1483685937691,"shasum":"3ee74a2b8b28d14b757036dabbf69001bbdc16bb"},{"_id":"public/tag/dp/page/5/index.html","modified":1483685937746,"shasum":"1ad5072fa7ec04813ca41785362f4a0a537c95ff"},{"_id":"public/tag/dp/page/6/index.html","modified":1483685937788,"shasum":"5026da19a01d0b16d5a626018213b2f5355c9ef1"},{"_id":"public/tag/dp/page/7/index.html","modified":1483685937833,"shasum":"b56a7e826079a376fa19867977a13d68ec978c69"},{"_id":"public/tag/贪心/index.html","modified":1483685937885,"shasum":"b88fe394f5f18456115e19b9879b030d17cf1ec8"},{"_id":"public/tag/贪心/page/2/index.html","modified":1483685937897,"shasum":"8febeadd742d484e06a00c7a8ed64eb8d22af476"},{"_id":"public/tag/cogs/index.html","modified":1483685937963,"shasum":"ee98537e6c5855eae6e0d11455577a08c9a3a035"},{"_id":"public/tag/cogs/page/2/index.html","modified":1483685938025,"shasum":"96c4b0763f0c8ff50edd57ed3e833659edef099b"},{"_id":"public/tag/cogs/page/3/index.html","modified":1483685938080,"shasum":"c844a23d12e6af4b14cab757cb85a290954196cc"},{"_id":"public/tag/cogs/page/4/index.html","modified":1483685938115,"shasum":"58f09590ce563f936aa603e3fb96f619d5498bf8"},{"_id":"public/tag/模拟/index.html","modified":1483685938138,"shasum":"23e2560a8cc824a39e7105166716f12d6b42d109"},{"_id":"public/tag/几何/index.html","modified":1483685938151,"shasum":"f95af89f51e59d956a4d3148fe5685600d01c2a4"},{"_id":"public/tag/斜率优化/index.html","modified":1483685938204,"shasum":"85f0bd205cb86899c8c257cae47f81b6b3708816"},{"_id":"public/tag/单调队列/index.html","modified":1483685938259,"shasum":"dd37ea86615313a54518067423a6e5b3777368be"},{"_id":"public/tag/单调队列/page/2/index.html","modified":1483685938271,"shasum":"7b1f426df73fffe88a86fdaf686167fb5c72e1ef"},{"_id":"public/tag/强连通分量/index.html","modified":1483685938312,"shasum":"3654e8ab504f83cff5218b1fd0ca8719c24fc5cb"},{"_id":"public/tag/tarjan/index.html","modified":1483685938364,"shasum":"483eac283d9a65810cd5f02593d9d96e16e25a13"},{"_id":"public/tag/tarjan/page/2/index.html","modified":1483685938392,"shasum":"3b5226c35881143dea177572bd9853b73bd02d01"},{"_id":"public/tag/缩点/index.html","modified":1483685938446,"shasum":"e79aa0eceba7eb1ca291ca65abba964bbca2c39b"},{"_id":"public/tag/悬线法/index.html","modified":1483685938458,"shasum":"189750cf640f2b2f568bc614bb0f93a1256e3801"},{"_id":"public/tag/最短路/index.html","modified":1483685938511,"shasum":"09bf83bc09a701088f4d56facecfb86178d09767"},{"_id":"public/tag/矩阵乘法/index.html","modified":1483685938545,"shasum":"e9e59a3dc5a0acdf9c511f726c23773a89402a31"},{"_id":"public/tag/os-x/index.html","modified":1483685938573,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/linux/index.html","modified":1483685938585,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/archlinux/index.html","modified":1483685938608,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/virtualbox/index.html","modified":1483685938619,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/虚拟机/index.html","modified":1483685938641,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/ssh/index.html","modified":1483685938652,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/uva/index.html","modified":1483685938700,"shasum":"4e977cc8902a347211920af9fc8a7f19f2abf767"},{"_id":"public/tag/区间-dp/index.html","modified":1483685938720,"shasum":"02579bdc4e2c12fe2bfb8ed660cedaa1330b5203"},{"_id":"public/tag/计数原理/index.html","modified":1483685938760,"shasum":"9519441d018012db4db5d0764f8f26ede15ac68a"},{"_id":"public/tag/组合数学/index.html","modified":1483685938792,"shasum":"8b88b0a7b3f2b68955b9967a6791f35f37f34a09"},{"_id":"public/tag/容斥原理/index.html","modified":1483685938817,"shasum":"c34eac53ddf9134f075dc333b6ade28f9835e76d"},{"_id":"public/tag/递推/index.html","modified":1483685938860,"shasum":"71aeb97f8512c40dfa9ff83dafc8589a1ea742b0"},{"_id":"public/tag/高精度/index.html","modified":1483685938883,"shasum":"e39d7ffd890dba6f906360190df199f043d037da"},{"_id":"public/tag/数位-dp/index.html","modified":1483685938924,"shasum":"103e322523445a4eb741a4d3ee09c847f60e01c5"},{"_id":"public/tag/数论/index.html","modified":1483685938989,"shasum":"9f7293f51c522e3474a43f7e29ba1c328029bbe2"},{"_id":"public/tag/数论/page/2/index.html","modified":1483685939013,"shasum":"8f2618a2e98ddd6fbb4085dc0e09d50913171909"},{"_id":"public/tag/乘法逆元/index.html","modified":1483685939048,"shasum":"3d49ad662946db8083400e4961021b6bb81d3813"},{"_id":"public/tag/全排列/index.html","modified":1483685939066,"shasum":"afc073d4ce11398490cf26a8a2d085f5151d83cb"},{"_id":"public/tag/背包-dp/index.html","modified":1483685939127,"shasum":"c41a8d72b11e1c5c19bff23e3bb9df63a5586443"},{"_id":"public/tag/背包-dp/page/2/index.html","modified":1483685939143,"shasum":"81e7aa9bff8639659857306a5ce9233aea65cef7"},{"_id":"public/tag/概率与期望/index.html","modified":1483685939179,"shasum":"77c795b0ec5d468151dfebb9172944a796a00aba"},{"_id":"public/tag/组合数/index.html","modified":1483685939226,"shasum":"2c3aa6296271a5d5e04784f51dfc3be88a22d13c"},{"_id":"public/tag/整数划分/index.html","modified":1483685939239,"shasum":"dd7b750ea4b04961bf8b2536af71d191fac94e54"},{"_id":"public/tag/回溯/index.html","modified":1483685939262,"shasum":"dd7b750ea4b04961bf8b2536af71d191fac94e54"},{"_id":"public/tag/codevs/index.html","modified":1483685939320,"shasum":"c855d9e4f5f7c1c1833e0f40a5e28aa9f3038c36"},{"_id":"public/tag/codevs/page/2/index.html","modified":1483685939380,"shasum":"f33158cea45a6e3e6b83ecd648f71038343491ab"},{"_id":"public/tag/codevs/page/3/index.html","modified":1483685939409,"shasum":"32fe931ec38673032bd4ef95d9588f6982ce7bbc"},{"_id":"public/tag/codevs/page/4/index.html","modified":1483685939474,"shasum":"37a9c03d9f12502d4ebc7f8f611691d3f70eae17"},{"_id":"public/tag/codevs/page/5/index.html","modified":1483685939493,"shasum":"b9b5224de9dfca39a0015feee6e2aaf8355ad31c"},{"_id":"public/tag/tyvj/index.html","modified":1483685939538,"shasum":"a9a6cbcd7684d4dd150a8fb4fb685ee084333c34"},{"_id":"public/tag/划分-dp/index.html","modified":1483685939566,"shasum":"16f4d17d57d9ab288bd17cb059915fb2aa4019ab"},{"_id":"public/tag/算法模板/index.html","modified":1483692253811,"shasum":"144e7b76ed96ac1280fea2d115ee386105308d8b"},{"_id":"public/tag/算法模板/page/2/index.html","modified":1483685939648,"shasum":"fc4ce4405655712d365462a17940ed117fceee0f"},{"_id":"public/tag/算法模板/page/3/index.html","modified":1483685939677,"shasum":"666fea8dec323ae9c803aa92488dc54e55478a0f"},{"_id":"public/tag/tjoi/index.html","modified":1483685939708,"shasum":"b98f6b96cabcf2347c571d068d0ecdad0a63ceb0"},{"_id":"public/tag/状压-dp/index.html","modified":1483685939733,"shasum":"75a6d0a6a3956ed48a4ac6d284a0eb6ffec2831f"},{"_id":"public/tag/字符串/index.html","modified":1483685939786,"shasum":"9eea440938006f318adf1ed8cb21337c0a84ed53"},{"_id":"public/tag/字符串/page/2/index.html","modified":1483685939834,"shasum":"cb428b322d7390f6c9af577dc37cb7e0df82cb0d"},{"_id":"public/tag/字符串/page/3/index.html","modified":1483685939891,"shasum":"ad3a9ffa08ffcb3ca207048c0f4d1b74d2bf67eb"},{"_id":"public/tag/字符串/page/4/index.html","modified":1483685939905,"shasum":"cb0756c2102520a3b864bb55ac7524501acfab7f"},{"_id":"public/tag/ac-自动机/index.html","modified":1483685939958,"shasum":"9cea2862a841bf2a94db788b16b48452bd3cd3a1"},{"_id":"public/tag/ac-自动机/page/2/index.html","modified":1483685939972,"shasum":"d8ad219c3e2e4a097a4afec69aa4e02f07dc2f02"},{"_id":"public/tag/离线/index.html","modified":1483685940016,"shasum":"016fce1f93f999298976b7f6e0c2563488531d9e"},{"_id":"public/tag/splay/index.html","modified":1483685940070,"shasum":"79d7d747c076cde4c0031279c540ff365e03901c"},{"_id":"public/tag/splay/page/2/index.html","modified":1483685940085,"shasum":"84bf1f6d4bf33476aadb203c9ec476ec1840fea2"},{"_id":"public/tag/树状数组/index.html","modified":1483685940148,"shasum":"c7e0ab350d945d88c738352ab86069fba18003d3"},{"_id":"public/tag/树状数组/page/2/index.html","modified":1483685940161,"shasum":"b010db9d13248e5040fd893bdb222233ef856d7a"},{"_id":"public/tag/学习笔记/index.html","modified":1483692254230,"shasum":"04d17185f1e6f950818f3681f29f9e1e97687f3e"},{"_id":"public/tag/学习笔记/page/2/index.html","modified":1483685940249,"shasum":"27c8bcf77189722eaf2f6dd848f9664bcc271d08"},{"_id":"public/tag/学习笔记/page/3/index.html","modified":1483685940291,"shasum":"b67e702566ef1a66d68f9f455c3f68c266ed77b0"},{"_id":"public/tag/图论/index.html","modified":1483685940337,"shasum":"e9b96996f260a259ee7161e25f4c20fa23056060"},{"_id":"public/tag/图论/page/2/index.html","modified":1483685940381,"shasum":"68c812bc42ab3dd2a39ebfab33059ee27f7e028b"},{"_id":"public/tag/图论/page/3/index.html","modified":1483685940436,"shasum":"c4b1d300a5cb02135c4c52e5e0efc0517dae506f"},{"_id":"public/tag/图论/page/4/index.html","modified":1483685940463,"shasum":"346497ac4f8f8a8c4773304bbd7155bfdd11607e"},{"_id":"public/tag/强联通分量/index.html","modified":1483685940498,"shasum":"840fcbe1fbfeb2780b5cd79ffa29a57592da7faf"},{"_id":"public/tag/割点/index.html","modified":1483685940522,"shasum":"cb634887742bb595400a168202de21de92bfb4d0"},{"_id":"public/tag/双联通分量/index.html","modified":1483685940540,"shasum":"8474251a0845b684ed93b40a2abc23e4456e5b48"},{"_id":"public/tag/差分约束系统/index.html","modified":1483685940576,"shasum":"a77ba0e0dd9cce1359e6cb14858ffda4b43ededd"},{"_id":"public/tag/后缀数组/index.html","modified":1483685940636,"shasum":"d801a355ec0e34b20fce184a5e7b91134a19d0cc"},{"_id":"public/tag/后缀数组/page/2/index.html","modified":1483685940650,"shasum":"054e39143ed6bddc4a11e83860f0a3ee93e273bf"},{"_id":"public/tag/稀疏表/index.html","modified":1483685940666,"shasum":"26d38fcf3575811c00b0e9a83dd3327068d99845"},{"_id":"public/tag/c/index.html","modified":1483685940686,"shasum":"1fad7df1628d8c1308b88a46a7626dbc14536948"},{"_id":"public/tag/stl/index.html","modified":1483685940717,"shasum":"f50e6eff40c18880739d338bd7b1e779c8c895b8"},{"_id":"public/tag/spoj/index.html","modified":1483685940733,"shasum":"baa5a6b0f6b1513f2dc9609ae304c65c62a5ead5"},{"_id":"public/tag/shoi/index.html","modified":1483685940771,"shasum":"53df0cd7d717d064929e77eda0764b0bb462b1c7"},{"_id":"public/tag/博弈论/index.html","modified":1483685940789,"shasum":"21097c7afb2c5a4d34a4d61c0f947da2f8f8fd70"},{"_id":"public/tag/仙人掌/index.html","modified":1483685940805,"shasum":"53fd0f9629b5c04694a379090cc4f2267b1d0732"},{"_id":"public/tag/cdq/index.html","modified":1483685940850,"shasum":"91f1c39abf42c77454046c59076eb8222199b1ce"},{"_id":"public/tag/分治/index.html","modified":1483685940894,"shasum":"68f77acf9380e8c5aca86fca6a740efc28c5bff1"},{"_id":"public/tag/sdoi/index.html","modified":1483685940950,"shasum":"0c38b9210afafacb1638992628982f1454f79c80"},{"_id":"public/tag/sdoi/page/2/index.html","modified":1483685941006,"shasum":"23695f900eea590e7c28218e1bd1292b28c25717"},{"_id":"public/tag/二进制/index.html","modified":1483685941031,"shasum":"3f2c8d01cbc894521eafceb1822dde3110f8b926"},{"_id":"public/tag/异或/index.html","modified":1483685941052,"shasum":"3f2c8d01cbc894521eafceb1822dde3110f8b926"},{"_id":"public/tag/位运算/index.html","modified":1483685941082,"shasum":"70eec66492298319d9691c2965e3a5c7e9178b07"},{"_id":"public/tag/错位排列/index.html","modified":1483685941119,"shasum":"1dbe02a85e44154406ce1ecec972b4b138b437a9"},{"_id":"public/tag/素数判定/index.html","modified":1483685941149,"shasum":"cb90b55aa5616e1b16ae67b5637f71cfe243cb26"},{"_id":"public/tag/线性筛/index.html","modified":1483685941183,"shasum":"167b30790f403904a370beb5ddf9526d2d8ed893"},{"_id":"public/tag/二分答案/index.html","modified":1483685941232,"shasum":"27d6e3ae21567cf9d4ddf3394f43502290752b1a"},{"_id":"public/tag/rmq/index.html","modified":1483685941264,"shasum":"71018e897e83d33950bae1cdbd2df2ae666dc22f"},{"_id":"public/tag/最近公共祖先/index.html","modified":1483685941307,"shasum":"a9ca05181edbe18f5455e484cc35c51c0841874b"},{"_id":"public/tag/实数二分/index.html","modified":1483685941338,"shasum":"7e1004df80c3992def22c47e3811838d82368e05"},{"_id":"public/tag/ntt/index.html","modified":1483685941375,"shasum":"1f790c27dcc94444cf3ff7f5cf262c1ef7e6f596"},{"_id":"public/tag/生成函数/index.html","modified":1483685941413,"shasum":"1f790c27dcc94444cf3ff7f5cf262c1ef7e6f596"},{"_id":"public/tag/快速幂/index.html","modified":1483685941449,"shasum":"b26d46102f4a18e501c16b49401084d67079b7ef"},{"_id":"public/tag/原根/index.html","modified":1483685941481,"shasum":"ecff6d16b0d35ab8eee1fefbf5f29bdc070a0b71"},{"_id":"public/tag/并查集/index.html","modified":1483685941532,"shasum":"dd9af0391dd4bd215c42b4dd8cddd953ab988d7a"},{"_id":"public/tag/主席树/index.html","modified":1483685941561,"shasum":"1878cda2857935ca110a833f27d09ed416aee61f"},{"_id":"public/tag/启发式合并/index.html","modified":1483685941584,"shasum":"43e4a1809abe90b4baa89213da9f750e1976090f"},{"_id":"public/tag/exgcd/index.html","modified":1483685941605,"shasum":"061d80bb11e324802f8e857038a080e8ad1a6e82"},{"_id":"public/tag/bsgs/index.html","modified":1483685941653,"shasum":"07441a40bd3246276e19e25f1f6999bd911d02a8"},{"_id":"public/tag/动态树/index.html","modified":1483685941684,"shasum":"34c2946d64c32be95f758a3b624226ddf7076e41"},{"_id":"public/tag/link-cut-tree/index.html","modified":1483685941709,"shasum":"d15843ec388fa33965f6b391b1bd4011a4e7d8d7"},{"_id":"public/tag/scoi/index.html","modified":1483685941767,"shasum":"134955ae3b78ba83f09e73bc8389b2f4ba382de9"},{"_id":"public/tag/scoi/page/2/index.html","modified":1483685941811,"shasum":"4af1c3c8292c3f5399c886c467deb328baff7f45"},{"_id":"public/tag/set/index.html","modified":1483685941829,"shasum":"22c3ae9ec64154c6827ae22e9690d682aa7a1e93"},{"_id":"public/tag/乱搞/index.html","modified":1483685941862,"shasum":"ccc6e294c65b2955a28fbd7a7912746cb1dc44f9"},{"_id":"public/tag/二分图匹配/index.html","modified":1483685941896,"shasum":"99fa093fc24cfba681a1f9c6b72e0118a184a512"},{"_id":"public/tag/树形-dp/index.html","modified":1483685941933,"shasum":"591f823cf61b4fd4b244424aae2d2b38838850b4"},{"_id":"public/tag/倍增/index.html","modified":1483685941964,"shasum":"0b4bf641763f2ab020727c8c47c4c849ae1e59f5"},{"_id":"public/tag/拓扑排序/index.html","modified":1483685941983,"shasum":"e93b625fa50faaeb605fcd933ccccfe7f8123cc2"},{"_id":"public/tag/匈牙利算法/index.html","modified":1483685942002,"shasum":"d79d1357db8aa78ff98add77be6d2e3d6968a76c"},{"_id":"public/tag/枚举答案/index.html","modified":1483685942022,"shasum":"aef74405a5caa9bd8600e9e5f69bb18ed07368e8"},{"_id":"public/tag/群论/index.html","modified":1483685942047,"shasum":"4de6bf60ac40d5d246cccf3eabec6d3481999185"},{"_id":"public/tag/搜索/index.html","modified":1483685942110,"shasum":"a596ca49ac22663932fa38f282904d33eaf655e7"},{"_id":"public/tag/dfs/index.html","modified":1483685942137,"shasum":"2a42941cc13ae99b3851e2353a171dc31875dc41"},{"_id":"public/tag/树分块/index.html","modified":1483685942151,"shasum":"f0abf9c2df47b578bf5e25cafd0343caf1e482ea"},{"_id":"public/tag/分块/index.html","modified":1483685942205,"shasum":"49d4aaa6c0e8f98bf5ab8eadd34a12753aed518b"},{"_id":"public/tag/poj/index.html","modified":1483685942244,"shasum":"fa524eee7c29f0172134b85a830324151ce86d3d"},{"_id":"public/tag/trie/index.html","modified":1483685942268,"shasum":"0b462c1a0c9bcc6638f19a2061a346224737db5b"},{"_id":"public/tag/kmp/index.html","modified":1483685942296,"shasum":"6ecaddf46f079e9dec410f20c86a821f9c707821"},{"_id":"public/tag/prim/index.html","modified":1483685942311,"shasum":"a982772555ac4e4fe2319d34a19440a58bd155c8"},{"_id":"public/tag/生成树/index.html","modified":1483685942333,"shasum":"0536163740b856f6bf8329ad8326de1202f56412"},{"_id":"public/tag/分数规划/index.html","modified":1483685942365,"shasum":"0536163740b856f6bf8329ad8326de1202f56412"},{"_id":"public/tag/poi/index.html","modified":1483685942398,"shasum":"63e4d34284d8ff84e5be6ae9ebc1d107f27e3499"},{"_id":"public/tag/noip/index.html","modified":1483685942464,"shasum":"d77b5a1bff4893ebfe18f76dae47cf569b2ceb1b"},{"_id":"public/tag/noip/page/2/index.html","modified":1483685942527,"shasum":"f07bafadc0b94724d6b72ad06354e7246b58bb6e"},{"_id":"public/tag/noip/page/3/index.html","modified":1483685942549,"shasum":"1d488081d07668fad3ff9159df5c2035f43c93e5"},{"_id":"public/tag/前缀和/index.html","modified":1483685942585,"shasum":"d40d1d8420e034273d8c4872fdb1632891f0a7da"},{"_id":"public/tag/队列/index.html","modified":1483685942622,"shasum":"b3e7c0d3e166f3768c605e77193a321204994034"},{"_id":"public/tag/floyd/index.html","modified":1483685942654,"shasum":"8ab760e48b22e3e0aff9a5550c6eb016aea25221"},{"_id":"public/tag/状态压缩/index.html","modified":1483685942680,"shasum":"16be2f373f17dbbf056e90324cf274f127357df1"},{"_id":"public/tag/bfs/index.html","modified":1483685942726,"shasum":"90bb6a4c6951b72d34903127601cab359ab11f4c"},{"_id":"public/tag/hash/index.html","modified":1483685942762,"shasum":"035ed236af25d1be829c48ab8e2d04a7be53a24b"},{"_id":"public/tag/spfa/index.html","modified":1483685942788,"shasum":"e21a2a0232e8e8b3d34f07d617932d3d3d7b1060"},{"_id":"public/tag/逆序对/index.html","modified":1483685942806,"shasum":"0c63acf46a9fa351a07a65cf326508fcb06d9b1d"},{"_id":"public/tag/二分/index.html","modified":1483685942832,"shasum":"d0955287996e2fa526b4b4295f1157847a80c4e8"},{"_id":"public/tag/差分/index.html","modified":1483685942857,"shasum":"7913e5f149506654603af1b3aeddb01b731aac8a"},{"_id":"public/tag/vijos/index.html","modified":1483685942874,"shasum":"9198a662d1cb35280f385c6bb48839d7758219de"},{"_id":"public/tag/洛谷/index.html","modified":1483685942905,"shasum":"b274e5827e9cb7840080391f7ed4374f29d4ff66"},{"_id":"public/tag/二分图染色/index.html","modified":1483685942929,"shasum":"130688381acff964236ecb65853ceb2406a08d94"},{"_id":"public/tag/线性-dp/index.html","modified":1483685942954,"shasum":"6ebadf649f07b966f6efa43e0f96a24233705b7e"},{"_id":"public/tag/noi/index.html","modified":1483685943013,"shasum":"f4f509363bb306dc2cadaa9960dc6bdd6230e341"},{"_id":"public/tag/noi/page/2/index.html","modified":1483685943076,"shasum":"572c8635179586b908cc233d985b6b03fc391cc1"},{"_id":"public/tag/离散化/index.html","modified":1483685943092,"shasum":"d3db6035cb213f2d5c4afd0fb30b43821c68a252"},{"_id":"public/tag/哈希/index.html","modified":1483685943104,"shasum":"27aa027e1dab98268597b02fe90b1474ed30ea14"},{"_id":"public/tag/map/index.html","modified":1483685943135,"shasum":"5776e09eebc510cc53860a09d695d7aa161ebc80"},{"_id":"public/tag/上下界网络流/index.html","modified":1483685943171,"shasum":"fa8d0661d6ee727bb4b50f27982fc3270f1e3b1b"},{"_id":"public/tag/哈夫曼树/index.html","modified":1483685943196,"shasum":"e052180b0b200b7856f9993726971a58d889744f"},{"_id":"public/tag/堆/index.html","modified":1483685943219,"shasum":"e052180b0b200b7856f9993726971a58d889744f"},{"_id":"public/tag/lct/index.html","modified":1483685943241,"shasum":"39265bc35b5e1619e5f537fc2abfba2382354dc8"},{"_id":"public/tag/坐标变换/index.html","modified":1483685943272,"shasum":"d28c4ae73c9f2c7ec04a92cd3ac6b8945395cf45"},{"_id":"public/tag/二维树状数组/index.html","modified":1483685943288,"shasum":"d28c4ae73c9f2c7ec04a92cd3ac6b8945395cf45"},{"_id":"public/tag/最大权闭合图/index.html","modified":1483685943345,"shasum":"d79a58347720871fe21770354f7b72717948f03d"},{"_id":"public/tag/点分治/index.html","modified":1483685943382,"shasum":"99f76d55738d69a678c1fe13890248a5b4358061"},{"_id":"public/tag/莫队/index.html","modified":1483685943421,"shasum":"7615782432a0ce79f7a8c7915048b6a46b9f08a9"},{"_id":"public/tag/kruskal/index.html","modified":1483685943433,"shasum":"6459a03343428a3998af8226feeca06efae15ab5"},{"_id":"public/tag/最小生成树/index.html","modified":1483685943466,"shasum":"2ef2bcc9175bc07a127573c4d0ff634cb580040f"},{"_id":"public/tag/manacher/index.html","modified":1483685943488,"shasum":"2e360bc100ead1f603e2feb99cdfcf01f4acfb31"},{"_id":"public/tag/jsoi/index.html","modified":1483685943534,"shasum":"1097533ea7f360c30f04ea3bd68d377c13909067"},{"_id":"public/tag/jsoi/page/2/index.html","modified":1483685943563,"shasum":"53c0e6e76931128ec08baec7eeaf81cb0b336527"},{"_id":"public/tag/高斯消元/index.html","modified":1483685943595,"shasum":"4eb389e071bd1bc2892ecc5c84529a519433817d"},{"_id":"public/tag/博弈/index.html","modified":1483685943612,"shasum":"4cc251649b6d3ef3d73ddd76bfe41beac7d1da88"},{"_id":"public/tag/枚举/index.html","modified":1483685943632,"shasum":"7ad9a4a8b8dbb7fb2a5db19962485c5a629f0911"},{"_id":"public/tag/ioi/index.html","modified":1483685943648,"shasum":"a8aeba768535fa5402f49c970a1731d3035c7895"},{"_id":"public/tag/基环树/index.html","modified":1483685943665,"shasum":"8c836b53da49442dc14c9ffb0377e12174c2f31e"},{"_id":"public/tag/hnoi/index.html","modified":1483685943713,"shasum":"825b8087d49b1626cefd078f9e0816a8de41e339"},{"_id":"public/tag/hnoi/page/2/index.html","modified":1483685943759,"shasum":"36b40f5b8885e0f1f86a7de0663dc70d528a6b69"},{"_id":"public/tag/dfs-序/index.html","modified":1483685943776,"shasum":"b5b80bff237cf98ce369d89d76b0649626806002"},{"_id":"public/tag/prufer-序列/index.html","modified":1483685943792,"shasum":"b1aa289e181b2b399433552fdd6f58842ba8954e"},{"_id":"public/tag/弦图/index.html","modified":1483685943810,"shasum":"07d8f6e657293e57a8d750319fb4c16416392872"},{"_id":"public/tag/最大势/index.html","modified":1483685943823,"shasum":"07d8f6e657293e57a8d750319fb4c16416392872"},{"_id":"public/tag/burnside-引理/index.html","modified":1483685943849,"shasum":"14f6560c28bca2c9e8ed8c57b7c81699b6dff36d"},{"_id":"public/tag/heoi/index.html","modified":1483685943878,"shasum":"96c29b7ffa3be2cf0116891aed33518995a032e1"},{"_id":"public/tag/hdu/index.html","modified":1483685943904,"shasum":"edc6e18925e4a9c6e67ced827ad5dab2a281667d"},{"_id":"public/tag/bestcoder/index.html","modified":1483685943923,"shasum":"ce22709a8f3eff2deabab41fd755933ad8c9e14d"},{"_id":"public/tag/haoi/index.html","modified":1483685943979,"shasum":"4f394d40a353f8eba0d8c438b8116f4dd9e5fa4a"},{"_id":"public/tag/haoi/page/2/index.html","modified":1483685944026,"shasum":"1d3d6c5c53146239e44331ef5fd39bb3d4aa0d3d"},{"_id":"public/tag/莫比乌斯反演/index.html","modified":1483685944042,"shasum":"78a69b38c9cdf5e1b73f920af47de5e5ec28a644"},{"_id":"public/tag/gdb/index.html","modified":1483685944052,"shasum":"e7cb8f4e7bd974950f709c7fb42d271bd0900673"},{"_id":"public/tag/调试/index.html","modified":1483685944073,"shasum":"e7cb8f4e7bd974950f709c7fb42d271bd0900673"},{"_id":"public/tag/计算几何/index.html","modified":1483692256801,"shasum":"885f815179bb25055be006b4d3735bf9355d2a5b"},{"_id":"public/tag/fjoi/index.html","modified":1483685944113,"shasum":"48e35c94f8e4cfd47ee7199b5710fec82e126994"},{"_id":"public/tag/多项式/index.html","modified":1483685944133,"shasum":"a2cd2e5cc1334caede534007ed88e0a3e08674d9"},{"_id":"public/tag/欧拉回路/index.html","modified":1483685944159,"shasum":"d703b8662a031d03d6376e0b024a30f11c7177ce"},{"_id":"public/tag/docker/index.html","modified":1483685944180,"shasum":"6b6a6c7584ed5e9512450fd000dcf2c97b2eef4e"},{"_id":"public/tag/评测系统/index.html","modified":1483685944192,"shasum":"6b6a6c7584ed5e9512450fd000dcf2c97b2eef4e"},{"_id":"public/tag/ctsc/index.html","modified":1483685944215,"shasum":"d41eee9936e21e63aab7785870532933655843d6"},{"_id":"public/tag/网络流-24-题/index.html","modified":1483685944256,"shasum":"6a23dd62f3f6e4c7d7d6fff93e59765564821011"},{"_id":"public/tag/网络流-24-题/page/2/index.html","modified":1483685944299,"shasum":"421fb1bd83bc49c06211ab44276679c1ae4673dc"},{"_id":"public/tag/cqoi/index.html","modified":1483685944332,"shasum":"564f467d9efbdd3914bdf43db26f1dd494bb3cc6"},{"_id":"public/tag/最大独立集/index.html","modified":1483685944356,"shasum":"b8bb12c555897d061051e59d7cd4428693d0afaf"},{"_id":"public/tag/记忆化搜索/index.html","modified":1483685944377,"shasum":"ac948f3878b316ace63d160b9bada0a4dcf789af"},{"_id":"public/tag/usaco/index.html","modified":1483685944425,"shasum":"9e2fab0ba97735170dab52865aae2081a8247905"},{"_id":"public/tag/coci/index.html","modified":1483685944457,"shasum":"7a9c84077bf01c3a6c952f133742bb249575afbd"},{"_id":"public/tag/树上路径并/index.html","modified":1483685944481,"shasum":"7a9c84077bf01c3a6c952f133742bb249575afbd"},{"_id":"public/tag/codeforces/index.html","modified":1483685944507,"shasum":"e5178ea18c6fe7518f31e93077e078c9a82655f2"},{"_id":"public/tag/ceoi/index.html","modified":1483685944523,"shasum":"d2c014e5b222cfa4ecd977d16c47fba968d8f6f1"},{"_id":"public/tag/lucas-定理/index.html","modified":1483685944544,"shasum":"5ce385a91d2c5f1b35883444942961254be72259"},{"_id":"public/tag/链表/index.html","modified":1483685944558,"shasum":"0e189446148943e1efc7a32b0d67431bfd6c2772"},{"_id":"public/tag/栈/index.html","modified":1483685944577,"shasum":"4cfab61b0b9962c0fce8d6feff0d4ee079d8ee01"},{"_id":"public/tag/平衡树/index.html","modified":1483685944600,"shasum":"0fbeed93bce146e96f44dcb07242cedbdcb4fc9c"},{"_id":"public/tag/dijkstra/index.html","modified":1483685944623,"shasum":"e198980356554d1075ba918732eb6d08598676c8"},{"_id":"public/tag/割边/index.html","modified":1483685944635,"shasum":"c9293b2d42b7a9399260d3108d48d72c51c8a977"},{"_id":"public/tag/离散对数/index.html","modified":1483685944653,"shasum":"c2dfc5584f2d6e37524dbcc35ba7398ceac2507c"},{"_id":"public/tag/apio/index.html","modified":1483685944684,"shasum":"32efe5cea670fd6c4b8d3b247b4757f915361a2a"},{"_id":"public/tag/左偏树/index.html","modified":1483685944703,"shasum":"707525a087c9c5b4bcd8fde4dc4321312d88dfb5"},{"_id":"public/tag/dag/index.html","modified":1483685944731,"shasum":"c2e19ea4663cde9dcb7aa18bbd38708fff506321"},{"_id":"public/tag/最长路/index.html","modified":1483685944748,"shasum":"c2e19ea4663cde9dcb7aa18bbd38708fff506321"},{"_id":"public/tag/bellman-ford/index.html","modified":1483685944766,"shasum":"c2e19ea4663cde9dcb7aa18bbd38708fff506321"},{"_id":"public/tag/ahoi/index.html","modified":1483685944798,"shasum":"652ffd7955972725e090b3f27d229605972f5bbe"},{"_id":"public/tag/单调栈/index.html","modified":1483685944825,"shasum":"01a608007570645975bcbc6bc4765a60749b68bc"},{"_id":"public/tag/省队集训/index.html","modified":1483685944846,"shasum":"7685ef1b518b984d6c08f868d6cc1441a251f76e"},{"_id":"public/tag/块状链表/index.html","modified":1483685944870,"shasum":"7685ef1b518b984d6c08f868d6cc1441a251f76e"},{"_id":"public/tag/暴力/index.html","modified":1483685944897,"shasum":"4cfa5bcb09f1ee97699ed4d805db916eecbb7aea"},{"_id":"public/tag/二分查找/index.html","modified":1483685944910,"shasum":"b417cf2ad82a12cbb31c0dd6fb6a81f6986f2f72"},{"_id":"public/tag/扫描线/index.html","modified":1483685944927,"shasum":"59b373fcda4eba4b95d33aae671e18d245086e77"},{"_id":"source/_posts/geometry-notes/7.ggb","shasum":"664cb26c185c2c0366f0e066d3bedb2c3fb5ef53","modified":1483689811124},{"_id":"source/_posts/geometry-notes/7.svg","shasum":"c4a8ffe9d179dfc720ab34a8981813efb8c11be9","modified":1483689815008},{"_id":"public/geometry-notes/7.ggb","modified":1483692227150,"shasum":"664cb26c185c2c0366f0e066d3bedb2c3fb5ef53"},{"_id":"public/geometry-notes/7.svg","modified":1483692227153,"shasum":"c4a8ffe9d179dfc720ab34a8981813efb8c11be9"}],"Category":[{"name":"OI","_id":"cixlg9r7c0001ooxleudrxue8"},{"name":"Geek","_id":"cixlg9r9h0035ooxlomt7421m"},{"name":"Diary","_id":"cixlg9rcd0070ooxlp5rw7pai"}],"Data":[],"Page":[{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2016-09-10T05:42:23.025Z","updated":"2016-09-10T05:42:23.025Z","path":"tags/index.html","comments":1,"_id":"cixlg9r7n000dooxl7j1j5chd"},{"title":"Friends","date":"2016-01-18T13:08:05.000Z","_content":"\n<table width=\"100%\" id=\"oier\" style=\"text-align: center; \">\n<thead>\n<tr class=\"header\">\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td>[sxb_201](http://blog.csdn.net/sxb_201)</td>\n<td><span>齐河一中</span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span>青岛二中</span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span>东营一中</span></td>\n</tr>\n\n<tr>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span>雅礼中学</span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td>[Rapiz](https://www.zybuluo.com/rapiz/note/367932)</td>\n<td><span>郑州一中</span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span>安阳一中</span></td>\n</tr>\n\n<tr>\n<td>[Platypus](http://platypuspro.github.io/)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[Franky](http://www.cnblogs.com/Franky-ln/)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span>武汉二中</span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span>武汉二中</span></td>\n</tr>\n\n<tr>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span>成都七中</span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[凌风仙鸡](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[ShallWe](http://shallwe2000.cc/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[frank_c1](http://www.acyume.com/)</td>\n<td><span>学军中学</span></td>\n</tr>\n\n<tr>\n<td>[Krydom](http://krydom.com/)</td>\n<td><span>常州一中</span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# LYOI 2016\n[Edge](http://blog.u-pt.pw) [ilern](http://ilern.coding.me/428/) [yqy](https://yqy.moe) [Sulfur6](http://sulfur6.top/) [Roller](http://roller.coding.me/heyheyhey/) [x_shuai](http://x_shuai.leanote.com/) [Gavin](http://gavin_blog.leanote.com/) [Grape](http://bbs.u-pt.pw)\n\n# 其它\n\n[盒子の自留地](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n\n[Dimpurr](http://im.dimpurr.com/)\n","source":"friends.md","raw":"title: Friends\npermalink: friends/\ndate: 2016-01-18 21:08:05\n---\n\n<table width=\"100%\" id=\"oier\" style=\"text-align: center; \">\n<thead>\n<tr class=\"header\">\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td>[sxb_201](http://blog.csdn.net/sxb_201)</td>\n<td><span>齐河一中</span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span>青岛二中</span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span>东营一中</span></td>\n</tr>\n\n<tr>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span>雅礼中学</span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td>[Rapiz](https://www.zybuluo.com/rapiz/note/367932)</td>\n<td><span>郑州一中</span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span>安阳一中</span></td>\n</tr>\n\n<tr>\n<td>[Platypus](http://platypuspro.github.io/)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[Franky](http://www.cnblogs.com/Franky-ln/)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span>郑州外国语</span></td>\n</tr>\n\n<tr>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span>武汉二中</span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span>武汉二中</span></td>\n</tr>\n\n<tr>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span>成都七中</span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[凌风仙鸡](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[ShallWe](http://shallwe2000.cc/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[frank_c1](http://www.acyume.com/)</td>\n<td><span>学军中学</span></td>\n</tr>\n\n<tr>\n<td>[Krydom](http://krydom.com/)</td>\n<td><span>常州一中</span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# LYOI 2016\n[Edge](http://blog.u-pt.pw) [ilern](http://ilern.coding.me/428/) [yqy](https://yqy.moe) [Sulfur6](http://sulfur6.top/) [Roller](http://roller.coding.me/heyheyhey/) [x_shuai](http://x_shuai.leanote.com/) [Gavin](http://gavin_blog.leanote.com/) [Grape](http://bbs.u-pt.pw)\n\n# 其它\n\n[盒子の自留地](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n\n[Dimpurr](http://im.dimpurr.com/)\n","updated":"2016-10-15T13:43:52.349Z","path":"friends/index.html","comments":1,"layout":"page","_id":"cixlg9r7r000eooxl2js6cb38"},{"title":"About Me","date":"2015-11-22T21:36:32.000Z","_content":"\n一只学 OI 的~~可爱的~~男孩子，~~大家可以叫我黄学弟~~。\n\n来自山东省临沂一中，目前高一，从 2015 年 8 月开始学 OI。\n\n没有进省队。\n\n<!-- 想要拿 NOI 金牌。 -->\n\n> 用这灿烂时光，绽放不一样的光。\n","source":"about-me.md","raw":"title: About Me\npermalink: about-me/\ndate: 2015-11-23 05:36:32\n---\n\n一只学 OI 的~~可爱的~~男孩子，~~大家可以叫我黄学弟~~。\n\n来自山东省临沂一中，目前高一，从 2015 年 8 月开始学 OI。\n\n没有进省队。\n\n<!-- 想要拿 NOI 金牌。 -->\n\n> 用这灿烂时光，绽放不一样的光。\n","updated":"2016-05-20T12:39:29.758Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"cixlg9r7t000fooxldkjaeodp"}],"Post":[{"title":"「省选模拟赛」染色 - 树链剖分","date":"2016-03-20T15:07:32.000Z","_content":"\n给定一棵 $ n $ 个节点的树，树的节点标号从 $ 0 $ 开始。每个节点可以是白色或黑色，初始时每个节点的颜色为白色。要求支持以下两种操作：\n\n1. 将节点 $ x $ 涂黑；\n2. 查询节点 $ x $ 到所有黑点距离之和。\n\n<!-- more -->\n\n### 题解\n先预处理出所有点到根的距离之和，维护当前所有黑点到根的距离之和 $ sum $ 和黑点总数 $ count $。\n\n考虑询问由根节点的向它的某个子节点 u 移动，则答案为：\n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n即\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n树链剖分，用线段树维护 $ count(u) * d_i $ 在链上的总和，每次 $ O(log ^ 2 n) $ 计算。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","source":"_posts/20160318-color.md","raw":"title: 「省选模拟赛」染色 - 树链剖分\ncategories: OI\ntags: \n  - 安徽集训\n  - 树链剖分\n  - 线段树\n  - 数据结构\n  - 高级数据结构\npermalink: 20160318-color\ndate: 2016-03-20 23:07:32\n---\n\n给定一棵 $ n $ 个节点的树，树的节点标号从 $ 0 $ 开始。每个节点可以是白色或黑色，初始时每个节点的颜色为白色。要求支持以下两种操作：\n\n1. 将节点 $ x $ 涂黑；\n2. 查询节点 $ x $ 到所有黑点距离之和。\n\n<!-- more -->\n\n### 题解\n先预处理出所有点到根的距离之和，维护当前所有黑点到根的距离之和 $ sum $ 和黑点总数 $ count $。\n\n考虑询问由根节点的向它的某个子节点 u 移动，则答案为：\n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n即\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n树链剖分，用线段树维护 $ count(u) * d_i $ 在链上的总和，每次 $ O(log ^ 2 n) $ 计算。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","slug":"20160318-color","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r760000ooxlll2vxp8k"},{"title":"「ZJOI2014」力 - FFT","date":"2016-06-11T13:27:00.000Z","_content":"\n已知\n\n$$ E_i = \\frac{F_i}{q_i} $$\n\n$$ F_j = \\sum\\limits_{i < j} \\frac{q_i q_j}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i q_j}{(i - j) ^ 2}  $$\n\n求数列 $ E $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3527](http://www.lydsy.com/JudgeOnline/problem.php?id=3527)\n\n### 题解\n由题意得\n\n$$ E_j = \\sum\\limits_{i < j} \\frac{q_i}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i}{(i - j) ^ 2} $$\n\n设 $ E_j = A_j - B_j $ 考虑前一半，它等价于\n\n$$ A_j = \\sum\\limits_{i = 1} ^ {j - 1} \\frac{q_j}{(i - j) ^ 2} $$\n\n考虑这样两个函数\n\n$$\ng(i) = \\begin{cases} \\frac{1}{i ^ 2} & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n$$\nf(i) = \\begin{cases} q_i & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n上式化为\n\n$$ A_j = \\sum\\limits_{i = 0} ^ {j} f(i) g(j - i) $$\n\n为~~多项式乘法~~卷积的形式，可以用 FFT 加速计算。\n\n同理，对于后一半，有\n\n$$ A_j = \\sum\\limits_{i = j + 1} ^ {n} \\frac{q_j}{(i - j) ^ 2} $$\n\n与 [BZOJ 2194](bzoj-2194) 一题相似，将 $ A $ 翻转后计算即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_EXTENDED = 262144;\nconst long double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<long double> omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<long double>(cosl(2 * PI / n * i), sinl(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<long double> *a, const int n, const std::complex<long double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[t], a[i]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<long double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<long double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid multiply(std::complex<long double> *a, std::complex<long double> *b, const int n) {\n\t\tint size = 1;\n\t\twhile (size < n * 2) size *= 2;\n\n\t\t/*\n\t\tstatic std::complex<long double> c[MAXN_EXTENDED];\n\t\tfor (int i = 0; i < n; i++) c[i] = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i <= j; i++) {\n\t\t\t\tc[j] += a[i] * b[j - i];\n\t\t\t}\n\t\t}\n\n\t\tstd::copy(c, c + n, a);\n\t\treturn;\n\t\t*/\n\n\t\tinit(size);\n\n\t\tdft(a, size);\n\t\tdft(b, size);\n\n\t\tfor (int i = 0; i < size; i++) a[i] *= b[i];\n\n\t\tidft(a, size);\n\t}\n} fft;\n\nint n;\nlong double q[MAXN + 1];\n\ninline void calc(const long double *q, long double *E) {\n\tstatic std::complex<long double> f[MAXN_EXTENDED], g[MAXN_EXTENDED];\n\tstd::fill(f, f + MAXN_EXTENDED, 0);\n\tstd::fill(g, g + MAXN_EXTENDED, 0);\n\tstd::copy(q, q + n + 1, f);\n\tf[0] = g[0] = std::complex<long double>(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[i] = std::complex<long double>(1.0 / pow(i, 2), 0);\n\t}\n\n\tfft.multiply(f, g, n + 1);\n\tfor (int i = 1; i <= n; i++) E[i] = f[i].real();\n\n\t/*\n\tfor (int i = 0; i < (n + 1) * 2; i++) printf(\"* %lf\\n\", static_cast<double>(f[i].real()));\n\tputchar('\\n');\n\n\treturn;\n\n\tstatic std::complex<long double> r[MAXN_EXTENDED];\n\tfor (int j = 0; j <= n; j++) {\n\t\tr[j] = 0;\n\t\tfor (int i = 0; i <= j; i++) {\n\t\t\tr[j] += f[i] * g[j - i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) printf(\"* %lf\\n\", static_cast<double>(r[i].real()));\n\tputchar('\\n');\n\n\tfor (int i = 1; i <= n; i++) E[i] = r[i].real();\n\t*/\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdouble x;\n\t\tscanf(\"%lf\", &x);\n\t\tq[i] = x;\n\t}\n\n\tstatic long double E1[MAXN + 1], E2[MAXN + 1];\n\tcalc(q, E1);\n\tstd::reverse(q + 1, q + n + 1);\n\tcalc(q, E2);\n\n\tfor (int i = 1; i <= n; i++) printf(\"%.3lf\\n\", static_cast<double>(E1[i] - E2[n - i + 1]));\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2014-force.md","raw":"title: 「ZJOI2014」力 - FFT\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - FFT\n  - 数学\npermalink: zjoi2014-force\ndate: 2016-06-11 21:27:00\n---\n\n已知\n\n$$ E_i = \\frac{F_i}{q_i} $$\n\n$$ F_j = \\sum\\limits_{i < j} \\frac{q_i q_j}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i q_j}{(i - j) ^ 2}  $$\n\n求数列 $ E $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3527](http://www.lydsy.com/JudgeOnline/problem.php?id=3527)\n\n### 题解\n由题意得\n\n$$ E_j = \\sum\\limits_{i < j} \\frac{q_i}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i}{(i - j) ^ 2} $$\n\n设 $ E_j = A_j - B_j $ 考虑前一半，它等价于\n\n$$ A_j = \\sum\\limits_{i = 1} ^ {j - 1} \\frac{q_j}{(i - j) ^ 2} $$\n\n考虑这样两个函数\n\n$$\ng(i) = \\begin{cases} \\frac{1}{i ^ 2} & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n$$\nf(i) = \\begin{cases} q_i & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n上式化为\n\n$$ A_j = \\sum\\limits_{i = 0} ^ {j} f(i) g(j - i) $$\n\n为~~多项式乘法~~卷积的形式，可以用 FFT 加速计算。\n\n同理，对于后一半，有\n\n$$ A_j = \\sum\\limits_{i = j + 1} ^ {n} \\frac{q_j}{(i - j) ^ 2} $$\n\n与 [BZOJ 2194](bzoj-2194) 一题相似，将 $ A $ 翻转后计算即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_EXTENDED = 262144;\nconst long double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<long double> omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<long double>(cosl(2 * PI / n * i), sinl(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<long double> *a, const int n, const std::complex<long double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[t], a[i]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<long double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<long double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid multiply(std::complex<long double> *a, std::complex<long double> *b, const int n) {\n\t\tint size = 1;\n\t\twhile (size < n * 2) size *= 2;\n\n\t\t/*\n\t\tstatic std::complex<long double> c[MAXN_EXTENDED];\n\t\tfor (int i = 0; i < n; i++) c[i] = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i <= j; i++) {\n\t\t\t\tc[j] += a[i] * b[j - i];\n\t\t\t}\n\t\t}\n\n\t\tstd::copy(c, c + n, a);\n\t\treturn;\n\t\t*/\n\n\t\tinit(size);\n\n\t\tdft(a, size);\n\t\tdft(b, size);\n\n\t\tfor (int i = 0; i < size; i++) a[i] *= b[i];\n\n\t\tidft(a, size);\n\t}\n} fft;\n\nint n;\nlong double q[MAXN + 1];\n\ninline void calc(const long double *q, long double *E) {\n\tstatic std::complex<long double> f[MAXN_EXTENDED], g[MAXN_EXTENDED];\n\tstd::fill(f, f + MAXN_EXTENDED, 0);\n\tstd::fill(g, g + MAXN_EXTENDED, 0);\n\tstd::copy(q, q + n + 1, f);\n\tf[0] = g[0] = std::complex<long double>(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[i] = std::complex<long double>(1.0 / pow(i, 2), 0);\n\t}\n\n\tfft.multiply(f, g, n + 1);\n\tfor (int i = 1; i <= n; i++) E[i] = f[i].real();\n\n\t/*\n\tfor (int i = 0; i < (n + 1) * 2; i++) printf(\"* %lf\\n\", static_cast<double>(f[i].real()));\n\tputchar('\\n');\n\n\treturn;\n\n\tstatic std::complex<long double> r[MAXN_EXTENDED];\n\tfor (int j = 0; j <= n; j++) {\n\t\tr[j] = 0;\n\t\tfor (int i = 0; i <= j; i++) {\n\t\t\tr[j] += f[i] * g[j - i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) printf(\"* %lf\\n\", static_cast<double>(r[i].real()));\n\tputchar('\\n');\n\n\tfor (int i = 1; i <= n; i++) E[i] = r[i].real();\n\t*/\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdouble x;\n\t\tscanf(\"%lf\", &x);\n\t\tq[i] = x;\n\t}\n\n\tstatic long double E1[MAXN + 1], E2[MAXN + 1];\n\tcalc(q, E1);\n\tstd::reverse(q + 1, q + n + 1);\n\tcalc(q, E2);\n\n\tfor (int i = 1; i <= n; i++) printf(\"%.3lf\\n\", static_cast<double>(E1[i] - E2[n - i + 1]));\n\n\treturn 0;\n}\n```\n","slug":"zjoi2014-force","published":1,"updated":"2016-06-12T01:30:38.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r7v000gooxlu86flrpb"},{"title":"「ZJOI2010」网络扩容 - 网络流 + 费用流","date":"2016-06-21T00:48:00.000Z","_content":"\n给定一张有向图，每条边都有一个容量 $ C $ 和一个扩容费用 $ W $。这里扩容费用是指将容量扩大 $ 1 $ 所需的费用，求\n\n1. 在不扩容的情况下，$ 1 $ 到 $ N $ 的最大流；\n2. 将 $ 1 $ 到 $ N $ 的最大流增加 $ K $ 所需的最小扩容费用。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1834](http://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n### 题解\n第一问直接跑网络流。\n\n第二问，考虑扩容的实质是**增加**一条连接原来两个点的边，并且这条边费用为 $ W $。  \n将每一条边对应新增的边加入到残量网络中，限制流量为 $ K $ 跑最小费用流即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 5000;\nconst int MAXK = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c, *in;\n\tint l, d, f;\n\tbool q;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\n\t\tq.push(&N[s]);\n\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->in = e;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tstatic struct Edge {\n\t\tint s, t, c, w;\n\t} E[MAXM];\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tscanf(\"%d %d %d %d\", &e.s, &e.t, &e.c, &e.w);\n\t\taddEdge(e.s, e.t, e.c, 0);\n\t}\n\n\tint maxFlow = dinic(1, n, n + 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\taddEdge(e.s, e.t, INT_MAX, e.w);\n\t}\n\n\taddEdge(0, 1, k, 0);\n\n\tint flow, cost;\n\tedmondskarp(0, n, n + 1, flow, cost);\n\tprintf(\"%d %d\\n\", maxFlow, cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2010-network.md","raw":"title: 「ZJOI2010」网络扩容 - 网络流 + 费用流\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - 网络流\n  - Dinic\n  - 费用流\n  - Edmonds-Karp\npermalink: zjoi2010-network\ndate: 2016-06-21 08:48:00\n---\n\n给定一张有向图，每条边都有一个容量 $ C $ 和一个扩容费用 $ W $。这里扩容费用是指将容量扩大 $ 1 $ 所需的费用，求\n\n1. 在不扩容的情况下，$ 1 $ 到 $ N $ 的最大流；\n2. 将 $ 1 $ 到 $ N $ 的最大流增加 $ K $ 所需的最小扩容费用。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1834](http://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n### 题解\n第一问直接跑网络流。\n\n第二问，考虑扩容的实质是**增加**一条连接原来两个点的边，并且这条边费用为 $ W $。  \n将每一条边对应新增的边加入到残量网络中，限制流量为 $ K $ 跑最小费用流即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 5000;\nconst int MAXK = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c, *in;\n\tint l, d, f;\n\tbool q;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\n\t\tq.push(&N[s]);\n\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->in = e;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tstatic struct Edge {\n\t\tint s, t, c, w;\n\t} E[MAXM];\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tscanf(\"%d %d %d %d\", &e.s, &e.t, &e.c, &e.w);\n\t\taddEdge(e.s, e.t, e.c, 0);\n\t}\n\n\tint maxFlow = dinic(1, n, n + 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\taddEdge(e.s, e.t, INT_MAX, e.w);\n\t}\n\n\taddEdge(0, 1, k, 0);\n\n\tint flow, cost;\n\tedmondskarp(0, n, n + 1, flow, cost);\n\tprintf(\"%d %d\\n\", maxFlow, cost);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2010-network","published":1,"updated":"2016-06-21T00:49:12.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r80000qooxls99odt0h"},{"title":"「ZJOI2009」狼和羊的故事 - 最小割","date":"2016-06-23T10:23:00.000Z","_content":"\nOrez 的羊狼圈可以看作一个 $ n \\times m $ 个矩阵格子，这个矩阵的边缘已经装上了篱笆。他决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。 通过仔细观察，Orez 发现狼和羊都有属于自己领地，Orez 想要添加篱笆的尽可能的短。篱笆不能改变狼羊的所属领地，篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1412](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)\n\n### 题解\n从源点向狼的领地连边，容量正无穷，从羊的领地向汇点连边，容量正无穷；相邻格子连无向边。最小割即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (x == 1) addEdge(s, id(i, j), INT_MAX);\n\t\t\telse if (x == 2) addEdge(id(i, j), t, INT_MAX);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), 1);\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), 1);\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), 1);\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), 1);\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2009-ws.md","raw":"title: 「ZJOI2009」狼和羊的故事 - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: zjoi2009-ws\ndate: 2016-06-23 18:23:00\n---\n\nOrez 的羊狼圈可以看作一个 $ n \\times m $ 个矩阵格子，这个矩阵的边缘已经装上了篱笆。他决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。 通过仔细观察，Orez 发现狼和羊都有属于自己领地，Orez 想要添加篱笆的尽可能的短。篱笆不能改变狼羊的所属领地，篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1412](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)\n\n### 题解\n从源点向狼的领地连边，容量正无穷，从羊的领地向汇点连边，容量正无穷；相邻格子连无向边。最小割即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (x == 1) addEdge(s, id(i, j), INT_MAX);\n\t\t\telse if (x == 2) addEdge(id(i, j), t, INT_MAX);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), 1);\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), 1);\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), 1);\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), 1);\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2009-ws","published":1,"updated":"2016-06-23T10:23:36.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r880012ooxly9xlvj0j"},{"title":"「ZJOI2008」生日聚会 - DP","date":"2016-11-13T02:00:00.000Z","_content":"\n对于任意连续的一段，男孩与女孩的数目之差不超过 $ k $。假设参加 party 的人中共有 $ n $ 个男孩与 $ m $ 个女孩，求方案总数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1037](http://www.lydsy.com/JudgeOnline/problem.php?id=1037)\n\n### 题解\n设 $ f(i, j, p, q) $ 表示前 $ i $ 个人中，有 $ j $ 个男孩，包含第 $ i $ 个人的连续区间中，男孩最多比女孩多 $ p $ 个，女孩最多比男孩多 $ q $ 个，的方案数。\n\n如果第 $ i $ 个是男孩\n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j + 1, p + 1, \\max(q - 1, 0)) $$\n\n\n如果第 $ i $ 个是男孩\n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j, \\max(p - 1, 0), q + 1) $$\n\n答案即为 $ \\sum\\limits_{p = 0} ^ k \\sum\\limits_{q = 0} ^ k f(n + m, n, p, q) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 150;\nconst int MAXK = 20;\nconst int MOD = 12345678;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t// f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q\n\tstatic int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2];\n\tf[0][0][0][0] = 1;\n\tfor (int i = 0; i < n + m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tfor (int q = 0; q <= k; q++) {\n\t\t\t\t\t// Add a boy\n\t\t\t\t\t(f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD;\n\t\t\t\t\t// Add a girl\n\t\t\t\t\t(f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int p = 0; p <= k; p++) for (int q = 0; q <= k; q++) (ans += f[n + m][n][p][q]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2008-party.md","raw":"title: 「ZJOI2008」生日聚会 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - DP\npermalink: zjoi2008-party\ndate: 2016-11-13 10:00:00\n---\n\n对于任意连续的一段，男孩与女孩的数目之差不超过 $ k $。假设参加 party 的人中共有 $ n $ 个男孩与 $ m $ 个女孩，求方案总数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1037](http://www.lydsy.com/JudgeOnline/problem.php?id=1037)\n\n### 题解\n设 $ f(i, j, p, q) $ 表示前 $ i $ 个人中，有 $ j $ 个男孩，包含第 $ i $ 个人的连续区间中，男孩最多比女孩多 $ p $ 个，女孩最多比男孩多 $ q $ 个，的方案数。\n\n如果第 $ i $ 个是男孩\n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j + 1, p + 1, \\max(q - 1, 0)) $$\n\n\n如果第 $ i $ 个是男孩\n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j, \\max(p - 1, 0), q + 1) $$\n\n答案即为 $ \\sum\\limits_{p = 0} ^ k \\sum\\limits_{q = 0} ^ k f(n + m, n, p, q) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 150;\nconst int MAXK = 20;\nconst int MOD = 12345678;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t// f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q\n\tstatic int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2];\n\tf[0][0][0][0] = 1;\n\tfor (int i = 0; i < n + m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tfor (int q = 0; q <= k; q++) {\n\t\t\t\t\t// Add a boy\n\t\t\t\t\t(f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD;\n\t\t\t\t\t// Add a girl\n\t\t\t\t\t(f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int p = 0; p <= k; p++) for (int q = 0; q <= k; q++) (ans += f[n + m][n][p][q]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"zjoi2008-party","published":1,"updated":"2016-11-13T02:13:03.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8b001aooxlsxcj7zkb"},{"title":"「ZJOI2008」泡泡堂 - 贪心","date":"2016-11-13T01:53:00.000Z","_content":"\n两队分别 $ n $ 个选手对战，已知每个选手的实力，实力强的选手一定获胜。每一场胜、平、败的得分分别为 $ 2, 1, 0 $。求一个队能获得的最高得分和最低得分。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034)\n\n### 题解\n贪心，从弱到强考虑队伍 A 中的每一个人，如果它可以战胜 B 中的某一个人，则让它战胜 B 中它能战胜的最强的人。最后考虑 A 中剩余的人，尽量让这些人和 B 中的人平局。\n\n证明略。\n\n### 代码\n```c++\n#include <cstdio>\n#include <set>\n\nconst int MAXN = 100000;\n\nint n;\n\ninline int solve(const int *a, const int *b) {\n\tstd::multiset<int> sa, sb;\n\tfor (int i = 0; i < n; i++) sa.insert(a[i]), sb.insert(b[i]);\n\n\tint ans = 0;\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); ) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (target == sb.begin()) {\n\t\t\tit++;\n\t\t} else {\n\t\t\ttarget--;\n\t\t\tsb.erase(target);\n\t\t\tsa.erase(it++);\n\t\t\tans += 2;\n\t\t}\n\t}\n\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); it++) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (*target == *it) sb.erase(target), ans++;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\t/*\n\tstd::sort(a, a + n);\n\tstd::sort(b, b + n);\n\t*/\n\n\tprintf(\"%d %d\\n\", solve(a, b), n * 2 - solve(b, a));\n\t\n\treturn 0;\n}\n```","source":"_posts/zjoi2008-bnb.md","raw":"title: 「ZJOI2008」泡泡堂 - 贪心\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - 贪心\npermalink: zjoi2008-bnb\ndate: 2016-11-13 09:53:00\n---\n\n两队分别 $ n $ 个选手对战，已知每个选手的实力，实力强的选手一定获胜。每一场胜、平、败的得分分别为 $ 2, 1, 0 $。求一个队能获得的最高得分和最低得分。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034)\n\n### 题解\n贪心，从弱到强考虑队伍 A 中的每一个人，如果它可以战胜 B 中的某一个人，则让它战胜 B 中它能战胜的最强的人。最后考虑 A 中剩余的人，尽量让这些人和 B 中的人平局。\n\n证明略。\n\n### 代码\n```c++\n#include <cstdio>\n#include <set>\n\nconst int MAXN = 100000;\n\nint n;\n\ninline int solve(const int *a, const int *b) {\n\tstd::multiset<int> sa, sb;\n\tfor (int i = 0; i < n; i++) sa.insert(a[i]), sb.insert(b[i]);\n\n\tint ans = 0;\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); ) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (target == sb.begin()) {\n\t\t\tit++;\n\t\t} else {\n\t\t\ttarget--;\n\t\t\tsb.erase(target);\n\t\t\tsa.erase(it++);\n\t\t\tans += 2;\n\t\t}\n\t}\n\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); it++) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (*target == *it) sb.erase(target), ans++;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\t/*\n\tstd::sort(a, a + n);\n\tstd::sort(b, b + n);\n\t*/\n\n\tprintf(\"%d %d\\n\", solve(a, b), n * 2 - solve(b, a));\n\t\n\treturn 0;\n}\n```","slug":"zjoi2008-bnb","published":1,"updated":"2016-11-13T01:53:48.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8j001gooxl5xhuodpp"},{"title":"「ZJOI2008」杀蚂蚁 - 模拟 + 几何","date":"2016-05-23T13:26:00.000Z","_content":"\n题面见[杀蚂蚁的可读版本](https://www.zybuluo.com/Jerusalem/note/221811)。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1033](http://www.lydsy.com/JudgeOnline/problem.php?id=1033)  \n[COGS 2048](http://cogs.top/cogs/problem/problem.php?pid=2048)\n\n### 题解\n根据题意模拟即可 ……\n\n唯一的难点是判断线段和圆的交点。先过圆心做线段的垂线，判断与线段是否有交点，如果有，则设点到线段距离为 $ a $，圆心与线段端点距离的较大值为 $ b $；否则设圆心与线段距离较小值为 $ a $，较大值为 $ b $。\n\n满足\n\n$$\n\\begin{cases}\na \\leq r \\\\\nb \\gt r\n\\end{cases}\n$$\n\n即可\n\n保存直线的时候可以用斜截式，但注意斜率不存在和斜率为零的特判。\n\n还有就是不要**写错变量名** ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <list>\n#include <algorithm>\n\ntypedef long double real;\n\nconst int MAXN = 8;\nconst int MAXM = 8;\nconst int MAXS = 20;\nconst int MAXT = 200000;\nconst real EPS = 1e-6;\n\nint n, m, s, d, r, t, time;\n\nstruct Map {\n\tint message;\n\tbool reachable;\n\n\tMap() : message(0), reachable(true) {}\n} map[MAXN + 1][MAXM + 1];\n\ntemplate <typename T>\nstruct Point {\n\tT x, y;\n\n\tPoint(const T x = 0, const T y = 0) : x(x), y(y) {}\n\n\tMap *operator->() const { return &map[static_cast<int>(x)][static_cast<int>(y)]; }\n\n\tPoint offset(const int id) const {\n\t\tswitch (id) {\n\t\t\tcase 0: return Point(x, y + 1);\n\t\t\tcase 1: return Point(x + 1, y);\n\t\t\tcase 2: return Point(x, y - 1);\n\t\t\tcase 3: return Point(x - 1, y);\n\t\t\tdefault: return *this;\n\t\t}\n\t}\n\n\tbool valid() const { return x >= 0 && x <= n && y >= 0 && y <= m; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\n\ninline bool dcmp(const real a) { return fabs(a) <= EPS; }\ninline bool dcmp(const real a, const real b) { return dcmp(a - b); }\n\ninline bool isnan(const real x) { return x != x; }\ninline bool isinf(const real x) { return !isnan(x) && isnan(x - x); }\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ntemplate <typename Ta, typename Tb>\ninline real distance(const Point<Ta> a, const Point<Tb> b) {\n\treturn sqrt(static_cast<real>(sqr(a.x - b.x) + sqr(a.y - b.y)));\n}\n\nstruct Ant {\n\tPoint<int> position, lastPosition;\n\tint level;\n\tint hpLimit, hp;\n\tbool hasCake;\n\tint spawnTime;\n\n\tAnt(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) {\n\t\t// printf(\"spawn Ant(%d)\\n\", level);\n\t\tposition->reachable = false;\n\t}\n\n\tinline void moveTo(const Point<int> &nextPosition) {\n\t\tlastPosition = position;\n\t\tposition = nextPosition;\n\t\tif (lastPosition == position) return;\n\t\t// printf(\"moveTo(): from [%d, %d] to [%d, %d]\\n\", lastPosition.x, lastPosition.y, position.x, position.y);\n\t\tlastPosition->reachable = true;\n\t\tposition->reachable = false;\n\t}\n\n\tinline int age() const {\n\t\treturn time - spawnTime;\n\t}\n\n\tinline bool attackable(const Point<int> &p) {\n\t\tconst real dist = distance(position, p);\n\t\treturn dist < r || dcmp(dist, r);\n\t}\n};\n\nstruct Line {\n\treal k, b;\n\n\t/*\n\t * k != nan: y = kx + b\n\t * k == nan: x = b\n\t */\n\n\tLine(const Point<int> &p1, const Point<int> &p2) {\n\t\tconst real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\t\tif (x1 == x2) {\n\t\t\tk = NAN;\n\t\t\tb = x1;\n\t\t} else {\n\t\t\tk = (y2 - y1) / (x2 - x1);\n\t\t\tb = y1 - k * x1;\n\t\t}\n\t}\n\n\tLine(const real k, const Point<int> &p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {}\n\n\tLine(const real k, const real b) : k(k), b(b) {}\n\n\tLine perpendicular(const Point<int> &p1) const {\n\t\tif (isnan(k)) return Line(0, p1.y);\n\t\telse return Line(-1.0 / k, p1);\n\t}\n};\n\nstruct Segment {\n\tPoint<int> p1, p2;\n\tLine line;\n\treal length;\n\n\tSegment(const Point<int> &p1, const Point<int> &p2) : p1(p1), p2(p2), line(p1, p2) {\n\t\tlength = distance(p1, p2);\n\t}\n};\n\nPoint<real> lineIntersection(const Line &a, const Line &b) {\n\tif (isnan(a.k) && isnan(b.k) || a.k == b.k) throw;\n\tif (isnan(a.k)) return Point<real>(a.b, a.b * b.k + b.b);\n\tif (isnan(b.k)) return Point<real>(b.b, b.b * a.k + a.b);\n\tconst real x = (b.b - a.b) / (a.k - b.k);\n\tconst real y = a.k * x + a.b;\n\treturn Point<real>(x, y);\n}\n\nbool pointOnSegment(const Point<real> &p, const Segment &s) {\n\treturn dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length);\n}\n\nbool segmentCircleIntersection(const Segment &s, const Point<int> &p, const real r) {\n\tLine v = s.line.perpendicular(p);\n\tPoint<real> is = lineIntersection(v, s.line);\n\treal min, max;\n\tif (pointOnSegment(is, s)) {\n\t\tmin = distance(is, p);\n\t\tmax = std::max(distance(is, s.p1), distance(is, s.p2));\n\t} else {\n\t\tmin = distance(p, s.p1);\n\t\tmax = distance(p, s.p2);\n\t\tif (min > max) std::swap(min, max);\n\t}\n\n\treturn (min < r || dcmp(min, r)) && (max > r || dcmp(max, r));\n}\n\nstd::list<Ant> ants;\nstd::list<Ant>::iterator cakeOwner = ants.end();\nPoint<int> towers[MAXS];\n\ninline void spawn() {\n\tif (ants.size() < 6) {\n\t\tif (map[0][0].reachable == false) return;\n\n\t\tstatic int cnt = -1;\n\t\tcnt++;\n\t\tants.push_back(Ant(cnt / 6 + 1));\n\t}\n}\n\ninline void incMessage() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tit->position->message += it->hasCake ? 5 : 2;\n\t}\n}\n\ninline void move() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"move(): _cnt = %d\\n\", _cnt);\n\n\t\tint id = -1;\n\t\t// printf(\"move(): lastPosition = [%d, %d]\\n\", it->lastPosition.x, it->lastPosition.y);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint<int> newPosition = it->position.offset(i);\n\n\t\t\tif (!newPosition.valid()) continue;\n\t\t\tif (newPosition == it->lastPosition) continue;\n\t\t\tif (!newPosition->reachable) continue;\n\n\t\t\tif (id == -1 || newPosition->message > it->position.offset(id)->message) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\n\t\t// if (id != -1) printf(\"move(): checking moving to [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\n\t\tif (id != -1 && (it->age() + 1) % 5 == 0) {\n\t\t\t// printf(\"move(): special, before = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t\tPoint<int> newPosition;\n\t\t\tdo {\n\t\t\t\tid = (id - 1 + 4) % 4;\n\t\t\t\tnewPosition = it->position.offset(id);\n\t\t\t} while (!newPosition.valid() || !newPosition->reachable || newPosition == it->lastPosition);\n\t\t\t// printf(\"move(): special, after = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t}\n\n\t\tit->moveTo(it->position.offset(id));\n\t}\n}\n\ninline void getCake() {\n\tif (cakeOwner != ants.end()) return;\n\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(n, m)) {\n\t\t\tcakeOwner = it;\n\t\t\tit->hasCake = true;\n\t\t\tit->hp = std::min(it->hpLimit, it->hp + it->hpLimit / 2);\n\t\t\t// puts(\"getCake(): got\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void attack() {\n\tfor (int i = 0; i < s; i++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"attack(): _cnt = %d\\n\", _cnt);\n\n\t\tstd::list<Ant>::iterator target = ants.end();\n\t\tif (cakeOwner != ants.end() && cakeOwner->attackable(towers[i])) {\n\t\t\ttarget = cakeOwner;\n\t\t}\n\n\t\tif (target == ants.end()) {\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\treal d = distance(it->position, towers[i]);\n\t\t\t\tif ((d < r || dcmp(d, r)) && (target == ants.end() || distance(it->position, towers[i]) < distance(target->position, towers[i]))) {\n\t\t\t\t\ttarget = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (target != ants.end()) {\n\t\t\ttarget->hp -= d;\n\t\t\tSegment s(towers[i], target->position);\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\tif (it != target && segmentCircleIntersection(s, it->position, 0.5)) {\n\t\t\t\t\t// printf(\"attack(): _cnt = %d, through [%d, %d]\\n\", _cnt, it->position.x, it->position.y);\n\t\t\t\t\tit->hp -= d;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if (it == target) printf(\"attack(): _cnt = %d, target [%d, %d]\\n\", _cnt, target->position.x, target->position.y);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void kill() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); ) {\n\t\tif (it->hp < 0) {\n\t\t\tit->position->reachable = true;\n\t\t\tif (it == cakeOwner) cakeOwner = ants.end();\n\t\t\tit = ants.erase(it);\n\t\t} else it++;\n\t}\n}\n\ninline bool check() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(0, 0) && it->hasCake) return false;\n\t}\n\n\treturn true;\n}\n\ninline void decMessage() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (map[i][j].message > 0) map[i][j].message--;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%d %d\\n%d %d %d\", &n, &m, &s, &d, &r);\n\tfor (int i = 0; i < s; i++) {\n\t\tscanf(\"%d %d\", &towers[i].x, &towers[i].y);\n\t\ttowers[i]->reachable = false;\n\t}\n\tscanf(\"%d\", &t);\n\n\ttime = 1;\n\tfor (; time <= t; time++) {\n\t\t// printf(\"main(): time = %d\\n\", time);\n\t\tspawn();\n\t\tincMessage();\n\t\tmove();\n\t\tgetCake();\n\t\tattack();\n\t\tkill();\n\t\tif (!check()) break;\n\t\tdecMessage();\n\n\t\t// for (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.y, it->position.x);\n\t\t// putchar('\\n');\n\t}\n\n\tif (time > t) puts(\"The game is going on\");\n\telse printf(\"Game over after %d seconds\\n\", time);\n\n\tprintf(\"%d\\n\", ants.size());\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.x, it->position.y);\n\n\tfclose(stdin);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2008-antbuster.md","raw":"title: 「ZJOI2008」杀蚂蚁 - 模拟 + 几何\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - 模拟\n  - 几何\n  - 数学\npermalink: zjoi2008-antbuster\ndate: 2016-05-23 21:26:00\n---\n\n题面见[杀蚂蚁的可读版本](https://www.zybuluo.com/Jerusalem/note/221811)。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1033](http://www.lydsy.com/JudgeOnline/problem.php?id=1033)  \n[COGS 2048](http://cogs.top/cogs/problem/problem.php?pid=2048)\n\n### 题解\n根据题意模拟即可 ……\n\n唯一的难点是判断线段和圆的交点。先过圆心做线段的垂线，判断与线段是否有交点，如果有，则设点到线段距离为 $ a $，圆心与线段端点距离的较大值为 $ b $；否则设圆心与线段距离较小值为 $ a $，较大值为 $ b $。\n\n满足\n\n$$\n\\begin{cases}\na \\leq r \\\\\nb \\gt r\n\\end{cases}\n$$\n\n即可\n\n保存直线的时候可以用斜截式，但注意斜率不存在和斜率为零的特判。\n\n还有就是不要**写错变量名** ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <list>\n#include <algorithm>\n\ntypedef long double real;\n\nconst int MAXN = 8;\nconst int MAXM = 8;\nconst int MAXS = 20;\nconst int MAXT = 200000;\nconst real EPS = 1e-6;\n\nint n, m, s, d, r, t, time;\n\nstruct Map {\n\tint message;\n\tbool reachable;\n\n\tMap() : message(0), reachable(true) {}\n} map[MAXN + 1][MAXM + 1];\n\ntemplate <typename T>\nstruct Point {\n\tT x, y;\n\n\tPoint(const T x = 0, const T y = 0) : x(x), y(y) {}\n\n\tMap *operator->() const { return &map[static_cast<int>(x)][static_cast<int>(y)]; }\n\n\tPoint offset(const int id) const {\n\t\tswitch (id) {\n\t\t\tcase 0: return Point(x, y + 1);\n\t\t\tcase 1: return Point(x + 1, y);\n\t\t\tcase 2: return Point(x, y - 1);\n\t\t\tcase 3: return Point(x - 1, y);\n\t\t\tdefault: return *this;\n\t\t}\n\t}\n\n\tbool valid() const { return x >= 0 && x <= n && y >= 0 && y <= m; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\n\ninline bool dcmp(const real a) { return fabs(a) <= EPS; }\ninline bool dcmp(const real a, const real b) { return dcmp(a - b); }\n\ninline bool isnan(const real x) { return x != x; }\ninline bool isinf(const real x) { return !isnan(x) && isnan(x - x); }\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ntemplate <typename Ta, typename Tb>\ninline real distance(const Point<Ta> a, const Point<Tb> b) {\n\treturn sqrt(static_cast<real>(sqr(a.x - b.x) + sqr(a.y - b.y)));\n}\n\nstruct Ant {\n\tPoint<int> position, lastPosition;\n\tint level;\n\tint hpLimit, hp;\n\tbool hasCake;\n\tint spawnTime;\n\n\tAnt(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) {\n\t\t// printf(\"spawn Ant(%d)\\n\", level);\n\t\tposition->reachable = false;\n\t}\n\n\tinline void moveTo(const Point<int> &nextPosition) {\n\t\tlastPosition = position;\n\t\tposition = nextPosition;\n\t\tif (lastPosition == position) return;\n\t\t// printf(\"moveTo(): from [%d, %d] to [%d, %d]\\n\", lastPosition.x, lastPosition.y, position.x, position.y);\n\t\tlastPosition->reachable = true;\n\t\tposition->reachable = false;\n\t}\n\n\tinline int age() const {\n\t\treturn time - spawnTime;\n\t}\n\n\tinline bool attackable(const Point<int> &p) {\n\t\tconst real dist = distance(position, p);\n\t\treturn dist < r || dcmp(dist, r);\n\t}\n};\n\nstruct Line {\n\treal k, b;\n\n\t/*\n\t * k != nan: y = kx + b\n\t * k == nan: x = b\n\t */\n\n\tLine(const Point<int> &p1, const Point<int> &p2) {\n\t\tconst real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\t\tif (x1 == x2) {\n\t\t\tk = NAN;\n\t\t\tb = x1;\n\t\t} else {\n\t\t\tk = (y2 - y1) / (x2 - x1);\n\t\t\tb = y1 - k * x1;\n\t\t}\n\t}\n\n\tLine(const real k, const Point<int> &p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {}\n\n\tLine(const real k, const real b) : k(k), b(b) {}\n\n\tLine perpendicular(const Point<int> &p1) const {\n\t\tif (isnan(k)) return Line(0, p1.y);\n\t\telse return Line(-1.0 / k, p1);\n\t}\n};\n\nstruct Segment {\n\tPoint<int> p1, p2;\n\tLine line;\n\treal length;\n\n\tSegment(const Point<int> &p1, const Point<int> &p2) : p1(p1), p2(p2), line(p1, p2) {\n\t\tlength = distance(p1, p2);\n\t}\n};\n\nPoint<real> lineIntersection(const Line &a, const Line &b) {\n\tif (isnan(a.k) && isnan(b.k) || a.k == b.k) throw;\n\tif (isnan(a.k)) return Point<real>(a.b, a.b * b.k + b.b);\n\tif (isnan(b.k)) return Point<real>(b.b, b.b * a.k + a.b);\n\tconst real x = (b.b - a.b) / (a.k - b.k);\n\tconst real y = a.k * x + a.b;\n\treturn Point<real>(x, y);\n}\n\nbool pointOnSegment(const Point<real> &p, const Segment &s) {\n\treturn dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length);\n}\n\nbool segmentCircleIntersection(const Segment &s, const Point<int> &p, const real r) {\n\tLine v = s.line.perpendicular(p);\n\tPoint<real> is = lineIntersection(v, s.line);\n\treal min, max;\n\tif (pointOnSegment(is, s)) {\n\t\tmin = distance(is, p);\n\t\tmax = std::max(distance(is, s.p1), distance(is, s.p2));\n\t} else {\n\t\tmin = distance(p, s.p1);\n\t\tmax = distance(p, s.p2);\n\t\tif (min > max) std::swap(min, max);\n\t}\n\n\treturn (min < r || dcmp(min, r)) && (max > r || dcmp(max, r));\n}\n\nstd::list<Ant> ants;\nstd::list<Ant>::iterator cakeOwner = ants.end();\nPoint<int> towers[MAXS];\n\ninline void spawn() {\n\tif (ants.size() < 6) {\n\t\tif (map[0][0].reachable == false) return;\n\n\t\tstatic int cnt = -1;\n\t\tcnt++;\n\t\tants.push_back(Ant(cnt / 6 + 1));\n\t}\n}\n\ninline void incMessage() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tit->position->message += it->hasCake ? 5 : 2;\n\t}\n}\n\ninline void move() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"move(): _cnt = %d\\n\", _cnt);\n\n\t\tint id = -1;\n\t\t// printf(\"move(): lastPosition = [%d, %d]\\n\", it->lastPosition.x, it->lastPosition.y);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint<int> newPosition = it->position.offset(i);\n\n\t\t\tif (!newPosition.valid()) continue;\n\t\t\tif (newPosition == it->lastPosition) continue;\n\t\t\tif (!newPosition->reachable) continue;\n\n\t\t\tif (id == -1 || newPosition->message > it->position.offset(id)->message) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\n\t\t// if (id != -1) printf(\"move(): checking moving to [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\n\t\tif (id != -1 && (it->age() + 1) % 5 == 0) {\n\t\t\t// printf(\"move(): special, before = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t\tPoint<int> newPosition;\n\t\t\tdo {\n\t\t\t\tid = (id - 1 + 4) % 4;\n\t\t\t\tnewPosition = it->position.offset(id);\n\t\t\t} while (!newPosition.valid() || !newPosition->reachable || newPosition == it->lastPosition);\n\t\t\t// printf(\"move(): special, after = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t}\n\n\t\tit->moveTo(it->position.offset(id));\n\t}\n}\n\ninline void getCake() {\n\tif (cakeOwner != ants.end()) return;\n\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(n, m)) {\n\t\t\tcakeOwner = it;\n\t\t\tit->hasCake = true;\n\t\t\tit->hp = std::min(it->hpLimit, it->hp + it->hpLimit / 2);\n\t\t\t// puts(\"getCake(): got\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void attack() {\n\tfor (int i = 0; i < s; i++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"attack(): _cnt = %d\\n\", _cnt);\n\n\t\tstd::list<Ant>::iterator target = ants.end();\n\t\tif (cakeOwner != ants.end() && cakeOwner->attackable(towers[i])) {\n\t\t\ttarget = cakeOwner;\n\t\t}\n\n\t\tif (target == ants.end()) {\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\treal d = distance(it->position, towers[i]);\n\t\t\t\tif ((d < r || dcmp(d, r)) && (target == ants.end() || distance(it->position, towers[i]) < distance(target->position, towers[i]))) {\n\t\t\t\t\ttarget = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (target != ants.end()) {\n\t\t\ttarget->hp -= d;\n\t\t\tSegment s(towers[i], target->position);\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\tif (it != target && segmentCircleIntersection(s, it->position, 0.5)) {\n\t\t\t\t\t// printf(\"attack(): _cnt = %d, through [%d, %d]\\n\", _cnt, it->position.x, it->position.y);\n\t\t\t\t\tit->hp -= d;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if (it == target) printf(\"attack(): _cnt = %d, target [%d, %d]\\n\", _cnt, target->position.x, target->position.y);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void kill() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); ) {\n\t\tif (it->hp < 0) {\n\t\t\tit->position->reachable = true;\n\t\t\tif (it == cakeOwner) cakeOwner = ants.end();\n\t\t\tit = ants.erase(it);\n\t\t} else it++;\n\t}\n}\n\ninline bool check() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(0, 0) && it->hasCake) return false;\n\t}\n\n\treturn true;\n}\n\ninline void decMessage() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (map[i][j].message > 0) map[i][j].message--;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%d %d\\n%d %d %d\", &n, &m, &s, &d, &r);\n\tfor (int i = 0; i < s; i++) {\n\t\tscanf(\"%d %d\", &towers[i].x, &towers[i].y);\n\t\ttowers[i]->reachable = false;\n\t}\n\tscanf(\"%d\", &t);\n\n\ttime = 1;\n\tfor (; time <= t; time++) {\n\t\t// printf(\"main(): time = %d\\n\", time);\n\t\tspawn();\n\t\tincMessage();\n\t\tmove();\n\t\tgetCake();\n\t\tattack();\n\t\tkill();\n\t\tif (!check()) break;\n\t\tdecMessage();\n\n\t\t// for (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.y, it->position.x);\n\t\t// putchar('\\n');\n\t}\n\n\tif (time > t) puts(\"The game is going on\");\n\telse printf(\"Game over after %d seconds\\n\", time);\n\n\tprintf(\"%d\\n\", ants.size());\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.x, it->position.y);\n\n\tfclose(stdin);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2008-antbuster","published":1,"updated":"2016-05-23T13:27:10.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8o001mooxltmkb3fh1"},{"title":"「ZJOI2007」仓库建设 - 斜率优化 DP","date":"2016-05-18T03:58:00.000Z","_content":"\n第 $ i $ 个工厂目前已有成品 $ P_i $ 件，在第 $ i $ 个位置建立仓库的费用是 $ C_i $。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于公司产品的对外销售处设置在山脚的工厂 $ N $，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送 $ 1 $ 个单位距离的费用是 $ 1 $。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：\n\n1. 工厂 $ i $ 距离工厂 $ 1 $ 的距离 $ x_i $（其中 $ x_1 = 0 $）；\n2. 工厂 $ i $ 目前已有成品数量 $ p_i $；\n3. 在工厂 $ i $ 建立仓库的费用 $ c_i $。\n\n请你帮助公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### 题解\n将整个序列翻转，变为从编号大的运往编号小的，设 $ S(i) $ 表示前 $ i $ 个工厂全部运到 $ 1 $ 号工厂的费用，$ s(i) $ 表示前 $ i $ 个工厂的成品总数量。\n\n设 $ f(i) $ 表示前 i 个工厂处理完成的最小花费，则\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n斜率优化，考虑两个决策 $ a $、$ b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","source":"_posts/zjoi2007-storage.md","raw":"title: 「ZJOI2007」仓库建设 - 斜率优化 DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - 斜率优化\n  - 单调队列\n  - DP\npermalink: zjoi2007-storage\ndate: 2016-05-18 11:58:00\n---\n\n第 $ i $ 个工厂目前已有成品 $ P_i $ 件，在第 $ i $ 个位置建立仓库的费用是 $ C_i $。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于公司产品的对外销售处设置在山脚的工厂 $ N $，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送 $ 1 $ 个单位距离的费用是 $ 1 $。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：\n\n1. 工厂 $ i $ 距离工厂 $ 1 $ 的距离 $ x_i $（其中 $ x_1 = 0 $）；\n2. 工厂 $ i $ 目前已有成品数量 $ p_i $；\n3. 在工厂 $ i $ 建立仓库的费用 $ c_i $。\n\n请你帮助公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### 题解\n将整个序列翻转，变为从编号大的运往编号小的，设 $ S(i) $ 表示前 $ i $ 个工厂全部运到 $ 1 $ 号工厂的费用，$ s(i) $ 表示前 $ i $ 个工厂的成品总数量。\n\n设 $ f(i) $ 表示前 i 个工厂处理完成的最小花费，则\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n斜率优化，考虑两个决策 $ a $、$ b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","slug":"zjoi2007-storage","published":1,"updated":"2016-10-24T23:28:04.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8t001xooxlf2d94gbw"},{"title":"「ZJOI2007」最大半连通子图 - 强连通分量","date":"2016-09-03T23:38:00.000Z","_content":"\n一个有向图 $ G = (V, E) $ 称为半连通的（Semi-Connected），如果满足：\n\n> $ \\forall u, v \\in V $，满足 $ u \\rightarrow v $ 或 $ v \\rightarrow u $，即对于图中任意两点 $ u $，$ v $，存在一条 $ u $ 到 $ v $ 的有向路径或者从 $ v $ 到 $ u $ 的有向路径。\n\n若 $ G' = (V', E') $ 满足 $ V' \\subseteq V $，$ E' $ 是 $ E $ 中所有跟 $ V' $ 有关的边，则称 $ G' $ 是 $ G $ 的一个导出子图。  \n若 $ G' $ 是 $ G $ 的导出子图，且 $ G' $ 半连通，则称 $ G' $ 为 $ G $ 的半连通子图。  \n若 $ G' $ 是 $ G $ 所有半连通子图中包含节点数最多的，则称 $ G' $ 是 $ G $ 的最大半连通子图。\n\n给定一个有向图 $ G $，请求出 $ G $ 的最大半连通子图拥有的节点数 $ K $，以及不同的最大半连通子图的数目 $ C $。由于 $ C $ 可能比较大，仅要求输出 $ C $ 对 $ X $ 的余数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1093](http://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n### 题解\n显然，一个强连通分量中的点是半连通的，一条链上的所有点是半连通的。\n\n将原图的强连通分量缩为点，问题转化为求 DAG 上最长路，拓扑排序后 DP 即可。\n\n对于方案统计，求出从起点到每一个点的最长路 $ d(i) $ 后，对于每条边 $ u \\rightarrow v $，如果 $ d(v) = d(u) + s(v) $（$ s(i) $ 表示点 $ i $ 所对应原图的强连通分量大小），则这条边在一条或多条最长路中，对所有在最长路上的边构成的图求路径数即可。\n\n注意重边需要特判。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst int MAXX = 100000000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tstruct SCC *s;\n\tNode *p;\n\tbool inStack, pushed, visited;\n\tint dfn, low, d, sum;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size, inDegree, in, len, sum;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, x;\n\ninline int tarjan() {\n\tint cnt = 0, ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\t\t\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tt.push(v);\n\t\t\t\tv->inStack = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->inStack) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tscc->v.s = scc;\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->s = scc;\n\t\t\t\t\t\tscc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tstd::tr1::unordered_set<unsigned long long> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tunsigned long long x = (static_cast<unsigned long long>(e->s->s - S) << 32) | static_cast<unsigned long long>(e->t->s - S);\n\t\t\tif (e->s->s != e->t->s && !s.count(x)) {\n\t\t\t\ts.insert(x);\n\t\t\t\t// printf(\"[%ld, %ld]\\n\", e->s->s - S + 1, e->t->s - S + 1);\n\t\t\t\te->s->s->v.e = new Edge(&e->s->s->v, &e->t->s->v);\n\t\t\t\te->t->s->inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dp(const int cnt) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"size[%d] = %d\\n\", i, S[i].size);\n\t\tif (S[i].inDegree == 0) q.push(&S[i].v);\n\t\tS[i].v.d = S[i].size;\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\te->t->d = std::max(e->t->d, v->d + e->t->s->size);\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d);\n\treturn ans;\n}\n\ninline int dpSum(const int cnt, const int d) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].inDegree == 0) {\n\t\t\tq.push(&S[i].v);\n\t\t\tS[i].v.sum = 1;\n\t\t}\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->d == v->d + e->t->s->size) (e->t->sum += v->sum) %= x;\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x;\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint d = dp(cnt);\n\n\tprintf(\"%d\\n\", d);\n\tprintf(\"%d\\n\", dpSum(cnt, d));\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2007-semi.md","raw":"title: 「ZJOI2007」最大半连通子图 - 强连通分量\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - 强连通分量\n  - Tarjan\n  - 缩点\n  - DP\npermalink: zjoi2007-semi\ndate: 2016-09-04 07:38:00\n---\n\n一个有向图 $ G = (V, E) $ 称为半连通的（Semi-Connected），如果满足：\n\n> $ \\forall u, v \\in V $，满足 $ u \\rightarrow v $ 或 $ v \\rightarrow u $，即对于图中任意两点 $ u $，$ v $，存在一条 $ u $ 到 $ v $ 的有向路径或者从 $ v $ 到 $ u $ 的有向路径。\n\n若 $ G' = (V', E') $ 满足 $ V' \\subseteq V $，$ E' $ 是 $ E $ 中所有跟 $ V' $ 有关的边，则称 $ G' $ 是 $ G $ 的一个导出子图。  \n若 $ G' $ 是 $ G $ 的导出子图，且 $ G' $ 半连通，则称 $ G' $ 为 $ G $ 的半连通子图。  \n若 $ G' $ 是 $ G $ 所有半连通子图中包含节点数最多的，则称 $ G' $ 是 $ G $ 的最大半连通子图。\n\n给定一个有向图 $ G $，请求出 $ G $ 的最大半连通子图拥有的节点数 $ K $，以及不同的最大半连通子图的数目 $ C $。由于 $ C $ 可能比较大，仅要求输出 $ C $ 对 $ X $ 的余数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1093](http://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n### 题解\n显然，一个强连通分量中的点是半连通的，一条链上的所有点是半连通的。\n\n将原图的强连通分量缩为点，问题转化为求 DAG 上最长路，拓扑排序后 DP 即可。\n\n对于方案统计，求出从起点到每一个点的最长路 $ d(i) $ 后，对于每条边 $ u \\rightarrow v $，如果 $ d(v) = d(u) + s(v) $（$ s(i) $ 表示点 $ i $ 所对应原图的强连通分量大小），则这条边在一条或多条最长路中，对所有在最长路上的边构成的图求路径数即可。\n\n注意重边需要特判。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst int MAXX = 100000000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tstruct SCC *s;\n\tNode *p;\n\tbool inStack, pushed, visited;\n\tint dfn, low, d, sum;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size, inDegree, in, len, sum;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, x;\n\ninline int tarjan() {\n\tint cnt = 0, ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\t\t\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tt.push(v);\n\t\t\t\tv->inStack = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->inStack) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tscc->v.s = scc;\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->s = scc;\n\t\t\t\t\t\tscc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tstd::tr1::unordered_set<unsigned long long> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tunsigned long long x = (static_cast<unsigned long long>(e->s->s - S) << 32) | static_cast<unsigned long long>(e->t->s - S);\n\t\t\tif (e->s->s != e->t->s && !s.count(x)) {\n\t\t\t\ts.insert(x);\n\t\t\t\t// printf(\"[%ld, %ld]\\n\", e->s->s - S + 1, e->t->s - S + 1);\n\t\t\t\te->s->s->v.e = new Edge(&e->s->s->v, &e->t->s->v);\n\t\t\t\te->t->s->inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dp(const int cnt) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"size[%d] = %d\\n\", i, S[i].size);\n\t\tif (S[i].inDegree == 0) q.push(&S[i].v);\n\t\tS[i].v.d = S[i].size;\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\te->t->d = std::max(e->t->d, v->d + e->t->s->size);\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d);\n\treturn ans;\n}\n\ninline int dpSum(const int cnt, const int d) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].inDegree == 0) {\n\t\t\tq.push(&S[i].v);\n\t\t\tS[i].v.sum = 1;\n\t\t}\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->d == v->d + e->t->s->size) (e->t->sum += v->sum) %= x;\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x;\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint d = dp(cnt);\n\n\tprintf(\"%d\\n\", d);\n\tprintf(\"%d\\n\", dpSum(cnt, d));\n\n\treturn 0;\n}\n```","slug":"zjoi2007-semi","published":1,"updated":"2016-09-03T23:51:14.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8x0027ooxl2z31ndqo"},{"title":"「ZJOI2007」棋盘制作 - 悬线法","date":"2016-12-13T09:23:00.000Z","_content":"\n在一个 $ N \\times M $ 的 $ 01 $ 矩阵中，求面积最大的相邻位置数字不同的矩形和正方形。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1057](http://www.lydsy.com/JudgeOnline/problem.php?id=1057)\n\n### 题解\n定义「极大合法子矩阵」为满足题目要求（相邻位置数字不同）的每一条边都不能向外扩展的子矩阵。面积最大的合法矩形一定是一个极大合法子矩阵。而面积最大的合法正方形一定是以一个极大和法子矩阵为边长的正方形。\n\n对于每个位置，求出从这个位置向上能延伸到的满足题目要求（相邻位置数字不同）的最高点，用一条线连结，称这条线为「悬线」。求出悬线向左向右能延伸到的最远位置，则悬线左右移动的轨迹为一个合法子矩阵，且这个子矩阵的上边、左边、右边不能延伸。如果它的下边可以延伸，则在接下来的枚举中，延伸得到的矩阵可以被枚举到，否则它就是一个极大合法子矩阵。\n\n这种枚举的方法可以枚举到所有高度（上边到下边距离，即悬线的长度）的极大合法子矩阵，所以不会漏解。\n\n求每个位置向上、向左、向右能延伸到的最高点可以使用递推，而悬线向左或向右延伸的最远位置是一个后缀最小值，也可以递推。时间复杂度为 $ O(nm) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\ninline int sqr(int x) {\n\treturn x * x;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= n; i++) f[i][0] = -1;\n\t// for (int j = 1; j <= m; j++) f[0][j] = -1;\n\n\tstatic int f[MAXN + 1][MAXN + 1], g[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (j == 1 ||  a[i][j] == a[i][j - 1]) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tf[i][j] = f[i][j - 1] + 1;\n\t\t\t}\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\t\t}\n\n\t\tfor (int j = m; j >= 1; j--) {\n\t\t\tif (j == m || a[i][j] == a[i][j + 1]) {\n\t\t\t\tg[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tg[i][j] = g[i][j + 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ansSquare = 1, ansRectangle = 1;\n\tfor (int j = 1; j <= m; j++) {\n\t\tint up = 0, left = 0, right = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i == 1 || a[i][j] == a[i - 1][j]) {\n\t\t\t\tup = 1;\n\t\t\t\tleft = f[i][j];\n\t\t\t\tright = g[i][j];\n\t\t\t} else {\n\t\t\t\tup++;\n\t\t\t\tleft = std::min(left, f[i][j]);\n\t\t\t\tright = std::min(right, g[i][j]);\n\t\t\t}\n\n\t\t\t// printf(\"up = %d, left = %d, right = %d\\n\", up, left, right);\n\t\t\tansRectangle = std::max(ansRectangle, up * (left + right - 1));\n\t\t\tansSquare = std::max(ansSquare, sqr(std::min(up, left + right - 1)));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansSquare, ansRectangle);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2007-chess.md","raw":"title: 「ZJOI2007」棋盘制作 - 悬线法\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - 悬线法\npermalink: zjoi2007-chess\ndate: 2016-12-13 17:23:00\n---\n\n在一个 $ N \\times M $ 的 $ 01 $ 矩阵中，求面积最大的相邻位置数字不同的矩形和正方形。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1057](http://www.lydsy.com/JudgeOnline/problem.php?id=1057)\n\n### 题解\n定义「极大合法子矩阵」为满足题目要求（相邻位置数字不同）的每一条边都不能向外扩展的子矩阵。面积最大的合法矩形一定是一个极大合法子矩阵。而面积最大的合法正方形一定是以一个极大和法子矩阵为边长的正方形。\n\n对于每个位置，求出从这个位置向上能延伸到的满足题目要求（相邻位置数字不同）的最高点，用一条线连结，称这条线为「悬线」。求出悬线向左向右能延伸到的最远位置，则悬线左右移动的轨迹为一个合法子矩阵，且这个子矩阵的上边、左边、右边不能延伸。如果它的下边可以延伸，则在接下来的枚举中，延伸得到的矩阵可以被枚举到，否则它就是一个极大合法子矩阵。\n\n这种枚举的方法可以枚举到所有高度（上边到下边距离，即悬线的长度）的极大合法子矩阵，所以不会漏解。\n\n求每个位置向上、向左、向右能延伸到的最高点可以使用递推，而悬线向左或向右延伸的最远位置是一个后缀最小值，也可以递推。时间复杂度为 $ O(nm) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\ninline int sqr(int x) {\n\treturn x * x;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= n; i++) f[i][0] = -1;\n\t// for (int j = 1; j <= m; j++) f[0][j] = -1;\n\n\tstatic int f[MAXN + 1][MAXN + 1], g[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (j == 1 ||  a[i][j] == a[i][j - 1]) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tf[i][j] = f[i][j - 1] + 1;\n\t\t\t}\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\t\t}\n\n\t\tfor (int j = m; j >= 1; j--) {\n\t\t\tif (j == m || a[i][j] == a[i][j + 1]) {\n\t\t\t\tg[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tg[i][j] = g[i][j + 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ansSquare = 1, ansRectangle = 1;\n\tfor (int j = 1; j <= m; j++) {\n\t\tint up = 0, left = 0, right = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i == 1 || a[i][j] == a[i - 1][j]) {\n\t\t\t\tup = 1;\n\t\t\t\tleft = f[i][j];\n\t\t\t\tright = g[i][j];\n\t\t\t} else {\n\t\t\t\tup++;\n\t\t\t\tleft = std::min(left, f[i][j]);\n\t\t\t\tright = std::min(right, g[i][j]);\n\t\t\t}\n\n\t\t\t// printf(\"up = %d, left = %d, right = %d\\n\", up, left, right);\n\t\t\tansRectangle = std::max(ansRectangle, up * (left + right - 1));\n\t\t\tansSquare = std::max(ansSquare, sqr(std::min(up, left + right - 1)));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansSquare, ansRectangle);\n\n\treturn 0;\n}\n```","slug":"zjoi2007-chess","published":1,"updated":"2016-12-13T09:23:42.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r92002iooxlczrdlyzt"},{"title":"「ZJOI2006」物流运输 - 最短路 + DP","date":"2016-05-23T13:41:00.000Z","_content":"\n物流公司要把一批货物从码头 $ A $ 运到码头 $ B $。由于货物量比较大，需要 $ n $ 天才能运完。货物运输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个 $ n $ 天的运输计划，使得总成本尽可能地小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)  \n[COGS 1824](http://cogs.top/cogs/problem/problem.php?pid=1824)\n\n### 题解\n首先，对时间暴力枚举一段区间，对这些天内任意一天不能使用的点标记，在剩余的点中求出最短路，以得到任意几天走相同路线的最少花费（最短路乘以天数）。\n\n设 $ c(l,\\ r) $ 表示第 $ l $ 天到第 $ r $ 天走相同路线的最少花费，设 $ f(i) $ 表示完成前 $ i $ 天的运输计划并修改路线的最少花费，则\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + k + c(j + 1,\\ i) \\} $$\n\n注意，当 $ c(j + 1,\\ i) $ 无效，即第 $ j + 1 $ 天到第 $ i $ 天无法走同一条路线时不可转移。\n\n最终答案为 $ f(n) - k $，时间复杂度为 $ O(n ^ 2 m \\log m) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <utility>\n#include <functional>\n\nstruct Node;\nstruct Edge;\n\nconst int MAXN = 20;\nconst int MAXD = 100;\n\nstruct Node {\n\tEdge *e;\n\tint d;\n\tbool flag[MAXD], invalid;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const int w) {\n\tN[u].e = new Edge(&N[u], &N[v], w);\n\tN[v].e = new Edge(&N[v], &N[u], w);\n}\n\nint d, n, k, m, c[MAXD + 1][MAXD + 1];\nint f[MAXD + 1];\n\ninline int dijkstra(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].d = INT_MAX;\n\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tN[s].d = 0;\n\tq.push(std::make_pair(0, &N[s]));\n\n\twhile (!q.empty()) {\n\t\tconst std::pair<int, Node *> p = q.top();\n\t\tq.pop();\n\n\t\tNode *v = p.second;\n\n\t\tif (v->d != p.first) continue;\n\t\tif (v->d > N[t].d) break;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\n\t\t\tif (e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\tq.push(std::make_pair(e->t->d, e->t));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn N[t].d;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &d, &n, &k, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint u, l, r;\n\t\tscanf(\"%d %d %d\", &u, &l, &r), u--, l--, r--;\n\t\tstd::fill(N[u].flag + l, N[u].flag + r + 1, true);\n\t}\n\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = i; j <= d; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tN[k].invalid = false;\n\t\t\t\tfor (int l = i; l <= j; l++) {\n\t\t\t\t\tif (N[k].flag[l - 1]) {\n\t\t\t\t\t\tN[k].invalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc[i][j] = dijkstra(0, n - 1);\n\t\t\tif (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1);\n\t\t\t// printf(\"%d\\n\", c[i][j]);\n\t\t}\n\t}\n\n\tstd::fill(f, f + d + 1, INT_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (c[j + 1][i] != INT_MAX) {\n\t\t\t\tf[i] = std::min(f[i], f[j] + k + c[j + 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[d] - k);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2006-trans.md","raw":"title: 「ZJOI2006」物流运输 - 最短路 + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - 最短路\n  - DP\npermalink: zjoi2006-trans\ndate: 2016-05-23 21:41:00\n---\n\n物流公司要把一批货物从码头 $ A $ 运到码头 $ B $。由于货物量比较大，需要 $ n $ 天才能运完。货物运输过程中一般要转停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个 $ n $ 天的运输计划，使得总成本尽可能地小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)  \n[COGS 1824](http://cogs.top/cogs/problem/problem.php?pid=1824)\n\n### 题解\n首先，对时间暴力枚举一段区间，对这些天内任意一天不能使用的点标记，在剩余的点中求出最短路，以得到任意几天走相同路线的最少花费（最短路乘以天数）。\n\n设 $ c(l,\\ r) $ 表示第 $ l $ 天到第 $ r $ 天走相同路线的最少花费，设 $ f(i) $ 表示完成前 $ i $ 天的运输计划并修改路线的最少花费，则\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + k + c(j + 1,\\ i) \\} $$\n\n注意，当 $ c(j + 1,\\ i) $ 无效，即第 $ j + 1 $ 天到第 $ i $ 天无法走同一条路线时不可转移。\n\n最终答案为 $ f(n) - k $，时间复杂度为 $ O(n ^ 2 m \\log m) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <utility>\n#include <functional>\n\nstruct Node;\nstruct Edge;\n\nconst int MAXN = 20;\nconst int MAXD = 100;\n\nstruct Node {\n\tEdge *e;\n\tint d;\n\tbool flag[MAXD], invalid;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const int w) {\n\tN[u].e = new Edge(&N[u], &N[v], w);\n\tN[v].e = new Edge(&N[v], &N[u], w);\n}\n\nint d, n, k, m, c[MAXD + 1][MAXD + 1];\nint f[MAXD + 1];\n\ninline int dijkstra(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].d = INT_MAX;\n\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tN[s].d = 0;\n\tq.push(std::make_pair(0, &N[s]));\n\n\twhile (!q.empty()) {\n\t\tconst std::pair<int, Node *> p = q.top();\n\t\tq.pop();\n\n\t\tNode *v = p.second;\n\n\t\tif (v->d != p.first) continue;\n\t\tif (v->d > N[t].d) break;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\n\t\t\tif (e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\tq.push(std::make_pair(e->t->d, e->t));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn N[t].d;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &d, &n, &k, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint u, l, r;\n\t\tscanf(\"%d %d %d\", &u, &l, &r), u--, l--, r--;\n\t\tstd::fill(N[u].flag + l, N[u].flag + r + 1, true);\n\t}\n\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = i; j <= d; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tN[k].invalid = false;\n\t\t\t\tfor (int l = i; l <= j; l++) {\n\t\t\t\t\tif (N[k].flag[l - 1]) {\n\t\t\t\t\t\tN[k].invalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc[i][j] = dijkstra(0, n - 1);\n\t\t\tif (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1);\n\t\t\t// printf(\"%d\\n\", c[i][j]);\n\t\t}\n\t}\n\n\tstd::fill(f, f + d + 1, INT_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (c[j + 1][i] != INT_MAX) {\n\t\t\t\tf[i] = std::min(f[i], f[j] + k + c[j + 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[d] - k);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2006-trans","published":1,"updated":"2016-05-23T13:42:15.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r95002oooxls8l15ust"},{"title":"「ZJOI2004」沼泽鳄鱼 - 矩阵乘法","date":"2016-10-07T22:54:00.000Z","_content":"\n给一个图，有一些鳄鱼在两个、三个或四个点之间周期性移动，求从 $ s $ 点到 $ t $ 点，恰好走 $ k $ 步，任意时刻都不与鳄鱼同时到达同一个点的方案数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1898](www.lydsy.com/JudgeOnline/problem.php?id=1898)  \n[COGS 1469](http://cogs.pro/cogs/problem/problem.php?pid=1469)\n\n### 题解\n如果没有鳄鱼的限制，答案就是邻接矩阵的 $ k $ 次方中 $ s $ 行 $ t $ 列的值。\n\n有了鳄鱼之后，每一时刻都不能和鳄鱼停在同一个点上，所以每一次要乘的图是不同的。对于每个时间点，将鳄鱼到达点的所有出边删掉（表示，**到达**这个点会被鳄鱼吃掉）。\n\n取 $ \\mathrm{lcm}(2, 3, 4) = 12 $，图的形态每 $ 12 $ 个单位时间循环一次。分别求出这 $ 12 $ 个矩阵和它们的积，对 $ k $ 的大于 $ 12 $ 的部分做快速幂，剩余部分乘上最多 $ 11 $ 个矩阵即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 50;\nconst int MAXM = 20;\nconst long long MAXK = 2e9;\nconst int CYCLE_LCM = 12;\nconst int MOD = 10000;\n\nstruct Matrix {\n\tint a[MAXN][MAXN];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXN; i++) a[i][i] = 1;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res;\n\tfor (int i = 0; i < MAXN; i++) for (int j = 0; j < MAXN; j++) for (int k = 0; k < MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"swamp.in\", \"r\", stdin);\n\tfreopen(\"swamp.out\", \"w\", stdout);\n\n\tint n, m, st, ed, k;\n\tscanf(\"%d %d %d %d %d\", &n, &m, &st, &ed, &k);\n\n\tMatrix g;\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tg(u, v)++;\n\t\tg(v, u)++;\n\t}\n\n\tMatrix gs[CYCLE_LCM];\n\tfor (int i = 0; i < CYCLE_LCM; i++) gs[i] = g;\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint cycle;\n\t\tscanf(\"%d\", &cycle);\n\t\tfor (int i = 0; i < cycle; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfor (int j = i; j < CYCLE_LCM; j += cycle) {\n\t\t\t\tfor (int l = 0; l < n; l++) gs[j](x, l) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", g(i, j), j == n - 1 ? '\\n' : ' ');\n\tputs(\"-------------\");\n\tfor (int l = 0; l < CYCLE_LCM; l++) {\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", gs[l](i, j), j == n - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------\");\n\t}\n#endif\n\n#ifndef FORCE\n\tMatrix prod(true);\n\tfor (int i = 0; i < CYCLE_LCM; i++) prod = prod * gs[i];\n\n\tMatrix res = pow(prod, k / CYCLE_LCM);\n\tfor (int i = 0; i < k % CYCLE_LCM; i++) res = res * gs[i];\n#else\n\tMatrix res(true);\n\tfor (int i = 0; i < k; i++) res = res * gs[i % CYCLE_LCM];\n#endif\n\n\tprintf(\"%d\\n\", res(st, ed));\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", res(i, j), j == n - 1 ? '\\n' : ' ');\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2004-swamp.md","raw":"title: 「ZJOI2004」沼泽鳄鱼 - 矩阵乘法\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - 矩阵乘法\n  - DP\npermalink: zjoi2004-swamp\ndate: 2016-10-08 06:54:00\n---\n\n给一个图，有一些鳄鱼在两个、三个或四个点之间周期性移动，求从 $ s $ 点到 $ t $ 点，恰好走 $ k $ 步，任意时刻都不与鳄鱼同时到达同一个点的方案数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1898](www.lydsy.com/JudgeOnline/problem.php?id=1898)  \n[COGS 1469](http://cogs.pro/cogs/problem/problem.php?pid=1469)\n\n### 题解\n如果没有鳄鱼的限制，答案就是邻接矩阵的 $ k $ 次方中 $ s $ 行 $ t $ 列的值。\n\n有了鳄鱼之后，每一时刻都不能和鳄鱼停在同一个点上，所以每一次要乘的图是不同的。对于每个时间点，将鳄鱼到达点的所有出边删掉（表示，**到达**这个点会被鳄鱼吃掉）。\n\n取 $ \\mathrm{lcm}(2, 3, 4) = 12 $，图的形态每 $ 12 $ 个单位时间循环一次。分别求出这 $ 12 $ 个矩阵和它们的积，对 $ k $ 的大于 $ 12 $ 的部分做快速幂，剩余部分乘上最多 $ 11 $ 个矩阵即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 50;\nconst int MAXM = 20;\nconst long long MAXK = 2e9;\nconst int CYCLE_LCM = 12;\nconst int MOD = 10000;\n\nstruct Matrix {\n\tint a[MAXN][MAXN];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXN; i++) a[i][i] = 1;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res;\n\tfor (int i = 0; i < MAXN; i++) for (int j = 0; j < MAXN; j++) for (int k = 0; k < MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"swamp.in\", \"r\", stdin);\n\tfreopen(\"swamp.out\", \"w\", stdout);\n\n\tint n, m, st, ed, k;\n\tscanf(\"%d %d %d %d %d\", &n, &m, &st, &ed, &k);\n\n\tMatrix g;\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tg(u, v)++;\n\t\tg(v, u)++;\n\t}\n\n\tMatrix gs[CYCLE_LCM];\n\tfor (int i = 0; i < CYCLE_LCM; i++) gs[i] = g;\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint cycle;\n\t\tscanf(\"%d\", &cycle);\n\t\tfor (int i = 0; i < cycle; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfor (int j = i; j < CYCLE_LCM; j += cycle) {\n\t\t\t\tfor (int l = 0; l < n; l++) gs[j](x, l) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", g(i, j), j == n - 1 ? '\\n' : ' ');\n\tputs(\"-------------\");\n\tfor (int l = 0; l < CYCLE_LCM; l++) {\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", gs[l](i, j), j == n - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------\");\n\t}\n#endif\n\n#ifndef FORCE\n\tMatrix prod(true);\n\tfor (int i = 0; i < CYCLE_LCM; i++) prod = prod * gs[i];\n\n\tMatrix res = pow(prod, k / CYCLE_LCM);\n\tfor (int i = 0; i < k % CYCLE_LCM; i++) res = res * gs[i];\n#else\n\tMatrix res(true);\n\tfor (int i = 0; i < k; i++) res = res * gs[i % CYCLE_LCM];\n#endif\n\n\tprintf(\"%d\\n\", res(st, ed));\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", res(i, j), j == n - 1 ? '\\n' : ' ');\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"zjoi2004-swamp","published":1,"updated":"2016-10-07T23:08:49.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r99002wooxlw9wlizgc"},{"title":"OS X 与虚拟机中 Linux 无缝整合","date":"2016-03-07T01:04:27.000Z","_content":"\nOS X 中有很多与 GNU/Linux 相似的地方，但也有很大的差异，很多时候 GNU/Linux 系统比 OS X 好用一些，而 OS X 的图形界面比 GNU/Linux 不知要高到哪里去了 …… 二者兼得的方法，就是使用虚拟机。\n\n下面以最好用的虚拟机软件 `VirtualBox` 为例，演示配置 Archlinux 虚拟机与 OS X 主机无缝整合的步骤。\n\n<!-- more -->\n\n## 安装 OpenSSH\n首先，在虚拟机中安装好 Arch Linux 系统，并安装好增强工具。\n\n安装 OpenSSH：\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## 配置端口转发\n打开「设置」→「网络」，选择「网络地址转换「NAT」连接方式。\n\n![网络设置](virtualbox-archlinux/network.png)\n\n点击「端口转发」。\n\n![端口转发](virtualbox-archlinux/port.png)\n\n子系统端口填写 `22`，主机端口填一个大于 `1000` 的值，因为在 OS X 下，非 `root` 用户的进程是无法绑定 `1000` 以下的端口的。\n\n确定后，在主机的 Terminal 中尝试连接。\n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## 共享文件夹\n在 Virtualbox 的「设置」→「共享文件夹」中设置共享根目录。\n\n![共享文件夹](virtualbox-archlinux/share.png)\n\n为了解决权限问题，不要选择「自动挂载」，而是手动配置自动挂载。\n\n### `rc.local` 服务\n\nArchlinux 的 systemd 原生不支持开机自动执行 `rc.local` 文件，所以我们需要先添加一个服务。\n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n输入以下内容：\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n保存后启用服务，并创建 `rc.local` 文件：\n\n```bash\nsudo systemctl enable rc-local\n```\n\n### 自动挂载脚本\n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n重启后，虚拟机中的主目录就和主机上的主目录共享啦。\n\n## SSH 免密码登录\n进行完以上步骤后，已经可以在主机通过 SSH 连接到虚拟机了，但需要输入密码。我们可以使用私钥认证的方式免去输入密码。\n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n一路回车后，会在 `~/.ssh` 目录下生成私钥和公钥。\n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n因为主机和虚拟机的主目录是共享的，所以在主机里设置后，虚拟机里也会生效。\n\n现在试试 SSH 连接到虚拟机，应该不需要密码了。\n\n## 配置 Terminal 快捷键\n众所周知，Terminal 中以默认设置打开新窗口的快捷键是 `Command + N`。我们也可以设置打开新窗口并 SSH 连接到虚拟机的快捷键。\n\n### 添加描述文件\n在 Terminal 的偏好设置中，选择「描述文件」，把「Basic」配置复制一份，命名为「Basic Linux」，并在 `Shell` 一栏中填写「运行命令」为 SSH，不勾选下方的「在 Shell 中运行」。\n\n![共享文件夹](virtualbox-archlinux/terminal.png)\n\n这样就已经可以在菜单中打开连接虚拟机的新窗口了。\n\n### 添加快捷键\n在系统偏好设置中添加快捷键：\n\n「系统偏好设置」→「键盘」→「快捷键」→「应用程序快捷键」→「添加」\n\n![共享文件夹](virtualbox-archlinux/hotkey.png)\n\n点击「添加」后，就可以使用快捷键啦！\n\n## 成果\n在 Terminal 中，按下 `Command + B`：\n\n![共享文件夹](virtualbox-archlinux/screenfetch.png)\n\n为了比较好的效果，可以改一下 `screenfetch`。\n","source":"_posts/virtualbox-archlinux.md","raw":"title: OS X 与虚拟机中 Linux 无缝整合\ncategories: Geek\ntags: \n  - OS X\n  - Linux\n  - Archlinux\n  - VirtualBox\n  - 虚拟机\n  - SSH\npermalink: virtualbox-archlinux\ndate: 2016-03-07 09:04:27\n---\n\nOS X 中有很多与 GNU/Linux 相似的地方，但也有很大的差异，很多时候 GNU/Linux 系统比 OS X 好用一些，而 OS X 的图形界面比 GNU/Linux 不知要高到哪里去了 …… 二者兼得的方法，就是使用虚拟机。\n\n下面以最好用的虚拟机软件 `VirtualBox` 为例，演示配置 Archlinux 虚拟机与 OS X 主机无缝整合的步骤。\n\n<!-- more -->\n\n## 安装 OpenSSH\n首先，在虚拟机中安装好 Arch Linux 系统，并安装好增强工具。\n\n安装 OpenSSH：\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## 配置端口转发\n打开「设置」→「网络」，选择「网络地址转换「NAT」连接方式。\n\n![网络设置](virtualbox-archlinux/network.png)\n\n点击「端口转发」。\n\n![端口转发](virtualbox-archlinux/port.png)\n\n子系统端口填写 `22`，主机端口填一个大于 `1000` 的值，因为在 OS X 下，非 `root` 用户的进程是无法绑定 `1000` 以下的端口的。\n\n确定后，在主机的 Terminal 中尝试连接。\n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## 共享文件夹\n在 Virtualbox 的「设置」→「共享文件夹」中设置共享根目录。\n\n![共享文件夹](virtualbox-archlinux/share.png)\n\n为了解决权限问题，不要选择「自动挂载」，而是手动配置自动挂载。\n\n### `rc.local` 服务\n\nArchlinux 的 systemd 原生不支持开机自动执行 `rc.local` 文件，所以我们需要先添加一个服务。\n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n输入以下内容：\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n保存后启用服务，并创建 `rc.local` 文件：\n\n```bash\nsudo systemctl enable rc-local\n```\n\n### 自动挂载脚本\n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n重启后，虚拟机中的主目录就和主机上的主目录共享啦。\n\n## SSH 免密码登录\n进行完以上步骤后，已经可以在主机通过 SSH 连接到虚拟机了，但需要输入密码。我们可以使用私钥认证的方式免去输入密码。\n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n一路回车后，会在 `~/.ssh` 目录下生成私钥和公钥。\n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n因为主机和虚拟机的主目录是共享的，所以在主机里设置后，虚拟机里也会生效。\n\n现在试试 SSH 连接到虚拟机，应该不需要密码了。\n\n## 配置 Terminal 快捷键\n众所周知，Terminal 中以默认设置打开新窗口的快捷键是 `Command + N`。我们也可以设置打开新窗口并 SSH 连接到虚拟机的快捷键。\n\n### 添加描述文件\n在 Terminal 的偏好设置中，选择「描述文件」，把「Basic」配置复制一份，命名为「Basic Linux」，并在 `Shell` 一栏中填写「运行命令」为 SSH，不勾选下方的「在 Shell 中运行」。\n\n![共享文件夹](virtualbox-archlinux/terminal.png)\n\n这样就已经可以在菜单中打开连接虚拟机的新窗口了。\n\n### 添加快捷键\n在系统偏好设置中添加快捷键：\n\n「系统偏好设置」→「键盘」→「快捷键」→「应用程序快捷键」→「添加」\n\n![共享文件夹](virtualbox-archlinux/hotkey.png)\n\n点击「添加」后，就可以使用快捷键啦！\n\n## 成果\n在 Terminal 中，按下 `Command + B`：\n\n![共享文件夹](virtualbox-archlinux/screenfetch.png)\n\n为了比较好的效果，可以改一下 `screenfetch`。\n","slug":"virtualbox-archlinux","published":1,"updated":"2016-05-11T09:33:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r9g0034ooxlb1zybm8l"},{"title":"「UVa 1362」Exploring Pyramids - 区间 DP + 计数原理","date":"2016-03-14T08:32:16.000Z","_content":"\n给定一棵树的欧拉序列，树的子节点是有序的，求有多少棵树满足这个欧拉序列。\n\n<!-- more -->\n\n### 链接\n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### 题解\n书上的解法，用 $ f(i, j) $ 表示欧拉序列 $ S $ 中的第 $ i $ 到第 $ j $ 个字符所表示的树的数量，则有：\n\n1. 当 $ i = j $ 时，$ f(i, j) = 1 $；\n2. 当 $ S(i) \\neq S(j) $ 时，$ f(i, j) = 0 $，因为欧拉序列的第一个点和最后一个点都必须是根节点。\n\n欧拉序列的一个特点是，每一次回溯到根都会将根节点记录下来。所以我们可以枚举中转点 $ k $，当 $ i = k = j $ 时，递归计算 $ (i, k) $ 区间内（第一棵子树）的答案和 $ [k, j] $ 区间的答案（其它子树），并将其相乘。\n\n多组数据一定要清数组，一定要清数组，一定要清数组 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","source":"_posts/uva-1362.md","raw":"title: 「UVa 1362」Exploring Pyramids - 区间 DP + 计数原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - DP\n  - 区间 DP\n  - 计数原理\npermalink: uva-1362\ndate: 2016-03-14 16:32:16\n---\n\n给定一棵树的欧拉序列，树的子节点是有序的，求有多少棵树满足这个欧拉序列。\n\n<!-- more -->\n\n### 链接\n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### 题解\n书上的解法，用 $ f(i, j) $ 表示欧拉序列 $ S $ 中的第 $ i $ 到第 $ j $ 个字符所表示的树的数量，则有：\n\n1. 当 $ i = j $ 时，$ f(i, j) = 1 $；\n2. 当 $ S(i) \\neq S(j) $ 时，$ f(i, j) = 0 $，因为欧拉序列的第一个点和最后一个点都必须是根节点。\n\n欧拉序列的一个特点是，每一次回溯到根都会将根节点记录下来。所以我们可以枚举中转点 $ k $，当 $ i = k = j $ 时，递归计算 $ (i, k) $ 区间内（第一棵子树）的答案和 $ [k, j] $ 区间的答案（其它子树），并将其相乘。\n\n多组数据一定要清数组，一定要清数组，一定要清数组 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","slug":"uva-1362","published":1,"updated":"2016-10-24T23:28:14.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ra4003jooxlk639w24c"},{"title":"「UVa 11806」Cheerleaders - 组合数 + 容斥原理","date":"2016-03-11T14:10:34.000Z","_content":"\n在一个 $ M * N $ 的矩阵中摆放 $ K $ 只石子，要求第一行、第一列、第 $ \nM $ 行、第 $ N $ 列必须有石子，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### 题解\n1. 设 $ A $、$ C $ 分别表示第一行、第 $ M $ \n行**没有**摆放石子的方案集合；\n2. 设 $ B $、$ D $ 分别表示第一列、第 $ N $ \n列**没有**摆放石子的方案集合；\n3. 设 $ S $ 表示在 $ M * N $ 的矩阵中**任意**摆放 $ K $ \n只石子的方案集合。\n\n则问题转化为，求在集合 $ S $ 内但不在集合 $ A $、$ B $、$ C $、$ D $ \n内的元素总数。\n\n由容斥原理得，答案\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n各个集合的元素数量可用组合数计算，组合数需要预处理。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11806.md","raw":"title: 「UVa 11806」Cheerleaders - 组合数 + 容斥原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 组合数学\n  - 容斥原理\npermalink: uva-11806\ndate: 2016-03-11 22:10:34\n---\n\n在一个 $ M * N $ 的矩阵中摆放 $ K $ 只石子，要求第一行、第一列、第 $ \nM $ 行、第 $ N $ 列必须有石子，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### 题解\n1. 设 $ A $、$ C $ 分别表示第一行、第 $ M $ \n行**没有**摆放石子的方案集合；\n2. 设 $ B $、$ D $ 分别表示第一列、第 $ N $ \n列**没有**摆放石子的方案集合；\n3. 设 $ S $ 表示在 $ M * N $ 的矩阵中**任意**摆放 $ K $ \n只石子的方案集合。\n\n则问题转化为，求在集合 $ S $ 内但不在集合 $ A $、$ B $、$ C $、$ D $ \n内的元素总数。\n\n由容斥原理得，答案\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n各个集合的元素数量可用组合数计算，组合数需要预处理。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11806","published":1,"updated":"2016-05-11T09:33:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9raa003tooxlpkd1wmj8"},{"title":"「UVa 11538」Chess Queen - 计数原理","date":"2016-03-12T02:47:13.000Z","_content":"\n在一个 $ N * M $ 棋盘中放置两个皇后，使得它们可以相互攻击，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### 题解\n两个皇后可以互相攻击，当且仅当它们在「同一行」或「同一列」或「同一对角线」。这三种情况互相独立，可以用加法原理。\n\n考虑「同一行」的情况，用 $ f(a, b) $ 表示在一个 $ a $ 行 $ b $ 列的棋盘中放置两个皇后在同一行的方案数。令 $ a = 1 $，此时第一个皇后有 $ b $ 种放置方法，第二个有 $ b - 1 $ 种，即\n\n$$ f(1, b) = b(b - 1) $$\n\n推广到多行的情况，每一行的情况互不影响，可以用加法原理，即：\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n「同一列」和「同一行」原理相同，行列数互换后代入上式即可。\n\n「同一对角线」的情况比较复杂，假设 $ m ≥ n $，则同一方向的对角线中，有 $ m - n + 1 $ 条的长度为 $ n $（蓝色部分），剩下的两边分别有 $ n - 1 $ 条长度递增。\n\n![（图片使用 \nLibreOffice Calc \n制作）](uva-11538/cells.png)\n\n中间的一撮所对应的情况相当于在一个 $ m - n + 1 $ 行 $ n $ 列的棋盘中放置，使得两个皇后在**同一行**，即 $ f(m - n + 1, n) $。\n\n两边长度递增的对角线也要按照类似「同一行」的方法推导，即：\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n但是根据题目的数据范围，$ O(n) $ 地每次计算是会超时的，考虑展开。\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n分别使用平方和公式和等差数列求和公式展开，得\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n这是一边的长度递增的对角线上的方案数，两边的要乘以二，因为有两个方向，所以最后还要乘以二。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11538.md","raw":"title: 「UVa 11538」Chess Queen - 计数原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 组合数学\n  - 计数原理\npermalink: uva-11538\ndate: 2016-03-12 10:47:13\n---\n\n在一个 $ N * M $ 棋盘中放置两个皇后，使得它们可以相互攻击，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### 题解\n两个皇后可以互相攻击，当且仅当它们在「同一行」或「同一列」或「同一对角线」。这三种情况互相独立，可以用加法原理。\n\n考虑「同一行」的情况，用 $ f(a, b) $ 表示在一个 $ a $ 行 $ b $ 列的棋盘中放置两个皇后在同一行的方案数。令 $ a = 1 $，此时第一个皇后有 $ b $ 种放置方法，第二个有 $ b - 1 $ 种，即\n\n$$ f(1, b) = b(b - 1) $$\n\n推广到多行的情况，每一行的情况互不影响，可以用加法原理，即：\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n「同一列」和「同一行」原理相同，行列数互换后代入上式即可。\n\n「同一对角线」的情况比较复杂，假设 $ m ≥ n $，则同一方向的对角线中，有 $ m - n + 1 $ 条的长度为 $ n $（蓝色部分），剩下的两边分别有 $ n - 1 $ 条长度递增。\n\n![（图片使用 \nLibreOffice Calc \n制作）](uva-11538/cells.png)\n\n中间的一撮所对应的情况相当于在一个 $ m - n + 1 $ 行 $ n $ 列的棋盘中放置，使得两个皇后在**同一行**，即 $ f(m - n + 1, n) $。\n\n两边长度递增的对角线也要按照类似「同一行」的方法推导，即：\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n但是根据题目的数据范围，$ O(n) $ 地每次计算是会超时的，考虑展开。\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n分别使用平方和公式和等差数列求和公式展开，得\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n这是一边的长度递增的对角线上的方案数，两边的要乘以二，因为有两个方向，所以最后还要乘以二。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11538","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rac0041ooxl472q7ojl"},{"title":"「UVa 11375」Matches - 递推","date":"2016-03-13T03:07:45.000Z","_content":"\n有 $ N $ 个火柴，用这些火柴能摆出非负整数，摆出的数不能有前导零，火柴不必用完，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### 题解\n首先考虑不存在数字 0 的情况，用 $ f(i) $ 表示用 $ i $ 个火柴棒能摆出的方案总数，用 $ c(x) $ 表示摆出数字 x 使用的火柴棒数量。\n\n前导零是不被允许的，所以初始状态要把 1 ~ 9 几个数字的方案数加一。\n\n每次递推用 $ f(i) $ 去更新 $ f(i + c(x)) $（$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $），表示在 $ f(i) $ 表示的数字尾部添加一个 $ x $ 所得的方案。\n\n递推计算完成后求出前缀和 $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $ 即为答案，如果 $ n \\geq 6 $ 则需要将答案加一（考虑单独的数字 0）。\n\n需要使用高精度。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11375.md","raw":"title: 「UVa 11375」Matches - 递推\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - 高精度\npermalink: uva-11375\ndate: 2016-03-13 11:07:45\n---\n\n有 $ N $ 个火柴，用这些火柴能摆出非负整数，摆出的数不能有前导零，火柴不必用完，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### 题解\n首先考虑不存在数字 0 的情况，用 $ f(i) $ 表示用 $ i $ 个火柴棒能摆出的方案总数，用 $ c(x) $ 表示摆出数字 x 使用的火柴棒数量。\n\n前导零是不被允许的，所以初始状态要把 1 ~ 9 几个数字的方案数加一。\n\n每次递推用 $ f(i) $ 去更新 $ f(i + c(x)) $（$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $），表示在 $ f(i) $ 表示的数字尾部添加一个 $ x $ 所得的方案。\n\n递推计算完成后求出前缀和 $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $ 即为答案，如果 $ n \\geq 6 $ 则需要将答案加一（考虑单独的数字 0）。\n\n需要使用高精度。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11375","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ran0047ooxl2b7e0xtc"},{"title":"「UVa 11361」Investigating Div-Sum Property - 数位 DP","date":"2016-03-15T00:53:05.000Z","_content":"\n问在区间 $ [a, b] $ 内有多少数 $ x $ 满足：\n\n1. $ x $ 是 $ k $ 的倍数；\n2. $ x $ 的各位数之和是 $ k $ 的倍数。\n\n<!-- more -->\n\n### 链接\n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### 题解\n设 $ {\\rm sum}(x) $ 表示 $ x $ 的各位数之和，$ g(x, m_1, m_2) $ 表示 $ [0, x] $ 内有多少正整数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，问题转化为求 $ g(b, 0, 0) - g(a - 1, 0, 0) $。\n\n设 $ f(n, m_1, m_2) $ 表示有多少 $ n $ 位数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，计算 $ f $ 函数可以枚举最高位数字 1 ~ 9，并递归计算。\n\n$ g $ 函数也可以递归求，设参数 $ x $ 的最高位上的数为 $ t $，则可以先在 $ [0, t) $ 枚举最高位上的数，此时后面的低位数是任意的，可以由 $ f $ 函数来计算；最后令最高位为 $ x $，递归处理低位的数，累加起来就是答案。\n\n题目有坑，$ k $ 较大时结果直接为零 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11361.md","raw":"title: 「UVa 11361」Investigating Div-Sum Property - 数位 DP\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - DP\n  - 数位 DP\npermalink: uva-11361\ndate: 2016-03-15 08:53:05\n---\n\n问在区间 $ [a, b] $ 内有多少数 $ x $ 满足：\n\n1. $ x $ 是 $ k $ 的倍数；\n2. $ x $ 的各位数之和是 $ k $ 的倍数。\n\n<!-- more -->\n\n### 链接\n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### 题解\n设 $ {\\rm sum}(x) $ 表示 $ x $ 的各位数之和，$ g(x, m_1, m_2) $ 表示 $ [0, x] $ 内有多少正整数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，问题转化为求 $ g(b, 0, 0) - g(a - 1, 0, 0) $。\n\n设 $ f(n, m_1, m_2) $ 表示有多少 $ n $ 位数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，计算 $ f $ 函数可以枚举最高位数字 1 ~ 9，并递归计算。\n\n$ g $ 函数也可以递归求，设参数 $ x $ 的最高位上的数为 $ t $，则可以先在 $ [0, t) $ 枚举最高位上的数，此时后面的低位数是任意的，可以由 $ f $ 函数来计算；最后令最高位为 $ x $，递归处理低位的数，累加起来就是答案。\n\n题目有坑，$ k $ 较大时结果直接为零 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11361","published":1,"updated":"2016-10-24T23:28:44.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9raq004fooxlyk872vzc"},{"title":"「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元","date":"2016-03-13T09:20:34.000Z","_content":"\n分别属于多个家族的 $ N $（$ N \\leq 40000 $）个人想要站成一排，但没有人想站在他爹前面，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### 题解\n题目描述的父子关系组成了一个森林，每个家族对应一棵树，我们可以添加一个虚拟节点，让它成为每个家族祖先的「父亲」，然后求出整棵树的方案数即为答案。\n\n用 $ f(i) $ 表示以 $ i $ 为根的子树的方案数，用 $ s(i) $ 表示以 $ i $ 为根的子树的大小。\n\n首先，$ i $ 的几棵子树各自的排列方案是相互独立的，可以使用乘法原理来计算。\n\n还要注意一点，$ i $ 的几棵子树的节点是可以穿插排列的，即只需要保证每对父子的相对位置而整体是无序的。如果对所有子树的节点做全排列，那么改变了原有的父子相对位置的排列方案都是无效的，即**同一种穿插方式中多次改变父子相对位置只有一次有效**。我们可以把同一个子树的节点看做相同的，然后做**有重复元素的全排列**，就可以得到正确结果，因为每一种排列都对应且只对应一种顺序。\n\n「子树各自的排列方案」和「节点的穿插顺序」是相互独立的，因此要用乘法原理。\n\n用 $ c(i) $ 表示 $ i $ 的子节点的集合，则递归计算的公式为：\n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n公式中使用了除法，模意义下的除以一个数等于乘以这个数的**乘法逆元**，所以要在程序开始时递推预处理出所有数的阶乘，并求出对应的乘法逆元。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11174.md","raw":"title: 「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 数论\n  - 递推\n  - 计数原理\n  - 乘法逆元\n  - 全排列\npermalink: uva-11174\ndate: 2016-03-13 17:20:34\n---\n\n分别属于多个家族的 $ N $（$ N \\leq 40000 $）个人想要站成一排，但没有人想站在他爹前面，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### 题解\n题目描述的父子关系组成了一个森林，每个家族对应一棵树，我们可以添加一个虚拟节点，让它成为每个家族祖先的「父亲」，然后求出整棵树的方案数即为答案。\n\n用 $ f(i) $ 表示以 $ i $ 为根的子树的方案数，用 $ s(i) $ 表示以 $ i $ 为根的子树的大小。\n\n首先，$ i $ 的几棵子树各自的排列方案是相互独立的，可以使用乘法原理来计算。\n\n还要注意一点，$ i $ 的几棵子树的节点是可以穿插排列的，即只需要保证每对父子的相对位置而整体是无序的。如果对所有子树的节点做全排列，那么改变了原有的父子相对位置的排列方案都是无效的，即**同一种穿插方式中多次改变父子相对位置只有一次有效**。我们可以把同一个子树的节点看做相同的，然后做**有重复元素的全排列**，就可以得到正确结果，因为每一种排列都对应且只对应一种顺序。\n\n「子树各自的排列方案」和「节点的穿插顺序」是相互独立的，因此要用乘法原理。\n\n用 $ c(i) $ 表示 $ i $ 的子节点的集合，则递归计算的公式为：\n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n公式中使用了除法，模意义下的除以一个数等于乘以这个数的**乘法逆元**，所以要在程序开始时递推预处理出所有数的阶乘，并求出对应的乘法逆元。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11174","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rat004nooxl0udxuz2r"},{"title":"「UVa 11137」Ingenuous Cubrency - 递推 / 背包 DP","date":"2016-03-13T03:56:43.000Z","_content":"\n给出一个正整数 $ N $（$ N \\leq 1000 $），求有多少种方案把 $ N $ 表示成几个正整数的立方和的形式。\n\n<!-- more -->\n\n### 链接\n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### 题解\n书上的解法：用 $ f(i, j) $ 表示使用不超过 $ i $ 的整数的立方和表示数 $ j $ 的方案数。以 i 为阶段进行递推，对于每个 j，枚举新一个 $ i^3 $ 项的系数 $ x $ 使 $ j + xi^3 \\leq 1000 $，用 $ f(i - 1, j) $ 去更新 $ f(i, j + xi^3) $。最后 $ f(21, n) $ 即为答案。\n\n书上在最后提到可以优化。考虑将每个立方数看做物品，将 1000 看做背包，则问题转化为：求装满背包的方案。\n\n直接进行完全背包即可。\n\n### 代码\n#### 解法一\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### 解法二\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11137.md","raw":"title: 「UVa 11137」Ingenuous Cubrency - 递推 / 背包 DP\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - DP\n  - 背包 DP\npermalink: uva-11137\ndate: 2016-03-13 11:56:43\n---\n\n给出一个正整数 $ N $（$ N \\leq 1000 $），求有多少种方案把 $ N $ 表示成几个正整数的立方和的形式。\n\n<!-- more -->\n\n### 链接\n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### 题解\n书上的解法：用 $ f(i, j) $ 表示使用不超过 $ i $ 的整数的立方和表示数 $ j $ 的方案数。以 i 为阶段进行递推，对于每个 j，枚举新一个 $ i^3 $ 项的系数 $ x $ 使 $ j + xi^3 \\leq 1000 $，用 $ f(i - 1, j) $ 去更新 $ f(i, j + xi^3) $。最后 $ f(21, n) $ 即为答案。\n\n书上在最后提到可以优化。考虑将每个立方数看做物品，将 1000 看做背包，则问题转化为：求装满背包的方案。\n\n直接进行完全背包即可。\n\n### 代码\n#### 解法一\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### 解法二\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11137","published":1,"updated":"2016-10-24T23:28:29.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9raw004zooxlsfkm9zyy"},{"title":"「UVa 11021」Tribles - 概率与期望","date":"2016-05-31T12:05:00.000Z","_content":"\n有 $ k $ 个 Tribles，每个 Trible 只能存活一天，但在死亡之前，每个 Trible 有 $ p_i $ 的概率繁衍出 $ i $ 个 Tribles。求 $ m $ 天之后所有 Tribles 全部死亡的概率。\n\n<!-- more -->\n\n### 链接\n[UVa 11021](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=481&page=show_problem&problem=1962)  \n[COGS 1487](http://cogs.top/cogs/problem/problem.php?pid=1487)\n\n### 题解\n设 $ f(i) $ 为一个 Trible 经过 $ i $ 天后全部死亡的概率，则 $ x $ 个 Trible 经过 $ i $ 天后全部死亡的概率为 $ f(i) ^ x $。\n\n根据题意，每个 Trible 每天的繁衍行为共分为 $ n $ 种情况，每一种情况发生的概率乘以繁衍出的 Tribles 在剩余的 $ i - 1 $ 天全部死亡的概率的总和即为结果。\n\n边界条件为 $ f(0) = 1 $。\n\n$$ f(i) = \\sum\\limits_{j = 0} ^ {n - 1} f(i - 1) ^ j \\times p(j) $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXK = 1000;\nconst int MAXM = 1000;\n\nint main() {\n\tint t, n, k, m;\n\tscanf(\"%d\", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\tscanf(\"%d %d %d\", &n, &k, &m);\n\t\tstatic double p[MAXN], f[MAXK + 1];\n\t\tfor (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n\t\tstd::fill(f, f + m + 1, 0);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i] += p[j] * pow(f[i - 1], j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case #%d: %.7lf\\n\", i, pow(f[m], k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11021.md","raw":"title: 「UVa 11021」Tribles - 概率与期望\ncategories: OI\ntags: \n  - UVa\n  - COGS\n  - DP\n  - 数学\n  - 概率与期望\npermalink: uva-11021\ndate: 2016-05-31 20:05:00\n---\n\n有 $ k $ 个 Tribles，每个 Trible 只能存活一天，但在死亡之前，每个 Trible 有 $ p_i $ 的概率繁衍出 $ i $ 个 Tribles。求 $ m $ 天之后所有 Tribles 全部死亡的概率。\n\n<!-- more -->\n\n### 链接\n[UVa 11021](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=481&page=show_problem&problem=1962)  \n[COGS 1487](http://cogs.top/cogs/problem/problem.php?pid=1487)\n\n### 题解\n设 $ f(i) $ 为一个 Trible 经过 $ i $ 天后全部死亡的概率，则 $ x $ 个 Trible 经过 $ i $ 天后全部死亡的概率为 $ f(i) ^ x $。\n\n根据题意，每个 Trible 每天的繁衍行为共分为 $ n $ 种情况，每一种情况发生的概率乘以繁衍出的 Tribles 在剩余的 $ i - 1 $ 天全部死亡的概率的总和即为结果。\n\n边界条件为 $ f(0) = 1 $。\n\n$$ f(i) = \\sum\\limits_{j = 0} ^ {n - 1} f(i - 1) ^ j \\times p(j) $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXK = 1000;\nconst int MAXM = 1000;\n\nint main() {\n\tint t, n, k, m;\n\tscanf(\"%d\", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\tscanf(\"%d %d %d\", &n, &k, &m);\n\t\tstatic double p[MAXN], f[MAXK + 1];\n\t\tfor (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n\t\tstd::fill(f, f + m + 1, 0);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i] += p[j] * pow(f[i - 1], j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case #%d: %.7lf\\n\", i, pow(f[m], k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11021","published":1,"updated":"2016-10-24T23:28:54.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rb10057ooxl45cl24ny"},{"title":"「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数","date":"2016-03-15T07:35:55.000Z","_content":"\n串并联网络有两个端点，一个是源，一个是汇，递归定义如下：\n\n1. 一条单独的边是串并联网络；\n2. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将它们的源和汇分别接在一起也能得到串并联网络（并联）；\n3. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将 $ G1 $ 的源和 $ G2 $ 的汇接在一起也能得到串并联网络（串联）；\n\n并联或串联在一起的各个部分可以调换顺序，顺序改变后的串并联网络和之前是相同的。求 $ N $ 条边能组成多少种不同的串并联网络。\n\n<!-- more -->\n\n### 链接\n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### 题解\n书上的解法，考虑每个串并联网络都是一棵树，组成网络的几个部分是树的子节点，那么叶子节点就对应了网络中的边，并且整棵树从根到叶子，父子关系所代表的连接方式是交替着的，某一层是并联，则下一层即为串联。同一种树的形态，第一层的连接方式不同，也就对应了两个网络。\n\n问题转化为，求有多少子节点有序且有 $ N $ 个叶子节点的形态不同的树。设 $ f(n) $ 为答案，则可以根据各个子树所『分得』的叶子节点数量来递归求解 —— 回溯法枚举 $ n $ 的**整数划分**，就得到了单层子树所有的情况。\n\n假设整数划分的某一种方案中，有 $ k $ 个 $ i $，求这 $ k $ 棵子树的方案数可使用组合数：从 $ f(i) $ 个中选择 $ k $ 个，可重复选择，答案为 $ \\binom{f(i) + k - 1}{k} $。计算出每一组子树的方案数，相乘即为根节点的答案。\n\n最终答案为 $ f(n) * 2 $，注意 $ n = 1 $ 时答案为 $ 1 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","source":"_posts/uva-10253.md","raw":"title: 「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - 计数原理\n  - 组合数\n  - 整数划分\n  - 回溯\npermalink: uva-10253\ndate: 2016-03-15 15:35:55\n---\n\n串并联网络有两个端点，一个是源，一个是汇，递归定义如下：\n\n1. 一条单独的边是串并联网络；\n2. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将它们的源和汇分别接在一起也能得到串并联网络（并联）；\n3. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将 $ G1 $ 的源和 $ G2 $ 的汇接在一起也能得到串并联网络（串联）；\n\n并联或串联在一起的各个部分可以调换顺序，顺序改变后的串并联网络和之前是相同的。求 $ N $ 条边能组成多少种不同的串并联网络。\n\n<!-- more -->\n\n### 链接\n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### 题解\n书上的解法，考虑每个串并联网络都是一棵树，组成网络的几个部分是树的子节点，那么叶子节点就对应了网络中的边，并且整棵树从根到叶子，父子关系所代表的连接方式是交替着的，某一层是并联，则下一层即为串联。同一种树的形态，第一层的连接方式不同，也就对应了两个网络。\n\n问题转化为，求有多少子节点有序且有 $ N $ 个叶子节点的形态不同的树。设 $ f(n) $ 为答案，则可以根据各个子树所『分得』的叶子节点数量来递归求解 —— 回溯法枚举 $ n $ 的**整数划分**，就得到了单层子树所有的情况。\n\n假设整数划分的某一种方案中，有 $ k $ 个 $ i $，求这 $ k $ 棵子树的方案数可使用组合数：从 $ f(i) $ 个中选择 $ k $ 个，可重复选择，答案为 $ \\binom{f(i) + k - 1}{k} $。计算出每一组子树的方案数，相乘即为根节点的答案。\n\n最终答案为 $ f(n) * 2 $，注意 $ n = 1 $ 时答案为 $ 1 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","slug":"uva-10253","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rb5005fooxl4xju7de7"},{"title":"「Tyvj 3317」火车票 - 划分 DP","id":"18","updated":"2016-01-19T13:05:08.000Z","date":"2016-01-11T21:29:30.000Z","_content":"\n铁路线上有n（2 ≤ n ≤ 10000）个火车站，每个火车站到该线路的首发火车站距离都是已知的。任意两站之间的票价如下表所示：\n\n$$\\cases{0< X≤L1 & C1 \\\\ L1< X≤L2 & C2 \\\\ L2< X≤L3 & C3}$$\n\n其中L1，L2，L3，C1，C2，C3都是已知的正整数，且($1 ≤ L1 < L2 < L3 ≤ 10^9$, $1 ≤ C1 < C2 < C3 ≤ 10^9$)。显然若两站之间的距离大于 L3，那么从一站到另一站至少要买两张票。\n\n注意：每一张票在使用时只能从一站开始到另一站结束。\n\n对于给出的起点和终点，求出最省钱的方案。\n\n<!-- more -->\n\n### 链接\n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### 题解\n以经过火车站站点的数量划分阶段，用 $a[i]$表示从站点 `0` 到站点 `i` 的距离，用 $f[i]$ 表示从起点 `s` 到站点 `i` 所需要的最少花费，则转移方程为：\n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]≤L3\\} $$\n\n边界条件为\n\n$$ f[s] = 0 $$\n\n### 代码\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```\n","source":"_posts/tyvj-3317.md","raw":"title: 「Tyvj 3317」火车票 - 划分 DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - 划分 DP\npermalink: tyvj-3317\nid: 18\nupdated: '2016-01-19 21:05:08'\ndate: 2016-01-12 05:29:30\n---\n\n铁路线上有n（2 ≤ n ≤ 10000）个火车站，每个火车站到该线路的首发火车站距离都是已知的。任意两站之间的票价如下表所示：\n\n$$\\cases{0< X≤L1 & C1 \\\\ L1< X≤L2 & C2 \\\\ L2< X≤L3 & C3}$$\n\n其中L1，L2，L3，C1，C2，C3都是已知的正整数，且($1 ≤ L1 < L2 < L3 ≤ 10^9$, $1 ≤ C1 < C2 < C3 ≤ 10^9$)。显然若两站之间的距离大于 L3，那么从一站到另一站至少要买两张票。\n\n注意：每一张票在使用时只能从一站开始到另一站结束。\n\n对于给出的起点和终点，求出最省钱的方案。\n\n<!-- more -->\n\n### 链接\n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### 题解\n以经过火车站站点的数量划分阶段，用 $a[i]$表示从站点 `0` 到站点 `i` 的距离，用 $f[i]$ 表示从起点 `s` 到站点 `i` 所需要的最少花费，则转移方程为：\n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]≤L3\\} $$\n\n边界条件为\n\n$$ f[s] = 0 $$\n\n### 代码\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```\n","slug":"tyvj-3317","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rbg005rooxlwmmodxef"},{"title":"树链剖分学习笔记","date":"2015-12-27T14:48:11.000Z","_content":"\n更新于 2016 年 12 月 28 日。\n\n树链剖分是一种维护树上路径信息的算法，它将一棵树剖分成一些不相交的链，保证每个点在且仅在一条链上。并通过线段树、树状数组等数据结构维护每一条链上的信息。\n\n![zyz 大佬的评价](images/zyz.png)\n\n<!-- more -->\n\n### 题目：树的统计\n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n给出一棵树，每个点有一个可修改的点权，每次查询两点之间**所有点**的点权和或点权最大值。\n\n### 基本思想\n![](tree-chain-split-notes/1.svg)\n\n把整棵树划分成许多条**链**，使每个节点都在唯一的链上，对每一条链维护一棵**线段树**，把在树上的操作转移到线段树上。\n\n树链剖分的策略是**轻重边路径剖分**，这种策略可以保证整棵树上的轻边和链的数量都不超过  $ O(\\log n) $。\n\n### 定义\n```c++\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;  // 所在的链\n    // maxChild 最大的子树\n\tNode *fa, *maxChild; \n    // size 以当前节点为根的子树大小\n    // pos 当前节点在链上的编号\n\tint size, dfn, pos, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top; // 链的顶端\n    // 这里还可以维护更多的信息，比如链的长度\n    int len;\n\n\tChain(Node *top) : top(top), len(0) {}\n};\n```\n\n对于每个节点 $ v $，$ \\text{depth}(v) $ 表示这个节点的深度（即到整棵树的根的距离），$ \\text{size}(v) $ 表示以这个节点为根的树的大小（即节点总数），$ \\text{max-child}(v) $ 表示该节点的最大子树。\n\n每个节点都在一条链上，每条链 $ c $ 上深度最小的点称为链顶节点 $ \\text{top}(c) $。$ \\text{pos}(v) $ 表示当前节点 $ v $ 是链上的第几个点（链顶节点的 $ \\text{pos} $ 为 $ 1 $，即 $ \\text{pos}(\\text{top}(c)) = 1 $）。\n\n### 剖分\n```c++\ninline void split()\n{\n\tN[1].depth = 1; // 注意先赋值根的深度为 1\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n```\n\n剖分的过程主要由两次 DFS 组成，第一遍 DFS 求出每个节点 $ v $ 的 $ \\text{size}(v) $ 和 $ \\text{max-child}(v) $。\n\n```c++\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1; // 统计子节点之前，整棵树的大小为 1\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n\t\tif (!e->to->vis)\n        {\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n            \n\t\t\tdfs1(e->to);\n            \n            // 递归回溯时统计子树大小\n\t\t\tv->size += e->to->size;\n            \n            // 求最大子树，如果最大子树为空，\n            // 或者当前子树比最大子树更大，则更新最大子树\n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n```\n\n第二遍 DFS，求出每个点所在的链。\n\n对于每个节点，如果它是根（没有父节点）或它不是父节点的「最大子树（$ \\text{max-child} $）」，则创建一条以该节点为链顶节点的链，否则该节点与其父节点在同一条链上（实现了链的延伸）。\n\n为了维护树上路径信息，我们记录每个点的 DFS 序 $ \\text{dfn}(v) $，为了使同一条链上的点在 DFS 序中是相邻的，我们在 DFS 时优先递归处理最大子树 $ \\text{max-child} $。\n\n```c++\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0; // 时间戳\n\tv->dfn = ++ts;     // 记录 DFS 序\n\n\t// 创建一条新链\n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain; // 与父节点在同一条链上\n\n\t// 优先递归处理最大子树，\n    // 保证一条链在 DFS 序中是连续的\n\tif (v->maxChild) dfs2(v->maxChild); \n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n    \t// // 最大子树已经处理过，不要重复处理\n\t\tif (e->to->fa == v && e->to != v->maxChild)\n        {\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n```\n\n### 线段树\n我们使用线段树维护每一条链的信息，以 DFS 序建树，保证每条链上的节点在线段树中是连续的。\n\n```c++\nsegt = SegmentTree::build(1, n);\n```\n\n### 修改\n修改某个点的权值，只需要在线段树上该点 DFS 序的位置上更新即可。\n\n注意修改时一定要以 DFS 序作为修改位置。\n\n```cpp\ninline void update(int u, int x) {\n\tsegt->update(N[u].dfn, x);\n}\n```\n\n### 查询路径信息\n查询两个点 $ u $ 与 $ v $ 之间的点权和（或点权极值）的方法：\n\n1. 如果 $ u $ 与 $ v $ 不在同一条链上，不妨设 $ u $ **所在链链顶节点深度较大**，在线段树上查询 $ u $ 所在链链顶节点（$ \\text{top}(\\text{chain}(u)) $）到 $ u $ 的路径，并将 $ u $ 跳到其**所在链链顶节点**；\n2. 如果 $ u $ 与 $ v $ 在同一条链上，则直接在线段树中查询。\n\n注意查询时一定要以 DFS 序作为区间端点查询。\n\n```cpp\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n    {\n    \t// 令 u 链顶节点的深度较大\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN; // 答案初始化负无穷\n\twhile (u->chain != v->chain)\n    {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n```\n\n### 最近公共祖先\n用类似查询路径信息的方法，当两个点跳到同一条链上时，深度较小的即为原两点的 LCA。\n\n```c++\ninline Node *lca(Node *u, Node *v)\n{\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->fa;\n\t}\n\t\n\tif (u->depth > v->depth) std::swap(u, v);\n\treturn u;\n}\n```\n\n### 完整代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;\n\tNode *fa, *maxChild;\n\tint size, dfn, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top;\n\n\tChain(Node *top) : top(top) {}\n};\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n}\n\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n\t\t\tdfs1(e->to);\n\t\t\tv->size += e->to->size;\n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = ++ts;\n\n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain;\n\n\tif (v->maxChild) dfs2(v->maxChild);\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->to->fa == v && e->to != v->maxChild)\n\t\t{\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n\ninline void split()\n{\n\tN[1].depth = 1;\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n\nstruct SegmentTree\n{\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint sum, max;\n\n\tSegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), sum(0), max(INT_MIN) {}\n\n\tvoid maintain()\n\t{\n\t\tsum = lc->sum + rc->sum;\n\t\tmax = std::max(lc->max, rc->max);\n\t}\n\n\tvoid update(int pos, int x)\n\t{\n\t\tif (l == r) sum = max = x;\n\t\telse\n\t\t{\n\t\t\tif (pos <= mid) lc->update(pos, x);\n\t\t\telse rc->update(pos, x);\n\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tint querySum(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return lc->querySum(l, r) + rc->querySum(l, r);\n\t}\n\n\tint queryMax(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc->queryMax(l, r), rc->queryMax(l, r));\n\t}\n\n\tstatic SegmentTree *build(int l, int r)\n\t{\n\t\tif (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse\n\t\t{\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\ninline void update(int u, int x)\n{\n\tsegt->update(N[u].dfn, x);\n}\n\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsplit();\n\n\tsegt = SegmentTree::build(1, n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tupdate(i, x);\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tchar cmd[sizeof(\"CHANGE\")];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", cmd, &a, &b);\n\n\t\tif (cmd[1] == 'H')\n\t\t{\n\t\t\tupdate(a, b);\n\t\t}\n\t\telse if (cmd[1] == 'S')\n\t\t{\n\t\t\tprintf(\"%d\\n\", querySum(a, b));\n\t\t}\n\t\telse if (cmd[1] == 'M')\n\t\t{\n\t\t\tprintf(\"%d\\n\", queryMax(a, b));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tree-chain-split-notes.md","raw":"title: 树链剖分学习笔记\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - 数据结构\n  - 树链剖分\n  - 高级数据结构\n  - 算法模板  \npermalink: tree-chain-split-notes\ndate: 2015-12-27 22:48:11\n---\n\n更新于 2016 年 12 月 28 日。\n\n树链剖分是一种维护树上路径信息的算法，它将一棵树剖分成一些不相交的链，保证每个点在且仅在一条链上。并通过线段树、树状数组等数据结构维护每一条链上的信息。\n\n![zyz 大佬的评价](images/zyz.png)\n\n<!-- more -->\n\n### 题目：树的统计\n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n给出一棵树，每个点有一个可修改的点权，每次查询两点之间**所有点**的点权和或点权最大值。\n\n### 基本思想\n![](tree-chain-split-notes/1.svg)\n\n把整棵树划分成许多条**链**，使每个节点都在唯一的链上，对每一条链维护一棵**线段树**，把在树上的操作转移到线段树上。\n\n树链剖分的策略是**轻重边路径剖分**，这种策略可以保证整棵树上的轻边和链的数量都不超过  $ O(\\log n) $。\n\n### 定义\n```c++\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;  // 所在的链\n    // maxChild 最大的子树\n\tNode *fa, *maxChild; \n    // size 以当前节点为根的子树大小\n    // pos 当前节点在链上的编号\n\tint size, dfn, pos, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top; // 链的顶端\n    // 这里还可以维护更多的信息，比如链的长度\n    int len;\n\n\tChain(Node *top) : top(top), len(0) {}\n};\n```\n\n对于每个节点 $ v $，$ \\text{depth}(v) $ 表示这个节点的深度（即到整棵树的根的距离），$ \\text{size}(v) $ 表示以这个节点为根的树的大小（即节点总数），$ \\text{max-child}(v) $ 表示该节点的最大子树。\n\n每个节点都在一条链上，每条链 $ c $ 上深度最小的点称为链顶节点 $ \\text{top}(c) $。$ \\text{pos}(v) $ 表示当前节点 $ v $ 是链上的第几个点（链顶节点的 $ \\text{pos} $ 为 $ 1 $，即 $ \\text{pos}(\\text{top}(c)) = 1 $）。\n\n### 剖分\n```c++\ninline void split()\n{\n\tN[1].depth = 1; // 注意先赋值根的深度为 1\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n```\n\n剖分的过程主要由两次 DFS 组成，第一遍 DFS 求出每个节点 $ v $ 的 $ \\text{size}(v) $ 和 $ \\text{max-child}(v) $。\n\n```c++\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1; // 统计子节点之前，整棵树的大小为 1\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n\t\tif (!e->to->vis)\n        {\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n            \n\t\t\tdfs1(e->to);\n            \n            // 递归回溯时统计子树大小\n\t\t\tv->size += e->to->size;\n            \n            // 求最大子树，如果最大子树为空，\n            // 或者当前子树比最大子树更大，则更新最大子树\n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n```\n\n第二遍 DFS，求出每个点所在的链。\n\n对于每个节点，如果它是根（没有父节点）或它不是父节点的「最大子树（$ \\text{max-child} $）」，则创建一条以该节点为链顶节点的链，否则该节点与其父节点在同一条链上（实现了链的延伸）。\n\n为了维护树上路径信息，我们记录每个点的 DFS 序 $ \\text{dfn}(v) $，为了使同一条链上的点在 DFS 序中是相邻的，我们在 DFS 时优先递归处理最大子树 $ \\text{max-child} $。\n\n```c++\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0; // 时间戳\n\tv->dfn = ++ts;     // 记录 DFS 序\n\n\t// 创建一条新链\n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain; // 与父节点在同一条链上\n\n\t// 优先递归处理最大子树，\n    // 保证一条链在 DFS 序中是连续的\n\tif (v->maxChild) dfs2(v->maxChild); \n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n    \t// // 最大子树已经处理过，不要重复处理\n\t\tif (e->to->fa == v && e->to != v->maxChild)\n        {\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n```\n\n### 线段树\n我们使用线段树维护每一条链的信息，以 DFS 序建树，保证每条链上的节点在线段树中是连续的。\n\n```c++\nsegt = SegmentTree::build(1, n);\n```\n\n### 修改\n修改某个点的权值，只需要在线段树上该点 DFS 序的位置上更新即可。\n\n注意修改时一定要以 DFS 序作为修改位置。\n\n```cpp\ninline void update(int u, int x) {\n\tsegt->update(N[u].dfn, x);\n}\n```\n\n### 查询路径信息\n查询两个点 $ u $ 与 $ v $ 之间的点权和（或点权极值）的方法：\n\n1. 如果 $ u $ 与 $ v $ 不在同一条链上，不妨设 $ u $ **所在链链顶节点深度较大**，在线段树上查询 $ u $ 所在链链顶节点（$ \\text{top}(\\text{chain}(u)) $）到 $ u $ 的路径，并将 $ u $ 跳到其**所在链链顶节点**；\n2. 如果 $ u $ 与 $ v $ 在同一条链上，则直接在线段树中查询。\n\n注意查询时一定要以 DFS 序作为区间端点查询。\n\n```cpp\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n    {\n    \t// 令 u 链顶节点的深度较大\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN; // 答案初始化负无穷\n\twhile (u->chain != v->chain)\n    {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n```\n\n### 最近公共祖先\n用类似查询路径信息的方法，当两个点跳到同一条链上时，深度较小的即为原两点的 LCA。\n\n```c++\ninline Node *lca(Node *u, Node *v)\n{\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->fa;\n\t}\n\t\n\tif (u->depth > v->depth) std::swap(u, v);\n\treturn u;\n}\n```\n\n### 完整代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;\n\tNode *fa, *maxChild;\n\tint size, dfn, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top;\n\n\tChain(Node *top) : top(top) {}\n};\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n}\n\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n\t\t\tdfs1(e->to);\n\t\t\tv->size += e->to->size;\n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = ++ts;\n\n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain;\n\n\tif (v->maxChild) dfs2(v->maxChild);\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->to->fa == v && e->to != v->maxChild)\n\t\t{\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n\ninline void split()\n{\n\tN[1].depth = 1;\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n\nstruct SegmentTree\n{\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint sum, max;\n\n\tSegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), sum(0), max(INT_MIN) {}\n\n\tvoid maintain()\n\t{\n\t\tsum = lc->sum + rc->sum;\n\t\tmax = std::max(lc->max, rc->max);\n\t}\n\n\tvoid update(int pos, int x)\n\t{\n\t\tif (l == r) sum = max = x;\n\t\telse\n\t\t{\n\t\t\tif (pos <= mid) lc->update(pos, x);\n\t\t\telse rc->update(pos, x);\n\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tint querySum(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return lc->querySum(l, r) + rc->querySum(l, r);\n\t}\n\n\tint queryMax(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc->queryMax(l, r), rc->queryMax(l, r));\n\t}\n\n\tstatic SegmentTree *build(int l, int r)\n\t{\n\t\tif (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse\n\t\t{\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\ninline void update(int u, int x)\n{\n\tsegt->update(N[u].dfn, x);\n}\n\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsplit();\n\n\tsegt = SegmentTree::build(1, n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tupdate(i, x);\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tchar cmd[sizeof(\"CHANGE\")];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", cmd, &a, &b);\n\n\t\tif (cmd[1] == 'H')\n\t\t{\n\t\t\tupdate(a, b);\n\t\t}\n\t\telse if (cmd[1] == 'S')\n\t\t{\n\t\t\tprintf(\"%d\\n\", querySum(a, b));\n\t\t}\n\t\telse if (cmd[1] == 'M')\n\t\t{\n\t\t\tprintf(\"%d\\n\", queryMax(a, b));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tree-chain-split-notes","published":1,"updated":"2017-01-01T01:45:30.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rbn0060ooxlf67buek0"},{"title":"「TJOI2015」棋盘 - 状压 DP + 矩阵乘法","date":"2016-10-07T23:39:00.000Z","_content":"\n有一个 $ n $ 行 $ m $ 列的棋盘，每个棋子可以攻击到本行、上一行、下一行的一些棋子，求有多少种放棋子的方案使得任意两个棋子都不会互相攻击。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4000](http://www.lydsy.com/JudgeOnline/problem.php?id=4000)  \n[COGS 1979](http://cogs.pro/cogs/problem/problem.php?pid=1979)\n\n### 题解\n枚举一行内放置的所有方案，求出每种方案是否可行，并求出相邻两行放置的所有方案是否可行。\n\n设 $ f(i, j) $ 表示前 $ i $ 行，第 $ i $ 行放置状态为 $ j $ 的方案数，转移时枚举上一行的所有可行方案，累加。\n\n使用矩阵快速幂优化，时间复杂度为 $ O(m ^ 3 \\log n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\nconst int MAXM = 6;\nconst int MAXSTATUS = 1 << 6;\n\nstruct Matrix {\n\tunsigned int a[MAXSTATUS][MAXSTATUS];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXSTATUS; i++) a[i][i] = true;\n\t}\n\n\tunsigned int &operator()(const int i, const int j) { return a[i][j]; }\n\tconst unsigned int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) for (int k = 0; k < MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j);\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\n#ifdef DBG\ninline void print(const int x, const int m) {\n\tfor (int i = 0; i < m; i++) putchar((x & (1 << i)) ? '1' : '0');\n\t// putchar('\\n');\n}\n#endif\n\nint m, w, pos;\n\ninline void apply(const bool *tpl, const int j, bool *target) {\n\tfor (int k = 0; k < w; k++) {\n\t\tif (j - pos + k >= 0 && j - pos + k < m && tpl[k]) target[j - pos + k] = true;\n\t}\n}\n\nint main() {\n\tfreopen(\"tjoi2015_board.in\", \"r\", stdin);\n\tfreopen(\"tjoi2015_board.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d %d %d %d\", &n, &m, &w, &pos);\n\n\tstatic bool attack[3][MAXM];\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < w; j++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tattack[i][j] = x;\n\t}\n\tattack[1][pos] = false;\n\n\tstatic bool valid[MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tstatic bool tmp[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmp[k] = false;\n\t\tvalid[i] = true;\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j)) apply(attack[1], j, tmp);\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j) && tmp[j]) {\n\t\t\tvalid[i] = false;\n\t\t\tbreak;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(valid[i] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar('\\n');\n#endif\n\t}\n\n\tstatic bool near[MAXSTATUS][MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) for (int j = 0; j < (1 << m); j++) {\n\t\tif (!valid[i] || !valid[j]) {\n\t\t\tnear[i][j] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnear[i][j] = true;\n\t\tstatic bool tmpA[MAXM], tmpB[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmpA[k] = tmpB[k] = false;\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(i & (1 << k))) continue;\n\t\t\tapply(attack[2], k, tmpB);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(j & (1 << k))) continue;\n\t\t\tapply(attack[0], k, tmpA);\n\t\t}\n\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (((i & (1 << k)) && tmpA[k]) || ((j & (1 << k)) && tmpB[k])) {\n\t\t\t\tnear[i][j] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(near[i][j] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar(' ');\n\t\tprint(j, m);\n\t\tputchar('\\n');\n\n\t\tif (valid[i] && valid[j]) printf(\"near[%d][%d] = %d\\n\", i, j, static_cast<int>(near[i][j]));\n#endif\n\t}\n\n#ifdef DBG\n\tstatic unsigned int f[MAXN + 1][MAXSTATUS];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tif (!valid[j]) continue;\n\t\t\tfor (int k = 0; k < (1 << m); k++) {\n\t\t\t\tif (!valid[k]) continue;\n\t\t\t\tif (near[k][j]) f[i][j] += f[i - 1][k];\n\t\t\t}\n\n\t\t\tprintf(\"f(%d, [\", i);\n\t\t\tprint(j, m);\n\t\t\tprintf(\"] = %u\\n\", f[i][j]);\n\t\t}\n\t}\n\n\tunsigned int ansCheck = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ansCheck += f[n][i];\n#endif\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tif (valid[i]) {\n\t\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\t\tif (valid[j]) {\n\t\t\t\t\tif (near[j][i]) {\n\t\t\t\t\t\tshift(j, i) = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\n#ifndef FORCE\n\tMatrix res = pow(shift, n) * init;\n#else\n\tMatrix res(true);\n\tfor (int i = 1; i <= n; i++) {\n\t\tres = res * shift;\n#ifdef DBG\n\t\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) printf(\"%d%c\", res(i, j), j == MAXSTATUS - 1 ? '\\n' : ' ');\n#endif\n\t}\n\tres = res * init;\n#endif\n\n\tunsigned int ans = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ans += res(i, 0);\n\tprintf(\"%u\\n\", ans);\n\n#ifdef DBG\n\tprintf(\"ansCheck = %u\\n\", ansCheck);\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2015-chessboard.md","raw":"title: 「TJOI2015」棋盘 - 状压 DP + 矩阵乘法\ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - 状压 DP\n  - 矩阵乘法\npermalink: tjoi2015-chessboard\ndate: 2016-10-08 07:39:00\n---\n\n有一个 $ n $ 行 $ m $ 列的棋盘，每个棋子可以攻击到本行、上一行、下一行的一些棋子，求有多少种放棋子的方案使得任意两个棋子都不会互相攻击。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4000](http://www.lydsy.com/JudgeOnline/problem.php?id=4000)  \n[COGS 1979](http://cogs.pro/cogs/problem/problem.php?pid=1979)\n\n### 题解\n枚举一行内放置的所有方案，求出每种方案是否可行，并求出相邻两行放置的所有方案是否可行。\n\n设 $ f(i, j) $ 表示前 $ i $ 行，第 $ i $ 行放置状态为 $ j $ 的方案数，转移时枚举上一行的所有可行方案，累加。\n\n使用矩阵快速幂优化，时间复杂度为 $ O(m ^ 3 \\log n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\nconst int MAXM = 6;\nconst int MAXSTATUS = 1 << 6;\n\nstruct Matrix {\n\tunsigned int a[MAXSTATUS][MAXSTATUS];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXSTATUS; i++) a[i][i] = true;\n\t}\n\n\tunsigned int &operator()(const int i, const int j) { return a[i][j]; }\n\tconst unsigned int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) for (int k = 0; k < MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j);\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\n#ifdef DBG\ninline void print(const int x, const int m) {\n\tfor (int i = 0; i < m; i++) putchar((x & (1 << i)) ? '1' : '0');\n\t// putchar('\\n');\n}\n#endif\n\nint m, w, pos;\n\ninline void apply(const bool *tpl, const int j, bool *target) {\n\tfor (int k = 0; k < w; k++) {\n\t\tif (j - pos + k >= 0 && j - pos + k < m && tpl[k]) target[j - pos + k] = true;\n\t}\n}\n\nint main() {\n\tfreopen(\"tjoi2015_board.in\", \"r\", stdin);\n\tfreopen(\"tjoi2015_board.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d %d %d %d\", &n, &m, &w, &pos);\n\n\tstatic bool attack[3][MAXM];\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < w; j++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tattack[i][j] = x;\n\t}\n\tattack[1][pos] = false;\n\n\tstatic bool valid[MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tstatic bool tmp[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmp[k] = false;\n\t\tvalid[i] = true;\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j)) apply(attack[1], j, tmp);\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j) && tmp[j]) {\n\t\t\tvalid[i] = false;\n\t\t\tbreak;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(valid[i] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar('\\n');\n#endif\n\t}\n\n\tstatic bool near[MAXSTATUS][MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) for (int j = 0; j < (1 << m); j++) {\n\t\tif (!valid[i] || !valid[j]) {\n\t\t\tnear[i][j] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnear[i][j] = true;\n\t\tstatic bool tmpA[MAXM], tmpB[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmpA[k] = tmpB[k] = false;\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(i & (1 << k))) continue;\n\t\t\tapply(attack[2], k, tmpB);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(j & (1 << k))) continue;\n\t\t\tapply(attack[0], k, tmpA);\n\t\t}\n\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (((i & (1 << k)) && tmpA[k]) || ((j & (1 << k)) && tmpB[k])) {\n\t\t\t\tnear[i][j] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(near[i][j] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar(' ');\n\t\tprint(j, m);\n\t\tputchar('\\n');\n\n\t\tif (valid[i] && valid[j]) printf(\"near[%d][%d] = %d\\n\", i, j, static_cast<int>(near[i][j]));\n#endif\n\t}\n\n#ifdef DBG\n\tstatic unsigned int f[MAXN + 1][MAXSTATUS];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tif (!valid[j]) continue;\n\t\t\tfor (int k = 0; k < (1 << m); k++) {\n\t\t\t\tif (!valid[k]) continue;\n\t\t\t\tif (near[k][j]) f[i][j] += f[i - 1][k];\n\t\t\t}\n\n\t\t\tprintf(\"f(%d, [\", i);\n\t\t\tprint(j, m);\n\t\t\tprintf(\"] = %u\\n\", f[i][j]);\n\t\t}\n\t}\n\n\tunsigned int ansCheck = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ansCheck += f[n][i];\n#endif\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tif (valid[i]) {\n\t\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\t\tif (valid[j]) {\n\t\t\t\t\tif (near[j][i]) {\n\t\t\t\t\t\tshift(j, i) = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\n#ifndef FORCE\n\tMatrix res = pow(shift, n) * init;\n#else\n\tMatrix res(true);\n\tfor (int i = 1; i <= n; i++) {\n\t\tres = res * shift;\n#ifdef DBG\n\t\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) printf(\"%d%c\", res(i, j), j == MAXSTATUS - 1 ? '\\n' : ' ');\n#endif\n\t}\n\tres = res * init;\n#endif\n\n\tunsigned int ans = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ans += res(i, 0);\n\tprintf(\"%u\\n\", ans);\n\n#ifdef DBG\n\tprintf(\"ansCheck = %u\\n\", ansCheck);\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"tjoi2015-chessboard","published":1,"updated":"2016-10-24T23:29:16.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rbw0069ooxlmf2loxri"},{"title":"「TJOI2013」单词 - AC 自动机","date":"2016-09-11T23:07:00.000Z","_content":"\n某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3172](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n### 题解\nAC 自动机可以用来多模式串匹配。对所有的单词建 AC 自动机，在所有单词中间加一个非字母字符隔开组成论文。在 AC 自动机中匹配论文串，记录每个串的匹配次数即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1e6 + 200;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst char BASE_CHAR = '`';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n#ifdef DBG\n\t\tchar ch;\n#endif\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n#ifdef DBG\n\t\tv = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = &(*v)->c[*p];\n\t\t\t(*v)->ch = *p + 'a';\n\t\t}\n#endif\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\tchar *p = s;\n\n\tstatic Trie::Node *node[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n\t\t*p++ = 0;\n\t\tnode[i] = t.insert(s, s + len);\n\t}\n\n\t*--p = 0;\n\t// for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR);\n\n\tt.build();\n\tt.exec(s, p);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", node[i]->ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-word.md","raw":"title: 「TJOI2013」单词 - AC 自动机\ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - 字符串\n  - AC 自动机\npermalink: tjoi2013-word\ndate: 2016-09-12 07:07:00\n---\n\n某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3172](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n### 题解\nAC 自动机可以用来多模式串匹配。对所有的单词建 AC 自动机，在所有单词中间加一个非字母字符隔开组成论文。在 AC 自动机中匹配论文串，记录每个串的匹配次数即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1e6 + 200;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst char BASE_CHAR = '`';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n#ifdef DBG\n\t\tchar ch;\n#endif\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n#ifdef DBG\n\t\tv = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = &(*v)->c[*p];\n\t\t\t(*v)->ch = *p + 'a';\n\t\t}\n#endif\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\tchar *p = s;\n\n\tstatic Trie::Node *node[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n\t\t*p++ = 0;\n\t\tnode[i] = t.insert(s, s + len);\n\t}\n\n\t*--p = 0;\n\t// for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR);\n\n\tt.build();\n\tt.exec(s, p);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", node[i]->ans);\n\n\treturn 0;\n}\n```\n","slug":"tjoi2013-word","published":1,"updated":"2016-10-07T23:45:42.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rc1006hooxlvjp7qzfs"},{"title":"「TJOI2013」最长上升子序列 - 离线 + 树状数组","date":"2016-04-03T14:49:33.000Z","_content":"\n给定一个序列，初始为空。现在我们将 $ 1 $ 到 $ N $ 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？\n\n<!-- more -->\n\n### 链接\n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### 题解\n首先，将操作离线，可以得到最终序列中每个元素的位置。\n\n因为是从小到大加入，所以对某个元素的答案有贡献的元素仅为位置比它小且在它之前加入的元素，所以直接用一个树状数组维护前缀最大值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-lis.md","raw":"title: 「TJOI2013」最长上升子序列 - 离线 + 树状数组\ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - 离线\n  - Splay\n  - 树状数组\npermalink: tjoi2013-lis\ndate: 2016-04-03 22:49:33\n---\n\n给定一个序列，初始为空。现在我们将 $ 1 $ 到 $ N $ 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？\n\n<!-- more -->\n\n### 链接\n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### 题解\n首先，将操作离线，可以得到最终序列中每个元素的位置。\n\n因为是从小到大加入，所以对某个元素的答案有贡献的元素仅为位置比它小且在它之前加入的元素，所以直接用一个树状数组维护前缀最大值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tjoi2013-lis","published":1,"updated":"2016-10-07T23:45:34.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rc6006pooxlzn7qpvcm"},{"title":"所谓「初心」","date":"2016-12-31T04:41:00.000Z","_content":"\n“所谓初心，不过是没有勇气去面对未来的借口罢了。”\n\n<!-- more -->\n\n不知从何时起，总以为最美好的时光是在从前 ……  \n总能说出一些理由，让自己以为过去的时光是那么的美好 ……  \n越来越没有勇气去面对未来，即使口中的未来充满希望 ……\n\n走的路远了，也便感觉越来越沉重，死死的抓住过去不肯放手，即使那并无意义。「美好的时光一去不复返了」，却也只能这样叹息。这样有用吗？只不过是在奋力逃避现实的束缚罢了。\n\n感觉自己的内心永远在矛盾着 —— 从来没有勇气去做出任何选择，只是害怕失去。内心的状态永远是飘忽不定的，心情也时好时坏。像个小孩子一样脆弱，内心永远长不大，假装自己很坚强的样子，为了不让这个世界失望 —— 而这个世界早已让自己失望过多少次了。口中常说，自己要成为一个怎样的人，却永远只当作是个梦想 —— 没有在意过实现了多少，却能感觉到，离期望的那个样子，似乎越来越远了 ……  \n终于再也不敢喊出自己的梦想，就像从来没有过一样 ……\n\n周围的人都在欢声笑语，仿佛这一切都与我无关。  \n自己更像是个旁观者，见证着一些事情，从开始，到结束。  \n开始思考，自己来到这个世界上的意义是什么呢。\n\n这样有什么用呢。\n\n想要回到过去，重新来过，但却想不出什么后悔的地方。似乎，再走一遍，到头来，也还是这样吧。\n\n假装自己状态很好 ……  \n假装自己很坚强 ……  \n假装自己内心并不空虚 ……\n\n别人信了，自己也信了。\n\n曾寄希望于二次元，渴望能找到那种归属感，但最终还是发现，那是一个与我更加格格不入的世界。班级里的同学，也没有什么话可以说的。终于在 OI 的圈子里第一次有了朋友，却仍然没有勇气去与人交往。  \n我安慰自己，我与别人不一样。  \n但事实上，自己却是一个那样平凡的人。\n\n一直在努力着，渴望能被人们接受。  \n这样，也许有用吧。\n\n……\n\n该来的还是会来。  \n该得到的还是会得到。  \n该失去的还是会失去。  \n只是再也不敢说出，对未来的期望了。\n\n所谓「初心仍在」，又有什么意义呢？  \n所谓未来，又在何处呢 ……\n","source":"_posts/the-ever-heart.md","raw":"title: 所谓「初心」\ncategories: \n  - Diary\npermalink: the-ever-heart\ndate: 2016-12-31 12:41:00\n---\n\n“所谓初心，不过是没有勇气去面对未来的借口罢了。”\n\n<!-- more -->\n\n不知从何时起，总以为最美好的时光是在从前 ……  \n总能说出一些理由，让自己以为过去的时光是那么的美好 ……  \n越来越没有勇气去面对未来，即使口中的未来充满希望 ……\n\n走的路远了，也便感觉越来越沉重，死死的抓住过去不肯放手，即使那并无意义。「美好的时光一去不复返了」，却也只能这样叹息。这样有用吗？只不过是在奋力逃避现实的束缚罢了。\n\n感觉自己的内心永远在矛盾着 —— 从来没有勇气去做出任何选择，只是害怕失去。内心的状态永远是飘忽不定的，心情也时好时坏。像个小孩子一样脆弱，内心永远长不大，假装自己很坚强的样子，为了不让这个世界失望 —— 而这个世界早已让自己失望过多少次了。口中常说，自己要成为一个怎样的人，却永远只当作是个梦想 —— 没有在意过实现了多少，却能感觉到，离期望的那个样子，似乎越来越远了 ……  \n终于再也不敢喊出自己的梦想，就像从来没有过一样 ……\n\n周围的人都在欢声笑语，仿佛这一切都与我无关。  \n自己更像是个旁观者，见证着一些事情，从开始，到结束。  \n开始思考，自己来到这个世界上的意义是什么呢。\n\n这样有什么用呢。\n\n想要回到过去，重新来过，但却想不出什么后悔的地方。似乎，再走一遍，到头来，也还是这样吧。\n\n假装自己状态很好 ……  \n假装自己很坚强 ……  \n假装自己内心并不空虚 ……\n\n别人信了，自己也信了。\n\n曾寄希望于二次元，渴望能找到那种归属感，但最终还是发现，那是一个与我更加格格不入的世界。班级里的同学，也没有什么话可以说的。终于在 OI 的圈子里第一次有了朋友，却仍然没有勇气去与人交往。  \n我安慰自己，我与别人不一样。  \n但事实上，自己却是一个那样平凡的人。\n\n一直在努力着，渴望能被人们接受。  \n这样，也许有用吧。\n\n……\n\n该来的还是会来。  \n该得到的还是会得到。  \n该失去的还是会失去。  \n只是再也不敢说出，对未来的期望了。\n\n所谓「初心仍在」，又有什么意义呢？  \n所谓未来，又在何处呢 ……\n","slug":"the-ever-heart","published":1,"updated":"2016-12-31T05:02:27.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcc006zooxl7j0zh7n1"},{"title":"Tarjan 强联通分量学习笔记","date":"2016-03-03T13:12:23.000Z","_content":"\n在一个有向图中，如果某两点间都有**互相**到达的路径，那么称中两个点**强联通**，如果任意两点都强联通，那么称这个图为**强联通图**；一个有向图的**极大**强联通子图称为**强联通分量**。\n\nTarjan 算法可以在 $ O(n + m) $ 的时间内求出一个图的所有强联通分量。\n\n<!-- more -->\n\n### 定义\nTarjan 算法的核心过程是一次 DFS，它基于的事实是，一个强联通分量中的点一定处于搜索树中同一棵子树中。\n\n栈，搜索树中同一棵子树中的点在栈中是相邻的。\n\n$ {\\rm dfn}(u) $ 表示进入节点 $ u $ 时的时间。\n\n$ {\\rm low}(u) $ 表示由节点 $ u $ 开始搜索所能到达的点中，在搜索树上是 $ u $ 的祖先且 $ {\\rm dfn} $ 最小的节点的 $ {\\rm dfn} $。\n\n### 算法描述\n1. 从起点开始 DFS；\n2. 进入一个节点时，初始化它的 $ {\\rm dfn} $ 和 $ {\\rm low} $ 均为当前时间戳，并进栈；\n3. 枚举当前点 $ v $ 的所有邻接点；\n4. 如果某个邻接点 $ u $ 已在栈中，则更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $；\n5. 如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $；\n6. 所有邻接点回溯完成后，如果当前点仍满足 $ {\\rm low}(v) = {\\rm dfn}(v) $，则将栈中从 $ v $ 到栈顶的所有元素出栈，并标记为一个强联通分量。\n\n### 解释\n枚举 $ v $ 的邻接点时，如果某个邻接点 $ u $ 已在栈中，则更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n因为栈中的所有点均为搜索树上点 $ v $ 的祖先，从搜索树上一个点搜到它的祖先，说明找到了一个环。此时用 $ u $ 去更新 $ v $ 的最远祖先。\n\n如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n点 $ u $ 出发能到达的点，点 $ v $ 必定也能到达。尽管 $ {\\rm low}(u) $ 可能不是 $ v $ 的祖先（可能是 $ u $ 或 $ v $ 本身），但这并不影响。\n\n所有邻接点回溯完成后，如果当前点仍满足\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n说明从当前点出发不可能回到任意一个搜索树上的祖先，即当前节点是某个强联通分量所在子树的根节点，而这些节点都在当前节点之后被压在了栈中。\n\n注意，同一个强联通分量的点一定有相同的 $ {\\rm low} $ 值，$ {\\rm low} $ 值相同的两个点也一定在同一个强联通分量中。\n\n### 模板\n实际代码中要用到两个栈，一个用于控制 DFS（代码中的 `s`），另一个用于 Tarjan 算法（代码中的 `t`）。\n\n因为图不一定是弱连通图，所以要以每个点为起点进行一次上述算法。\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","source":"_posts/tarjan-scc-notes.md","raw":"title: Tarjan 强联通分量学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 强联通分量\n  - Tarjan\n  - 算法模板\npermalink: tarjan-scc-notes\ndate: 2016-03-03 21:12:23\n---\n\n在一个有向图中，如果某两点间都有**互相**到达的路径，那么称中两个点**强联通**，如果任意两点都强联通，那么称这个图为**强联通图**；一个有向图的**极大**强联通子图称为**强联通分量**。\n\nTarjan 算法可以在 $ O(n + m) $ 的时间内求出一个图的所有强联通分量。\n\n<!-- more -->\n\n### 定义\nTarjan 算法的核心过程是一次 DFS，它基于的事实是，一个强联通分量中的点一定处于搜索树中同一棵子树中。\n\n栈，搜索树中同一棵子树中的点在栈中是相邻的。\n\n$ {\\rm dfn}(u) $ 表示进入节点 $ u $ 时的时间。\n\n$ {\\rm low}(u) $ 表示由节点 $ u $ 开始搜索所能到达的点中，在搜索树上是 $ u $ 的祖先且 $ {\\rm dfn} $ 最小的节点的 $ {\\rm dfn} $。\n\n### 算法描述\n1. 从起点开始 DFS；\n2. 进入一个节点时，初始化它的 $ {\\rm dfn} $ 和 $ {\\rm low} $ 均为当前时间戳，并进栈；\n3. 枚举当前点 $ v $ 的所有邻接点；\n4. 如果某个邻接点 $ u $ 已在栈中，则更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $；\n5. 如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $；\n6. 所有邻接点回溯完成后，如果当前点仍满足 $ {\\rm low}(v) = {\\rm dfn}(v) $，则将栈中从 $ v $ 到栈顶的所有元素出栈，并标记为一个强联通分量。\n\n### 解释\n枚举 $ v $ 的邻接点时，如果某个邻接点 $ u $ 已在栈中，则更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n因为栈中的所有点均为搜索树上点 $ v $ 的祖先，从搜索树上一个点搜到它的祖先，说明找到了一个环。此时用 $ u $ 去更新 $ v $ 的最远祖先。\n\n如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n点 $ u $ 出发能到达的点，点 $ v $ 必定也能到达。尽管 $ {\\rm low}(u) $ 可能不是 $ v $ 的祖先（可能是 $ u $ 或 $ v $ 本身），但这并不影响。\n\n所有邻接点回溯完成后，如果当前点仍满足\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n说明从当前点出发不可能回到任意一个搜索树上的祖先，即当前节点是某个强联通分量所在子树的根节点，而这些节点都在当前节点之后被压在了栈中。\n\n注意，同一个强联通分量的点一定有相同的 $ {\\rm low} $ 值，$ {\\rm low} $ 值相同的两个点也一定在同一个强联通分量中。\n\n### 模板\n实际代码中要用到两个栈，一个用于控制 DFS（代码中的 `s`），另一个用于 Tarjan 算法（代码中的 `t`）。\n\n因为图不一定是弱连通图，所以要以每个点为起点进行一次上述算法。\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","slug":"tarjan-scc-notes","published":1,"updated":"2016-12-21T02:08:20.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcj0072ooxl3m66k49j"},{"title":"Tarjan 割点学习笔记","date":"2016-09-08T11:45:00.000Z","_content":"\n在一个无向图中，如果删掉点 $ v $ 后图的连通块数量增加，则称点 $ v $ 为图的**割点**。\n\n<!-- more -->\n\n### 定义\n$ \\mathrm{dfn}(u) $ 表示进入节点 $ u $ 时的时间。\n\n$ \\mathrm{low}(u) $ 表示由节点 $ u $ 开始搜索所能到达的点中，在搜索树上是 $ u $ 的祖先且 $ \\mathrm{dfn} $ 最小的节点的 $ \\mathrm{dfn} $。\n\n### 算法描述\n类似于 Tarjan 求强连通分量的算法。\n\n1. 从起点开始 DFS；\n2. 进入一个节点时，初始化它的 $ \\mathrm{dfn} $ 和 $ \\mathrm{low} $ 均为当前时间戳；\n3. 枚举当前点 $ v $ 的所有邻接点；\n4. 如果某个邻接点 $ u $ 已被访问过，则更新 $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{dfn}(u)) $；\n5. 如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新 $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{low(u)}) $；\n6. 对于一个搜索树上的非根节点 $ u $，如果存在子节点 $ v $，满足 $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $，则 $ u $ 为割点；\n7. 对于根节点，如果它有两个或更多的子节点，则它为割点。\n\n### 解释\n> 对于根节点，如果它有两个或更多的子节点，则它为割点。\n\n显然，根是两棵子树上节点的唯一连通方式。\n\n> 对于一个搜索树上的非根节点 $ u $，如果存在子节点 $ v $，满足 $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $，则 $ u $ 为割点；\n\n$ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ 的意义是，$ v $ 向上无法到达 $ u $ 的父节点。\n\n### 模板\n递归（CodeVS 5524）：\n\n更新于 2016 年 12 月 29 日。\n\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tNode *fa;\n\tint dfn, low;\n\tbool vis, isCut;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].firstEdge = new Edge(&N[s], &N[t]);\n\tN[t].firstEdge = new Edge(&N[t], &N[s]);\n}\n\ninline int tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint res = 0, childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\tres += tarjan(e->to);\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (v->fa)\n\t\t\t{\n\t\t\t\t// 某个子节点能到达的最高点不高于 v\n\t\t\t\tif (e->to->low >= v->dfn) v->isCut = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 不是搜索树的根\n\t\t\t\t// 有两个以上的子树\n\t\t\t\tif (++childCnt == 2) v->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 无向图 DFS 树没有横叉边，所有非树边均为返祖边\n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (v->isCut) res++;\n\n\treturn res;\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis) ans += tarjan(&N[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\tN[i].vis = N[i].isCut = false;\n\t\tN[i].dfn = N[i].low = 0;\n\t\tN[i].fa = NULL;\n\t}\n\n\treturn 0;\n}\n```\n\n非递归：\n\n```c++\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n```\n","source":"_posts/tarjan-cut-notes.md","raw":"title: Tarjan 割点学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 割点\n  - Tarjan\n  - 算法模板\npermalink: tarjan-cut-notes\ndate: 2016-09-08 19:45:00\n---\n\n在一个无向图中，如果删掉点 $ v $ 后图的连通块数量增加，则称点 $ v $ 为图的**割点**。\n\n<!-- more -->\n\n### 定义\n$ \\mathrm{dfn}(u) $ 表示进入节点 $ u $ 时的时间。\n\n$ \\mathrm{low}(u) $ 表示由节点 $ u $ 开始搜索所能到达的点中，在搜索树上是 $ u $ 的祖先且 $ \\mathrm{dfn} $ 最小的节点的 $ \\mathrm{dfn} $。\n\n### 算法描述\n类似于 Tarjan 求强连通分量的算法。\n\n1. 从起点开始 DFS；\n2. 进入一个节点时，初始化它的 $ \\mathrm{dfn} $ 和 $ \\mathrm{low} $ 均为当前时间戳；\n3. 枚举当前点 $ v $ 的所有邻接点；\n4. 如果某个邻接点 $ u $ 已被访问过，则更新 $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{dfn}(u)) $；\n5. 如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新 $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{low(u)}) $；\n6. 对于一个搜索树上的非根节点 $ u $，如果存在子节点 $ v $，满足 $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $，则 $ u $ 为割点；\n7. 对于根节点，如果它有两个或更多的子节点，则它为割点。\n\n### 解释\n> 对于根节点，如果它有两个或更多的子节点，则它为割点。\n\n显然，根是两棵子树上节点的唯一连通方式。\n\n> 对于一个搜索树上的非根节点 $ u $，如果存在子节点 $ v $，满足 $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $，则 $ u $ 为割点；\n\n$ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ 的意义是，$ v $ 向上无法到达 $ u $ 的父节点。\n\n### 模板\n递归（CodeVS 5524）：\n\n更新于 2016 年 12 月 29 日。\n\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tNode *fa;\n\tint dfn, low;\n\tbool vis, isCut;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].firstEdge = new Edge(&N[s], &N[t]);\n\tN[t].firstEdge = new Edge(&N[t], &N[s]);\n}\n\ninline int tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint res = 0, childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\tres += tarjan(e->to);\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (v->fa)\n\t\t\t{\n\t\t\t\t// 某个子节点能到达的最高点不高于 v\n\t\t\t\tif (e->to->low >= v->dfn) v->isCut = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 不是搜索树的根\n\t\t\t\t// 有两个以上的子树\n\t\t\t\tif (++childCnt == 2) v->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 无向图 DFS 树没有横叉边，所有非树边均为返祖边\n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (v->isCut) res++;\n\n\treturn res;\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis) ans += tarjan(&N[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\tN[i].vis = N[i].isCut = false;\n\t\tN[i].dfn = N[i].low = 0;\n\t\tN[i].fa = NULL;\n\t}\n\n\treturn 0;\n}\n```\n\n非递归：\n\n```c++\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n```\n","slug":"tarjan-cut-notes","published":1,"updated":"2017-01-01T01:45:20.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcq007cooxll7931685"},{"title":"Tarjan 双联通分量学习笔记","date":"2017-01-01T00:09:00.000Z","_content":"\n坑。\n\n<!-- more -->\n\n### 代码（POJ 1523）\n![zyz 大佬的评价](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge, *inEdge;\n\tint dfn, low;\n\tbool vis, isCut;\n\tNode *fa;\n\tstd::vector<struct BCC *> inBCC; // 一个点所属于的双连通分量们（只有割点会属于多个双连通分量）\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next, *revEdge; // 记录反向边\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct BCC\n{\n\tstd::vector<Node *> nodes; // 可以记录，如，双连通分量中有哪些点\n} bccs[MAXN + 1];\n\nint cnt;\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n\n\tN[from].firstEdge->revEdge = N[to].firstEdge;\n\tN[to].firstEdge->revEdge = N[from].firstEdge;\n}\n\ninline void tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tstatic std::stack<Edge *> s;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->revEdge == v->inEdge) continue; // 判断由父节点到该节点的边的反向边走回父节点\n\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\ts.push(e); // 树边入栈\n\n\t\t\tchildCnt++;\n\n\t\t\te->to->fa = v;\n\t\t\te->to->inEdge = e; // 记录入边\n\t\t\ttarjan(e->to);\n\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (e->to->low >= v->dfn) // 找到割点\n\t\t\t{\n\t\t\t\tv->isCut = true;      // 根总是会在这里被认为是割点，稍后判断根是否为真正的割点\n\n\t\t\t\t// 记录点双连通分量\n\t\t\t\tEdge *tmp;\n\t\t\t\tBCC *bcc = &bccs[++cnt];\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\ttmp = s.top();\n\t\t\t\t\ts.pop();\n\n\t\t\t\t\t// 如果这个点「所属于的最后一个双连通分量」不是「当前的双连通分量 bcc」\n\t\t\t\t\t// 因为这些边可能枚举到重复的点，为了不重复记录一个点所属于的双连通分量\n\t\t\t\t\tif (tmp->from->inBCC.empty() || tmp->from->inBCC.back() != bcc)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp->from->inBCC.push_back(bcc);\n\t\t\t\t\t\tbcc->nodes.push_back(tmp->from);\n\t\t\t\t\t}\n\n\t\t\t\t\t// 同理\n\t\t\t\t\tif (tmp->to->inBCC.empty() || tmp->to->inBCC.back() != bcc)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp->to->inBCC.push_back(bcc);\n\t\t\t\t\t\tbcc->nodes.push_back(tmp->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (tmp != e); // 直到当前边为止，类比强连通分量的求法\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts.push(e); // 返祖边入栈\n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (!v->fa && childCnt < 2) v->isCut = false; // 如果根的子节点数量不够 2，则它不是一个割点\n}\n\nint main() {\n\tint T = 0;\n\twhile (1)\n\t{\n\t\t++T;\n\n\t\tint n = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(\"%d\", &u);\n\n\t\t\tif (u == 0) break;\n\n\t\t\tscanf(\"%d\", &v);\n\n\t\t\tn = std::max(n, u);\n\t\t\tn = std::max(n, v);\n\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (!N[i].vis) tarjan(&N[i]);\n\t\t}\n\n\t\tif (T != 1) putchar('\\n');\n\t\tprintf(\"Network #%d\\n\", T);\n\n\t\tbool flag = false;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].isCut)\n\t\t\t{\n\t\t\t\tprintf(\"  SPF node %d leaves %d subnets\\n\", i, int(N[i].inBCC.size()));\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!flag) puts(\"  No SPF nodes\");\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].isCut = N[i].vis = false;\n\t\t\tN[i].fa = NULL;\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].inBCC.clear();\n\t\t}\n\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tbccs[i].nodes.clear();\n\t\t}\n\n\t\tcnt = 0;\n\n\t\tif (n == 0) break;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tarjan-bcc-notes.md","raw":"title: Tarjan 双联通分量学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 双联通分量\n  - Tarjan\n  - 算法模板\npermalink: tarjan-bcc-notes\ndate: 2017-01-01 08:09:00\n---\n\n坑。\n\n<!-- more -->\n\n### 代码（POJ 1523）\n![zyz 大佬的评价](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge, *inEdge;\n\tint dfn, low;\n\tbool vis, isCut;\n\tNode *fa;\n\tstd::vector<struct BCC *> inBCC; // 一个点所属于的双连通分量们（只有割点会属于多个双连通分量）\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next, *revEdge; // 记录反向边\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct BCC\n{\n\tstd::vector<Node *> nodes; // 可以记录，如，双连通分量中有哪些点\n} bccs[MAXN + 1];\n\nint cnt;\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n\n\tN[from].firstEdge->revEdge = N[to].firstEdge;\n\tN[to].firstEdge->revEdge = N[from].firstEdge;\n}\n\ninline void tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tstatic std::stack<Edge *> s;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->revEdge == v->inEdge) continue; // 判断由父节点到该节点的边的反向边走回父节点\n\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\ts.push(e); // 树边入栈\n\n\t\t\tchildCnt++;\n\n\t\t\te->to->fa = v;\n\t\t\te->to->inEdge = e; // 记录入边\n\t\t\ttarjan(e->to);\n\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (e->to->low >= v->dfn) // 找到割点\n\t\t\t{\n\t\t\t\tv->isCut = true;      // 根总是会在这里被认为是割点，稍后判断根是否为真正的割点\n\n\t\t\t\t// 记录点双连通分量\n\t\t\t\tEdge *tmp;\n\t\t\t\tBCC *bcc = &bccs[++cnt];\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\ttmp = s.top();\n\t\t\t\t\ts.pop();\n\n\t\t\t\t\t// 如果这个点「所属于的最后一个双连通分量」不是「当前的双连通分量 bcc」\n\t\t\t\t\t// 因为这些边可能枚举到重复的点，为了不重复记录一个点所属于的双连通分量\n\t\t\t\t\tif (tmp->from->inBCC.empty() || tmp->from->inBCC.back() != bcc)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp->from->inBCC.push_back(bcc);\n\t\t\t\t\t\tbcc->nodes.push_back(tmp->from);\n\t\t\t\t\t}\n\n\t\t\t\t\t// 同理\n\t\t\t\t\tif (tmp->to->inBCC.empty() || tmp->to->inBCC.back() != bcc)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp->to->inBCC.push_back(bcc);\n\t\t\t\t\t\tbcc->nodes.push_back(tmp->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (tmp != e); // 直到当前边为止，类比强连通分量的求法\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts.push(e); // 返祖边入栈\n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (!v->fa && childCnt < 2) v->isCut = false; // 如果根的子节点数量不够 2，则它不是一个割点\n}\n\nint main() {\n\tint T = 0;\n\twhile (1)\n\t{\n\t\t++T;\n\n\t\tint n = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(\"%d\", &u);\n\n\t\t\tif (u == 0) break;\n\n\t\t\tscanf(\"%d\", &v);\n\n\t\t\tn = std::max(n, u);\n\t\t\tn = std::max(n, v);\n\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (!N[i].vis) tarjan(&N[i]);\n\t\t}\n\n\t\tif (T != 1) putchar('\\n');\n\t\tprintf(\"Network #%d\\n\", T);\n\n\t\tbool flag = false;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].isCut)\n\t\t\t{\n\t\t\t\tprintf(\"  SPF node %d leaves %d subnets\\n\", i, int(N[i].inBCC.size()));\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!flag) puts(\"  No SPF nodes\");\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].isCut = N[i].vis = false;\n\t\t\tN[i].fa = NULL;\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].inBCC.clear();\n\t\t}\n\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tbccs[i].nodes.clear();\n\t\t}\n\n\t\tcnt = 0;\n\n\t\tif (n == 0) break;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tarjan-bcc-notes","published":1,"updated":"2017-01-01T01:45:08.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcu007kooxl669tzoxp"},{"title":"差分约束系统学习笔记","date":"2016-01-01T16:18:34.000Z","_content":"\n差分约束系统，就是给出一组形如 $x_i-x_j>=d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。\n\n<!-- more -->\n\n### 原理\n在图论中，求解单源最短路的算法在进行每一次每条边上的“松弛”操作时，都是根据以下条件：\n\n（其中 `from`、`to` 表示边的起点、终点，`$` 表示某个点到源点的当前距离）\n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n也就是说，每一次松弛操作保证了：\n\n```php\n$to - $from >= w\n```\n\n于是，我们可以把差分约束系统中的变量看做图中的**点**，把不等关系看做**边**，然后对整个图进行一次单源最短路算法，即可使所有不等式满足。\n\n如果图中存在**权值和为负**的环，则说明不等式组无解。\n\n### 实现\n对于每一个不等式 $x_i-x_j>=d$，从 `j` 向 `i` 连一条边，权值为 `d`。\n\n如果不等号的方向相反，即 $x_i-x_j>=d$，则应在不等式两边同时乘以 `-1`，变成 $x_j-x_i<=-d$，即从 `i` 到 `j` 连一条边，权值为 `-d`。\n\n算法初始化时，将源点的 `dist` 置为 `0`，其他的点 `dist` 置为无穷大。若有解，则算法结束后每个点的 `dist` 值即为解。\n\n如果图中有负边，则必须使用 Bellman-Ford 算法，如果 Bellman-Ford 算法在 `n - 1` 次松弛后还继续进行松弛，则说明图中有**权值和为负**的环，原不等式组无解。\n\n如果使用带有队列优化的 Bellman-Ford 算法，则每个点入队次数超过 `n` 时说明图中有**权值和为负**的环，原不等式组无解。\n\n### 例题\n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF 团卧底的后宫\n\n给出 `n` 个形如 $x_i-x_j<=d$ 或 $x_i-x_j>=d$ 的不等式，求一组使 $x_1$ 与 $x_n$ 差最大的解，输出最大差值，若无解输出 `-1`，若 $x_1$ 与 $x_n$ 的差为无限大则输出 `-2`。\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/system-of-difference-constraints-notes.md","raw":"title: 差分约束系统学习笔记\ncategories: OI\ntags: \n  - 图论\n  - 学习笔记\n  - 差分约束系统\n  - 最短路\n  - 算法模板\npermalink: system-of-difference-constraints-notes\ndate: 2016-01-02 00:18:34\n---\n\n差分约束系统，就是给出一组形如 $x_i-x_j>=d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。\n\n<!-- more -->\n\n### 原理\n在图论中，求解单源最短路的算法在进行每一次每条边上的“松弛”操作时，都是根据以下条件：\n\n（其中 `from`、`to` 表示边的起点、终点，`$` 表示某个点到源点的当前距离）\n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n也就是说，每一次松弛操作保证了：\n\n```php\n$to - $from >= w\n```\n\n于是，我们可以把差分约束系统中的变量看做图中的**点**，把不等关系看做**边**，然后对整个图进行一次单源最短路算法，即可使所有不等式满足。\n\n如果图中存在**权值和为负**的环，则说明不等式组无解。\n\n### 实现\n对于每一个不等式 $x_i-x_j>=d$，从 `j` 向 `i` 连一条边，权值为 `d`。\n\n如果不等号的方向相反，即 $x_i-x_j>=d$，则应在不等式两边同时乘以 `-1`，变成 $x_j-x_i<=-d$，即从 `i` 到 `j` 连一条边，权值为 `-d`。\n\n算法初始化时，将源点的 `dist` 置为 `0`，其他的点 `dist` 置为无穷大。若有解，则算法结束后每个点的 `dist` 值即为解。\n\n如果图中有负边，则必须使用 Bellman-Ford 算法，如果 Bellman-Ford 算法在 `n - 1` 次松弛后还继续进行松弛，则说明图中有**权值和为负**的环，原不等式组无解。\n\n如果使用带有队列优化的 Bellman-Ford 算法，则每个点入队次数超过 `n` 时说明图中有**权值和为负**的环，原不等式组无解。\n\n### 例题\n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF 团卧底的后宫\n\n给出 `n` 个形如 $x_i-x_j<=d$ 或 $x_i-x_j>=d$ 的不等式，求一组使 $x_1$ 与 $x_n$ 差最大的解，输出最大差值，若无解输出 `-1`，若 $x_1$ 与 $x_n$ 的差为无限大则输出 `-2`。\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"system-of-difference-constraints-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcx007sooxl0re9kkbg"},{"title":"后缀数组学习笔记","date":"2016-04-12T11:29:14.000Z","_content":"\n在 OI 竞赛中，有一类题目是面向字符串的。这类题目往往要求选手的程序快速地求出给定的字符串的某些信息，这就需要一些对应的数据结构和算法来维护字符串。后缀数组就是一个这样的数据结构 —— 它通过对字符串后缀的处理，可以方便地得到子串的信息。\n\n<!-- more -->\n\n### 定义\n字符串 $ s $ 连续的一段字符组成的串叫做字符串，更广义地，任何一个由可比较大小的元素组成的数组都可称为字符串。字符串的下标从 $ 0 $ 开始，长度为 $ {\\rm length}(s) $。\n\n后缀：$ {\\rm suffix}(i) $ 表示字符串 $ s $ 从第 $ i $ 个位置开始的后缀，即由 $ s[i] $ ~ $ s[n - 1] $ 组成的子串。\n\n字符串的比较：  \n两个字符串大小的比较，从首位开始，一位一位地按照 ASCII 码比较，如果从某位置开始不相同，则认为该位置处字符 ASCII 码小的字符串小；  \n如果一个字符串比较完了最后一位，而另一个没有，则认为前者（长度小的）小；  \n如果两个字符串长度相同并且所有位置上的字符均相同，则认为两个字符串相等。\n\n注意，同一个字符串的两个后缀是不可能相等的，因为无法满足相等的必要条件**长度相同**。\n\n后缀数组：$ {\\rm SA}[] $ 是一个一维数组，保存了对字符串 $ s $ 的所有后缀排序后的结果。$ {\\rm SA}[i] $ 表示第 $ i $ 小的后缀在原串中的起始位置。\n\n名次数组：$ {\\rm rank}[] $ 是一个一维数组，按起始位置保存了每个后缀在 $ {\\rm SA}[] $ 中的排名。$ {\\rm rank}[i] $ 表示 $ {\\rm suffix}(i) $ 的排名，即 $ {\\rm rank}[{\\rm SA}[i]] = i $（第 $ i $ 小的后缀的排名为 $ i $）。\n\n高度数组：$ {\\rm height}[] $ 是一个一维数组，保存了相邻两个后缀的最长公共前缀（Longest Common Prefix，LCP）长度。\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n即 $ {\\rm height}[i] $ 表示存在的最大的 $ x $，满足对于任何 $ k \\in [0, x) $ 有 $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $。\n\n### 后缀数组与名次数组的构造\n#### 朴素构造算法\n如果我们直观地通过定义来构造后缀数组与名次数组（即将每个后缀看做独立的字符串进行快速排序），时间复杂度为 $ O(n ^ 2 \\log n) $，但平方级别的复杂度通常是无法承受的。\n\n上述构造方法的瓶颈在于**字符串的比较**，原串的每个后缀的长度是 $ O(n) $ 级别的，最坏情况下需要 $ O(n) $ 次比较操作才能得到两个后缀的大小关系。\n\n##### 基于 Hash 的优化\n考虑对字符串进行 Hash。使用 BKDRHash 算法 $ O(n) $ 地预处理整个字符串后，可以 $ O(1) $ 地得到任意子串的 Hash 值，比较两个子串是否相等。\n\n这样，我们就得到了一个改进算法：比较两个后缀时，二分它们的 LCP 长度，并比较第一位不同的字符，总时间复杂度为 $ O(n \\log n \\log n) $。\n\n使用 Hash 来构造后缀数组的好处在于时间复杂度较低，并且可以动态维护（使用 `std::set`），坏处在于 Hash 的不稳定性。\n\n#### 倍增算法\n上述两个算法，我们都是将两个后缀看做独立字符串进行比较，而忽视了后缀之间的内在联系。一个更优的算法是**倍增算法**，它的主要思路是，每次利用上一次的结果，倍增计算出从每个位置 $ i $ 开始长度为 $ 2 ^ k $ 的子串的排名。\n\n算法的开始，我们有 `\"heheda\"`，从每个位置开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名分别为：\n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n为了求出长度为 $ 2 ^ 1 = 2 $ 的子串的排名，我们以每个位置 $ i $ 开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名作为位置 $ i $ 的**第一关键字**，以每个位置 $ i + 2 ^ 0 = i + 1 $ 开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名作为位置 $ i $ 的**第二关键字**，进行双关键字排序。\n\n对于 $ i + 2 ^ 0 \\geq n $ 的位置，我们用一个比其他所有值都小的数作为它的第二关键字，即 $ -1 $。\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n重复以上过程，求出长度为 $ 2 ^ 2 = 4 $ 的子串的排名：\n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n可以看出，这时候 $ {\\rm rank}[] $ 数组的最终值已被求出。而对于任何一组数据，显然可以在最坏情况下 $ O(\\log n) $ 轮上述过程后，求出 $ {\\rm rank}[] $ 数组的最终值。\n\n如果使用快速排序来实现双关键字排序，总时间复杂度为 $ O(n \\log n \\log n) $，实现难度比 Hash 的方法要低，并且更稳定。而考虑到每个关键字均为 $ [-1, n) $ 的整数，我们可以使用 $ O(n) $ 的基数排序，来将总时间复杂度将为 $ O(n \\log n) $。\n\n##### 代码\n\n首先，将原数据进行离散化，保证每个元素的值在 $ [0, n) $ 内。\n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir` 和 `sec` 分别表示第一关键字和第二关键字，`buc` 表示基数排序所用的桶。关键字的取值范围为 $ [-1, n) $，需要用到负数下标。\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n对每个单独的字符进行排序，得到它们的排名。\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n进行 $ O(\\log n) $ 次迭代（下文代码均为循环内操作）。\n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n设置每个位置的第一、第二关键字。\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n对第二关键字进行排序，$ {\\rm tmp}[i] $ 存储第 $ i $ **大**的第二关键字的所在位置。\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n对第一关键字进行排序，按照 $ {\\rm tmp}[] $ 中的顺序依次领取排名，在 $ {\\rm tmp}[] $ 中靠前的位置将较早领取排名，而较早领取到的排名较大。\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n按照后缀数组 $ {\\rm SA}[] $ 中的顺序求出名次数组 $ {\\rm rank}[] $，因为中间过程中排名会有并列，所以要分情况讨论：\n\n1. 没有前一名，当前位置的排名为 $ 0 $；\n2. 当前位置和前一名位置的第一、第二关键字均相等，当前位置的排名与前一位置的排名相等；\n3. 当前位置和前一名位置的第一或第二关键字不相等，当前位置的排名为前一位置的排名 $ + 1 $；\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n由于倍增算法时间复杂度较为优秀，并且实现难度不高，在实践中较为常用。另外，后缀数组也有线性的构造方法，例如 DC3，但其实现难度较高，实际应用不如倍增算法广。\n\n### 高度数组的计算\n后缀数组的大部分应用，都需要高度数组 $ {\\rm height}[] $ 的辅助，如果我们按照定义去计算 $ {\\rm height}[] $，最坏的时间复杂度为 $ O(n ^ 2) $。平方级别的复杂度仍然是无法承受的。\n\n#### 性质\n定义 $ h(i) $ 表示从第 $ i $ 个位置开始的后缀与排在其前一名的后缀的最长公共前缀，即当 $ {\\rm rank}[i] > 0 $ 时，有\n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n对于 $ h(i) $，有一个结论\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n当 $ h(i - 1) < 1 $ 时，结论显然是成立的，下面我们主要考虑 $ h(i - 1) \\geq 1 $ 的情况。\n\n令 $ u = {\\rm suffix}(i) $，$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $，即排在第 $ i $ 个位置的后缀和排在它前面一位的后缀；  \n令 $ u' = {\\rm suffix}(i - 1) $，$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $，即排在第 $ i - 1 $ 个位置的后缀和排在它前面一位的后缀。\n\n我们需要证明 $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $。\n\n现在换一个字符串 `\"heheheda\"` 作为例子，关系对应如下：\n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n当 $ h(i - 1) \\geq 1 $ 时，$ u' $ 与 $ v' $ 的第一个字符必定相等，同时去掉其第一个字符后，所得的两个新的后缀的最长公共前缀长度为 $ {\\rm LCP}(u', v') - 1 $。这两个后缀不一定是 $ u $ 和 $ v $（如果它们排名\t不相邻的话），但在后缀数组中，这两个后缀一定确定了一个包含 $ u $ 和 $ v $ 的区间（考虑位置靠前或靠后的后缀的影响），所以，结合下文中关于最长公共前缀的部分内容，$ {\\rm LCP}(u, v) $ 一定不会比它更小。\n\n#### 代码\n有了这一性质，我们可以按照 $ {\\rm height}[{\\rm SA}[i]] $ 的顺序递推。  \n设 $ k = {\\rm height}[{\\rm rank}[i - 1]] $（即上文的 $ h(i - 1) $），显然在计算每个 $ {\\rm height}[{\\rm rank}[i]] $ 时，$ k $ 每次减小 $ 1 $，最多增加到 $ n $，所以这个过程的时间复杂度为 $ O(n) $。  \n相对于前面 $ O(n \\log n) $ 的过程，线性的复杂度已经不会成为瓶颈。\n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n值得注意的是，$ {\\rm height}[0] $ 的值是无效的，因为排名最靠前的后缀没有前一名。\n\n### 最长公共前缀\n通过高度数组 $ {\\rm height}[] $，我们可以得到排名相邻的两个后缀的最长公共前缀。\n\n对于排名不相邻的两个后缀，它们的前缀的相似性比相邻后缀要差。显然排名不相邻的两个后缀的最长公共前缀长度**一定不会**比这两个后缀在后缀数组中确定的一段**区间中任意两个**相邻后缀的最长公共前缀长度**更长**。\n\n所以，求出这段区间内最小的 $ {\\rm height} $ 值即为这两个不相邻后缀的最长公共前缀长度。\n\n问题转化为区间最值查询（Range Minimum/Maximum Query，RMQ）问题，可以使用稀疏表（Sparse Table，ST）算法解决。该算法在 $ O(n \\log n) $ 的时间内预处理，并在 $ O(1) $ 的时间内完成每个询问。\n\n#### 代码\n代码中 $ {\\rm st}[i][t] $ 表示起始位置在 $ [i, i + 2 ^ t] $ 之间的所有相邻后缀的最长公共前缀长度的最小值，即 $ {\\rm LCP}(i, i + 2 ^ t) $。\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### 模板\n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","source":"_posts/suffix-array-notes.md","raw":"title: 后缀数组学习笔记\ncategories: OI\ntags: \n  - 后缀数组\n  - 字符串\n  - 学习笔记\n  - 算法模板\n  - 稀疏表\npermalink: suffix-array-notes\ndate: 2016-04-12 19:29:14\n---\n\n在 OI 竞赛中，有一类题目是面向字符串的。这类题目往往要求选手的程序快速地求出给定的字符串的某些信息，这就需要一些对应的数据结构和算法来维护字符串。后缀数组就是一个这样的数据结构 —— 它通过对字符串后缀的处理，可以方便地得到子串的信息。\n\n<!-- more -->\n\n### 定义\n字符串 $ s $ 连续的一段字符组成的串叫做字符串，更广义地，任何一个由可比较大小的元素组成的数组都可称为字符串。字符串的下标从 $ 0 $ 开始，长度为 $ {\\rm length}(s) $。\n\n后缀：$ {\\rm suffix}(i) $ 表示字符串 $ s $ 从第 $ i $ 个位置开始的后缀，即由 $ s[i] $ ~ $ s[n - 1] $ 组成的子串。\n\n字符串的比较：  \n两个字符串大小的比较，从首位开始，一位一位地按照 ASCII 码比较，如果从某位置开始不相同，则认为该位置处字符 ASCII 码小的字符串小；  \n如果一个字符串比较完了最后一位，而另一个没有，则认为前者（长度小的）小；  \n如果两个字符串长度相同并且所有位置上的字符均相同，则认为两个字符串相等。\n\n注意，同一个字符串的两个后缀是不可能相等的，因为无法满足相等的必要条件**长度相同**。\n\n后缀数组：$ {\\rm SA}[] $ 是一个一维数组，保存了对字符串 $ s $ 的所有后缀排序后的结果。$ {\\rm SA}[i] $ 表示第 $ i $ 小的后缀在原串中的起始位置。\n\n名次数组：$ {\\rm rank}[] $ 是一个一维数组，按起始位置保存了每个后缀在 $ {\\rm SA}[] $ 中的排名。$ {\\rm rank}[i] $ 表示 $ {\\rm suffix}(i) $ 的排名，即 $ {\\rm rank}[{\\rm SA}[i]] = i $（第 $ i $ 小的后缀的排名为 $ i $）。\n\n高度数组：$ {\\rm height}[] $ 是一个一维数组，保存了相邻两个后缀的最长公共前缀（Longest Common Prefix，LCP）长度。\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n即 $ {\\rm height}[i] $ 表示存在的最大的 $ x $，满足对于任何 $ k \\in [0, x) $ 有 $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $。\n\n### 后缀数组与名次数组的构造\n#### 朴素构造算法\n如果我们直观地通过定义来构造后缀数组与名次数组（即将每个后缀看做独立的字符串进行快速排序），时间复杂度为 $ O(n ^ 2 \\log n) $，但平方级别的复杂度通常是无法承受的。\n\n上述构造方法的瓶颈在于**字符串的比较**，原串的每个后缀的长度是 $ O(n) $ 级别的，最坏情况下需要 $ O(n) $ 次比较操作才能得到两个后缀的大小关系。\n\n##### 基于 Hash 的优化\n考虑对字符串进行 Hash。使用 BKDRHash 算法 $ O(n) $ 地预处理整个字符串后，可以 $ O(1) $ 地得到任意子串的 Hash 值，比较两个子串是否相等。\n\n这样，我们就得到了一个改进算法：比较两个后缀时，二分它们的 LCP 长度，并比较第一位不同的字符，总时间复杂度为 $ O(n \\log n \\log n) $。\n\n使用 Hash 来构造后缀数组的好处在于时间复杂度较低，并且可以动态维护（使用 `std::set`），坏处在于 Hash 的不稳定性。\n\n#### 倍增算法\n上述两个算法，我们都是将两个后缀看做独立字符串进行比较，而忽视了后缀之间的内在联系。一个更优的算法是**倍增算法**，它的主要思路是，每次利用上一次的结果，倍增计算出从每个位置 $ i $ 开始长度为 $ 2 ^ k $ 的子串的排名。\n\n算法的开始，我们有 `\"heheda\"`，从每个位置开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名分别为：\n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n为了求出长度为 $ 2 ^ 1 = 2 $ 的子串的排名，我们以每个位置 $ i $ 开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名作为位置 $ i $ 的**第一关键字**，以每个位置 $ i + 2 ^ 0 = i + 1 $ 开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名作为位置 $ i $ 的**第二关键字**，进行双关键字排序。\n\n对于 $ i + 2 ^ 0 \\geq n $ 的位置，我们用一个比其他所有值都小的数作为它的第二关键字，即 $ -1 $。\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n重复以上过程，求出长度为 $ 2 ^ 2 = 4 $ 的子串的排名：\n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n可以看出，这时候 $ {\\rm rank}[] $ 数组的最终值已被求出。而对于任何一组数据，显然可以在最坏情况下 $ O(\\log n) $ 轮上述过程后，求出 $ {\\rm rank}[] $ 数组的最终值。\n\n如果使用快速排序来实现双关键字排序，总时间复杂度为 $ O(n \\log n \\log n) $，实现难度比 Hash 的方法要低，并且更稳定。而考虑到每个关键字均为 $ [-1, n) $ 的整数，我们可以使用 $ O(n) $ 的基数排序，来将总时间复杂度将为 $ O(n \\log n) $。\n\n##### 代码\n\n首先，将原数据进行离散化，保证每个元素的值在 $ [0, n) $ 内。\n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir` 和 `sec` 分别表示第一关键字和第二关键字，`buc` 表示基数排序所用的桶。关键字的取值范围为 $ [-1, n) $，需要用到负数下标。\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n对每个单独的字符进行排序，得到它们的排名。\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n进行 $ O(\\log n) $ 次迭代（下文代码均为循环内操作）。\n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n设置每个位置的第一、第二关键字。\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n对第二关键字进行排序，$ {\\rm tmp}[i] $ 存储第 $ i $ **大**的第二关键字的所在位置。\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n对第一关键字进行排序，按照 $ {\\rm tmp}[] $ 中的顺序依次领取排名，在 $ {\\rm tmp}[] $ 中靠前的位置将较早领取排名，而较早领取到的排名较大。\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n按照后缀数组 $ {\\rm SA}[] $ 中的顺序求出名次数组 $ {\\rm rank}[] $，因为中间过程中排名会有并列，所以要分情况讨论：\n\n1. 没有前一名，当前位置的排名为 $ 0 $；\n2. 当前位置和前一名位置的第一、第二关键字均相等，当前位置的排名与前一位置的排名相等；\n3. 当前位置和前一名位置的第一或第二关键字不相等，当前位置的排名为前一位置的排名 $ + 1 $；\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n由于倍增算法时间复杂度较为优秀，并且实现难度不高，在实践中较为常用。另外，后缀数组也有线性的构造方法，例如 DC3，但其实现难度较高，实际应用不如倍增算法广。\n\n### 高度数组的计算\n后缀数组的大部分应用，都需要高度数组 $ {\\rm height}[] $ 的辅助，如果我们按照定义去计算 $ {\\rm height}[] $，最坏的时间复杂度为 $ O(n ^ 2) $。平方级别的复杂度仍然是无法承受的。\n\n#### 性质\n定义 $ h(i) $ 表示从第 $ i $ 个位置开始的后缀与排在其前一名的后缀的最长公共前缀，即当 $ {\\rm rank}[i] > 0 $ 时，有\n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n对于 $ h(i) $，有一个结论\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n当 $ h(i - 1) < 1 $ 时，结论显然是成立的，下面我们主要考虑 $ h(i - 1) \\geq 1 $ 的情况。\n\n令 $ u = {\\rm suffix}(i) $，$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $，即排在第 $ i $ 个位置的后缀和排在它前面一位的后缀；  \n令 $ u' = {\\rm suffix}(i - 1) $，$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $，即排在第 $ i - 1 $ 个位置的后缀和排在它前面一位的后缀。\n\n我们需要证明 $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $。\n\n现在换一个字符串 `\"heheheda\"` 作为例子，关系对应如下：\n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n当 $ h(i - 1) \\geq 1 $ 时，$ u' $ 与 $ v' $ 的第一个字符必定相等，同时去掉其第一个字符后，所得的两个新的后缀的最长公共前缀长度为 $ {\\rm LCP}(u', v') - 1 $。这两个后缀不一定是 $ u $ 和 $ v $（如果它们排名\t不相邻的话），但在后缀数组中，这两个后缀一定确定了一个包含 $ u $ 和 $ v $ 的区间（考虑位置靠前或靠后的后缀的影响），所以，结合下文中关于最长公共前缀的部分内容，$ {\\rm LCP}(u, v) $ 一定不会比它更小。\n\n#### 代码\n有了这一性质，我们可以按照 $ {\\rm height}[{\\rm SA}[i]] $ 的顺序递推。  \n设 $ k = {\\rm height}[{\\rm rank}[i - 1]] $（即上文的 $ h(i - 1) $），显然在计算每个 $ {\\rm height}[{\\rm rank}[i]] $ 时，$ k $ 每次减小 $ 1 $，最多增加到 $ n $，所以这个过程的时间复杂度为 $ O(n) $。  \n相对于前面 $ O(n \\log n) $ 的过程，线性的复杂度已经不会成为瓶颈。\n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n值得注意的是，$ {\\rm height}[0] $ 的值是无效的，因为排名最靠前的后缀没有前一名。\n\n### 最长公共前缀\n通过高度数组 $ {\\rm height}[] $，我们可以得到排名相邻的两个后缀的最长公共前缀。\n\n对于排名不相邻的两个后缀，它们的前缀的相似性比相邻后缀要差。显然排名不相邻的两个后缀的最长公共前缀长度**一定不会**比这两个后缀在后缀数组中确定的一段**区间中任意两个**相邻后缀的最长公共前缀长度**更长**。\n\n所以，求出这段区间内最小的 $ {\\rm height} $ 值即为这两个不相邻后缀的最长公共前缀长度。\n\n问题转化为区间最值查询（Range Minimum/Maximum Query，RMQ）问题，可以使用稀疏表（Sparse Table，ST）算法解决。该算法在 $ O(n \\log n) $ 的时间内预处理，并在 $ O(1) $ 的时间内完成每个询问。\n\n#### 代码\n代码中 $ {\\rm st}[i][t] $ 表示起始位置在 $ [i, i + 2 ^ t] $ 之间的所有相邻后缀的最长公共前缀长度的最小值，即 $ {\\rm LCP}(i, i + 2 ^ t) $。\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### 模板\n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","slug":"suffix-array-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rd10080ooxlz7juhd5t"},{"title":"STL 在 OI 中的应用","id":"8","updated":"2016-02-17T02:35:37.000Z","date":"2015-12-23T21:43:15.000Z","_content":"\n在 OI 竞赛中，可以使用的语言有 C++、C、Pascal，其中 C++ 最大的优势是，它本身提供了一个模板库 —— Standard Template Library（标准模板库），简称 STL。STL 包含一系列算法和容器等，合理地使用 STL，可以在提高编写代码的效率。NOI 系列比赛自 2011 年起允许 C++ 选手使用 STL，所以我们应该利用好 STL，发挥 C++ 语言的优势。\n\n<!-- more -->\n\n### 分类\n> STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分。\n\n本文主要讲解容器、迭代器、算法，其他的几个部分在竞赛中很少使用到。\n\n### 命名空间\n命名空间（namespace）是 C++ 的一个特性，它被用于解决名称冲突，比如假设 Menci 和 Fuxey 都在自己的头文件里编写了一个 `work()` 函数，如果这两个函数我们都要用，则名称会产生冲突，但如果两人都将自己的函数写在单独的命名空间内，就成了 `Menci::work()` 和 `Fuxey::work()`，就不会冲突了。\n\nSTL 的所有内容都包含在 `std` 命名空间内。\n\n如果我们要调用 STL 中的 `sort` 函数（下文会有提到），要这样写：\n\n```cpp\nstd::sort(a, a + n);\n```\n\n我们也可以将 `std::sort` 这个函数“导入”到全局中，就可以直接 `sort(a, a + n)` 这样调用了。  \n使用 `using` 关键字来“导入”命名空间中的函数或类。\n\n```cpp\nusing std::sort;\n```\n\n也可以将整个命名空间导入全局，这样就可以直接访问命名空间中的所有内容，但更容易产生名称冲突（比如你可能会声明一个叫做 `max` 的变量，但它会覆盖 STL 中的 `max` 函数）。  \n使用 `using namespace` 来“导入”整个命名空间。\n\n```cpp\nusing namespace std;\n```\n\n### 算法\nSTL 中的算法主要包含在 `<algorithm>` 头文件中，这个文件名要记住，每天念一遍。\n\n##### 排序\nSTL 中提供一系列与排序有关的函数，其中最常用到的是 `sort` 和 `stable_sort`，`sort` 是不稳定的排序，它的期望时间复杂度为 $O(n {\\log} n)$，`stable_sort` 是稳定的排序，它的时间复杂度为 $O(n {\\log} n)$。\n\n`sort` 使用类似与快速排序的算法，在大多数情况下能获得最高的效率，`stable_sort` 使用多路归并排序算法，可以在稳定的前提下取得较高的效率。一般常用 `sort`。\n\n用法（以 `sort` 为例，`stable_sort` 相同）：\n\n对左闭右开区间 [l, r) 排序，使用 `sort(l, r)`。其中 l 和 r 是指向元素的**迭代器**，在了解**迭代器**之前，我们可以将其理解为指向元素的指针。\n\n注意这里的区间表示是一个**左闭右开区间**，STL 中经常会出现这种区间，如果我们要对一个数组 a 的前 n 个元素进行排序，则对应区间为 [a, a + n)，因为 a 指向数组的第一个元素（下标为 0），a + n 指向数组的第 n 个元素**之后**。\n\n`sort` 函数默认是升序排序，如果需要降序，可以通过自定义“比较函数”来实现。\n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并**降序**排序后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n降序排序是**大于号**，升序排序是**小于号**（注意**不能**加等号变成大于等于、小于等于），如果不指定比较函数，默认为**升序**。\n\n也可以通过**重载运算符**或者定义**比较函数**的方法对结构体进行排序：\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n写在结构体中的 `operator<` 即为重载运算符，这让我们的结构体支持小于号的比较操作。  \n结构体下面的 `compare` 是比较函数，**比较函数**和**重载运算符**只需要写一个就够了。\n\n注意两种写法中的 `const` 和 `&` 都不能省略。\n\n##### 去重\n\n使用 `unique` 函数来去除数组中的重复元素，其调用格式与 `sort` 类似，注意调用 `unique` 前必须保证数组是有序的（升序降序都可以）。\n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` 函数返回去重后的数组的最后一个元素之后，一般通过用返回值减去首地址的方法获得不重复的元素数量：\n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并升序排序并去重后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### 较大、较小值\n\n使用 `max` 和 `min` 来取得两个数中较大或较小的。\n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); // 结果为 890\ny = std::min(a, b); // 结果为 -1\n```\n\n##### 查找\n\nSTL 中常用的用于查找的函数有三个：`lower_bound`、`upper_bound`、`binary_search`，一般 `lower_bound` 最为常用。\n\n`lower_bound` 用于在一个升序序列中查找某个元素，并返回第一个**不小于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`upper_bound` 用于在一个升序序列中查找某个元素，并返回第一个**大于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`binary_search` 用于确定某个元素有没有在一个升序序列中出现过，返回 `true` 或 `false`。\n\n三个函数的时间复杂度均为$O({\\log}n)$。\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1 指向 a 中第 4 个元素 a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2 指向 a 中第 5 个元素 a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3 指向 a 中第 7 个元素 a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n，因为数组 a 中没有不小于 8 的元素，此时访问 *p4 会越界\n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false 因为数组 a 中没有 3\n```\n\n##### 交换\n使用 `swap` 函数交换两个变量的值。\n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### 迭代器\n迭代器是用于访问 STL 容器中元素的一种数据类型，一般迭代器的声明如下：\n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n上述代码声明了一个迭代器 `p`，其中 `CONTAINER` 是容器类型，可以是 `vector`、`set` 等，`T` 是容器中元素的类型。\n\n一般的，容器的 `begin()` 方法返回**首个元素**的迭代器， `end()` 方法返回**最后一个元素之后**的迭代器。这两个迭代器确定了一个包含容器内所有元素的**左闭右开区间** `[begin(), end())`。对于任何指向有效元素的迭代器都有其**不等于** `end()`，`end()` 并不指向任何一个元素，试图访问 `end()` 对应的元素是非法的。\n\n在使用 STL 提供的算法时，可以用迭代器表示一个区间，如：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n一些容器的迭代器可以支持**随机访问**，如指向 `vector[i]` 的迭代器为 `vector.begin() + i`，而另一些容器如 `set` 不支持这种用法。\n\n所有的迭代器都支持使用 `++` 和 `--` 运算符将迭代器加一或减一。\n\n迭代器的用法类似于指向数组元素的指针，对于迭代器 `p`，用 `*p` 得到迭代器对应的元素；如果该迭代器所对应的元素类型为结构体，则可以直接使用 `->` 访问其对应结构体中的元素。\n\n一般的，使用迭代器遍历容器类似于下述代码：\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### 容器\n\n##### 数组 vector\nSTL 在头文件 `<vector>` 提供了一个**可变长**的数组 `vector`，它支持动态的插入、删除操作。\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 0。\n\n```cpp\nstd::vector<int> v;\n```\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 n。\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector` 提供 `begin()` 和 `end()`，分别获取指向**第一个元素**和**最后一个元素之后**的迭代器。\n\n以下代码对 v 中的所有元素以升序排序：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n使用 `size()` 得到 `vector` 的元素数量，使用 `resize()` 重新指定 `vector` 的元素数量。\n\n分别使用 `push_back()` 和 `pop_back()` 在 `vector` 的**尾部**加入或删除元素，这两个过程的时间复杂度为$O(1)$。\n\n使用 `insert()` 在某个特定的位置插入一个元素，时间复杂度为$O(n)$。\n\n使用 `erase()` 删除某个位置的元素，时间复杂度为$O(n)$。\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n// 依次输出 12345、23333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n注意，在加入元素时，如果 `vector` 拥有的内存空间不足以存放欲加入的元素，则 `vector` 会申请一块新的内存，并将旧数据拷贝过去，这个过程通常花费 $O(n)$ 的时间。\n\n##### 集合 set\nSTL 在头文件 `<set>` 中提供了一个**有序集合** `set`，其中的元素全部是**唯一**的，并且插入进的元素自动按照升序排列，但 `set` 不支持通过下标定位某个元素，只能通过**迭代器**遍历。\n\n以下代码声明了一个 `int` 类型的集合。\n\n```cpp\nstd::set<int> s;\n```\n\n使用 `insert()` 在集合中加入一个元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `erase()` 删除集合中**某个元素**或**某个位置的元素**，其时间复杂度均为$O({\\log}n)$。\n\n`set` 自身提供 `lower_bound()` 用于定位元素，其作用与前文中的同名函数类似，也可以使用 `find()` 来精确查找元素。\n\n遍历 `set` 只能使用**迭代器**。`set` 的迭代器为 `set<T>::iterator`，其中 `T` 为元素类型。\n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // 重复插入无效\ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end()，因为未找到 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n// 依次输出 -1、23333\n```\n\n上述代码中运用的迭代器的方法在 STL 容器中较为常见。\n\n##### 字符串 string\nSTL 在头文件 `<string>` 中将一些与字符串有关的操作封装在了 `string` 内。\n\n使用 `cin` 和 `cout` 来输入、输出字符串。\n\n使用 `find()` 查找另一个字符串在该字符串中的出现位置，返回结果从 0 开始。\n\n使用 `c_str()` 获得 `string` 对应的 `const char *` 类型数据，可用于向 C 库函数传递。\n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos，因为没有找到 23333\n\npos = s.find(\"ci\");\n// pos = 3，因为出现位置为第 4 个字符\n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n// 输出两次 Menci\n```\n\n##### 队列 queue\nSTL 在头文件 `<queue>` 中提供了先入先出（FIFO）队列 `queue`。\n\n使用 `push()` 向队列中加入元素。\n\n使用 `front()` 获取队首元素（并不删除）。\n\n使用 `pop()` 删除队首元素。\n\n使用 `empty()` 判断队列是否为空。\n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true，队列初始为空\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n// 依次输出 23333，66666\n```\n\n##### 栈 stack\nSTL 在头文件 `<stack>` 提供了后入先出（LIFO）栈 `stack`。\n\n使用 `push()` 向栈中加入元素。\n\n使用 `top()` 获取栈顶元素（并不删除）。\n\n使用 `pop()` 删除栈顶元素。\n\n使用 `empty()` 判断栈是否为空。\n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true，栈初始为空\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n// 依次输出 66666，23333\n```\n\n##### 优先队列 priority_queue\nSTL 在头文件 `<queue>` 中提供优先队列 `priority_queue`，在任意时间都能取出队列中的**最大值**。\n\n使用 `push()` 向优先队列中加入元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `top()` 获取优先队列中**最大**的元素（并不删除），其时间复杂度为$O(1)$。\n\n使用 `pop()` 删除优先队列中**最大**元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `empty()` 判断优先队列是否为空。\n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true，优先队列初始为空\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n// 依次输出 66666，23333，-1\n```\n\n`priority_queue` 默认提供队列中的**最大值**，也可以以以下声明方式让 `priority_queue` 提供**最小值**。\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n注意把三个 `T` 换成优先队列中元素的类型（如 `int`）；`std::greater<T>` 的右边要加一个空格，否则会被编译器误认为是 `>>` 右移运算符。\n","source":"_posts/stl-in-oi.md","raw":"title: STL 在 OI 中的应用\ncategories: OI\ntags: \n  - C++\n  - STL\npermalink: stl-in-oi\nid: 8\nupdated: '2016-02-17 10:35:37'\ndate: 2015-12-24 05:43:15\n---\n\n在 OI 竞赛中，可以使用的语言有 C++、C、Pascal，其中 C++ 最大的优势是，它本身提供了一个模板库 —— Standard Template Library（标准模板库），简称 STL。STL 包含一系列算法和容器等，合理地使用 STL，可以在提高编写代码的效率。NOI 系列比赛自 2011 年起允许 C++ 选手使用 STL，所以我们应该利用好 STL，发挥 C++ 语言的优势。\n\n<!-- more -->\n\n### 分类\n> STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分。\n\n本文主要讲解容器、迭代器、算法，其他的几个部分在竞赛中很少使用到。\n\n### 命名空间\n命名空间（namespace）是 C++ 的一个特性，它被用于解决名称冲突，比如假设 Menci 和 Fuxey 都在自己的头文件里编写了一个 `work()` 函数，如果这两个函数我们都要用，则名称会产生冲突，但如果两人都将自己的函数写在单独的命名空间内，就成了 `Menci::work()` 和 `Fuxey::work()`，就不会冲突了。\n\nSTL 的所有内容都包含在 `std` 命名空间内。\n\n如果我们要调用 STL 中的 `sort` 函数（下文会有提到），要这样写：\n\n```cpp\nstd::sort(a, a + n);\n```\n\n我们也可以将 `std::sort` 这个函数“导入”到全局中，就可以直接 `sort(a, a + n)` 这样调用了。  \n使用 `using` 关键字来“导入”命名空间中的函数或类。\n\n```cpp\nusing std::sort;\n```\n\n也可以将整个命名空间导入全局，这样就可以直接访问命名空间中的所有内容，但更容易产生名称冲突（比如你可能会声明一个叫做 `max` 的变量，但它会覆盖 STL 中的 `max` 函数）。  \n使用 `using namespace` 来“导入”整个命名空间。\n\n```cpp\nusing namespace std;\n```\n\n### 算法\nSTL 中的算法主要包含在 `<algorithm>` 头文件中，这个文件名要记住，每天念一遍。\n\n##### 排序\nSTL 中提供一系列与排序有关的函数，其中最常用到的是 `sort` 和 `stable_sort`，`sort` 是不稳定的排序，它的期望时间复杂度为 $O(n {\\log} n)$，`stable_sort` 是稳定的排序，它的时间复杂度为 $O(n {\\log} n)$。\n\n`sort` 使用类似与快速排序的算法，在大多数情况下能获得最高的效率，`stable_sort` 使用多路归并排序算法，可以在稳定的前提下取得较高的效率。一般常用 `sort`。\n\n用法（以 `sort` 为例，`stable_sort` 相同）：\n\n对左闭右开区间 [l, r) 排序，使用 `sort(l, r)`。其中 l 和 r 是指向元素的**迭代器**，在了解**迭代器**之前，我们可以将其理解为指向元素的指针。\n\n注意这里的区间表示是一个**左闭右开区间**，STL 中经常会出现这种区间，如果我们要对一个数组 a 的前 n 个元素进行排序，则对应区间为 [a, a + n)，因为 a 指向数组的第一个元素（下标为 0），a + n 指向数组的第 n 个元素**之后**。\n\n`sort` 函数默认是升序排序，如果需要降序，可以通过自定义“比较函数”来实现。\n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并**降序**排序后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n降序排序是**大于号**，升序排序是**小于号**（注意**不能**加等号变成大于等于、小于等于），如果不指定比较函数，默认为**升序**。\n\n也可以通过**重载运算符**或者定义**比较函数**的方法对结构体进行排序：\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n写在结构体中的 `operator<` 即为重载运算符，这让我们的结构体支持小于号的比较操作。  \n结构体下面的 `compare` 是比较函数，**比较函数**和**重载运算符**只需要写一个就够了。\n\n注意两种写法中的 `const` 和 `&` 都不能省略。\n\n##### 去重\n\n使用 `unique` 函数来去除数组中的重复元素，其调用格式与 `sort` 类似，注意调用 `unique` 前必须保证数组是有序的（升序降序都可以）。\n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` 函数返回去重后的数组的最后一个元素之后，一般通过用返回值减去首地址的方法获得不重复的元素数量：\n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并升序排序并去重后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### 较大、较小值\n\n使用 `max` 和 `min` 来取得两个数中较大或较小的。\n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); // 结果为 890\ny = std::min(a, b); // 结果为 -1\n```\n\n##### 查找\n\nSTL 中常用的用于查找的函数有三个：`lower_bound`、`upper_bound`、`binary_search`，一般 `lower_bound` 最为常用。\n\n`lower_bound` 用于在一个升序序列中查找某个元素，并返回第一个**不小于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`upper_bound` 用于在一个升序序列中查找某个元素，并返回第一个**大于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`binary_search` 用于确定某个元素有没有在一个升序序列中出现过，返回 `true` 或 `false`。\n\n三个函数的时间复杂度均为$O({\\log}n)$。\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1 指向 a 中第 4 个元素 a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2 指向 a 中第 5 个元素 a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3 指向 a 中第 7 个元素 a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n，因为数组 a 中没有不小于 8 的元素，此时访问 *p4 会越界\n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false 因为数组 a 中没有 3\n```\n\n##### 交换\n使用 `swap` 函数交换两个变量的值。\n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### 迭代器\n迭代器是用于访问 STL 容器中元素的一种数据类型，一般迭代器的声明如下：\n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n上述代码声明了一个迭代器 `p`，其中 `CONTAINER` 是容器类型，可以是 `vector`、`set` 等，`T` 是容器中元素的类型。\n\n一般的，容器的 `begin()` 方法返回**首个元素**的迭代器， `end()` 方法返回**最后一个元素之后**的迭代器。这两个迭代器确定了一个包含容器内所有元素的**左闭右开区间** `[begin(), end())`。对于任何指向有效元素的迭代器都有其**不等于** `end()`，`end()` 并不指向任何一个元素，试图访问 `end()` 对应的元素是非法的。\n\n在使用 STL 提供的算法时，可以用迭代器表示一个区间，如：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n一些容器的迭代器可以支持**随机访问**，如指向 `vector[i]` 的迭代器为 `vector.begin() + i`，而另一些容器如 `set` 不支持这种用法。\n\n所有的迭代器都支持使用 `++` 和 `--` 运算符将迭代器加一或减一。\n\n迭代器的用法类似于指向数组元素的指针，对于迭代器 `p`，用 `*p` 得到迭代器对应的元素；如果该迭代器所对应的元素类型为结构体，则可以直接使用 `->` 访问其对应结构体中的元素。\n\n一般的，使用迭代器遍历容器类似于下述代码：\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### 容器\n\n##### 数组 vector\nSTL 在头文件 `<vector>` 提供了一个**可变长**的数组 `vector`，它支持动态的插入、删除操作。\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 0。\n\n```cpp\nstd::vector<int> v;\n```\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 n。\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector` 提供 `begin()` 和 `end()`，分别获取指向**第一个元素**和**最后一个元素之后**的迭代器。\n\n以下代码对 v 中的所有元素以升序排序：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n使用 `size()` 得到 `vector` 的元素数量，使用 `resize()` 重新指定 `vector` 的元素数量。\n\n分别使用 `push_back()` 和 `pop_back()` 在 `vector` 的**尾部**加入或删除元素，这两个过程的时间复杂度为$O(1)$。\n\n使用 `insert()` 在某个特定的位置插入一个元素，时间复杂度为$O(n)$。\n\n使用 `erase()` 删除某个位置的元素，时间复杂度为$O(n)$。\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n// 依次输出 12345、23333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n注意，在加入元素时，如果 `vector` 拥有的内存空间不足以存放欲加入的元素，则 `vector` 会申请一块新的内存，并将旧数据拷贝过去，这个过程通常花费 $O(n)$ 的时间。\n\n##### 集合 set\nSTL 在头文件 `<set>` 中提供了一个**有序集合** `set`，其中的元素全部是**唯一**的，并且插入进的元素自动按照升序排列，但 `set` 不支持通过下标定位某个元素，只能通过**迭代器**遍历。\n\n以下代码声明了一个 `int` 类型的集合。\n\n```cpp\nstd::set<int> s;\n```\n\n使用 `insert()` 在集合中加入一个元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `erase()` 删除集合中**某个元素**或**某个位置的元素**，其时间复杂度均为$O({\\log}n)$。\n\n`set` 自身提供 `lower_bound()` 用于定位元素，其作用与前文中的同名函数类似，也可以使用 `find()` 来精确查找元素。\n\n遍历 `set` 只能使用**迭代器**。`set` 的迭代器为 `set<T>::iterator`，其中 `T` 为元素类型。\n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // 重复插入无效\ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end()，因为未找到 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n// 依次输出 -1、23333\n```\n\n上述代码中运用的迭代器的方法在 STL 容器中较为常见。\n\n##### 字符串 string\nSTL 在头文件 `<string>` 中将一些与字符串有关的操作封装在了 `string` 内。\n\n使用 `cin` 和 `cout` 来输入、输出字符串。\n\n使用 `find()` 查找另一个字符串在该字符串中的出现位置，返回结果从 0 开始。\n\n使用 `c_str()` 获得 `string` 对应的 `const char *` 类型数据，可用于向 C 库函数传递。\n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos，因为没有找到 23333\n\npos = s.find(\"ci\");\n// pos = 3，因为出现位置为第 4 个字符\n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n// 输出两次 Menci\n```\n\n##### 队列 queue\nSTL 在头文件 `<queue>` 中提供了先入先出（FIFO）队列 `queue`。\n\n使用 `push()` 向队列中加入元素。\n\n使用 `front()` 获取队首元素（并不删除）。\n\n使用 `pop()` 删除队首元素。\n\n使用 `empty()` 判断队列是否为空。\n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true，队列初始为空\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n// 依次输出 23333，66666\n```\n\n##### 栈 stack\nSTL 在头文件 `<stack>` 提供了后入先出（LIFO）栈 `stack`。\n\n使用 `push()` 向栈中加入元素。\n\n使用 `top()` 获取栈顶元素（并不删除）。\n\n使用 `pop()` 删除栈顶元素。\n\n使用 `empty()` 判断栈是否为空。\n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true，栈初始为空\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n// 依次输出 66666，23333\n```\n\n##### 优先队列 priority_queue\nSTL 在头文件 `<queue>` 中提供优先队列 `priority_queue`，在任意时间都能取出队列中的**最大值**。\n\n使用 `push()` 向优先队列中加入元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `top()` 获取优先队列中**最大**的元素（并不删除），其时间复杂度为$O(1)$。\n\n使用 `pop()` 删除优先队列中**最大**元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `empty()` 判断优先队列是否为空。\n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true，优先队列初始为空\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n// 依次输出 66666，23333，-1\n```\n\n`priority_queue` 默认提供队列中的**最大值**，也可以以以下声明方式让 `priority_queue` 提供**最小值**。\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n注意把三个 `T` 换成优先队列中元素的类型（如 `int`）；`std::greater<T>` 的右边要加一个空格，否则会被编译器误认为是 `>>` 右移运算符。\n","slug":"stl-in-oi","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rd70089ooxleh439i2r"},{"title":"「SPOJ 694」Distinct Substrings - 后缀数组","date":"2016-04-12T13:40:06.000Z","_content":"\n给定一个字符串，求该字符串含有的本质不同的子串数量。\n\n<!-- more -->\n\n### 链接\n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### 题解\n每个子串都是原字符串的某个后缀的前缀，所以我们可以统计每个后缀的前缀数量。在后缀数组中，排名第 $ i $ 的后缀与排名第 $ i - 1 $ 的后缀有 $ {\\rm height}[i] $ 个相同的前缀，所以要从答案中减去这些。\n\n设数组下标从 1 开始，则答案为\n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/spoj-694.md","raw":"title: 「SPOJ 694」Distinct Substrings - 后缀数组\ncategories: OI\ntags: \n  - SPOJ\n  - 后缀数组\n  - 字符串\npermalink: spoj-694\ndate: 2016-04-12 21:40:06\n---\n\n给定一个字符串，求该字符串含有的本质不同的子串数量。\n\n<!-- more -->\n\n### 链接\n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### 题解\n每个子串都是原字符串的某个后缀的前缀，所以我们可以统计每个后缀的前缀数量。在后缀数组中，排名第 $ i $ 的后缀与排名第 $ i - 1 $ 的后缀有 $ {\\rm height}[i] $ 个相同的前缀，所以要从答案中减去这些。\n\n设数组下标从 1 开始，则答案为\n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"spoj-694","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdb008fooxlmuqr73ki"},{"title":"Splay 模板 + 详细注释","date":"2016-12-23T12:13:00.000Z","_content":"\n普通平衡树的模板。\n\n插入、查询、删除、前趋、后继、排名、选择。\n\n![zyz 大佬的评价](images/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <climits>\n\nstruct Splay\n{\n\tstruct Node\n\t{\n\t\t// root 可能会被修改，使用指向指针的指针\n\t\tNode *fa, *ch[2], **root;\n\t\t// x 表示这个节点上的数\n\t\t// size 表示整棵树（左右子树和自身）的大小\n\t\t// cnt 表示这个数 x 有多少个\n\t\tint x, size, cnt;\n\n\t\tNode(Node **root, Node *fa, int x) : root(root), fa(fa), x(x), cnt(1), size(1)\n\t\t{\n\t\t\tch[0] = ch[1] = NULL; // 不要忘记初始化\n\t\t}\n\n\t\t// 如果当前节点是其父节点的左儿子，返回 0 否则返回 1\n\t\tint relation()\n\t\t{\n\t\t\treturn this == fa->ch[0] ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain()\n\t\t{\n\t\t\tsize = cnt;\n\t\t\tif (ch[0]) size += ch[0]->size;\n\t\t\tif (ch[1]) size += ch[1]->size;\n\t\t}\n\n\t\tvoid rotate()\n\t\t{\n\t\t\t// 旧的父节点\n\t\t\tNode *old = fa;\n\t\t\t// 旋转前当前节点与父节点的关系\n\t\t\tint r = relation();\n\n\t\t\t// 自身 <--> 父节点的父节点\n\t\t\tfa = old->fa;\n\t\t\tif (old->fa)\n\t\t\t{\n\t\t\t\t// 如果父节点有父节点（不是根），那么用当前节点替换父节点的父节点中父节点的位置的指向\n\t\t\t\told->fa->ch[old->relation()] = this;\n\t\t\t}\n\n\t\t\t// 原有的另一个子节点 <--> 原有的父节点\n\t\t\tif (ch[r ^ 1])\n\t\t\t{\n\t\t\t\tch[r ^ 1]->fa = old;\n\t\t\t}\n\t\t\told->ch[r] = ch[r ^ 1]; // 右边的 ch[r ^ 1] 相当于 this->ch[r ^ 1]\n\n\t\t\t// 原有的父节点 作为自身的子节点\n\t\t\told->fa = this;\n\t\t\tch[r ^ 1] = old;\n\n\t\t\t// 更新维护信息\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\t// 如果转到了根，更新储存的指向根节点的指针\n\t\t\tif (fa == NULL)\n\t\t\t{\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\t// 旋转到某一特定位置，如在删除时将后继节点旋转为根的右儿子\n\t\t// target 为目标父节点，缺省参数为 NULL，即旋转直到成为根（没有父节点）\n\t\tvoid splay(Node *target = NULL)\n\t\t{\n\t\t\twhile (fa != target) // while (父节点不是目标父节点)\n\t\t\t{\n\t\t\t\tif (fa->fa == target) // 父节点的父节点是目标父节点，直接转一次\n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse if (fa->relation() == relation()) // 关系相同，先转父节点，再转自身\n\t\t\t\t{\n\t\t\t\t\tfa->rotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 前趋，全称 precursor 或 predecessor\n\t\tNode *pred()\n\t\t{\n\t\t\t// 左子树的最右点\n\t\t\tNode *v = ch[0];\n\t\t\twhile (v->ch[1]) v = v->ch[1];\n\t\t\treturn v;\n\t\t}\n\n\t\t// 后继，全称 successor\n\t\tNode *succ()\n\t\t{\n\t\t\t// 右子树的最左点\n\t\t\tNode *v = ch[1];\n\t\t\twhile (v->ch[0]) v = v->ch[0];\n\t\t\treturn v;\n\t\t}\n\n\t\t// 求一个节点的排名，即左子树大小\n\t\tint rank()\n\t\t{\n\t\t\treturn ch[0] ? ch[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL)\n\t{\n\t\tinsert(INT_MAX);\n\t\tinsert(INT_MIN);\n\t}\n\n\tNode *insert(int x)\n\t{\n\t\t// v 是一个指向指针的指针\n\t\t// 表示要插入到的位置\n\t\t// 如果 v 指向一个空指针\n\t\t// 那么就可以插入到这里\n\t\t//\n\t\t// fa 是新节点的父节点\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v != NULL && (*v)->x != x) // 直到找到一个空位置，或者找到原有的值为 x 的节点\n\t\t{\n\t\t\tfa = *v;    // 以上一次找到的不空的 v 作为父节点\n\t\t\tfa->size++; // 因为要在这棵子树下插入一个新的节点\n\t\t\t\n\t\t\t// 根据大小向左右子树迭代\n\t\t\tif (x < fa->x)\n\t\t\t{\n\t\t\t\tv = &fa->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = &fa->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (*v != NULL)\n\t\t{\n\t\t\t(*v)->cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*v) = new Node(&root, fa, x);\n\t\t}\n\n\t\t(*v)->splay();\n\n\t\t// 伸展之后，*v 这个位置存的可能不再是新节点（因为父子关系改变了，而 v 一般指向一个节点的某个子节点的位置）\n\t\t// 直接返回根\n\t\treturn root;\n\t}\n\n\tNode *find(int x)\n\t{\n\t\t// 从根节点开始找\n\t\tNode *v = root;\n\t\twhile (v != NULL && v->x != x)\n\t\t{\n\t\t\tif (x < v->x)\n\t\t\t{\n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\t// 删除一个节点\n\tvoid erase(Node *v)\n\t{\n\t\tNode *pred = v->pred(), *succ = v->succ();\n\t\tpred->splay();\n\t\tsucc->splay(pred); // 使后继成为前趋（根）的右儿子\n\n\t\t// 此时后继的左儿子即为要删除的节点 v，且 v 此时为叶子节点\n\t\t\n\t\tif (v->size > 1)\n\t\t{\n\t\t\t// 如果存在不止一个 x，只需将计数减一\n\t\t\tv->size--;\n\t\t\tv->cnt--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete succ->ch[0]; // 使用 delete 关键字（严格地说，new 和 delete 是运算符）释放 new 分配的内存\n\t\t\tsucc->ch[0] = NULL; // 不要忘记置空\n\t\t}\n\n\t\t// 删了节点，需要将大小减小\n\t\tsucc->size--;\n\t\tpred->size--;\n\t}\n\n\t// 删除一个数\n\tvoid erase(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (!v) return; // 没有找到要删的节点，直接返回（一般题目中不会出现这种情况）\n\t\t\n\t\terase(v);\n\t}\n\n\t// 求一个数的前趋\n\tint pred(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->pred()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->pred()->x;\n\t\t}\n\t}\n\n\t// 求一个数的后继\n\tint succ(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->succ()->x;\n\t\t}\n\t}\n\n\t// 求一个数的排名\n\tint rank(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\t// 此时 v 已经是根节点了，因为新插入插入节点会被伸展\n\t\t\tint res = v->rank(); // 因为有一个无穷小，所以不需要 +1\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 此时 v 已经是根节点了，因为查找到的节点会被伸展\n\t\t\treturn v->rank();\n\t\t}\n\t}\n\n\t// 求第 k 小的数\n\tint select(int k)\n\t{\n\t\tNode *v = root;\n\t\twhile (!(k >= v->rank() && k < v->rank() + v->cnt))\n\t\t{\n\t\t\tif (k < v->rank())\n\t\t\t{\n\t\t\t\t// 要查的第 k 比当前节点的排名小，需要继续在左子树中查询\n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk -= v->rank() + v->cnt;\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v->x;\n\t}\n} splay;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tint opt, x;\n\t\tscanf(\"%d %d\", &opt, &x);\n\t\tif (opt == 1)\n\t\t{\n\t\t\tsplay.insert(x);\n\t\t}\n\t\telse if (opt == 2)\n\t\t{\n\t\t\tsplay.erase(x);\n\t\t}\n\t\telse if (opt == 3)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t}\n\t\telse if (opt == 4)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t}\n\t\telse if (opt == 5)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t}\n\t\telse if (opt == 6)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/splay-template.md","raw":"title: Splay 模板 + 详细注释\ncategories: OI\ntags: \n  - Splay\n  - 高级数据结构\n  - 数据结构\n  - 算法模板\npermalink: splay-template\ndate: 2016-12-23 20:13:00\n---\n\n普通平衡树的模板。\n\n插入、查询、删除、前趋、后继、排名、选择。\n\n![zyz 大佬的评价](images/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <climits>\n\nstruct Splay\n{\n\tstruct Node\n\t{\n\t\t// root 可能会被修改，使用指向指针的指针\n\t\tNode *fa, *ch[2], **root;\n\t\t// x 表示这个节点上的数\n\t\t// size 表示整棵树（左右子树和自身）的大小\n\t\t// cnt 表示这个数 x 有多少个\n\t\tint x, size, cnt;\n\n\t\tNode(Node **root, Node *fa, int x) : root(root), fa(fa), x(x), cnt(1), size(1)\n\t\t{\n\t\t\tch[0] = ch[1] = NULL; // 不要忘记初始化\n\t\t}\n\n\t\t// 如果当前节点是其父节点的左儿子，返回 0 否则返回 1\n\t\tint relation()\n\t\t{\n\t\t\treturn this == fa->ch[0] ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain()\n\t\t{\n\t\t\tsize = cnt;\n\t\t\tif (ch[0]) size += ch[0]->size;\n\t\t\tif (ch[1]) size += ch[1]->size;\n\t\t}\n\n\t\tvoid rotate()\n\t\t{\n\t\t\t// 旧的父节点\n\t\t\tNode *old = fa;\n\t\t\t// 旋转前当前节点与父节点的关系\n\t\t\tint r = relation();\n\n\t\t\t// 自身 <--> 父节点的父节点\n\t\t\tfa = old->fa;\n\t\t\tif (old->fa)\n\t\t\t{\n\t\t\t\t// 如果父节点有父节点（不是根），那么用当前节点替换父节点的父节点中父节点的位置的指向\n\t\t\t\told->fa->ch[old->relation()] = this;\n\t\t\t}\n\n\t\t\t// 原有的另一个子节点 <--> 原有的父节点\n\t\t\tif (ch[r ^ 1])\n\t\t\t{\n\t\t\t\tch[r ^ 1]->fa = old;\n\t\t\t}\n\t\t\told->ch[r] = ch[r ^ 1]; // 右边的 ch[r ^ 1] 相当于 this->ch[r ^ 1]\n\n\t\t\t// 原有的父节点 作为自身的子节点\n\t\t\told->fa = this;\n\t\t\tch[r ^ 1] = old;\n\n\t\t\t// 更新维护信息\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\t// 如果转到了根，更新储存的指向根节点的指针\n\t\t\tif (fa == NULL)\n\t\t\t{\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\t// 旋转到某一特定位置，如在删除时将后继节点旋转为根的右儿子\n\t\t// target 为目标父节点，缺省参数为 NULL，即旋转直到成为根（没有父节点）\n\t\tvoid splay(Node *target = NULL)\n\t\t{\n\t\t\twhile (fa != target) // while (父节点不是目标父节点)\n\t\t\t{\n\t\t\t\tif (fa->fa == target) // 父节点的父节点是目标父节点，直接转一次\n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse if (fa->relation() == relation()) // 关系相同，先转父节点，再转自身\n\t\t\t\t{\n\t\t\t\t\tfa->rotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 前趋，全称 precursor 或 predecessor\n\t\tNode *pred()\n\t\t{\n\t\t\t// 左子树的最右点\n\t\t\tNode *v = ch[0];\n\t\t\twhile (v->ch[1]) v = v->ch[1];\n\t\t\treturn v;\n\t\t}\n\n\t\t// 后继，全称 successor\n\t\tNode *succ()\n\t\t{\n\t\t\t// 右子树的最左点\n\t\t\tNode *v = ch[1];\n\t\t\twhile (v->ch[0]) v = v->ch[0];\n\t\t\treturn v;\n\t\t}\n\n\t\t// 求一个节点的排名，即左子树大小\n\t\tint rank()\n\t\t{\n\t\t\treturn ch[0] ? ch[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL)\n\t{\n\t\tinsert(INT_MAX);\n\t\tinsert(INT_MIN);\n\t}\n\n\tNode *insert(int x)\n\t{\n\t\t// v 是一个指向指针的指针\n\t\t// 表示要插入到的位置\n\t\t// 如果 v 指向一个空指针\n\t\t// 那么就可以插入到这里\n\t\t//\n\t\t// fa 是新节点的父节点\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v != NULL && (*v)->x != x) // 直到找到一个空位置，或者找到原有的值为 x 的节点\n\t\t{\n\t\t\tfa = *v;    // 以上一次找到的不空的 v 作为父节点\n\t\t\tfa->size++; // 因为要在这棵子树下插入一个新的节点\n\t\t\t\n\t\t\t// 根据大小向左右子树迭代\n\t\t\tif (x < fa->x)\n\t\t\t{\n\t\t\t\tv = &fa->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = &fa->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (*v != NULL)\n\t\t{\n\t\t\t(*v)->cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*v) = new Node(&root, fa, x);\n\t\t}\n\n\t\t(*v)->splay();\n\n\t\t// 伸展之后，*v 这个位置存的可能不再是新节点（因为父子关系改变了，而 v 一般指向一个节点的某个子节点的位置）\n\t\t// 直接返回根\n\t\treturn root;\n\t}\n\n\tNode *find(int x)\n\t{\n\t\t// 从根节点开始找\n\t\tNode *v = root;\n\t\twhile (v != NULL && v->x != x)\n\t\t{\n\t\t\tif (x < v->x)\n\t\t\t{\n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\t// 删除一个节点\n\tvoid erase(Node *v)\n\t{\n\t\tNode *pred = v->pred(), *succ = v->succ();\n\t\tpred->splay();\n\t\tsucc->splay(pred); // 使后继成为前趋（根）的右儿子\n\n\t\t// 此时后继的左儿子即为要删除的节点 v，且 v 此时为叶子节点\n\t\t\n\t\tif (v->size > 1)\n\t\t{\n\t\t\t// 如果存在不止一个 x，只需将计数减一\n\t\t\tv->size--;\n\t\t\tv->cnt--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete succ->ch[0]; // 使用 delete 关键字（严格地说，new 和 delete 是运算符）释放 new 分配的内存\n\t\t\tsucc->ch[0] = NULL; // 不要忘记置空\n\t\t}\n\n\t\t// 删了节点，需要将大小减小\n\t\tsucc->size--;\n\t\tpred->size--;\n\t}\n\n\t// 删除一个数\n\tvoid erase(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (!v) return; // 没有找到要删的节点，直接返回（一般题目中不会出现这种情况）\n\t\t\n\t\terase(v);\n\t}\n\n\t// 求一个数的前趋\n\tint pred(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->pred()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->pred()->x;\n\t\t}\n\t}\n\n\t// 求一个数的后继\n\tint succ(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->succ()->x;\n\t\t}\n\t}\n\n\t// 求一个数的排名\n\tint rank(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\t// 此时 v 已经是根节点了，因为新插入插入节点会被伸展\n\t\t\tint res = v->rank(); // 因为有一个无穷小，所以不需要 +1\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 此时 v 已经是根节点了，因为查找到的节点会被伸展\n\t\t\treturn v->rank();\n\t\t}\n\t}\n\n\t// 求第 k 小的数\n\tint select(int k)\n\t{\n\t\tNode *v = root;\n\t\twhile (!(k >= v->rank() && k < v->rank() + v->cnt))\n\t\t{\n\t\t\tif (k < v->rank())\n\t\t\t{\n\t\t\t\t// 要查的第 k 比当前节点的排名小，需要继续在左子树中查询\n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk -= v->rank() + v->cnt;\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v->x;\n\t}\n} splay;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tint opt, x;\n\t\tscanf(\"%d %d\", &opt, &x);\n\t\tif (opt == 1)\n\t\t{\n\t\t\tsplay.insert(x);\n\t\t}\n\t\telse if (opt == 2)\n\t\t{\n\t\t\tsplay.erase(x);\n\t\t}\n\t\telse if (opt == 3)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t}\n\t\telse if (opt == 4)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t}\n\t\telse if (opt == 5)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t}\n\t\telse if (opt == 6)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","slug":"splay-template","published":1,"updated":"2017-01-01T01:44:59.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdj008looxlpanbg3cl"},{"title":"Splay 学习笔记（三）","date":"2016-01-19T12:02:00.000Z","_content":"\n在《Splay 学习笔记（一）》中，我们学会了利用 Splay 来维护二叉排序树，现在让我们来把我们的 Splay 变得更加优美。\n\n模板请见[《Splay 模板 + 详细注释》](/splay-template)。\n\n<!-- more -->\n\n### 结构体定义\n两个孩子用一个数组来存，0 表示左孩子，1 表示右孩子，不需要再编写函数来获得某个孩子的引用了。\n\n引入 `count` 成员，表示这个值共出现了几次，不再重复插入相同的值，效率可以得到提高，特别是求前趋后继，实现起来也会变得更加简单。\n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay 操作\n把之前的“旋转到某位置”改为“旋转直到某节点成为自己的父节点”，不需要二级指针了，也不需要判断如果参数为 `NULL` 那么转到根了。\n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n### 节点的前趋 / 后继\n直接 `Splay` 后求即可，不需要多次迭代了。\n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### 选择\n选择第 `k` 小的元素时，需要把循环的条件改为**`k` 是否在 `[rank + 1, rank + count]`**的范围内，迭代到右子树时也要做相应的改动。\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### 完整代码（普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-3.md","raw":"title: Splay 学习笔记（三）\ncategories: OI\ntags: \n  - Splay\n  - 高级数据结构\n  - 学习笔记\n  - 数据结构\npermalink: splay-notes-3\ndate: 2016-01-19 20:02:00\n---\n\n在《Splay 学习笔记（一）》中，我们学会了利用 Splay 来维护二叉排序树，现在让我们来把我们的 Splay 变得更加优美。\n\n模板请见[《Splay 模板 + 详细注释》](/splay-template)。\n\n<!-- more -->\n\n### 结构体定义\n两个孩子用一个数组来存，0 表示左孩子，1 表示右孩子，不需要再编写函数来获得某个孩子的引用了。\n\n引入 `count` 成员，表示这个值共出现了几次，不再重复插入相同的值，效率可以得到提高，特别是求前趋后继，实现起来也会变得更加简单。\n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay 操作\n把之前的“旋转到某位置”改为“旋转直到某节点成为自己的父节点”，不需要二级指针了，也不需要判断如果参数为 `NULL` 那么转到根了。\n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n### 节点的前趋 / 后继\n直接 `Splay` 后求即可，不需要多次迭代了。\n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### 选择\n选择第 `k` 小的元素时，需要把循环的条件改为**`k` 是否在 `[rank + 1, rank + count]`**的范围内，迭代到右子树时也要做相应的改动。\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### 完整代码（普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-3","published":1,"updated":"2016-12-27T07:29:20.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdn008rooxl40ma1v0r"},{"title":"Splay 学习笔记（二）","id":"7","updated":"2016-01-19T13:07:35.000Z","date":"2015-12-22T21:44:41.000Z","_content":"\n在 Splay 学习笔记（一）中，我们学会了用 Splay 维护二叉排序树，来实现了有序集合的查询 / 修改操作，接下来，我们来研究 Splay 在维护数列中的用途。\n\n<!-- more -->\n\n### 基本原理\n我们知道，Splay 可以在不改变二叉树的中序遍历的情况下对节点进行旋转，通常我们用 Splay 来维护二叉排序树，用 Splay 维护的二叉排序树支持**区间删除**操作，但我们也可以通过一个数列的中序遍历创建一棵 Splay，然后使用类似区间删除中选择区间的原理来处理区间问题。\n\n这里，我们使用 Splay 实现数列的区间反转，反转一段区间，就对应了二叉树中的反转其**中序遍历**，我们可以使用递归交换左右子树的方法来实现，类比线段树的区间操作，在这里也可以应用线段树中的 `lazy-tag` 思想，给区间打标记。\n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n其中 `reversed` 表示以该节点为根的 Splay（其中序序列）有没有被反转，`bound` 表示该节点是否为数列的边界（相当于原 Splay 二叉排序树中的 `MIN` 和 `MAX` 两个虚拟节点）。\n\n### 数列de构建\n我们通常使用一个数列（数组）来初始化 Splay，这里使用递归构造每个区间的方式实现。具体我们编写两个 `build()`，分别针对**整棵树**和**一个区间**。\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n为了方便区间操作，我们在树的最左下端和最右下端分别创建一个虚拟节点，表示整棵树所表示的**开区间**的边界。\n\n注意递归构建时的区间计算，与线段树的**只有叶子节点表示单点，其它节点全部表示区间**不同，Splay 的每个节点都既表示**一个单点**，又表示**以该节点为根的 Splay 的所有节点构成的区间**，每个节点所代表的区间都会根据树的形态变化而变化，正因为如此，我们才可以通过 Splay 实现灵活的区间操作。\n\n### 标记de下放\n我们对区间操作的维护采用了类似线段树中 `lazy-tag` 的思想。同样，在 Splay 中，我们也需要在必要时对标记进行下放。\n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n反转标记的下放非常简单，交换左右子树，然后将标记打到子树上（`^= 1` 这里使用位运算异或来实现取反）。\n\n### 单点de选择\n当我们需要查询数列中某个点的信息时，我们需要对单点进行 `select()` 操作，这恰好对应了原 Splay 中选择第 `k` 大的操作。\n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n**注意**：`while` 循环判断条件中，调用 `node->lsize()` 取得其左子树大小前，一定要先将 `node` 的标记下放。**如果某个节点上的标记没有被下放，那么对其左、右孩子的访问都是非法的。**\n\n### 区间de选择\n为了实现区间操作，我们需要选择某个区间。注意这里的 `select()` 操作得到区间是指**代表该区间的节点**。为了准确的选择区间，我们需要对树的形态做一些调整。\n\n在 Splay 中选择一个开区间的步骤：\n\n1. 将区间的左端点 `Splay` 到**根**；\n2. 将区间的右端点 `Splay` 到**根的右子树**；\n3. 右端点的左子树即为要选择的区间。\n\n代码实现要注意**闭区间**到**开区间**的转化，同时，这里也体现出了两个虚拟节点带来的便利。\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### 区间de操作\n对区间进行操作时，我们只需要选择这段区间，并对所得的节点打上标记即可。\n\n以区间反转为例：\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### 结果de获取\n为了在结束时获取操作结果并输出，我们编写 `fetch()` 方法，将整棵树的中序序列复制到一个数组中。\n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n需要注意及时进行 `pushdown()` 操作和对边界的判断。\n\n### 注意事项\n需要注意的是，在访问每个节点之前，我们都需要保证树上没有**针对该节点**的标记（即从根节点到该节点的一整条链上没有标记），否则即为不可预料的非法访问。\n\n旋转，操作前先对父节点和自身执行 `pushdown()`，**然后再求 `relation()`**。\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay` 操作，每次循环开始时需要对父节点进行一次 `pushdown()`，因为接下来就要调用 `relation()`。\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n还有上文提到过的单点选择 `select()` 和 `dfs()` 遍历，因为涉及到对子节点的访问，所以在访问前也需要 `pushdown()`。\n\n### 完整代码（Tyvj / BZOJ 文艺平衡树）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### 总结\n学完了这些，对 Splay 维护数列的原理与实现也就基本了解了。其他的一些功能，比如区间最值，区间求和也都大同小异。有些区间操作使用线段树也可实现，但 Splay 的另一个优势在于，它可以动态地插入、删除节点，也就可以实现动态插入、删除区间，这是线段树所不具备的。","source":"_posts/splay-notes-2.md","raw":"title: Splay 学习笔记（二）\ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\npermalink: splay-notes-2\nid: 7\nupdated: '2016-01-19 21:07:35'\ndate: 2015-12-23 05:44:41\n---\n\n在 Splay 学习笔记（一）中，我们学会了用 Splay 维护二叉排序树，来实现了有序集合的查询 / 修改操作，接下来，我们来研究 Splay 在维护数列中的用途。\n\n<!-- more -->\n\n### 基本原理\n我们知道，Splay 可以在不改变二叉树的中序遍历的情况下对节点进行旋转，通常我们用 Splay 来维护二叉排序树，用 Splay 维护的二叉排序树支持**区间删除**操作，但我们也可以通过一个数列的中序遍历创建一棵 Splay，然后使用类似区间删除中选择区间的原理来处理区间问题。\n\n这里，我们使用 Splay 实现数列的区间反转，反转一段区间，就对应了二叉树中的反转其**中序遍历**，我们可以使用递归交换左右子树的方法来实现，类比线段树的区间操作，在这里也可以应用线段树中的 `lazy-tag` 思想，给区间打标记。\n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n其中 `reversed` 表示以该节点为根的 Splay（其中序序列）有没有被反转，`bound` 表示该节点是否为数列的边界（相当于原 Splay 二叉排序树中的 `MIN` 和 `MAX` 两个虚拟节点）。\n\n### 数列de构建\n我们通常使用一个数列（数组）来初始化 Splay，这里使用递归构造每个区间的方式实现。具体我们编写两个 `build()`，分别针对**整棵树**和**一个区间**。\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n为了方便区间操作，我们在树的最左下端和最右下端分别创建一个虚拟节点，表示整棵树所表示的**开区间**的边界。\n\n注意递归构建时的区间计算，与线段树的**只有叶子节点表示单点，其它节点全部表示区间**不同，Splay 的每个节点都既表示**一个单点**，又表示**以该节点为根的 Splay 的所有节点构成的区间**，每个节点所代表的区间都会根据树的形态变化而变化，正因为如此，我们才可以通过 Splay 实现灵活的区间操作。\n\n### 标记de下放\n我们对区间操作的维护采用了类似线段树中 `lazy-tag` 的思想。同样，在 Splay 中，我们也需要在必要时对标记进行下放。\n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n反转标记的下放非常简单，交换左右子树，然后将标记打到子树上（`^= 1` 这里使用位运算异或来实现取反）。\n\n### 单点de选择\n当我们需要查询数列中某个点的信息时，我们需要对单点进行 `select()` 操作，这恰好对应了原 Splay 中选择第 `k` 大的操作。\n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n**注意**：`while` 循环判断条件中，调用 `node->lsize()` 取得其左子树大小前，一定要先将 `node` 的标记下放。**如果某个节点上的标记没有被下放，那么对其左、右孩子的访问都是非法的。**\n\n### 区间de选择\n为了实现区间操作，我们需要选择某个区间。注意这里的 `select()` 操作得到区间是指**代表该区间的节点**。为了准确的选择区间，我们需要对树的形态做一些调整。\n\n在 Splay 中选择一个开区间的步骤：\n\n1. 将区间的左端点 `Splay` 到**根**；\n2. 将区间的右端点 `Splay` 到**根的右子树**；\n3. 右端点的左子树即为要选择的区间。\n\n代码实现要注意**闭区间**到**开区间**的转化，同时，这里也体现出了两个虚拟节点带来的便利。\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### 区间de操作\n对区间进行操作时，我们只需要选择这段区间，并对所得的节点打上标记即可。\n\n以区间反转为例：\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### 结果de获取\n为了在结束时获取操作结果并输出，我们编写 `fetch()` 方法，将整棵树的中序序列复制到一个数组中。\n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n需要注意及时进行 `pushdown()` 操作和对边界的判断。\n\n### 注意事项\n需要注意的是，在访问每个节点之前，我们都需要保证树上没有**针对该节点**的标记（即从根节点到该节点的一整条链上没有标记），否则即为不可预料的非法访问。\n\n旋转，操作前先对父节点和自身执行 `pushdown()`，**然后再求 `relation()`**。\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay` 操作，每次循环开始时需要对父节点进行一次 `pushdown()`，因为接下来就要调用 `relation()`。\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n还有上文提到过的单点选择 `select()` 和 `dfs()` 遍历，因为涉及到对子节点的访问，所以在访问前也需要 `pushdown()`。\n\n### 完整代码（Tyvj / BZOJ 文艺平衡树）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### 总结\n学完了这些，对 Splay 维护数列的原理与实现也就基本了解了。其他的一些功能，比如区间最值，区间求和也都大同小异。有些区间操作使用线段树也可实现，但 Splay 的另一个优势在于，它可以动态地插入、删除节点，也就可以实现动态插入、删除区间，这是线段树所不具备的。","slug":"splay-notes-2","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdq008xooxlfaz16hdw"},{"title":"Splay 学习笔记（一）","date":"2015-12-19T21:36:24.000Z","_content":"\n上周周四开始学 Splay，一边看《高级数据结构》，一边看 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》，现在终于弄明白最基础的一部分了。\n\n模板请见[《Splay 模板 + 详细注释》](/splay-template)。\n\n<!-- more -->\n\n### Splay 是什么?\nSplay Tree（伸展树）是一种自平衡二叉排序树，可以在均摊$O({\\log} n)$的时间内完成基于 Splay（伸展）操作的修改与查询。\n\n### 基本结构\n根据定义，Splay 是一棵二叉树，它的左子树和右子树分别是一棵 Splay，并且存储的值满足左子树 < 根 < 右子树，以下为每个 Splay 节点的定义。\n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n其中 `root` 表示指向**指向根节点的指针**的指针，这样做可以方便从任意一个节点找到整棵 Splay 的根节点，并修改它。`size` 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了 `size`，就可以轻松地实现选择和排名操作。\n\n### 准备\n为了方便各种复杂的操作，我们先为节点类 `node_t` 编写几个短小的方法，代码如下：\n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n这里在 `node_t` 的析构函数中递归释放所有内存，这在区间删除中可能耗时较长，如果内存不紧张，可以考虑不释放内存。\n\n为了旋转操作的方便，我们给每个节点设置一个“关系”属性，表示该节点与其父节点的关系，若该节点为左孩子，则“关系”为 `0`，反之则为 `1`。`relation()` 方法用来计算这个“关系”，而 `child()` 方法返回与该节点“关系”为 `x` 的子节点的**引用**。\n\n`maintain()` 方法则用来重新计算以该节点为根的 Splay 的大小，注意，为免去不必要的计算，假设两个子节点的大小是**已经计算好**的，不会再将其重新计算。\n\n### 旋转\n为了调换 Splay 中父节点与子节点的位置，我们实现 `rotate()` 方法，该方法在**保证以下三点**的情况下，将该节点向上移动一个位置：\n\n1. 整棵 Splay 的中序遍历不变；\n2. 受影响节点的 `size` 仍然有效；\n3. `*root` 总是指向整棵 Splay 的根。\n\n以左旋（若当前节点为父节点的左孩子）为例，旋转分为四个步骤：\n\n1. 将**祖父**节点与自身连接；\n2. 将自己的**右孩子**接到自己的父节点的**左孩子**的位置（替代自己）；\n3. 将父节点接到自己的**右孩子**的位置；\n4. 检查如果此时自身节点为根，则更新 `*root`。\n\n如图（图片来自 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》）：\n![splay](splay-notes-1/splay.png)\n\n代码：\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay 操作\nSplay 规定，每访问一个节点后，都要强制将该节点旋转到根的位置，于是我们很容易想到使用一个循环，判断是否已经到达目标，若不是则旋转，但这种方法的出现的问题在于，一条单链在旋转后仍然是单链，而且每次操作的时间复杂度无法得到保证！\n\n所以我们需要 `Splay` 操作来进行更加“智能化”的旋转，`Splay` 操作的每一次循环分为三步：\n\n1. 如果父节点为目标位置，则向上旋转；\n2. 如果**当前节点与父节点的“关系”**和**父节点与祖父节点的“关系”相同**，则先旋转父节点，再旋转自身；\n3. 如果不满足以上条件，则将自身连续旋转两次。\n\n代码（省略旋转目标的旋转到根）：\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### 插入\n一棵二叉排序树最基础的操作就是插入。\n\n首先，设置一个变量 `target`，表示要插入到的位置，它被初始化为指向根节点，每次循环判断要插入的值大于或小于当前的 `target` 的值，并修改 `target` 为指向某个孩子，循环直到 `target` 指向一个 `NULL`，即可在此位置创建新节点。\n\n插入完成后，需要将新节点 `Splay` 到根的位置。\n\n代码：\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n为了下文**删除**操作的方便，我们在每棵 Splay 构造时为其插入两个节点，分别表示无穷大和无穷小，树中其他节点的值都应该在这两个节点的值构成的**开区间**内。\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### 查找\n根据二叉排序树的有序性，我们可以很轻松的根据值查找到对应的节点，即从根开始查找，根据当前节点的值与要查找节点的值的大小关系，迭代到对应的子节点上，当当前节点的值等于要查找的值时即找到，若当前节点为 `NULL`，则说明查找失败。\n\n注意，当有多个相同值时，查找过程应该返回相同值中排名最靠前的，在此我们使用求找到节点的**前趋**，然后求其**后继**的方法（前趋和后继的求法见下文）。\n\n查找过程结束后，需要将找到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### 排名\n一个值在二叉排序树中的排名，即为该值在此二叉排序树的**中序遍历**中第一次出现的位置。\n\n在 Splay 中求排名非常简单，只要找到对应的节点，将其 `Splay` 到根，此时其左子树的 `size + 1` 即为所求的排名，而因为我们在初始化时多插入了一个“无穷小”节点，所以还要将 `1` 减去。\n\n一个有效数值的排名从 `1` 开始，因为表示“无穷小”的节点的排名为 `0`。\n\n代码：\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### 选择\n对应“排名”操作，二叉排序树有“选择”操作——返回此二叉排序树的**中序遍历**中的第 `k` 个元素。\n\n选择比排名要复杂一些，Splay 的选择过程和其他二叉排序树是相同的，我们通过以下几个步骤来实现：\n\n1. 初始化“当前节点”为根；\n2. 每次循环判断**以当前节点为根的 Splay 中**比该节点小的元素数量是否为 `k - 1`，如果是，则该节点即为要选择的节点；\n3. 如果 `k` 小于当前节点的排名，则迭代到左子树，否则，将 `k` 的值减小**当前节点的排名**后迭代到右子树（因为我们跳过的节点数等于**当前节点排名**）。\n\n选择过程结束后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n### 节点的前趋 / 后继\n我们定义二叉排序树中一个节点的前趋为在此二叉排序树的中序遍历中最后一个数值**小于**该节点数值的节点，同理，一个节点的后继为在此二叉排序树的中序遍历中第一个数值**大于**该节点数值的节点。\n\n以节点的前趋为例，其在 Splay 中的实现为：\n\n1. 将欲求其前趋的节点 `Splay` 到根；\n2. 找到根节点**左子树**的**最右链**的**最下端**（后继则相反），该节点即为此二叉排序树的中序遍历中最后一个数值**小于等于**根节点数值的节点；\n3. 如果该节点的数值与欲求其前趋的节点的数值相等，则转到步骤 1，否则该节点即为所求的前趋。\n\n求出节点的前趋或后继后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n### 值的前趋 / 后继\n我们定义一个数 `x` 在一棵二叉排序树中的前趋为此二叉排序树中小于 `x` 的数中最大的数，同理，一个数 `x` 在一棵二叉排序树中的后继为此二叉排序树中大于 `x` 的数中最小的数。\n\n以值的前趋为例，其实现分为两种情况：\n\n1. 欲求前趋的值在此二叉排序树中，则找到该值对应的节点并求其前趋即可；\n2. 欲求前趋的值不在此二叉排序树中，我们将该值作为一个新节点插入此二叉排序树，用情况 1 的方法求得其前趋，然后将插入的节点删除即可（删除的方法见下文）。\n\n代码：\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n### 删除（单点 / 区间）\nSplay 支持两种删除操作：单点删除和区间删除。因为单点删除即为左右端点相同的区间删除，所以我们在此主要讨论区间删除。\n\nSplay 的区间删除实现并不难，但方法非常的巧妙（下文中提到的前趋、后继均为节点的前趋、后继）：\n\n1. 将左端点的前趋 `Splay` 到根；\n2. 将右端点的后继 `Splay` 到**根的右子树**；\n3. 删除**右端点的后继的左子树**；\n4. 分别重新计算右端点的后继、左端点的前趋的 `size`。\n\n代码：\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### 完整代码（Tyvj / BZOJ / CodeVS 普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-1.md","raw":"title: Splay 学习笔记（一）\ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\npermalink: splay-notes-1\ndate: 2015-12-20 05:36:24\n---\n\n上周周四开始学 Splay，一边看《高级数据结构》，一边看 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》，现在终于弄明白最基础的一部分了。\n\n模板请见[《Splay 模板 + 详细注释》](/splay-template)。\n\n<!-- more -->\n\n### Splay 是什么?\nSplay Tree（伸展树）是一种自平衡二叉排序树，可以在均摊$O({\\log} n)$的时间内完成基于 Splay（伸展）操作的修改与查询。\n\n### 基本结构\n根据定义，Splay 是一棵二叉树，它的左子树和右子树分别是一棵 Splay，并且存储的值满足左子树 < 根 < 右子树，以下为每个 Splay 节点的定义。\n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n其中 `root` 表示指向**指向根节点的指针**的指针，这样做可以方便从任意一个节点找到整棵 Splay 的根节点，并修改它。`size` 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了 `size`，就可以轻松地实现选择和排名操作。\n\n### 准备\n为了方便各种复杂的操作，我们先为节点类 `node_t` 编写几个短小的方法，代码如下：\n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n这里在 `node_t` 的析构函数中递归释放所有内存，这在区间删除中可能耗时较长，如果内存不紧张，可以考虑不释放内存。\n\n为了旋转操作的方便，我们给每个节点设置一个“关系”属性，表示该节点与其父节点的关系，若该节点为左孩子，则“关系”为 `0`，反之则为 `1`。`relation()` 方法用来计算这个“关系”，而 `child()` 方法返回与该节点“关系”为 `x` 的子节点的**引用**。\n\n`maintain()` 方法则用来重新计算以该节点为根的 Splay 的大小，注意，为免去不必要的计算，假设两个子节点的大小是**已经计算好**的，不会再将其重新计算。\n\n### 旋转\n为了调换 Splay 中父节点与子节点的位置，我们实现 `rotate()` 方法，该方法在**保证以下三点**的情况下，将该节点向上移动一个位置：\n\n1. 整棵 Splay 的中序遍历不变；\n2. 受影响节点的 `size` 仍然有效；\n3. `*root` 总是指向整棵 Splay 的根。\n\n以左旋（若当前节点为父节点的左孩子）为例，旋转分为四个步骤：\n\n1. 将**祖父**节点与自身连接；\n2. 将自己的**右孩子**接到自己的父节点的**左孩子**的位置（替代自己）；\n3. 将父节点接到自己的**右孩子**的位置；\n4. 检查如果此时自身节点为根，则更新 `*root`。\n\n如图（图片来自 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》）：\n![splay](splay-notes-1/splay.png)\n\n代码：\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay 操作\nSplay 规定，每访问一个节点后，都要强制将该节点旋转到根的位置，于是我们很容易想到使用一个循环，判断是否已经到达目标，若不是则旋转，但这种方法的出现的问题在于，一条单链在旋转后仍然是单链，而且每次操作的时间复杂度无法得到保证！\n\n所以我们需要 `Splay` 操作来进行更加“智能化”的旋转，`Splay` 操作的每一次循环分为三步：\n\n1. 如果父节点为目标位置，则向上旋转；\n2. 如果**当前节点与父节点的“关系”**和**父节点与祖父节点的“关系”相同**，则先旋转父节点，再旋转自身；\n3. 如果不满足以上条件，则将自身连续旋转两次。\n\n代码（省略旋转目标的旋转到根）：\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### 插入\n一棵二叉排序树最基础的操作就是插入。\n\n首先，设置一个变量 `target`，表示要插入到的位置，它被初始化为指向根节点，每次循环判断要插入的值大于或小于当前的 `target` 的值，并修改 `target` 为指向某个孩子，循环直到 `target` 指向一个 `NULL`，即可在此位置创建新节点。\n\n插入完成后，需要将新节点 `Splay` 到根的位置。\n\n代码：\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n为了下文**删除**操作的方便，我们在每棵 Splay 构造时为其插入两个节点，分别表示无穷大和无穷小，树中其他节点的值都应该在这两个节点的值构成的**开区间**内。\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### 查找\n根据二叉排序树的有序性，我们可以很轻松的根据值查找到对应的节点，即从根开始查找，根据当前节点的值与要查找节点的值的大小关系，迭代到对应的子节点上，当当前节点的值等于要查找的值时即找到，若当前节点为 `NULL`，则说明查找失败。\n\n注意，当有多个相同值时，查找过程应该返回相同值中排名最靠前的，在此我们使用求找到节点的**前趋**，然后求其**后继**的方法（前趋和后继的求法见下文）。\n\n查找过程结束后，需要将找到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### 排名\n一个值在二叉排序树中的排名，即为该值在此二叉排序树的**中序遍历**中第一次出现的位置。\n\n在 Splay 中求排名非常简单，只要找到对应的节点，将其 `Splay` 到根，此时其左子树的 `size + 1` 即为所求的排名，而因为我们在初始化时多插入了一个“无穷小”节点，所以还要将 `1` 减去。\n\n一个有效数值的排名从 `1` 开始，因为表示“无穷小”的节点的排名为 `0`。\n\n代码：\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### 选择\n对应“排名”操作，二叉排序树有“选择”操作——返回此二叉排序树的**中序遍历**中的第 `k` 个元素。\n\n选择比排名要复杂一些，Splay 的选择过程和其他二叉排序树是相同的，我们通过以下几个步骤来实现：\n\n1. 初始化“当前节点”为根；\n2. 每次循环判断**以当前节点为根的 Splay 中**比该节点小的元素数量是否为 `k - 1`，如果是，则该节点即为要选择的节点；\n3. 如果 `k` 小于当前节点的排名，则迭代到左子树，否则，将 `k` 的值减小**当前节点的排名**后迭代到右子树（因为我们跳过的节点数等于**当前节点排名**）。\n\n选择过程结束后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n### 节点的前趋 / 后继\n我们定义二叉排序树中一个节点的前趋为在此二叉排序树的中序遍历中最后一个数值**小于**该节点数值的节点，同理，一个节点的后继为在此二叉排序树的中序遍历中第一个数值**大于**该节点数值的节点。\n\n以节点的前趋为例，其在 Splay 中的实现为：\n\n1. 将欲求其前趋的节点 `Splay` 到根；\n2. 找到根节点**左子树**的**最右链**的**最下端**（后继则相反），该节点即为此二叉排序树的中序遍历中最后一个数值**小于等于**根节点数值的节点；\n3. 如果该节点的数值与欲求其前趋的节点的数值相等，则转到步骤 1，否则该节点即为所求的前趋。\n\n求出节点的前趋或后继后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n### 值的前趋 / 后继\n我们定义一个数 `x` 在一棵二叉排序树中的前趋为此二叉排序树中小于 `x` 的数中最大的数，同理，一个数 `x` 在一棵二叉排序树中的后继为此二叉排序树中大于 `x` 的数中最小的数。\n\n以值的前趋为例，其实现分为两种情况：\n\n1. 欲求前趋的值在此二叉排序树中，则找到该值对应的节点并求其前趋即可；\n2. 欲求前趋的值不在此二叉排序树中，我们将该值作为一个新节点插入此二叉排序树，用情况 1 的方法求得其前趋，然后将插入的节点删除即可（删除的方法见下文）。\n\n代码：\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n### 删除（单点 / 区间）\nSplay 支持两种删除操作：单点删除和区间删除。因为单点删除即为左右端点相同的区间删除，所以我们在此主要讨论区间删除。\n\nSplay 的区间删除实现并不难，但方法非常的巧妙（下文中提到的前趋、后继均为节点的前趋、后继）：\n\n1. 将左端点的前趋 `Splay` 到根；\n2. 将右端点的后继 `Splay` 到**根的右子树**；\n3. 删除**右端点的后继的左子树**；\n4. 分别重新计算右端点的后继、左端点的前趋的 `size`。\n\n代码：\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### 完整代码（Tyvj / BZOJ / CodeVS 普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-1","published":1,"updated":"2016-12-27T07:29:12.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rds0094ooxlo8t6v8ua"},{"title":"「SHOI2008」堵塞的交通 - 线段树","date":"2016-10-19T06:30:00.000Z","_content":"\n整个国家的交通系统可以被看成是一个 $ 2 $ 行 $ C $ 列的矩形网格，网格上的每个点代表一个城市，相邻的城市之间有一条道路，所以总共有 $ 2C $ 个城市和 $ 3C - 2 $ 条道路。\n\n交通信息可以分为以下几种格式：\n1. `Close r1 c1 r2 c2`，相邻的两座城市 $ (r_1, c_1) $ 和 $ (r_2, c_2) $ 之间的道路被堵塞了；\n2. `Open r1 c1 r2 c2`，相邻的两座城市 $ (r_1, c_1) $ 和 $ (r_2, c_2) $ 之间的道路被疏通了；\n3. `Ask r1 c1 r2 c2`，询问城市 $ (r_1, c_1) $ 和 $ (r_2, c_2) $ 是否连通。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018)\n\n### 题解\n对所有列建立线段树，维护一个区间的连通性。我们用 $ (i, 0) $ 和 $ (i, 1) $ 分别表示第 $ i $ 列的上面和下面的位置。\n\n线段树中 $ [l, r] $ 区间维护 $ (l, 0), (l, 1) $ 分别与 $ (r, 0), (r, 1) $ 的连通性。\n\n如果第 $ i $ 列上下连通，则认为区间 $ [l = i, r = i] $ 的 $ (l, 0) $ 与 $ (r, 1) $、$ (l, 1) $ 与 $ (r, 0) $ 连通。\n\n合并 $ [l, m] $ 与 $ [m + 1, r] $ 两个区间时，枚举经过 $ m \\leftrightarrow m + 1 $ 的上方还是下方的路径。\n\n查询区间 $ [l, r] $ 列时，首先二分从 $ l $ 能到达的最左列 $ l' $ 和 $ r $ 能到的的最右列 $ r' $，在线段树上查询 $ [l', r'] $ 即可。\n\n具体细节见代码。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nbool right[MAXN][2], middle[MAXN + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(const bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\nConnectivity merge(Connectivity a, Connectivity b, const int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tConnectivity conn;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {}\n\n\tvoid update(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tconn(0, 0) = conn(1, 1) = true;\n\t\t\tconn(0, 1) = conn(1, 0) = middle[mid];\n\t\t\treturn;\n\t\t} else if (!(l <= this->l && r >= this->r)) {\n\t\t\tlc->update(l, r);\n\t\t\trc->update(l, r);\n\t\t} else if (this->l == this->r - 1) lc->update(l, r), rc->update(l, r);\n\t\tconn = merge(lc->conn, rc->conn, mid);\n\t}\n\n\tConnectivity query(const int l, const int r) {\n\t\tif (l <= this->l && r >= this->r) return conn;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\ninline void update(int r1, int c1, int r2, int c2, const bool val) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = val;\n\t} else {\n\t\tmiddle[c1] = val;\n\t}\n\tsegment->update(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tConnectivity res = segment->query(mid, c1);\n\t\tif (res(0, r1) || res(1, r1)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lconn = segment->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segment->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rconn = segment->query(c2, rpos);\n\n\tConnectivity conn = segment->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lconn(i, r1) && rconn(r2, j) && conn(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegment = SegmentTree::build(1, n);\n\n\tchar cmd[5];\n\twhile (~scanf(\"%s\", cmd)) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse if (cmd[0] == 'O') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, true);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, false);\n\t\t} else if (cmd[0] == 'A') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tif (c1 > c2) std::swap(c1, c2), std::swap(r1, r2);\n\t\t\tputs(query(r1 - 1, c1, r2 - 1, c2) ? \"Y\" : \"N\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-traffic.md","raw":"title: 「SHOI2008」堵塞的交通 - 线段树\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - 线段树\npermalink: shoi2008-traffic\ndate: 2016-10-19 14:30:00\n---\n\n整个国家的交通系统可以被看成是一个 $ 2 $ 行 $ C $ 列的矩形网格，网格上的每个点代表一个城市，相邻的城市之间有一条道路，所以总共有 $ 2C $ 个城市和 $ 3C - 2 $ 条道路。\n\n交通信息可以分为以下几种格式：\n1. `Close r1 c1 r2 c2`，相邻的两座城市 $ (r_1, c_1) $ 和 $ (r_2, c_2) $ 之间的道路被堵塞了；\n2. `Open r1 c1 r2 c2`，相邻的两座城市 $ (r_1, c_1) $ 和 $ (r_2, c_2) $ 之间的道路被疏通了；\n3. `Ask r1 c1 r2 c2`，询问城市 $ (r_1, c_1) $ 和 $ (r_2, c_2) $ 是否连通。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018)\n\n### 题解\n对所有列建立线段树，维护一个区间的连通性。我们用 $ (i, 0) $ 和 $ (i, 1) $ 分别表示第 $ i $ 列的上面和下面的位置。\n\n线段树中 $ [l, r] $ 区间维护 $ (l, 0), (l, 1) $ 分别与 $ (r, 0), (r, 1) $ 的连通性。\n\n如果第 $ i $ 列上下连通，则认为区间 $ [l = i, r = i] $ 的 $ (l, 0) $ 与 $ (r, 1) $、$ (l, 1) $ 与 $ (r, 0) $ 连通。\n\n合并 $ [l, m] $ 与 $ [m + 1, r] $ 两个区间时，枚举经过 $ m \\leftrightarrow m + 1 $ 的上方还是下方的路径。\n\n查询区间 $ [l, r] $ 列时，首先二分从 $ l $ 能到达的最左列 $ l' $ 和 $ r $ 能到的的最右列 $ r' $，在线段树上查询 $ [l', r'] $ 即可。\n\n具体细节见代码。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nbool right[MAXN][2], middle[MAXN + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(const bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\nConnectivity merge(Connectivity a, Connectivity b, const int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tConnectivity conn;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {}\n\n\tvoid update(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tconn(0, 0) = conn(1, 1) = true;\n\t\t\tconn(0, 1) = conn(1, 0) = middle[mid];\n\t\t\treturn;\n\t\t} else if (!(l <= this->l && r >= this->r)) {\n\t\t\tlc->update(l, r);\n\t\t\trc->update(l, r);\n\t\t} else if (this->l == this->r - 1) lc->update(l, r), rc->update(l, r);\n\t\tconn = merge(lc->conn, rc->conn, mid);\n\t}\n\n\tConnectivity query(const int l, const int r) {\n\t\tif (l <= this->l && r >= this->r) return conn;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\ninline void update(int r1, int c1, int r2, int c2, const bool val) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = val;\n\t} else {\n\t\tmiddle[c1] = val;\n\t}\n\tsegment->update(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tConnectivity res = segment->query(mid, c1);\n\t\tif (res(0, r1) || res(1, r1)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lconn = segment->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segment->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rconn = segment->query(c2, rpos);\n\n\tConnectivity conn = segment->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lconn(i, r1) && rconn(r2, j) && conn(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegment = SegmentTree::build(1, n);\n\n\tchar cmd[5];\n\twhile (~scanf(\"%s\", cmd)) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse if (cmd[0] == 'O') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, true);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, false);\n\t\t} else if (cmd[0] == 'A') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tif (c1 > c2) std::swap(c1, c2), std::swap(r1, r2);\n\t\t\tputs(query(r1 - 1, c1, r2 - 1, c2) ? \"Y\" : \"N\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"shoi2008-traffic","published":1,"updated":"2016-10-19T06:30:27.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdx009booxlch8h998g"},{"title":"「SHOI2008」小约翰的游戏 - 博弈论","date":"2016-10-19T07:53:00.000Z","_content":"\n桌子上有 $ n $ 堆石子，轮流取石子，每个人取的时候，可以随意选择一堆石子，在这堆石子中取走任意多的石子，但不能一粒石子也不取，我们规定取到最后一粒石子的人算**输**。求先手是否必胜。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1022](http://www.lydsy.com/JudgeOnline/problem.php?id=1022)\n\n### 题解\n如果每堆石子都只有一个，则先手只能每次取一颗石子。如果有奇数堆，则先手必败，否则先手必胜。\n\n如果至少有一堆石子不止有一个，则**每堆石子数量的异或不为零时，先手必胜**。\n\n证明：如果当前每堆石子数量的异或和不为零，则先手玩家一定存在一种方案取走若干颗石子，使它们的异或和为零。下一次取时，后手玩家的任意方案均会使这个异或和变得不为零。最终，先手玩家存在一种方案，使得剩下一堆一个石子，后手玩家取到这颗石子后输。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 50;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint s = 0;\n\t\tbool flag = false;\n\t\twhile (n--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ts ^= x;\n\t\t\tif (x > 1) flag = true;\n\t\t}\n\n\t\tputs(((!flag && s == 0) || (flag && s != 0)) ? \"John\" : \"Brother\");\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-john.md","raw":"title: 「SHOI2008」小约翰的游戏 - 博弈论\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - 数学\n  - 博弈论\npermalink: shoi2008-john\ndate: 2016-10-19 15:53:00\n---\n\n桌子上有 $ n $ 堆石子，轮流取石子，每个人取的时候，可以随意选择一堆石子，在这堆石子中取走任意多的石子，但不能一粒石子也不取，我们规定取到最后一粒石子的人算**输**。求先手是否必胜。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1022](http://www.lydsy.com/JudgeOnline/problem.php?id=1022)\n\n### 题解\n如果每堆石子都只有一个，则先手只能每次取一颗石子。如果有奇数堆，则先手必败，否则先手必胜。\n\n如果至少有一堆石子不止有一个，则**每堆石子数量的异或不为零时，先手必胜**。\n\n证明：如果当前每堆石子数量的异或和不为零，则先手玩家一定存在一种方案取走若干颗石子，使它们的异或和为零。下一次取时，后手玩家的任意方案均会使这个异或和变得不为零。最终，先手玩家存在一种方案，使得剩下一堆一个石子，后手玩家取到这颗石子后输。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 50;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint s = 0;\n\t\tbool flag = false;\n\t\twhile (n--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ts ^= x;\n\t\t\tif (x > 1) flag = true;\n\t\t}\n\n\t\tputs(((!flag && s == 0) || (flag && s != 0)) ? \"John\" : \"Brother\");\n\t}\n\n\treturn 0;\n}\n```","slug":"shoi2008-john","published":1,"updated":"2016-10-19T07:53:47.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9re0009hooxl4o7msif9"},{"title":"「SHOI2008」汉诺塔 - DP","date":"2016-10-19T07:24:00.000Z","_content":"\n在任何操作执行之前，我们以任意的次序为六种操作（AB、AC、BA、BC、CA 和 CB）赋予不同的优先级，然后，我们总是选择符合以下两个条件的操作来移动盘子，直到所有的盘子都从柱子 A 移动到另一根柱子：\n\n1. 这种操作是所有合法操作中优先级最高的；\n2. 这种操作所要移动的盘子不是上一次操作所移动的那个盘子。\n\n可以证明，上述策略一定能完成汉诺塔游戏。  \n现在你的任务就是假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019)\n\n### 题解\n设 $ f(j, i) $ 表示只考虑柱子 $ i $ 上的最上面的 $ j $ 个盘子（不考虑下面更大的盘子和其它柱子上的盘子），将这些盘子移动到 $ g(j, i) $ 上的步数。\n\n根据汉诺塔的规则，我们需要先移动前 $ j - 1 $ 个盘子，需要 $ f(j - 1, i) $ 次操作，这些盘子被移动到 $ g(j - 1, i) $ 上。设 $ a = g(j - 1, i) $，则另一个柱子 $ b = 3 - a - i $。我们需要把第 $ j $ 个盘子移动到 $ b $ 上。\n\n继续考虑移动到 $ a $ 上的 $ j - 1 $ 个盘子，这些盘子需要移动到 $ g(j - 1, a) $ 上，如果 $ g(j - 1, a) = b $，则直接将它们移到 $ b $ 上，此时 $ j $ 个盘子均已移动到 $ b $ 上，所以 $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) $，$ g(j, i) = b $。\n\n如果 $ g(j - 1, a) = i $ 则需要将 $ j - 1 $ 个盘子移回 $ i $ 柱子，然后将最大的盘子移到 $ a $ 上，再将前 $ j - 1 $ 个盘子移到 $ a $ 上（因为 $ g(j - 1, i) = a $）。所以 $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) $，$ g(j, i) = a $\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 30;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int g[MAXN + 1][3];\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tint a = s[0] - 'A', b = s[1] - 'A';\n\t\tif (g[1][a] == -1) g[1][a] = b;\n\t}\n\n\tstatic long long f[MAXN + 1][3];\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-hannoi.md","raw":"title: 「SHOI2008」汉诺塔 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\npermalink: shoi2008-hannoi\ndate: 2016-10-19 15:24:00\n---\n\n在任何操作执行之前，我们以任意的次序为六种操作（AB、AC、BA、BC、CA 和 CB）赋予不同的优先级，然后，我们总是选择符合以下两个条件的操作来移动盘子，直到所有的盘子都从柱子 A 移动到另一根柱子：\n\n1. 这种操作是所有合法操作中优先级最高的；\n2. 这种操作所要移动的盘子不是上一次操作所移动的那个盘子。\n\n可以证明，上述策略一定能完成汉诺塔游戏。  \n现在你的任务就是假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019)\n\n### 题解\n设 $ f(j, i) $ 表示只考虑柱子 $ i $ 上的最上面的 $ j $ 个盘子（不考虑下面更大的盘子和其它柱子上的盘子），将这些盘子移动到 $ g(j, i) $ 上的步数。\n\n根据汉诺塔的规则，我们需要先移动前 $ j - 1 $ 个盘子，需要 $ f(j - 1, i) $ 次操作，这些盘子被移动到 $ g(j - 1, i) $ 上。设 $ a = g(j - 1, i) $，则另一个柱子 $ b = 3 - a - i $。我们需要把第 $ j $ 个盘子移动到 $ b $ 上。\n\n继续考虑移动到 $ a $ 上的 $ j - 1 $ 个盘子，这些盘子需要移动到 $ g(j - 1, a) $ 上，如果 $ g(j - 1, a) = b $，则直接将它们移到 $ b $ 上，此时 $ j $ 个盘子均已移动到 $ b $ 上，所以 $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) $，$ g(j, i) = b $。\n\n如果 $ g(j - 1, a) = i $ 则需要将 $ j - 1 $ 个盘子移回 $ i $ 柱子，然后将最大的盘子移到 $ a $ 上，再将前 $ j - 1 $ 个盘子移到 $ a $ 上（因为 $ g(j - 1, i) = a $）。所以 $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) $，$ g(j, i) = a $\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 30;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int g[MAXN + 1][3];\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tint a = s[0] - 'A', b = s[1] - 'A';\n\t\tif (g[1][a] == -1) g[1][a] = b;\n\t}\n\n\tstatic long long f[MAXN + 1][3];\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\n\treturn 0;\n}\n```","slug":"shoi2008-hannoi","published":1,"updated":"2016-10-19T07:24:21.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9re3009oooxl9oqc1j4j"},{"title":"「SHOI2008」循环的债务 - DP","date":"2016-10-19T07:35:00.000Z","_content":"\nA、B、C 三个人之间互相有一些债务，每个人有每种面值 $ 1, 5, 10, 20, 50, 100 $ 的钞票若干，求使他们把债务还清的最少交换的现金数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)\n\n### 题解\n设 $ f(i, a, b) $ 表示考虑了前 $ i $ 种面值的钞票，使 A 拥有 $ a $ 元，B 拥有 $ b $ 元的最少交换次数。\n\n每一次考虑一种面值的钞票，枚举以下几种转移方式，使用**刷表**转移：\n\n* $ a \\rightarrow b, c $\n* $ b \\rightarrow a, c $\n* $ c \\rightarrow a, b $\n* $ a, b \\rightarrow c $\n* $ a, c \\rightarrow b $\n* $ b, c \\rightarrow a $\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tconst int min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c < 0) {\n\t\tconst int max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tint has[3][6 + 1];\n\tint sum = 0, sums[3] = { 0, 0, 0 };\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &has[i][6 - j]);\n\t\t\tsums[i] += has[i][6 - j] * VAL[6 - j];\n#ifdef DBG\n\t\t\tfor (int k = 0; k < has[i][6 - j]; k++) printf(\"%d\\n\", VAL[6 - j]);\n#endif\n\t\t}\n\t\tsum += sums[i];\n#ifdef DBG\n\t\tputchar('\\n');\n#endif\n\t}\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", sums[0], sums[1], sums[2]);\n#endif\n\n\tstatic int f[6 + 1][MAXN + 1][MAXN + 1];\n\tfor (int i = 0; i <= 6; i++) for (int j = 0; j <= MAXN; j++) for (int k = 0; k <= MAXN; k++) f[i][j][k] = INT_MAX;\n\n\tf[0][sums[0]][sums[1]] = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= sum; a++) {\n\t\t\tfor (int b = 0; b <= sum - a; b++) {\n\t\t\t\tconst int c = sum - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= has[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= has[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= has[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= has[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tif (_a < 0 || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tif (_a > sum || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef DBG\n\t\t\t\tif (f[i + 1][a][b] != INT_MAX) printf(\"f(%d, %d, %d) = %d\\n\", i + 1, a, b, f[i + 1][a][b]);\n#endif\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b;\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", resA, resB, resC);\n#endif\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-debt.md","raw":"title: 「SHOI2008」循环的债务 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\npermalink: shoi2008-debt\ndate: 2016-10-19 15:35:00\n---\n\nA、B、C 三个人之间互相有一些债务，每个人有每种面值 $ 1, 5, 10, 20, 50, 100 $ 的钞票若干，求使他们把债务还清的最少交换的现金数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)\n\n### 题解\n设 $ f(i, a, b) $ 表示考虑了前 $ i $ 种面值的钞票，使 A 拥有 $ a $ 元，B 拥有 $ b $ 元的最少交换次数。\n\n每一次考虑一种面值的钞票，枚举以下几种转移方式，使用**刷表**转移：\n\n* $ a \\rightarrow b, c $\n* $ b \\rightarrow a, c $\n* $ c \\rightarrow a, b $\n* $ a, b \\rightarrow c $\n* $ a, c \\rightarrow b $\n* $ b, c \\rightarrow a $\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tconst int min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c < 0) {\n\t\tconst int max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tint has[3][6 + 1];\n\tint sum = 0, sums[3] = { 0, 0, 0 };\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &has[i][6 - j]);\n\t\t\tsums[i] += has[i][6 - j] * VAL[6 - j];\n#ifdef DBG\n\t\t\tfor (int k = 0; k < has[i][6 - j]; k++) printf(\"%d\\n\", VAL[6 - j]);\n#endif\n\t\t}\n\t\tsum += sums[i];\n#ifdef DBG\n\t\tputchar('\\n');\n#endif\n\t}\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", sums[0], sums[1], sums[2]);\n#endif\n\n\tstatic int f[6 + 1][MAXN + 1][MAXN + 1];\n\tfor (int i = 0; i <= 6; i++) for (int j = 0; j <= MAXN; j++) for (int k = 0; k <= MAXN; k++) f[i][j][k] = INT_MAX;\n\n\tf[0][sums[0]][sums[1]] = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= sum; a++) {\n\t\t\tfor (int b = 0; b <= sum - a; b++) {\n\t\t\t\tconst int c = sum - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= has[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= has[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= has[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= has[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tif (_a < 0 || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tif (_a > sum || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef DBG\n\t\t\t\tif (f[i + 1][a][b] != INT_MAX) printf(\"f(%d, %d, %d) = %d\\n\", i + 1, a, b, f[i + 1][a][b]);\n#endif\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b;\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", resA, resB, resC);\n#endif\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","slug":"shoi2008-debt","published":1,"updated":"2016-10-19T07:35:55.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9re6009tooxlxwkgks62"},{"title":"「SHOI2008」仙人掌图 - 仙人掌 DP","date":"2016-10-26T00:02:00.000Z","_content":"\n求仙人掌图的直径。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023)\n\n### 题解\n任选一个点为根，DFS 整棵树，设 $ f(i) $ 表示 **DFS 树中以 $ i $ 为根的子树在原图中的诱导子图**中以 $ i $ 开始的最长路径。\n\n如果直接树形 DP，得出的答案可能会偏大，因为环的存在会使树上两个点的距离变小。考虑进行树形 DP 时，不在**同一个环**上的点之间转移，即 $ f(i) $ 求出的路径均不包含 $ i $ 点所在环内的路径。\n\n在 DFS 过程中维护 $ \\mathrm{dfn}(i) $ 和 $ \\mathrm{low}(i) $，在回溯时，对于 $ i $ 的邻接点 $ j $（$ j $ 不是 $ i $ 的父节点），如果 $ \\mathrm{low}(j) > \\mathrm{dfn}(i) $，则表明 $ j $ 与 $ i $ 不在同一个环中，这种情况下可以由 $ f(j) $ 转移到 $ f(i) $，并更新答案。如果 $ j $ 不是 $ i $ 的子节点且 $ \\mathrm{dfn}(j) > \\mathrm{dfn}(i) $，则连接 $ i $ 与 $ j $ 的边是一条返祖边。\n\n对于一个环，我们称环上深度最小的点（返祖边的一个端点）为环的**最高点**。找到返祖边之后，一直向父节点走，可以遍历整个环。对于这个环的最高点 $ i $，根据 $ f(i) $ 的定义，整个环是包含在以 $ i $ 为根的子树的诱导子图中的，也就是说这里的 $ f(i) $ 可以包含环中的路径。考虑环上的另一个点 $ j $，$ f(i) $ 一定是 $ f(j) + \\mathrm{dist}(j) $ 的形式。\n\n环上的点也可以更新答案，答案的形式是 $ f(i) + f(j) + \\mathrm{dist}(i, j) $ 的形式。这 $ s(i) $ 为环上第 $ i $ 个点到第一个点的距离，$ f'(i) $ 为环上第 $ i $ 个点的 $ f $ 值，则答案可表示为 $ f'(i) + f'(j) + s(i) - s(j) $ 的形式。将环拆成链，翻倍，使用单调队列维护 $ f'(j) - s(j) $ 的最大值，并保证 $ s(i) - s(j) $ 不大于环的一半。注意这里更新答案需要在更新最高点的 $ f $ 值之前。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 50000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tint dfn, low, len;\n\tbool visited, pushed;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nint n;\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void updateCircle(Node *top, Node *u, int &ans) {\n#ifdef DBG\n\tprintf(\"updateCircle(%lu, %lu)\\n\", top - N + 1, u - N + 1);\n#endif\n\tstatic Node *v[MAXN * 2];\n\tint cnt = 0;\n\twhile (1) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->parent;\n\t}\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAXN * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\t// ans = max{ f[i] + f[j] + i - j }\n\t// maintain the max of f[j] - j\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n#ifdef DBG\n\t\tprintf(\"updateCircle: ans <- %d\\n\", v[*l]->len + v[i]->len + i - *l);\n#endif\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\t// printf(\"updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\\n\", top - N + 1, u - N + 1, v[i] - N + 1, v[i]->len, i, cnt - i);\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n#ifdef CHECK\n\tprintf(\"updateCircle(%lu, %lu) = %d\\n\", top - N + 1, u - N + 1, res);\n#endif\n\n\ttop->len = std::max(top->len, res);\n}\n\ninline int tarjan() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].pushed = true;\n\n\tint ts = 0, ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->dfn = v->low = ++ts;\n\t\t}\n\n\t\tif (v->c && v->c->t == v->parent) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\tif (e->t->dfn) {\n\t\t\t\tv->low = std::min(v->low, e->t->dfn);\n\t\t\t} else {\n\t\t\t\te->t->pushed = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t == v->parent) continue;\n\n\t\t\t\tif (e->t->low > v->dfn) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: ans <- (f[%lu] = %d) + (f[%lu] = %d) + 1\\n\", v - N + 1, v->len, e->t - N + 1, e->t->len);\n#endif\n\t\t\t\t\tans = std::max(ans, v->len + e->t->len + 1);\n\t\t\t\t\tv->len = std::max(v->len, e->t->len + 1);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e->t->parent != v && e->t->dfn > v->dfn) {\n\t\t\t\t\tupdateCircle(v, e->t, ans);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d (from circle)\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->parent) v->parent->low = std::min(v->parent->low, v->low);\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u), u--, k--;\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v), v--;\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", tarjan());\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-cactus.md","raw":"title: 「SHOI2008」仙人掌图 - 仙人掌 DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\n  - 仙人掌\n  - Tarjan\npermalink: shoi2008-cactus\ndate: 2016-10-26 08:02:00\n---\n\n求仙人掌图的直径。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023)\n\n### 题解\n任选一个点为根，DFS 整棵树，设 $ f(i) $ 表示 **DFS 树中以 $ i $ 为根的子树在原图中的诱导子图**中以 $ i $ 开始的最长路径。\n\n如果直接树形 DP，得出的答案可能会偏大，因为环的存在会使树上两个点的距离变小。考虑进行树形 DP 时，不在**同一个环**上的点之间转移，即 $ f(i) $ 求出的路径均不包含 $ i $ 点所在环内的路径。\n\n在 DFS 过程中维护 $ \\mathrm{dfn}(i) $ 和 $ \\mathrm{low}(i) $，在回溯时，对于 $ i $ 的邻接点 $ j $（$ j $ 不是 $ i $ 的父节点），如果 $ \\mathrm{low}(j) > \\mathrm{dfn}(i) $，则表明 $ j $ 与 $ i $ 不在同一个环中，这种情况下可以由 $ f(j) $ 转移到 $ f(i) $，并更新答案。如果 $ j $ 不是 $ i $ 的子节点且 $ \\mathrm{dfn}(j) > \\mathrm{dfn}(i) $，则连接 $ i $ 与 $ j $ 的边是一条返祖边。\n\n对于一个环，我们称环上深度最小的点（返祖边的一个端点）为环的**最高点**。找到返祖边之后，一直向父节点走，可以遍历整个环。对于这个环的最高点 $ i $，根据 $ f(i) $ 的定义，整个环是包含在以 $ i $ 为根的子树的诱导子图中的，也就是说这里的 $ f(i) $ 可以包含环中的路径。考虑环上的另一个点 $ j $，$ f(i) $ 一定是 $ f(j) + \\mathrm{dist}(j) $ 的形式。\n\n环上的点也可以更新答案，答案的形式是 $ f(i) + f(j) + \\mathrm{dist}(i, j) $ 的形式。这 $ s(i) $ 为环上第 $ i $ 个点到第一个点的距离，$ f'(i) $ 为环上第 $ i $ 个点的 $ f $ 值，则答案可表示为 $ f'(i) + f'(j) + s(i) - s(j) $ 的形式。将环拆成链，翻倍，使用单调队列维护 $ f'(j) - s(j) $ 的最大值，并保证 $ s(i) - s(j) $ 不大于环的一半。注意这里更新答案需要在更新最高点的 $ f $ 值之前。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 50000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tint dfn, low, len;\n\tbool visited, pushed;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nint n;\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void updateCircle(Node *top, Node *u, int &ans) {\n#ifdef DBG\n\tprintf(\"updateCircle(%lu, %lu)\\n\", top - N + 1, u - N + 1);\n#endif\n\tstatic Node *v[MAXN * 2];\n\tint cnt = 0;\n\twhile (1) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->parent;\n\t}\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAXN * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\t// ans = max{ f[i] + f[j] + i - j }\n\t// maintain the max of f[j] - j\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n#ifdef DBG\n\t\tprintf(\"updateCircle: ans <- %d\\n\", v[*l]->len + v[i]->len + i - *l);\n#endif\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\t// printf(\"updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\\n\", top - N + 1, u - N + 1, v[i] - N + 1, v[i]->len, i, cnt - i);\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n#ifdef CHECK\n\tprintf(\"updateCircle(%lu, %lu) = %d\\n\", top - N + 1, u - N + 1, res);\n#endif\n\n\ttop->len = std::max(top->len, res);\n}\n\ninline int tarjan() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].pushed = true;\n\n\tint ts = 0, ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->dfn = v->low = ++ts;\n\t\t}\n\n\t\tif (v->c && v->c->t == v->parent) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\tif (e->t->dfn) {\n\t\t\t\tv->low = std::min(v->low, e->t->dfn);\n\t\t\t} else {\n\t\t\t\te->t->pushed = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t == v->parent) continue;\n\n\t\t\t\tif (e->t->low > v->dfn) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: ans <- (f[%lu] = %d) + (f[%lu] = %d) + 1\\n\", v - N + 1, v->len, e->t - N + 1, e->t->len);\n#endif\n\t\t\t\t\tans = std::max(ans, v->len + e->t->len + 1);\n\t\t\t\t\tv->len = std::max(v->len, e->t->len + 1);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e->t->parent != v && e->t->dfn > v->dfn) {\n\t\t\t\t\tupdateCircle(v, e->t, ans);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d (from circle)\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->parent) v->parent->low = std::min(v->parent->low, v->low);\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u), u--, k--;\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v), v--;\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", tarjan());\n\n\treturn 0;\n}\n```","slug":"shoi2008-cactus","published":1,"updated":"2016-10-26T00:02:45.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9re9009yooxl765qsyac"},{"title":"「SHOI2007」善意的投票 - 最小割","date":"2016-06-21T07:04:00.000Z","_content":"\n幼儿园里有 $ n $ 个小朋友打算通过投票来决定睡不睡午觉。他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。每位小朋友应该怎样投票，才能使冲突数最小？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1934](http://www.lydsy.com/JudgeOnline/problem.php?id=1934)\n\n### 题解\n从源点向每个意愿反对的人连边，从每个意愿赞成的人向汇点连边，「好朋友」之间连单向边，容量均为 $ 1 $。最小割即为答案。\n\n对于一条增广路 $ S - u - v - T $，$ u $ 意愿反对，$ v $ 意愿赞成。如果割掉中间 $ u - v $ 的边，表示 $ u $ 和 $ v $ 分别按照自己的意愿投票，两个人之间冲突，代价 $ +1 $。如果割掉 $ S - u $ 或 $ v - T $，表示 $ u $ 或 $ v $ 不按照自己的意愿，自身发生冲突，代价 $ +1 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->e; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\t// printf(\"[%d, %d, %d, %d]\\n\", s, t, c, rc);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) {\n\t\t\taddEdge(s, i, 1);\n\t\t} else {\n\t\t\taddEdge(i, t, 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v, 1, 1);\n\t}\n\n\tint maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/shoi2007-vote.md","raw":"title: 「SHOI2007」善意的投票 - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: shoi2007-vote\ndate: 2016-06-21 15:04:00\n---\n\n幼儿园里有 $ n $ 个小朋友打算通过投票来决定睡不睡午觉。他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。每位小朋友应该怎样投票，才能使冲突数最小？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1934](http://www.lydsy.com/JudgeOnline/problem.php?id=1934)\n\n### 题解\n从源点向每个意愿反对的人连边，从每个意愿赞成的人向汇点连边，「好朋友」之间连单向边，容量均为 $ 1 $。最小割即为答案。\n\n对于一条增广路 $ S - u - v - T $，$ u $ 意愿反对，$ v $ 意愿赞成。如果割掉中间 $ u - v $ 的边，表示 $ u $ 和 $ v $ 分别按照自己的意愿投票，两个人之间冲突，代价 $ +1 $。如果割掉 $ S - u $ 或 $ v - T $，表示 $ u $ 或 $ v $ 不按照自己的意愿，自身发生冲突，代价 $ +1 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->e; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\t// printf(\"[%d, %d, %d, %d]\\n\", s, t, c, rc);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) {\n\t\t\taddEdge(s, i, 1);\n\t\t} else {\n\t\t\taddEdge(i, t, 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v, 1, 1);\n\t}\n\n\tint maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"shoi2007-vote","published":1,"updated":"2016-06-21T07:04:25.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9red00a6ooxldbfoe8ph"},{"title":"「SHOI2007」园丁的烦恼 - CDQ","date":"2016-06-25T02:54:00.000Z","_content":"\n每一棵树可以用一个整数坐标来表示，每次询问你某一个矩阵内有多少树。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1935](http://www.lydsy.com/JudgeOnline/problem.php?id=1935)\n\n### 题解\n同 [BZOJ 1176](bzoj-1176)。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 10000000;\n\nstruct Triple {\n\tint x, y, *ans, k;\n\n\tTriple() {}\n\tTriple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {}\n} a[MAXN + MAXM * 4];\n\nint max = 0;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t// printf(\"sum[1, %d] = %d\\n\", x, ans);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\t// printf(\"a[%d] += %d\\n\", x, delta);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\t// printf(\"a[%d] = 0\\n\", x);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\nvoid cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM * 4];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\t// printf(\"ans += %d\\n\", bit.query(q->y) * q->k);\n\t\t\tif (q->ans) *q->ans += bit.query(q->y) * q->k;\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y), a[i].x += 2, a[i].y += 2;\n\t\tmax = std::max(max, a[i].y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint cnt = n;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2;\n\t\tint *p = &ans[i];\n\n\t\ta[cnt++] = Triple(x2, y2, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y2, p, -1);\n\t\ta[cnt++] = Triple(x2, y1 - 1, p, -1);\n\n\t\tmax = std::max(max, y1);\n\t\tmax = std::max(max, y2);\n\t}\n\n\t// for (int i = 0; i < cnt; i++) {\n\t// \tif (a[i].ans) printf(\"Query [%d, %d] for ans[%ld]\\n\", a[i].x, a[i].y, a[i].ans - ans);\n\t// \telse printf(\"Update [%d, %d] = 1\\n\", a[i].x, a[i].y);\n\t// }\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/shoi2007-tree.md","raw":"title: 「SHOI2007」园丁的烦恼 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - 数据结构\n  - CDQ\n  - 树状数组\n  - 分治\npermalink: shoi2007-tree\ndate: 2016-06-25 10:54:00\n---\n\n每一棵树可以用一个整数坐标来表示，每次询问你某一个矩阵内有多少树。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1935](http://www.lydsy.com/JudgeOnline/problem.php?id=1935)\n\n### 题解\n同 [BZOJ 1176](bzoj-1176)。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 10000000;\n\nstruct Triple {\n\tint x, y, *ans, k;\n\n\tTriple() {}\n\tTriple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {}\n} a[MAXN + MAXM * 4];\n\nint max = 0;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t// printf(\"sum[1, %d] = %d\\n\", x, ans);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\t// printf(\"a[%d] += %d\\n\", x, delta);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\t// printf(\"a[%d] = 0\\n\", x);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\nvoid cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM * 4];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\t// printf(\"ans += %d\\n\", bit.query(q->y) * q->k);\n\t\t\tif (q->ans) *q->ans += bit.query(q->y) * q->k;\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y), a[i].x += 2, a[i].y += 2;\n\t\tmax = std::max(max, a[i].y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint cnt = n;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2;\n\t\tint *p = &ans[i];\n\n\t\ta[cnt++] = Triple(x2, y2, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y2, p, -1);\n\t\ta[cnt++] = Triple(x2, y1 - 1, p, -1);\n\n\t\tmax = std::max(max, y1);\n\t\tmax = std::max(max, y2);\n\t}\n\n\t// for (int i = 0; i < cnt; i++) {\n\t// \tif (a[i].ans) printf(\"Query [%d, %d] for ans[%ld]\\n\", a[i].x, a[i].y, a[i].ans - ans);\n\t// \telse printf(\"Update [%d, %d] = 1\\n\", a[i].x, a[i].y);\n\t// }\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"shoi2007-tree","published":1,"updated":"2016-06-25T03:07:53.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9reh00adooxl81or26s2"},{"title":"「SDOI2016」储能表 - 二进制","date":"2016-04-18T09:06:53.000Z","_content":"\n有一个 $ n $ 行 $ m $ 列的表格，行从 $ 0 $ 到 $ n - 1 $ 编号，列从 $ 0 $ 到 $ m - 1 $ 编号。  \n每个格子都储存着能量。最初，第 $ i $ 行第 $ j $ 列的格子储存着 $ (i \\ {\\rm xor} \\ j) $ 点能量。所以，整个表格储存的总能量是，\n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n随着时间的推移，格子中的能量会渐渐减少。一个时间单位，每个格子中的能量都会减少 $ 1 $。显然，一个格子的能量减少到 $ 0 $ 之后就不会再减少了。  \n也就是说，$ k $ 个时间单位后，整个表格储存的总能量是，\n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n给出一个表格，求 $ k $ 个时间单位后它储存的总能量。  \n由于总能量可能较大，输出时对 $ p $ 取模。\n\n<!-- more -->\n\n### 链接\n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### 题解\n正解是数位 DP …… 这里讲一种乱搞做法 ……\n\n考虑异或的性质：\n\n性质一：对于任意 $ x < 2 ^ N $，$ y < 2 ^ N $，必有 $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n> 证明：之前两个数的从低到高第 $ N $ 位均为 $ 0 $，现在均为 $ 1 $，异或后结果不变。\n\n性质二：对于任意 $ x \\neq y $，必有 $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n> 证明：反证法，假设 $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $，则有 $ x \\ {\\rm xor} \\ a = z $、$ y \\ {\\rm xor} \\ a = z $，即 $ x = y $，与题设矛盾。\n\n性质三：对于任意 $ x < 2 ^ N $，$ [0, 2 ^ N - 1] $ 的所有数与 $ x $ 的异或所得结果取遍 $ [0, 2 ^ N - 1] $ 的所有数。\n\n> 证明：显然，有性质 2 可知这些数互不相同，并且二进制最多有 $ N $ 位，不可能大于等于 $ 2 ^ N $，即这 $ 2 ^ N - 1 $ 个互不相同的数都在 $ [0, 2 ^ N - 1] $ 内。\n\n设 $ n > m $，为方便阅读，$ n $ 表示列数，$ m $ 表示行数。\n\n打表找规律，先从最简单的开始搞。不考虑 $ k $，当 $ n = m = 2 ^ N $（$ N = 3 $）时，结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n可以看到，整个矩阵的每一行包含了 $ [0, 2 ^ N - 1] $ 的所有数字。直接使用等差数列求和公式计算即可。\n\n稍复杂的情况，设 $ N = \\lfloor \\log_2 n \\rfloor $，$ M = \\lfloor \\log_2 m \\rfloor $。当 $ N = M $ 时，打表结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n左上角的黑色部分可以直接规约到第一种情况。红色的部分中，参与异或运算的一个数多了一个二进制位，根据性质三，这一部分能取到 $ [2 ^ N, 2 ^ N + 2 ^ M - 1] $ 的所有数。绿色部分同理。\n\n对于黄色部分，相当于去掉了 $ n $ 和 $ m $ 的最高位后的一个子问题，递归计算即可。\n\n更复杂的情况，当 $ N > M $（因为 $ n > m $ 所以不可能存在 $ N < M $）时，打表结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n由性质三得，左边黑色部分取遍了 $ [0, 2 ^ N - 1] $，可用等差数列求和公式直接计算，右边部分都大于等于 $ 2 ^ N $，将它们同时减去 $ 2 ^ N $ 后即为 $ N = M $ 的情况，递归处理后为每个数加上 $ 2 ^ N $ 即可。\n\n现在考虑 $ k $ 对结果的影响，我们在计算一个等差数列 $ 0, 1, 2, 3, … n $ 时，前面所有 $ \\leq k $ 的项都会变成 $ 0 $，后面所有项减去 $ k $，相当于一个以 $ 1 $ 开始，长度为 $ n - k $ 的等差数列，代入公式即可。\n\n对于最后一种情况的递归，需要在 $ k $ 中将 $ n $ 的最高位去掉。最后为每个数加上时，对每个数的增量减去 $ k $ 即可。\n\n每次递归时，会去掉 $ n $ 二进制最高位上的 $ 1 $，其他的计算都可以在常数时间内完成，总时间复杂度为 $ O(T \\log (\\max(n, m))) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-table.md","raw":"title: 「SDOI2016」储能表 - 二进制\ndate: 2016-04-18 17:06:53\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - 二进制\n  - 异或\n  - 位运算\npermalink: sdoi2016-table\n---\n\n有一个 $ n $ 行 $ m $ 列的表格，行从 $ 0 $ 到 $ n - 1 $ 编号，列从 $ 0 $ 到 $ m - 1 $ 编号。  \n每个格子都储存着能量。最初，第 $ i $ 行第 $ j $ 列的格子储存着 $ (i \\ {\\rm xor} \\ j) $ 点能量。所以，整个表格储存的总能量是，\n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n随着时间的推移，格子中的能量会渐渐减少。一个时间单位，每个格子中的能量都会减少 $ 1 $。显然，一个格子的能量减少到 $ 0 $ 之后就不会再减少了。  \n也就是说，$ k $ 个时间单位后，整个表格储存的总能量是，\n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n给出一个表格，求 $ k $ 个时间单位后它储存的总能量。  \n由于总能量可能较大，输出时对 $ p $ 取模。\n\n<!-- more -->\n\n### 链接\n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### 题解\n正解是数位 DP …… 这里讲一种乱搞做法 ……\n\n考虑异或的性质：\n\n性质一：对于任意 $ x < 2 ^ N $，$ y < 2 ^ N $，必有 $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n> 证明：之前两个数的从低到高第 $ N $ 位均为 $ 0 $，现在均为 $ 1 $，异或后结果不变。\n\n性质二：对于任意 $ x \\neq y $，必有 $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n> 证明：反证法，假设 $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $，则有 $ x \\ {\\rm xor} \\ a = z $、$ y \\ {\\rm xor} \\ a = z $，即 $ x = y $，与题设矛盾。\n\n性质三：对于任意 $ x < 2 ^ N $，$ [0, 2 ^ N - 1] $ 的所有数与 $ x $ 的异或所得结果取遍 $ [0, 2 ^ N - 1] $ 的所有数。\n\n> 证明：显然，有性质 2 可知这些数互不相同，并且二进制最多有 $ N $ 位，不可能大于等于 $ 2 ^ N $，即这 $ 2 ^ N - 1 $ 个互不相同的数都在 $ [0, 2 ^ N - 1] $ 内。\n\n设 $ n > m $，为方便阅读，$ n $ 表示列数，$ m $ 表示行数。\n\n打表找规律，先从最简单的开始搞。不考虑 $ k $，当 $ n = m = 2 ^ N $（$ N = 3 $）时，结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n可以看到，整个矩阵的每一行包含了 $ [0, 2 ^ N - 1] $ 的所有数字。直接使用等差数列求和公式计算即可。\n\n稍复杂的情况，设 $ N = \\lfloor \\log_2 n \\rfloor $，$ M = \\lfloor \\log_2 m \\rfloor $。当 $ N = M $ 时，打表结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n左上角的黑色部分可以直接规约到第一种情况。红色的部分中，参与异或运算的一个数多了一个二进制位，根据性质三，这一部分能取到 $ [2 ^ N, 2 ^ N + 2 ^ M - 1] $ 的所有数。绿色部分同理。\n\n对于黄色部分，相当于去掉了 $ n $ 和 $ m $ 的最高位后的一个子问题，递归计算即可。\n\n更复杂的情况，当 $ N > M $（因为 $ n > m $ 所以不可能存在 $ N < M $）时，打表结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n由性质三得，左边黑色部分取遍了 $ [0, 2 ^ N - 1] $，可用等差数列求和公式直接计算，右边部分都大于等于 $ 2 ^ N $，将它们同时减去 $ 2 ^ N $ 后即为 $ N = M $ 的情况，递归处理后为每个数加上 $ 2 ^ N $ 即可。\n\n现在考虑 $ k $ 对结果的影响，我们在计算一个等差数列 $ 0, 1, 2, 3, … n $ 时，前面所有 $ \\leq k $ 的项都会变成 $ 0 $，后面所有项减去 $ k $，相当于一个以 $ 1 $ 开始，长度为 $ n - k $ 的等差数列，代入公式即可。\n\n对于最后一种情况的递归，需要在 $ k $ 中将 $ n $ 的最高位去掉。最后为每个数加上时，对每个数的增量减去 $ k $ 即可。\n\n每次递归时，会去掉 $ n $ 二进制最高位上的 $ 1 $，其他的计算都可以在常数时间内完成，总时间复杂度为 $ O(T \\log (\\max(n, m))) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-table","published":1,"updated":"2016-09-10T05:54:16.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rem00anooxl0p5xvvaj"},{"title":"SDOI2016 Round1 行纪","date":"2016-04-09T13:59:32.000Z","_content":"\n第一次参加省选，感觉还是要写点什么比较好吧，哪怕记记流水账 ……\n\n<!-- more -->\n\n### Day 0\n早上，火车到了济南，打电话问了问老师要坐哪路公交车 …… 到了酒店开了房，感觉还不错 …… 然而老师要到下午才能赶过来 ……\n\n下午正睡觉，老师给我打电话说让我赶紧过去 …… 报道啊啊啊啊 ……\n\n坐公交车去了山师报道 …… 考场在山师**附中** ……\n\n路不远这两天不用坐车了吧，走着也没关系诶 ……\n\n下午回去调了道费用流，练练 EK 模板 ……\n\n晚上去超市买了两个士力架，两盒牛奶，一块香皂 ……\n\n回酒店我竟然记得路！果然自己一个人出来一趟学会了认路的技能吗 QwQ ……\n\n晚上调了一道组合数学，还是 yts1999 出的题，%%%！\n\n睡觉睡不着，又用手机上 Blog 看了看模板 ……\n\n### Day 1\n早上大约七点半到了考点，抽了号 ……  \n早就知道这里的电脑是 XP 系统，还好之前集训时熟悉的 Windows 下的操作 ……  \n7:59 准时发题，和 WC 一样是纸质的 ……\n\n喝水看题 ……\n\n第一题：异或？异或有什么性质来着？难道是线性基？肯定不是啊喂 …… 看这样子像个 DP？打个表找找规律吧 ……  \n30min 过去了 ……  \n…… 然而并没有什么规律，打好 20 分暴力放在一边 ……\n\n第二题：一个数是另一个数的约数 …… 一个数除以另一个数是质数 …… 等等！数据这么大怎么判断质数！Miller – Rabin 我不会啊啊啊啊 ……  \n写个线性筛 + 试除吧 ……  \n匹配？收益大于等于零？看起来像是要二分的样子。跑费用流？等等！这是不是二分图啊！  \npapapa 敲了个二分图染色，跑了 $ 1000 \\times 1000 $ 的数据发现是二分图 …… 虽然不会证就当它是吧反正我不会带花树再说了带花树 $ O((n + m) ^ 3) $ 也过不了啊喂！  \n建图还是要先二分图染色再重建的 …… 常数会不会太大？算了就这样吧 …… 几分钟敲了个 EK 模板，还好昨天刚敲过 ……  \n一个半小时（具体时间记不清了）后样例过了 ……  \n写对拍 ……  \n诶这暴力咋写？  \n把每个数拆成 $ b_i $ 个数搞，复杂度爆炸但是对拍足够了吧 ……  \n半个小时后开始对拍 ……  \n`Wrong Answer on Test #7`？md 暴力写错了 …… 滚去改  \n`Wrong Answer on Test #13`？md 又是暴力写错了 …… 滚去改  \n然后就是一堆 `Accepted` ……  先放在那里吧 ……\n\n第三题：树？！我会树剖！  \n这标记是什么鬼 …… 根本不会啊 …… 难道是 SegmentTree Beats？ 先打个暴力吧 ……  \n每次询问一遍 BFS 相当的暴力，嗯样例能过 ……  \n部分分有 $ a = 0 $ 的点，写个树剖吧 ……  \n……  \n十一点半了 ……  树剖写完了，赶紧对拍 ……  \n`Wrong Answer on Test #18`？缩小数据范围试试 …… 该不会暴力又写错了吧 ……  \n`Wrong Answer on Test #32` …… 数据范围够小了手算下 …… 嗯我的树剖写错了 ……  \nmd 这线段树什么鬼 …… 改线段树 ……  \nmd 我的树剖根本没有计算出 `size` 啊怎么剖出来的 ……  \n`s.top()` 接着 `s.pop()` 蛤？……  \n改完树剖已经 12:40 了 …… 对拍终于不出错了 ……\n\n回去看 T2 …… maya 忘了写静态内存了 …… 改改改 ……  \nT2 复杂度有点大？就当他是 $ O( $ 跑得出 $ ) $ 吧 …… 来组 $ n = 200 $ 试试 ……  \n答案好几万，跑了 1.5s ……  \n啊啊啊啊啊啊啊啊啊怎么办来不及优化了啊 ……  \n算了，T 就 T 吧 …… 回去检查检查文件 ……\n\n下午知道了成绩，140，rank9，还算可以吧 ……\n\nheheda AK 了！  \nstd rank2！\n\n……\n\n感觉明天要考字符串、反演、法法塔之类的 …… 啥都不会，药丸啊 …… 晚上赶紧写了个 KMP 模板 …… 也许明天打暴力用得到？\n\n其实，Day1 成绩好未必是一件好事？起点越高，失败后便摔得越惨吧。  \n但愿 Day2 不会滚粗。\n\n### Day 2\n今天不用抽号了，去的晚一点没关系 …… 7:50 进了考场\n\nwow 昨天的目录还在，不用重新写对拍了诶 ……\n\n7:57 准时发题 ……\n\n喝水看题 ……\n\n第一题：maya这不是集训原题的弱化版吗！完了我不会啊啊啊啊怎么办，暴力后缀数组能有 60 分啊啊啊啊，他们肯定至少能写出来 60 分啊啊啊啊，今天注定滚粗了啊啊啊啊啊  \n先打个 30 分暴力吧，`std::set< std::vector<int> >` 够暴力吧 ……  \n\n第二题：maya计数问题！前段时间写过不少类似的题吧，推推式子看 …… 我们先来求没有稳定数的排列数 …… 然后至少一个稳定的排列数量 …… 诶这个好像要容斥？  \n二十分钟后，脑海里一片空白 …… 这种题他们肯定都会啊，我怎么就是想不出来啊啊啊啊，第一题怎么办 ……  \n先打个 10 分暴力吧 …… $ O(n!) $ 枚举全排列 ……\n\n第三题：好像是个 DP？10 分可以爆搜？$ O(n ^ 3) $ 的划分 DP 可以 30 分？不管了，先回去想想第一题吧 …… 也许还有希望 ……\n\n嗯 …… 后缀数组，先用 `std::sort` 写个暴力后缀数组再说 ……  \n好像求出 `height` 可以统计子串数？让我想想 …… `height` 表示排名相邻两个后缀的最长公共前缀长度 …… 这个好像可以线性递推？不管了，写个暴力吧 ……\n\n于是我有了一个 $ O(n ^ 2 \\log n + n ^ 2) $ 的后缀数组 ……\n\n让我想想，每个后缀对答案的贡献是 ……\n\n1.5h 过去了，终于把暴力后缀数组写完，暴力求 `height` 写完，统计子串数量写完 ……\n\n手敲了一组大数据，答案和暴力结果一样，感觉推导的应该没问题 ……\n\n$ O(n ^ 2) $ 求 `height` 明显复杂度太高吧？让我想想怎么线性递推 ……  \n对于某个后缀的 `height`，当这个后缀与前一个后缀的首个字符相等时，结果为后一个字符所对应后缀的 `height + 1`，否则为 0 ……  \n用 `\"heheda\"` 作为例子手算了一下，感觉没问题 ……  \n恩好像没问题，就这样写吧 ……  \n实在不知道递推顺序，就记忆搜索吧 ……  \n\n嗯，让我想想后缀数组复杂度能不能降一降，写个倍增试试？\n\n倍增的框架敲上了，想想怎么基数排序来着 …… 怎么基数排序来着 ……  \n将近半个小时过去了，还是没想到怎么基数排序 ……  \n算了吧，直接丢给 `std::sort` 做双关键字吧！\n\n于是我的后缀数组变成了 $ O(n \\log n \\log n + n) $ ……\n\n让我再试组数据 …… 啊啊啊啊啊怎么和暴力结果不一样啊！！！  \n后缀数组把倍增换成原来的暴力排序，结果还是不对 ……  \n难道是 `height` 求错了？  \n改成原来的平方暴力 ……  \n嗯，好像是对的 ……  \nmaya我递推式推错了 …… 怎么办怎么办怎么办！\n\n看了看时间已经十一点半多了 ……  \n算了吧，换成平方暴力！\n\n后缀数组的复杂度定格为 $ O(n \\log n \\log n + n ^ 2) $ ……  \n瓶颈依然是 `height` 的平方 …… 药丸 ……  \n\n赶紧写第三题！  \n乘上一个整数表示方差？看来要维护两个信息啊 …… 和的平方与平方的和 …… 啥玩意 …… 还是记忆搜索吧 ……\n\n写完自认为能有 30 分的 DP 之后已经 12:40 了 ……  \n赶紧测测样例，maya样例不过啊 ……  \n输出中间结果试试 …… maya除不开啊 ……  \n一定是我式子推错了吧 ……  \n赶紧换成 `double` 就算精度炸了说不定还有希望啊 ……  \n恩就这样吧 …… 样例总算过了 ……  \n\n12:50，赶紧检查一下前两题，文件输入输出写好 …… 关文件 …… 调试代码去掉 ……  \nmaya第二题的表打错了啊啊啊赶紧重新打 ……  \n\n13:00 结束 …… 深感药丸 ……\n\n听讲题 ……\n\nDay1 T1 数位DP？  \nT2 好像我的做法不是正解？正解没有二分 …… 怪不得跑这么慢 ……  \nT3 有点类似超哥线段树的东西？不懂啊 Orz\n\nDay2 T1 后缀自动机裸题？后缀数组搞一搞就好？  \n唉后悔没学后缀数组了 ……  \nT2 叫什么错位排列？maya我就剩一点容斥就能推出 60 分做法了啊啊啊啊啊 ……  \nT3 斜率优化？好像我暴力的式子也推错了 …… 爆零啦 ……  \n\n成绩出来了 …… 90 分滚粗 …… 直接掉到 60 多名了 ……\n\n果然 Day1 的 Flag 生效了？\n\n下午坐火车走了，晚上回到了临沂 ……\n","source":"_posts/sdoi2016-round1.md","raw":"title: SDOI2016 Round1 行纪\ncategories: \n  - Diary\npermalink: sdoi2016-round1\ndate: 2016-04-09 21:59:32\n---\n\n第一次参加省选，感觉还是要写点什么比较好吧，哪怕记记流水账 ……\n\n<!-- more -->\n\n### Day 0\n早上，火车到了济南，打电话问了问老师要坐哪路公交车 …… 到了酒店开了房，感觉还不错 …… 然而老师要到下午才能赶过来 ……\n\n下午正睡觉，老师给我打电话说让我赶紧过去 …… 报道啊啊啊啊 ……\n\n坐公交车去了山师报道 …… 考场在山师**附中** ……\n\n路不远这两天不用坐车了吧，走着也没关系诶 ……\n\n下午回去调了道费用流，练练 EK 模板 ……\n\n晚上去超市买了两个士力架，两盒牛奶，一块香皂 ……\n\n回酒店我竟然记得路！果然自己一个人出来一趟学会了认路的技能吗 QwQ ……\n\n晚上调了一道组合数学，还是 yts1999 出的题，%%%！\n\n睡觉睡不着，又用手机上 Blog 看了看模板 ……\n\n### Day 1\n早上大约七点半到了考点，抽了号 ……  \n早就知道这里的电脑是 XP 系统，还好之前集训时熟悉的 Windows 下的操作 ……  \n7:59 准时发题，和 WC 一样是纸质的 ……\n\n喝水看题 ……\n\n第一题：异或？异或有什么性质来着？难道是线性基？肯定不是啊喂 …… 看这样子像个 DP？打个表找找规律吧 ……  \n30min 过去了 ……  \n…… 然而并没有什么规律，打好 20 分暴力放在一边 ……\n\n第二题：一个数是另一个数的约数 …… 一个数除以另一个数是质数 …… 等等！数据这么大怎么判断质数！Miller – Rabin 我不会啊啊啊啊 ……  \n写个线性筛 + 试除吧 ……  \n匹配？收益大于等于零？看起来像是要二分的样子。跑费用流？等等！这是不是二分图啊！  \npapapa 敲了个二分图染色，跑了 $ 1000 \\times 1000 $ 的数据发现是二分图 …… 虽然不会证就当它是吧反正我不会带花树再说了带花树 $ O((n + m) ^ 3) $ 也过不了啊喂！  \n建图还是要先二分图染色再重建的 …… 常数会不会太大？算了就这样吧 …… 几分钟敲了个 EK 模板，还好昨天刚敲过 ……  \n一个半小时（具体时间记不清了）后样例过了 ……  \n写对拍 ……  \n诶这暴力咋写？  \n把每个数拆成 $ b_i $ 个数搞，复杂度爆炸但是对拍足够了吧 ……  \n半个小时后开始对拍 ……  \n`Wrong Answer on Test #7`？md 暴力写错了 …… 滚去改  \n`Wrong Answer on Test #13`？md 又是暴力写错了 …… 滚去改  \n然后就是一堆 `Accepted` ……  先放在那里吧 ……\n\n第三题：树？！我会树剖！  \n这标记是什么鬼 …… 根本不会啊 …… 难道是 SegmentTree Beats？ 先打个暴力吧 ……  \n每次询问一遍 BFS 相当的暴力，嗯样例能过 ……  \n部分分有 $ a = 0 $ 的点，写个树剖吧 ……  \n……  \n十一点半了 ……  树剖写完了，赶紧对拍 ……  \n`Wrong Answer on Test #18`？缩小数据范围试试 …… 该不会暴力又写错了吧 ……  \n`Wrong Answer on Test #32` …… 数据范围够小了手算下 …… 嗯我的树剖写错了 ……  \nmd 这线段树什么鬼 …… 改线段树 ……  \nmd 我的树剖根本没有计算出 `size` 啊怎么剖出来的 ……  \n`s.top()` 接着 `s.pop()` 蛤？……  \n改完树剖已经 12:40 了 …… 对拍终于不出错了 ……\n\n回去看 T2 …… maya 忘了写静态内存了 …… 改改改 ……  \nT2 复杂度有点大？就当他是 $ O( $ 跑得出 $ ) $ 吧 …… 来组 $ n = 200 $ 试试 ……  \n答案好几万，跑了 1.5s ……  \n啊啊啊啊啊啊啊啊啊怎么办来不及优化了啊 ……  \n算了，T 就 T 吧 …… 回去检查检查文件 ……\n\n下午知道了成绩，140，rank9，还算可以吧 ……\n\nheheda AK 了！  \nstd rank2！\n\n……\n\n感觉明天要考字符串、反演、法法塔之类的 …… 啥都不会，药丸啊 …… 晚上赶紧写了个 KMP 模板 …… 也许明天打暴力用得到？\n\n其实，Day1 成绩好未必是一件好事？起点越高，失败后便摔得越惨吧。  \n但愿 Day2 不会滚粗。\n\n### Day 2\n今天不用抽号了，去的晚一点没关系 …… 7:50 进了考场\n\nwow 昨天的目录还在，不用重新写对拍了诶 ……\n\n7:57 准时发题 ……\n\n喝水看题 ……\n\n第一题：maya这不是集训原题的弱化版吗！完了我不会啊啊啊啊怎么办，暴力后缀数组能有 60 分啊啊啊啊，他们肯定至少能写出来 60 分啊啊啊啊，今天注定滚粗了啊啊啊啊啊  \n先打个 30 分暴力吧，`std::set< std::vector<int> >` 够暴力吧 ……  \n\n第二题：maya计数问题！前段时间写过不少类似的题吧，推推式子看 …… 我们先来求没有稳定数的排列数 …… 然后至少一个稳定的排列数量 …… 诶这个好像要容斥？  \n二十分钟后，脑海里一片空白 …… 这种题他们肯定都会啊，我怎么就是想不出来啊啊啊啊，第一题怎么办 ……  \n先打个 10 分暴力吧 …… $ O(n!) $ 枚举全排列 ……\n\n第三题：好像是个 DP？10 分可以爆搜？$ O(n ^ 3) $ 的划分 DP 可以 30 分？不管了，先回去想想第一题吧 …… 也许还有希望 ……\n\n嗯 …… 后缀数组，先用 `std::sort` 写个暴力后缀数组再说 ……  \n好像求出 `height` 可以统计子串数？让我想想 …… `height` 表示排名相邻两个后缀的最长公共前缀长度 …… 这个好像可以线性递推？不管了，写个暴力吧 ……\n\n于是我有了一个 $ O(n ^ 2 \\log n + n ^ 2) $ 的后缀数组 ……\n\n让我想想，每个后缀对答案的贡献是 ……\n\n1.5h 过去了，终于把暴力后缀数组写完，暴力求 `height` 写完，统计子串数量写完 ……\n\n手敲了一组大数据，答案和暴力结果一样，感觉推导的应该没问题 ……\n\n$ O(n ^ 2) $ 求 `height` 明显复杂度太高吧？让我想想怎么线性递推 ……  \n对于某个后缀的 `height`，当这个后缀与前一个后缀的首个字符相等时，结果为后一个字符所对应后缀的 `height + 1`，否则为 0 ……  \n用 `\"heheda\"` 作为例子手算了一下，感觉没问题 ……  \n恩好像没问题，就这样写吧 ……  \n实在不知道递推顺序，就记忆搜索吧 ……  \n\n嗯，让我想想后缀数组复杂度能不能降一降，写个倍增试试？\n\n倍增的框架敲上了，想想怎么基数排序来着 …… 怎么基数排序来着 ……  \n将近半个小时过去了，还是没想到怎么基数排序 ……  \n算了吧，直接丢给 `std::sort` 做双关键字吧！\n\n于是我的后缀数组变成了 $ O(n \\log n \\log n + n) $ ……\n\n让我再试组数据 …… 啊啊啊啊啊怎么和暴力结果不一样啊！！！  \n后缀数组把倍增换成原来的暴力排序，结果还是不对 ……  \n难道是 `height` 求错了？  \n改成原来的平方暴力 ……  \n嗯，好像是对的 ……  \nmaya我递推式推错了 …… 怎么办怎么办怎么办！\n\n看了看时间已经十一点半多了 ……  \n算了吧，换成平方暴力！\n\n后缀数组的复杂度定格为 $ O(n \\log n \\log n + n ^ 2) $ ……  \n瓶颈依然是 `height` 的平方 …… 药丸 ……  \n\n赶紧写第三题！  \n乘上一个整数表示方差？看来要维护两个信息啊 …… 和的平方与平方的和 …… 啥玩意 …… 还是记忆搜索吧 ……\n\n写完自认为能有 30 分的 DP 之后已经 12:40 了 ……  \n赶紧测测样例，maya样例不过啊 ……  \n输出中间结果试试 …… maya除不开啊 ……  \n一定是我式子推错了吧 ……  \n赶紧换成 `double` 就算精度炸了说不定还有希望啊 ……  \n恩就这样吧 …… 样例总算过了 ……  \n\n12:50，赶紧检查一下前两题，文件输入输出写好 …… 关文件 …… 调试代码去掉 ……  \nmaya第二题的表打错了啊啊啊赶紧重新打 ……  \n\n13:00 结束 …… 深感药丸 ……\n\n听讲题 ……\n\nDay1 T1 数位DP？  \nT2 好像我的做法不是正解？正解没有二分 …… 怪不得跑这么慢 ……  \nT3 有点类似超哥线段树的东西？不懂啊 Orz\n\nDay2 T1 后缀自动机裸题？后缀数组搞一搞就好？  \n唉后悔没学后缀数组了 ……  \nT2 叫什么错位排列？maya我就剩一点容斥就能推出 60 分做法了啊啊啊啊啊 ……  \nT3 斜率优化？好像我暴力的式子也推错了 …… 爆零啦 ……  \n\n成绩出来了 …… 90 分滚粗 …… 直接掉到 60 多名了 ……\n\n果然 Day1 的 Flag 生效了？\n\n下午坐火车走了，晚上回到了临沂 ……\n","slug":"sdoi2016-round1","published":1,"updated":"2016-11-20T15:49:24.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9req00azooxln3o0605f"},{"title":"「SDOI2016」排列计数 - 组合数学 + 错位排列","date":"2016-04-13T03:45:13.000Z","_content":"\n求有多少种长度为 $ n $ 的序列 $ A $，满足以下条件：\n\n* $ 1 $ ~ $ n $ 这 $ n $ 个数在序列中各出现了一次\n* 若第 $ i $ 个数 $ A[i] $ 的值为 $ i $，则称 $ i $ 是稳定的。序列恰好有 $ m $ 个数是稳定的\n\n满足条件的序列可能很多，序列数对 $ 10 ^ 9 + 7 $ 取模。\n\n<!-- more -->\n\n### 链接\n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### 题解\n根据条件一，我们得知这是一个全排列。\n\n对于条件二，我们可以先从 $ n $ 个数中选出 $ m $ 个，使它们的值是稳定的，然后使剩下的 $ n - m $ 全部错位排列。\n\n设 $ f(i) $ 表示长度为 i 的序列的错位排列数，答案即为\n\n$$ C(n, m) * f(n - m) $$\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-permutation.md","raw":"title: 「SDOI2016」排列计数 - 组合数学 + 错位排列\ndate: 2016-04-13 11:45:13\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - 组合数学\n  - 数学\n  - 错位排列\n  - 组合数\npermalink: sdoi2016-permutation\n---\n\n求有多少种长度为 $ n $ 的序列 $ A $，满足以下条件：\n\n* $ 1 $ ~ $ n $ 这 $ n $ 个数在序列中各出现了一次\n* 若第 $ i $ 个数 $ A[i] $ 的值为 $ i $，则称 $ i $ 是稳定的。序列恰好有 $ m $ 个数是稳定的\n\n满足条件的序列可能很多，序列数对 $ 10 ^ 9 + 7 $ 取模。\n\n<!-- more -->\n\n### 链接\n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### 题解\n根据条件一，我们得知这是一个全排列。\n\n对于条件二，我们可以先从 $ n $ 个数中选出 $ m $ 个，使它们的值是稳定的，然后使剩下的 $ n - m $ 全部错位排列。\n\n设 $ f(i) $ 表示长度为 i 的序列的错位排列数，答案即为\n\n$$ C(n, m) * f(n - m) $$\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-permutation","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9res00b1ooxl1tynortw"},{"title":"「SDOI2016」数字配对 - 费用流","date":"2016-04-09T10:06:43.000Z","_content":"\n有 $ n $ 种数字，第 $ i $ 种数字是 $ a_i $、有 $ b_i $ 个，权值是 $ c_i $。\n\n若两个数字 $ a_i $、$ a_j $ 满足，$ a_i $ 是 $ a_j $ 的倍数，且 $ \\frac{a_i}{a_j} $ 是一个质数，那么这两个数字可以配对，并获得 $ c_i \\times c_j $ 的价值。\n\n一个数字只能参与一次配对，可以不参与配对。  \n在获得的价值总和不小于 $ 0 $ 的前提下，求最多进行多少次配对。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### 题解\n线性筛预处理质数（到 $ 10 ^ 6 $ 肯定够用了），用试除法判断质数，可以匹配的数字连边，做一遍二分图染色。\n\n源点到所有 $ X $ 点连边，容量为 $ b_i $ 费用为 $ 0 $；所有 $ Y $ 点向汇点连边，容量为 $ b_i $ 费用为 $ 0 $；可以匹配的数字从 $ X $ 点向 $ Y $ 点连边，容量为无穷大，费用为 $ -(c_i \\times c_j) $。\n\n先求出整张网络的最大流作为二分的上界。然后建立超级源点，并从超级源点向源点连边，二分这条边的容量，用费用流检验，如果费用 $ \\leq 0 $ 说明可行。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-pair.md","raw":"title: 「SDOI2016」数字配对 - 费用流\ndate: 2016-04-09 18:06:43\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - Edmonds-Karp\n  - 数论\n  - 素数判定\n  - 线性筛\n  - 网络流\n  - 费用流\n  - 二分答案\npermalink: sdoi2016-pair\n---\n\n有 $ n $ 种数字，第 $ i $ 种数字是 $ a_i $、有 $ b_i $ 个，权值是 $ c_i $。\n\n若两个数字 $ a_i $、$ a_j $ 满足，$ a_i $ 是 $ a_j $ 的倍数，且 $ \\frac{a_i}{a_j} $ 是一个质数，那么这两个数字可以配对，并获得 $ c_i \\times c_j $ 的价值。\n\n一个数字只能参与一次配对，可以不参与配对。  \n在获得的价值总和不小于 $ 0 $ 的前提下，求最多进行多少次配对。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### 题解\n线性筛预处理质数（到 $ 10 ^ 6 $ 肯定够用了），用试除法判断质数，可以匹配的数字连边，做一遍二分图染色。\n\n源点到所有 $ X $ 点连边，容量为 $ b_i $ 费用为 $ 0 $；所有 $ Y $ 点向汇点连边，容量为 $ b_i $ 费用为 $ 0 $；可以匹配的数字从 $ X $ 点向 $ Y $ 点连边，容量为无穷大，费用为 $ -(c_i \\times c_j) $。\n\n先求出整张网络的最大流作为二分的上界。然后建立超级源点，并从超级源点向源点连边，二分这条边的容量，用费用流检验，如果费用 $ \\leq 0 $ 说明可行。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-pair","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rev00bbooxlauiqllaa"},{"title":"「SDOI2016」征途 - 斜率优化 DP","date":"2016-04-17T14:46:04.000Z","_content":"\nPine 开始了从 $ S $ 地到 $ T $ 地的征途。  \n从 $ S $ 地到 $ T $ 地的路可以划分成 $ n $ 段，相邻两段路的分界点设有休息站。  \nPine 计划用 $ m $ 天到达 $ T $ 地。除第 $ m $ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。  \nPine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。  \n帮助 Pine 求出最小方差是多少。\n\n设方差是 $ v $，可以证明，$ v \\times m ^ 2 $ 是一个整数。为了避免精度误差，输出结果时输出 $ v \\times m ^ 2 $。\n\n<!-- more -->\n\n### 链接\n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### 题解\n设 $ a_i $ 为每一天的路程，$ S = \\sum\\limits_{i = 1} ^ n a_i $，题目要求即为最小化\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n将上式展开，整理得\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n因为 $ m $ 是个常数，$ S ^ 2 $ 是个常数，所以只要最小化\n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n即可\n\n设 $ f[j][i] $ 表示前 $ i $ 段路，分成 $ j $ 天的最优方案对应上式的值，则有\n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\n直接以这个式子进行划分DP，状态数为 $ O(nm) $，时间复杂度为 $ O(nm ^ 2) $，预计得分 60 分。\n\n尝试进行优化。首先，二维的状态存储，显然第一维是可以滚动的，设 $ g(i) = f[j - 1][i] $。考虑 $ k $ 的两个取值 $ k = a $ 和 $ k = b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n左边是一个斜率的式子，分子和分母都是单调的，右边也是单调的。使用一个单调队列来存储一些决策点，使得从前到后每一个决策点都比下一个决策点更优，需要满足的条件是：\n\n1. 较后面的一对点组成的斜率比较前面一对点大；\n2. 第 $ a $ 个点与第 $ b $ 个点（$ a > b $）组成的斜率大于 $ 2 s_i $（如果小于，说明较靠后的 $ a $ 点更优）。\n\n因为斜率是单调递增的，所以第 2 条只需要使前两个元素满足条件即可。\n\n枚举 $ i $，不需要枚举 $ k $，而是从单调队列中寻找最优决策点。首先检查队首元素，使其满足条件 2，此时队首即为最优解；然后将当前决策点作为新的 $ k $ 加入到队列尾部，需要先删除一些决策点使得条件 1 被满足。因为每个决策点最多会被添加、删除各一次，所以状态转移的代价为均摊 $ O(1) $，总时间复杂度降为 $ O(nm) $，可以通过本题。\n\n注意正无穷的取值，合理取值可以避免特判。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-journey.md","raw":"title: 「SDOI2016」征途 - 斜率优化 DP\ndate: 2016-04-17 22:46:04\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - DP\n  - 斜率优化\n  - 单调队列\npermalink: sdoi2016-journey\n---\n\nPine 开始了从 $ S $ 地到 $ T $ 地的征途。  \n从 $ S $ 地到 $ T $ 地的路可以划分成 $ n $ 段，相邻两段路的分界点设有休息站。  \nPine 计划用 $ m $ 天到达 $ T $ 地。除第 $ m $ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。  \nPine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。  \n帮助 Pine 求出最小方差是多少。\n\n设方差是 $ v $，可以证明，$ v \\times m ^ 2 $ 是一个整数。为了避免精度误差，输出结果时输出 $ v \\times m ^ 2 $。\n\n<!-- more -->\n\n### 链接\n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### 题解\n设 $ a_i $ 为每一天的路程，$ S = \\sum\\limits_{i = 1} ^ n a_i $，题目要求即为最小化\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n将上式展开，整理得\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n因为 $ m $ 是个常数，$ S ^ 2 $ 是个常数，所以只要最小化\n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n即可\n\n设 $ f[j][i] $ 表示前 $ i $ 段路，分成 $ j $ 天的最优方案对应上式的值，则有\n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\n直接以这个式子进行划分DP，状态数为 $ O(nm) $，时间复杂度为 $ O(nm ^ 2) $，预计得分 60 分。\n\n尝试进行优化。首先，二维的状态存储，显然第一维是可以滚动的，设 $ g(i) = f[j - 1][i] $。考虑 $ k $ 的两个取值 $ k = a $ 和 $ k = b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n左边是一个斜率的式子，分子和分母都是单调的，右边也是单调的。使用一个单调队列来存储一些决策点，使得从前到后每一个决策点都比下一个决策点更优，需要满足的条件是：\n\n1. 较后面的一对点组成的斜率比较前面一对点大；\n2. 第 $ a $ 个点与第 $ b $ 个点（$ a > b $）组成的斜率大于 $ 2 s_i $（如果小于，说明较靠后的 $ a $ 点更优）。\n\n因为斜率是单调递增的，所以第 2 条只需要使前两个元素满足条件即可。\n\n枚举 $ i $，不需要枚举 $ k $，而是从单调队列中寻找最优决策点。首先检查队首元素，使其满足条件 2，此时队首即为最优解；然后将当前决策点作为新的 $ k $ 加入到队列尾部，需要先删除一些决策点使得条件 1 被满足。因为每个决策点最多会被添加、删除各一次，所以状态转移的代价为均摊 $ O(1) $，总时间复杂度降为 $ O(nm) $，可以通过本题。\n\n注意正无穷的取值，合理取值可以避免特判。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-journey","published":1,"updated":"2016-10-24T23:29:40.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rf000bqooxlxoy869wq"},{"title":"「SDOI2016」生成魔咒 - 后缀数组","date":"2016-04-12T13:57:57.000Z","_content":"\n魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $ 1 $、$ 2 $ 拼凑起来形成一个魔咒串 $ [1, 2] $。  \n一个魔咒串 $ S $ 的非空字串被称为魔咒串 $ S $ 的生成魔咒。  \n例如 $ S = [1, 2, 1] $ 时，它的生成魔咒有 $ [1] $、$ [2] $、$ [1, 2] $、$ [2, 1] $、$ [1, 2, 1] $ 五种。$ S = [1, 1, 1] $ 时，它的生成魔咒有 $ [1] $、$ [1, 1] $、$ [1, 1, 1] $ 三种。  \n最初 $ S $ 为空串。共进行 $ n $ 次操作，每次操作是在 $ S $ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $ S $ 共有多少种生成魔咒。\n\n<!-- more -->\n\n### 链接\n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### 题解\n如果没有加入字符的操作，可以直接使用后缀数组的 $ {\\rm height} $ 计算。有了在结尾加入字符的操作，我们可以将整个串反转，变成在开头加入字符，这样相当于每次添加一个后缀。\n\n将操作离线，得到最终的串，对它建立后缀数组和稀疏表。\n\n用一个 `std::set` 维护当前已经被加入的后缀的排名，以方便查询当前加入的后缀的排名前、后一位的后缀。\n\n考虑每次加入一个新的后缀对答案的贡献。统计每个时刻串中的重复子串数量，设新加入的后缀为 $ i $，排在它前、后一位的后缀分别为 $ pred $、$ succ $。\n\n在加入之前，$ pred $、$ succ $ 的排名是相邻的，而现在不相邻了，需要减去它们的最长公共前缀长度。加入之后，$ pred $、$ succ $ 都与 $ i $ 相邻，需要加上它们的最长公共前缀长度。\n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n根据等差数列求和公式，长度为 $ i $ 的字符串的总子串数量为\n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n每次用总子串数量减去重复数量即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-incantation.md","raw":"title: 「SDOI2016」生成魔咒 - 后缀数组\ndate: 2016-04-12 21:57:57\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - 后缀数组\n  - 字符串\n  - RMQ\npermalink: sdoi2016-incantation\n---\n\n魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $ 1 $、$ 2 $ 拼凑起来形成一个魔咒串 $ [1, 2] $。  \n一个魔咒串 $ S $ 的非空字串被称为魔咒串 $ S $ 的生成魔咒。  \n例如 $ S = [1, 2, 1] $ 时，它的生成魔咒有 $ [1] $、$ [2] $、$ [1, 2] $、$ [2, 1] $、$ [1, 2, 1] $ 五种。$ S = [1, 1, 1] $ 时，它的生成魔咒有 $ [1] $、$ [1, 1] $、$ [1, 1, 1] $ 三种。  \n最初 $ S $ 为空串。共进行 $ n $ 次操作，每次操作是在 $ S $ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $ S $ 共有多少种生成魔咒。\n\n<!-- more -->\n\n### 链接\n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### 题解\n如果没有加入字符的操作，可以直接使用后缀数组的 $ {\\rm height} $ 计算。有了在结尾加入字符的操作，我们可以将整个串反转，变成在开头加入字符，这样相当于每次添加一个后缀。\n\n将操作离线，得到最终的串，对它建立后缀数组和稀疏表。\n\n用一个 `std::set` 维护当前已经被加入的后缀的排名，以方便查询当前加入的后缀的排名前、后一位的后缀。\n\n考虑每次加入一个新的后缀对答案的贡献。统计每个时刻串中的重复子串数量，设新加入的后缀为 $ i $，排在它前、后一位的后缀分别为 $ pred $、$ succ $。\n\n在加入之前，$ pred $、$ succ $ 的排名是相邻的，而现在不相邻了，需要减去它们的最长公共前缀长度。加入之后，$ pred $、$ succ $ 都与 $ i $ 相邻，需要加上它们的最长公共前缀长度。\n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n根据等差数列求和公式，长度为 $ i $ 的字符串的总子串数量为\n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n每次用总子串数量减去重复数量即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-incantation","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rf400byooxl5qvktlmq"},{"title":"「SDOI2016」游戏 - 树链剖分","date":"2016-04-15T14:25:55.000Z","_content":"\nAlice 和 Bob 在玩一个游戏。  \n游戏在一棵有 $ n $ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $ 123456789123456789 $。  \n有时，Alice 会选择一条从 $ s $ 到 $ t $ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $ r $，若 $ r $ 与 $ s $ 的距离是 $ dis $，那么 Alice 在点 $ r $ 上添加的数字是 $ a \\times dis + b $。  \n有时，Bob 会选择一条从 $ s $ 到 $ t $ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。  \nBob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### 题解\n首先，树链剖分，转化成链上的操作，使用线段树维护。\n\n对一条路径上的每个点添加一个数字，设 $ p = {\\rm LCA}(s, t) $ ，可以把这条路径分为两条链，即 $ s \\rightarrow p $、$ p \\rightarrow t $。\n\n![Tree](sdoi2016-game/tree.png)\n\n设 $ {\\rm dist}(u, v) $ 为 u、v 两点间距离，则左边一条路径上每一个点被赋的值为\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n注意到，后面的 $ a \\times {\\rm dist}(s, root) + b $ 是一个常数。\n\n右边的一条路径上每个点被赋的值为\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n同理，后面的 $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ 也是一个常数。\n\n这样，我们得到了两个直线的斜截式方程，问题转化为：在序列上给一段区间添加一条直线；求一段区间内所有直线方程带入 $ x $ 值后的最小 $ y $ 值。\n\n这个问题可以使用线段树解决，每个节点维护：\n\n1. 区间最小值；\n2. 在当前节点 `mid` （区间中点）处取得值最小的一条直线。\n\n因为所有叶子节点的 `mid` 构成了整条线段，所以这样维护一定可以取得最小值。\n\n注意到直线的方程这种标记是不能合并的，所以每当添加一条直线的时候，判断这条直线在区间左端点、区间中点、区间右端点处带入得到的值是否比原有直线更优。\n\n如果左右端点都取**不**到更优值，则中点一定取不到更优值，且子节点的中点（整个区间）都取不到更优值，因为一次函数的图像是单调的。此时直接舍弃新的直线即可。\n\n如果左右端点都能取到更优值，同理，中点一定能取到更优值，且子节点的中点（整个区间）都能取到更优值。此时直接更新舍弃旧的直线即可。\n\n其他的情况，均为左右端点之一能取到更优值。如果中点能取到更优值，可以将新旧直线互换，并将左右端点能否取到更优值取反。即转化为，只有左右端点之一能取到更优值。\n\n此时的两条直线图像是这样的（因为带入的横坐标是离散的，所以真实的情况并不一定是直线，此处便于理解画成直线）：\n\n![Line](sdoi2016-game/line.png)\n\n旧直线为浅色，新直线为深色。可以看出在左端点处，新直线取得更优值，因为新直线已经不可能对当前节点（的中点处）有贡献，而只**可能**对左半个区间（的中点）有贡献，所以直接在线段树上向左子树下放即可。这是一个递归的过程。\n\n这样有一个问题，当前区间的新直线可能对两个子节点所控制的区间的中点的值有贡献，而查询时有可能查询到两个子节点而忽略当前节点。为了解决此问题，在查询子节点时，先尝试将自身记录的直线下放下去。\n\n树链剖分会产生最多 $ O(\\log n) $ 条重链，线段树上一次查询或修改操作会访问最多 $ O(\\log n) $ 个节点，每个标记最多被下传 $ O(\\log n) $ 次，所以该算法的时间复杂度为 $ O(n \\log ^ 3 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-game.md","raw":"title: 「SDOI2016」游戏 - 树链剖分\ndate: 2016-04-15 22:25:55\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - 树链剖分\n  - 线段树\n  - 数学\n  - 数据结构\n  - 最近公共祖先\npermalink: sdoi2016-game\n---\n\nAlice 和 Bob 在玩一个游戏。  \n游戏在一棵有 $ n $ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $ 123456789123456789 $。  \n有时，Alice 会选择一条从 $ s $ 到 $ t $ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $ r $，若 $ r $ 与 $ s $ 的距离是 $ dis $，那么 Alice 在点 $ r $ 上添加的数字是 $ a \\times dis + b $。  \n有时，Bob 会选择一条从 $ s $ 到 $ t $ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。  \nBob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### 题解\n首先，树链剖分，转化成链上的操作，使用线段树维护。\n\n对一条路径上的每个点添加一个数字，设 $ p = {\\rm LCA}(s, t) $ ，可以把这条路径分为两条链，即 $ s \\rightarrow p $、$ p \\rightarrow t $。\n\n![Tree](sdoi2016-game/tree.png)\n\n设 $ {\\rm dist}(u, v) $ 为 u、v 两点间距离，则左边一条路径上每一个点被赋的值为\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n注意到，后面的 $ a \\times {\\rm dist}(s, root) + b $ 是一个常数。\n\n右边的一条路径上每个点被赋的值为\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n同理，后面的 $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ 也是一个常数。\n\n这样，我们得到了两个直线的斜截式方程，问题转化为：在序列上给一段区间添加一条直线；求一段区间内所有直线方程带入 $ x $ 值后的最小 $ y $ 值。\n\n这个问题可以使用线段树解决，每个节点维护：\n\n1. 区间最小值；\n2. 在当前节点 `mid` （区间中点）处取得值最小的一条直线。\n\n因为所有叶子节点的 `mid` 构成了整条线段，所以这样维护一定可以取得最小值。\n\n注意到直线的方程这种标记是不能合并的，所以每当添加一条直线的时候，判断这条直线在区间左端点、区间中点、区间右端点处带入得到的值是否比原有直线更优。\n\n如果左右端点都取**不**到更优值，则中点一定取不到更优值，且子节点的中点（整个区间）都取不到更优值，因为一次函数的图像是单调的。此时直接舍弃新的直线即可。\n\n如果左右端点都能取到更优值，同理，中点一定能取到更优值，且子节点的中点（整个区间）都能取到更优值。此时直接更新舍弃旧的直线即可。\n\n其他的情况，均为左右端点之一能取到更优值。如果中点能取到更优值，可以将新旧直线互换，并将左右端点能否取到更优值取反。即转化为，只有左右端点之一能取到更优值。\n\n此时的两条直线图像是这样的（因为带入的横坐标是离散的，所以真实的情况并不一定是直线，此处便于理解画成直线）：\n\n![Line](sdoi2016-game/line.png)\n\n旧直线为浅色，新直线为深色。可以看出在左端点处，新直线取得更优值，因为新直线已经不可能对当前节点（的中点处）有贡献，而只**可能**对左半个区间（的中点）有贡献，所以直接在线段树上向左子树下放即可。这是一个递归的过程。\n\n这样有一个问题，当前区间的新直线可能对两个子节点所控制的区间的中点的值有贡献，而查询时有可能查询到两个子节点而忽略当前节点。为了解决此问题，在查询子节点时，先尝试将自身记录的直线下放下去。\n\n树链剖分会产生最多 $ O(\\log n) $ 条重链，线段树上一次查询或修改操作会访问最多 $ O(\\log n) $ 个节点，每个标记最多被下传 $ O(\\log n) $ 次，所以该算法的时间复杂度为 $ O(n \\log ^ 3 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-game","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rf800c7ooxlwt64odd7"},{"title":"「SDOI2015」星际战争 - 网络流","date":"2016-02-29T07:42:11.000Z","_content":"\nY 军团一共派遣了 $ N $ 个巨型机器人进攻 X 军团的阵地，其中第 $ i $ 个巨型机器人的装甲值为 $ A_i $。当一个巨型机器人的装甲值减少到 0 或者以下时，这个巨型机器人就被摧毁了。X 军团有 $ M $ 个激光武器，其中第 $ i $ 个激光武器每秒可以削减一个巨型机器人 $ B_i $ 的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### 题解\n先二分一个时间，然后用网络流判定是否能在这段时间内打完。\n\n1. 从源点到每一个武器连一条边，容量为武器的威力 × 时间；\n2. 从每一个机器人向汇点连一条边，容量为该机器人的装甲值；\n3. 从每个武器向所有从该武器能攻击的机器人连一条边，容量为正无穷。\n\n嗯，说起来很容易对吧w ……\n\n然而答案是实数，实数二分倒没什么问题，要注意的是 Dinic 模板也要改成实数的。\n\n二分的范围不太好确定，既然题目明确有解，那就定上界为**用一个威力最小的武器打所有机器人所用时间**，反正不会错。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n \nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n \nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n \n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n \nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n \ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n \nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n \n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n \n\t\ts->level = 1;\n\t\t \n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n \n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn false;\n\t}\n \n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n \n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn 0;\n\t}\n \n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n \n\t\treturn ans;\n\t}\n} dinic;\n \ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n \n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n \ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n \ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n \n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n \n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n \n\tdouble flow = dinic(s, t, n + m + 2);\n \n\tcleanUp(n + m + 2);\n \n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n \ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n \n\treturn l + (r - l) / 2;\n}\n \nint main() {\n\tscanf(\"%d %d\", &n, &m);\n \n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n \n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n \n\tprintf(\"%.6lf\\n\", dichotomy());\n \n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-war.md","raw":"title: 「SDOI2015」星际战争 - 网络流\ndate: 2016-02-29 15:42:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Dinic\n  - 图论\n  - 网络流\n  - 二分答案\n  - 实数二分\npermalink: sdoi2015-war\n---\n\nY 军团一共派遣了 $ N $ 个巨型机器人进攻 X 军团的阵地，其中第 $ i $ 个巨型机器人的装甲值为 $ A_i $。当一个巨型机器人的装甲值减少到 0 或者以下时，这个巨型机器人就被摧毁了。X 军团有 $ M $ 个激光武器，其中第 $ i $ 个激光武器每秒可以削减一个巨型机器人 $ B_i $ 的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### 题解\n先二分一个时间，然后用网络流判定是否能在这段时间内打完。\n\n1. 从源点到每一个武器连一条边，容量为武器的威力 × 时间；\n2. 从每一个机器人向汇点连一条边，容量为该机器人的装甲值；\n3. 从每个武器向所有从该武器能攻击的机器人连一条边，容量为正无穷。\n\n嗯，说起来很容易对吧w ……\n\n然而答案是实数，实数二分倒没什么问题，要注意的是 Dinic 模板也要改成实数的。\n\n二分的范围不太好确定，既然题目明确有解，那就定上界为**用一个威力最小的武器打所有机器人所用时间**，反正不会错。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n \nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n \nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n \n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n \nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n \ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n \nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n \n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n \n\t\ts->level = 1;\n\t\t \n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n \n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn false;\n\t}\n \n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n \n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn 0;\n\t}\n \n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n \n\t\treturn ans;\n\t}\n} dinic;\n \ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n \n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n \ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n \ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n \n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n \n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n \n\tdouble flow = dinic(s, t, n + m + 2);\n \n\tcleanUp(n + m + 2);\n \n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n \ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n \n\treturn l + (r - l) / 2;\n}\n \nint main() {\n\tscanf(\"%d %d\", &n, &m);\n \n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n \n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n \n\tprintf(\"%.6lf\\n\", dichotomy());\n \n\treturn 0;\n}\n```\n","slug":"sdoi2015-war","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rfj00ciooxlhm5cby1n"},{"title":"「SDOI2015」序列统计 - 生成函数 + NTT","date":"2016-06-12T01:27:00.000Z","_content":"\n小 C 有一个集合 $ S $，里面的元素都是小于 $ M $ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $ N $ 的数列，数列中的每个数都属于集合 $ S $。\n\n小 C 用这个生成器生成了许多这样的数列。但是小 C 有一个问题需要你的帮助：给定整数 $ x $，求所有可以生成出的，且满足数列中所有数的乘积 $ \\bmod M $ 的值等于 $ x $ 的不同的数列的有多少个。小 C 认为，两个数列 $ \\{ A_i \\} $ 和 $ \\{B_i\\} $ 不同，当且仅当至少存在一个整数 $ i $，满足 $ A_i \\neq B_i $。另外，小 C 认为这个问题的答案可能很大，因此他只需要你帮助他求出答案 $ \\bmod 1004535809 $ 的值就可以了。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3992](http://www.lydsy.com/JudgeOnline/problem.php?id=3992)\n\n### 题解\n首先，题目中要求乘起来为 $ x $ 的方案数，我们可以对 $ S_i $ 和 $ x $ 取关于 $ M $ 的原根的离散对数，转化为 $ \\log S_i $ 加起来为 $ \\log x $ 的方案数。\n\n小于 $ M $ 的非负整数，除去 $ 0 $，共有 $ M - 2 $ 个，这些数 $ [1,\\ M - 1] $ 的离散对数的取值范围为 $ [0,\\ M - 2] $。因为根据费马小定理，有 $ g ^ {M - 1} \\equiv g ^ 0 \\equiv 1 \\pmod {M} $。\n\n定义生成函数\n\n$$ A(x) = \\sum\\limits_{i = 0} ^ {\\infty} a_i x ^ i $$\n\n对于集合中的每个数 $ S_i $，令 $ a_{\\log S_i} = 1 $，否则 $ a_{\\log S_i} = 0 $。\n\n快速幂求出 $ A ^ N(x) $ 的第 $ \\log x $ 项即为答案。相乘时使用 NTT。\n\n注意取离散对数后要求的是加起来 $ \\bmod {M - 1} $ 为 $ \\log x $，所以每次乘法后需要将所有次数 $ \\bmod {M - 1} $ 为 $ i $ 的项系数加到 $ i $ 次项上。\n\n时间复杂度为 $ O(M \\sqrt M + M \\log M \\log N) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXM = 8000;\nconst int MAXM_EXTENDED = 16384;\nconst long long MOD = 1004535809;\n\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\t// printf(\"root(%lld) = %d\\n\", p, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nint m;\nlong long log[MAXM];\n\ninline void prepare() {\n\tlong long t = 1, r = root(m);\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tlog[t] = i;\n\t\t// printf(\"log(%lld) = %d\\n\", t, i);\n\t\tt = t * r % m;\n\t}\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t\t// printf(\"omega[%d] = %lld\\n\", i, omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t\tassert(t < MAXM_EXTENDED);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tassert(n / l * i < MAXM_EXTENDED);\n\t\t\t\t\tassert(p - a + i < MAXM_EXTENDED);\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\t// printf(\"use omega = %lld\\n\", omega[n / l * i]);\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n\n\tvoid operator()(long long *a, long long *b, const int n) {\n\t\tassert(n <= MAXM_EXTENDED);\n\t\t/*\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tprintf(\" * \");\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tdft(a, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tif (a != b) dft(b, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;\n\n\t\tidft(a, n);\n\t\tif (a != b) idft(b, n);\n\t}\n} ntt;\n\ninline void pow(const long long *a, const int m, const int n, long long *res) {\n\tint size = 1;\n\twhile (size < m + m) size *= 2;\n\tntt.init(size);\n\t// printf(\"size = %d, m = %d\\n\", size, m);\n\n\tstatic long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED];\n\tstd::copy(a, a + m, buf);\n\tstd::copy(a, a + m, res);\n\tint tmp = n - 1;\n\n\t/*\n\tfor (int i = 0; i < tmp; i++) {\n\t\tntt(res, buf, size);\n\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t}\n\treturn;\n\t*/\n\n\tassert(size <= MAXM_EXTENDED);\n\n\twhile (tmp) {\n\t\tif (tmp & 1) {\n\t\t\tntt.dft(res, size);\n\t\t\tstd::copy(buf, buf + size, bufDft);\n\t\t\tntt.dft(bufDft, size);\n\t\t\tfor (int i = 0; i < size; i++) (res[i] *= bufDft[i]) %= MOD;\n\t\t\tntt.idft(res, size);\n\t\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t\t}\n\t\ttmp >>= 1;\n\n\t\tntt.dft(buf, size);\n\t\tfor (int i = 0; i < size; i++) (buf[i] *= buf[i]) %= MOD;\n\t\tntt.idft(buf, size);\n\t\tfor (int i = m; i < size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0;\n\t}\n}\n\nint main() {\n\tlong long n;\n\tint x, s;\n\tstatic long long a[MAXM];\n\n\tscanf(\"%lld %d %d %d\", &n, &m, &x, &s);\n\tfor (int i = 0; i < s; i++) scanf(\"%lld\", &a[i]);\n\n\tprepare();\n\n\tstatic long long f[MAXM_EXTENDED];\n\tfor (int i = 0; i < s; i++) {\n\t\tif (a[i] == 0) continue;\n\t\tf[log[a[i] % m]]++;\n\t}\n\n\tstatic long long res[MAXM_EXTENDED];\n\tpow(f, m - 1, n, res);\n\n\tassert(log[x] < MAXM_EXTENDED);\n\n\tlong long ans = res[log[x]];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-sequence.md","raw":"title: 「SDOI2015」序列统计 - 生成函数 + NTT\ndate: 2016-06-12 09:27:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - FFT\n  - NTT\n  - 数学\n  - 生成函数\n  - 快速幂\n  - 原根\npermalink: sdoi2015-sequence\n---\n\n小 C 有一个集合 $ S $，里面的元素都是小于 $ M $ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $ N $ 的数列，数列中的每个数都属于集合 $ S $。\n\n小 C 用这个生成器生成了许多这样的数列。但是小 C 有一个问题需要你的帮助：给定整数 $ x $，求所有可以生成出的，且满足数列中所有数的乘积 $ \\bmod M $ 的值等于 $ x $ 的不同的数列的有多少个。小 C 认为，两个数列 $ \\{ A_i \\} $ 和 $ \\{B_i\\} $ 不同，当且仅当至少存在一个整数 $ i $，满足 $ A_i \\neq B_i $。另外，小 C 认为这个问题的答案可能很大，因此他只需要你帮助他求出答案 $ \\bmod 1004535809 $ 的值就可以了。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3992](http://www.lydsy.com/JudgeOnline/problem.php?id=3992)\n\n### 题解\n首先，题目中要求乘起来为 $ x $ 的方案数，我们可以对 $ S_i $ 和 $ x $ 取关于 $ M $ 的原根的离散对数，转化为 $ \\log S_i $ 加起来为 $ \\log x $ 的方案数。\n\n小于 $ M $ 的非负整数，除去 $ 0 $，共有 $ M - 2 $ 个，这些数 $ [1,\\ M - 1] $ 的离散对数的取值范围为 $ [0,\\ M - 2] $。因为根据费马小定理，有 $ g ^ {M - 1} \\equiv g ^ 0 \\equiv 1 \\pmod {M} $。\n\n定义生成函数\n\n$$ A(x) = \\sum\\limits_{i = 0} ^ {\\infty} a_i x ^ i $$\n\n对于集合中的每个数 $ S_i $，令 $ a_{\\log S_i} = 1 $，否则 $ a_{\\log S_i} = 0 $。\n\n快速幂求出 $ A ^ N(x) $ 的第 $ \\log x $ 项即为答案。相乘时使用 NTT。\n\n注意取离散对数后要求的是加起来 $ \\bmod {M - 1} $ 为 $ \\log x $，所以每次乘法后需要将所有次数 $ \\bmod {M - 1} $ 为 $ i $ 的项系数加到 $ i $ 次项上。\n\n时间复杂度为 $ O(M \\sqrt M + M \\log M \\log N) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXM = 8000;\nconst int MAXM_EXTENDED = 16384;\nconst long long MOD = 1004535809;\n\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\t// printf(\"root(%lld) = %d\\n\", p, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nint m;\nlong long log[MAXM];\n\ninline void prepare() {\n\tlong long t = 1, r = root(m);\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tlog[t] = i;\n\t\t// printf(\"log(%lld) = %d\\n\", t, i);\n\t\tt = t * r % m;\n\t}\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t\t// printf(\"omega[%d] = %lld\\n\", i, omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t\tassert(t < MAXM_EXTENDED);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tassert(n / l * i < MAXM_EXTENDED);\n\t\t\t\t\tassert(p - a + i < MAXM_EXTENDED);\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\t// printf(\"use omega = %lld\\n\", omega[n / l * i]);\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n\n\tvoid operator()(long long *a, long long *b, const int n) {\n\t\tassert(n <= MAXM_EXTENDED);\n\t\t/*\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tprintf(\" * \");\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tdft(a, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tif (a != b) dft(b, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;\n\n\t\tidft(a, n);\n\t\tif (a != b) idft(b, n);\n\t}\n} ntt;\n\ninline void pow(const long long *a, const int m, const int n, long long *res) {\n\tint size = 1;\n\twhile (size < m + m) size *= 2;\n\tntt.init(size);\n\t// printf(\"size = %d, m = %d\\n\", size, m);\n\n\tstatic long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED];\n\tstd::copy(a, a + m, buf);\n\tstd::copy(a, a + m, res);\n\tint tmp = n - 1;\n\n\t/*\n\tfor (int i = 0; i < tmp; i++) {\n\t\tntt(res, buf, size);\n\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t}\n\treturn;\n\t*/\n\n\tassert(size <= MAXM_EXTENDED);\n\n\twhile (tmp) {\n\t\tif (tmp & 1) {\n\t\t\tntt.dft(res, size);\n\t\t\tstd::copy(buf, buf + size, bufDft);\n\t\t\tntt.dft(bufDft, size);\n\t\t\tfor (int i = 0; i < size; i++) (res[i] *= bufDft[i]) %= MOD;\n\t\t\tntt.idft(res, size);\n\t\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t\t}\n\t\ttmp >>= 1;\n\n\t\tntt.dft(buf, size);\n\t\tfor (int i = 0; i < size; i++) (buf[i] *= buf[i]) %= MOD;\n\t\tntt.idft(buf, size);\n\t\tfor (int i = m; i < size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0;\n\t}\n}\n\nint main() {\n\tlong long n;\n\tint x, s;\n\tstatic long long a[MAXM];\n\n\tscanf(\"%lld %d %d %d\", &n, &m, &x, &s);\n\tfor (int i = 0; i < s; i++) scanf(\"%lld\", &a[i]);\n\n\tprepare();\n\n\tstatic long long f[MAXM_EXTENDED];\n\tfor (int i = 0; i < s; i++) {\n\t\tif (a[i] == 0) continue;\n\t\tf[log[a[i] % m]]++;\n\t}\n\n\tstatic long long res[MAXM_EXTENDED];\n\tpow(f, m - 1, n, res);\n\n\tassert(log[x] < MAXM_EXTENDED);\n\n\tlong long ans = res[log[x]];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2015-sequence","published":1,"updated":"2016-06-17T13:39:09.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rfo00csooxlhfez3dbn"},{"title":"「SDOI2014」旅行 - 树链剖分","date":"2016-09-02T13:39:00.000Z","_content":"\n给一棵树，每个点有其初始颜色和权值，每次修改一个点的颜色或权值，查询路径上颜色与起点相同点权值的和或最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3531](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)\n\n### 题解\n树链剖分，对每种颜色单独建立线段树，线段树动态开点、删点，时间复杂度与空间复杂度均为 $ O(n \\log n) $ 级别。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 1e5;\nconst int MAXQ = 1e5;\nconst int MAXC = 1e5;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint max, sum;\n\n\tSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {}\n\n\tvoid update(const int pos, const int val) {\n\t\tif (l != r) {\n\t\t\tSegmentTree *&c = pos <= mid ? lc : rc;\n\t\t\tif (!c) c = (pos <= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r);\n\t\t\tc->update(pos, val);\n\t\t\tif (val == 0 && !c->lc && !c->rc) delete c, c = NULL;\n\t\t\tmax = sum = 0;\n\t\t\tif (lc) max = std::max(max, lc->max), sum += lc->sum;\n\t\t\tif (rc) max = std::max(max, rc->max), sum += rc->sum;\n\t\t} else sum = max = val;\n\t}\n\n\tint querySum(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return (lc ? lc->querySum(l, r) : 0) + (rc ? rc->querySum(l, r) : 0);\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc ? lc->queryMax(l, r) : 0, rc ? rc->queryMax(l, r) : 0);\n\t}\n} *seg[MAXC];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i;\n\tbool f;\n\tNode *p, *c, *t;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, q, f[MAXN], v[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].d = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->f) {\n\t\t\tv->f = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n\t\t\t\te->t->d = v->d + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->s = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->s += e->t->s;\n\t\t\t\tif (!v->c || v->c->s < e->t->s) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\ts.push(&N[0]);\n\tint i = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (v->f) {\n\t\t\tv->f = false;\n\t\t\tv->i = i++;\n\t\t\tif (!v->p || v != v->p->c) v->t = v;\n\t\t\telse v->t = v->p->t;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else s.pop();\n\t}\n}\n\ninline int querySum(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans += seg->querySum(a->t->i, a->i);\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn ans + seg->querySum(a->i, b->i);\n}\n\ninline int queryMax(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans = std::max(ans, seg->queryMax(a->t->i, a->i));\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn std::max(ans, seg->queryMax(a->i, b->i));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (int i = 0; i < MAXC; i++) seg[i] = new SegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &v[i], &f[i]);\n\t\tf[i]--;\n\t\t// printf(\"seg[%d]->update(%d, %d)\\n\", f[i], i, v[i]);\n\t\t// seg[f[i]]->update(i, v[i]);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < n; i++) seg[f[i]]->update(N[i].i, v[i]);\n\n\twhile (q-- ) {\n\t\tchar s[3];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", s, &a, &b);\n\t\t\n\t\tif (s[1] == 'C') {\n\t\t\ta--, b--;\n\t\t\tseg[f[a]]->update(N[a].i, 0);\n\t\t\tseg[b]->update(N[a].i, v[a]);\n\t\t\tf[a] = b;\n\t\t} else if (s[1] == 'W') {\n\t\t\ta--;\n\t\t\tseg[f[a]]->update(N[a].i, b);\n\t\t\tv[a] = b;\n\t\t} else if (s[1] == 'S') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", querySum(a, b, seg[f[a]]));\n\t\t} else if (s[1] == 'M') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", queryMax(a, b, seg[f[a]]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/sdoi2014-journey.md","raw":"title: 「SDOI2014」旅行 - 树链剖分\ndate: 2016-09-02 21:39:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - 树链剖分\n  - 数据结构\npermalink: sdoi2014-journey\n---\n\n给一棵树，每个点有其初始颜色和权值，每次修改一个点的颜色或权值，查询路径上颜色与起点相同点权值的和或最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3531](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)\n\n### 题解\n树链剖分，对每种颜色单独建立线段树，线段树动态开点、删点，时间复杂度与空间复杂度均为 $ O(n \\log n) $ 级别。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 1e5;\nconst int MAXQ = 1e5;\nconst int MAXC = 1e5;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint max, sum;\n\n\tSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {}\n\n\tvoid update(const int pos, const int val) {\n\t\tif (l != r) {\n\t\t\tSegmentTree *&c = pos <= mid ? lc : rc;\n\t\t\tif (!c) c = (pos <= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r);\n\t\t\tc->update(pos, val);\n\t\t\tif (val == 0 && !c->lc && !c->rc) delete c, c = NULL;\n\t\t\tmax = sum = 0;\n\t\t\tif (lc) max = std::max(max, lc->max), sum += lc->sum;\n\t\t\tif (rc) max = std::max(max, rc->max), sum += rc->sum;\n\t\t} else sum = max = val;\n\t}\n\n\tint querySum(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return (lc ? lc->querySum(l, r) : 0) + (rc ? rc->querySum(l, r) : 0);\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc ? lc->queryMax(l, r) : 0, rc ? rc->queryMax(l, r) : 0);\n\t}\n} *seg[MAXC];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i;\n\tbool f;\n\tNode *p, *c, *t;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, q, f[MAXN], v[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].d = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->f) {\n\t\t\tv->f = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n\t\t\t\te->t->d = v->d + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->s = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->s += e->t->s;\n\t\t\t\tif (!v->c || v->c->s < e->t->s) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\ts.push(&N[0]);\n\tint i = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (v->f) {\n\t\t\tv->f = false;\n\t\t\tv->i = i++;\n\t\t\tif (!v->p || v != v->p->c) v->t = v;\n\t\t\telse v->t = v->p->t;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else s.pop();\n\t}\n}\n\ninline int querySum(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans += seg->querySum(a->t->i, a->i);\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn ans + seg->querySum(a->i, b->i);\n}\n\ninline int queryMax(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans = std::max(ans, seg->queryMax(a->t->i, a->i));\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn std::max(ans, seg->queryMax(a->i, b->i));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (int i = 0; i < MAXC; i++) seg[i] = new SegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &v[i], &f[i]);\n\t\tf[i]--;\n\t\t// printf(\"seg[%d]->update(%d, %d)\\n\", f[i], i, v[i]);\n\t\t// seg[f[i]]->update(i, v[i]);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < n; i++) seg[f[i]]->update(N[i].i, v[i]);\n\n\twhile (q-- ) {\n\t\tchar s[3];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", s, &a, &b);\n\t\t\n\t\tif (s[1] == 'C') {\n\t\t\ta--, b--;\n\t\t\tseg[f[a]]->update(N[a].i, 0);\n\t\t\tseg[b]->update(N[a].i, v[a]);\n\t\t\tf[a] = b;\n\t\t} else if (s[1] == 'W') {\n\t\t\ta--;\n\t\t\tseg[f[a]]->update(N[a].i, b);\n\t\t\tv[a] = b;\n\t\t} else if (s[1] == 'S') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", querySum(a, b, seg[f[a]]));\n\t\t} else if (s[1] == 'M') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", queryMax(a, b, seg[f[a]]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"sdoi2014-journey","published":1,"updated":"2016-09-02T13:42:35.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rft00d6ooxlm2ytmtoh"},{"title":"「SDOI2013」森林 - LCA + 主席树 + 启发式合并","date":"2016-09-05T13:49:00.000Z","_content":"\n森林中有 $ n $ 个点，$ m $ 条边，每个点有点权，执行 $ T $ 次操作：\n\n1. 查询两点间点权的第 $ k $ 小；\n2. 连接两个点，保证图在操作后仍然为森林。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3123](http://www.lydsy.com/JudgeOnline/problem.php?id=3123)\n\n### 题解\n对于第 $ k $ 小的询问，可以使用类似树上前缀和求两点距离的方法，使用主席树。将主席树的序列前缀和改为树上前缀和即可。\n\n对于合并操作，每次将较小树合并到较大树上（使用并查集维护每棵树的大小），可以证明总复杂度为 $ O(n \\log ^ 2 n) $。\n\n### 代码\n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 80000;\nconst int MAXN_LOG = 17;\n\nstruct UnionFindSet {\n\tint a[MAXN], s[MAXN];\n\n\tinline void init(const int n) { for (register int i = 0; i < n; i++) a[i] = i, s[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tinline int getSize(const int x) { return s[find(x)]; }\n\n\tinline void merge(const int x, const int y) {\n\t\tconst register int p = find(x), q = find(y);\n\t\ta[p] = q;\n\t\ts[q] += s[p];\n\t}\n} ufs;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint cnt, refCnt;\n\n\tinline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {}\n\n\tinline static SegmentTree *newNode();\n\tinline static void deleteNode(SegmentTree *v);\n\n\t~SegmentTree() {\n\t\tif (r - l < 600) return;\n\t\tif (lc && lc->unref()) deleteNode(lc);\n\t\tif (rc && rc->unref()) deleteNode(rc);\n\t}\n\n\tinline SegmentTree *buildChild(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x <= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0);\n\t\telse return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0);\n\t}\n\n\tSegmentTree *insertSelf(const int x) {\n\t\tcnt++;\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return this;\n\t\telse if (x <= mid) return (lc = buildChild(x))->insertSelf(x), this;\n\t\telse return (rc = buildChild(x))->insertSelf(x), this;\n\t}\n\n\tSegmentTree *insert(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1);\n\t\telse if (x <= mid) return new (newNode()) SegmentTree(l, r, lc ? lc->insert(x) : buildChild(x)->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\telse return new (newNode()) SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : buildChild(x)->insertSelf(x), cnt + 1);\n\t}\n\n\tinline SegmentTree *ref() {\n\t\trefCnt++;\n\t\treturn this;\n\t}\n\n\tinline bool unref() {\n\t\treturn !--refCnt;\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse return lc->query(l, r) + rc->query(l, r);\n\t}\n\n\tinline int rank() {\n\t\treturn lc ? lc->cnt : 0;\n\t}\n} *segRoot;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[sizeof(T) * SIZE], *p;\n\tT *recycle[SIZE], **pr;\n\t\n\tinline MemoryPool() : p(buf), pr(recycle) {}\n\n\tinline T *alloc() {\n\t\tif (p == buf + sizeof(T) * SIZE) {\n\t\t\tif (pr <= recycle) throw std::bad_alloc();\n\t\t\telse return *--pr;\n\t\t} else {\n\t\t\tregister char *res = p;\n\t\t\tp += sizeof(T);\n\t\t\treturn reinterpret_cast<T *>(res);\n\t\t}\n\t}\n\n\tinline void free(T *p) {\n\t\t*pr++ = p;\n\t}\n};\n\nMemoryPool<SegmentTree, MAXN * MAXN_LOG * 10> pool;\ninline SegmentTree *SegmentTree::newNode() {\n\treturn pool.alloc();\n}\n\ninline void SegmentTree::deleteNode(SegmentTree *p) {\n\tp->~SegmentTree();\n\tpool.free(p);\n}\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *p;\n\tint w, ts, d;\n\tbool v;\n\tSegmentTree *seg;\n\tNode *f[MAXN_LOG + 1];\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {};\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nint n, ts, logn = 0;\n\ninline void bfs(Node *start, const bool init = true) {\n\t++ts;\n\tstd::queue<Node *> q;\n\tstart->ts = ts;\n\tif (init) {\n\t\tstart->p = start->f[0] = start;\n\t\tstart->seg = segRoot->insert(start->w);\n\t\tstart->d = 0;\n\t}\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (register int j = 1; j <= logn; j++) {\n\t\t\tv->f[j] = v->f[j - 1]->f[j - 1];\n\t\t}\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->ts != ts && (init || e->t != start->p)) {\n\t\t\te->t->ts = ts;\n\t\t\te->t->p = e->t->f[0] = v;\n\t\t\tif (e->t->seg) SegmentTree::deleteNode(e->t->seg);\n\t\t\te->t->seg = v->seg->insert(e->t->w);\n\t\t\te->t->d = v->d + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void bfs() {\n\tfor (register int i = 0; i < n; i++) if (N[i].ts == 0) bfs(&N[i]);\n}\n\ninline void link(int u, int v) {\n\tconst register int su = ufs.getSize(u), sv = ufs.getSize(v);\n\tif (su > sv) std::swap(u, v);\n\n\taddEdge(u, v);\n\tN[u].p = N[u].f[0] = &N[v];\n\tSegmentTree::deleteNode(N[u].seg);\n\tN[u].seg = N[v].seg->insert(N[u].w);\n\tN[u].d = N[v].d + 1;\n\tbfs(&N[u], false);\n\n\tufs.merge(u, v);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\tif (u->d < v->d) std::swap(u, v);\n\tif (u->d != v->d) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i]->d >= v->d) u = u->f[i];\n\t}\n\tif (u != v) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n\t\treturn u->p;\n\t}\n\treturn u;\n}\n\ninline int query(Node *u, Node *v, int k) {\n\tNode *p = lca(u, v);\n\tregister int min = 0, max = n - 1;\n\tSegmentTree *sa = u->seg, *sb = v->seg, *sc = p->seg, *sd = p->p != p ? p->p->seg : segRoot;\n\twhile (min != max) {\n\t\tconst register int mid = min + (max - min) / 2;\n\t\tregister int t = 0;\n\t\tif (sa) t += sa->rank();\n\t\tif (sb) t += sb->rank();\n\t\tif (sc) t -= sc->rank();\n\t\tif (sd) t -= sd->rank();\n\t\tif (k <= t) {\n\t\t\tif (sa) sa = sa->lc;\n\t\t\tif (sb) sb = sb->lc;\n\t\t\tif (sc) sc = sc->lc;\n\t\t\tif (sd) sd = sd->lc;\n\t\t\tmax = mid;\n\t\t} else {\n\t\t\tif (sa) sa = sa->rc;\n\t\t\tif (sb) sb = sb->rc;\n\t\t\tif (sc) sc = sc->rc;\n\t\t\tif (sd) sd = sd->rc;\n\t\t\tk -= t, min = mid + 1;\n\t\t}\n\t}\n\treturn min;\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tint m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tufs.init(n);\n\tfor (; (1 << (logn + 1)) <= n; logn++);\n\n\tfor (register int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\tstatic int set[MAXN];\n\tfor (register int i = 0; i < n; i++) set[i] = N[i].w;\n\tstd::sort(set, set + n);\n\tregister int *end = std::unique(set, set + n);\n\tfor (register int i = 0; i < n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set;\n\n\tsegRoot = new SegmentTree(0, n - 1);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbfs();\n\n\tregister int lastAns = 0;\n\twhile (t--) {\n\t\tchar cmd[2];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", cmd, &u, &v), u ^= lastAns, v ^= lastAns, u--, v--;\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tk ^= lastAns;\n\t\t\tprintf(\"%d\\n\", lastAns = set[query(&N[u], &N[v], k)]);\n\t\t} else {\n\t\t\tlink(u, v);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2013-rforest.md","raw":"title: 「SDOI2013」森林 - LCA + 主席树 + 启发式合并\ndate: 2016-09-05 21:49:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - 并查集\n  - 主席树\n  - 启发式合并\n  - 最近公共祖先\npermalink: sdoi2013-rforest\n---\n\n森林中有 $ n $ 个点，$ m $ 条边，每个点有点权，执行 $ T $ 次操作：\n\n1. 查询两点间点权的第 $ k $ 小；\n2. 连接两个点，保证图在操作后仍然为森林。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3123](http://www.lydsy.com/JudgeOnline/problem.php?id=3123)\n\n### 题解\n对于第 $ k $ 小的询问，可以使用类似树上前缀和求两点距离的方法，使用主席树。将主席树的序列前缀和改为树上前缀和即可。\n\n对于合并操作，每次将较小树合并到较大树上（使用并查集维护每棵树的大小），可以证明总复杂度为 $ O(n \\log ^ 2 n) $。\n\n### 代码\n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 80000;\nconst int MAXN_LOG = 17;\n\nstruct UnionFindSet {\n\tint a[MAXN], s[MAXN];\n\n\tinline void init(const int n) { for (register int i = 0; i < n; i++) a[i] = i, s[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tinline int getSize(const int x) { return s[find(x)]; }\n\n\tinline void merge(const int x, const int y) {\n\t\tconst register int p = find(x), q = find(y);\n\t\ta[p] = q;\n\t\ts[q] += s[p];\n\t}\n} ufs;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint cnt, refCnt;\n\n\tinline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {}\n\n\tinline static SegmentTree *newNode();\n\tinline static void deleteNode(SegmentTree *v);\n\n\t~SegmentTree() {\n\t\tif (r - l < 600) return;\n\t\tif (lc && lc->unref()) deleteNode(lc);\n\t\tif (rc && rc->unref()) deleteNode(rc);\n\t}\n\n\tinline SegmentTree *buildChild(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x <= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0);\n\t\telse return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0);\n\t}\n\n\tSegmentTree *insertSelf(const int x) {\n\t\tcnt++;\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return this;\n\t\telse if (x <= mid) return (lc = buildChild(x))->insertSelf(x), this;\n\t\telse return (rc = buildChild(x))->insertSelf(x), this;\n\t}\n\n\tSegmentTree *insert(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1);\n\t\telse if (x <= mid) return new (newNode()) SegmentTree(l, r, lc ? lc->insert(x) : buildChild(x)->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\telse return new (newNode()) SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : buildChild(x)->insertSelf(x), cnt + 1);\n\t}\n\n\tinline SegmentTree *ref() {\n\t\trefCnt++;\n\t\treturn this;\n\t}\n\n\tinline bool unref() {\n\t\treturn !--refCnt;\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse return lc->query(l, r) + rc->query(l, r);\n\t}\n\n\tinline int rank() {\n\t\treturn lc ? lc->cnt : 0;\n\t}\n} *segRoot;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[sizeof(T) * SIZE], *p;\n\tT *recycle[SIZE], **pr;\n\t\n\tinline MemoryPool() : p(buf), pr(recycle) {}\n\n\tinline T *alloc() {\n\t\tif (p == buf + sizeof(T) * SIZE) {\n\t\t\tif (pr <= recycle) throw std::bad_alloc();\n\t\t\telse return *--pr;\n\t\t} else {\n\t\t\tregister char *res = p;\n\t\t\tp += sizeof(T);\n\t\t\treturn reinterpret_cast<T *>(res);\n\t\t}\n\t}\n\n\tinline void free(T *p) {\n\t\t*pr++ = p;\n\t}\n};\n\nMemoryPool<SegmentTree, MAXN * MAXN_LOG * 10> pool;\ninline SegmentTree *SegmentTree::newNode() {\n\treturn pool.alloc();\n}\n\ninline void SegmentTree::deleteNode(SegmentTree *p) {\n\tp->~SegmentTree();\n\tpool.free(p);\n}\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *p;\n\tint w, ts, d;\n\tbool v;\n\tSegmentTree *seg;\n\tNode *f[MAXN_LOG + 1];\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {};\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nint n, ts, logn = 0;\n\ninline void bfs(Node *start, const bool init = true) {\n\t++ts;\n\tstd::queue<Node *> q;\n\tstart->ts = ts;\n\tif (init) {\n\t\tstart->p = start->f[0] = start;\n\t\tstart->seg = segRoot->insert(start->w);\n\t\tstart->d = 0;\n\t}\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (register int j = 1; j <= logn; j++) {\n\t\t\tv->f[j] = v->f[j - 1]->f[j - 1];\n\t\t}\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->ts != ts && (init || e->t != start->p)) {\n\t\t\te->t->ts = ts;\n\t\t\te->t->p = e->t->f[0] = v;\n\t\t\tif (e->t->seg) SegmentTree::deleteNode(e->t->seg);\n\t\t\te->t->seg = v->seg->insert(e->t->w);\n\t\t\te->t->d = v->d + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void bfs() {\n\tfor (register int i = 0; i < n; i++) if (N[i].ts == 0) bfs(&N[i]);\n}\n\ninline void link(int u, int v) {\n\tconst register int su = ufs.getSize(u), sv = ufs.getSize(v);\n\tif (su > sv) std::swap(u, v);\n\n\taddEdge(u, v);\n\tN[u].p = N[u].f[0] = &N[v];\n\tSegmentTree::deleteNode(N[u].seg);\n\tN[u].seg = N[v].seg->insert(N[u].w);\n\tN[u].d = N[v].d + 1;\n\tbfs(&N[u], false);\n\n\tufs.merge(u, v);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\tif (u->d < v->d) std::swap(u, v);\n\tif (u->d != v->d) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i]->d >= v->d) u = u->f[i];\n\t}\n\tif (u != v) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n\t\treturn u->p;\n\t}\n\treturn u;\n}\n\ninline int query(Node *u, Node *v, int k) {\n\tNode *p = lca(u, v);\n\tregister int min = 0, max = n - 1;\n\tSegmentTree *sa = u->seg, *sb = v->seg, *sc = p->seg, *sd = p->p != p ? p->p->seg : segRoot;\n\twhile (min != max) {\n\t\tconst register int mid = min + (max - min) / 2;\n\t\tregister int t = 0;\n\t\tif (sa) t += sa->rank();\n\t\tif (sb) t += sb->rank();\n\t\tif (sc) t -= sc->rank();\n\t\tif (sd) t -= sd->rank();\n\t\tif (k <= t) {\n\t\t\tif (sa) sa = sa->lc;\n\t\t\tif (sb) sb = sb->lc;\n\t\t\tif (sc) sc = sc->lc;\n\t\t\tif (sd) sd = sd->lc;\n\t\t\tmax = mid;\n\t\t} else {\n\t\t\tif (sa) sa = sa->rc;\n\t\t\tif (sb) sb = sb->rc;\n\t\t\tif (sc) sc = sc->rc;\n\t\t\tif (sd) sd = sd->rc;\n\t\t\tk -= t, min = mid + 1;\n\t\t}\n\t}\n\treturn min;\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tint m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tufs.init(n);\n\tfor (; (1 << (logn + 1)) <= n; logn++);\n\n\tfor (register int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\tstatic int set[MAXN];\n\tfor (register int i = 0; i < n; i++) set[i] = N[i].w;\n\tstd::sort(set, set + n);\n\tregister int *end = std::unique(set, set + n);\n\tfor (register int i = 0; i < n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set;\n\n\tsegRoot = new SegmentTree(0, n - 1);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbfs();\n\n\tregister int lastAns = 0;\n\twhile (t--) {\n\t\tchar cmd[2];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", cmd, &u, &v), u ^= lastAns, v ^= lastAns, u--, v--;\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tk ^= lastAns;\n\t\t\tprintf(\"%d\\n\", lastAns = set[query(&N[u], &N[v], k)]);\n\t\t} else {\n\t\t\tlink(u, v);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"sdoi2013-rforest","published":1,"updated":"2016-10-19T09:24:21.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rfw00dcooxlt9lyjj2q"},{"title":"「SDOI2011」计算器 - 快速幂 + EXGCD + BSGS","date":"2016-06-13T04:07:00.000Z","_content":"\n你被要求设计一个计算器完成以下三项任务：\n\n1. 给定 $ y $、$ z $、$ p $，计算 $ y ^ z \\bmod p $ 的值；\n2. 给定 $ y $、$ z $、$ p $，计算满足 $ xy \\equiv z \\pmod p $ 的最小非负整数 $ x $；\n3. 给定 $ y $、$ z $、$ p $，计算满足 $ y ^ x \\equiv z \\pmod p $的最小非负整数 $ x $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242)\n\n### 题解\n第一种，快速幂。\n\n第二种，当 $ y \\equiv 0 \\pmod p $ 且 $ z \\not \\equiv 0 \\pmod p $ 时无解。  \n否则当 $ z \\equiv 0 \\pmod p $ 时答案为 $ 0 $。\n\n其它情况，考虑 $ y $ 在模 $ p $ 意义下的乘法逆元\n\n$$ x \\equiv z \\times y ^ {-1} \\pmod p $$\n\nEXGCD 求解逆元即可。\n\n第三种，BSGS 求解离散对数。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <tr1/unordered_map>\n\ntemplate <typename T>\ninline T pow(const T a, const T n, const T p) {\n\tT ans = 1;\n\tfor (T x = a, tmp = n; tmp; tmp >>= 1, x = x * x % p) if (tmp & 1) ans = ans * x % p;\n\treturn ans;\n}\n\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tif (a == 0) {\n\t\treturn b == 0 ? 1 : -1;\n\t}\n\n\tstd::tr1::unordered_map<T, T> map;\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT r = b, k = inv(t, p) % p;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(r)) return map[r] + i * m;\n\t\tr = r * k % p;\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\twhile (t--) {\n\t\tlong long a, b, p;\n\t\tscanf(\"%lld %lld %lld\", &a, &b, &p);\n\t\tif (k == 1) {\n\t\t\tprintf(\"%lld\\n\", pow(a, b, p));\n\t\t} else if (k == 2) {\n\t\t\tif (a > p && a % p == 0) puts(\"Orz, I cannot find x!\");\n\t\t\telse {\n\t\t\t\tlong long t = inv(a, p);\n\t\t\t\tprintf(\"%lld\\n\", b * t % p);\n\t\t\t}\n\t\t} else if (k == 3) {\n\t\t\tlong long ans = bsgs(a % p, b % p, p);\n\t\t\tif (ans == -1) puts(\"Orz, I cannot find x!\");\n\t\t\telse printf(\"%lld\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2011-calc.md","raw":"title: 「SDOI2011」计算器 - 快速幂 + EXGCD + BSGS\ndate: 2016-06-13 12:07:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - 数学\n  - EXGCD\n  - 快速幂\n  - BSGS\npermalink: sdoi2011-calc\n---\n\n你被要求设计一个计算器完成以下三项任务：\n\n1. 给定 $ y $、$ z $、$ p $，计算 $ y ^ z \\bmod p $ 的值；\n2. 给定 $ y $、$ z $、$ p $，计算满足 $ xy \\equiv z \\pmod p $ 的最小非负整数 $ x $；\n3. 给定 $ y $、$ z $、$ p $，计算满足 $ y ^ x \\equiv z \\pmod p $的最小非负整数 $ x $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242)\n\n### 题解\n第一种，快速幂。\n\n第二种，当 $ y \\equiv 0 \\pmod p $ 且 $ z \\not \\equiv 0 \\pmod p $ 时无解。  \n否则当 $ z \\equiv 0 \\pmod p $ 时答案为 $ 0 $。\n\n其它情况，考虑 $ y $ 在模 $ p $ 意义下的乘法逆元\n\n$$ x \\equiv z \\times y ^ {-1} \\pmod p $$\n\nEXGCD 求解逆元即可。\n\n第三种，BSGS 求解离散对数。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <tr1/unordered_map>\n\ntemplate <typename T>\ninline T pow(const T a, const T n, const T p) {\n\tT ans = 1;\n\tfor (T x = a, tmp = n; tmp; tmp >>= 1, x = x * x % p) if (tmp & 1) ans = ans * x % p;\n\treturn ans;\n}\n\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tif (a == 0) {\n\t\treturn b == 0 ? 1 : -1;\n\t}\n\n\tstd::tr1::unordered_map<T, T> map;\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT r = b, k = inv(t, p) % p;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(r)) return map[r] + i * m;\n\t\tr = r * k % p;\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\twhile (t--) {\n\t\tlong long a, b, p;\n\t\tscanf(\"%lld %lld %lld\", &a, &b, &p);\n\t\tif (k == 1) {\n\t\t\tprintf(\"%lld\\n\", pow(a, b, p));\n\t\t} else if (k == 2) {\n\t\t\tif (a > p && a % p == 0) puts(\"Orz, I cannot find x!\");\n\t\t\telse {\n\t\t\t\tlong long t = inv(a, p);\n\t\t\t\tprintf(\"%lld\\n\", b * t % p);\n\t\t\t}\n\t\t} else if (k == 3) {\n\t\t\tlong long ans = bsgs(a % p, b % p, p);\n\t\t\tif (ans == -1) puts(\"Orz, I cannot find x!\");\n\t\t\telse printf(\"%lld\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"sdoi2011-calc","published":1,"updated":"2016-06-13T04:07:43.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rg100dnooxloxhb1gg3"},{"title":"「SDOI2010」星际竞速 - 费用流","date":"2016-02-29T13:30:11.000Z","_content":"\n大赛要求车手们从一颗与这 $ N $ 颗行星之间没有任何航路的天体出发，访问这 $ N $ 颗行星每颗恰好一次。超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会沿星际航路高速航行。在能力爆发模式下，经过一段时间的定位之后，它能瞬间移动到任意一个行星。在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。求完成比赛的最少时间。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### 题解\n求完成比赛的最少时间，很容易想到最短路，然而不确定起点终点而且恰好访问一次都不太适合最短路 …… 考虑网络流建模吧。\n\n刚开始想到的一个**错误**的解法：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出，之间连一条容量为 1，费用为零的边；\n2. 从源点到每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点到汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 建立『中转站』，从每个点到中转站连一条容量为 1 费用为 0 的边；从中转站到每个点连一条容量为 1 费用为定位时间的边。\n\n求出最小费用最大流 …… 呃，答案就是零 ……\n\n很容易想出上面的模型是错的，因为它不能保证每个点都被访问过 —— 虽然它比较直观。\n\n再来分析一下题意，每个点都经过一次，有点类似路径覆盖，而路径覆盖中是没有边权的，考虑把边权加在费用上。\n\n一种**类似于路径覆盖**的建模方式：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出；\n2. 从源点向每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点向汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 从源点向每个**出点**连一条容量为 1 费用为定位时间的边。\n\n这种建模思想抓住了题目中『每个点经过一次』的条件，避开了路径上的问题 —— 整个网络保证了到汇点边全部满流，也就对应了每个点被经过一次。\n\n处理『瞬间移动』的思路是，不考虑是从哪个星球移动过来，向哪里走 —— 因为从每个点向哪里走是由选择的边决定的（甚至可能瞬移到的点就是终点），只需要考虑，瞬移经过的点不需要再在其他路径上被经过，所以直接从源点连到某个点的出点就好啦。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-starrace.md","raw":"title: 「SDOI2010」星际竞速 - 费用流 \ndate: 2016-02-29 21:30:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Edmonds-Karp\n  - 图论\n  - 网络流\n  - 费用流\npermalink: sdoi2010-starrace\n---\n\n大赛要求车手们从一颗与这 $ N $ 颗行星之间没有任何航路的天体出发，访问这 $ N $ 颗行星每颗恰好一次。超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会沿星际航路高速航行。在能力爆发模式下，经过一段时间的定位之后，它能瞬间移动到任意一个行星。在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。求完成比赛的最少时间。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### 题解\n求完成比赛的最少时间，很容易想到最短路，然而不确定起点终点而且恰好访问一次都不太适合最短路 …… 考虑网络流建模吧。\n\n刚开始想到的一个**错误**的解法：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出，之间连一条容量为 1，费用为零的边；\n2. 从源点到每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点到汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 建立『中转站』，从每个点到中转站连一条容量为 1 费用为 0 的边；从中转站到每个点连一条容量为 1 费用为定位时间的边。\n\n求出最小费用最大流 …… 呃，答案就是零 ……\n\n很容易想出上面的模型是错的，因为它不能保证每个点都被访问过 —— 虽然它比较直观。\n\n再来分析一下题意，每个点都经过一次，有点类似路径覆盖，而路径覆盖中是没有边权的，考虑把边权加在费用上。\n\n一种**类似于路径覆盖**的建模方式：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出；\n2. 从源点向每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点向汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 从源点向每个**出点**连一条容量为 1 费用为定位时间的边。\n\n这种建模思想抓住了题目中『每个点经过一次』的条件，避开了路径上的问题 —— 整个网络保证了到汇点边全部满流，也就对应了每个点被经过一次。\n\n处理『瞬间移动』的思路是，不考虑是从哪个星球移动过来，向哪里走 —— 因为从每个点向哪里走是由选择的边决定的（甚至可能瞬移到的点就是终点），只需要考虑，瞬移经过的点不需要再在其他路径上被经过，所以直接从源点连到某个点的出点就好啦。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-starrace","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rg500dxooxl2qhyge5n"},{"title":"「SDOI2010」地精部落 - DP","date":"2016-06-20T07:49:00.000Z","_content":"\n我们称一个排列是合法的，当且仅当每一个数都满足这个数比它相邻的数都要大或都要小。\n\n求长度为 $ N $ 的合法排列数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1925](http://www.lydsy.com/JudgeOnline/problem.php?id=1925)\n\n### 题解\n题目相当于要求 $ 0 $ ~ $ n - 1 $ 的合法排列数。\n\n设 $ f(i,\\ j) $ 表示 $ 0 $ ~ $ i $ 的排列，第一个数为 $ j $（$ j \\leq i $），**且第二个数比第一个数小**的方案数。\n\n考虑第二个数，当第二个数**小于** $ j - 1 $ 时，其方案数为第一个数为 $ j - 1 $ 时的方案数，即 $ f(i,\\ j - 1) $。  \n当第二个数**等于** $ j - 1 $ 时，从第二个数开始，是一个 $ 0 $ ~ $ i - 1 $ 的排列，这个排列的第二个数比第一个数**大**。如果将每个数 $ x $ 变成 $ (i - 1) - x $，那么就变成原有的第二个数比第一个数小的情况了。即 $ f(i - 1,\\ (i - 1) - (j - 1)) $。\n\n所以转移方程为 $ f(i,\\ j) = f(i,\\ j - 1) + f(i - 1, i - j) $。\n\n答案为 $ 2 \\sum\\limits_{i = 0} ^ {n - 1} f(n - 1,\\ i) $，因为要考虑第二个数**大于**第一个数的方案数所以乘 $ 2 $。\n\n### 代码\n不使用滚动数组，内存 30M+ 是可以过的。\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\nint _f[MAXN * (MAXN + 1) / 2];\nint *f[MAXN + 1];\n\ninline void init() {\n\tint *curr = _f;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i] = curr;\n\t\tcurr += i + 1;\n\t}\n\t// printf(\"%ld %d\\n\", curr - _f, n * (n + 1) / 2);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\tinit();\n\n\tf[1][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p;\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[n - 1][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n\n使用滚动数组之后，时间也快不少。\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\n\tstatic int f[2][MAXN];\n\tf[1 % 2][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[(n - 1) % 2][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-goblin.md","raw":"title: 「SDOI2010」地精部落 - DP\ndate: 2016-06-20 15:49:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - DP\npermalink: sdoi2010-goblin\n---\n\n我们称一个排列是合法的，当且仅当每一个数都满足这个数比它相邻的数都要大或都要小。\n\n求长度为 $ N $ 的合法排列数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1925](http://www.lydsy.com/JudgeOnline/problem.php?id=1925)\n\n### 题解\n题目相当于要求 $ 0 $ ~ $ n - 1 $ 的合法排列数。\n\n设 $ f(i,\\ j) $ 表示 $ 0 $ ~ $ i $ 的排列，第一个数为 $ j $（$ j \\leq i $），**且第二个数比第一个数小**的方案数。\n\n考虑第二个数，当第二个数**小于** $ j - 1 $ 时，其方案数为第一个数为 $ j - 1 $ 时的方案数，即 $ f(i,\\ j - 1) $。  \n当第二个数**等于** $ j - 1 $ 时，从第二个数开始，是一个 $ 0 $ ~ $ i - 1 $ 的排列，这个排列的第二个数比第一个数**大**。如果将每个数 $ x $ 变成 $ (i - 1) - x $，那么就变成原有的第二个数比第一个数小的情况了。即 $ f(i - 1,\\ (i - 1) - (j - 1)) $。\n\n所以转移方程为 $ f(i,\\ j) = f(i,\\ j - 1) + f(i - 1, i - j) $。\n\n答案为 $ 2 \\sum\\limits_{i = 0} ^ {n - 1} f(n - 1,\\ i) $，因为要考虑第二个数**大于**第一个数的方案数所以乘 $ 2 $。\n\n### 代码\n不使用滚动数组，内存 30M+ 是可以过的。\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\nint _f[MAXN * (MAXN + 1) / 2];\nint *f[MAXN + 1];\n\ninline void init() {\n\tint *curr = _f;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i] = curr;\n\t\tcurr += i + 1;\n\t}\n\t// printf(\"%ld %d\\n\", curr - _f, n * (n + 1) / 2);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\tinit();\n\n\tf[1][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p;\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[n - 1][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n\n使用滚动数组之后，时间也快不少。\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\n\tstatic int f[2][MAXN];\n\tf[1 % 2][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[(n - 1) % 2][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-goblin","published":1,"updated":"2016-06-20T07:50:35.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rg800e5ooxlwalebfg2"},{"title":"「SDOI2009」晨跑 - 费用流","date":"2016-06-21T12:24:00.000Z","_content":"\n现在给出一张地图，地图中包含 $ N $ 个十字路口和 $ M $ 条街道，Elaxia 只能从一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $ 1 $，学校编号为 $ N $。 Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。  \n他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1877](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)\n\n### 题解\n将每个点拆成两个点，中间设置 $ 1 $ 的流量限制，求出最小费用最大流，费用为路程，流量为天数。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\t// printf(\"%d %d\\n\", f, c);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->d > v->d + e->w && e->f < e->c) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\t// printf(\"[%ld, %ld]\\n\", e->s - N, e->t - N);\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1, 0);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\taddEdge(u + n, v, 1, w);\n\t}\n\n\taddEdge(s, 1 + n, INT_MAX, 0);\n\taddEdge(n, t, INT_MAX, 0);\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tprintf(\"%d %d\\n\", f, c);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2009-run.md","raw":"title: 「SDOI2009」晨跑 - 费用流\ndate: 2016-06-21 20:24:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\npermalink: sdoi2009-run\n---\n\n现在给出一张地图，地图中包含 $ N $ 个十字路口和 $ M $ 条街道，Elaxia 只能从一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $ 1 $，学校编号为 $ N $。 Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。  \n他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1877](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)\n\n### 题解\n将每个点拆成两个点，中间设置 $ 1 $ 的流量限制，求出最小费用最大流，费用为路程，流量为天数。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\t// printf(\"%d %d\\n\", f, c);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->d > v->d + e->w && e->f < e->c) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\t// printf(\"[%ld, %ld]\\n\", e->s - N, e->t - N);\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1, 0);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\taddEdge(u + n, v, 1, w);\n\t}\n\n\taddEdge(s, 1 + n, INT_MAX, 0);\n\taddEdge(n, t, INT_MAX, 0);\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tprintf(\"%d %d\\n\", f, c);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2009-run","published":1,"updated":"2016-06-21T12:24:51.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgb00eaooxla477j5s2"},{"title":"「SDOI2008」校门外的区间 - 线段树","date":"2016-09-02T13:07:00.000Z","_content":"\n受校门外的树这道经典问题的启发，A 君根据基本的离散数学的知识，抽象出 $ 5 $ 种运算维护集合 $ S $（$ S $初始为空）并最终输出 $ S $。现在，请你完成这道校门外的树之难度增强版 —— 校门外的区间。\n\n$ 5 $ 种运算如下：\n\n1. $ A = A \\cup B $；\n2. $ A = A \\cap B $\n3. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} $\n4. $ A = \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n5. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} \\cup \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n\n<!-- more -->\n\n### 链接\n[BZOJ 3226](http://www.lydsy.com/JudgeOnline/problem.php?id=3226)\n\n### 题解\n比较容易想到，用线段树维护区间。因为区间端点均为整数，所以对于开区间 $ (a, b) $，可以转化为闭区间 $ [a + 0.5, b - 0.5] $，再两端点同时 $ \\times 2 $，得到 $ [2a + 1, 2b - 1] $。\n\n对于每种操作：\n\n1. 对 $ B $ 区间置 $ 1 $；\n2. 对非 $ B $ 区间置 $ 0 $；\n3. 对 $ B $ 区间置 $ 0 $；\n4. 反转整个序列，并将非 $ B $ 区间置 $ 0 $；\n5. 反转 $ B $ 区间。\n\n这两种标记是可以合并的：置 $ 0 $ 和置 $ 1 $ 可以替换任何标记，反转叠加在置 $ 0 $ 上变成置 $ 1 $，叠加在置 $ 1 $ 上变成置 $ 0 $，反转互相叠加可以抵销。\n\n查询时，从根到叶子找到第一个置 $ 0 $ 或置 $ 1 $，并记录路径上反转标记的数量。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 65535;\nconst int MAXM = 70000;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tenum TagType {\n\t\tZero, One, Reverse, None\n\t} tag;\n\tbool val;\n\n\tSegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {}\n\n\tvoid setTag(const TagType t) {\n\t\tif (t == Reverse) {\n\t\t\tif (l == r) val ^= 1;\n\t\t\telse {\n\t\t\t\tif (tag == Reverse) tag = None;\n\t\t\t\telse if (tag == Zero) tag = One;\n\t\t\t\telse if (tag == One) tag = Zero;\n\t\t\t\telse tag = Reverse;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l == r) val = t == One;\n\t\t\telse tag = t;\n\t\t}\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag != None) {\n\t\t\tlc->setTag(tag);\n\t\t\trc->setTag(tag);\n\t\t\ttag = None;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const TagType t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) setTag(t);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, t);\n\t\t\trc->update(l, r, t);\n\t\t}\n\t}\n\n\tbool query(const int pos) {\n\t\tSegmentTree *v = this;\n\t\tbool rev = false;\n\t\twhile (!(v->l == v->r || v->tag == Zero || v->tag == One)) {\n\t\t\tif (v->tag == Reverse) rev ^= 1;\n\t\t\tv = (pos <= v->mid) ? v->lc : v->rc;\n\t\t}\n\t\tif (v->tag == Zero) v->val = false;\n\t\telse if (v->tag == One) v->val = true;\n\t\treturn rev ? v->val ^ 1 : v->val;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, l, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\t/*\n\tstatic bool a[MAXN * 2 + 1];\n\n\tstatic void update(const int l, const int r, const TagType t) {\n\t\tif (l > r) return;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (t == Zero) a[i] = false;\n\t\t\telse if (t == One) a[i] = true;\n\t\t\telse if (t == Reverse) a[i] ^= 1;\n\t\t}\n\t}\n\n\tstatic bool query(const int pos) { return a[pos]; }\n\n\tstatic SegmentTree *build(const int l, const int r) { return NULL; }\n\t*/\n} *segment;\n\n// bool SegmentTree::a[MAXN * 2 + 1];\n\ninline void parse(char *s, int &l, int &r) {\n\tchar ch;\n\tbool fl = false;\n\tch = *s++;\n\tif (ch == '(') fl = true;\n\tl = 0;\n\twhile ((ch = *s++) != ',') l = l * 10 + ch - '0';\n\tl *= 2;\n\tif (fl) l++;\n\tr = 0;\n\twhile ((ch = *s++), (ch >= '0' && ch <= '9')) r = r * 10 + ch - '0';\n\tr *= 2;\n\tif (ch == ')') r--;\n}\n\ninline void print() {\n\tint l = -1;\n\tbool flag = false;\n\tfor (int i = 0; i <= MAXN * 2; i++) {\n\t\tbool val = segment->query(i);\n\t\tif (l == -1 && val) {\n\t\t\tl = i;\n\t\t} else if (l != -1 && !val) {\n\t\t\tprintf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')');\n\t\t\tflag = true;\n\t\t\tl = -1;\n\t\t}\n\t}\n\tif (l != -1) printf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true;\n\tif (!flag) printf(\"empty set\");\n\tputchar('\\n');\n}\n\nint main() {\n\tsegment = SegmentTree::build(0, MAXN * 2);\n\tchar cmd[2], s[100];\n\twhile (~scanf(\"%s %s\", cmd, s)) {\n\t\tint l, r;\n\t\tparse(s, l, r);\n\t\t// printf(\"read: [%d, %d]\\n\", l, r);\n\n\t\tif (cmd[0] == 'U') {\n\t\t\tsegment->update(l, r, SegmentTree::One);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'D') {\n\t\t\tsegment->update(l, r, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tsegment->update(0, MAXN * 2, SegmentTree::Reverse);\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'S') {\n\t\t\tsegment->update(l, r, SegmentTree::Reverse);\n\t\t}\n\n\t\t// print();\n\t}\n\n\tprint();\n\n\treturn 0;\n}\n```","source":"_posts/sdoi2008-interval.md","raw":"title: 「SDOI2008」校门外的区间 - 线段树\ndate: 2016-09-02 21:07:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - 数据结构\n  - 线段树\npermalink: sdoi2008-interval\n---\n\n受校门外的树这道经典问题的启发，A 君根据基本的离散数学的知识，抽象出 $ 5 $ 种运算维护集合 $ S $（$ S $初始为空）并最终输出 $ S $。现在，请你完成这道校门外的树之难度增强版 —— 校门外的区间。\n\n$ 5 $ 种运算如下：\n\n1. $ A = A \\cup B $；\n2. $ A = A \\cap B $\n3. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} $\n4. $ A = \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n5. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} \\cup \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n\n<!-- more -->\n\n### 链接\n[BZOJ 3226](http://www.lydsy.com/JudgeOnline/problem.php?id=3226)\n\n### 题解\n比较容易想到，用线段树维护区间。因为区间端点均为整数，所以对于开区间 $ (a, b) $，可以转化为闭区间 $ [a + 0.5, b - 0.5] $，再两端点同时 $ \\times 2 $，得到 $ [2a + 1, 2b - 1] $。\n\n对于每种操作：\n\n1. 对 $ B $ 区间置 $ 1 $；\n2. 对非 $ B $ 区间置 $ 0 $；\n3. 对 $ B $ 区间置 $ 0 $；\n4. 反转整个序列，并将非 $ B $ 区间置 $ 0 $；\n5. 反转 $ B $ 区间。\n\n这两种标记是可以合并的：置 $ 0 $ 和置 $ 1 $ 可以替换任何标记，反转叠加在置 $ 0 $ 上变成置 $ 1 $，叠加在置 $ 1 $ 上变成置 $ 0 $，反转互相叠加可以抵销。\n\n查询时，从根到叶子找到第一个置 $ 0 $ 或置 $ 1 $，并记录路径上反转标记的数量。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 65535;\nconst int MAXM = 70000;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tenum TagType {\n\t\tZero, One, Reverse, None\n\t} tag;\n\tbool val;\n\n\tSegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {}\n\n\tvoid setTag(const TagType t) {\n\t\tif (t == Reverse) {\n\t\t\tif (l == r) val ^= 1;\n\t\t\telse {\n\t\t\t\tif (tag == Reverse) tag = None;\n\t\t\t\telse if (tag == Zero) tag = One;\n\t\t\t\telse if (tag == One) tag = Zero;\n\t\t\t\telse tag = Reverse;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l == r) val = t == One;\n\t\t\telse tag = t;\n\t\t}\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag != None) {\n\t\t\tlc->setTag(tag);\n\t\t\trc->setTag(tag);\n\t\t\ttag = None;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const TagType t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) setTag(t);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, t);\n\t\t\trc->update(l, r, t);\n\t\t}\n\t}\n\n\tbool query(const int pos) {\n\t\tSegmentTree *v = this;\n\t\tbool rev = false;\n\t\twhile (!(v->l == v->r || v->tag == Zero || v->tag == One)) {\n\t\t\tif (v->tag == Reverse) rev ^= 1;\n\t\t\tv = (pos <= v->mid) ? v->lc : v->rc;\n\t\t}\n\t\tif (v->tag == Zero) v->val = false;\n\t\telse if (v->tag == One) v->val = true;\n\t\treturn rev ? v->val ^ 1 : v->val;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, l, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\t/*\n\tstatic bool a[MAXN * 2 + 1];\n\n\tstatic void update(const int l, const int r, const TagType t) {\n\t\tif (l > r) return;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (t == Zero) a[i] = false;\n\t\t\telse if (t == One) a[i] = true;\n\t\t\telse if (t == Reverse) a[i] ^= 1;\n\t\t}\n\t}\n\n\tstatic bool query(const int pos) { return a[pos]; }\n\n\tstatic SegmentTree *build(const int l, const int r) { return NULL; }\n\t*/\n} *segment;\n\n// bool SegmentTree::a[MAXN * 2 + 1];\n\ninline void parse(char *s, int &l, int &r) {\n\tchar ch;\n\tbool fl = false;\n\tch = *s++;\n\tif (ch == '(') fl = true;\n\tl = 0;\n\twhile ((ch = *s++) != ',') l = l * 10 + ch - '0';\n\tl *= 2;\n\tif (fl) l++;\n\tr = 0;\n\twhile ((ch = *s++), (ch >= '0' && ch <= '9')) r = r * 10 + ch - '0';\n\tr *= 2;\n\tif (ch == ')') r--;\n}\n\ninline void print() {\n\tint l = -1;\n\tbool flag = false;\n\tfor (int i = 0; i <= MAXN * 2; i++) {\n\t\tbool val = segment->query(i);\n\t\tif (l == -1 && val) {\n\t\t\tl = i;\n\t\t} else if (l != -1 && !val) {\n\t\t\tprintf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')');\n\t\t\tflag = true;\n\t\t\tl = -1;\n\t\t}\n\t}\n\tif (l != -1) printf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true;\n\tif (!flag) printf(\"empty set\");\n\tputchar('\\n');\n}\n\nint main() {\n\tsegment = SegmentTree::build(0, MAXN * 2);\n\tchar cmd[2], s[100];\n\twhile (~scanf(\"%s %s\", cmd, s)) {\n\t\tint l, r;\n\t\tparse(s, l, r);\n\t\t// printf(\"read: [%d, %d]\\n\", l, r);\n\n\t\tif (cmd[0] == 'U') {\n\t\t\tsegment->update(l, r, SegmentTree::One);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'D') {\n\t\t\tsegment->update(l, r, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tsegment->update(0, MAXN * 2, SegmentTree::Reverse);\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'S') {\n\t\t\tsegment->update(l, r, SegmentTree::Reverse);\n\t\t}\n\n\t\t// print();\n\t}\n\n\tprint();\n\n\treturn 0;\n}\n```","slug":"sdoi2008-interval","published":1,"updated":"2016-09-02T13:38:18.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rge00ehooxlqzn0kp06"},{"title":"「SDOI2008」洞穴勘测 - Link-Cut Tree","date":"2016-03-15T12:06:34.000Z","_content":"\n如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间出现了一条通道，终端机上会显示一条指令 `Connect u v`；如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间的通道被毁，终端机上会显示一条指令 `Destroy u v`。辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $ u $ 和洞穴 $ v $ 是否连通。已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### 题解\n最简单的 Link-Cut Tree 模板题。\n\n相当于能拆的并查集。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/sdoi2008-cave.md","raw":"title: 「SDOI2008」洞穴勘测 - Link-Cut Tree \ndate: 2016-03-15 20:06:34\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - CodeVS\n  - 数据结构\n  - 高级数据结构\n  - 动态树\n  - Link-Cut Tree\npermalink: sdoi2008-cave\n---\n\n如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间出现了一条通道，终端机上会显示一条指令 `Connect u v`；如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间的通道被毁，终端机上会显示一条指令 `Destroy u v`。辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $ u $ 和洞穴 $ v $ 是否连通。已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### 题解\n最简单的 Link-Cut Tree 模板题。\n\n相当于能拆的并查集。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"sdoi2008-cave","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgi00enooxlb04gdz9k"},{"title":"「SCOI2015」小凸解密码 - set","date":"2016-03-25T00:53:27.000Z","_content":"\n给定一个环形数列 $ A $ 和运算符序列 $ C $，可以从任意一个位置作为起点计算 $ B $，方法为：\n\n1. $ B_0 = A_0 $；\n2. 当 $ C_x = + $ 时，$ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $；\n3. 当 $ C_x = * $ 时，$ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $；\n\n每次可以修改 $ A $ 和 $ C $ 中的某一个元素，询问以指定起点开始计算 $ B $ 得到的环形数列 $ B $ 中距离 $ B_0 $ 最远的零区间中距离 $ B_0 $ 最近的零的距离。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### 题解\n首先，可以发现在没有修改的情况下，指定的不同起点只是起点得到的值不同，我们先直接递推计算出 B，查询的时候修改 $ B_0 = A_0 $ 查询完改回去。一次修改只会影响两个位置（$ B_i $ 和 $ B_{i + 1} $）。\n\n所以问题转化为，维护一个环形零一串，每次修改一个位置，查询到某个位置的最近零区间。\n\n用 `set` 维护每一个零区间，然后各种分情况讨论 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-password.md","raw":"title: 「SCOI2015」小凸解密码 - set\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - set\n  - 乱搞\npermalink: scoi2015-password\ndate: 2016-03-25 08:53:27\n---\n\n给定一个环形数列 $ A $ 和运算符序列 $ C $，可以从任意一个位置作为起点计算 $ B $，方法为：\n\n1. $ B_0 = A_0 $；\n2. 当 $ C_x = + $ 时，$ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $；\n3. 当 $ C_x = * $ 时，$ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $；\n\n每次可以修改 $ A $ 和 $ C $ 中的某一个元素，询问以指定起点开始计算 $ B $ 得到的环形数列 $ B $ 中距离 $ B_0 $ 最远的零区间中距离 $ B_0 $ 最近的零的距离。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### 题解\n首先，可以发现在没有修改的情况下，指定的不同起点只是起点得到的值不同，我们先直接递推计算出 B，查询的时候修改 $ B_0 = A_0 $ 查询完改回去。一次修改只会影响两个位置（$ B_i $ 和 $ B_{i + 1} $）。\n\n所以问题转化为，维护一个环形零一串，每次修改一个位置，查询到某个位置的最近零区间。\n\n用 `set` 维护每一个零区间，然后各种分情况讨论 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-password","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgn00eyooxl34o2j4rb"},{"title":"「SCOI2015」情报传递 - 离线 + Link-Cut Tree","date":"2016-03-22T10:09:12.000Z","_content":"\n奈特公司有着庞大的情报网络。情报网络中共有 $ n $ 名情报员。每名情报员有若干名下线，除 1 名大头目外其余 $ n - 1 $ 名情报员有且仅有 1 名上线。每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $ T $ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $ X $ 号情报员传递给 $ Y $ 号情报员。\n\n情报员最初处于潜伏阶段，危险值为 0；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 1 点危险值（开始搜集情报的当天危险值仍为 0，第 2 天危险值为 1，以此类推）。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $ C $。公司认为，传递这条情报的所有情报员中，危险值大于 $ C $ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### 题解\n因为整个网络是一棵树，所以可以用一棵 Link-Cut Tree 来维护。\n\n前 30 分，无修改操作，直接求出两点距离。\n\n30 ~ 60 分，保证 $ C = 0 $，修改直接单点修改值为 1，查询直接查询有多少 1 即可。\n\n后 40 分，考虑到对于每个查询操作，只有距离它 $ C + 1 $ 天之前的修改操作对它有贡献，所以可以将操作离线，保证每次修改后直接处理查询即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-message.md","raw":"title: 「SCOI2015」情报传递 - 离线 + Link-Cut Tree\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - 离线\n  - Link-Cut Tree\n  - 数据结构\n  - 高级数据结构\npermalink: scoi2015-message\ndate: 2016-03-22 18:09:12\n---\n\n奈特公司有着庞大的情报网络。情报网络中共有 $ n $ 名情报员。每名情报员有若干名下线，除 1 名大头目外其余 $ n - 1 $ 名情报员有且仅有 1 名上线。每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $ T $ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $ X $ 号情报员传递给 $ Y $ 号情报员。\n\n情报员最初处于潜伏阶段，危险值为 0；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 1 点危险值（开始搜集情报的当天危险值仍为 0，第 2 天危险值为 1，以此类推）。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $ C $。公司认为，传递这条情报的所有情报员中，危险值大于 $ C $ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### 题解\n因为整个网络是一棵树，所以可以用一棵 Link-Cut Tree 来维护。\n\n前 30 分，无修改操作，直接求出两点距离。\n\n30 ~ 60 分，保证 $ C = 0 $，修改直接单点修改值为 1，查询直接查询有多少 1 即可。\n\n后 40 分，考虑到对于每个查询操作，只有距离它 $ C + 1 $ 天之前的修改操作对它有贡献，所以可以将操作离线，保证每次修改后直接处理查询即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-message","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgu00f8ooxlekr1ehvn"},{"title":"「SCOI2015」小凸玩矩阵 - 二分图匹配","date":"2016-03-22T09:56:34.000Z","_content":"\n小方给小凸一个 $ N * M $（$ N \\leq M $）的矩阵 $ A $，要求小秃从其中选出 $ N $个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的 $ N $ 个数中第 $ K $ 大的数字的最小值是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### 题解\n二分第 $ K $ 大的数是多少，然后建二分图，用行匹配列，检验匹配数是不是大于等于 $ N - K + 1 $。\n\n注意，是第 $ K $ 大，不是第 $ K $ 小！\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-matrix.md","raw":"title: 「SCOI2015」小凸玩矩阵 - 二分图匹配\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - 二分答案\n  - 二分图匹配\n  - 网络流\n  - Dinic\npermalink: scoi2015-matrix\ndate: 2016-03-22 17:56:34\n---\n\n小方给小凸一个 $ N * M $（$ N \\leq M $）的矩阵 $ A $，要求小秃从其中选出 $ N $个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的 $ N $ 个数中第 $ K $ 大的数字的最小值是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### 题解\n二分第 $ K $ 大的数是多少，然后建二分图，用行匹配列，检验匹配数是不是大于等于 $ N - K + 1 $。\n\n注意，是第 $ K $ 大，不是第 $ K $ 小！\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-matrix","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgy00fhooxl3k6h71qd"},{"title":"「SCOI2015」小凸玩密室 - 树形 DP","date":"2016-03-23T15:16:05.000Z","_content":"\n密室是一棵有 $ n $ 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。每个灯泡有个权值 $ A_i $，每条边也有个权值 $ B_i $。点亮第 $ 1 $ 个灯泡不需要花费，之后每点亮 $ 1 $ 个新的灯泡 $ V $ 的花费，等于上一个被点亮的灯泡 $ U $ 到这个点 $ V $ 的距离 $ D_{u, v} $，乘以这个点的权值 $ A_v $。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。请告诉他们，逃出密室的最少花费是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### 题解\n动态规划，用 $ f_{x, i} $ 表示走完 $ x $ 及其子树再走到其第 $ i $ 层祖先的另一个孩子的最小代价。\n\n\n当 $ x $ 为叶子节点时，直接走过去\n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n当 $ x $ 只有左儿子时，先走到左孩子，再从左孩子走过去\n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n当 $ x $ 既有左儿子，又有右儿子时，考虑先走哪个最优\n\n另一个 DP：$ g_{x, i} $ 表示走完 $ x $ 及其子树再走到其第 $ i $ 层祖先的最小代价。\n\n当 $ x $ 为叶子节点时，直接走过去\n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n当 $ x $ 只有左儿子时，先走到左孩子，再从左孩子走过去\n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n当 $ x $ 既有左儿子，又有右儿子时，考虑先走哪个最优\n\n\n状态表示中，$ i = 0 $ 表示停在任意位置，因为计算 $ {\\rm dist} $ 的时候任何一个点走到 $ 0 $ 的花费都是 $ 0 $。\n\n枚举从哪个点开始，如果从根开始，答案为 $ g_{1, 0} $，否则先走自己，再走兄弟，再走父亲，再走父亲的兄弟的顺序，直到走到根，取所有答案的最小值。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-light.md","raw":"title: 「SCOI2015」小凸玩密室 - 树形 DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - DP\n  - 树形 DP\npermalink: scoi2015-light\ndate: 2016-03-23 23:16:05\n---\n\n密室是一棵有 $ n $ 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。每个灯泡有个权值 $ A_i $，每条边也有个权值 $ B_i $。点亮第 $ 1 $ 个灯泡不需要花费，之后每点亮 $ 1 $ 个新的灯泡 $ V $ 的花费，等于上一个被点亮的灯泡 $ U $ 到这个点 $ V $ 的距离 $ D_{u, v} $，乘以这个点的权值 $ A_v $。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。请告诉他们，逃出密室的最少花费是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### 题解\n动态规划，用 $ f_{x, i} $ 表示走完 $ x $ 及其子树再走到其第 $ i $ 层祖先的另一个孩子的最小代价。\n\n\n当 $ x $ 为叶子节点时，直接走过去\n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n当 $ x $ 只有左儿子时，先走到左孩子，再从左孩子走过去\n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n当 $ x $ 既有左儿子，又有右儿子时，考虑先走哪个最优\n\n另一个 DP：$ g_{x, i} $ 表示走完 $ x $ 及其子树再走到其第 $ i $ 层祖先的最小代价。\n\n当 $ x $ 为叶子节点时，直接走过去\n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n当 $ x $ 只有左儿子时，先走到左孩子，再从左孩子走过去\n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n当 $ x $ 既有左儿子，又有右儿子时，考虑先走哪个最优\n\n\n状态表示中，$ i = 0 $ 表示停在任意位置，因为计算 $ {\\rm dist} $ 的时候任何一个点走到 $ 0 $ 的花费都是 $ 0 $。\n\n枚举从哪个点开始，如果从根开始，答案为 $ g_{1, 0} $，否则先走自己，再走兄弟，再走父亲，再走父亲的兄弟的顺序，直到走到根，取所有答案的最小值。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-light","published":1,"updated":"2016-10-24T23:31:27.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rh300frooxlgpbhevex"},{"title":"「SCOI2015」国旗计划 - 贪心 + 倍增","date":"2016-03-22T10:25:14.000Z","_content":"\nA 国幅员辽阔，边境线上设有 $ M $ 个边防站，顺时针编号 $ 1 $ 至 $ M $。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。每名战士的奔袭区间都不会被其他战士的奔袭区间所包含。\n\n现在，局长希望知道，至少需要多少名战士，才能使得他们的奔袭区间覆盖全部的边境线。局长还希望知道对于每一名战士，在他必须参加国旗计划的前提下，至少需要多少名战士才能覆盖全部边境线。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### 题解\n首先，明确一个贪心的思路：对于任何一个战士，选择他后要选择的下一个，一定是在他后面并且与他奔袭区间交集最小的（因为所有的区间完全覆盖并且没有相互包含）。\n\n把所有区间翻倍存储，以左端点排序。\n\n40 分：枚举每个战士，在他之后的所有战士中确定一个与他奔袭区间交集最小的，作为他的下一个（时间复杂度 $ O(n ^ 2) $）；然后对于每个询问从该战士开始不断找下一个战士，直到找回来为止；\n\n70 分：把找「下一个战士」的复杂度优化为 $ O(n \\log n) $，使用 `std::upper_bound`，用当前战士的区间右端点和其他区间的左端点比较，返回的结果 -1 即为要找的「下一个战士」。\n\n100 分：思考回答询问时的过程，每次线性地向后扫描做了很多重复的工作，考虑到无论从那个战士出发，经过的相同位置向后的路线都是相同的，所以可以先 $ O(n \\log n) $ 地预处理出一个稀疏表，用 $ next_{i, j} $ 表示战士 $ i $ 向后找 $ 2 ^ j $ 次所到达的战士，然后就可以 $ O(\\log n) $ 地回答每个询问了。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-flag.md","raw":"title: 「SCOI2015」国旗计划 - 贪心 + 倍增\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - 贪心\n  - 倍增\npermalink: scoi2015-flag\ndate: 2016-03-22 18:25:14\n---\n\nA 国幅员辽阔，边境线上设有 $ M $ 个边防站，顺时针编号 $ 1 $ 至 $ M $。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。每名战士的奔袭区间都不会被其他战士的奔袭区间所包含。\n\n现在，局长希望知道，至少需要多少名战士，才能使得他们的奔袭区间覆盖全部的边境线。局长还希望知道对于每一名战士，在他必须参加国旗计划的前提下，至少需要多少名战士才能覆盖全部边境线。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### 题解\n首先，明确一个贪心的思路：对于任何一个战士，选择他后要选择的下一个，一定是在他后面并且与他奔袭区间交集最小的（因为所有的区间完全覆盖并且没有相互包含）。\n\n把所有区间翻倍存储，以左端点排序。\n\n40 分：枚举每个战士，在他之后的所有战士中确定一个与他奔袭区间交集最小的，作为他的下一个（时间复杂度 $ O(n ^ 2) $）；然后对于每个询问从该战士开始不断找下一个战士，直到找回来为止；\n\n70 分：把找「下一个战士」的复杂度优化为 $ O(n \\log n) $，使用 `std::upper_bound`，用当前战士的区间右端点和其他区间的左端点比较，返回的结果 -1 即为要找的「下一个战士」。\n\n100 分：思考回答询问时的过程，每次线性地向后扫描做了很多重复的工作，考虑到无论从那个战士出发，经过的相同位置向后的路线都是相同的，所以可以先 $ O(n \\log n) $ 地预处理出一个稀疏表，用 $ next_{i, j} $ 表示战士 $ i $ 向后找 $ 2 ^ j $ 次所到达的战士，然后就可以 $ O(\\log n) $ 地回答每个询问了。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-flag","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rh800fzooxlezmphpdp"},{"title":"「SCOI2012」喵星球上的点名 - AC 自动机","date":"2016-09-29T13:26:00.000Z","_content":"\n假设课堂上有 $ N $ 个喵星人，每个喵星人的名字由姓和名构成。喵星球上的老师会选择 $ M $ 个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的子串，那么这个喵星人就必须答到。\n\n统计每次点名的时候有多少喵星人答到，以及 $ M $ 次点名结束后每个喵星人答到多少次。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2754](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n\n### 题解\n对点名串建立 AC 自动机，用姓名串暴力跑后缀链接即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","source":"_posts/scoi2012-name.md","raw":"title: 「SCOI2012」喵星球上的点名 - AC 自动机\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 字符串\n  - AC 自动机\npermalink: scoi2012-name\ndate: 2016-09-29 21:26:00\n---\n\n假设课堂上有 $ N $ 个喵星人，每个喵星人的名字由姓和名构成。喵星球上的老师会选择 $ M $ 个串来点名，每次读出一个串的时候，如果这个串是一个喵星人的姓或名的子串，那么这个喵星人就必须答到。\n\n统计每次点名的时候有多少喵星人答到，以及 $ M $ 次点名结束后每个喵星人答到多少次。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2754](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n\n### 题解\n对点名串建立 AC 自动机，用姓名串暴力跑后缀链接即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","slug":"scoi2012-name","published":1,"updated":"2016-09-29T13:28:38.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhb00g7ooxlkn1pigrh"},{"title":"「SCOI2011」糖果 - 强联通分量 + 拓扑排序","date":"2016-03-04T13:32:23.000Z","_content":"\n幼儿园里有 $ N $ 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。在分配糖果的时候，需要满足小朋友们的 $ K $ 个要求。幼儿园的糖果总是有限的，想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### 题解\n在满足题目的要求下，最优解一定是：最少的一个，比别人多也只多一个。很容易想到用查分约束系统来做。\n\n然而刚学了 Tarjan 就想乱搞搞，做法是，把所有关系转化为小于等于和小于两种，先把小于等于的边全部加进去，跑一遍 Tarjan，然后缩点，此时一个强联通分量上的小朋友糖果数是相同的。\n\n把小于的边再加上，进行拓扑排序，如果有环说明无解。把小于等于的边权值置为 0，小于的边权值置为 1，入度为零的点距离置为 1。求出所有最长路，每个点距离乘以该点小朋友的数量的和即为答案。\n\n注意开 `long long`。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2011-candy.md","raw":"title: 「SCOI2011」糖果 - 强联通分量 + 拓扑排序\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 强联通分量\n  - Tarjan\n  - 缩点\n  - 拓扑排序\n  - 差分约束系统\npermalink: scoi2011-candy\ndate: 2016-03-04 21:32:23\n---\n\n幼儿园里有 $ N $ 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。在分配糖果的时候，需要满足小朋友们的 $ K $ 个要求。幼儿园的糖果总是有限的，想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### 题解\n在满足题目的要求下，最优解一定是：最少的一个，比别人多也只多一个。很容易想到用查分约束系统来做。\n\n然而刚学了 Tarjan 就想乱搞搞，做法是，把所有关系转化为小于等于和小于两种，先把小于等于的边全部加进去，跑一遍 Tarjan，然后缩点，此时一个强联通分量上的小朋友糖果数是相同的。\n\n把小于的边再加上，进行拓扑排序，如果有环说明无解。把小于等于的边权值置为 0，小于的边权值置为 1，入度为零的点距离置为 1。求出所有最长路，每个点距离乘以该点小朋友的数量的和即为答案。\n\n注意开 `long long`。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","slug":"scoi2011-candy","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhe00gdooxlfqdkhbdw"},{"title":"「SCOI2010」游戏 - 二分图匹配","date":"2016-03-07T01:43:18.000Z","_content":"\n在游戏里，他拥有很多的装备，每种装备都有两个属性，这些属性的值用 $ [1, 10000] $ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 终极 BOSS 很奇怪，攻击他的装备所使用的属性值必须从 $ 1 $ 开始连续递增地攻击，才能对 BOSS 产生伤害。也就是说一开始的时候，只能使用某个属性值为 $ 1 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 2 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 3 $ 的装备攻击 BOSS …… 以此类推。他最多能连续攻击 BOSS 多少次？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### 题解\n看一下数据范围 $ N ≤ 1000000 $，如果枚举每件武器，肯定要 $ O(n) $ 的算法才能过，但又想不出 $ O(n) $ 的算法来 ……\n\n我们换一种思路，从属性值小到大，之间如果有一个数不能没有可用的武器，则不可能继续打出比这个数更大的属性值了。也就是说答案具有单调性，可以采用枚举答案并检验的方法。\n\n题目中并没有要求某个属性值要由特定的武器打出，所以说可以任意选择某个可用的武器来打出指定的属性值。\n\n从 $ 1 $ 开始，任选一个可打出 $ 1 $ 的武器并标记为使用过，枚举时如果发现能打出 $ X $ 的武器全部被用过了，就尝试将某一件属性值为 $ \\{X, Y\\} $ 武器标记为 $ X $，并寻找 $ Y $ 的替代（$ Y < X $），这样递归下去，直到某个属性值使用了一件没有被使用武器，则成功，否则失败。\n\n算法思想与『二分图匹配』中的匈牙利算法比较相似。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2010-game.md","raw":"title: 「SCOI2010」游戏 - 二分图匹配\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 图论\n  - 二分图匹配\n  - 匈牙利算法\n  - 枚举答案\npermalink: scoi2010-game\ndate: 2016-03-07 09:43:18\n---\n\n在游戏里，他拥有很多的装备，每种装备都有两个属性，这些属性的值用 $ [1, 10000] $ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 终极 BOSS 很奇怪，攻击他的装备所使用的属性值必须从 $ 1 $ 开始连续递增地攻击，才能对 BOSS 产生伤害。也就是说一开始的时候，只能使用某个属性值为 $ 1 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 2 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 3 $ 的装备攻击 BOSS …… 以此类推。他最多能连续攻击 BOSS 多少次？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### 题解\n看一下数据范围 $ N ≤ 1000000 $，如果枚举每件武器，肯定要 $ O(n) $ 的算法才能过，但又想不出 $ O(n) $ 的算法来 ……\n\n我们换一种思路，从属性值小到大，之间如果有一个数不能没有可用的武器，则不可能继续打出比这个数更大的属性值了。也就是说答案具有单调性，可以采用枚举答案并检验的方法。\n\n题目中并没有要求某个属性值要由特定的武器打出，所以说可以任意选择某个可用的武器来打出指定的属性值。\n\n从 $ 1 $ 开始，任选一个可打出 $ 1 $ 的武器并标记为使用过，枚举时如果发现能打出 $ X $ 的武器全部被用过了，就尝试将某一件属性值为 $ \\{X, Y\\} $ 武器标记为 $ X $，并寻找 $ Y $ 的替代（$ Y < X $），这样递归下去，直到某个属性值使用了一件没有被使用武器，则成功，否则失败。\n\n算法思想与『二分图匹配』中的匈牙利算法比较相似。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","slug":"scoi2010-game","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhn00gnooxl5rbwdn1f"},{"title":"「SCOI2009」windy 数 - 数位 DP","date":"2016-05-12T09:25:00.000Z","_content":"\nwindy 定义了一种 windy 数。不含前导零且相邻两个数字之差至少为 $ 2 $ 的正整数被称为 windy 数。\n\nwindy 想知道，在 $ A $ 和 $ B $ 之间，包括 $ A $ 和 $ B $，总共有多少个 windy 数？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### 题解\n数位 DP，设\n\n$$ f[n][last][notZero][limited] $$\n\n表示最后 $ n $ 位数，这 $ n $ 位数的前一位数是 $ last $，之前是否有非零数（如果前面全是零则不考虑差分限制），是否达到上界，的总数量。\n\nPS：不允许有前导零的实现方式是，允许前导零，但不对前导零设置限制。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","source":"_posts/scoi2009-windy.md","raw":"title: 「SCOI2009」windy 数 - 数位 DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 数位 DP\n  - DP\npermalink: scoi2009-windy\ndate: 2016-05-12 17:25:00\n---\n\nwindy 定义了一种 windy 数。不含前导零且相邻两个数字之差至少为 $ 2 $ 的正整数被称为 windy 数。\n\nwindy 想知道，在 $ A $ 和 $ B $ 之间，包括 $ A $ 和 $ B $，总共有多少个 windy 数？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### 题解\n数位 DP，设\n\n$$ f[n][last][notZero][limited] $$\n\n表示最后 $ n $ 位数，这 $ n $ 位数的前一位数是 $ last $，之前是否有非零数（如果前面全是零则不考虑差分限制），是否达到上界，的总数量。\n\nPS：不允许有前导零的实现方式是，允许前导零，但不对前导零设置限制。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","slug":"scoi2009-windy","published":1,"updated":"2016-10-24T23:30:33.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhs00gxooxlkf7c3f5g"},{"title":"「SCOI2009」粉刷匠 - 背包 DP","date":"2016-07-11T14:59:00.000Z","_content":"\nwindy 有 $ N $ 条木板需要被粉刷。每条木板被分为 $ M $ 个格子。 每个格子要被刷成红色或蓝色。 windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。每个格子最多只能被粉刷一次。如果 windy 只能粉刷 $ T $ 次，他最多能正确粉刷多少格子？\n\n一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1296](http://www.lydsy.com/JudgeOnline/problem.php?id=1296)\n\n### 题解\n对于每一行，用 $ f(j, k) $ 表示前 $ j $ 个格子刷 $ k $ 次的最大正确数量。枚举最后一次刷的区间，刷较多的颜色。\n\n用 $ w(i, j) $ 表示第 $ i $ 行刷 $ j $ 次的最大正确数量。最后用背包求解即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXT = 2500;\n\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\n\tstatic int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tstatic char s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\tint cnt[2] = { 0, 0 };\n\t\t\t\tfor (int l = j - 1; l >= k - 1; l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tf[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1]));\n\t\t\t\t\tw[i][k] = std::max(w[i][k], f[j][k]);\n\t\t\t\t}\n\t\t\t\t// printf(\"f[%d][%d][%d] = %d\\n\", i, j, k, f[j][k]);\n\t\t\t}\n\t\t}\n\n\t\t// for (int j = 1; j <= m; j++) printf(\"w[%d][%d] = %d\\n\", i, j, w[i][j]);\n\t}\n\n\tstatic int g[MAXT + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = t; j >= 0; j--) {\n\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\tif (k <= j) g[j] = std::max(g[j], g[j - k] + w[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[t]);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2009-paint.md","raw":"title: 「SCOI2009」粉刷匠 - 背包 DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - DP\n  - 背包 DP\npermalink: scoi2009-paint\ndate: 2016-07-11 22:59:00\n---\n\nwindy 有 $ N $ 条木板需要被粉刷。每条木板被分为 $ M $ 个格子。 每个格子要被刷成红色或蓝色。 windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。每个格子最多只能被粉刷一次。如果 windy 只能粉刷 $ T $ 次，他最多能正确粉刷多少格子？\n\n一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1296](http://www.lydsy.com/JudgeOnline/problem.php?id=1296)\n\n### 题解\n对于每一行，用 $ f(j, k) $ 表示前 $ j $ 个格子刷 $ k $ 次的最大正确数量。枚举最后一次刷的区间，刷较多的颜色。\n\n用 $ w(i, j) $ 表示第 $ i $ 行刷 $ j $ 次的最大正确数量。最后用背包求解即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXT = 2500;\n\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\n\tstatic int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tstatic char s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\tint cnt[2] = { 0, 0 };\n\t\t\t\tfor (int l = j - 1; l >= k - 1; l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tf[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1]));\n\t\t\t\t\tw[i][k] = std::max(w[i][k], f[j][k]);\n\t\t\t\t}\n\t\t\t\t// printf(\"f[%d][%d][%d] = %d\\n\", i, j, k, f[j][k]);\n\t\t\t}\n\t\t}\n\n\t\t// for (int j = 1; j <= m; j++) printf(\"w[%d][%d] = %d\\n\", i, j, w[i][j]);\n\t}\n\n\tstatic int g[MAXT + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = t; j >= 0; j--) {\n\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\tif (k <= j) g[j] = std::max(g[j], g[j - k] + w[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[t]);\n\n\treturn 0;\n}\n```\n","slug":"scoi2009-paint","published":1,"updated":"2016-10-24T23:30:41.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhv00h3ooxl3lmr2y96"},{"title":"「SCOI2009」游戏 - 群论 + 背包 DP","date":"2016-11-13T00:24:00.000Z","_content":"\nwindy 学会了一种游戏。对于 $ 1 $ 到 $ N $ 这 $ N $ 个数字，都有唯一且不同的 $ 1 $ 到 $ N $ 的数字与之对应。最开始 windy 把数字按顺序 $ 1, 2, 3, \\ldots, N $ 写一排在纸上。然后再在这一排下面写上它们对应的数字。然后又在新的一排下面写上它们对应的数字。如此反复，直到序列再次变为 $ 1, 2, 3, \\ldots, N $。\n\n如：$ 1, 2, 3, 4, 5, 6 $ 对应的关系为\n\n$$\n\\begin{cases}\n1 \\rightarrow 2 \\\\\n2 \\rightarrow 3 \\\\\n3 \\rightarrow 1 \\\\\n4 \\rightarrow 5 \\\\\n5 \\rightarrow 4 \\\\\n6 \\rightarrow 6\n\\end{cases}\n$$\n\nwindy 的操作如下：\n\n$$\n\\begin{gather}\n1, 2, 3, 4, 5, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 5, 4, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 4, 5, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 5, 4, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 4, 5, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 5, 4, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 4, 5, 6\n\\end{gather}\n$$\n\n这时，我们就有若干排 $ 1 $ 到 $ N $ 的排列，上例中有 $ 7 $ 排。现在 windy 想知道，对于所有可能的对应关系，有多少种可能的排数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025)\n\n### 题解\n对于一个置换，我们可以将其分解为若干个循环，问题中的「排数」即为这些循环长度的最小公倍数。设这些循环长度分别为\n\n$$ \\{ x_1, x_2, \\ldots, x_m \\} $$\n\n对于某个 $ x_k $ 的一个质因子 $ p $，它对 $ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) $ 有贡献，当且仅当 $ p $ 在 $ x_k $ 的唯一分解式中的次数是所有 $ x_i $ 中最大的。\n\n为了便于统计，我们只考虑每个 $ x_i $ 都是不同的质数的幂的情况（暂不考虑 $ x_i = 1 $ 的情况）\n\n$$\n\\begin{cases}\nx_1 = p_1 ^ {k_1} \\\\\nx_2 = p_2 ^ {k_2} \\\\\n\\cdots \\\\\nx_m = p_m ^ {k_m}\n\\end{cases}\n$$\n\n这种情况下，$ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) = x_1 \\times x_2 \\times \\ldots \\times x_m $。而 $ \\{ x_1. x_2, \\ldots, x_m \\} $ 是一组合法的循环长度，当且仅当 $ x_1 + x_2 + \\ldots + x_m = n $。因为我们可以任意添加长度为 $ 1 $ 的循环，而不对其最小公倍数产生影响，所以 $ x_1 + x_2 + \\ldots + x_m \\leq n $ 即为合法方案。\n\n现在的问题变成，有一些质数 $ p_i $，每个质数可以不选，也可以选择一个特定的幂 $ p_i ^ {k_i} $。要求最终选择的所有数之和 $ \\leq n $，求方案总数。这个问题可以转化为分组背包的方案计数问题 —— 第 $ i $ 组物品体积为 $ p_i ^ 1, p_i ^ 2, \\ldots p_i ^ {k_i} $（$ p_i ^ {k_i} \\leq n $），背包容量为 $ n $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\n\nint primes[MAXN], isNotPrime[MAXN + 1], cnt;\n\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * primes[j] <= MAXN; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n\t// for (int i = 0; i < cnt; i++) printf(\"%d\\n\", primes[i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tgetPrimes();\n\n\tstatic long long f[MAXN + 1][MAXN + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int k = 0; k <= n; k++) f[i][k] = f[i - 1][k];\n\t\tfor (int p = primes[i]; p <= n; p *= primes[i]) {\n\t\t\tfor (int k = p; k <= n; k++) {\n\t\t\t\tf[i][k] += f[i - 1][k - p];\n\t\t\t}\n\t\t}\n\t\t// for (int k = 0; k <= n; k++) printf(\"f[%d][%d] = %d\\n\", i, k, f[i][k]);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) ans += f[cnt][i];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2009-game.md","raw":"title: 「SCOI2009」游戏 - 群论 + 背包 DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 数学\n  - 群论\n  - 背包 DP\n  - DP\npermalink: scoi2009-game\ndate: 2016-11-13 08:24:00\n---\n\nwindy 学会了一种游戏。对于 $ 1 $ 到 $ N $ 这 $ N $ 个数字，都有唯一且不同的 $ 1 $ 到 $ N $ 的数字与之对应。最开始 windy 把数字按顺序 $ 1, 2, 3, \\ldots, N $ 写一排在纸上。然后再在这一排下面写上它们对应的数字。然后又在新的一排下面写上它们对应的数字。如此反复，直到序列再次变为 $ 1, 2, 3, \\ldots, N $。\n\n如：$ 1, 2, 3, 4, 5, 6 $ 对应的关系为\n\n$$\n\\begin{cases}\n1 \\rightarrow 2 \\\\\n2 \\rightarrow 3 \\\\\n3 \\rightarrow 1 \\\\\n4 \\rightarrow 5 \\\\\n5 \\rightarrow 4 \\\\\n6 \\rightarrow 6\n\\end{cases}\n$$\n\nwindy 的操作如下：\n\n$$\n\\begin{gather}\n1, 2, 3, 4, 5, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 5, 4, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 4, 5, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 5, 4, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 4, 5, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 5, 4, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 4, 5, 6\n\\end{gather}\n$$\n\n这时，我们就有若干排 $ 1 $ 到 $ N $ 的排列，上例中有 $ 7 $ 排。现在 windy 想知道，对于所有可能的对应关系，有多少种可能的排数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025)\n\n### 题解\n对于一个置换，我们可以将其分解为若干个循环，问题中的「排数」即为这些循环长度的最小公倍数。设这些循环长度分别为\n\n$$ \\{ x_1, x_2, \\ldots, x_m \\} $$\n\n对于某个 $ x_k $ 的一个质因子 $ p $，它对 $ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) $ 有贡献，当且仅当 $ p $ 在 $ x_k $ 的唯一分解式中的次数是所有 $ x_i $ 中最大的。\n\n为了便于统计，我们只考虑每个 $ x_i $ 都是不同的质数的幂的情况（暂不考虑 $ x_i = 1 $ 的情况）\n\n$$\n\\begin{cases}\nx_1 = p_1 ^ {k_1} \\\\\nx_2 = p_2 ^ {k_2} \\\\\n\\cdots \\\\\nx_m = p_m ^ {k_m}\n\\end{cases}\n$$\n\n这种情况下，$ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) = x_1 \\times x_2 \\times \\ldots \\times x_m $。而 $ \\{ x_1. x_2, \\ldots, x_m \\} $ 是一组合法的循环长度，当且仅当 $ x_1 + x_2 + \\ldots + x_m = n $。因为我们可以任意添加长度为 $ 1 $ 的循环，而不对其最小公倍数产生影响，所以 $ x_1 + x_2 + \\ldots + x_m \\leq n $ 即为合法方案。\n\n现在的问题变成，有一些质数 $ p_i $，每个质数可以不选，也可以选择一个特定的幂 $ p_i ^ {k_i} $。要求最终选择的所有数之和 $ \\leq n $，求方案总数。这个问题可以转化为分组背包的方案计数问题 —— 第 $ i $ 组物品体积为 $ p_i ^ 1, p_i ^ 2, \\ldots p_i ^ {k_i} $（$ p_i ^ {k_i} \\leq n $），背包容量为 $ n $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\n\nint primes[MAXN], isNotPrime[MAXN + 1], cnt;\n\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * primes[j] <= MAXN; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n\t// for (int i = 0; i < cnt; i++) printf(\"%d\\n\", primes[i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tgetPrimes();\n\n\tstatic long long f[MAXN + 1][MAXN + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int k = 0; k <= n; k++) f[i][k] = f[i - 1][k];\n\t\tfor (int p = primes[i]; p <= n; p *= primes[i]) {\n\t\t\tfor (int k = p; k <= n; k++) {\n\t\t\t\tf[i][k] += f[i - 1][k - p];\n\t\t\t}\n\t\t}\n\t\t// for (int k = 0; k <= n; k++) printf(\"f[%d][%d] = %d\\n\", i, k, f[i][k]);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) ans += f[cnt][i];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"scoi2009-game","published":1,"updated":"2016-11-13T00:47:58.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ri000h9ooxloxq9cuyx"},{"title":"「SCOI2009」生日快乐 - 搜索","date":"2016-11-12T13:17:00.000Z","_content":"\nwindy 的生日到了，为了庆祝生日，他的朋友们帮他买了一个边长分别为 $ X $ 和 $ Y $ 的矩形蛋糕。现在包括 windy，一共有 $ N $ 个人来分这块大蛋糕，要求每个人必须获得相同面积的蛋糕。windy 主刀，每一切只能平行于一块蛋糕的一边（任意一边），并且必须把这块蛋糕切成两块。这样，要切成 $ N $ 块蛋糕，windy 必须切 $ N - 1 $ 次。为了使得每块蛋糕看起来漂亮，我们要求 $ N $ 块蛋糕的长边与短边的比值的最大值最小。你能帮助 windy 求出这个比值么？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024)\n\n### 题解\n首先，为了保证**每个人必须获得相同面积的蛋糕**，假设某一次操作选择了蛋糕的一部分，这部分的面积为总面积的 $ k \\over n $，我们必须在它的 $ k $ 等分点上切一刀，然后对切成的两个部分递归操作。\n\nDFS 搜索每次切下的位置即可，分横切和纵切两种情况。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 10;\n\ndouble dfs(const int n, const double x, const double y) {\n\tif (n == 1) {\n\t\treturn std::max(x, y) / std::min(x, y);\n\t}\n\n\tdouble res1 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y)));\n\t}\n\n\tdouble res2 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n)));\n\t}\n\n\treturn std::min(res1, res2);\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(n, x, y));\n\treturn 0;\n}\n```","source":"_posts/scoi2009-cake.md","raw":"title: 「SCOI2009」生日快乐 - 搜索\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 搜索\n  - DFS\npermalink: scoi2009-cake\ndate: 2016-11-12 21:17:00\n---\n\nwindy 的生日到了，为了庆祝生日，他的朋友们帮他买了一个边长分别为 $ X $ 和 $ Y $ 的矩形蛋糕。现在包括 windy，一共有 $ N $ 个人来分这块大蛋糕，要求每个人必须获得相同面积的蛋糕。windy 主刀，每一切只能平行于一块蛋糕的一边（任意一边），并且必须把这块蛋糕切成两块。这样，要切成 $ N $ 块蛋糕，windy 必须切 $ N - 1 $ 次。为了使得每块蛋糕看起来漂亮，我们要求 $ N $ 块蛋糕的长边与短边的比值的最大值最小。你能帮助 windy 求出这个比值么？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024)\n\n### 题解\n首先，为了保证**每个人必须获得相同面积的蛋糕**，假设某一次操作选择了蛋糕的一部分，这部分的面积为总面积的 $ k \\over n $，我们必须在它的 $ k $ 等分点上切一刀，然后对切成的两个部分递归操作。\n\nDFS 搜索每次切下的位置即可，分横切和纵切两种情况。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 10;\n\ndouble dfs(const int n, const double x, const double y) {\n\tif (n == 1) {\n\t\treturn std::max(x, y) / std::min(x, y);\n\t}\n\n\tdouble res1 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y)));\n\t}\n\n\tdouble res2 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n)));\n\t}\n\n\treturn std::min(res1, res2);\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(n, x, y));\n\treturn 0;\n}\n```","slug":"scoi2009-cake","published":1,"updated":"2016-11-12T13:17:41.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ri400hiooxlr5ux6do7"},{"title":"「SCOI2007」修车 - 费用流","date":"2016-03-09T01:52:35.000Z","_content":"\n同一时刻有 $ N $ 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 $ M $ 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 $ M $ 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。\n\n顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### 题解\n为每辆车建立点，为每个技术人员的**每一次修车**建立点。\n\n设第 $ i $ 个技术人员修第 $ j $ 辆车所用时间为 $ t_{i, j} $，第 $ i $ 辆车的点为 $ v_i $，第 $ i $ 个技术人员倒数第 $ k $ 次修车（此时有 $ k $ 个人在等待）的点为 $ v_{j, k} $（$ k {\\in} [1, n] $）。\n\n从源点向每辆车连边，容量为 1，费用为 0；从每个 $ v_i $ 向每个 $ v_{j, k} $ 连边，容量为 1，费用为 $ t_{i, j} * k $；从每个 $ v_{j, k} $ 向汇点连边，容量为 1，费用为 0。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n又一次把 $ n $、$ m $ 读入倒了 ……\n\n又一次敲错 EK 模板 ……\n\nhehe\n","source":"_posts/scoi2007-repair.md","raw":"title: 「SCOI2007」修车 - 费用流\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - SCOI\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\npermalink: scoi2007-repair\ndate: 2016-03-09 09:52:35\n---\n\n同一时刻有 $ N $ 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 $ M $ 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 $ M $ 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。\n\n顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### 题解\n为每辆车建立点，为每个技术人员的**每一次修车**建立点。\n\n设第 $ i $ 个技术人员修第 $ j $ 辆车所用时间为 $ t_{i, j} $，第 $ i $ 辆车的点为 $ v_i $，第 $ i $ 个技术人员倒数第 $ k $ 次修车（此时有 $ k $ 个人在等待）的点为 $ v_{j, k} $（$ k {\\in} [1, n] $）。\n\n从源点向每辆车连边，容量为 1，费用为 0；从每个 $ v_i $ 向每个 $ v_{j, k} $ 连边，容量为 1，费用为 $ t_{i, j} * k $；从每个 $ v_{j, k} $ 向汇点连边，容量为 1，费用为 0。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n又一次把 $ n $、$ m $ 读入倒了 ……\n\n又一次敲错 EK 模板 ……\n\nhehe\n","slug":"scoi2007-repair","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ri800hqooxl0br8tnkk"},{"title":"「SCOI2007」蜥蜴 - 网络流","date":"2016-09-03T13:47:00.000Z","_content":"\n在一个 $ r $ 行 $ c $ 列的网格地图中有一些高度不同的石柱，一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。\n\n每行每列中相邻石柱的距离为 $ 1 $，蜥蜴的跳跃距离是 $ d $，即蜥蜴可以跳到平面**曼哈顿**距离不超过 $ d $ 的任何一个石柱上。\n\n石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 $ 1 $（如果仍然落在地图内部，则到达的石柱高度不变），如果该石柱原来高度为 $ 1 $，则蜥蜴离开后消失。以后其他蜥蜴不能落脚。\n\n任何时刻不能有两只蜥蜴在同一个石柱上。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1066](http://www.lydsy.com/JudgeOnline/problem.php?id=1066)\n\n### 题解\n网络流，从每个点向所有与其曼哈顿距离在 $ d $ 以内的点连双向边，对每个点设置流量限制为石柱高度，蜥蜴数量减去最大流即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXD = 4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"addEdge(%d, %d, %d)\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j, const int l) {\n\treturn l * n * m + i * m + j + 1;\n}\n\nint main() {\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &d);\n\n\t/*\n\tprintf(\"%d -> %d\\n\", id(2, 2, 1), id(2, 2, 0));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 0), id(2, 2, 2));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 2), id(2, 1, 1));\n\tprintf(\"%d -> %d\\n\", id(2, 1, 1), id(3, 1, 0));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 0), id(3, 1, 2));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 2), id(3, 0, 1));\n\t*/\n\t/*\n\tfor (int h = 0; h <= d; h++) for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%d\\n\", id(i, j, h));\n\tprintf(\"t = %d\\n\", n * m * (d + 1) + 1);\n\treturn 0;\n\t*/\n\n\tconst int s = 0, t = n * m * 2 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\taddEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0');\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\tif (abs(i - k) + abs(j - l) <= d) {\n\t\t\t\t\t\taddEdge(id(i, j, 1), id(k, l, 0), INT_MAX);\n\t\t\t\t\t\taddEdge(id(k, l, 1), id(i, j, 0), INT_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < d || i > n - d - 1 || j < d || j > m - d - 1) addEdge(id(i, j, 1), t, INT_MAX);\n\t\t}\n\t}\n\n\tint ans = dinic(s, t, n * m * 2 + 2);\n\tprintf(\"%d\\n\", cnt - ans);\n\n\treturn 0;\n}\n```","source":"_posts/scoi2007-lizard.md","raw":"title: 「SCOI2007」蜥蜴 - 网络流\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 网络流\n  - Dinic\npermalink: scoi2007-lizard\ndate: 2016-09-03 21:47:00\n---\n\n在一个 $ r $ 行 $ c $ 列的网格地图中有一些高度不同的石柱，一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。\n\n每行每列中相邻石柱的距离为 $ 1 $，蜥蜴的跳跃距离是 $ d $，即蜥蜴可以跳到平面**曼哈顿**距离不超过 $ d $ 的任何一个石柱上。\n\n石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 $ 1 $（如果仍然落在地图内部，则到达的石柱高度不变），如果该石柱原来高度为 $ 1 $，则蜥蜴离开后消失。以后其他蜥蜴不能落脚。\n\n任何时刻不能有两只蜥蜴在同一个石柱上。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1066](http://www.lydsy.com/JudgeOnline/problem.php?id=1066)\n\n### 题解\n网络流，从每个点向所有与其曼哈顿距离在 $ d $ 以内的点连双向边，对每个点设置流量限制为石柱高度，蜥蜴数量减去最大流即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXD = 4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"addEdge(%d, %d, %d)\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j, const int l) {\n\treturn l * n * m + i * m + j + 1;\n}\n\nint main() {\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &d);\n\n\t/*\n\tprintf(\"%d -> %d\\n\", id(2, 2, 1), id(2, 2, 0));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 0), id(2, 2, 2));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 2), id(2, 1, 1));\n\tprintf(\"%d -> %d\\n\", id(2, 1, 1), id(3, 1, 0));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 0), id(3, 1, 2));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 2), id(3, 0, 1));\n\t*/\n\t/*\n\tfor (int h = 0; h <= d; h++) for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%d\\n\", id(i, j, h));\n\tprintf(\"t = %d\\n\", n * m * (d + 1) + 1);\n\treturn 0;\n\t*/\n\n\tconst int s = 0, t = n * m * 2 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\taddEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0');\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\tif (abs(i - k) + abs(j - l) <= d) {\n\t\t\t\t\t\taddEdge(id(i, j, 1), id(k, l, 0), INT_MAX);\n\t\t\t\t\t\taddEdge(id(k, l, 1), id(i, j, 0), INT_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < d || i > n - d - 1 || j < d || j > m - d - 1) addEdge(id(i, j, 1), t, INT_MAX);\n\t\t}\n\t}\n\n\tint ans = dinic(s, t, n * m * 2 + 2);\n\tprintf(\"%d\\n\", cnt - ans);\n\n\treturn 0;\n}\n```","slug":"scoi2007-lizard","published":1,"updated":"2016-09-03T13:51:23.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ric00hzooxlglirxi4t"},{"title":"「SCOI2005」王室联邦 - 树分块","date":"2016-12-30T03:10:00.000Z","_content":"\n他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。他的国家有 $ n $ 个城市，编号为 $ 1 \\ldots n $。一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。\n\n每个省至少要有 $ B $ 个城市，最多只有 $ 3B $ 个城市。\n\n每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。\n\n一个城市可以作为多个省的省会。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1086](http://www.lydsy.com/JudgeOnline/problem.php?id=1086)\n\n### 题解\nDFS 整棵树，处理每个节点时，将其一部分子节点分块，将未被分块的子节点返回。\n\n枚举 $ u $ 每个子节点 $ v $，递归处理子树后将每个子节点返回的未被分块的节点（下文有解释）累加到集合 $ S $ 中，一但累加的数量达到 $ B $，就把集合 $ S $ 中的点作为一个新的块，并将当前节点 $ u $ 作为该块的「省会」，然后清空 $ S $ 继续枚举下一棵子树。\n\n处理完所有子树后，将 $ u $ 自身也加入集合 $ S $，此时剩余在集合 $ S $ 中的节点为「未被分块的节点」，这些节点被返回到上一层。显然，$ S $ 大小最大为 $ B $（$ B - 1 $ 个子树上的节点加上 $ u $ 本身）。\n\n即，使用上述分块方法，整棵树 DFS 完成时，每个块的大小最大为 $ 2B - 1 $。\n\nDFS 完成整棵树后，剩余在集合 $ S $ 中的点最多有 $ B $ 个，将这些点加入到最后一个块（DFS 根节点时创建的最后一个块）中，这个块的大小最大为 $ 3B - 1 $。\n\n集合 $ S $ 可以用一个栈来维护，用**进入节点时的栈顶**到**当前栈顶**之间的元素表示集合 $ S $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 1000;\n\nstruct Node {\n\tstruct Edge *e;\n\tstruct Block *block;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Block {\n\tNode *top;\n} blocks[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, b, blockCount;\nstd::stack<Node *> s;\n\ninline void dfs(Node *v, Node *fa) {\n\tsize_t status = s.size();\n\n\tfor (Edge *e = v->e; e; e = e->next) {\n\t\tif (e->t != fa) {\n\t\t\tdfs(e->t, v);\n\n\t\t\tif (int(s.size() - status) >= b) {\n\t\t\t\tblocks[++blockCount].top = v;\n\t\t\t\twhile (s.size() != status) {\n\t\t\t\t\tNode *u = s.top();\n\t\t\t\t\ts.pop();\n\t\t\t\t\tu->block = &blocks[blockCount];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ts.push(v);\n}\n\ninline void solve() {\n\tdfs(&N[1], NULL);\n\twhile (!s.empty()) {\n\t\tNode *u = s.top();\n\t\ts.pop();\n\t\tu->block = &blocks[blockCount];\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &b);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsolve();\n\n\tprintf(\"%d\\n\", blockCount);\n\tfor (int i = 1; i <= n; i++) printf(\"%lu%c\", N[i].block - blocks, i == n ? '\\n' : ' ');\n\tfor (int i = 1; i <= blockCount; i++) printf(\"%lu%c\", blocks[i].top - N, i == blockCount ? '\\n' : ' ');\n\n\treturn 0;\n}\n```","source":"_posts/scoi2005-royal.md","raw":"title: 「SCOI2005」王室联邦 - 树分块\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 树分块\n  - 分块\n  - 数据结构\npermalink: scoi2005-royal\ndate: 2016-12-30 11:10:00\n---\n\n他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。他的国家有 $ n $ 个城市，编号为 $ 1 \\ldots n $。一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。\n\n每个省至少要有 $ B $ 个城市，最多只有 $ 3B $ 个城市。\n\n每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。\n\n一个城市可以作为多个省的省会。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1086](http://www.lydsy.com/JudgeOnline/problem.php?id=1086)\n\n### 题解\nDFS 整棵树，处理每个节点时，将其一部分子节点分块，将未被分块的子节点返回。\n\n枚举 $ u $ 每个子节点 $ v $，递归处理子树后将每个子节点返回的未被分块的节点（下文有解释）累加到集合 $ S $ 中，一但累加的数量达到 $ B $，就把集合 $ S $ 中的点作为一个新的块，并将当前节点 $ u $ 作为该块的「省会」，然后清空 $ S $ 继续枚举下一棵子树。\n\n处理完所有子树后，将 $ u $ 自身也加入集合 $ S $，此时剩余在集合 $ S $ 中的节点为「未被分块的节点」，这些节点被返回到上一层。显然，$ S $ 大小最大为 $ B $（$ B - 1 $ 个子树上的节点加上 $ u $ 本身）。\n\n即，使用上述分块方法，整棵树 DFS 完成时，每个块的大小最大为 $ 2B - 1 $。\n\nDFS 完成整棵树后，剩余在集合 $ S $ 中的点最多有 $ B $ 个，将这些点加入到最后一个块（DFS 根节点时创建的最后一个块）中，这个块的大小最大为 $ 3B - 1 $。\n\n集合 $ S $ 可以用一个栈来维护，用**进入节点时的栈顶**到**当前栈顶**之间的元素表示集合 $ S $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 1000;\n\nstruct Node {\n\tstruct Edge *e;\n\tstruct Block *block;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Block {\n\tNode *top;\n} blocks[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, b, blockCount;\nstd::stack<Node *> s;\n\ninline void dfs(Node *v, Node *fa) {\n\tsize_t status = s.size();\n\n\tfor (Edge *e = v->e; e; e = e->next) {\n\t\tif (e->t != fa) {\n\t\t\tdfs(e->t, v);\n\n\t\t\tif (int(s.size() - status) >= b) {\n\t\t\t\tblocks[++blockCount].top = v;\n\t\t\t\twhile (s.size() != status) {\n\t\t\t\t\tNode *u = s.top();\n\t\t\t\t\ts.pop();\n\t\t\t\t\tu->block = &blocks[blockCount];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ts.push(v);\n}\n\ninline void solve() {\n\tdfs(&N[1], NULL);\n\twhile (!s.empty()) {\n\t\tNode *u = s.top();\n\t\ts.pop();\n\t\tu->block = &blocks[blockCount];\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &b);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsolve();\n\n\tprintf(\"%d\\n\", blockCount);\n\tfor (int i = 1; i <= n; i++) printf(\"%lu%c\", N[i].block - blocks, i == n ? '\\n' : ' ');\n\tfor (int i = 1; i <= blockCount; i++) printf(\"%lu%c\", blocks[i].top - N, i == blockCount ? '\\n' : ' ');\n\n\treturn 0;\n}\n```","slug":"scoi2005-royal","published":1,"updated":"2016-12-30T03:33:44.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rif00i5ooxl84oy73ga"},{"title":"「SCOI2003」字符串折叠 - 区间 DP","date":"2016-07-06T03:54:00.000Z","_content":"\n折叠的定义如下：\n\n1. 一个字符串可以看成它自身的折叠。\n2. $ X(S) $ 是 $ X(X > 1) $ 个 $ S $ 连接在一起的串的折叠。\n3. 如果 $ A $ 是 $ A’ $ 的折叠，$ B $ 是 $ B’ $ 的折叠，则 $ AB $ 是 $ A’B’ $ 的折叠。\n\n给一个字符串，求它的最短折叠。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1090](http://www.lydsy.com/JudgeOnline/problem.php?id=1090)\n\n### 题解\n设 $ f(l, r) $ 为 $ [l, r] $ 区间内字符串的最短折叠。\n\n四种转移：\n\n1. 自身的长度 $ r - l + 1 $；\n2. 枚举左边前缀的长度，将前缀向右匹配，将第一个失配点右边作为一个子区间处理；\n3. 枚举右边后缀的长度，将后缀向左匹配，将第一个失配点左边作为一个子区间处理；\n4. 枚举断点，将区间分成两个处理。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nint n;\nchar s[MAXN + 1];\n\ninline int numberLength(int x) {\n\tint res = 0;\n\tdo res++; while (x /= 10);\n\treturn res;\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1;\n\telse if (l > r) return ans = 0;\n\n\tans = r - l + 1;\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(l, l + i - 1);\n\t\tint pos = l + i, cnt = 1;\n\t\twhile (pos + i - 1 <= r && strncmp(s + l, s + pos, i) == 0) pos += i, cnt++;\n\t\tans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(r - i + 1, r);\n\t\tint pos = r - i - i + 1, cnt = 1;\n\t\twhile (pos >= l && strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++;\n\t\tans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1 - 1; i++) {\n\t\tans = std::min(ans, dp(l, i) + dp(i + 1, r));\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tprintf(\"%d\\n\", dp(0, n - 1));\n\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/scoi2003-fold.md","raw":"title: 「SCOI2003」字符串折叠 - 区间 DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - DP\n  - 区间 DP\npermalink: scoi2003-fold\ndate: 2016-07-06 11:54:00\n---\n\n折叠的定义如下：\n\n1. 一个字符串可以看成它自身的折叠。\n2. $ X(S) $ 是 $ X(X > 1) $ 个 $ S $ 连接在一起的串的折叠。\n3. 如果 $ A $ 是 $ A’ $ 的折叠，$ B $ 是 $ B’ $ 的折叠，则 $ AB $ 是 $ A’B’ $ 的折叠。\n\n给一个字符串，求它的最短折叠。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1090](http://www.lydsy.com/JudgeOnline/problem.php?id=1090)\n\n### 题解\n设 $ f(l, r) $ 为 $ [l, r] $ 区间内字符串的最短折叠。\n\n四种转移：\n\n1. 自身的长度 $ r - l + 1 $；\n2. 枚举左边前缀的长度，将前缀向右匹配，将第一个失配点右边作为一个子区间处理；\n3. 枚举右边后缀的长度，将后缀向左匹配，将第一个失配点左边作为一个子区间处理；\n4. 枚举断点，将区间分成两个处理。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nint n;\nchar s[MAXN + 1];\n\ninline int numberLength(int x) {\n\tint res = 0;\n\tdo res++; while (x /= 10);\n\treturn res;\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1;\n\telse if (l > r) return ans = 0;\n\n\tans = r - l + 1;\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(l, l + i - 1);\n\t\tint pos = l + i, cnt = 1;\n\t\twhile (pos + i - 1 <= r && strncmp(s + l, s + pos, i) == 0) pos += i, cnt++;\n\t\tans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(r - i + 1, r);\n\t\tint pos = r - i - i + 1, cnt = 1;\n\t\twhile (pos >= l && strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++;\n\t\tans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1 - 1; i++) {\n\t\tans = std::min(ans, dp(l, i) + dp(i + 1, r));\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tprintf(\"%d\\n\", dp(0, n - 1));\n\n\treturn 0;\n}\n```\n\n\n\n","slug":"scoi2003-fold","published":1,"updated":"2016-10-24T23:31:18.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rik00ieooxlposk45jc"},{"title":"RMQ 模板","date":"2016-12-30T01:18:00.000Z","_content":"\nRMQ 稀疏表（Sparse Table）的模板。\n\n![zyz 大佬的评价](images/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\n\nint n, a[MAXN + 1], st[MAXN + 1][MAXN_LOG + 1], logx[MAXN + 1]; // 不能直接叫 log\n\ninline void sparseTable()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint t = 0;\n\t\twhile ((1 << (t + 1)) <= i) t++;\n\t\tlogx[i] = t;\n\t}\n\n\tfor (int i = 1; i <= n; i++) st[i][0] = a[i]; // 初始值，以每个位置开始 2 ^ 0 = 1 长度的区间，即自身\n\n\tfor (int j = 1; j <= logx[n]; j++)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\t// 判断当前要计算的区间是否越界\n\t\t\tif (i + (1 << (j - 1)) <= n) st[i][j] = std::max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n}\n\ninline int rmq(int l, int r)\n{\n\tint t = logx[r - l];\n\treturn std::max(st[l][t], st[r - (1 << t) + 1][t]); // 左右两个区间，恰好覆盖\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tprintf(\"%d\\n\", rmq(l, r));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/rmq-template.md","raw":"title: RMQ 模板\ncategories: OI\ntags: \n  - RMQ\n  - 数据结构\n  - 算法模板\npermalink: rmq-template\ndate: 2016-12-30 09:18:00\n---\n\nRMQ 稀疏表（Sparse Table）的模板。\n\n![zyz 大佬的评价](images/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\n\nint n, a[MAXN + 1], st[MAXN + 1][MAXN_LOG + 1], logx[MAXN + 1]; // 不能直接叫 log\n\ninline void sparseTable()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint t = 0;\n\t\twhile ((1 << (t + 1)) <= i) t++;\n\t\tlogx[i] = t;\n\t}\n\n\tfor (int i = 1; i <= n; i++) st[i][0] = a[i]; // 初始值，以每个位置开始 2 ^ 0 = 1 长度的区间，即自身\n\n\tfor (int j = 1; j <= logx[n]; j++)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\t// 判断当前要计算的区间是否越界\n\t\t\tif (i + (1 << (j - 1)) <= n) st[i][j] = std::max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n}\n\ninline int rmq(int l, int r)\n{\n\tint t = logx[r - l];\n\treturn std::max(st[l][t], st[r - (1 << t) + 1][t]); // 左右两个区间，恰好覆盖\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tprintf(\"%d\\n\", rmq(l, r));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"rmq-template","published":1,"updated":"2017-01-01T01:45:57.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rio00ikooxllp2j80bd"},{"title":"「POJ 3630」Phone List - Trie","date":"2017-01-02T03:05:00.000Z","_content":"\n给 $ n $ 个字符串，求有没有一个字符串是另一个字符串的前缀。\n\n<!-- more -->\n\n### 链接\n[POJ 3630](http://poj.org/problem?id=3630)\n\n### 题解\n建立 Trie，依次插入每个字符串，在插入时判断。\n\n判断当前字符串的前缀已被插入：插入时在路径上遇到一个单词节点。\n\n判断当前字符串是已插入字符串的前缀：插入时最后一个节点已存在。\n\n为防止 TLE，需要内存池。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int MAXN = 10000;\n\nstruct Node {\n\tNode *ch[10];\n\tbool isWord;\n\n\tNode(bool isWord = false) : isWord(isWord) {\n\t\tfor (int i = 0; i < 10; i++) ch[i] = NULL;\n\t}\n} *root, _pool[MAXN * 10], *_curr;\n\nbool insert(char *begin, char *end) {\n\tNode **v = &root;\n\tbool res = false;\n\tfor (char *p = begin; p != end; p++) {\n\t\tif (!*v) *v = new (_curr++) Node(false);\n\t\telse if ((*v)->isWord) res = true;\n\n\t\tv = &(*v)->ch[*p];\n\t}\n\tif (!*v) *v = new (_curr++) Node(true);\n\telse res = true;\n\n\treturn res;\n}\n\nvoid init() {\n\troot = NULL;\n\t_curr = _pool;\n}\n\nint main() {\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tinit();\n\n\t\tbool ans = false;\n\t\twhile (n--) {\n\t\t\tstatic char s[10 + 2];\n\t\t\tscanf(\"%s\", s + 1);\n\n\t\t\tint len = strlen(s + 1);\n\t\t\tfor (int i = 1; i <= len; i++) s[i] -= '0';\n\n\t\t\tif (insert(s + 1, s + len + 1)) ans = true;\n\t\t}\n\n\t\tputs(ans ? \"NO\" : \"YES\");\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-3630.md","raw":"title: 「POJ 3630」Phone List - Trie\ncategories: OI\ntags: \n  - POJ\n  - Trie\n  - 字符串\npermalink: poj-3630\ndate: 2017-01-02 11:05:00\n---\n\n给 $ n $ 个字符串，求有没有一个字符串是另一个字符串的前缀。\n\n<!-- more -->\n\n### 链接\n[POJ 3630](http://poj.org/problem?id=3630)\n\n### 题解\n建立 Trie，依次插入每个字符串，在插入时判断。\n\n判断当前字符串的前缀已被插入：插入时在路径上遇到一个单词节点。\n\n判断当前字符串是已插入字符串的前缀：插入时最后一个节点已存在。\n\n为防止 TLE，需要内存池。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int MAXN = 10000;\n\nstruct Node {\n\tNode *ch[10];\n\tbool isWord;\n\n\tNode(bool isWord = false) : isWord(isWord) {\n\t\tfor (int i = 0; i < 10; i++) ch[i] = NULL;\n\t}\n} *root, _pool[MAXN * 10], *_curr;\n\nbool insert(char *begin, char *end) {\n\tNode **v = &root;\n\tbool res = false;\n\tfor (char *p = begin; p != end; p++) {\n\t\tif (!*v) *v = new (_curr++) Node(false);\n\t\telse if ((*v)->isWord) res = true;\n\n\t\tv = &(*v)->ch[*p];\n\t}\n\tif (!*v) *v = new (_curr++) Node(true);\n\telse res = true;\n\n\treturn res;\n}\n\nvoid init() {\n\troot = NULL;\n\t_curr = _pool;\n}\n\nint main() {\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tinit();\n\n\t\tbool ans = false;\n\t\twhile (n--) {\n\t\t\tstatic char s[10 + 2];\n\t\t\tscanf(\"%s\", s + 1);\n\n\t\t\tint len = strlen(s + 1);\n\t\t\tfor (int i = 1; i <= len; i++) s[i] -= '0';\n\n\t\t\tif (insert(s + 1, s + len + 1)) ans = true;\n\t\t}\n\n\t\tputs(ans ? \"NO\" : \"YES\");\n\t}\n\n\treturn 0;\n}\n```\n","slug":"poj-3630","published":1,"updated":"2017-01-02T03:10:17.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rir00ipooxlk35f67ay"},{"title":"「POJ 3461」Oulipo - KMP","date":"2016-04-09T13:36:23.000Z","_content":"\n给出两个字符串，求一个字符串在另一个字符串中的出现次数。\n\n<!-- more -->\n\n### 题解\nKMP 裸题，拿来练练模板 ……\n\n注意 `next` 千万不要声明成 `char` 型，别问我为什么要说这个 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/poj-3461.md","raw":"title: 「POJ 3461」Oulipo - KMP\ncategories: OI\ntags: \n  - POJ\n  - KMP\n  - 字符串\n  - 算法模板\npermalink: poj-3461\ndate: 2016-04-09 21:36:23\n---\n\n给出两个字符串，求一个字符串在另一个字符串中的出现次数。\n\n<!-- more -->\n\n### 题解\nKMP 裸题，拿来练练模板 ……\n\n注意 `next` 千万不要声明成 `char` 型，别问我为什么要说这个 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","slug":"poj-3461","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9riw00iwooxlq7cnrzba"},{"title":"「POJ 2728」Desert King - 01 分数规划","date":"2016-03-11T01:33:14.000Z","_content":"\n一个王国有 $ N $ 个城市，每个城市有坐标 $ (x, y) $ 和海拔 $ z $，在 $ N $ 个城市之间修水渠，要保证每个城市有水，水渠是水平的，每个城市的海拔不同，现在要求修单位长度的水渠的海拔高度差最小。\n\n<!-- more -->\n\n### 链接\n[POJ 2728](http://poj.org/problem?id=2728)\n\n### 题解\n最优比率生成树，01 分数规划，搞的不是很明白 …… Orz\n\nPS：果然我的代码自带大常数，搞了一早上不是 WA 就是 TLE，最后把编译器从 G++ 改为 VC++ 就 AC 了 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-2728.md","raw":"title: 「POJ 2728」Desert King - 01 分数规划\ncategories: OI\ntags: \n  - POJ\n  - Prim\n  - 生成树\n  - 二分答案\n  - 实数二分\n  - 分数规划\npermalink: poj-2728\ndate: 2016-03-11 09:33:14\n---\n\n一个王国有 $ N $ 个城市，每个城市有坐标 $ (x, y) $ 和海拔 $ z $，在 $ N $ 个城市之间修水渠，要保证每个城市有水，水渠是水平的，每个城市的海拔不同，现在要求修单位长度的水渠的海拔高度差最小。\n\n<!-- more -->\n\n### 链接\n[POJ 2728](http://poj.org/problem?id=2728)\n\n### 题解\n最优比率生成树，01 分数规划，搞的不是很明白 …… Orz\n\nPS：果然我的代码自带大常数，搞了一早上不是 WA 就是 TLE，最后把编译器从 G++ 改为 VC++ 就 AC 了 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","slug":"poj-2728","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rj000j3ooxl2ngxiemi"},{"title":"「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推","date":"2016-03-14T04:12:45.000Z","_content":"\n给定 $ N $（$ N \\leq 50 $）个点，在平面上固定其位置，求这些点最多能组成多少个不同的无向连通图。\n\n<!-- more -->\n\n### 链接\n[POJ 1737](http://poj.org/problem?id=1737)\n\n### 题解\n统计连通图的方案数是困难的，但我们可以轻易地计算出用 N 个点组成任意图的方案数：因为 N 个点的**无向**图最多有 $ \\frac{N(N - 1)}{2} $ 条边，考虑每条边选或不选，则共有 $ 2 ^ {\\frac{N(N - 1)}{2}} $ 种不同的图。\n\n求出任意图的方案数后，只要再求出非连通图的方案数，就可以得到答案。考虑 $ N $ 个点组成的非连通图中的点 $ v $，它一定处于一个由 $ K $（$ 1 \\leq K \\leq N - 1 $）个点组成的**联通分量**中，点 $ v $ 确定后，组成这个联通分量还需要 $ K - 1 $ 个点，总方案数为 $ \\binom{N - 1}{K - 1} $；每个连通分量都是一个**连通图**，可以递归来求；考虑完一个联通分量，图的剩余部分（与该联通分量隔离的 $ N - K $ 个点）是一个任意图，也可以递归来求。\n\n设 $ n $ 个点组成连通图的方案数为 $ f(n) $、组成非联通图的方案数为 $ g(n) $、组成任意图的方案数为 $ h(n) $，则递归计算 $ f(n) $ 的公式为：\n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n需要使用高精度。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-1737.md","raw":"title: 「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推\ncategories: OI\ntags: \n  - POJ\n  - 递推\n  - 高精度\n  - 组合数\n  - 计数原理\n  - 数学\npermalink: poj-1737\ndate: 2016-03-14 12:12:45\n---\n\n给定 $ N $（$ N \\leq 50 $）个点，在平面上固定其位置，求这些点最多能组成多少个不同的无向连通图。\n\n<!-- more -->\n\n### 链接\n[POJ 1737](http://poj.org/problem?id=1737)\n\n### 题解\n统计连通图的方案数是困难的，但我们可以轻易地计算出用 N 个点组成任意图的方案数：因为 N 个点的**无向**图最多有 $ \\frac{N(N - 1)}{2} $ 条边，考虑每条边选或不选，则共有 $ 2 ^ {\\frac{N(N - 1)}{2}} $ 种不同的图。\n\n求出任意图的方案数后，只要再求出非连通图的方案数，就可以得到答案。考虑 $ N $ 个点组成的非连通图中的点 $ v $，它一定处于一个由 $ K $（$ 1 \\leq K \\leq N - 1 $）个点组成的**联通分量**中，点 $ v $ 确定后，组成这个联通分量还需要 $ K - 1 $ 个点，总方案数为 $ \\binom{N - 1}{K - 1} $；每个连通分量都是一个**连通图**，可以递归来求；考虑完一个联通分量，图的剩余部分（与该联通分量隔离的 $ N - K $ 个点）是一个任意图，也可以递归来求。\n\n设 $ n $ 个点组成连通图的方案数为 $ f(n) $、组成非联通图的方案数为 $ g(n) $、组成任意图的方案数为 $ h(n) $，则递归计算 $ f(n) $ 的公式为：\n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n需要使用高精度。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"poj-1737","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rj600jeooxll009vlfm"},{"title":"「POI2008」BLO - 割点","date":"2016-09-08T10:37:00.000Z","_content":"\nByteotia 城市有 $ n $ 个 towns，$ m $ 条双向 roads。每条 road 连接两个不同的 towns，没有重复的 road。所有 towns 连通。\n\n求当把每个点**封锁**时，会有多少**有序**点对 $ (u, v) $ 不连通。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1123](http://www.lydsy.com/JudgeOnline/problem.php?id=1123)\n\n### 题解\n如果一个点不是割点，则答案是 $ 2 \\times (n - 1) $。\n\n如果一个点是割点，则将它去掉后，剩下的所有连通块两两之间不联通，对于两个连通块，它们对答案的贡献是它们的大小之和。\n\nDFS 时维护 DFS 树上每棵子树的大小，对于每个割点 $ u $，删掉它后，所有满足 $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ 的子节点 $ v $ 的子树均为一个对答案有贡献的连通块。另外，树上除 $ u $ 的整棵子树的其它部分也是一个连通块。\n\n设每个连通块的大小分别为 $ x_1, x_2, \\ldots, x_k $，$ s = \\sum\\limits_{i = 1} ^ k x_i $，则答案贡献为：\n\n$$\n\\begin{aligned}\n& x_1x_2 + x_1x_3 + \\ldots + x_1x_k + \\ldots + x_kx_{k - 1} \\\\\n= & x_1(x_2 + x_3 + \\ldots + x_k) + x_2(x_1 + x_3 + \\ldots + x_k) + \\ldots + x_k(x_1 + x_2 + \\ldots + x_{k - 1}) \\\\\n= & \\sum\\limits_{i = 1} ^ k x_i \\times (s - x_i)\n\\end{aligned}\n$$\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low, size;\n\tlong long ans;\n\tbool flag, pushed, v;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline long long calc(const std::vector<long long> &vec) {\n\tlong long s = 0, ans = 0;\n\tfor (size_t i = 0; i < vec.size(); i++) s += vec[i];\n\tfor (size_t i = 0; i < vec.size(); i++) ans += (s - vec[i]) * vec[i];\n\treturn ans;\n}\n\ninline void tarjan() {\n\tint ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::stack<Node *> s;\n\t\tN[i].pushed = true;\n\t\ts.push(&N[i]);\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\t\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->size = 1;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tstd::vector<long long> vec;\n\t\t\t\tif (v != &N[i]) {\n\t\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\t\tif (e->t->p != v) continue;\n\t\t\t\t\t\tif (e->t->low >= v->dfn) {\n\t\t\t\t\t\t\tv->flag = true;\n\t\t\t\t\t\t\tvec.push_back(e->t->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->size += e->t->size;\n\t\t\t\t\t}\n\t\t\t\t\tint t = n - 1;\n\t\t\t\t\tfor (size_t i = 0; i < vec.size(); i++) t -= vec[i];\n\t\t\t\t\tvec.push_back(t);\n\t\t\t\t\tif (v->flag) v->ans = calc(vec);\n\t\t\t\t\t// if (v->flag) printf(\"tarjan(): found %lu\\n\", v - N + 1);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<long long> vec;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) vec.push_back(e->t->size);\n\t\tif (vec.size() >= 2) N[i].ans = calc(vec), N[i].flag = true;\n\t\t// if (N[i].flag) printf(\"tarjan(): found %d\\n\", i + 1);\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\ttarjan();\n\n\tfor (int i = 0; i < n; i++) printf(\"%lld\\n\", N[i].ans + (n - 1) * 2);\n\n\treturn 0;\n}\n```","source":"_posts/poi2008-blo.md","raw":"title: 「POI2008」BLO - 割点\ncategories: OI\ntags: \n  - BZOJ\n  - POI\n  - Tarjan\n  - 图论\n  - 割点\npermalink: poi2008-blo\ndate: 2016-09-08 18:37:00\n---\n\nByteotia 城市有 $ n $ 个 towns，$ m $ 条双向 roads。每条 road 连接两个不同的 towns，没有重复的 road。所有 towns 连通。\n\n求当把每个点**封锁**时，会有多少**有序**点对 $ (u, v) $ 不连通。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1123](http://www.lydsy.com/JudgeOnline/problem.php?id=1123)\n\n### 题解\n如果一个点不是割点，则答案是 $ 2 \\times (n - 1) $。\n\n如果一个点是割点，则将它去掉后，剩下的所有连通块两两之间不联通，对于两个连通块，它们对答案的贡献是它们的大小之和。\n\nDFS 时维护 DFS 树上每棵子树的大小，对于每个割点 $ u $，删掉它后，所有满足 $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ 的子节点 $ v $ 的子树均为一个对答案有贡献的连通块。另外，树上除 $ u $ 的整棵子树的其它部分也是一个连通块。\n\n设每个连通块的大小分别为 $ x_1, x_2, \\ldots, x_k $，$ s = \\sum\\limits_{i = 1} ^ k x_i $，则答案贡献为：\n\n$$\n\\begin{aligned}\n& x_1x_2 + x_1x_3 + \\ldots + x_1x_k + \\ldots + x_kx_{k - 1} \\\\\n= & x_1(x_2 + x_3 + \\ldots + x_k) + x_2(x_1 + x_3 + \\ldots + x_k) + \\ldots + x_k(x_1 + x_2 + \\ldots + x_{k - 1}) \\\\\n= & \\sum\\limits_{i = 1} ^ k x_i \\times (s - x_i)\n\\end{aligned}\n$$\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low, size;\n\tlong long ans;\n\tbool flag, pushed, v;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline long long calc(const std::vector<long long> &vec) {\n\tlong long s = 0, ans = 0;\n\tfor (size_t i = 0; i < vec.size(); i++) s += vec[i];\n\tfor (size_t i = 0; i < vec.size(); i++) ans += (s - vec[i]) * vec[i];\n\treturn ans;\n}\n\ninline void tarjan() {\n\tint ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::stack<Node *> s;\n\t\tN[i].pushed = true;\n\t\ts.push(&N[i]);\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\t\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->size = 1;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tstd::vector<long long> vec;\n\t\t\t\tif (v != &N[i]) {\n\t\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\t\tif (e->t->p != v) continue;\n\t\t\t\t\t\tif (e->t->low >= v->dfn) {\n\t\t\t\t\t\t\tv->flag = true;\n\t\t\t\t\t\t\tvec.push_back(e->t->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->size += e->t->size;\n\t\t\t\t\t}\n\t\t\t\t\tint t = n - 1;\n\t\t\t\t\tfor (size_t i = 0; i < vec.size(); i++) t -= vec[i];\n\t\t\t\t\tvec.push_back(t);\n\t\t\t\t\tif (v->flag) v->ans = calc(vec);\n\t\t\t\t\t// if (v->flag) printf(\"tarjan(): found %lu\\n\", v - N + 1);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<long long> vec;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) vec.push_back(e->t->size);\n\t\tif (vec.size() >= 2) N[i].ans = calc(vec), N[i].flag = true;\n\t\t// if (N[i].flag) printf(\"tarjan(): found %d\\n\", i + 1);\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\ttarjan();\n\n\tfor (int i = 0; i < n; i++) printf(\"%lld\\n\", N[i].ans + (n - 1) * 2);\n\n\treturn 0;\n}\n```","slug":"poi2008-blo","published":1,"updated":"2016-09-08T10:58:08.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rj900jmooxls9vrr6cg"},{"title":"「POI2006」Szk-Schools - 费用流","date":"2016-06-22T10:20:00.000Z","_content":"\n有一个长度为 $ n $ 的序列 $ a_i $，每个数都在 $ [1,\\ n] $ 之间，要求把这些数变成一个 $ n $ 的排列：\n\n1. $ a_i $ 可以被改成 $ [l_i,\\ r_i] $ 之间的数；\n2. $ a_i $ 改变为 $ x $ 的花费为 $ k \\times | a_i - x | $。\n\n求是否可行及最小花费。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1520](http://www.lydsy.com/JudgeOnline/problem.php?id=1520)\n\n### 题解\n对于第 $ i $ 个旧数字，向 $ [l_i,\\ r_i] $ 中的每个新数字连一条边，容量为 $ 1 $，费用为花费。\n\n源点向每个旧数字连边，容量为 $ 1 $；每个新数字向汇点连边，容量为 $ 1 $。\n\n若最大流不为 $ n $ 则无解，否则最小费用即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint d, f;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint m, l, r, k;\n\t\tscanf(\"%d %d %d %d\", &m, &l, &r, &k);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\n\t\tfor (int j = l; j <= r; j++) {\n\t\t\taddEdge(i, n + j, 1, k * abs(j - m));\n\t\t}\n\t}\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tif (f != n) puts(\"NIE\");\n\telse printf(\"%d\\n\", c);\n\n\treturn 0;\n}\n```\n","source":"_posts/poi2006-szk.md","raw":"title: 「POI2006」Szk-Schools - 费用流\ndate: 2016-06-22 18:20:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\npermalink: poi2006-szk\n---\n\n有一个长度为 $ n $ 的序列 $ a_i $，每个数都在 $ [1,\\ n] $ 之间，要求把这些数变成一个 $ n $ 的排列：\n\n1. $ a_i $ 可以被改成 $ [l_i,\\ r_i] $ 之间的数；\n2. $ a_i $ 改变为 $ x $ 的花费为 $ k \\times | a_i - x | $。\n\n求是否可行及最小花费。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1520](http://www.lydsy.com/JudgeOnline/problem.php?id=1520)\n\n### 题解\n对于第 $ i $ 个旧数字，向 $ [l_i,\\ r_i] $ 中的每个新数字连一条边，容量为 $ 1 $，费用为花费。\n\n源点向每个旧数字连边，容量为 $ 1 $；每个新数字向汇点连边，容量为 $ 1 $。\n\n若最大流不为 $ n $ 则无解，否则最小费用即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint d, f;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint m, l, r, k;\n\t\tscanf(\"%d %d %d %d\", &m, &l, &r, &k);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\n\t\tfor (int j = l; j <= r; j++) {\n\t\t\taddEdge(i, n + j, 1, k * abs(j - m));\n\t\t}\n\t}\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tif (f != n) puts(\"NIE\");\n\telse printf(\"%d\\n\", c);\n\n\treturn 0;\n}\n```\n","slug":"poi2006-szk","published":1,"updated":"2016-06-22T10:20:59.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rjd00juooxlptjla394"},{"title":"「POI2005」Kos-Dicing - 二分答案 + 网络流","date":"2016-06-22T10:25:00.000Z","_content":"\nDicing 是一个两人玩的游戏，人们专门成立了这个游戏的一个俱乐部，俱乐部的人时常在一起玩这个游戏然后评选出玩得最好的人。有一个人想知道比赛以后赢的最多的那个家伙最少会赢多少场。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1532](http://www.lydsy.com/JudgeOnline/problem.php?id=1532)\n\n### 题解\n二分答案 $ x $，从源点向每个人连边容量为 $ x $，从每个人向他参加的比赛连边容量为 $ 1 $，每个比赛向汇点连边容量为 $ 1 $，若最大流为 $ m $ 则可行。\n\n每一条单位为 $ 1 $ 的增广路表示一个人赢了一场比赛。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c > e->f) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c > e->f) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\t// printf(\"dinic() = %d\\n\", res);\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\nEdge *E[MAXN];\n\ninline void reset(const int c) {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tif (i < n) E[i]->c = c;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n\t}\n}\n\ninline int solve(const int s, const int t, const int n) {\n\tint l = 0, r = m;\n\twhile (l < r) {\n\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\tint mid = l + (r - l) / 2;\n\n\t\treset(mid);\n\n\t\tif (dinic(s, t, n) < m) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) E[i - 1] = addEdge(s, i, 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\taddEdge(a, n + i, 1);\n\t\taddEdge(b, n + i, 1);\n\n\t\taddEdge(n + i, t, 1);\n\t}\n\n\tprintf(\"%d\\n\", solve(s, t, n + m + 2));\n\n\treturn 0;\n}\n```\n","source":"_posts/poi2005-kos.md","raw":"title: 「POI2005」Kos-Dicing - 二分答案 + 网络流\ndate: 2016-06-22 18:25:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - 网络流\n  - Dinic\n  - 二分答案\npermalink: poi2005-kos\n---\n\nDicing 是一个两人玩的游戏，人们专门成立了这个游戏的一个俱乐部，俱乐部的人时常在一起玩这个游戏然后评选出玩得最好的人。有一个人想知道比赛以后赢的最多的那个家伙最少会赢多少场。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1532](http://www.lydsy.com/JudgeOnline/problem.php?id=1532)\n\n### 题解\n二分答案 $ x $，从源点向每个人连边容量为 $ x $，从每个人向他参加的比赛连边容量为 $ 1 $，每个比赛向汇点连边容量为 $ 1 $，若最大流为 $ m $ 则可行。\n\n每一条单位为 $ 1 $ 的增广路表示一个人赢了一场比赛。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c > e->f) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c > e->f) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\t// printf(\"dinic() = %d\\n\", res);\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\nEdge *E[MAXN];\n\ninline void reset(const int c) {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tif (i < n) E[i]->c = c;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n\t}\n}\n\ninline int solve(const int s, const int t, const int n) {\n\tint l = 0, r = m;\n\twhile (l < r) {\n\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\tint mid = l + (r - l) / 2;\n\n\t\treset(mid);\n\n\t\tif (dinic(s, t, n) < m) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) E[i - 1] = addEdge(s, i, 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\taddEdge(a, n + i, 1);\n\t\taddEdge(b, n + i, 1);\n\n\t\taddEdge(n + i, t, 1);\n\t}\n\n\tprintf(\"%d\\n\", solve(s, t, n + m + 2));\n\n\treturn 0;\n}\n```\n","slug":"poi2005-kos","published":1,"updated":"2016-06-22T10:25:54.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rjh00k1ooxltud1xze2"},{"title":"「POI2000」病毒 - AC 自动机 + 拓扑排序","date":"2016-09-12T23:46:00.000Z","_content":"\n二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2938](http://www.lydsy.com/JudgeOnline/problem.php?id=2938)\n\n### 题解\n为病毒代码建立 AC 自动机，如果一个节点是单词节点，或者它可以通过后缀链接转移到单词节点，则这个节点是无效的。\n\n按照 AC 自动机建图，对于每个节点，向在之后添加 $ 0 $ 和 $ 1 $ 所到达的点连边。如果图中包含一个由有效节点组成的环，且 AC 自动机根节点对应节点可以到达这个环，则答案为真。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\nconst int MAXN = 30000;\n\nint n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) {\n\t\t\tthis->id = n++;\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint inDegree;\n\tbool invalid, flag, visited;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\t// printf(\"Edge(%d, %d)\\n\", s, t);\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].inDegree++;\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) N[v->id].invalid = true;\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *u = v;\n\t\t\twhile (u != t.root && !u->c[i]) u = u->fail;\n\t\t\tif (u->c[i]) {\n\t\t\t\tif (!v->isWord && !v->next && !u->c[i]->isWord) addEdge(v->id, u->c[i]->id);\n\t\t\t} else {\n\t\t\t\tif (!v->isWord && !v->next) addEdge(v->id, t.root->id);\n\t\t\t}\n\n\t\t\tif (!v->c[i]) continue;\n\t\t\tv->c[i]->visited = true;\n\t\t\tq.push(v->c[i]);\n\t\t}\n\t}\n}\n\ninline bool solve() {\n\tstd::queue<Node *> q;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!N[i].inDegree && !N[i].invalid) {\n\t\tq.push(&N[i]);\n\t\tcnt++;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt--;\n\t\tv->flag = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\t\t\tif (!--e->t->inDegree) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cnt) return false;\n\n\tq.push(&N[0]);\n\tN[0].visited = true;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tif (!v->flag) return true;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->visited && !e->t->invalid) e->t->visited = true, q.push(e->t);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\n\tputs(solve() ? \"TAK\" : \"NIE\");\n\n\treturn 0;\n}\n```","source":"_posts/poi2000-wir.md","raw":"title: 「POI2000」病毒 - AC 自动机 + 拓扑排序\ndate: 2016-09-13 07:46:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - 字符串\n  - AC 自动机\n  - 拓扑排序\npermalink: poi2000-wir\n---\n\n二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2938](http://www.lydsy.com/JudgeOnline/problem.php?id=2938)\n\n### 题解\n为病毒代码建立 AC 自动机，如果一个节点是单词节点，或者它可以通过后缀链接转移到单词节点，则这个节点是无效的。\n\n按照 AC 自动机建图，对于每个节点，向在之后添加 $ 0 $ 和 $ 1 $ 所到达的点连边。如果图中包含一个由有效节点组成的环，且 AC 自动机根节点对应节点可以到达这个环，则答案为真。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\nconst int MAXN = 30000;\n\nint n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) {\n\t\t\tthis->id = n++;\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint inDegree;\n\tbool invalid, flag, visited;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\t// printf(\"Edge(%d, %d)\\n\", s, t);\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].inDegree++;\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) N[v->id].invalid = true;\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *u = v;\n\t\t\twhile (u != t.root && !u->c[i]) u = u->fail;\n\t\t\tif (u->c[i]) {\n\t\t\t\tif (!v->isWord && !v->next && !u->c[i]->isWord) addEdge(v->id, u->c[i]->id);\n\t\t\t} else {\n\t\t\t\tif (!v->isWord && !v->next) addEdge(v->id, t.root->id);\n\t\t\t}\n\n\t\t\tif (!v->c[i]) continue;\n\t\t\tv->c[i]->visited = true;\n\t\t\tq.push(v->c[i]);\n\t\t}\n\t}\n}\n\ninline bool solve() {\n\tstd::queue<Node *> q;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!N[i].inDegree && !N[i].invalid) {\n\t\tq.push(&N[i]);\n\t\tcnt++;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt--;\n\t\tv->flag = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\t\t\tif (!--e->t->inDegree) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cnt) return false;\n\n\tq.push(&N[0]);\n\tN[0].visited = true;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tif (!v->flag) return true;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->visited && !e->t->invalid) e->t->visited = true, q.push(e->t);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\n\tputs(solve() ? \"TAK\" : \"NIE\");\n\n\treturn 0;\n}\n```","slug":"poi2000-wir","published":1,"updated":"2016-09-12T23:51:54.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rjk00k8ooxl6ttbs39a"},{"title":"数论学习笔记（一）","date":"2016-01-19T13:48:24.000Z","_content":"\n数论是 OI 中很重要的一部分，然而我基本上都不会，所以从现在开始我要学数论！\n\n<!-- more -->\n\n### 欧几里得\n算是 OI 中数论最基本的了吧，求两个数的最大公约数。\n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b ≠ 0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n顺便求两个数的最小公倍数。\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n写程序时先除后乘防炸。\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得 `exgcd` 可以在求出 $\\gcd(a,b)$ 的同时求出二元一次不定方程 $ax+by=\\gcd(a,b)$的一组整数解。\n\n举个栗子，求 $\\gcd(47,30)$ 时，得到以下式子。\n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n把余数移到左边\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n从 $\\gcd(47,30)=1$ 开始，将四个式子依次带入，得\n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n解得 $x=-7,y=11$。\n\n由上述式子可观察到，每次辗转交换了 `x` 和 `y`，并将 `y` 减去了原 `x` 与辗转相除所得商的乘积。\n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes 筛法\n在筛选之前，先认为每个数都是素数。枚举所有数，如果这个数是素数，那么筛掉这个数的所有倍数，标记它们为“不是素数”。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n两个优化：\n1. 第二层循环可以从 $i^2$ 开始，因为对于每个小于 $i$ 的数 $i'$，$i*i'$ 都已经在第 $i'$ 次循环筛掉了。\n2. 枚举 $[2,\\sqrt{n}]$ 的素数即可，因为对于每个合数 $p>\\sqrt{n}$，则必有素数 $k$ 满足 $p=k*k'$ 且 $k< \\sqrt{n}$，所以 $p$ 会在第 $k$ 次循环被筛掉。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### 欧拉函数\n根据唯一分解定理，任何一个正整数 $n$ 都可以写成 $k$ 个素数的幂的积的形式，其中第 $i$ 个素数的指数为 $a_i$。即：\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n根据容斥原理，从总数 $n$ 中先减去每个 $p_i$ 的倍数，再把多减的补回来，再把多补的减回来 …… 最终得到公式\n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n把求和和容斥原理的应用全部展开之后就是\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n程序实现就是先令结果为 $n$，每次把结果除掉一个 $p$ 再乘上 $p-1$。嗯，不是很好理解 ……\n\n对于给定的 $n$，用类似筛法的思想枚举素数，每次找到一个素数后把它的倍数全部筛掉。\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // 前面没筛干净的\n\treturn ans;\n}\n```\n\n未完待续 ……\n","source":"_posts/number-theory-notes-1.md","raw":"title: 数论学习笔记（一）\ncategories: OI\ntags: \n  - 数学\n  - 数论\n  - 学习笔记\n  - 算法模板  \npermalink: number-theory-notes-1\ndate: 2016-01-19 21:48:24\n---\n\n数论是 OI 中很重要的一部分，然而我基本上都不会，所以从现在开始我要学数论！\n\n<!-- more -->\n\n### 欧几里得\n算是 OI 中数论最基本的了吧，求两个数的最大公约数。\n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b ≠ 0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n顺便求两个数的最小公倍数。\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n写程序时先除后乘防炸。\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得 `exgcd` 可以在求出 $\\gcd(a,b)$ 的同时求出二元一次不定方程 $ax+by=\\gcd(a,b)$的一组整数解。\n\n举个栗子，求 $\\gcd(47,30)$ 时，得到以下式子。\n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n把余数移到左边\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n从 $\\gcd(47,30)=1$ 开始，将四个式子依次带入，得\n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n解得 $x=-7,y=11$。\n\n由上述式子可观察到，每次辗转交换了 `x` 和 `y`，并将 `y` 减去了原 `x` 与辗转相除所得商的乘积。\n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes 筛法\n在筛选之前，先认为每个数都是素数。枚举所有数，如果这个数是素数，那么筛掉这个数的所有倍数，标记它们为“不是素数”。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n两个优化：\n1. 第二层循环可以从 $i^2$ 开始，因为对于每个小于 $i$ 的数 $i'$，$i*i'$ 都已经在第 $i'$ 次循环筛掉了。\n2. 枚举 $[2,\\sqrt{n}]$ 的素数即可，因为对于每个合数 $p>\\sqrt{n}$，则必有素数 $k$ 满足 $p=k*k'$ 且 $k< \\sqrt{n}$，所以 $p$ 会在第 $k$ 次循环被筛掉。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### 欧拉函数\n根据唯一分解定理，任何一个正整数 $n$ 都可以写成 $k$ 个素数的幂的积的形式，其中第 $i$ 个素数的指数为 $a_i$。即：\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n根据容斥原理，从总数 $n$ 中先减去每个 $p_i$ 的倍数，再把多减的补回来，再把多补的减回来 …… 最终得到公式\n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n把求和和容斥原理的应用全部展开之后就是\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n程序实现就是先令结果为 $n$，每次把结果除掉一个 $p$ 再乘上 $p-1$。嗯，不是很好理解 ……\n\n对于给定的 $n$，用类似筛法的思想枚举素数，每次找到一个素数后把它的倍数全部筛掉。\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // 前面没筛干净的\n\treturn ans;\n}\n```\n\n未完待续 ……\n","slug":"number-theory-notes-1","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rjo00kfooxlcesjwb8f"},{"title":"用 std::stack 实现非递归 DFS","date":"2016-04-08T06:30:21.000Z","_content":"\n众所周知，在有些省份（比如山东、河南），省选时使用 Windows 垃圾系统评测，而 Windows 下默认的系统栈非常小（只有 1M），这造成了有些 DFS 相关算法无法通过极端数据，而是发生『栈溢出』的错误。一种解决方法是使用非递归的 DFS。\n\n<!-- more -->\n\n### 框架\n我们通常这样实现递归 DFS：\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n第一次访问每个元素时，标记它为访问过，并对其进行初始化操作；枚举所有子元素，分为『未访问过』和『已访问过』分别进行处理。\n\n为了将这个过程转化为非递归，我们使用一个栈来存储 DFS 搜索树上的一条链。\n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan 强联通分量模板\n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### 树链剖分模板\n树链剖分的 DFS 过程比较特殊，我们可以每次将一个节点的所有子节点压入栈中，所有子树全部遍历完后回溯回来上传信息。\n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","source":"_posts/non-recursion-dfs-with-stack.md","raw":"title: 用 std::stack 实现非递归 DFS\ncategories: OI\ntags: \n  - STL\n  - DFS\n  - 算法模板\n  - Tarjan\n  - 强联通分量\n  - 树链剖分\npermalink: non-recursion-dfs-with-stack\ndate: 2016-04-08 14:30:21\n---\n\n众所周知，在有些省份（比如山东、河南），省选时使用 Windows 垃圾系统评测，而 Windows 下默认的系统栈非常小（只有 1M），这造成了有些 DFS 相关算法无法通过极端数据，而是发生『栈溢出』的错误。一种解决方法是使用非递归的 DFS。\n\n<!-- more -->\n\n### 框架\n我们通常这样实现递归 DFS：\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n第一次访问每个元素时，标记它为访问过，并对其进行初始化操作；枚举所有子元素，分为『未访问过』和『已访问过』分别进行处理。\n\n为了将这个过程转化为非递归，我们使用一个栈来存储 DFS 搜索树上的一条链。\n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan 强联通分量模板\n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### 树链剖分模板\n树链剖分的 DFS 过程比较特殊，我们可以每次将一个节点的所有子节点压入栈中，所有子树全部遍历完后回溯回来上传信息。\n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","slug":"non-recursion-dfs-with-stack","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rk300klooxl9kn22g9j"},{"title":"NOIP2016 行纪","date":"2016-11-20T15:47:00.000Z","_content":"\n第二次 NOIP。  \n倒数第二次 NOIP。\n\n<!-- more -->\n\n### Day0\n上午在机房玩了一会，十点半坐上了去日照的车，在车上打了三局狼人。\n\n到了日照一中，报名排队好久，遇见了 lwyz 的神犇们，果断 % 一发。抽到了 10 考场，要去曲师大 ……\n\n下午在阶梯教室遇见了省实验大佬 zyz、wjh 和 xzy 还有 Erii。\n\n晚上试机，Dev-C++ 用着还算可以，竟然有 VC6，代码补全非常强！重启发现有 Linux，果断单用户 root 登录，格掉 sda3 发现是可以正常和 Windows 共享文件的，可惜命令行没法看题 ……\n\n### Day1\n早上吃完饭就做车去曲师大了。lyx 说突然就不慌了，但我自己还是有些紧张，毕竟高二了 ……\n\n进了考场，解压密码是无意义字符串，感觉有些紧张。看了下题，感觉一三题都可做。\n\n写了一下第一题，放在那里没管，然后去看第二题 …… 想到能把一条链拆成两段然后分别推一个式子，在 DFS 的时候统计答案 …… 写完之后过了样例 …… 可惜发现是完全错的，不是同一棵子树也会统计进去。已经浪费了两个多小时了，果断打了暴力 + $ S_i = 1 $ 的部分分。\n\n写第三题的时候只剩下半个多小时了，写了个 Floyd，特判了 $ m = 0 $ 和 $ m = 1 $。细节错误调了一会，最后没时间写 $ m = 2 $ 和 $ k = 1 $ 了 …… 想到的 DP 也没时间写了。\n\n回去问了问 zyz，说 T2 我的想法已经接近正解了 …… T3 我想的 DP 状态是对的 …… 感觉药丸了 ……\n\n一下午完全没有状态 …… 不想颓废也不想学习 …… 感觉这一年好像就要完了 ……\n\n晚上和 zyz 聊了一会，感觉好些了。和省实验大佬们打了几局狼人，回去睡觉了。\n\n### Day2\n早上状态还不错，进了考场没有前一天那么紧张了。\n\n第一题一眼看出可以 Pascal 定理 + 前缀和做到 $ O(2000 ^ 2 + Tn) $，写完后打了暴力拍了一下，没问题。感觉 lyx 和 lyh 应该只能打暴力了 …… 考前没讲数学是我的锅啊 QAQ\n\n第二题一眼看出可以全局表示 + 堆，然而这个复杂度在 CCF 评测机是过不了的 …… 没仔细想线性做法，怕和前一天犯一样的错误，去写第三题吧。\n\n第三题一眼看出可以状压搜索，刚开始细节出了点问题，加上 GDB 在 Windows 下的 Bug，浪费了一些时间，DFS 写完后发现 $ T = 5, n = 18 $ 会 T，果断改成 BFS 后时间可以接受了。复杂度应该是 $ O(T \\times (2 ^ n n ^ 2)) $ 的。\n\n---\n\n总体上来说，不是特别好，也不是特别差。\n\nDay1 算是很差了，Day2 算不算翻盘？\n\n还是很害怕细节出问题，毕竟高二了 …… 没机会了 ……\n\n---\n\n> 「这一次就算考差，也并不能代表什么 ……」\n  \n> 「现在和高一的时候心情肯定是不一样的，到了高三再来的时候，又会是另外一种心情。」\n\n> 「不还有一天吗，放开打就是了。还有二百天无所畏惧啊。」","source":"_posts/noip2016.md","raw":"title: NOIP2016 行纪\ncategories: Diary\npermalink: noip2016\ndate: 2016-11-20 23:47:00\n---\n\n第二次 NOIP。  \n倒数第二次 NOIP。\n\n<!-- more -->\n\n### Day0\n上午在机房玩了一会，十点半坐上了去日照的车，在车上打了三局狼人。\n\n到了日照一中，报名排队好久，遇见了 lwyz 的神犇们，果断 % 一发。抽到了 10 考场，要去曲师大 ……\n\n下午在阶梯教室遇见了省实验大佬 zyz、wjh 和 xzy 还有 Erii。\n\n晚上试机，Dev-C++ 用着还算可以，竟然有 VC6，代码补全非常强！重启发现有 Linux，果断单用户 root 登录，格掉 sda3 发现是可以正常和 Windows 共享文件的，可惜命令行没法看题 ……\n\n### Day1\n早上吃完饭就做车去曲师大了。lyx 说突然就不慌了，但我自己还是有些紧张，毕竟高二了 ……\n\n进了考场，解压密码是无意义字符串，感觉有些紧张。看了下题，感觉一三题都可做。\n\n写了一下第一题，放在那里没管，然后去看第二题 …… 想到能把一条链拆成两段然后分别推一个式子，在 DFS 的时候统计答案 …… 写完之后过了样例 …… 可惜发现是完全错的，不是同一棵子树也会统计进去。已经浪费了两个多小时了，果断打了暴力 + $ S_i = 1 $ 的部分分。\n\n写第三题的时候只剩下半个多小时了，写了个 Floyd，特判了 $ m = 0 $ 和 $ m = 1 $。细节错误调了一会，最后没时间写 $ m = 2 $ 和 $ k = 1 $ 了 …… 想到的 DP 也没时间写了。\n\n回去问了问 zyz，说 T2 我的想法已经接近正解了 …… T3 我想的 DP 状态是对的 …… 感觉药丸了 ……\n\n一下午完全没有状态 …… 不想颓废也不想学习 …… 感觉这一年好像就要完了 ……\n\n晚上和 zyz 聊了一会，感觉好些了。和省实验大佬们打了几局狼人，回去睡觉了。\n\n### Day2\n早上状态还不错，进了考场没有前一天那么紧张了。\n\n第一题一眼看出可以 Pascal 定理 + 前缀和做到 $ O(2000 ^ 2 + Tn) $，写完后打了暴力拍了一下，没问题。感觉 lyx 和 lyh 应该只能打暴力了 …… 考前没讲数学是我的锅啊 QAQ\n\n第二题一眼看出可以全局表示 + 堆，然而这个复杂度在 CCF 评测机是过不了的 …… 没仔细想线性做法，怕和前一天犯一样的错误，去写第三题吧。\n\n第三题一眼看出可以状压搜索，刚开始细节出了点问题，加上 GDB 在 Windows 下的 Bug，浪费了一些时间，DFS 写完后发现 $ T = 5, n = 18 $ 会 T，果断改成 BFS 后时间可以接受了。复杂度应该是 $ O(T \\times (2 ^ n n ^ 2)) $ 的。\n\n---\n\n总体上来说，不是特别好，也不是特别差。\n\nDay1 算是很差了，Day2 算不算翻盘？\n\n还是很害怕细节出问题，毕竟高二了 …… 没机会了 ……\n\n---\n\n> 「这一次就算考差，也并不能代表什么 ……」\n  \n> 「现在和高一的时候心情肯定是不一样的，到了高三再来的时候，又会是另外一种心情。」\n\n> 「不还有一天吗，放开打就是了。还有二百天无所畏惧啊。」","slug":"noip2016","published":1,"updated":"2016-11-20T15:48:34.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rk700ktooxl6g2yf5hl"},{"title":"「NOIP2016」玩具谜题 - 模拟","date":"2016-11-29T03:25:00.000Z","_content":"\n小南有一套可爱的玩具小人，它们各有不同的职业。\n\n有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。\n\n这时 `singer` 告诉小南一个谜题：「眼镜藏在我左数第 $ 3 $ 个玩具小人的右数第 $ 1 $ 个玩具小人的左数第 $ 2 $ 个玩具小人那里。」\n\n小南发现，这个谜题中玩具小人的朝向非常关键， 因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。\n\n小南一边艰难地辨认着玩具小人，一边数着：\n\n`singer` 朝内，左数第 $ 3 $ 个是 `archer`。  \n`archer` 朝外，右数第 $ 1 $ 个是 `thinker`。  \n`thinker` 朝外，左数第 $ 2 $ 个是 `writer`。\n\n所以眼镜藏在 `writer` 这里！\n\n虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为：\n\n有 $ n $ 个玩具小人围成一圈，已知它们的职业和朝向。现在第 $ 1 $ 个玩具小人告诉小南一个包含 $ m $ 条指令的谜题。其中第 $ i $ 条指令形如「左数/右数第 $ s_i $ 个玩具小人」。你需要输出依次数完这些指令后，到达的玩具小人的职业。\n\n<!-- more -->\n\n### 链接\n[Luogu 1563](https://www.luogu.org/problem/show?pid=1563)  \n[LYOI #99](https://ly.men.ci/problem/99)\n\n### 题解\n维护当前是第几个小人，通过每个小人的朝向和指令方向判断下标的增减，每次增减下标后对 $ n $ 取模。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 1e5 + 10;\n\nint main() {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic struct Node {\n\t\tchar name[10 + 1];\n\t\tint opposite;\n\t} a[MAXN];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &a[i].opposite, a[i].name);\n\t}\n\n\tint curr = 0;\n\twhile (m--) {\n\t\t// printf(\"%d: %s\\n\", curr, a[curr].name);\n\n\t\tint k, s;\n\t\tscanf(\"%d %d\", &k, &s);\n\n\t\tint d = (k ^ a[curr].opposite) ? 1 : -1;\n\n\t\t(((curr += d * s) %= n) += n) %= n;\n\t}\n\n\tprintf(\"%s\\n\", a[curr].name);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-toy.md","raw":"title: 「NOIP2016」玩具谜题 - 模拟\ncategories: OI\ntags: \n  - NOIP\n  - 模拟\npermalink: noip2016-toy\ndate: 2016-11-29 11:25:00\n---\n\n小南有一套可爱的玩具小人，它们各有不同的职业。\n\n有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。\n\n这时 `singer` 告诉小南一个谜题：「眼镜藏在我左数第 $ 3 $ 个玩具小人的右数第 $ 1 $ 个玩具小人的左数第 $ 2 $ 个玩具小人那里。」\n\n小南发现，这个谜题中玩具小人的朝向非常关键， 因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。\n\n小南一边艰难地辨认着玩具小人，一边数着：\n\n`singer` 朝内，左数第 $ 3 $ 个是 `archer`。  \n`archer` 朝外，右数第 $ 1 $ 个是 `thinker`。  \n`thinker` 朝外，左数第 $ 2 $ 个是 `writer`。\n\n所以眼镜藏在 `writer` 这里！\n\n虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为：\n\n有 $ n $ 个玩具小人围成一圈，已知它们的职业和朝向。现在第 $ 1 $ 个玩具小人告诉小南一个包含 $ m $ 条指令的谜题。其中第 $ i $ 条指令形如「左数/右数第 $ s_i $ 个玩具小人」。你需要输出依次数完这些指令后，到达的玩具小人的职业。\n\n<!-- more -->\n\n### 链接\n[Luogu 1563](https://www.luogu.org/problem/show?pid=1563)  \n[LYOI #99](https://ly.men.ci/problem/99)\n\n### 题解\n维护当前是第几个小人，通过每个小人的朝向和指令方向判断下标的增减，每次增减下标后对 $ n $ 取模。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 1e5 + 10;\n\nint main() {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic struct Node {\n\t\tchar name[10 + 1];\n\t\tint opposite;\n\t} a[MAXN];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &a[i].opposite, a[i].name);\n\t}\n\n\tint curr = 0;\n\twhile (m--) {\n\t\t// printf(\"%d: %s\\n\", curr, a[curr].name);\n\n\t\tint k, s;\n\t\tscanf(\"%d %d\", &k, &s);\n\n\t\tint d = (k ^ a[curr].opposite) ? 1 : -1;\n\n\t\t(((curr += d * s) %= n) += n) %= n;\n\t}\n\n\tprintf(\"%s\\n\", a[curr].name);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-toy","published":1,"updated":"2016-11-29T07:36:08.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rk900kvooxl5hjzokqa"},{"title":"「NOIP2016」天天爱跑步 - 树链剖分 + 前缀和","date":"2016-11-29T07:10:00.000Z","_content":"\n小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。\n\n这个游戏的地图可以看作一棵包含 $ n $ 个结点和 $ n - 1 $ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $ 1 $ 到 $ n $ 的连续正整数。\n\n现在有 $ m $ 个玩家，第 $ i $ 个玩家的起点为 $ S_i $，终点为 $ T_i $。每天打卡任务开始时，所有玩家在第 $ 0 $  秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）\n\n小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $ j $ 的观察员会选择在第 $ W_j $ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $ W_j $ 秒也理到达了结点 $ j $。小 C 想知道每个观察员会观察到多少人？\n\n注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 $ j $ 作为终点的玩家：若他在第 $ W_j $ 秒前到达终点，则在结点 $ j $ 的观察员不能观察到该玩家；若他正好在第 $ W_j $ 秒到达终点，则在结点 $ j $ 的观察员可以观察到这个玩家。\n\n<!-- more -->\n\n### 链接\n[Luogu 1600](https://www.luogu.org/problem/show?pid=1600)  \n[LYOI #100](https://ly.men.ci/problem/100)\n\n### 题解\n考虑链的情况，在一个长度为 $ L $ 的链 $ [0, L) $ 上，有一个玩家从 $ S_j $ 走到 $ T_j $（$ S_j < T_j $），则第 $ i $ 个点能观测到该玩家的条件是 $ W_i = i - S_j $。\n\n![](noip2016-running/linear-forward1.svg)\n\n特别地，当 $ S_j < 0 $ 时，这个结论仍然成立。\n\n![](noip2016-running/linear-forward2.svg)\n\n对于 $ S_j > T_j $ 的情况，结论变为 $ W_i = S_j - i $。\n\n![](noip2016-running/linear-backward1.svg)\n\n同理，$ S_j > L $ 时结论仍然成立，图略。\n\n将上面的结论式子移项，当 $ S_j < T_j $ 时，$ S_j = i - W_i $，对于一个确定的 $ i $，式子右边是一个常数。 设 $ X_i = i - W_i $，问题转化为：\n\n1. 每次在 $ [S_j, T_j] $ 的每个位置加入一个数；\n2. 询问对于每个 $ i $，其位置上共有多少数等于 $ X_i $。\n\n同理，当 $ S_j > T_j $ 时，$ S_j = W_i + i $，设 $ X_i = i + W_i $ 即可。\n\n这个问题可以通过差分前缀和来解决，在 $ S_j $ 加入一个添加标记，在 $ T_j $ 加入一个删除标记。维护一个数组表示当前每个数的出现次数，按顺序枚举 $ j $，对于每个 $ j $，将这个位置上所有添加标记添加的数的计数加一，统计答案后将这个位置上所有删除标记删除的数的计数减一。\n\n序列上的情况可以在 $ O(n) $ 时间内解决，对于树上的情况，对树进行树链剖分，每个玩家的路线可以被分到最多 $ O(\\log n) $ 条重链上，将每条重链看作一个上述序列，以链上深度最小的点为 $ 0 $。从最近公共祖先处将路径分成两半，一半相当于序列上 $ S_j < T_j $ 的情况，另一半相当于序列上 $ S_j > T_j $ 的情况。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 299998;\n\nstruct Tag {\n#ifdef FORCE\n\tint s, t, x;\n\n\tTag(int s, int t, int x) : s(s), t(t), x(x) {\n#ifdef DBG\n\t\tprintf(\"Tag(%d, %d, %d)\\n\", s, t, x);\n#endif\n\t}\n#else\n\tint x;\n\tbool remove;\n\n\tTag(int x, bool remove) : x(x), remove(remove) {}\n#endif\n};\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent, *child;\n\tint depth, size, w, index, x, ans;\n\tbool visited;\n\tstruct Chain *chain;\n#ifndef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Chain {\n\tNode *top, *bottom;\n\tstd::vector<Node *> nodes;\n#ifdef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n\tint len;\n} chains[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, chainCnt;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->depth) {\n\t\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\t\te->t->parent = v;\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->child || v->child->size < e->t->size) v->child = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].visited = false;\n\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\n\t\t\tif (!v->parent || v != v->parent->child) {\n\t\t\t\tv->chain = &chains[++chainCnt];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->index = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->parent->chain;\n\t\t\t\tv->index = v->parent->index + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bottom = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->parent == v) {\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= chainCnt; i++) chains[i].len = chains[i].nodes.size();\n\n#ifdef DBG\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tprintf(\"chains[%d]: top = %lu, bottom = %lu, nodes = [\", i, chains[i].top - N, chains[i].bottom - N);\n\t\tfor (int j = 0; j < chains[i].len; j++) {\n\t\t\tprintf(\"%lu%s\", chains[i].nodes[j] - N, j == chains[i].len - 1 ? \"]\\n\" : \", \");\n\t\t}\n\t}\n#endif\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->parent;\n\t}\n\tif (u->depth > v->depth) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->depth + v->depth - p->depth * 2;\n}\n\ninline void addTag(bool forward, Chain *chain, int s, int t, int x) {\n#ifdef FORCE\n\tif (forward) {\n\t\tchain->tagsForward.push_back(Tag(s, t, x));\n\t} else {\n\t\tchain->tagsBackward.push_back(Tag(s, t, x));\n\t}\n#else\n\tif (forward) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->tagsForward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsForward.push_back(Tag(x, true));\n\t} else {\n\t\tif (t > s) return;\n\t\tchain->nodes[s]->tagsBackward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsBackward.push_back(Tag(x, true));\n\t}\n#ifdef DBG\n\tprintf(\"addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\\n\", forward, chain - chains, s, t, x);\n#endif\n#endif\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n#ifdef DBG\n\tprintf(\"play(s = %lu, t = %lu, p = %lu)\\n\", s - N, t - N, p - N);\n#endif\n\n\tif (p != s) {\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\t// S -> P, backward on chain\n\t\twhile (u->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\t\taddTag(false, u->chain, u->index, 0, s->depth - u->chain->bottom->depth);\n\t\t\tu = u->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\taddTag(false, u->chain, u->index, p->index + 1, s->depth - u->chain->bottom->depth);\n\t}\n\n\tif (p != t) {\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\t// P -> T, forward on chain\n\t\twhile (v->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\t\taddTag(true, v->chain, 0, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t\t\tv = v->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\taddTag(true, v->chain, p->index + 1, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t}\n}\n\ninline void solve() {\n#ifdef FORCE\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) {\n\t\t\tfor (int j = it->s; j <= it->t; j++) {\n\t\t\t\tif (chain.nodes[j]->w - j == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) {\n\t\t\tfor (int j = it->s; j >= it->t; j--) {\n\t\t\t\tif (chain.nodes[j]->w - chain.len + j + 1 == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#else\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n\t\tstatic int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN;\n\t\t\n\t\t// forward\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - j], chain.nodes[j]->w - j);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// backward\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - chain.len + j + 1];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - chain.len + j + 1], chain.nodes[j]->w - chain.len + j + 1);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].w);\n\t}\n\n\tsplit();\n\n\twhile (m--) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tplay(&N[s], &N[t]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-running.md","raw":"title: 「NOIP2016」天天爱跑步 - 树链剖分 + 前缀和\ncategories: OI\ntags: \n  - NOIP\n  - 前缀和\n  - 树链剖分\npermalink: noip2016-running\ndate: 2016-11-29 15:10:00\n---\n\n小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。\n\n这个游戏的地图可以看作一棵包含 $ n $ 个结点和 $ n - 1 $ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $ 1 $ 到 $ n $ 的连续正整数。\n\n现在有 $ m $ 个玩家，第 $ i $ 个玩家的起点为 $ S_i $，终点为 $ T_i $。每天打卡任务开始时，所有玩家在第 $ 0 $  秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）\n\n小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $ j $ 的观察员会选择在第 $ W_j $ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $ W_j $ 秒也理到达了结点 $ j $。小 C 想知道每个观察员会观察到多少人？\n\n注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 $ j $ 作为终点的玩家：若他在第 $ W_j $ 秒前到达终点，则在结点 $ j $ 的观察员不能观察到该玩家；若他正好在第 $ W_j $ 秒到达终点，则在结点 $ j $ 的观察员可以观察到这个玩家。\n\n<!-- more -->\n\n### 链接\n[Luogu 1600](https://www.luogu.org/problem/show?pid=1600)  \n[LYOI #100](https://ly.men.ci/problem/100)\n\n### 题解\n考虑链的情况，在一个长度为 $ L $ 的链 $ [0, L) $ 上，有一个玩家从 $ S_j $ 走到 $ T_j $（$ S_j < T_j $），则第 $ i $ 个点能观测到该玩家的条件是 $ W_i = i - S_j $。\n\n![](noip2016-running/linear-forward1.svg)\n\n特别地，当 $ S_j < 0 $ 时，这个结论仍然成立。\n\n![](noip2016-running/linear-forward2.svg)\n\n对于 $ S_j > T_j $ 的情况，结论变为 $ W_i = S_j - i $。\n\n![](noip2016-running/linear-backward1.svg)\n\n同理，$ S_j > L $ 时结论仍然成立，图略。\n\n将上面的结论式子移项，当 $ S_j < T_j $ 时，$ S_j = i - W_i $，对于一个确定的 $ i $，式子右边是一个常数。 设 $ X_i = i - W_i $，问题转化为：\n\n1. 每次在 $ [S_j, T_j] $ 的每个位置加入一个数；\n2. 询问对于每个 $ i $，其位置上共有多少数等于 $ X_i $。\n\n同理，当 $ S_j > T_j $ 时，$ S_j = W_i + i $，设 $ X_i = i + W_i $ 即可。\n\n这个问题可以通过差分前缀和来解决，在 $ S_j $ 加入一个添加标记，在 $ T_j $ 加入一个删除标记。维护一个数组表示当前每个数的出现次数，按顺序枚举 $ j $，对于每个 $ j $，将这个位置上所有添加标记添加的数的计数加一，统计答案后将这个位置上所有删除标记删除的数的计数减一。\n\n序列上的情况可以在 $ O(n) $ 时间内解决，对于树上的情况，对树进行树链剖分，每个玩家的路线可以被分到最多 $ O(\\log n) $ 条重链上，将每条重链看作一个上述序列，以链上深度最小的点为 $ 0 $。从最近公共祖先处将路径分成两半，一半相当于序列上 $ S_j < T_j $ 的情况，另一半相当于序列上 $ S_j > T_j $ 的情况。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 299998;\n\nstruct Tag {\n#ifdef FORCE\n\tint s, t, x;\n\n\tTag(int s, int t, int x) : s(s), t(t), x(x) {\n#ifdef DBG\n\t\tprintf(\"Tag(%d, %d, %d)\\n\", s, t, x);\n#endif\n\t}\n#else\n\tint x;\n\tbool remove;\n\n\tTag(int x, bool remove) : x(x), remove(remove) {}\n#endif\n};\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent, *child;\n\tint depth, size, w, index, x, ans;\n\tbool visited;\n\tstruct Chain *chain;\n#ifndef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Chain {\n\tNode *top, *bottom;\n\tstd::vector<Node *> nodes;\n#ifdef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n\tint len;\n} chains[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, chainCnt;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->depth) {\n\t\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\t\te->t->parent = v;\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->child || v->child->size < e->t->size) v->child = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].visited = false;\n\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\n\t\t\tif (!v->parent || v != v->parent->child) {\n\t\t\t\tv->chain = &chains[++chainCnt];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->index = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->parent->chain;\n\t\t\t\tv->index = v->parent->index + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bottom = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->parent == v) {\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= chainCnt; i++) chains[i].len = chains[i].nodes.size();\n\n#ifdef DBG\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tprintf(\"chains[%d]: top = %lu, bottom = %lu, nodes = [\", i, chains[i].top - N, chains[i].bottom - N);\n\t\tfor (int j = 0; j < chains[i].len; j++) {\n\t\t\tprintf(\"%lu%s\", chains[i].nodes[j] - N, j == chains[i].len - 1 ? \"]\\n\" : \", \");\n\t\t}\n\t}\n#endif\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->parent;\n\t}\n\tif (u->depth > v->depth) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->depth + v->depth - p->depth * 2;\n}\n\ninline void addTag(bool forward, Chain *chain, int s, int t, int x) {\n#ifdef FORCE\n\tif (forward) {\n\t\tchain->tagsForward.push_back(Tag(s, t, x));\n\t} else {\n\t\tchain->tagsBackward.push_back(Tag(s, t, x));\n\t}\n#else\n\tif (forward) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->tagsForward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsForward.push_back(Tag(x, true));\n\t} else {\n\t\tif (t > s) return;\n\t\tchain->nodes[s]->tagsBackward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsBackward.push_back(Tag(x, true));\n\t}\n#ifdef DBG\n\tprintf(\"addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\\n\", forward, chain - chains, s, t, x);\n#endif\n#endif\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n#ifdef DBG\n\tprintf(\"play(s = %lu, t = %lu, p = %lu)\\n\", s - N, t - N, p - N);\n#endif\n\n\tif (p != s) {\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\t// S -> P, backward on chain\n\t\twhile (u->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\t\taddTag(false, u->chain, u->index, 0, s->depth - u->chain->bottom->depth);\n\t\t\tu = u->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\taddTag(false, u->chain, u->index, p->index + 1, s->depth - u->chain->bottom->depth);\n\t}\n\n\tif (p != t) {\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\t// P -> T, forward on chain\n\t\twhile (v->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\t\taddTag(true, v->chain, 0, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t\t\tv = v->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\taddTag(true, v->chain, p->index + 1, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t}\n}\n\ninline void solve() {\n#ifdef FORCE\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) {\n\t\t\tfor (int j = it->s; j <= it->t; j++) {\n\t\t\t\tif (chain.nodes[j]->w - j == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) {\n\t\t\tfor (int j = it->s; j >= it->t; j--) {\n\t\t\t\tif (chain.nodes[j]->w - chain.len + j + 1 == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#else\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n\t\tstatic int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN;\n\t\t\n\t\t// forward\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - j], chain.nodes[j]->w - j);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// backward\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - chain.len + j + 1];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - chain.len + j + 1], chain.nodes[j]->w - chain.len + j + 1);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].w);\n\t}\n\n\tsplit();\n\n\twhile (m--) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tplay(&N[s], &N[t]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-running","published":1,"updated":"2016-11-29T07:36:19.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rkc00l0ooxl3gg8o7tc"},{"title":"「NOIP2016」组合数问题 - 递推 + 前缀和","date":"2016-11-29T12:54:00.000Z","_content":"\n组合数表示的是从 $ n $ 个物品中选出 $ m $ 个物品的方案数。举个例子，从 $ (1, 2, 3) $ 三个物品中选择两个物品可以有 $ (1, 2) $，$ (1, 3) $，$ (2, 3) $ 这三种选择方法。\n\n根据组合数的定义，我们可以给出计算组合数的一般公式：\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n其中 $ n! = 1 \\times 2 \\times \\cdots \\times n $。\n\n小葱想知道如果给定 $ n $，$ m $ 和 $ k $，对于所有的 $ 0 \\leq i \\leq n $，$ 0 \\leq j \\leq \\min(i, m) $ 有多少对 $ (i, j) $ 满足是 $ k $ 的倍数。\n\n<!-- more -->\n\n### 链接\n[Luogu 2822](https://www.luogu.org/problem/show?pid=2822)  \n[LYOI #102](https://ly.men.ci/problem/102)\n\n### 题解\n根据 Pascal 定理，有\n\n$$ C_n ^ m = C_{n - 1} ^ {m - 1} + C_{n - 1} ^ {m} $$\n\n预处理出每个 $ C_i ^ j \\bmod k $，前缀和 $ s(u, i) $ 统计对于 $ 1 \\leq j \\leq i $，有多少 $ C_u ^ j \\bmod k = 0 $。每次询问 $ O(n) $ 的在前缀和中求和即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000 + 10;\n\nint C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1];\n\nint main() {\n\tfreopen(\"problem.in\", \"r\", stdin);\n\tfreopen(\"problem.out\", \"w\", stdout);\n\t\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\t\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcnt[i][j] = cnt[i][j - 1];\n\t\t\tif (C[i][j] == 0) cnt[i][j]++;\n\t\t}\n\t}\n\t\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += cnt[i][std::min(i, m)];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-problem.md","raw":"title: 「NOIP2016」组合数问题 - 递推 + 前缀和\ncategories: OI\ntags: \n  - NOIP\n  - 前缀和\n  - 数学\n  - 组合数\npermalink: noip2016-problem\ndate: 2016-11-29 20:54:00\n---\n\n组合数表示的是从 $ n $ 个物品中选出 $ m $ 个物品的方案数。举个例子，从 $ (1, 2, 3) $ 三个物品中选择两个物品可以有 $ (1, 2) $，$ (1, 3) $，$ (2, 3) $ 这三种选择方法。\n\n根据组合数的定义，我们可以给出计算组合数的一般公式：\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n其中 $ n! = 1 \\times 2 \\times \\cdots \\times n $。\n\n小葱想知道如果给定 $ n $，$ m $ 和 $ k $，对于所有的 $ 0 \\leq i \\leq n $，$ 0 \\leq j \\leq \\min(i, m) $ 有多少对 $ (i, j) $ 满足是 $ k $ 的倍数。\n\n<!-- more -->\n\n### 链接\n[Luogu 2822](https://www.luogu.org/problem/show?pid=2822)  \n[LYOI #102](https://ly.men.ci/problem/102)\n\n### 题解\n根据 Pascal 定理，有\n\n$$ C_n ^ m = C_{n - 1} ^ {m - 1} + C_{n - 1} ^ {m} $$\n\n预处理出每个 $ C_i ^ j \\bmod k $，前缀和 $ s(u, i) $ 统计对于 $ 1 \\leq j \\leq i $，有多少 $ C_u ^ j \\bmod k = 0 $。每次询问 $ O(n) $ 的在前缀和中求和即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000 + 10;\n\nint C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1];\n\nint main() {\n\tfreopen(\"problem.in\", \"r\", stdin);\n\tfreopen(\"problem.out\", \"w\", stdout);\n\t\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\t\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcnt[i][j] = cnt[i][j - 1];\n\t\t\tif (C[i][j] == 0) cnt[i][j]++;\n\t\t}\n\t}\n\t\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += cnt[i][std::min(i, m)];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"noip2016-problem","published":1,"updated":"2016-11-29T13:12:22.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rks00l6ooxlzwyn17nd"},{"title":"「NOIP2016」蚯蚓 - 队列","date":"2016-11-29T13:10:00.000Z","_content":"\n本题中，我们将用符号 $ \\lfloor c \\rfloor $ 表示对 $ c $ 向下取整，例如：$ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $。\n\n蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。\n\n蛐蛐国里现在共有 $ n $ 只蚯蚓（$ n $ 为正整数）。每只蚯蚓拥有长度，我们设第 $ i $ 只蚯蚓的长度为 $ a_i $（$ i = 1, 2, \\ldots , n $），并保证所有的长度都是非负整数（即：可能存在长度为 $ 0 $ 的蚯蚓）。\n\n每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $ p $（是满足 $ 0 < p < 1 $ 的有理数）决定，设这只蚯蚓长度为 $ x $，神刀手会将其切成两只长度分别为 $ \\lfloor px \\rfloor $ 和 $ x - \\lfloor px \\rfloor $ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $ 0 $，则这个长度为 $ 0 $ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $ q $（是一个非负整常数）。\n\n蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $ m $ 秒才能到来 ……（$ m $ 为非负整数）\n\n蛐蛐国王希望知道这 $ m $ 秒内的战况。具体来说，他希望知道：\n\n* $ m $ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $ m $ 个数）；\n* $ m $ 秒后，所有蚯蚓的长度（有 $ n + m $ 个数）。\n\n蛐蛐国王当然知道怎么做啦！但是他想考考你 ……\n\n<!-- more -->\n\n### 链接\n[Luogu 2827](https://www.luogu.org/problem/show?pid=2827)  \n[LYOI #103](https://ly.men.ci/problem/103)\n\n### 题解\n当 $ q = 0 $ 时，如果我们将每次切开后得到的蚯蚓分别放到两个序列中，则这两个序列都是单调的。将最初的蚯蚓排序，作为另一个序列。每次从三个序列中寻找最大值，删除，计算新蚯蚓插入到两个序列中即可。\n\n当 $ q \\neq 0 $ 时，每次只有两个新蚯蚓不增加长度，我们可以记录所有的蚯蚓被统一增加的长度，对每次不增加的减去这个长度。显然，单调性仍然满足。\n\n时间复杂度为 $ O(n \\log n + m) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 7000000;\n\ntemplate <typename T>\nstruct Queue {\n    T a[MAXN + MAXM], *l, *r;\n\n    Queue() : l(a), r(a - 1) {}\n\n    void push(const T &x) { *++r = x; }\n    void pop() { ++l; }\n    T &front() { return *l; }\n    bool empty() const { return l > r; }\n};\n\n#ifdef DBG\nstd::queue<int> q[3];\n#else\nQueue<int> q[3];\n#endif\n\ninline int getMax() {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\n#ifdef DBG\ninline void printAll(int d) {\n    std::vector<int> v;\n    for (int i = 0; i < 3; i++) {\n        std::queue<int> a = ::q[i];\n        while (!a.empty()) v.push_back(a.front()), a.pop();\n    }\n    std::sort(v.begin(), v.end());\n    printf(\"%lu: \", v.size());\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) printf(\"%d%c\", *it, it == --v.end() ? '\\n' : ' ');\n}\n#endif\n\nint main() {\n    freopen(\"earthworm.in\", \"r\", stdin);\n    freopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n    static int a[MAXN + 1];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    std::sort(a + 1, a + n + 1);\n\n    for (int i = n; i >= 1; i--) q[0].push(a[i]);\n\n    int d = 0;\n    for (int i = 1; i <= m; i++) {\n        int j = getMax();\n\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n\n        int a = static_cast<long long>(x) * u / v, b = x - a;\n\n        d += k;\n        a -= d, b -= d;\n\n        q[1].push(a), q[2].push(b);\n    }\n\n    putchar('\\n');\n\n    for (int i = 1; i <= n + m; i++) {\n        int j = getMax();\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n    }\n\n    putchar('\\n');\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","source":"_posts/noip2016-earthworm.md","raw":"title: 「NOIP2016」蚯蚓 - 队列\ncategories: OI\ntags: \n  - NOIP\n  - 队列\npermalink: noip2016-earthworm\ndate: 2016-11-29 21:10:00\n---\n\n本题中，我们将用符号 $ \\lfloor c \\rfloor $ 表示对 $ c $ 向下取整，例如：$ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $。\n\n蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。\n\n蛐蛐国里现在共有 $ n $ 只蚯蚓（$ n $ 为正整数）。每只蚯蚓拥有长度，我们设第 $ i $ 只蚯蚓的长度为 $ a_i $（$ i = 1, 2, \\ldots , n $），并保证所有的长度都是非负整数（即：可能存在长度为 $ 0 $ 的蚯蚓）。\n\n每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $ p $（是满足 $ 0 < p < 1 $ 的有理数）决定，设这只蚯蚓长度为 $ x $，神刀手会将其切成两只长度分别为 $ \\lfloor px \\rfloor $ 和 $ x - \\lfloor px \\rfloor $ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $ 0 $，则这个长度为 $ 0 $ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $ q $（是一个非负整常数）。\n\n蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $ m $ 秒才能到来 ……（$ m $ 为非负整数）\n\n蛐蛐国王希望知道这 $ m $ 秒内的战况。具体来说，他希望知道：\n\n* $ m $ 秒内，每一秒被切断的蚯蚓被切断前的长度（有 $ m $ 个数）；\n* $ m $ 秒后，所有蚯蚓的长度（有 $ n + m $ 个数）。\n\n蛐蛐国王当然知道怎么做啦！但是他想考考你 ……\n\n<!-- more -->\n\n### 链接\n[Luogu 2827](https://www.luogu.org/problem/show?pid=2827)  \n[LYOI #103](https://ly.men.ci/problem/103)\n\n### 题解\n当 $ q = 0 $ 时，如果我们将每次切开后得到的蚯蚓分别放到两个序列中，则这两个序列都是单调的。将最初的蚯蚓排序，作为另一个序列。每次从三个序列中寻找最大值，删除，计算新蚯蚓插入到两个序列中即可。\n\n当 $ q \\neq 0 $ 时，每次只有两个新蚯蚓不增加长度，我们可以记录所有的蚯蚓被统一增加的长度，对每次不增加的减去这个长度。显然，单调性仍然满足。\n\n时间复杂度为 $ O(n \\log n + m) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 7000000;\n\ntemplate <typename T>\nstruct Queue {\n    T a[MAXN + MAXM], *l, *r;\n\n    Queue() : l(a), r(a - 1) {}\n\n    void push(const T &x) { *++r = x; }\n    void pop() { ++l; }\n    T &front() { return *l; }\n    bool empty() const { return l > r; }\n};\n\n#ifdef DBG\nstd::queue<int> q[3];\n#else\nQueue<int> q[3];\n#endif\n\ninline int getMax() {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\n#ifdef DBG\ninline void printAll(int d) {\n    std::vector<int> v;\n    for (int i = 0; i < 3; i++) {\n        std::queue<int> a = ::q[i];\n        while (!a.empty()) v.push_back(a.front()), a.pop();\n    }\n    std::sort(v.begin(), v.end());\n    printf(\"%lu: \", v.size());\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) printf(\"%d%c\", *it, it == --v.end() ? '\\n' : ' ');\n}\n#endif\n\nint main() {\n    freopen(\"earthworm.in\", \"r\", stdin);\n    freopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n    static int a[MAXN + 1];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    std::sort(a + 1, a + n + 1);\n\n    for (int i = n; i >= 1; i--) q[0].push(a[i]);\n\n    int d = 0;\n    for (int i = 1; i <= m; i++) {\n        int j = getMax();\n\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n\n        int a = static_cast<long long>(x) * u / v, b = x - a;\n\n        d += k;\n        a -= d, b -= d;\n\n        q[1].push(a), q[2].push(b);\n    }\n\n    putchar('\\n');\n\n    for (int i = 1; i <= n + m; i++) {\n        int j = getMax();\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n    }\n\n    putchar('\\n');\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","slug":"noip2016-earthworm","published":1,"updated":"2016-11-29T13:11:22.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rkv00lcooxls72wclbx"},{"title":"「NOIP2016」换教室 - Floyd + DP + 概率与期望","date":"2016-11-29T07:35:00.000Z","_content":"\n对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。\n\n在可以选择的课程中，有 $ 2n $ 节课程安排在 $ n $ 个时间段上。在第 $ i $ （$ 1 \\leq  i \\leq n $）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $ c_i $ 上课，而另一节课程在教室 $ d_i $ 进行。\n\n在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 $ n $ 节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $ i $ 个时间段去教室 $ d_i $ 上课，否则仍然在教室 $ c_i $ 上课。\n\n由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $ i $ 节课程的教室时，申请被通过的概率是一个已知的实数 $ k_i $，并且对于不同课程的申请，被通过的概率是互相独立的。\n\n学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $ m $ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 $ m $ 门课程，也可以不用完这 $ m $ 个申请的机会，甚至可以一门课程都不申请。\n\n因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课问时间从一间教室赶到另一间教室。\n\n牛牛所在的大学有 $ v $ 个教室，有 $ e $ 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 $ i $（$ 1 \\leq i \\leq n - 1 $）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。\n\n现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。\n\n<!-- more -->\n\n### 链接\n[Luogu 1850](https://www.luogu.org/problem/show?pid=1850)  \n[LYOI #101](https://ly.men.ci/problem/101)\n\n### 题解\n使用 Floyd 算法求出任意两点间的最短路。考虑到某一节课的教室只会影响到最近两段路程，设 $ f(i, j, k) $ 表示前 $ i $ 节课，使用了 $ j $ 次申请交换，$ k \\in \\{ 0, 1 \\} $ 表示第 $ i $ 次是否申请交换的最小期望。\n\n首先考虑 $ f(i, j, 0) $ 的转移。上一次可以申请，也可以不申请，取较小值：\n\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i, j, 1) $ 的转移稍微复杂一些\n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n边界\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n时间复杂度为 $ O(v ^ 3 + nm) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <climits>\n#include <algorithm>\n\nconst int MAXCNT = 2000;\nconst int MAXN = 300;\n\nint cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1];\ndouble k[MAXCNT + 1];\n\nint main() {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d %d %d\", &cnt, &max, &n, &m);\n\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[u][v] = g[v][u] = std::min(g[u][v], w);\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (g[i][k] != INT_MAX && g[k][j] != INT_MAX && g[i][j] > g[i][k] + g[k][j]) {\n\t\t\t\t\tg[i][j] = g[i][k] + g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) g[i][i] = 0;\n\n\tstatic double f[MAXCNT + 1][MAXCNT + 1][2];\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\n\tfor (int i = 2; i <= cnt; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= max; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tfor (int j = 0; j <= max; j++) {\n\t\t\tprintf(\"f[%d][%d][0] = %.4lf\\n\", i, j, f[i][j][0]);\n\t\t\tprintf(\"f[%d][%d][1] = %.4lf\\n\", i, j, f[i][j][1]);\n\t\t}\n#endif\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor (int i = 0; i <= max; i++) {\n\t\tans = std::min(ans, f[cnt][i][0]);\n\t\tans = std::min(ans, f[cnt][i][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-classroom.md","raw":"title: 「NOIP2016」换教室 - Floyd + DP + 概率与期望\ncategories: OI\ntags: \n  - NOIP\n  - DP\n  - Floyd\n  - 概率与期望\npermalink: noip2016-classroom\ndate: 2016-11-29 15:35:00\n---\n\n对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。\n\n在可以选择的课程中，有 $ 2n $ 节课程安排在 $ n $ 个时间段上。在第 $ i $ （$ 1 \\leq  i \\leq n $）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $ c_i $ 上课，而另一节课程在教室 $ d_i $ 进行。\n\n在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 $ n $ 节安排好的课程。如果学生想更换第i节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $ i $ 个时间段去教室 $ d_i $ 上课，否则仍然在教室 $ c_i $ 上课。\n\n由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $ i $ 节课程的教室时，申请被通过的概率是一个已知的实数 $ k_i $，并且对于不同课程的申请，被通过的概率是互相独立的。\n\n学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $ m $ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请白己最希望更换教室的 $ m $ 门课程，也可以不用完这 $ m $ 个申请的机会，甚至可以一门课程都不申请。\n\n因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课问时间从一间教室赶到另一间教室。\n\n牛牛所在的大学有 $ v $ 个教室，有 $ e $ 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 $ i $（$ 1 \\leq i \\leq n - 1 $）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。\n\n现在牛牛想知道，申请哪几门课程可以使他因在教室问移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。\n\n<!-- more -->\n\n### 链接\n[Luogu 1850](https://www.luogu.org/problem/show?pid=1850)  \n[LYOI #101](https://ly.men.ci/problem/101)\n\n### 题解\n使用 Floyd 算法求出任意两点间的最短路。考虑到某一节课的教室只会影响到最近两段路程，设 $ f(i, j, k) $ 表示前 $ i $ 节课，使用了 $ j $ 次申请交换，$ k \\in \\{ 0, 1 \\} $ 表示第 $ i $ 次是否申请交换的最小期望。\n\n首先考虑 $ f(i, j, 0) $ 的转移。上一次可以申请，也可以不申请，取较小值：\n\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i, j, 1) $ 的转移稍微复杂一些\n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n边界\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n时间复杂度为 $ O(v ^ 3 + nm) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <climits>\n#include <algorithm>\n\nconst int MAXCNT = 2000;\nconst int MAXN = 300;\n\nint cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1];\ndouble k[MAXCNT + 1];\n\nint main() {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d %d %d\", &cnt, &max, &n, &m);\n\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[u][v] = g[v][u] = std::min(g[u][v], w);\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (g[i][k] != INT_MAX && g[k][j] != INT_MAX && g[i][j] > g[i][k] + g[k][j]) {\n\t\t\t\t\tg[i][j] = g[i][k] + g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) g[i][i] = 0;\n\n\tstatic double f[MAXCNT + 1][MAXCNT + 1][2];\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\n\tfor (int i = 2; i <= cnt; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= max; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tfor (int j = 0; j <= max; j++) {\n\t\t\tprintf(\"f[%d][%d][0] = %.4lf\\n\", i, j, f[i][j][0]);\n\t\t\tprintf(\"f[%d][%d][1] = %.4lf\\n\", i, j, f[i][j][1]);\n\t\t}\n#endif\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor (int i = 0; i <= max; i++) {\n\t\tans = std::min(ans, f[cnt][i][0]);\n\t\tans = std::min(ans, f[cnt][i][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-classroom","published":1,"updated":"2016-11-29T07:36:33.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rkz00lhooxldw6ys8ng"},{"title":"「NOIP2016」愤怒的小鸟 - 状态压缩 + BFS","date":"2016-11-29T13:21:00.000Z","_content":"\nKiana 最近沉迷于一款神奇的游戏无法自拔。\n\n简单来说，这款游戏是在一个平面上进行的。\n\n有一架弹弓位于 $ (0, 0) $ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $ y = ax ^ 2 + bx $ 的曲线，其中 $ a $，$ b $ 是 Kiana 指定的参数，且必须满足 $ a < 0 $。\n\n当小鸟落回地面（即 $ x $ 轴）时，它就会瞬间消失。\n\n在游戏的某个关卡里，平面的第一象限中有 $ n $ 只绿色的小猪，其中第 $ i $ 只小猪所在的坐标为 $ (x_i, y_i) $。\n\n如果某只小鸟的飞行轨迹经过了$ (x_i, y_i) $，那么第 $ i $ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；\n\n如果一只小鸟的飞行轨迹没有经过$ (x_i, y_i) $，那么这只小鸟飞行的全过程就不会对第 $ i $ 只小猪产生任何影响。\n\n例如，若两只小猪分别位于 $ (1, 3) $ 和 $ (3, 3) $，Kiana 可以选择发射一只飞行轨迹为 $ y = -x ^ 2 + 4x $ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。\n\n而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。\n\n这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。\n\n假设这款游戏一共有 $ T $ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。\n\n<!-- more -->\n\n### 链接\n[Luogu 2831](https://www.luogu.org/problem/show?pid=2831)  \n[LYOI #104](https://ly.men.ci/problem/104)\n\n### 题解\n在 $ y = ax ^ 2 + bx + c $ 中，考虑到 $ c $ 为常数，两个点即可确定这条抛物线。枚举每两个点，计算过这两个点的抛物线，如果 $ a \\leq 0 $ 则舍去，得到 $ O(n ^ 2) $ 条抛物线。枚举每条抛物线，计算有哪些猪在这条抛物线上（即一次操作可以消灭的猪的集合），使用一个二进制数存储。另外，对于不在任何一个合法抛物线上的猪，新增加一条「只过这个猪」的「虚拟」抛物线。\n\n以「当前剩余的猪的集合」为点，每个抛物线为边，建立状态图，BFS 即可得到答案。\n\n时间复杂度 $ O(2 ^ n n ^ 2) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 18 + 3;\nconst int MAXSTATUS = (1 << (MAXN + 1));\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    \n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp(double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp(double x, double y) {\n    return dcmp(x - y);\n}\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n    \n    Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {}\n    \n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n    \n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool visited;\n    int dist;\n} N[MAXSTATUS];\n\nint n, cmd, limit, lineCnt;\n\n/*\n#ifdef DBG\ninline void print(int s) {\n    for (int i = 0; i < n; i++) putchar((s & (1u << i)) ? '1' : '0');\n}\n#endif\n*/\n\ninline int bfs(int status) {\n    if (!status) return 0;\n    \n    std::queue<int> q;\n    q.push(status);\n    N[status].visited = true;\n    N[status].dist = 0;\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        if (N[v].dist == limit) continue;\n        \n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill;\n                \n                if (!N[u].visited) {\n                    N[u].visited = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    \n    return n;\n}\n\n/*\ninline void massert(bool x) {\n    if (!x) {\n        int b = 0;\n        b = 1;\n        b = 2;\n    }\n}\n*/\n\ninline Line getLine(const Point &a, const Point &b) {\n    Line l;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n    // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2)\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    // b = (y1 - a * x1 ^ 2) / x1\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n//    if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) {\n//        printf(\"ERROR: %lf %lf\\n\", l.b, (b.y - l.a * b.x * b.x) / b.x);\n//    }\n    return l;\n}\n\ninline bool onLine(const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve() {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n            \n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n        /*\n#ifdef DBG\n        printf(\"[a = %lf, b = %lf]: \", lines[i].a, lines[i].b);\n        print(lines[i].kill);\n        putchar('\\n');\n#endif\n        */\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1));\n        }\n    }\n        \n    std::sort(lines + 1, lines + lineCnt + 1);\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            }\n        }\n    }\n    \n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].visited = false;\n    }\n    \n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n    \n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n        \n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    fclose(stdin);\n    fclose(stdout);\n}\n```","source":"_posts/noip2016-angrybirds.md","raw":"title: 「NOIP2016」愤怒的小鸟 - 状态压缩 + BFS\ncategories: OI\ntags: \n  - NOIP\n  - 状态压缩\n  - 搜索\n  - BFS\npermalink: noip2016-angrybirds\ndate: 2016-11-29 21:21:00\n---\n\nKiana 最近沉迷于一款神奇的游戏无法自拔。\n\n简单来说，这款游戏是在一个平面上进行的。\n\n有一架弹弓位于 $ (0, 0) $ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $ y = ax ^ 2 + bx $ 的曲线，其中 $ a $，$ b $ 是 Kiana 指定的参数，且必须满足 $ a < 0 $。\n\n当小鸟落回地面（即 $ x $ 轴）时，它就会瞬间消失。\n\n在游戏的某个关卡里，平面的第一象限中有 $ n $ 只绿色的小猪，其中第 $ i $ 只小猪所在的坐标为 $ (x_i, y_i) $。\n\n如果某只小鸟的飞行轨迹经过了$ (x_i, y_i) $，那么第 $ i $ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；\n\n如果一只小鸟的飞行轨迹没有经过$ (x_i, y_i) $，那么这只小鸟飞行的全过程就不会对第 $ i $ 只小猪产生任何影响。\n\n例如，若两只小猪分别位于 $ (1, 3) $ 和 $ (3, 3) $，Kiana 可以选择发射一只飞行轨迹为 $ y = -x ^ 2 + 4x $ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。\n\n而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。\n\n这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入格式」中详述。\n\n假设这款游戏一共有 $ T $ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。\n\n<!-- more -->\n\n### 链接\n[Luogu 2831](https://www.luogu.org/problem/show?pid=2831)  \n[LYOI #104](https://ly.men.ci/problem/104)\n\n### 题解\n在 $ y = ax ^ 2 + bx + c $ 中，考虑到 $ c $ 为常数，两个点即可确定这条抛物线。枚举每两个点，计算过这两个点的抛物线，如果 $ a \\leq 0 $ 则舍去，得到 $ O(n ^ 2) $ 条抛物线。枚举每条抛物线，计算有哪些猪在这条抛物线上（即一次操作可以消灭的猪的集合），使用一个二进制数存储。另外，对于不在任何一个合法抛物线上的猪，新增加一条「只过这个猪」的「虚拟」抛物线。\n\n以「当前剩余的猪的集合」为点，每个抛物线为边，建立状态图，BFS 即可得到答案。\n\n时间复杂度 $ O(2 ^ n n ^ 2) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 18 + 3;\nconst int MAXSTATUS = (1 << (MAXN + 1));\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    \n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp(double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp(double x, double y) {\n    return dcmp(x - y);\n}\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n    \n    Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {}\n    \n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n    \n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool visited;\n    int dist;\n} N[MAXSTATUS];\n\nint n, cmd, limit, lineCnt;\n\n/*\n#ifdef DBG\ninline void print(int s) {\n    for (int i = 0; i < n; i++) putchar((s & (1u << i)) ? '1' : '0');\n}\n#endif\n*/\n\ninline int bfs(int status) {\n    if (!status) return 0;\n    \n    std::queue<int> q;\n    q.push(status);\n    N[status].visited = true;\n    N[status].dist = 0;\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        if (N[v].dist == limit) continue;\n        \n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill;\n                \n                if (!N[u].visited) {\n                    N[u].visited = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    \n    return n;\n}\n\n/*\ninline void massert(bool x) {\n    if (!x) {\n        int b = 0;\n        b = 1;\n        b = 2;\n    }\n}\n*/\n\ninline Line getLine(const Point &a, const Point &b) {\n    Line l;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n    // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2)\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    // b = (y1 - a * x1 ^ 2) / x1\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n//    if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) {\n//        printf(\"ERROR: %lf %lf\\n\", l.b, (b.y - l.a * b.x * b.x) / b.x);\n//    }\n    return l;\n}\n\ninline bool onLine(const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve() {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n            \n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n        /*\n#ifdef DBG\n        printf(\"[a = %lf, b = %lf]: \", lines[i].a, lines[i].b);\n        print(lines[i].kill);\n        putchar('\\n');\n#endif\n        */\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1));\n        }\n    }\n        \n    std::sort(lines + 1, lines + lineCnt + 1);\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            }\n        }\n    }\n    \n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].visited = false;\n    }\n    \n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n    \n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n        \n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    fclose(stdin);\n    fclose(stdout);\n}\n```","slug":"noip2016-angrybirds","published":1,"updated":"2016-11-29T13:22:13.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rl400loooxl33swj2te"},{"title":"「NOIP2015」运输计划 - 最近公共祖先 + 二分 + 树上路径交","date":"2016-10-19T09:19:00.000Z","_content":"\n在一棵树上，每条边有边权，给定 $ m $ 个路径 $ u_i \\leftrightarrow v_i $，求将其中一条边的边权置为 $ 0 $，使得 $ m $ 个路径的长度和最小。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4632](http://codevs.cn/problem/4632/)  \n[CodeVS 5440](http://codevs.cn/problem/5440/)  \n[BZOJ 4326](http://www.lydsy.com/JudgeOnline/problem.php?id=4326)  \n\n### 题解\n求出每条路径两个端点的最近公共祖先，进而求出每条路径的长度。二分一个答案 $ x $，所有长度 $ > x $ 的路径上都至少需要删去一条边。对这些路径求交，最优方案一定是删去路径交中长度最大的边，如果删去最大的边后，最长的路径仍不满足 $ \\leq x $，则答案 $ x $ 不合法。\n\n考虑如何求树上路径交。这里使用**树上前缀和**的方法，对于一条路径 $ u_i \\leftrightarrow v_i $，设 $ p_i = \\mathrm{lca}(u_i, v_i) $，在 $ u_i $ 和 $ v_i $ 上打上 $ +1 $ 标记，在 $ p_i $ 上打上 $ -2 $ 标记。从每个叶子节点向父节点走，走到根，路径上经过每一条边时的前缀和即为这条边被经过的次数。被每一条路径都经过的边组成的集合即为路径交。\n\n### 代码\n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <new>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 300000;\nconst int MAXM = 300000;\nconst int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tbool visited;\n\tint pos, depth, cover, dist;\n} N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w, cover;\n\tEdge *next;\n\n\tEdge() {}\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n} mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1];\n\nstruct Path {\n\tNode *u, *v, *p;\n\tint dist;\n} a[MAXM];\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new (pEdge++) Edge(&N[s], &N[t], w);\n\tN[t].e = new (pEdge++) Edge(&N[t], &N[s], w);\n}\n\nint n, m, log[MAXN * 2 + 1], max, eulerTourLen;\n\ninline void dfs() {\n\tstatic Node *s[MAXN];\n\tNode **top = s;\n\t*s = &N[0];\n\tN[0].depth = 1;\n\n\tint ts = 0;\n\twhile (top >= s) {\n\t\tNode *v = *top;\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->pos = eulerTourLen;\n\t\t\tdfsSequence[ts++] = v;\n\t\t}\n\n\t\teulerTour[eulerTourLen++] = v;\n\n\t\twhile (v->c && v->c->t->depth) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tif (!v->c->t->depth) {\n\t\t\t\tv->c->t->depth = v->depth + 1;\n\t\t\t\tv->c->t->dist = v->dist + v->c->w;\n\t\t\t\tv->c->t->in = v->c;\n\t\t\t\t*++top = v->c->t;\n\t\t\t}\n\t\t\tv->c = v->c->next;\n\t\t} else {\n\t\t\ttop--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) E[i - 1] = N[i].in;\n}\n\ninline Node *min(Node *a, Node *b) {\n\treturn a->depth < b->depth ? a : b;\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < eulerTourLen; i++) st[i][0] = eulerTour[i];\n\tfor (int j = 1; (1 << j) <= eulerTourLen; j++) {\n\t\tfor (int i = 0; i < eulerTourLen; i++) {\n\t\t\tif (i + (1 << (j - 1)) < eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= eulerTourLen; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t}\n}\n\ninline Node *rmq(const int l, const int r) {\n\tif (l == r) return st[l][0];\n\telse {\n\t\tconst int t = log[r - l];\n\t\treturn min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n}\n\ninline Node *lca(Node *u, Node *v) {\n\treturn rmq(std::min(u->pos, v->pos), std::max(u->pos, v->pos));\n}\n\ninline int distance(Node *u, Node *v, Node *p) {\n\treturn u->dist + v->dist - p->dist * 2;\n}\n\ninline bool check(const int limit) {\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[i].dist > limit) {\n\t\t\ta[i].p->cover -= 2;\n\t\t\ta[i].u->cover++;\n\t\t\ta[i].v->cover++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (dfsSequence[i]->in) {\n\t\t\tdfsSequence[i]->in->cover = dfsSequence[i]->cover;\n\t\t\tdfsSequence[i]->in->s->cover += dfsSequence[i]->cover;\n\t\t}\n\t\tdfsSequence[i]->cover = 0;\n\t}\n\n\tEdge *maxEdge = NULL;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (E[i]->cover == cnt && (!maxEdge || E[i]->w > maxEdge->w)) maxEdge = E[i];\n\t}\n\n\treturn maxEdge && max - maxEdge->w <= limit;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tdfs();\n\tsparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v), u--, v--;\n\t\ta[i].u = &N[u], a[i].v = &N[v];\n\t\ta[i].p = lca(a[i].u, a[i].v);\n\t\ta[i].dist = distance(a[i].u, a[i].v, a[i].p);\n\t\tmax = std::max(max, a[i].dist);\n\t\t// printf(\"lca(%lu, %lu) = %lu\\n\", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1);\n\t}\n\n\tint l = 0, r = max;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\t// check(11);\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2015-transport.md","raw":"title: 「NOIP2015」运输计划 - 最近公共祖先 + 二分 + 树上路径交\ncategories: OI\ntags: \n  - NOIP\n  - BZOJ\n  - CodeVS\n  - 最近公共祖先\npermalink: noip2015-transport\ndate: 2016-10-19 17:19:00\n---\n\n在一棵树上，每条边有边权，给定 $ m $ 个路径 $ u_i \\leftrightarrow v_i $，求将其中一条边的边权置为 $ 0 $，使得 $ m $ 个路径的长度和最小。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4632](http://codevs.cn/problem/4632/)  \n[CodeVS 5440](http://codevs.cn/problem/5440/)  \n[BZOJ 4326](http://www.lydsy.com/JudgeOnline/problem.php?id=4326)  \n\n### 题解\n求出每条路径两个端点的最近公共祖先，进而求出每条路径的长度。二分一个答案 $ x $，所有长度 $ > x $ 的路径上都至少需要删去一条边。对这些路径求交，最优方案一定是删去路径交中长度最大的边，如果删去最大的边后，最长的路径仍不满足 $ \\leq x $，则答案 $ x $ 不合法。\n\n考虑如何求树上路径交。这里使用**树上前缀和**的方法，对于一条路径 $ u_i \\leftrightarrow v_i $，设 $ p_i = \\mathrm{lca}(u_i, v_i) $，在 $ u_i $ 和 $ v_i $ 上打上 $ +1 $ 标记，在 $ p_i $ 上打上 $ -2 $ 标记。从每个叶子节点向父节点走，走到根，路径上经过每一条边时的前缀和即为这条边被经过的次数。被每一条路径都经过的边组成的集合即为路径交。\n\n### 代码\n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <new>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 300000;\nconst int MAXM = 300000;\nconst int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tbool visited;\n\tint pos, depth, cover, dist;\n} N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w, cover;\n\tEdge *next;\n\n\tEdge() {}\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n} mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1];\n\nstruct Path {\n\tNode *u, *v, *p;\n\tint dist;\n} a[MAXM];\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new (pEdge++) Edge(&N[s], &N[t], w);\n\tN[t].e = new (pEdge++) Edge(&N[t], &N[s], w);\n}\n\nint n, m, log[MAXN * 2 + 1], max, eulerTourLen;\n\ninline void dfs() {\n\tstatic Node *s[MAXN];\n\tNode **top = s;\n\t*s = &N[0];\n\tN[0].depth = 1;\n\n\tint ts = 0;\n\twhile (top >= s) {\n\t\tNode *v = *top;\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->pos = eulerTourLen;\n\t\t\tdfsSequence[ts++] = v;\n\t\t}\n\n\t\teulerTour[eulerTourLen++] = v;\n\n\t\twhile (v->c && v->c->t->depth) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tif (!v->c->t->depth) {\n\t\t\t\tv->c->t->depth = v->depth + 1;\n\t\t\t\tv->c->t->dist = v->dist + v->c->w;\n\t\t\t\tv->c->t->in = v->c;\n\t\t\t\t*++top = v->c->t;\n\t\t\t}\n\t\t\tv->c = v->c->next;\n\t\t} else {\n\t\t\ttop--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) E[i - 1] = N[i].in;\n}\n\ninline Node *min(Node *a, Node *b) {\n\treturn a->depth < b->depth ? a : b;\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < eulerTourLen; i++) st[i][0] = eulerTour[i];\n\tfor (int j = 1; (1 << j) <= eulerTourLen; j++) {\n\t\tfor (int i = 0; i < eulerTourLen; i++) {\n\t\t\tif (i + (1 << (j - 1)) < eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= eulerTourLen; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t}\n}\n\ninline Node *rmq(const int l, const int r) {\n\tif (l == r) return st[l][0];\n\telse {\n\t\tconst int t = log[r - l];\n\t\treturn min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n}\n\ninline Node *lca(Node *u, Node *v) {\n\treturn rmq(std::min(u->pos, v->pos), std::max(u->pos, v->pos));\n}\n\ninline int distance(Node *u, Node *v, Node *p) {\n\treturn u->dist + v->dist - p->dist * 2;\n}\n\ninline bool check(const int limit) {\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[i].dist > limit) {\n\t\t\ta[i].p->cover -= 2;\n\t\t\ta[i].u->cover++;\n\t\t\ta[i].v->cover++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (dfsSequence[i]->in) {\n\t\t\tdfsSequence[i]->in->cover = dfsSequence[i]->cover;\n\t\t\tdfsSequence[i]->in->s->cover += dfsSequence[i]->cover;\n\t\t}\n\t\tdfsSequence[i]->cover = 0;\n\t}\n\n\tEdge *maxEdge = NULL;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (E[i]->cover == cnt && (!maxEdge || E[i]->w > maxEdge->w)) maxEdge = E[i];\n\t}\n\n\treturn maxEdge && max - maxEdge->w <= limit;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tdfs();\n\tsparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v), u--, v--;\n\t\ta[i].u = &N[u], a[i].v = &N[v];\n\t\ta[i].p = lca(a[i].u, a[i].v);\n\t\ta[i].dist = distance(a[i].u, a[i].v, a[i].p);\n\t\tmax = std::max(max, a[i].dist);\n\t\t// printf(\"lca(%lu, %lu) = %lu\\n\", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1);\n\t}\n\n\tint l = 0, r = max;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\t// check(11);\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```\n","slug":"noip2015-transport","published":1,"updated":"2016-10-19T13:07:29.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rld00lwooxllsb6x8v1"},{"title":"「NOIP2015」子串 - DP","date":"2016-10-19T08:48:00.000Z","_content":"\n有两个仅包含小写英文字母的字符串 $ A $ 和 $ B $。现在要从字符串 $ A $ 中取出 $ k $ 个互不重叠的非空子串，然后把这 $ k $ 个子串按照其在字符串 $ A $ 中出现的顺序依次连接起来得到一个新的字符串，请问有多少种方案可以使得这个新串与字符串 $ B $ 相等？  \n注意：子串取出的位置不同也认为是不同的方案。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4560](http://codevs.cn/problem/4560/)\n\n### 题解\n设 $ f(i, j, t) $ 表示字符串 $ A $ 的前 $ i $ 位和字符串 $ B $ 的前 $ j $ 位（必选 $ A_i $），取出 $ t $ 个子串的方案数；$ g(i, j, t) $ 表示字符串 $ A $ 的前 $ i $ 位和字符串 $ B $ 的前 $ j $ 位（不必选 $ A_i $），取出 $ t $ 个子串的方案数。\n\n计算 $ f(i, j, t) $ 时，考虑匹配到前一个字符时的方案数（最后一个子串加一个字符），和单独作为一个子串的方案数。\n\n$$\nf(i, j, t) =\n\\begin{cases}\nf(i - 1, j - 1, t) + g(i - 1, j - 1, t - 1) & A_i = B_j \\\\\n0 & A_i \\neq B_j\n\\end{cases}\n$$\n\n$ g(i, j, t) $ 比较显然\n\n$$\ng(i, j, t) =\n\\begin{cases}\ng(i - 1, j, t) + f(i, j, t) & A_i = B_j \\\\\ng(i - 1, j, t) & A_i \\neq B_j\n\\end{cases}\n$$\n\n边界为 $ f(i, 0, 0) = g(i, 0, 0) = 1 $。\n\n需要滚动数组。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char a[MAXN + 1], b[MAXM + 1];\n\tscanf(\"%s\\n%s\", a, b);\n\n\tstatic int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1];\n\tg[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int curr = i % 2, prev = !curr;\n\t\tmemset(f[curr], 0, sizeof(f[curr]));\n\t\tmemset(g[curr], 0, sizeof(g[curr]));\n\n\t\tg[curr][0][0] = f[curr][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= std::min(j, k); t++) {\n\t\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\t\tf[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD;\n\t\t\t\t\tg[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD;\n#ifdef DBG\n\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\", i, j, t, g[curr][j][t]);\n\t\t\t\t\tprintf(\"f[%d][%d][%d] = %d\\n\", i, j, t, f[curr][j][t]);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tf[curr][j][t] = 0;\n\t\t\t\t\tg[curr][j][t] = g[prev][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2015-substring.md","raw":"title: 「NOIP2015」子串 - DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - DP\npermalink: noip2015-substring\ndate: 2016-10-19 16:48:00\n---\n\n有两个仅包含小写英文字母的字符串 $ A $ 和 $ B $。现在要从字符串 $ A $ 中取出 $ k $ 个互不重叠的非空子串，然后把这 $ k $ 个子串按照其在字符串 $ A $ 中出现的顺序依次连接起来得到一个新的字符串，请问有多少种方案可以使得这个新串与字符串 $ B $ 相等？  \n注意：子串取出的位置不同也认为是不同的方案。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4560](http://codevs.cn/problem/4560/)\n\n### 题解\n设 $ f(i, j, t) $ 表示字符串 $ A $ 的前 $ i $ 位和字符串 $ B $ 的前 $ j $ 位（必选 $ A_i $），取出 $ t $ 个子串的方案数；$ g(i, j, t) $ 表示字符串 $ A $ 的前 $ i $ 位和字符串 $ B $ 的前 $ j $ 位（不必选 $ A_i $），取出 $ t $ 个子串的方案数。\n\n计算 $ f(i, j, t) $ 时，考虑匹配到前一个字符时的方案数（最后一个子串加一个字符），和单独作为一个子串的方案数。\n\n$$\nf(i, j, t) =\n\\begin{cases}\nf(i - 1, j - 1, t) + g(i - 1, j - 1, t - 1) & A_i = B_j \\\\\n0 & A_i \\neq B_j\n\\end{cases}\n$$\n\n$ g(i, j, t) $ 比较显然\n\n$$\ng(i, j, t) =\n\\begin{cases}\ng(i - 1, j, t) + f(i, j, t) & A_i = B_j \\\\\ng(i - 1, j, t) & A_i \\neq B_j\n\\end{cases}\n$$\n\n边界为 $ f(i, 0, 0) = g(i, 0, 0) = 1 $。\n\n需要滚动数组。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char a[MAXN + 1], b[MAXM + 1];\n\tscanf(\"%s\\n%s\", a, b);\n\n\tstatic int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1];\n\tg[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int curr = i % 2, prev = !curr;\n\t\tmemset(f[curr], 0, sizeof(f[curr]));\n\t\tmemset(g[curr], 0, sizeof(g[curr]));\n\n\t\tg[curr][0][0] = f[curr][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= std::min(j, k); t++) {\n\t\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\t\tf[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD;\n\t\t\t\t\tg[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD;\n#ifdef DBG\n\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\", i, j, t, g[curr][j][t]);\n\t\t\t\t\tprintf(\"f[%d][%d][%d] = %d\\n\", i, j, t, f[curr][j][t]);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tf[curr][j][t] = 0;\n\t\t\t\t\tg[curr][j][t] = g[prev][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n```\n","slug":"noip2015-substring","published":1,"updated":"2016-11-02T06:50:28.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rlj00m2ooxlr531mhw2"},{"title":"「NOIP2015」斗地主 - 搜索","date":"2016-10-19T08:30:00.000Z","_content":"\n给一组扑克牌，按照斗地主的规则出牌，求最少多少次出完。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4325](http://www.lydsy.com/JudgeOnline/problem.php?id=4325)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### 题解\n以每种点数的牌的数量为状态（状态可压缩进一个 64 位整数中），搜索。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 13;\n\nconst int CARD_JOKER = 0;\nconst int CARD_2 = 1;\nconst int CARD_3 = 2;\nconst int CARD_4 = 3;\nconst int CARD_5 = 4;\nconst int CARD_6 = 5;\nconst int CARD_7 = 6;\nconst int CARD_8 = 7;\nconst int CARD_9 = 8;\nconst int CARD_10 = 9;\nconst int CARD_J = 10;\nconst int CARD_Q = 11;\nconst int CARD_K = 12;\nconst int CARD_A = 13;\n\ntypedef unsigned long long Status;\n\ninline int id(const int x) {\n\tif (x == 1) return 13;\n\treturn (x >= 2 && x <= 13) ? (x - 1) : x;\n}\n\ninline int get(const Status &s, const int index) {\n\treturn (s >> (index << 2)) & 15ll;\n}\n\n#ifdef DBG\ninline void print(const Status &s, const bool newLine = true) {\n\t// for (int i = 0; i < 64; i++) putchar((s & (1ll << i)) ? '1' : '0');\n\tfor (int i = 0; i < 14; i++) printf(\"%d \", get(s, i));\n\tif (newLine) putchar('\\n');\n}\n#endif\n\ninline void set(Status &s, const int index, const int val) {\n\t/*\n\tif (val < 0) {\n\t\tputs(\"???\");\n\t}\n\t*/\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"=> \");\n#endif\n\ts &= ~(15ll << (index << 2));\n\ts |= (val & 15ll) << (index << 2);\n#ifdef DBG\n\tprint(s);\n#endif\n}\n\ninline void change(Status &s, const int index, const int delta) {\n\tset(s, index, get(s, index) + delta);\n}\n\nint n, ans;\n// std::tr1::unordered_map<Status, int> map;\n\nstruct HashMap {\n\tconst static int HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tStatus key;\n\t\tint val, time;\n\t} N[HASH_SIZE];\n\n\tint time;\n\n\tHashMap() : time(1) {}\n\n\tint locate(const Status &key) {\n\t\tint i;\n\t\tfor (i = key % HASH_SIZE; N[i].time == time && N[i].key != key; (i < HASH_SIZE - 1) ? (i++) : (i = 0));\n\t\tif (N[i].time != time) {\n\t\t\tN[i].time = time;\n\t\t\tN[i].key = key;\n\t\t\tN[i].val = INT_MAX;\n\t\t}\n\t\treturn i;\n\t}\n\n\tint &operator[](const Status &key) {\n\t\treturn N[locate(key)].val;\n\t}\n\n\tvoid clear() {\n\t\ttime++;\n\t}\n} map;\n\ninline void search(const Status &s, const int step = 0) {\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"[%d, %d]\\n\", step, ans);\n#endif\n\tif (step >= ans) return;\n\n\tint &x = map[s];\n\tif (step >= x) return;\n\tx = step;\n\n\t/*\n\tstd::tr1::unordered_map<Status, int>::iterator it = map.find(s);\n\tif (it != map.end() && step >= it->second) return;\n\tmap[s] = step;\n\t*/\n\n\tif (!s) {\n\t\tans = step;\n\t\treturn;\n\t}\n\n\t// 333 444\n\tfor (int i = CARD_3; i <= CARD_K; i++) {\n\t\tStatus next = s;\n\t\tint x = get(next, i);\n\t\tif (x < 3) {\n\t\t\tcontinue;\n\t\t} else set(next, i, x - 3);\n\n\t\tfor (int j = i + 1; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 3) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 3);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 33 44 55\n\tfor (int i = CARD_3; i <= CARD_Q; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 2; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 2);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 2; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3 4 5 6 7\n\tfor (int i = CARD_3; i <= CARD_10; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 4; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 1);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 4; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::vector<int> four, three, two, one;\n\tfor (int i = CARD_JOKER; i <= CARD_A; i++) {\n\t\tint x = get(s, i);\n\t\tif (x == 4) four.push_back(i);\n\t\telse if (x == 3) three.push_back(i);\n\t\telse if (x == 2) two.push_back(i);\n\t\telse if (x == 1) one.push_back(i);\n\t}\n\n\t// 2222 [3 4] / 2222 [33 44]\n\tfor (std::vector<int>::const_iterator it = four.begin(); it != four.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) continue;\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != two.end(); b++) {\n\t\t\t\tif (*b == 0) continue;\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -2);\n\t\t\t\tchange(next, *b, -2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = four.begin(); a != four.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != one.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -1);\n\t\t\t\tchange(next, *b, -1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 222 [3] / 222 [33]\n\tfor (std::vector<int>::const_iterator it = three.begin(); it != three.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = three.begin(); a != three.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) {\n\t\t\t\t// Take only one joker\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 22\n\tfor (std::vector<int>::const_iterator it = two.begin(); it != two.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n\n\t// 2\n\tfor (std::vector<int>::const_iterator it = one.begin(); it != one.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d %d\", &t, &n);\n\twhile (t--) {\n\t\tStatus init = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tchange(init, id(a), 1);\n\t\t}\n\n\t\tmap.clear();\n\t\tans = INT_MAX;\n\t\tsearch(init);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2015-landlords.md","raw":"title: 「NOIP2015」斗地主 - 搜索\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BZOJ\n  - 搜索\npermalink: noip2015-landlords\ndate: 2016-10-19 16:30:00\n---\n\n给一组扑克牌，按照斗地主的规则出牌，求最少多少次出完。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4325](http://www.lydsy.com/JudgeOnline/problem.php?id=4325)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### 题解\n以每种点数的牌的数量为状态（状态可压缩进一个 64 位整数中），搜索。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 13;\n\nconst int CARD_JOKER = 0;\nconst int CARD_2 = 1;\nconst int CARD_3 = 2;\nconst int CARD_4 = 3;\nconst int CARD_5 = 4;\nconst int CARD_6 = 5;\nconst int CARD_7 = 6;\nconst int CARD_8 = 7;\nconst int CARD_9 = 8;\nconst int CARD_10 = 9;\nconst int CARD_J = 10;\nconst int CARD_Q = 11;\nconst int CARD_K = 12;\nconst int CARD_A = 13;\n\ntypedef unsigned long long Status;\n\ninline int id(const int x) {\n\tif (x == 1) return 13;\n\treturn (x >= 2 && x <= 13) ? (x - 1) : x;\n}\n\ninline int get(const Status &s, const int index) {\n\treturn (s >> (index << 2)) & 15ll;\n}\n\n#ifdef DBG\ninline void print(const Status &s, const bool newLine = true) {\n\t// for (int i = 0; i < 64; i++) putchar((s & (1ll << i)) ? '1' : '0');\n\tfor (int i = 0; i < 14; i++) printf(\"%d \", get(s, i));\n\tif (newLine) putchar('\\n');\n}\n#endif\n\ninline void set(Status &s, const int index, const int val) {\n\t/*\n\tif (val < 0) {\n\t\tputs(\"???\");\n\t}\n\t*/\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"=> \");\n#endif\n\ts &= ~(15ll << (index << 2));\n\ts |= (val & 15ll) << (index << 2);\n#ifdef DBG\n\tprint(s);\n#endif\n}\n\ninline void change(Status &s, const int index, const int delta) {\n\tset(s, index, get(s, index) + delta);\n}\n\nint n, ans;\n// std::tr1::unordered_map<Status, int> map;\n\nstruct HashMap {\n\tconst static int HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tStatus key;\n\t\tint val, time;\n\t} N[HASH_SIZE];\n\n\tint time;\n\n\tHashMap() : time(1) {}\n\n\tint locate(const Status &key) {\n\t\tint i;\n\t\tfor (i = key % HASH_SIZE; N[i].time == time && N[i].key != key; (i < HASH_SIZE - 1) ? (i++) : (i = 0));\n\t\tif (N[i].time != time) {\n\t\t\tN[i].time = time;\n\t\t\tN[i].key = key;\n\t\t\tN[i].val = INT_MAX;\n\t\t}\n\t\treturn i;\n\t}\n\n\tint &operator[](const Status &key) {\n\t\treturn N[locate(key)].val;\n\t}\n\n\tvoid clear() {\n\t\ttime++;\n\t}\n} map;\n\ninline void search(const Status &s, const int step = 0) {\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"[%d, %d]\\n\", step, ans);\n#endif\n\tif (step >= ans) return;\n\n\tint &x = map[s];\n\tif (step >= x) return;\n\tx = step;\n\n\t/*\n\tstd::tr1::unordered_map<Status, int>::iterator it = map.find(s);\n\tif (it != map.end() && step >= it->second) return;\n\tmap[s] = step;\n\t*/\n\n\tif (!s) {\n\t\tans = step;\n\t\treturn;\n\t}\n\n\t// 333 444\n\tfor (int i = CARD_3; i <= CARD_K; i++) {\n\t\tStatus next = s;\n\t\tint x = get(next, i);\n\t\tif (x < 3) {\n\t\t\tcontinue;\n\t\t} else set(next, i, x - 3);\n\n\t\tfor (int j = i + 1; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 3) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 3);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 33 44 55\n\tfor (int i = CARD_3; i <= CARD_Q; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 2; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 2);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 2; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3 4 5 6 7\n\tfor (int i = CARD_3; i <= CARD_10; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 4; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 1);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 4; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::vector<int> four, three, two, one;\n\tfor (int i = CARD_JOKER; i <= CARD_A; i++) {\n\t\tint x = get(s, i);\n\t\tif (x == 4) four.push_back(i);\n\t\telse if (x == 3) three.push_back(i);\n\t\telse if (x == 2) two.push_back(i);\n\t\telse if (x == 1) one.push_back(i);\n\t}\n\n\t// 2222 [3 4] / 2222 [33 44]\n\tfor (std::vector<int>::const_iterator it = four.begin(); it != four.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) continue;\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != two.end(); b++) {\n\t\t\t\tif (*b == 0) continue;\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -2);\n\t\t\t\tchange(next, *b, -2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = four.begin(); a != four.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != one.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -1);\n\t\t\t\tchange(next, *b, -1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 222 [3] / 222 [33]\n\tfor (std::vector<int>::const_iterator it = three.begin(); it != three.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = three.begin(); a != three.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) {\n\t\t\t\t// Take only one joker\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 22\n\tfor (std::vector<int>::const_iterator it = two.begin(); it != two.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n\n\t// 2\n\tfor (std::vector<int>::const_iterator it = one.begin(); it != one.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d %d\", &t, &n);\n\twhile (t--) {\n\t\tStatus init = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tchange(init, id(a), 1);\n\t\t}\n\n\t\tmap.clear();\n\t\tans = INT_MAX;\n\t\tsearch(init);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2015-landlords","published":1,"updated":"2016-10-19T08:32:59.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rlm00m7ooxlo7pfy78d"},{"title":"「NOIP2014」解方程 - Hash","date":"2016-10-19T08:25:00.000Z","_content":"\n已知多项式方程：\n\n$$ a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $$\n\n求这个方程在 $ [1, m] $ 内的整数解。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3751](http://www.lydsy.com/JudgeOnline/problem.php?id=3751)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### 题解\n设 $ f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $，我们对于一个质数 $ p $ 取模，如果 $ f(x) = 0 $，则一定有 $ f(x) \\bmod p = 0 $。\n\n求出所有满足 $ f(x) \\bmod p = 0 $ 的 $ x $（根据拉格朗日定理，最多有 $ n $ 个解），则所有 $ x' = x + kp \\leq m $ 均可能为原方程的解。在模另一个质数 $ p' $ 的意义下检验，如果 $ f(x') \\bmod p' = 0 $，则可以认为 $ x' $ 是原方程的解。\n\n时间复杂度为 $ O(np + n \\frac{nm}{p}) $，取 $ p \\approx \\sqrt {nm} $ 时，复杂度为 $ O(n \\sqrt{nm}) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <list>\n\nconst int MAXN = 100;\nconst int MAXLEN = 10000 + 1;\nconst int MAXM = 1000000;\nconst int MOD = 21893;\nconst int MOD2 = 18341629;\n\nint parse(const char *s, const int mod) {\n\tint res = 0, sgn = 1;\n\tif (*s == '-') s++, sgn = -1;\n\tfor (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod;\n\treturn res * sgn;\n}\n\nint main() {\n\tstatic char s[MAXN + 1][MAXLEN + 1];\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 0; i <= n; i++) a[i] = parse(s[i], MOD);\n\n\tstd::list<int> roots;\n\tfor (int i = 1; i < MOD; i++) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD;\n\t\t\tpow = pow * i % MOD;\n\t\t}\n\t\t\n\t\tif (val == 0) {\n\t\t\tfor (int j = i; j <= m; j += MOD) roots.push_back(j);\n\t\t}\n\t}\n\n\tfor (int j = 0; j <= n; j++) a[j] = parse(s[j], MOD2);\n\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD2;\n\t\t\tpow = pow * *it % MOD2;\n\t\t}\n\n\t\tif (val != 0) it = roots.erase(it);\n\t\telse it++;\n\t}\n\n\tprintf(\"%lu\\n\", roots.size());\n\troots.sort();\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","source":"_posts/noip2014-equation.md","raw":"title: 「NOIP2014」解方程 - Hash\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BZOJ\n  - Hash\n  - 数学\npermalink: noip2014-equation\ndate: 2016-10-19 16:25:00\n---\n\n已知多项式方程：\n\n$$ a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $$\n\n求这个方程在 $ [1, m] $ 内的整数解。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3751](http://www.lydsy.com/JudgeOnline/problem.php?id=3751)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### 题解\n设 $ f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $，我们对于一个质数 $ p $ 取模，如果 $ f(x) = 0 $，则一定有 $ f(x) \\bmod p = 0 $。\n\n求出所有满足 $ f(x) \\bmod p = 0 $ 的 $ x $（根据拉格朗日定理，最多有 $ n $ 个解），则所有 $ x' = x + kp \\leq m $ 均可能为原方程的解。在模另一个质数 $ p' $ 的意义下检验，如果 $ f(x') \\bmod p' = 0 $，则可以认为 $ x' $ 是原方程的解。\n\n时间复杂度为 $ O(np + n \\frac{nm}{p}) $，取 $ p \\approx \\sqrt {nm} $ 时，复杂度为 $ O(n \\sqrt{nm}) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <list>\n\nconst int MAXN = 100;\nconst int MAXLEN = 10000 + 1;\nconst int MAXM = 1000000;\nconst int MOD = 21893;\nconst int MOD2 = 18341629;\n\nint parse(const char *s, const int mod) {\n\tint res = 0, sgn = 1;\n\tif (*s == '-') s++, sgn = -1;\n\tfor (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod;\n\treturn res * sgn;\n}\n\nint main() {\n\tstatic char s[MAXN + 1][MAXLEN + 1];\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 0; i <= n; i++) a[i] = parse(s[i], MOD);\n\n\tstd::list<int> roots;\n\tfor (int i = 1; i < MOD; i++) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD;\n\t\t\tpow = pow * i % MOD;\n\t\t}\n\t\t\n\t\tif (val == 0) {\n\t\t\tfor (int j = i; j <= m; j += MOD) roots.push_back(j);\n\t\t}\n\t}\n\n\tfor (int j = 0; j <= n; j++) a[j] = parse(s[j], MOD2);\n\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD2;\n\t\t\tpow = pow * *it % MOD2;\n\t\t}\n\n\t\tif (val != 0) it = roots.erase(it);\n\t\telse it++;\n\t}\n\n\tprintf(\"%lu\\n\", roots.size());\n\troots.sort();\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","slug":"noip2014-equation","published":1,"updated":"2016-10-19T08:26:26.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rlp00mdooxln4fgznoz"},{"title":"「NOIP2014」飞扬的小鸟 - 背包 DP","date":"2016-10-08T09:06:00.000Z","_content":"\n* 游戏界面是一个长为 $ n $，高为 $ m $ 的二维平面，其中有 $ k $ 个管道（忽略管道的宽度）。\n* 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。\n* 小鸟每个单位时间沿横坐标方向右移的距离为 $ 1 $，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 $ X $，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 $ Y $。小鸟位于横坐标方向不同位置时，上升的高度 $ X $ 和下降的高度 $ Y $ 可能互不相同。\n* 小鸟高度等于 $ 0 $ 或者小鸟碰到管道时，游戏失败。小鸟高度为 $ m $ 时，无法再上升。\n\n现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。\n\n<!-- more -->\n\n### 链接\n[COGS 1805](http://cogs.pro/cogs/problem/problem.php?pid=1805)  \n[CodeVS 3729](http://codevs.cn/problem/3729/)\n\n### 题解\n动态规划，设 $ f(i, j) $ 表示飞到横坐标为 $ i $，纵座标为 $ j $ 处的最少屏幕点击次数。\n\n考虑每一个状态是如何到达的 —— 可能是在横坐标 $ i - 1 $ 处点击 $ k $ 次屏幕，上升 $ k \\times X $ 个单位高度后到达；也可能是不点击屏幕，下降 $ Y $ 个单位高度后到达。如果我们枚举 $ k $，则状态转移方程为\n\n$$\nf(i, j) = \\min(\\min\\limits_k \\{ f(i - 1, j - kX) \\} + k, f(i - 1, j + Y))\n$$\n\n显然，每次状态转移的时间为 $ O(m) $，总时间复杂度为 $ O(nm ^ 2) $，会超时。\n\n考虑「点击 $ k $ 次」和「点击 $ k - 1 $ 次」之间的联系，如果最优方案中，点击了 $ k $ 次到达纵坐标 $ j $，则如果点击 $ k - 1 $ 次，会到达纵坐标 $ j - X $，此时的状态转移方程（只考虑点击）为\n\n$$ f(i, j) = \\min(f(i - 1, j - X) + 1, f(i, j - X) + 1) $$\n\n即，「只点击一次」和「从点击若干次到达的将要位置上再点击一次」。这是一种类似完全背包中「多装一个」的思想。\n\n需要注意的是，使用优化后的状态转移方程计算时，不能简单地将障碍位置的答案直接置为正无穷 —— 考虑有一种情况，点击 $ k - 1 $ 次后会到达下方的管道的位置，而点击 $ k $ 次不会，而点击 $ k $ 次的答案需要由 $ k - 1 $ 次得到。解决方法是计算完一列的状态之后，将障碍区域的答案全部置为正无穷。\n\n统计答案时，如果到达最右边一列某些位置的步数不为正无穷，则取这些中的最小值作为最小步数，否则扫描每一列，记录管道数量，直到「不可达」的一列为止。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n\tbool exist;\n\tint top, bottom;\n} a[MAXN + 1];\n\nint n, m, k, up[MAXN + 1], down[MAXN + 1];\n\ntemplate <typename T> bool cmin(T &a, const T &b) {\n\treturn (a > b) ? (a = b, true) : false;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &up[i], &down[i]);\n\t}\n\n\twhile (k--) {\n\t\tint i;\n\t\tscanf(\"%d\", &i);\n\t\tscanf(\"%d %d\", &a[i].bottom, &a[i].top);\n\t\ta[i].exist = true;\n\t}\n\n\tstatic int f[MAXN + 1][MAXM + 1];\n\t// for (int i = 1; i <= m; i++) f[0][i] = 0;\n\tf[0][0] = INT_MAX;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = INT_MAX;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tf[i][j] = INT_MAX;\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\n\t\t\tif (j >= up[i - 1]) {\n\t\t\t\tif (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1);\n\t\t\t\tif (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (j <= m - down[i - 1]) {\n\t\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t\t}\n\t\t\t*/\n\n#ifdef DBG\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n#endif\n\t\t}\n\n\t\tfor (int j = 1; j <= m - down[i - 1]; j++) {\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t}\n\n\t\tf[i][m] = INT_MAX;\n\t\t// if (a[i].exist) continue;\n\t\tfor (int k = m - up[i - 1]; k <= m; k++) {\n\t\t\tif (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n\t\t\tif (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n\t\t}\n\n\t\tif (a[i].exist) for (int j = 1; j <= m; j++) if (j <= a[i].bottom || j >= a[i].top) f[i][j] = INT_MAX;\n\t}\n\n\tint clicks = INT_MAX;\n\tfor (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n\n\tif (clicks != INT_MAX) {\n\t\tprintf(\"1\\n%d\\n\", clicks);\n\t} else {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (f[i][j] != INT_MAX) {\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos != -1) break;\n\t\t}\n\n\t\tint pipeCnt = 0;\n\t\tfor (int i = 1; i <= pos; i++) if (a[i].exist) pipeCnt++;\n\n\t\tprintf(\"0\\n%d\\n\", pipeCnt);\n\t}\n\n\treturn 0;\n}\n```\t\n","source":"_posts/noip2014-bird.md","raw":"title: 「NOIP2014」飞扬的小鸟 - 背包 DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - COGS\n  - DP\n  - 背包 DP\npermalink: noip2014-bird\ndate: 2016-10-08 17:06:00\n---\n\n* 游戏界面是一个长为 $ n $，高为 $ m $ 的二维平面，其中有 $ k $ 个管道（忽略管道的宽度）。\n* 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。\n* 小鸟每个单位时间沿横坐标方向右移的距离为 $ 1 $，竖直移动的距离由玩家控制。如果点击屏幕，小鸟就会上升一定高度 $ X $，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 $ Y $。小鸟位于横坐标方向不同位置时，上升的高度 $ X $ 和下降的高度 $ Y $ 可能互不相同。\n* 小鸟高度等于 $ 0 $ 或者小鸟碰到管道时，游戏失败。小鸟高度为 $ m $ 时，无法再上升。\n\n现在,请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。\n\n<!-- more -->\n\n### 链接\n[COGS 1805](http://cogs.pro/cogs/problem/problem.php?pid=1805)  \n[CodeVS 3729](http://codevs.cn/problem/3729/)\n\n### 题解\n动态规划，设 $ f(i, j) $ 表示飞到横坐标为 $ i $，纵座标为 $ j $ 处的最少屏幕点击次数。\n\n考虑每一个状态是如何到达的 —— 可能是在横坐标 $ i - 1 $ 处点击 $ k $ 次屏幕，上升 $ k \\times X $ 个单位高度后到达；也可能是不点击屏幕，下降 $ Y $ 个单位高度后到达。如果我们枚举 $ k $，则状态转移方程为\n\n$$\nf(i, j) = \\min(\\min\\limits_k \\{ f(i - 1, j - kX) \\} + k, f(i - 1, j + Y))\n$$\n\n显然，每次状态转移的时间为 $ O(m) $，总时间复杂度为 $ O(nm ^ 2) $，会超时。\n\n考虑「点击 $ k $ 次」和「点击 $ k - 1 $ 次」之间的联系，如果最优方案中，点击了 $ k $ 次到达纵坐标 $ j $，则如果点击 $ k - 1 $ 次，会到达纵坐标 $ j - X $，此时的状态转移方程（只考虑点击）为\n\n$$ f(i, j) = \\min(f(i - 1, j - X) + 1, f(i, j - X) + 1) $$\n\n即，「只点击一次」和「从点击若干次到达的将要位置上再点击一次」。这是一种类似完全背包中「多装一个」的思想。\n\n需要注意的是，使用优化后的状态转移方程计算时，不能简单地将障碍位置的答案直接置为正无穷 —— 考虑有一种情况，点击 $ k - 1 $ 次后会到达下方的管道的位置，而点击 $ k $ 次不会，而点击 $ k $ 次的答案需要由 $ k - 1 $ 次得到。解决方法是计算完一列的状态之后，将障碍区域的答案全部置为正无穷。\n\n统计答案时，如果到达最右边一列某些位置的步数不为正无穷，则取这些中的最小值作为最小步数，否则扫描每一列，记录管道数量，直到「不可达」的一列为止。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n\tbool exist;\n\tint top, bottom;\n} a[MAXN + 1];\n\nint n, m, k, up[MAXN + 1], down[MAXN + 1];\n\ntemplate <typename T> bool cmin(T &a, const T &b) {\n\treturn (a > b) ? (a = b, true) : false;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &up[i], &down[i]);\n\t}\n\n\twhile (k--) {\n\t\tint i;\n\t\tscanf(\"%d\", &i);\n\t\tscanf(\"%d %d\", &a[i].bottom, &a[i].top);\n\t\ta[i].exist = true;\n\t}\n\n\tstatic int f[MAXN + 1][MAXM + 1];\n\t// for (int i = 1; i <= m; i++) f[0][i] = 0;\n\tf[0][0] = INT_MAX;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = INT_MAX;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tf[i][j] = INT_MAX;\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\n\t\t\tif (j >= up[i - 1]) {\n\t\t\t\tif (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1);\n\t\t\t\tif (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (j <= m - down[i - 1]) {\n\t\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t\t}\n\t\t\t*/\n\n#ifdef DBG\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n#endif\n\t\t}\n\n\t\tfor (int j = 1; j <= m - down[i - 1]; j++) {\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t}\n\n\t\tf[i][m] = INT_MAX;\n\t\t// if (a[i].exist) continue;\n\t\tfor (int k = m - up[i - 1]; k <= m; k++) {\n\t\t\tif (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n\t\t\tif (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n\t\t}\n\n\t\tif (a[i].exist) for (int j = 1; j <= m; j++) if (j <= a[i].bottom || j >= a[i].top) f[i][j] = INT_MAX;\n\t}\n\n\tint clicks = INT_MAX;\n\tfor (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n\n\tif (clicks != INT_MAX) {\n\t\tprintf(\"1\\n%d\\n\", clicks);\n\t} else {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (f[i][j] != INT_MAX) {\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos != -1) break;\n\t\t}\n\n\t\tint pipeCnt = 0;\n\t\tfor (int i = 1; i <= pos; i++) if (a[i].exist) pipeCnt++;\n\n\t\tprintf(\"0\\n%d\\n\", pipeCnt);\n\t}\n\n\treturn 0;\n}\n```\t\n","slug":"noip2014-bird","published":1,"updated":"2016-11-08T12:07:12.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rlu00mlooxlgdr1hbkg"},{"title":"「NOIP2013」华容道 - BFS + SPFA","date":"2016-11-13T09:00:00.000Z","_content":"\n1. 在一个 $ n \\times m $ 棋盘上有 $ n\\times m $ 个格子，其中有且只有一个格子是空白的，其余 $ n \\times m - 1 $ 个格子上每个格子上有一个棋子，每个棋子的大小都是 $ 1 \\times 1 $ 的；\n2. 有些棋子是固定的，有些棋子则是可以移动的；\n3. 任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。\n\n给定一个棋盘，游戏可以玩 $ q $ 次，当然，每次棋盘上固定的格子是不会变的，但是棋盘上空白的格子的初始位置、指定的可移动的棋子的初始位置和目标位置却可能不同。第 $ i $ 次玩的时候，空白的格子在第 $ EX_i $ 行第 $ EY_i $ 列，指定的可移动棋子的初始位置为第 $ SX_i $ 行第 $ SY_i $ 列，目标位置为第 $ TX_i $ 行第 $ TY_i $ 列。\n\n假设小 B 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉小 B 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### 题解\n一次游戏可以分为两个过程 —— 将空白格子移动到目标棋子的周围，将空白格子和目标棋子一起移动。显然，第二个过程中，每一步都是先将空白格子和目标格子交换，再将空白格子移动到目标格子的另一个相邻位置，下一步继续交换。\n\n预处理出 $ f(i, j, a, b) $ 表示当目标棋子在 $ (i, j) $，空白格子在它的 $ a $ 相邻方向上，（保持目标棋子不动）将空白格子移动到 $ b $ 相邻方向上，所需的最小代价。\n\n对于一次游戏，首先枚举将空白格子移动到目标棋子的哪个方向上，之后循环进行以下两个操作：\n\n1. 交换空白格子和目标棋子；\n2. 将空白格子移动到目标棋子的另一个相邻方向上。\n\n我们可以用 $ (i, j, k) $ 描述一个状态 —— 目标棋子在 $ (i, j) $ 上，空白格子在它的 $ k $ 相邻方向上。结合预处理出的 $ f(i, j, a, b) $，在状态图上求最短路即可。\n\n注意起点与终点相同的特判。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXQ = 500;\nconst int di[] = { 1, 0, 0, -1 };\nconst int dj[] = { 0, 1, -1, 0 };\n\nint n, m;\n\nstruct Node {\n\tbool invalid;\n\tint cost[4][4];\n\tint dist;    // BFS prepare\n\tstruct {\n\t\tint dist;\n\t\tbool inq;\n\t} v[4];      // SPFA\n} map[MAXN + 1][MAXN + 1];\n\nstruct Point {\n\tint i, j;\n\n\tPoint() {}\n\tPoint(int i, int j) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n\n\tbool valid() const {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tbool operator==(const Point &other) const {\n\t\treturn i == other.i && j == other.j;\n\t}\n};\n\nstruct Status {\n\tPoint p;\n\tint d;\n\n\tStatus(Point p, int d) : p(p), d(d) {}\n};\n\ninline int bfs(Point s, Point t, Point p) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmap[i][j].dist = INT_MAX;\n\t\t}\n\t}\n\n\tstd::queue<Point> q;\n\ts->dist = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return v->dist;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\n\t\t\tif (u->invalid || u == p) continue;\n\n\t\t\tif (u->dist > v->dist + 1) {\n\t\t\t\tu->dist = v->dist + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (map[i][j].invalid) continue;\n\n\t\t\tPoint v(i, j);\n\t\t\tfor (int s = 0; s < 4; s++) {\n\t\t\t\tPoint ps = v.move(s);\n\n\t\t\t\tfor (int t = s + 1; t < 4; t++) {\n\t\t\t\t\tPoint pt = v.move(t);\n\n\t\t\t\t\tif (!ps.valid() || ps->invalid || !pt.valid() || pt->invalid) v->cost[s][t] = v->cost[t][s] = INT_MAX;\n\t\t\t\t\telse v->cost[s][t] = v->cost[t][s] = bfs(ps, pt, v);\n\n#ifdef DBG\n\t\t\t\t\tprintf(\"[%d, %d] %d => %d = %d\\n\", v.i, v.j, s, t, v->cost[s][t]);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int spfa(Status s, Point t) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmap[i][j].v[k].dist = INT_MAX;\n\t\t\t\tmap[i][j].v[k].inq = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::queue<Status> q;\n\tq.push(s);\n\ts.p->v[s.d].dist = 0;\n\n\twhile (!q.empty()) {\n\t\tStatus status = q.front();\n\t\tq.pop();\n\n\t\tPoint &v = status.p;\n\t\tint &d = status.d;\n\n\t\tv->v[d].inq = false;\n\n\t\t// Move the empty block\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i == d || v->cost[d][i] == INT_MAX) continue;\n\n\t\t\tif (v->v[i].dist > v->v[d].dist + v->cost[d][i]) {\n\t\t\t\tv->v[i].dist = v->v[d].dist + v->cost[d][i];\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d]->v[%d]->dist = %d\\n\", v.i, v.j, i, v->v[i].dist);\n#endif\n\t\t\t\tif (!v->v[i].inq) {\n\t\t\t\t\tv->v[i].inq = true;\n\t\t\t\t\tq.push(Status(v, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap\n\t\tif (v->v[d].dist != INT_MAX) {\n\t\t\tPoint u = v.move(d);\n\t\t\tint t = 3 - d;\n\t\t\tif (u->v[t].dist > v->v[d].dist + 1) {\n\t\t\t\tu->v[t].dist = v->v[d].dist + 1;\n\t\t\t\tif (!u->v[t].inq) {\n\t\t\t\t\tu->v[t].inq = true;\n\t\t\t\t\tq.push(Status(u, t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INT_MAX;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = std::min(res, t->v[i].dist);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmap[i][j].invalid = (x == 0);\n\t\t}\n\t}\n\n\tprepare();\n\n\twhile (q--) {\n\t\tPoint empty, s, t;\n\t\tscanf(\"%d %d %d %d %d %d\", &empty.i, &empty.j, &s.i, &s.j, &t.i, &t.j);\n\n\t\tif (s == t) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v = s.move(i);\n\t\t\tif (!v.valid()) continue;\n\n\t\t\tint d1 = bfs(empty, v, s);\n\t\t\tif (d1 == INT_MAX) continue;\n\n\t\t\tint d2 = spfa(Status(s, i), t);\n\t\t\tif (d2 == INT_MAX) continue;\n\n\t\t\tans = std::min(ans, d1 + d2);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2013-puzzle.md","raw":"title: 「NOIP2013」华容道 - BFS + SPFA\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - 搜索\n  - 最短路\n  - SPFA\n  - BFS\npermalink: noip2013-puzzle\ndate: 2016-11-13 17:00:00\n---\n\n1. 在一个 $ n \\times m $ 棋盘上有 $ n\\times m $ 个格子，其中有且只有一个格子是空白的，其余 $ n \\times m - 1 $ 个格子上每个格子上有一个棋子，每个棋子的大小都是 $ 1 \\times 1 $ 的；\n2. 有些棋子是固定的，有些棋子则是可以移动的；\n3. 任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。\n\n给定一个棋盘，游戏可以玩 $ q $ 次，当然，每次棋盘上固定的格子是不会变的，但是棋盘上空白的格子的初始位置、指定的可移动的棋子的初始位置和目标位置却可能不同。第 $ i $ 次玩的时候，空白的格子在第 $ EX_i $ 行第 $ EY_i $ 列，指定的可移动棋子的初始位置为第 $ SX_i $ 行第 $ SY_i $ 列，目标位置为第 $ TX_i $ 行第 $ TY_i $ 列。\n\n假设小 B 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉小 B 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### 题解\n一次游戏可以分为两个过程 —— 将空白格子移动到目标棋子的周围，将空白格子和目标棋子一起移动。显然，第二个过程中，每一步都是先将空白格子和目标格子交换，再将空白格子移动到目标格子的另一个相邻位置，下一步继续交换。\n\n预处理出 $ f(i, j, a, b) $ 表示当目标棋子在 $ (i, j) $，空白格子在它的 $ a $ 相邻方向上，（保持目标棋子不动）将空白格子移动到 $ b $ 相邻方向上，所需的最小代价。\n\n对于一次游戏，首先枚举将空白格子移动到目标棋子的哪个方向上，之后循环进行以下两个操作：\n\n1. 交换空白格子和目标棋子；\n2. 将空白格子移动到目标棋子的另一个相邻方向上。\n\n我们可以用 $ (i, j, k) $ 描述一个状态 —— 目标棋子在 $ (i, j) $ 上，空白格子在它的 $ k $ 相邻方向上。结合预处理出的 $ f(i, j, a, b) $，在状态图上求最短路即可。\n\n注意起点与终点相同的特判。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXQ = 500;\nconst int di[] = { 1, 0, 0, -1 };\nconst int dj[] = { 0, 1, -1, 0 };\n\nint n, m;\n\nstruct Node {\n\tbool invalid;\n\tint cost[4][4];\n\tint dist;    // BFS prepare\n\tstruct {\n\t\tint dist;\n\t\tbool inq;\n\t} v[4];      // SPFA\n} map[MAXN + 1][MAXN + 1];\n\nstruct Point {\n\tint i, j;\n\n\tPoint() {}\n\tPoint(int i, int j) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n\n\tbool valid() const {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tbool operator==(const Point &other) const {\n\t\treturn i == other.i && j == other.j;\n\t}\n};\n\nstruct Status {\n\tPoint p;\n\tint d;\n\n\tStatus(Point p, int d) : p(p), d(d) {}\n};\n\ninline int bfs(Point s, Point t, Point p) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmap[i][j].dist = INT_MAX;\n\t\t}\n\t}\n\n\tstd::queue<Point> q;\n\ts->dist = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return v->dist;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\n\t\t\tif (u->invalid || u == p) continue;\n\n\t\t\tif (u->dist > v->dist + 1) {\n\t\t\t\tu->dist = v->dist + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (map[i][j].invalid) continue;\n\n\t\t\tPoint v(i, j);\n\t\t\tfor (int s = 0; s < 4; s++) {\n\t\t\t\tPoint ps = v.move(s);\n\n\t\t\t\tfor (int t = s + 1; t < 4; t++) {\n\t\t\t\t\tPoint pt = v.move(t);\n\n\t\t\t\t\tif (!ps.valid() || ps->invalid || !pt.valid() || pt->invalid) v->cost[s][t] = v->cost[t][s] = INT_MAX;\n\t\t\t\t\telse v->cost[s][t] = v->cost[t][s] = bfs(ps, pt, v);\n\n#ifdef DBG\n\t\t\t\t\tprintf(\"[%d, %d] %d => %d = %d\\n\", v.i, v.j, s, t, v->cost[s][t]);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int spfa(Status s, Point t) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmap[i][j].v[k].dist = INT_MAX;\n\t\t\t\tmap[i][j].v[k].inq = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::queue<Status> q;\n\tq.push(s);\n\ts.p->v[s.d].dist = 0;\n\n\twhile (!q.empty()) {\n\t\tStatus status = q.front();\n\t\tq.pop();\n\n\t\tPoint &v = status.p;\n\t\tint &d = status.d;\n\n\t\tv->v[d].inq = false;\n\n\t\t// Move the empty block\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i == d || v->cost[d][i] == INT_MAX) continue;\n\n\t\t\tif (v->v[i].dist > v->v[d].dist + v->cost[d][i]) {\n\t\t\t\tv->v[i].dist = v->v[d].dist + v->cost[d][i];\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d]->v[%d]->dist = %d\\n\", v.i, v.j, i, v->v[i].dist);\n#endif\n\t\t\t\tif (!v->v[i].inq) {\n\t\t\t\t\tv->v[i].inq = true;\n\t\t\t\t\tq.push(Status(v, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap\n\t\tif (v->v[d].dist != INT_MAX) {\n\t\t\tPoint u = v.move(d);\n\t\t\tint t = 3 - d;\n\t\t\tif (u->v[t].dist > v->v[d].dist + 1) {\n\t\t\t\tu->v[t].dist = v->v[d].dist + 1;\n\t\t\t\tif (!u->v[t].inq) {\n\t\t\t\t\tu->v[t].inq = true;\n\t\t\t\t\tq.push(Status(u, t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INT_MAX;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = std::min(res, t->v[i].dist);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmap[i][j].invalid = (x == 0);\n\t\t}\n\t}\n\n\tprepare();\n\n\twhile (q--) {\n\t\tPoint empty, s, t;\n\t\tscanf(\"%d %d %d %d %d %d\", &empty.i, &empty.j, &s.i, &s.j, &t.i, &t.j);\n\n\t\tif (s == t) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v = s.move(i);\n\t\t\tif (!v.valid()) continue;\n\n\t\t\tint d1 = bfs(empty, v, s);\n\t\t\tif (d1 == INT_MAX) continue;\n\n\t\t\tint d2 = spfa(Status(s, i), t);\n\t\t\tif (d2 == INT_MAX) continue;\n\n\t\t\tans = std::min(ans, d1 + d2);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noip2013-puzzle","published":1,"updated":"2016-11-13T10:35:58.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rly00msooxlf3pyicvr"},{"title":"「NOIP2013」火柴排队 - 逆序对","date":"2016-10-13T08:15:00.000Z","_content":"\n涵涵有两盒火柴，每盒装有 $ n $ 根火柴，每根火柴都有一个高度。现在将每盒中的火柴各自排成一列，同一列火柴的高度互不相同，两列火柴之间的距离定义为\n\n$$ \\sum\\limits_{i = 1} ^ n (a_i - b_i) ^ 2 $$\n\n其中 $ a_i $ 表示第一列火柴中第 $ i $ 个火柴的高度，$ b_i $ 表示第二列火柴中第 $ i $ 个火柴的高度。\n\n每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？\n\n<!-- more -->\n\n### 链接\n[CodeVS 3286](http://codevs.cn/problem/3286/)\n\n### 题解\n显然，最优方案为，对于每一个 $ k \\in [1, n] $，第一列中的第 $ k $ 大和第二列中的第 $ k $ 大在相同位置上。\n\n构造一个数组 $ a $，对于第二列火柴中的第 $ i $ 个，设它为第二列中的第 $ k $ 大，设第一列火柴中的第 $ k $ 大为第 $ j $ 个，则 $ a[i] = j $。求出 $ a $ 的逆序对数即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Match {\n\tint index, rank, value, w;\n} a[MAXN + 1], b[MAXN + 1];\n\nint n;\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n} bit;\n\ninline bool byVal(const Match &a, const Match &b) {\n\treturn a.value < b.value;\n}\n\ninline bool byID(const Match &a, const Match &b) {\n\treturn a.index < b.index;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].value), a[i].index = i;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &b[i].value), b[i].index = i;\n\n\tstd::sort(a + 1, a + n + 1, &byVal);\n\tstd::sort(b + 1, b + n + 1, &byVal);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].rank = b[i].rank = i;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i].w = a[i].index;\n\t}\n\n\tstd::sort(b + 1, b + n + 1, &byID);\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d\\n\", b[i].w);\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += bit.query(b[i].w + 1, n);\n\t\tbit.update(b[i].w, 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans % MOD);\n\n\treturn 0;\n}\n```","source":"_posts/noip2013-match.md","raw":"title: 「NOIP2013」火柴排队 - 逆序对\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - 逆序对\n  - 树状数组\npermalink: noip2013-match\ndate: 2016-10-13 16:15:00\n---\n\n涵涵有两盒火柴，每盒装有 $ n $ 根火柴，每根火柴都有一个高度。现在将每盒中的火柴各自排成一列，同一列火柴的高度互不相同，两列火柴之间的距离定义为\n\n$$ \\sum\\limits_{i = 1} ^ n (a_i - b_i) ^ 2 $$\n\n其中 $ a_i $ 表示第一列火柴中第 $ i $ 个火柴的高度，$ b_i $ 表示第二列火柴中第 $ i $ 个火柴的高度。\n\n每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？\n\n<!-- more -->\n\n### 链接\n[CodeVS 3286](http://codevs.cn/problem/3286/)\n\n### 题解\n显然，最优方案为，对于每一个 $ k \\in [1, n] $，第一列中的第 $ k $ 大和第二列中的第 $ k $ 大在相同位置上。\n\n构造一个数组 $ a $，对于第二列火柴中的第 $ i $ 个，设它为第二列中的第 $ k $ 大，设第一列火柴中的第 $ k $ 大为第 $ j $ 个，则 $ a[i] = j $。求出 $ a $ 的逆序对数即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Match {\n\tint index, rank, value, w;\n} a[MAXN + 1], b[MAXN + 1];\n\nint n;\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n} bit;\n\ninline bool byVal(const Match &a, const Match &b) {\n\treturn a.value < b.value;\n}\n\ninline bool byID(const Match &a, const Match &b) {\n\treturn a.index < b.index;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].value), a[i].index = i;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &b[i].value), b[i].index = i;\n\n\tstd::sort(a + 1, a + n + 1, &byVal);\n\tstd::sort(b + 1, b + n + 1, &byVal);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].rank = b[i].rank = i;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i].w = a[i].index;\n\t}\n\n\tstd::sort(b + 1, b + n + 1, &byID);\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d\\n\", b[i].w);\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += bit.query(b[i].w + 1, n);\n\t\tbit.update(b[i].w, 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans % MOD);\n\n\treturn 0;\n}\n```","slug":"noip2013-match","published":1,"updated":"2016-11-13T08:15:38.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rm500n1ooxlmjs77nnl"},{"title":"「NOIP2013」花匠 - 贪心","date":"2016-10-13T08:42:00.000Z","_content":"\n花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。\n\n具体而言，栋栋的花的高度可以看成一列整数 $ h_1, h_2, \\ldots, h_n $。设当一部分花被移走后，剩下的花的高度依次为 $ g_1, g_2, \\ldots, g_m $，则栋栋希望下面两个条件中至少有一个满足：\n\n条件 A：对于所有的 $ 1 < i < \\frac{m}{2} $，$ g_{2i} > g_{2i - 1} $ 且 $ g_{2i} > g_{2i + 1} $；  \n条件 B：对于所有的 $ 1 < i < \\frac{m}{2} $，$ g_{2i} < g_{2i - 1} $ 且 $ g_{2i} < g_{2i + 1} $。\n\n注意上面两个条件在 $ m = 1 $ 时同时满足，当 $ m > 1 $ 时最多有一个能满足。  \n请问，栋栋最多能将多少株花留在原地。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3289](http://codevs.cn/problem/3289/)\n\n### 题解\n最长波动子序列，贪心。\n\n记录在当前情况下最长波动子序列的最后两个数，设它们为 $ x $ 和 $ y $，考虑原序列最后加入一个 $ z $ 的影响。\n\n如果 $ x < y $ 且 $ y > z $（$ x > y $ 且 $ y < z $），则 $ z $ 可以接在当前最长波动子序列的后面，答案 $ + 1 $。\n\n如果 $ x < y $ 且 $ y < z $（$ x > y $ 且 $ y > z $），则可以用 $ z $ 替换 $ y $，这样一定不会使总的答案变差，并且可以使 $ z $ 之后一个（可能的）满足 $ k < y < z $ 的 $ k $ 接在 $ z $ 之后。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint prev, curr, ans = 1;\n\tscanf(\"%d\", &curr);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (x == curr) continue;\n\n\t\tif (ans == 1 || (prev < curr) != (curr < x)) {\n\t\t\tans++;\n\t\t\tprev = curr;\n\t\t\tcurr = x;\n\t\t} else {\n\t\t\tif (prev < curr) curr = std::max(curr, x);\n\t\t\telse curr = std::min(curr, x);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/noip2013-flower.md","raw":"title: 「NOIP2013」花匠 - 贪心\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - 贪心\npermalink: noip2013-flower\ndate: 2016-10-13 16:42:00\n---\n\n花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。\n\n具体而言，栋栋的花的高度可以看成一列整数 $ h_1, h_2, \\ldots, h_n $。设当一部分花被移走后，剩下的花的高度依次为 $ g_1, g_2, \\ldots, g_m $，则栋栋希望下面两个条件中至少有一个满足：\n\n条件 A：对于所有的 $ 1 < i < \\frac{m}{2} $，$ g_{2i} > g_{2i - 1} $ 且 $ g_{2i} > g_{2i + 1} $；  \n条件 B：对于所有的 $ 1 < i < \\frac{m}{2} $，$ g_{2i} < g_{2i - 1} $ 且 $ g_{2i} < g_{2i + 1} $。\n\n注意上面两个条件在 $ m = 1 $ 时同时满足，当 $ m > 1 $ 时最多有一个能满足。  \n请问，栋栋最多能将多少株花留在原地。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3289](http://codevs.cn/problem/3289/)\n\n### 题解\n最长波动子序列，贪心。\n\n记录在当前情况下最长波动子序列的最后两个数，设它们为 $ x $ 和 $ y $，考虑原序列最后加入一个 $ z $ 的影响。\n\n如果 $ x < y $ 且 $ y > z $（$ x > y $ 且 $ y < z $），则 $ z $ 可以接在当前最长波动子序列的后面，答案 $ + 1 $。\n\n如果 $ x < y $ 且 $ y < z $（$ x > y $ 且 $ y > z $），则可以用 $ z $ 替换 $ y $，这样一定不会使总的答案变差，并且可以使 $ z $ 之后一个（可能的）满足 $ k < y < z $ 的 $ k $ 接在 $ z $ 之后。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint prev, curr, ans = 1;\n\tscanf(\"%d\", &curr);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (x == curr) continue;\n\n\t\tif (ans == 1 || (prev < curr) != (curr < x)) {\n\t\t\tans++;\n\t\t\tprev = curr;\n\t\t\tcurr = x;\n\t\t} else {\n\t\t\tif (prev < curr) curr = std::max(curr, x);\n\t\t\telse curr = std::min(curr, x);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"noip2013-flower","published":1,"updated":"2016-11-13T08:42:45.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rm900n8ooxltf4y1ddn"},{"title":"「NOIP2012」同余方程 - 扩展欧几里得","date":"2016-01-19T13:20:19.000Z","_content":"\n求关于 `x` 同余方程 $ax ≡ 1 ({\\rm mod} \\ b)$的最小正整数解。 \n\n<!-- more -->\n\n### 链接\n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### 题解\n扩展欧几里得裸题，注意求最小正整数解，求出来 `x` 要模一次 `b`，然后加上 `b` 再模一次。\n\n### 代码\n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-mod.md","raw":"title: 「NOIP2012」同余方程 - 扩展欧几里得\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Tyvj\n  - 数论\n  - EXGCD\n  - 乘法逆元\npermalink: noip2012-mod\ndate: 2016-01-19 21:20:19\n---\n\n求关于 `x` 同余方程 $ax ≡ 1 ({\\rm mod} \\ b)$的最小正整数解。 \n\n<!-- more -->\n\n### 链接\n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### 题解\n扩展欧几里得裸题，注意求最小正整数解，求出来 `x` 要模一次 `b`，然后加上 `b` 再模一次。\n\n### 代码\n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","slug":"noip2012-mod","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rmc00ndooxlkjffopq1"},{"title":"「NOIP2012」开车旅行 - 倍增","date":"2016-11-13T09:14:00.000Z","_content":"\n小 A 和小 B 决定利用假期外出旅行，他们将想去的城市从 $ 1 $ 到 $ N $ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $ i $ 的海拔高度为 $ H_i $，城市 $ i $ 和城市 $ j $ 之间的距离 $ d(i, j) $ 恰好是这两个城市海拔高度之差的绝对值，即 $ d(i, j) = |H_i − H_j| $。\n\n旅行过程中，小 A 和小 B 轮流开车，第一天小 A 开车，之后每天轮换一次。他们计划选择一个城市 $ S $ 作为起点，一直向东行驶，并且最多行驶 $ X $ 公里就结束旅行。小 A 和小 B 的驾驶风格不同，小 B 总是沿着前进方向选择一个最近的城市作为目的地，而小 A 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $ X $ 公里，他们就会结束旅行。\n\n在启程之前，小 A 想知道两个问题：\n\n1. 对于一个给定的 $ X = X_0 $，从哪一个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值最小（如果小 B 的行驶路程为 $ 0 $，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。\n2. 对任意给定的 $ X = X_i $ 和出发城市 $ S_i $，小 A 开车行驶的路程总数以及小 B 行驶的路程总数。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1199](http://codevs.cn/problem/1199/)\n\n### 题解\n使用排序 + 链表求出在以个点为起点时，小 A 和小 B 开车到达的地点。\n\n设 $ f(k, i, j) $ 表示以小 A（$ k = 0 $）或小 B（$ k = 1 $）开始，以 $ i $ 为起点，$ 2 ^ j $ 天后到达的地点；$ g(k, i, j, l) $ 表示以小 A（$ k = 0 $）或小 B（$ k = 1 $）开始，以 $ i $ 为起点，$ 2 ^ j $ 天内，小 A（$ l = 0 $）或小 B（$ l = 1 $）或二者之和 $ l = 2 $ 的路程。\n\n对于第一问，枚举起点即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\nconst int MAXM = 10000;\n\nstruct Node {\n\tlong long x;\n\tNode *nextA, *nextB;\n\tstd::list<Node *>::iterator it;\n} N[MAXN + 1];\n\nint n, logn, f[2][MAXN + 1][MAXN_LOG + 1];\nlong long g[2][MAXN + 1][MAXN_LOG + 1][3];\n\ninline bool compareNode(Node *a, Node *b) {\n\treturn a->x < b->x;\n}\n\ninline bool comparePair(const std::pair<long long, Node *> &a, const std::pair<long long, Node *> &b) {\n\tif (a.first == b.first) return a.second->x < b.second->x;\n\telse return a.first < b.first;\n}\n\ninline void prepare() {\n\tstd::list<Node *> list;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlist.push_back(&N[i]);\n\t\tN[i].it = --list.end();\n\t}\n\n\tlist.sort(&compareNode);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tstd::vector< std::pair<long long, Node *> > vec;\n\n\t\tstd::list<Node *>::iterator near;\n\t\tnear = N[i].it, near++;\n\n\t\tif (near != list.end()) {\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (++near != list.end()) {\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tnear = N[i].it;\n\t\tif (near != list.begin()) {\n\t\t\tnear--;\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (near != list.begin()) {\n\t\t\t\tnear--;\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(vec.begin(), vec.end(), comparePair);\n\n\t\tif (vec.size() >= 2) {\n\t\t\tN[i].nextA = vec[1].second;\n#ifdef DBG\n\t\t\tprintf(\"nextA(%lld) = %lld\\n\", N[i].x, N[i].nextA->x);\n#endif\n\t\t} else N[i].nextA = &N[0];\n\n\t\tif (vec.size() >= 1) {\n\t\t\tN[i].nextB = vec[0].second;\n#ifdef DBG\n\t\t\tprintf(\"nextB(%lld) = %lld\\n\", N[i].x, N[i].nextB->x);\n#endif\n\t\t} else N[i].nextB = &N[0];\n\n\t\tlist.erase(N[i].it);\n\t}\n\tN[0].nextA = N[0].nextB = &N[0];\n\n\t// Build graph\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[0][i][0] = N[i].nextA - N;\n\t\tf[0][i][1] = N[i].nextA->nextB - N;\n\t\t\n\t\tf[1][i][0] = N[i].nextB - N;\n\t\tf[1][i][1] = N[i].nextB->nextA - N;\n\n\t\tg[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &N[0] ? 0 : llabs(N[i].x - N[i].nextA->x);\n\t\tg[0][i][0][1] = 0;\n\n\t\tg[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &N[0] ? 0 : llabs(N[i].x - N[i].nextB->x);\n\t\tg[1][i][0][0] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[0][i][1][0] = g[0][i][0][0];\n\t\tg[0][i][1][1] = g[1][N[i].nextA - N][0][1];\n\t\tg[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1];\n\n\t\tg[1][i][1][1] = g[1][i][0][1];\n\t\tg[1][i][1][0] = g[0][N[i].nextB - N][0][0];\n\t\tg[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0];\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 2; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tg[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l];\n\t\t\t\t}\n\t\t\t\tf[k][i][j] = f[k][f[k][i][j - 1]][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int j = 0; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tprintf(\"f(%d, %d, %d) = %d [%lld]\\n\\n\", k, i, j, f[k][i][j], N[f[k][i][j]].x);\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tprintf(\"g(%d, %d, %d, %d) = %lld\\n\", k, i, j, l, g[k][i][j][l]);\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\ninline long long solve(int start, long long limit, long long &sumA, long long &sumB) {\n\tint curr = start;\n\tlong long sum = sumA = sumB = 0;\n\tfor (int i = logn; i >= 1 && curr != 0; i--) {\n\t\twhile (curr && limit >= sum + g[0][curr][i][2]) {\n\t\t\tsum += g[0][curr][i][2];\n\t\t\tsumA += g[0][curr][i][0];\n\t\t\tsumB += g[0][curr][i][1];\n\t\t\tcurr = f[0][curr][i];\n\t\t}\n\t}\n\n\tif (curr && limit >= sum + g[0][curr][0][0]) {\n\t\tsumA += g[0][curr][0][0];\n\t\tsum += g[0][curr][0][0];\n\t}\n\n\treturn sum;\n}\n\ninline int solve(long long limit) {\n\tint ans = 0;\n\tdouble k = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long tmpA, tmpB;\n\t\tsolve(i, limit, tmpA, tmpB);\n\t\tdouble t = static_cast<double>(tmpA) / static_cast<double>(tmpB);\n\t\tif (k == -1 || t < k || (t == k && N[i].x > N[ans].x)) {\n\t\t\tk = t;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].x);\n\n\tprepare();\n\n\tlong long limit;\n\tscanf(\"%lld\", &limit);\n\tprintf(\"%d\\n\", solve(limit));\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint start;\n\t\tlong long limit;\n\t\tscanf(\"%d %lld\", &start, &limit);\n\t\tlong long sumA, sumB;\n\t\tsolve(start, limit, sumA, sumB);\n\t\tprintf(\"%lld %lld\\n\", sumA, sumB);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-drive.md","raw":"title: 「NOIP2012」开车旅行 - 倍增\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - 倍增\npermalink: noip2012-drive\ndate: 2016-11-13 17:14:00\n---\n\n小 A 和小 B 决定利用假期外出旅行，他们将想去的城市从 $ 1 $ 到 $ N $ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $ i $ 的海拔高度为 $ H_i $，城市 $ i $ 和城市 $ j $ 之间的距离 $ d(i, j) $ 恰好是这两个城市海拔高度之差的绝对值，即 $ d(i, j) = |H_i − H_j| $。\n\n旅行过程中，小 A 和小 B 轮流开车，第一天小 A 开车，之后每天轮换一次。他们计划选择一个城市 $ S $ 作为起点，一直向东行驶，并且最多行驶 $ X $ 公里就结束旅行。小 A 和小 B 的驾驶风格不同，小 B 总是沿着前进方向选择一个最近的城市作为目的地，而小 A 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $ X $ 公里，他们就会结束旅行。\n\n在启程之前，小 A 想知道两个问题：\n\n1. 对于一个给定的 $ X = X_0 $，从哪一个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值最小（如果小 B 的行驶路程为 $ 0 $，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。\n2. 对任意给定的 $ X = X_i $ 和出发城市 $ S_i $，小 A 开车行驶的路程总数以及小 B 行驶的路程总数。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1199](http://codevs.cn/problem/1199/)\n\n### 题解\n使用排序 + 链表求出在以个点为起点时，小 A 和小 B 开车到达的地点。\n\n设 $ f(k, i, j) $ 表示以小 A（$ k = 0 $）或小 B（$ k = 1 $）开始，以 $ i $ 为起点，$ 2 ^ j $ 天后到达的地点；$ g(k, i, j, l) $ 表示以小 A（$ k = 0 $）或小 B（$ k = 1 $）开始，以 $ i $ 为起点，$ 2 ^ j $ 天内，小 A（$ l = 0 $）或小 B（$ l = 1 $）或二者之和 $ l = 2 $ 的路程。\n\n对于第一问，枚举起点即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\nconst int MAXM = 10000;\n\nstruct Node {\n\tlong long x;\n\tNode *nextA, *nextB;\n\tstd::list<Node *>::iterator it;\n} N[MAXN + 1];\n\nint n, logn, f[2][MAXN + 1][MAXN_LOG + 1];\nlong long g[2][MAXN + 1][MAXN_LOG + 1][3];\n\ninline bool compareNode(Node *a, Node *b) {\n\treturn a->x < b->x;\n}\n\ninline bool comparePair(const std::pair<long long, Node *> &a, const std::pair<long long, Node *> &b) {\n\tif (a.first == b.first) return a.second->x < b.second->x;\n\telse return a.first < b.first;\n}\n\ninline void prepare() {\n\tstd::list<Node *> list;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlist.push_back(&N[i]);\n\t\tN[i].it = --list.end();\n\t}\n\n\tlist.sort(&compareNode);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tstd::vector< std::pair<long long, Node *> > vec;\n\n\t\tstd::list<Node *>::iterator near;\n\t\tnear = N[i].it, near++;\n\n\t\tif (near != list.end()) {\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (++near != list.end()) {\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tnear = N[i].it;\n\t\tif (near != list.begin()) {\n\t\t\tnear--;\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (near != list.begin()) {\n\t\t\t\tnear--;\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(vec.begin(), vec.end(), comparePair);\n\n\t\tif (vec.size() >= 2) {\n\t\t\tN[i].nextA = vec[1].second;\n#ifdef DBG\n\t\t\tprintf(\"nextA(%lld) = %lld\\n\", N[i].x, N[i].nextA->x);\n#endif\n\t\t} else N[i].nextA = &N[0];\n\n\t\tif (vec.size() >= 1) {\n\t\t\tN[i].nextB = vec[0].second;\n#ifdef DBG\n\t\t\tprintf(\"nextB(%lld) = %lld\\n\", N[i].x, N[i].nextB->x);\n#endif\n\t\t} else N[i].nextB = &N[0];\n\n\t\tlist.erase(N[i].it);\n\t}\n\tN[0].nextA = N[0].nextB = &N[0];\n\n\t// Build graph\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[0][i][0] = N[i].nextA - N;\n\t\tf[0][i][1] = N[i].nextA->nextB - N;\n\t\t\n\t\tf[1][i][0] = N[i].nextB - N;\n\t\tf[1][i][1] = N[i].nextB->nextA - N;\n\n\t\tg[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &N[0] ? 0 : llabs(N[i].x - N[i].nextA->x);\n\t\tg[0][i][0][1] = 0;\n\n\t\tg[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &N[0] ? 0 : llabs(N[i].x - N[i].nextB->x);\n\t\tg[1][i][0][0] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[0][i][1][0] = g[0][i][0][0];\n\t\tg[0][i][1][1] = g[1][N[i].nextA - N][0][1];\n\t\tg[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1];\n\n\t\tg[1][i][1][1] = g[1][i][0][1];\n\t\tg[1][i][1][0] = g[0][N[i].nextB - N][0][0];\n\t\tg[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0];\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 2; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tg[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l];\n\t\t\t\t}\n\t\t\t\tf[k][i][j] = f[k][f[k][i][j - 1]][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int j = 0; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tprintf(\"f(%d, %d, %d) = %d [%lld]\\n\\n\", k, i, j, f[k][i][j], N[f[k][i][j]].x);\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tprintf(\"g(%d, %d, %d, %d) = %lld\\n\", k, i, j, l, g[k][i][j][l]);\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\ninline long long solve(int start, long long limit, long long &sumA, long long &sumB) {\n\tint curr = start;\n\tlong long sum = sumA = sumB = 0;\n\tfor (int i = logn; i >= 1 && curr != 0; i--) {\n\t\twhile (curr && limit >= sum + g[0][curr][i][2]) {\n\t\t\tsum += g[0][curr][i][2];\n\t\t\tsumA += g[0][curr][i][0];\n\t\t\tsumB += g[0][curr][i][1];\n\t\t\tcurr = f[0][curr][i];\n\t\t}\n\t}\n\n\tif (curr && limit >= sum + g[0][curr][0][0]) {\n\t\tsumA += g[0][curr][0][0];\n\t\tsum += g[0][curr][0][0];\n\t}\n\n\treturn sum;\n}\n\ninline int solve(long long limit) {\n\tint ans = 0;\n\tdouble k = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long tmpA, tmpB;\n\t\tsolve(i, limit, tmpA, tmpB);\n\t\tdouble t = static_cast<double>(tmpA) / static_cast<double>(tmpB);\n\t\tif (k == -1 || t < k || (t == k && N[i].x > N[ans].x)) {\n\t\t\tk = t;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].x);\n\n\tprepare();\n\n\tlong long limit;\n\tscanf(\"%lld\", &limit);\n\tprintf(\"%d\\n\", solve(limit));\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint start;\n\t\tlong long limit;\n\t\tscanf(\"%d %lld\", &start, &limit);\n\t\tlong long sumA, sumB;\n\t\tsolve(start, limit, sumA, sumB);\n\t\tprintf(\"%lld %lld\\n\", sumA, sumB);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noip2012-drive","published":1,"updated":"2016-11-13T09:14:22.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rmh00nlooxl1idgmfrv"},{"title":"「NOIP2012」借教室 - 二分 / 线段树","date":"2016-10-08T08:56:00.000Z","_content":"\n我们需要处理接下来 $ n $ 天的借教室信息，其中第 $ i $ 天学校有 $ r_i $ 个教室可供租借。共有 $ m $ 份订单，每份订单用三个正整数描述，分别为 $ d_j, s_j, t_j $，表示某租借者需要从第 $ s_j $ 天到第 $ t_j $ 天租借教室（包括第 $ s_j $ 天和第 $ t_j $ 天），每天需要租借 $ d_j $ 个教室。 \n\n现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。\n\n<!-- more -->\n\n### 链接\n[COGS 1266](http://cogs.pro/cogs/problem/problem.php?pid=1266)  \n[CodeVS 1217](http://codevs.cn/problem/1217/)\n\n### 题解\n#### 解法一\n对天数建立线段树，维护区间最小值，每次租借时查询区间最小值，如果小于租借数量，则无法满足，否则对一个区间减去租借数量，继续处理下一个订单。\n\n期望得分 100 分，**实际得分 95 分**。\n\n#### 解法二\n二分天数 $ x $，使用差分 + 前缀和检验前 $ x $ 天是否可以完全满足。\n\n期望得分 100 分，实际得分 100 分。\n\n### 代码\n线段树，TLE\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 1000000;\nconst int MAXR = 1000000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar a[SIZE * sizeof(T)];\n\tT *p;\n\n\tMemoryPool() : p((T *)a) {}\n\n\tT *alloc() {\n\t\treturn p++;\n\t}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, min, lazy;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (lchild) lchild->value += lazy, lchild->min += lazy, lchild->lazy += lazy;\n\t\t\t\tif (rchild) rchild->value += lazy, rchild->min += lazy, rchild->lazy += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tint queryMin(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\t\telse if (l <= this->l && r >= this->r) return min;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tif (lchild) ans = std::min(ans, lchild->queryMin(l, r));\n\t\t\t\tif (rchild) ans = std::min(ans, rchild->queryMin(l, r));\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) value += x, min += x, lazy += x;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tif (lchild) lchild->update(l, r, x);\n\t\t\t\tif (rchild) rchild->update(l, r, x);\n\n\t\t\t\tmin = INT_MAX;\n\t\t\t\tif (lchild) min = std::min(min, lchild->min);\n\t\t\t\tif (rchild) min = std::min(min, rchild->min);\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tstatic MemoryPool<Node, MAXN * 2> pool;\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL);\n\t\telse return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tint queryMin(int l, int r) {\n\t\treturn root->queryMin(l, r);\n\t}\n\n\tvoid update(int l, int r, int x) {\n\t\troot->update(l, r, x);\n\t}\n};\n\nint n, m;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nint main() {\n\tread(n), read(m);\n\n\tSegmentTree segmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tread(x);\n\n\t\tsegmentTree.update(i, i, x);\n\t}\n\n\tint day = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, l, r;\n\t\tread(x), read(l), read(r);\n\n\t\tsegmentTree.update(l, r, -x);\n\t\tif (segmentTree.queryMin(1, n) < 0) {\n\t\t\tday = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (day != 0) printf(\"-1\\n%d\\n\", day);\n\telse puts(\"0\");\n\n\treturn 0;\n}\n```\n\n二分，AC\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e6;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int available[MAXN];\n\tstatic struct Request {\n\t\tint l, r, cnt;\n\t} req[MAXN];\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &available[i]);\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d\", &req[i].cnt, &req[i].l, &req[i].r), req[i].l--, req[i].r--;\n\n\tint l = -1, r = m - 1;\n\tstatic int used[MAXN];\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tbool valid = true;\n\n\t\tfor (int i = 0; i < n; i++) used[i] = 0;\n\t\tfor (int i = 0; i <= mid; i++) {\n\t\t\tused[req[i].l] += req[i].cnt;\n\t\t\tif (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) used[i] += used[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] > available[i]) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"[%d, %d] => %d\\n\", l, r, mid);\n#endif\n\n\t\tif (valid) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\n\tif (l == m - 1) puts(\"0\");\n\telse printf(\"-1\\n%d\\n\", l + 1 + 1);\n\n\treturn 0;\n}\n```","source":"_posts/noip2012-classrooms.md","raw":"title: 「NOIP2012」借教室 - 二分 / 线段树\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - COGS\n  - 二分\n  - 线段树\n  - 差分\npermalink: noip2012-classrooms\ndate: 2016-10-08 16:56:00\n---\n\n我们需要处理接下来 $ n $ 天的借教室信息，其中第 $ i $ 天学校有 $ r_i $ 个教室可供租借。共有 $ m $ 份订单，每份订单用三个正整数描述，分别为 $ d_j, s_j, t_j $，表示某租借者需要从第 $ s_j $ 天到第 $ t_j $ 天租借教室（包括第 $ s_j $ 天和第 $ t_j $ 天），每天需要租借 $ d_j $ 个教室。 \n\n现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。\n\n<!-- more -->\n\n### 链接\n[COGS 1266](http://cogs.pro/cogs/problem/problem.php?pid=1266)  \n[CodeVS 1217](http://codevs.cn/problem/1217/)\n\n### 题解\n#### 解法一\n对天数建立线段树，维护区间最小值，每次租借时查询区间最小值，如果小于租借数量，则无法满足，否则对一个区间减去租借数量，继续处理下一个订单。\n\n期望得分 100 分，**实际得分 95 分**。\n\n#### 解法二\n二分天数 $ x $，使用差分 + 前缀和检验前 $ x $ 天是否可以完全满足。\n\n期望得分 100 分，实际得分 100 分。\n\n### 代码\n线段树，TLE\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 1000000;\nconst int MAXR = 1000000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar a[SIZE * sizeof(T)];\n\tT *p;\n\n\tMemoryPool() : p((T *)a) {}\n\n\tT *alloc() {\n\t\treturn p++;\n\t}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, min, lazy;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (lchild) lchild->value += lazy, lchild->min += lazy, lchild->lazy += lazy;\n\t\t\t\tif (rchild) rchild->value += lazy, rchild->min += lazy, rchild->lazy += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tint queryMin(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\t\telse if (l <= this->l && r >= this->r) return min;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tif (lchild) ans = std::min(ans, lchild->queryMin(l, r));\n\t\t\t\tif (rchild) ans = std::min(ans, rchild->queryMin(l, r));\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) value += x, min += x, lazy += x;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tif (lchild) lchild->update(l, r, x);\n\t\t\t\tif (rchild) rchild->update(l, r, x);\n\n\t\t\t\tmin = INT_MAX;\n\t\t\t\tif (lchild) min = std::min(min, lchild->min);\n\t\t\t\tif (rchild) min = std::min(min, rchild->min);\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tstatic MemoryPool<Node, MAXN * 2> pool;\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL);\n\t\telse return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tint queryMin(int l, int r) {\n\t\treturn root->queryMin(l, r);\n\t}\n\n\tvoid update(int l, int r, int x) {\n\t\troot->update(l, r, x);\n\t}\n};\n\nint n, m;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nint main() {\n\tread(n), read(m);\n\n\tSegmentTree segmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tread(x);\n\n\t\tsegmentTree.update(i, i, x);\n\t}\n\n\tint day = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, l, r;\n\t\tread(x), read(l), read(r);\n\n\t\tsegmentTree.update(l, r, -x);\n\t\tif (segmentTree.queryMin(1, n) < 0) {\n\t\t\tday = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (day != 0) printf(\"-1\\n%d\\n\", day);\n\telse puts(\"0\");\n\n\treturn 0;\n}\n```\n\n二分，AC\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e6;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int available[MAXN];\n\tstatic struct Request {\n\t\tint l, r, cnt;\n\t} req[MAXN];\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &available[i]);\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d\", &req[i].cnt, &req[i].l, &req[i].r), req[i].l--, req[i].r--;\n\n\tint l = -1, r = m - 1;\n\tstatic int used[MAXN];\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tbool valid = true;\n\n\t\tfor (int i = 0; i < n; i++) used[i] = 0;\n\t\tfor (int i = 0; i <= mid; i++) {\n\t\t\tused[req[i].l] += req[i].cnt;\n\t\t\tif (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) used[i] += used[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] > available[i]) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"[%d, %d] => %d\\n\", l, r, mid);\n#endif\n\n\t\tif (valid) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\n\tif (l == m - 1) puts(\"0\");\n\telse printf(\"-1\\n%d\\n\", l + 1 + 1);\n\n\treturn 0;\n}\n```","slug":"noip2012-classrooms","published":1,"updated":"2016-10-08T09:04:11.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rml00nqooxlq0mqpsh5"},{"title":"「NOIP2012」疫情控制 - 二分 + 倍增 + 贪心","date":"2016-11-13T09:44:00.000Z","_content":"\nH 国有 $ n $ 个城市，这 $ n $ 个城市用 $ n - 1 $ 条双向道路相互连通构成一棵树，$ 1 $ 号城市是首都，也是树中的根节点。\n\nH 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。\n\n现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。\n\n请问最少需要多少个小时才能控制疫情。注意，不同的军队可以同时移动。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### 题解\n首先二分答案 $ t $，检验能否在 $ t $ 时间之内控制疫情。\n\n倍增求出每个军队能到达的最高（深度最小的）点，考虑根节点的每棵子树，如果这棵子树无法被**未能到达根**的军队完全覆盖，则需要将一个到达根的军队移动到这棵子树上，或者让一个原本能从这棵子树移动到根军队回到这棵子树。\n\n求出每个能到达根的军队的剩余时间（设它们为 $ X $ 集），和根到每个需要额外军队的子树的边权（设它们为 $ Y $ 集）。\n\n问题转化为，用 $ X $ 集去覆盖 $ Y $ 集，$ X $ 集中的每个元素可以覆盖 $ Y $ 集中不大于它的元素，并且 $ X $ 中的每个元素可以额外覆盖 $ Y $ 集中的一个元素，求能否覆盖。\n\n分别将 $ X $ 集和 $ Y $ 集排序，从小到大枚举 $ X $ 集中的每个元素，如果它可以额外覆盖的 $ Y $ 集元素未被覆盖，则去覆盖这个元素，否则覆盖最小未被覆盖的 $ Y $ 集元素。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <list>\n\nconst int MAXN = 50000;\nconst int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tbool visited, settled, childSettled;\n\tstd::vector<int> arrived;\n} N[MAXN + 1], *seq[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tint w;\n\tbool visited;\n\tstd::list<Edge *>::iterator it;\n\n\tEdge(Node *s, Node *t, int w) : s(s), t(t), next(s->e), w(w) {}\n};\n\ninline void addEdge(int s, int t, int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, m, a[MAXN + 1], logn;\n\nint f[MAXN + 1][MAXN_LOG + 1];\nlong long g[MAXN + 1][MAXN_LOG + 1];\n\ninline void prepare() {\n\tstd::queue<Node *> q;\n\n\tN[1].visited = true;\n\tf[1][0] = 1;\n\tg[1][0] = 0;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\tf[e->t - N][0] = v - N;\n\t\t\t\tg[e->t - N][0] = e->w;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n}\n\ninline bool compare(Edge *a, Edge *b) {\n\treturn a->w < b->w;\n}\n\ninline bool check(long long limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].arrived.clear();\n\t\tN[i].settled = false;\n\t\tN[i].childSettled = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = a[i];\n\n\t\tlong long dist = 0;\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (dist + g[u][j] <= limit && f[u][j] != 1) {\n\t\t\t\tdist += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\n\t\tN[u].arrived.push_back(limit - dist);\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (seq[i]->e->next || i == 1) { // It's not a leaf\n\t\t\tseq[i]->childSettled = true;\n\t\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\t\tif (e->t == seq[i]->parent) continue;\n\n\t\t\t\tif (!e->t->settled) {\n\t\t\t\t\tseq[i]->childSettled = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d, settled = %d\\n\", seq[i] - N, seq[i]->childSettled, seq[i]->settled);\n#endif\n\n\t\tseq[i]->settled = seq[i]->childSettled;\n\n\t\tif (seq[i]->arrived.size()) {\n\t\t\tseq[i]->settled = true;\n\t\t}\n\t}\n\n\tif (N[1].settled) return true;\n\n\tstd::list< std::pair<int, Edge *> > atRoot;\n\tstd::list<Edge *> needSettle;\n\tfor (Edge *e = N[1].e; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d\\n\", e->t - N, e->t->childSettled);\n#endif\n\n\t\tstd::vector<int> &vec = e->t->arrived;\n\t\tstd::sort(vec.begin(), vec.end());\n\n\t\tbool remain = e->t->childSettled;\n\t\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i] >= e->w) atRoot.push_back(std::make_pair(vec[i] - e->w, e));\n\t\t\telse remain = true;\n\t\t}\n\n\t\tif (remain) {\n\t\t\te->visited = true;\n\t\t} else {\n\t\t\tneedSettle.push_back(e);\n\t\t\te->it = --needSettle.end();\n\t\t\te->visited = false;\n\t\t}\n\t}\n\n\tatRoot.sort();\n\tneedSettle.sort(&compare);\n\n#ifdef DBG\n\tstd::vector< std::pair<int, Edge *> > _atRoot(atRoot.begin(), atRoot.end());\n\tstd::vector<Edge *> _needSettle(needSettle.begin(), needSettle.end());\n#endif\n\t// std::sort(needSettle.begin(), needSettle.end(), &compare);\n\n\tfor (std::list< std::pair<int, Edge *> >::iterator it = atRoot.begin(); it != atRoot.end(); it++) {\n\t\tif (needSettle.empty()) break;\n\t\tif (!it->second->visited) {\n\t\t\tit->second->visited = true;\n\t\t\tneedSettle.erase(it->second->it);\n\t\t} else {\n\t\t\tif (needSettle.front()->w <= it->first) {\n\t\t\t\tneedSettle.front()->visited = true;\n\t\t\t\tneedSettle.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSettle.empty();\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\tsum += w;\n\t\taddEdge(u, v, w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (Edge *e = N[1].e; e; e = e->next) cnt++;\n\n\tif (cnt > m) puts(\"-1\");\n\telse {\n\t\tint l = 0, r = sum;\n\t\twhile (l < r) {\n\t\t\tint mid = l + (r - l) / 2;\n#ifdef DBG\n\t\t\tprintf(\"[%d, %d], mid = %d\\n\", l, r, mid);\n#endif\n\t\t\tif (check(mid)) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2012-blockade.md","raw":"title: 「NOIP2012」疫情控制 - 二分 + 倍增 + 贪心\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - 二分\n  - 倍增\n  - 贪心\npermalink: noip2012-blockade\ndate: 2016-11-13 17:44:00\n---\n\nH 国有 $ n $ 个城市，这 $ n $ 个城市用 $ n - 1 $ 条双向道路相互连通构成一棵树，$ 1 $ 号城市是首都，也是树中的根节点。\n\nH 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。\n\n现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。\n\n请问最少需要多少个小时才能控制疫情。注意，不同的军队可以同时移动。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### 题解\n首先二分答案 $ t $，检验能否在 $ t $ 时间之内控制疫情。\n\n倍增求出每个军队能到达的最高（深度最小的）点，考虑根节点的每棵子树，如果这棵子树无法被**未能到达根**的军队完全覆盖，则需要将一个到达根的军队移动到这棵子树上，或者让一个原本能从这棵子树移动到根军队回到这棵子树。\n\n求出每个能到达根的军队的剩余时间（设它们为 $ X $ 集），和根到每个需要额外军队的子树的边权（设它们为 $ Y $ 集）。\n\n问题转化为，用 $ X $ 集去覆盖 $ Y $ 集，$ X $ 集中的每个元素可以覆盖 $ Y $ 集中不大于它的元素，并且 $ X $ 中的每个元素可以额外覆盖 $ Y $ 集中的一个元素，求能否覆盖。\n\n分别将 $ X $ 集和 $ Y $ 集排序，从小到大枚举 $ X $ 集中的每个元素，如果它可以额外覆盖的 $ Y $ 集元素未被覆盖，则去覆盖这个元素，否则覆盖最小未被覆盖的 $ Y $ 集元素。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <list>\n\nconst int MAXN = 50000;\nconst int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tbool visited, settled, childSettled;\n\tstd::vector<int> arrived;\n} N[MAXN + 1], *seq[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tint w;\n\tbool visited;\n\tstd::list<Edge *>::iterator it;\n\n\tEdge(Node *s, Node *t, int w) : s(s), t(t), next(s->e), w(w) {}\n};\n\ninline void addEdge(int s, int t, int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, m, a[MAXN + 1], logn;\n\nint f[MAXN + 1][MAXN_LOG + 1];\nlong long g[MAXN + 1][MAXN_LOG + 1];\n\ninline void prepare() {\n\tstd::queue<Node *> q;\n\n\tN[1].visited = true;\n\tf[1][0] = 1;\n\tg[1][0] = 0;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\tf[e->t - N][0] = v - N;\n\t\t\t\tg[e->t - N][0] = e->w;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n}\n\ninline bool compare(Edge *a, Edge *b) {\n\treturn a->w < b->w;\n}\n\ninline bool check(long long limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].arrived.clear();\n\t\tN[i].settled = false;\n\t\tN[i].childSettled = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = a[i];\n\n\t\tlong long dist = 0;\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (dist + g[u][j] <= limit && f[u][j] != 1) {\n\t\t\t\tdist += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\n\t\tN[u].arrived.push_back(limit - dist);\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (seq[i]->e->next || i == 1) { // It's not a leaf\n\t\t\tseq[i]->childSettled = true;\n\t\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\t\tif (e->t == seq[i]->parent) continue;\n\n\t\t\t\tif (!e->t->settled) {\n\t\t\t\t\tseq[i]->childSettled = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d, settled = %d\\n\", seq[i] - N, seq[i]->childSettled, seq[i]->settled);\n#endif\n\n\t\tseq[i]->settled = seq[i]->childSettled;\n\n\t\tif (seq[i]->arrived.size()) {\n\t\t\tseq[i]->settled = true;\n\t\t}\n\t}\n\n\tif (N[1].settled) return true;\n\n\tstd::list< std::pair<int, Edge *> > atRoot;\n\tstd::list<Edge *> needSettle;\n\tfor (Edge *e = N[1].e; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d\\n\", e->t - N, e->t->childSettled);\n#endif\n\n\t\tstd::vector<int> &vec = e->t->arrived;\n\t\tstd::sort(vec.begin(), vec.end());\n\n\t\tbool remain = e->t->childSettled;\n\t\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i] >= e->w) atRoot.push_back(std::make_pair(vec[i] - e->w, e));\n\t\t\telse remain = true;\n\t\t}\n\n\t\tif (remain) {\n\t\t\te->visited = true;\n\t\t} else {\n\t\t\tneedSettle.push_back(e);\n\t\t\te->it = --needSettle.end();\n\t\t\te->visited = false;\n\t\t}\n\t}\n\n\tatRoot.sort();\n\tneedSettle.sort(&compare);\n\n#ifdef DBG\n\tstd::vector< std::pair<int, Edge *> > _atRoot(atRoot.begin(), atRoot.end());\n\tstd::vector<Edge *> _needSettle(needSettle.begin(), needSettle.end());\n#endif\n\t// std::sort(needSettle.begin(), needSettle.end(), &compare);\n\n\tfor (std::list< std::pair<int, Edge *> >::iterator it = atRoot.begin(); it != atRoot.end(); it++) {\n\t\tif (needSettle.empty()) break;\n\t\tif (!it->second->visited) {\n\t\t\tit->second->visited = true;\n\t\t\tneedSettle.erase(it->second->it);\n\t\t} else {\n\t\t\tif (needSettle.front()->w <= it->first) {\n\t\t\t\tneedSettle.front()->visited = true;\n\t\t\t\tneedSettle.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSettle.empty();\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\tsum += w;\n\t\taddEdge(u, v, w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (Edge *e = N[1].e; e; e = e->next) cnt++;\n\n\tif (cnt > m) puts(\"-1\");\n\telse {\n\t\tint l = 0, r = sum;\n\t\twhile (l < r) {\n\t\t\tint mid = l + (r - l) / 2;\n#ifdef DBG\n\t\t\tprintf(\"[%d, %d], mid = %d\\n\", l, r, mid);\n#endif\n\t\t\tif (check(mid)) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2012-blockade","published":1,"updated":"2016-11-13T09:44:18.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rmt00o0ooxlss0g7dh7"},{"title":"「NOIP2010」关押罪犯 - 二分图染色","id":"54","updated":"2016-02-19T08:06:06.000Z","date":"2016-02-19T08:00:26.000Z","_content":"\nS 城现有两座监狱，一共关押着 `N` 名罪犯，编号分别为 `1 ~ N`，我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。每年每一对有仇恨的罪犯会发生一次冲突。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力。那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小，求这个最小值是多少？\n\n<!-- more -->\n\n### 链接\n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[洛谷 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### 题解\n因为要求最小值，所以考虑二分答案。当我们二分一个答案 `x` 后，只需要考虑怒气值大于 `x` 的成对罪犯了，这时候对整张图进行二分图染色，如果能被染色成为二分图，则这个答案合法。\n\n二分图染色：把每个未标记的节点标记为任意一种颜色，对其进行一次 BFS，每一次扩展把未被染色的节点标记为与自身相反的颜色，如果发现扩展出去的节点的颜色与自身相同，则染色失败。\n\n时间复杂度为 $ O(n{log}n) $，理论上来说可以过 100% 的数据，然而 Tyvj 的评测机太烂竟然 TLE 了一个点。\n\n有神犇说可以用并查集，然而我太弱不会 …… qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-prison.md","raw":"title: 「NOIP2010」关押罪犯 - 二分图染色\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Vijos\n  - 洛谷\n  - 图论\n  - 二分答案\n  - 二分图染色\npermalink: noip2010-prison\nid: 54\nupdated: '2016-02-19 16:06:06'\ndate: 2016-02-19 16:00:26\n---\n\nS 城现有两座监狱，一共关押着 `N` 名罪犯，编号分别为 `1 ~ N`，我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。每年每一对有仇恨的罪犯会发生一次冲突。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力。那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小，求这个最小值是多少？\n\n<!-- more -->\n\n### 链接\n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[洛谷 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### 题解\n因为要求最小值，所以考虑二分答案。当我们二分一个答案 `x` 后，只需要考虑怒气值大于 `x` 的成对罪犯了，这时候对整张图进行二分图染色，如果能被染色成为二分图，则这个答案合法。\n\n二分图染色：把每个未标记的节点标记为任意一种颜色，对其进行一次 BFS，每一次扩展把未被染色的节点标记为与自身相反的颜色，如果发现扩展出去的节点的颜色与自身相同，则染色失败。\n\n时间复杂度为 $ O(n{log}n) $，理论上来说可以过 100% 的数据，然而 Tyvj 的评测机太烂竟然 TLE 了一个点。\n\n有神犇说可以用并查集，然而我太弱不会 …… qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","slug":"noip2010-prison","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rmy00o7ooxly56ie22t"},{"title":"「NOIP2010」引水入城 - BFS + DP","date":"2016-11-13T09:23:00.000Z","_content":"\n在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个 $ N $ 行 $ M $ 列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。\n\n为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。因此，只有与湖泊毗邻的第 $ 1 $ 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。\n\n由于第 $ N $ 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1066](http://codevs.cn/problem/1066/)\n\n### 题解\n对于第一问，以第一行为起点，做 Floodfill，如果最后一行均能访问到，则能满足。\n\n对于第二问，分别以第一行每个点为起点，做 Floodfill，得到它能到达的最后一行的所有点，这些点一定构成了一个连续的区间（证明略）。得到 $ m $ 个区间，问题转化为选择尽量少的区间，覆盖整个区域 —— 排序后 DP 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 500;\n\nconst int di[] = { 0, 1, 0, -1 };\nconst int dj[] = { -1, 0, 1, 0 };\n\nstruct Node {\n\tint height;\n\tbool visited;\n} map[MAXN + 2][MAXN + 2];\n\nint n, m;\n\nstruct Point {\n\tint i, j;\n\t\n\tPoint(int i = 0, int j = 0) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tbool valid() {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n};\n\nstruct Interval {\n\tint l, r;\n\n\tInterval(int l = 0, int r = 0) : l(l), r(r) {}\n\n\tbool operator<(const Interval &other) const {\n\t\treturn (l == other.l) ? (r < other.r) : (l < other.l);\n\t}\n};\n\ninline int bfs(Point start, Interval &interval) {\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) map[i][j].visited = false;\n\n\tstd::queue<Point> q;\n\tif (start.i == 0 && start.j == 0) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap[1][i].visited = true;\n\t\t\tq.push(Point(1, i));\n\t\t}\n\t} else {\n\t\tq.push(start);\n\t\tstart->visited = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\t\t\tif (!u.valid()) continue;\n\n\t\t\tif (u->height < v->height && !u->visited) {\n\t\t\t\tu->visited = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start.i == 0 && start.j == 0) {\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) if (!map[n][i].visited) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool flag = false;\n#ifdef DBG\n\tprintf(\"%d:\", start.j);\n#endif\n\tfor (int i = 1; i <= m + 1; i++) {\n#ifdef DBG\n\t\tif (map[n][i].visited) {\n\t\t\tprintf(\" %d\", i);\n\t\t}\n#endif\n\t\tif (!flag && map[n][i].visited) {\n\t\t\tinterval.l = i;\n\t\t\tflag = true;\n\t\t} else if (flag && !map[n][i].visited) {\n\t\t\tinterval.r = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\" = [%d, %d]\\n\", interval.l, interval.r);\n#endif\n\n\treturn flag;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf(\"%d\", &map[i][j].height);\n\n\tInterval tmp;\n\tint cnt = bfs(Point(0, 0), tmp);\n\n\tif (cnt) {\n\t\tprintf(\"0\\n%d\\n\", cnt);\n\t} else {\n\t\tstatic Interval a[MAXN + 1];\n\t\tint k  = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tInterval interval;\n\t\t\tif (bfs(Point(1, i), interval)) {\n\t\t\t\ta[++k] = interval;\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(a + 1, a + k+ 1);\n\n\t\tstatic int f[MAXN + 1];\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tf[i] = INT_MAX;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[j].r >= a[i].l - 1) {\n\t\t\t\t\tf[i] = std::min(f[i], f[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i].r == m) ans = std::min(ans, f[i]);\n\t\t}\n\n\t\tprintf(\"1\\n%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-flow.md","raw":"title: 「NOIP2010」引水入城 - BFS + DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BFS\n  - DP\n  - 线性 DP\npermalink: noip2010-flow\ndate: 2016-11-13 17:23:00\n---\n\n在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个 $ N $ 行 $ M $ 列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。\n\n为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。因此，只有与湖泊毗邻的第 $ 1 $ 行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。\n\n由于第 $ N $ 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1066](http://codevs.cn/problem/1066/)\n\n### 题解\n对于第一问，以第一行为起点，做 Floodfill，如果最后一行均能访问到，则能满足。\n\n对于第二问，分别以第一行每个点为起点，做 Floodfill，得到它能到达的最后一行的所有点，这些点一定构成了一个连续的区间（证明略）。得到 $ m $ 个区间，问题转化为选择尽量少的区间，覆盖整个区域 —— 排序后 DP 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 500;\n\nconst int di[] = { 0, 1, 0, -1 };\nconst int dj[] = { -1, 0, 1, 0 };\n\nstruct Node {\n\tint height;\n\tbool visited;\n} map[MAXN + 2][MAXN + 2];\n\nint n, m;\n\nstruct Point {\n\tint i, j;\n\t\n\tPoint(int i = 0, int j = 0) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tbool valid() {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n};\n\nstruct Interval {\n\tint l, r;\n\n\tInterval(int l = 0, int r = 0) : l(l), r(r) {}\n\n\tbool operator<(const Interval &other) const {\n\t\treturn (l == other.l) ? (r < other.r) : (l < other.l);\n\t}\n};\n\ninline int bfs(Point start, Interval &interval) {\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) map[i][j].visited = false;\n\n\tstd::queue<Point> q;\n\tif (start.i == 0 && start.j == 0) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap[1][i].visited = true;\n\t\t\tq.push(Point(1, i));\n\t\t}\n\t} else {\n\t\tq.push(start);\n\t\tstart->visited = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\t\t\tif (!u.valid()) continue;\n\n\t\t\tif (u->height < v->height && !u->visited) {\n\t\t\t\tu->visited = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start.i == 0 && start.j == 0) {\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) if (!map[n][i].visited) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool flag = false;\n#ifdef DBG\n\tprintf(\"%d:\", start.j);\n#endif\n\tfor (int i = 1; i <= m + 1; i++) {\n#ifdef DBG\n\t\tif (map[n][i].visited) {\n\t\t\tprintf(\" %d\", i);\n\t\t}\n#endif\n\t\tif (!flag && map[n][i].visited) {\n\t\t\tinterval.l = i;\n\t\t\tflag = true;\n\t\t} else if (flag && !map[n][i].visited) {\n\t\t\tinterval.r = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\" = [%d, %d]\\n\", interval.l, interval.r);\n#endif\n\n\treturn flag;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf(\"%d\", &map[i][j].height);\n\n\tInterval tmp;\n\tint cnt = bfs(Point(0, 0), tmp);\n\n\tif (cnt) {\n\t\tprintf(\"0\\n%d\\n\", cnt);\n\t} else {\n\t\tstatic Interval a[MAXN + 1];\n\t\tint k  = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tInterval interval;\n\t\t\tif (bfs(Point(1, i), interval)) {\n\t\t\t\ta[++k] = interval;\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(a + 1, a + k+ 1);\n\n\t\tstatic int f[MAXN + 1];\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tf[i] = INT_MAX;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[j].r >= a[i].l - 1) {\n\t\t\t\t\tf[i] = std::min(f[i], f[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i].r == m) ans = std::min(ans, f[i]);\n\t\t}\n\n\t\tprintf(\"1\\n%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2010-flow","published":1,"updated":"2016-11-13T09:23:38.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rn600ojooxl1ilaowdd"},{"title":"「NOIP2006」能量项链 - 区间 DP","id":"19","updated":"2016-01-19T13:04:41.000Z","date":"2016-01-12T21:19:28.000Z","_content":"\n在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为$m*r*n$（Mars单位），新产生的珠子的头标记为m，尾标记为n。\n需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### 题解\n首先，项链是一个环，枚举断点给它拆开。\n\n区间DP，用 $a[i]$ 表示第 `i` 颗珠子的头标记（即第 `i + 1` 颗珠子的尾标记），用 $f[i][j]$ 表示第 `i` 到第 `j` 颗珠子聚合成一颗后释放能量的最大值，枚举 `k`，自 `k` 处断开后，无论左右两段如何聚合，两段分别聚合成的两个珠子的标记值是不变的，即状态转移方程为：\n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n边界条件为：\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n注意代码编写时，访问最后一颗珠子的尾标记时，会越界，可以通过将下标对珠子总数取模的方法解决，因为最后一颗珠子的尾标记等于第一颗珠子的头标记。\n\n总时间复杂度为 $O(n^4)$，刚好解决 $n=100$ 的最大测试点 TvT。\n\n调试可费了大功夫，详见**注释掉的代码**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2006-energy.md","raw":"title: 「NOIP2006」能量项链 - 区间 DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - Tyvj\n  - 区间 DP\npermalink: noip2006-energy\nid: 19\nupdated: '2016-01-19 21:04:41'\ndate: 2016-01-13 05:19:28\n---\n\n在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为$m*r*n$（Mars单位），新产生的珠子的头标记为m，尾标记为n。\n需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### 题解\n首先，项链是一个环，枚举断点给它拆开。\n\n区间DP，用 $a[i]$ 表示第 `i` 颗珠子的头标记（即第 `i + 1` 颗珠子的尾标记），用 $f[i][j]$ 表示第 `i` 到第 `j` 颗珠子聚合成一颗后释放能量的最大值，枚举 `k`，自 `k` 处断开后，无论左右两段如何聚合，两段分别聚合成的两个珠子的标记值是不变的，即状态转移方程为：\n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n边界条件为：\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n注意代码编写时，访问最后一颗珠子的尾标记时，会越界，可以通过将下标对珠子总数取模的方法解决，因为最后一颗珠子的尾标记等于第一颗珠子的头标记。\n\n总时间复杂度为 $O(n^4)$，刚好解决 $n=100$ 的最大测试点 TvT。\n\n调试可费了大功夫，详见**注释掉的代码**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noip2006-energy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnb00orooxl4qu3u03v"},{"title":"「NOIP2006」金明的预算方案 - 背包 DP + 树形 DP","id":"25","updated":"2016-01-19T13:02:58.000Z","date":"2016-01-16T22:11:03.000Z","_content":"\n金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的。\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[洛谷 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### 题解\n其实题挺水的，直接枚举选哪个附件就好，但学了树形 DP 就要写一写嘛。\n\n首先，我们有一个 01 背包的方程：\n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n对某个节点求解时，先对每一个子物品递归求解，然后进行一次 01 背包，得到一个由该物品及其附属物品组成的泛化物品组，然后一级一级地传到最顶层。\n\n设置一个价值与费用均为 `0` 的虚拟节点并将其作为所有无依赖的物品的父节点，求解 `0` 即为最终结果。\n\n更具体的讲解详见《背包九讲》。~~我太弱了讲不明白呢。~~\n\nPS：有个“坑”就是题目中的背包容量太大太大了，是妥妥的要 TLE 的（只能过前五个），但是因为背包容量和每件物品的体积都是 `10` 的倍数，所以读入数据后直接除以 `10` 就好。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2006-budget.md","raw":"title: 「NOIP2006」金明的预算方案 - 背包 DP + 树形 DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - Vijos\n  - 树形 DP\n  - 洛谷\n  - 背包 DP\npermalink: noip2006-budget\nid: 25\nupdated: '2016-01-19 21:02:58'\ndate: 2016-01-17 06:11:03\n---\n\n金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的。\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[洛谷 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### 题解\n其实题挺水的，直接枚举选哪个附件就好，但学了树形 DP 就要写一写嘛。\n\n首先，我们有一个 01 背包的方程：\n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n对某个节点求解时，先对每一个子物品递归求解，然后进行一次 01 背包，得到一个由该物品及其附属物品组成的泛化物品组，然后一级一级地传到最顶层。\n\n设置一个价值与费用均为 `0` 的虚拟节点并将其作为所有无依赖的物品的父节点，求解 `0` 即为最终结果。\n\n更具体的讲解详见《背包九讲》。~~我太弱了讲不明白呢。~~\n\nPS：有个“坑”就是题目中的背包容量太大太大了，是妥妥的要 TLE 的（只能过前五个），但是因为背包容量和每件物品的体积都是 `10` 的倍数，所以读入数据后直接除以 `10` 就好。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```\n","slug":"noip2006-budget","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rng00oyooxl1q61w30r"},{"title":"「NOIP2003」数字游戏 - 划分 DP","id":"20","updated":"2016-01-19T13:04:15.000Z","date":"2016-01-13T20:23:38.000Z","_content":"\n在你面前有一圈整数（一共 `n`（≤ 50）个），你要按顺序将其分为 `m`（≤ 9）个部分，各部分内的数字相加，相加所得的 `m` 个结果对 10 取模后再相乘，最终得到一个数 `k`。游戏的要求是使你所得的 `k` 最大或者最小。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[洛谷 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### 题解\n又是一道划分 DP，不过坑挺多的 …… 一是枚举断点，二是注意**负数对 `10` 取模后的结果是正数**。\n\n以最大值为例，以“分的部分”的数量划分阶段，用 $ f[i][j] $ 表示前 `i` 个数划分为 `j` 个部分所得的最大值，状态转移方程为：\n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n边界条件为：\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n求和可以用前缀和来维护，但是注意**枚举每个断点都必须重新初始化前缀和**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2003-game.md","raw":"title: 「NOIP2003」数字游戏 - 划分 DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - 划分 DP\n  - 洛谷\n  - Tyvj\npermalink: noip2003-game\nid: 20\nupdated: '2016-01-19 21:04:15'\ndate: 2016-01-14 04:23:38\n---\n\n在你面前有一圈整数（一共 `n`（≤ 50）个），你要按顺序将其分为 `m`（≤ 9）个部分，各部分内的数字相加，相加所得的 `m` 个结果对 10 取模后再相乘，最终得到一个数 `k`。游戏的要求是使你所得的 `k` 最大或者最小。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[洛谷 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### 题解\n又是一道划分 DP，不过坑挺多的 …… 一是枚举断点，二是注意**负数对 `10` 取模后的结果是正数**。\n\n以最大值为例，以“分的部分”的数量划分阶段，用 $ f[i][j] $ 表示前 `i` 个数划分为 `j` 个部分所得的最大值，状态转移方程为：\n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n边界条件为：\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n求和可以用前缀和来维护，但是注意**枚举每个断点都必须重新初始化前缀和**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```\n","slug":"noip2003-game","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnm00p7ooxlnvt9fmv4"},{"title":"「NOIP2000」乘积最大 - 划分 DP","id":"16","updated":"2016-01-19T13:05:38.000Z","date":"2016-01-08T21:10:45.000Z","_content":"\n在一个长度为 `N`（<= 400）的数字字符串中加上 `K`（<= 6）个乘号，使所得表达式值最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### 题解\n考虑划分 DP，以加入的乘号数量作为划分阶段，用 `f[n][k]` 表示原数字前 `n` 位中加入 `k` 个乘号所得表达式的最大值，预处理出 `a[i][j]` 表示原数字第 `i` 位到第 `j` 位组成的数字，则转移方程为：\n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n因为数据较水，所以使用 `long long` 即可，无需高精。\n\n### 代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```\n","source":"_posts/noip2000-cheng-ji-zui-da.md","raw":"title: 「NOIP2000」乘积最大 - 划分 DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - 划分 DP\npermalink: noip2000-cheng-ji-zui-da\nid: 16\nupdated: '2016-01-19 21:05:38'\ndate: 2016-01-09 05:10:45\n---\n\n在一个长度为 `N`（<= 400）的数字字符串中加上 `K`（<= 6）个乘号，使所得表达式值最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### 题解\n考虑划分 DP，以加入的乘号数量作为划分阶段，用 `f[n][k]` 表示原数字前 `n` 位中加入 `k` 个乘号所得表达式的最大值，预处理出 `a[i][j]` 表示原数字第 `i` 位到第 `j` 位组成的数字，则转移方程为：\n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n因为数据较水，所以使用 `long long` 即可，无需高精。\n\n### 代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```\n","slug":"noip2000-cheng-ji-zui-da","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnq00pfooxlzh4qesq9"},{"title":"「NOI2016」区间 - 线段树","date":"2016-09-05T23:19:00.000Z","_content":"\n在数轴上有 $ n $ 个闭区间 $ [l_1, r_1], [l_2, r_2] , \\ldots, [l_n, r_n] $。现在要从中选出 $ m $ 个区间，使得这 $ m $ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $ x $，使得对于每一个被选中的区间 $ [l_i, r_i] $，都有 $ l_i \\leq x \\leq r_i $。\n\n对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间 $ [l_i, r_i] $ 的长度定义为 $ r_i − l_i $，即等于它的右端点的值减去左端点的值。\n\n求所有合法方案中最小的花费。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4653](http://www.lydsy.com/JudgeOnline/problem.php?id=4653)\n\n### 题解\n将所有区间按照长度排序，按长度从小到大枚举每个区间，在线段树上对其标记，如果线段树上已有一点被 $ m $ 个区间覆盖，则从小到大删除区间，每次更新答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint val, tag;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {}\n\n\tvoid cover(const int delta) {\n\t\tval += delta;\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, delta);\n\t\t\trc->update(l, r, delta);\n\t\t\tval = std::max(lc->val, rc->val);\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return val;\n\t\telse {\n\t\t\tpushDown();\n\t\t\treturn std::max(lc->query(l, r), rc->query(l, r));\n\t\t}\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\nstruct Interval {\n\tint l, r, len;\n\n\tbool operator<(const Interval &other) const { return len < other.len; }\n} a[MAXN];\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].l, &a[i].r), a[i].len = a[i].r - a[i].l;\n\n\tstatic int set[MAXN * 2];\n\tint cnt = 0, max = 0;\n\tfor (int i = 0; i < n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r;\n\tstd::sort(set, set + n * 2);\n\tint *end = std::unique(set, set + n * 2);\n\tfor (int i = 0; i < n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r);\n\n\tstd::sort(a, a + n);\n\n\tsegment = SegmentTree::build(0, max);\n\n\tint ans = INT_MAX;\n\tfor (Interval *l = a, *r = a; r != a + n; r++) {\n\t\tsegment->update(r->l, r->r, 1);\n\t\twhile (l <= r && segment->query(0, max) >= m) {\n\t\t\tans = std::min(ans, r->len - l->len);\n\t\t\tsegment->update(l->l, l->r, -1);\n\t\t\tl++;\n\t\t}\n\t}\n\n\tif (ans == INT_MAX) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2016-interval.md","raw":"title: 「NOI2016」区间 - 线段树\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - 线段树\npermalink: noi2016-interval\ndate: 2016-09-06 07:19:00\n---\n\n在数轴上有 $ n $ 个闭区间 $ [l_1, r_1], [l_2, r_2] , \\ldots, [l_n, r_n] $。现在要从中选出 $ m $ 个区间，使得这 $ m $ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $ x $，使得对于每一个被选中的区间 $ [l_i, r_i] $，都有 $ l_i \\leq x \\leq r_i $。\n\n对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间 $ [l_i, r_i] $ 的长度定义为 $ r_i − l_i $，即等于它的右端点的值减去左端点的值。\n\n求所有合法方案中最小的花费。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4653](http://www.lydsy.com/JudgeOnline/problem.php?id=4653)\n\n### 题解\n将所有区间按照长度排序，按长度从小到大枚举每个区间，在线段树上对其标记，如果线段树上已有一点被 $ m $ 个区间覆盖，则从小到大删除区间，每次更新答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint val, tag;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {}\n\n\tvoid cover(const int delta) {\n\t\tval += delta;\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, delta);\n\t\t\trc->update(l, r, delta);\n\t\t\tval = std::max(lc->val, rc->val);\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return val;\n\t\telse {\n\t\t\tpushDown();\n\t\t\treturn std::max(lc->query(l, r), rc->query(l, r));\n\t\t}\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\nstruct Interval {\n\tint l, r, len;\n\n\tbool operator<(const Interval &other) const { return len < other.len; }\n} a[MAXN];\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].l, &a[i].r), a[i].len = a[i].r - a[i].l;\n\n\tstatic int set[MAXN * 2];\n\tint cnt = 0, max = 0;\n\tfor (int i = 0; i < n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r;\n\tstd::sort(set, set + n * 2);\n\tint *end = std::unique(set, set + n * 2);\n\tfor (int i = 0; i < n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r);\n\n\tstd::sort(a, a + n);\n\n\tsegment = SegmentTree::build(0, max);\n\n\tint ans = INT_MAX;\n\tfor (Interval *l = a, *r = a; r != a + n; r++) {\n\t\tsegment->update(r->l, r->r, 1);\n\t\twhile (l <= r && segment->query(0, max) >= m) {\n\t\t\tans = std::min(ans, r->len - l->len);\n\t\t\tsegment->update(l->l, l->r, -1);\n\t\t\tl++;\n\t\t}\n\t}\n\n\tif (ans == INT_MAX) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2016-interval","published":1,"updated":"2016-09-05T23:39:11.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnu00plooxlun40oh7g"},{"title":"「NOI2016」网格 - 图连通性","date":"2016-09-08T11:40:00.000Z","_content":"\n在一个 $ n \\times m $ 的网格上，有 $ c $ 个障碍，其余均为空地。求至少需要将多少空地转化为障碍，可以使得存在两个空地在四连通意义下不在同一连通块中。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4651](http://www.lydsy.com/JudgeOnline/problem.php?id=4651)  \n[UOJ #220](http://uoj.ac/problem/220)\n\n### 题解\n显然，如果有解，则答案最大为 $ 2 $。我们只需要依次判断答案是否为无解、$ -1 $、$ 0 $、$ 1 $ 即可。\n\n#### 判断无解\n无解有两种情况：\n\n1. 没有空地；\n2. 只有两块在四连通意义下相邻的空地。\n\n对于第一种情况，只需要判断 $ n \\times m = c $ 即可，第二种情况，因为 $ n $ 和 $ m $ 不大（$ n \\times m = c + 2 $），可以标记所有障碍格子，取出两块空地格子的坐标，判断 $ | x_1 - x_2 | + | y_1 - y_2 | = 1 $ 即可。\n\n#### 判断答案为 $ 0 $\n答案为 $ 0 $ 的充要条件为，存在一圈障碍（或边界），把内部和外部的空地隔开。即，**空地被障碍分成了多个连通块**。\n\n因为空地非常多，所以不能直接对空地做 FloodFill。但很多空地是多余的，「有用」的空地只会有 $ O(c) $ 个。\n\n考虑什么情况下障碍可以围成一个圈 —— **围成圈的障碍块一定是一个八连通块**，很显然，如果存在两个障碍块不在同一个八连通块中，则这个「圈」至少有两个缺口。\n\n我们从第一块障碍开始，向八连通方向对障碍块做 FloodFill。会得到一个极大的八连通分量。使用这个八连通分量中**与每个障碍块八连通的空地**建图，四连通空地建连边，如果图不连通，则答案为 $ 0 $。\n\n#### 判断答案为 $ 1 $\n答案为 $ 1 $ 的充要条件为，整个图存在一个点，将这个点变为障碍后，图不连通，即存在**割点**。\n\n和刚才一样，需要取出「有用」的空地来建图。考虑与每个障碍八连通的空地，如果整个图存在割点，则这些点中一定存在割点。\n\n但我们不能简单地使用这些点来建图，考虑下面这种情况：\n\n```plain\n.......\n...111.\n...1*1.\n.11111.\n.1*1...\n.111...\n.......\n```\n\n如果只使用所有被标为的 $ 1 $ 的点来建图，则中间的点为割点 —— 但它不是整个图的割点。\n\n我们可以再加一层空地，即将所有与**与障碍块八连通的空地**八连通的空地加到图中：\n\n```plain\n..22222\n..21112\n2221*12\n2111112\n21*1222\n21112..\n22222..\n```\n\n可以证明，这样建出的图，如果**被标为 $ 1 $ 的点**中有割点，则整个图有割点。\n\n#### 只有一行或一列时\n只有一行或一列时，如果有解，则答案最大为 $ 1 $。考虑如何判断。\n\n如果答案为 $ 0 $，则序列上存在一个由障碍组成的子序列，它的两边均为空地。排序后线性扫描即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define HASH(x, y) (static_cast<unsigned long long>(x) << 32) | static_cast<unsigned long long>(y)\n#define inline inline __attribute__((always_inline))\n\nconst int MAXC = 100000;\nconst int MAXN = MAXC * 24;\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\ntemplate <typename Tk, typename Tv>\nstruct HashMap {\n\tconst static size_t HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tstruct Pair {\n\t\t\tTk first;\n\t\t\tTv second;\n\t\t} p;\n\t\tint time;\n\t} N[HASH_SIZE];\n\n\ttypedef typename Node::Pair *iterator;\n\n\tint time;\n\n\tinline HashMap() : time(1) {}\n\n\tinline int hash(const Tk &k) {\n\t\treturn k % HASH_SIZE;\n\t}\n\n\tinline Node *locate(const Tk &k) {\n\t\tregister int i;\n\t\tfor (i = hash(k); N[i].time == time && N[i].p.first != k; (++i == HASH_SIZE) && (i = 0));\n\t\treturn &N[i];\n\t}\n\n\tinline iterator find(const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) return end();\n\t\treturn &v->p;\n\t}\n\n\tinline Tv &operator[](const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) {\n\t\t\tv->time = time, v->p.first = k, v->p.second = Tv();\n\t\t}\n\t\treturn v->p.second;\n\t}\n\n\tinline void clear() { time++; }\n\n\tinline iterator end() const { return NULL; }\n};\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint type, dfn, low;\n\tbool v, pushed, flag;\n\tint x, y;\n} N[MAXN], *p = N;\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tinline Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(Node *s, Node *t) {\n\ts->e = new Edge(s, t);\n}\n\nint n, m, c;\nstruct Point {\n\tint x, y;\n\n\tinline Point(const int x = 0, const int y = 0) : x(x), y(y) {}\n\n\tinline bool operator<(const Point &other) const {\n\t\treturn y < other.y;\n\t}\n} a[MAXN];\n\nHashMap<unsigned long long, Node *> map;\n\ninline Node *clear(Node *p) {\n\tfor (Edge *&e = p->e, *next; e; next = e->next, delete e, e = next);\n\tmemset(p, 0, sizeof(Node));\n\treturn p;\n}\n\n#ifdef DBG\nchar str[1000][1000];\n#endif\n\ninline void getNodes(const int x, const int y, const bool second = false) {\n\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(x + fx < 1 || x + fx > n || y + fy < 1 || y + fy > m)) {\n\t\tregister int nx = x + fx, ny = y + fy;\n\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx, ny));\n\t\tif (it == map.end() || it->second != NULL) {\n\t\t\tNode *v;\n\t\t\tif (it == map.end()) {\n\t\t\t\tv = map[HASH(nx, ny)] = clear(p++);\n\t\t\t\tv->x = nx, v->y = ny;\n\t\t\t} else v = it->second;\n\t\t\tv->type = 1;\n#ifdef DBG\n\t\t\tstr[v->x][v->y] = 'A';\n#endif\n\t\t\tif (second) for (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(nx + fx < 1 || nx + fx > n || ny + fy < 1 || ny + fy > m)) {\n\t\t\t\tregister int nx2 = nx + fx, ny2 = ny + fy;\n\t\t\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx2, ny2));\n\t\t\t\tif (it == map.end()) {\n\t\t\t\t\tclear(p);\n\t\t\t\t\tp->type = 2;\n\t\t\t\t\tp->x = nx2, p->y = ny2;\n#ifdef DBG\n\t\t\t\t\tstr[p->x][p->y] = 'B';\n#endif\n\t\t\t\t\tmap[HASH(nx2, ny2)] = p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void addEdges() {\n\t// for (HashMap<unsigned long long, Node *>::iterator it = map.begin(); it != map.end(); it++) if (it->second) {\n\tfor (Node *v = N; v != p; v++) {\n\t\tregister int &x = v->x, &y = v->y;\n\t\tfor (register int i = 0; i < 4; i++) if (!(x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m)) {\n\t\t\tregister int nx = x + dx[i], ny = y + dy[i];\n\t\t\tregister HashMap<unsigned long long, Node *>::iterator it2 = map.find(HASH(nx, ny));\n\t\t\tif (it2 != map.end() && it2->second) {\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d] -> [%d, %d]\\n\", v->x, v->y, it2->second->x, it2->second->y);\n#endif\n\t\t\t\taddEdge(v, it2->second);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int tarjan() {\n\tregister int ts = 0, cnt = 0;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\n\t\tstatic Node *s[MAXN];\n\t\tNode **top = s;\n\t\tstart->pushed = true;\n\t\t*top = start;\n\n\t\twhile (top != s - 1) {\n\t\t\tNode *v = *top;\n\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v && e->t != v->p) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) *++top = e->t, e->t->pushed = true, e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != start) for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t->low >= v->dfn) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v->flag && v->type == 1) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ttop--;\n\t\t\t}\n\t\t}\n\n\t\tint ch = 0;\n\t\tfor (Edge *e = start->e; e; e = e->next) if (e->t->p == start) ch++;\n\t\tstart->flag = ch >= 2;\n\t\tif (start->flag && start->type == 1) cnt++;\n\t}\n\n\treturn cnt;\n}\n\ninline bool isOne() {\n\tfor (register int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tmap[HASH(x, y)] = NULL;\n\t}\n\n\tp = N;\n\n\tfor (register int i = 0; i < c; i++) {\n\t\tgetNodes(a[i].x, a[i].y, true);\n\t}\n\n\taddEdges();\n\n\treturn tarjan() != 0;\n}\n\ninline bool bfsCount() {\n\tbool flag = false;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\t\tif (flag) return true;\n\t\tflag = true;\n\n\t\tstatic Node *q[MAXN];\n\t\tNode **l = q, **r = q;\n\t\tstart->v = true;\n\t\t*l = start;\n\n\t\twhile (l <= r) {\n\t\t\tNode *v = *l++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->v) {\n\t\t\t\te->t->v = true;\n\t\t\t\t*++r = e->t;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline bool isZero() {\n\tstatic HashMap<unsigned long long, bool> map2;\n\tmap2.clear();\n\tfor (register int i = 0; i < c; i++) {\n\t\tmap2[HASH(a[i].x, a[i].y)] = false;\n\t}\n\tbool ans = false;\n#ifdef DBG\n\tint id = 0;\n#endif\n\tfor (int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tregister bool &f = map2[HASH(x, y)];\n\t\tif (f) continue;\n\t\tf = true;\n\n#ifdef DBG\n\t\tid++;\n#endif\n\n\t\tstatic Point vec[MAXC];\n\t\tint cnt = 0;\n\n\t\tmap.clear();\n\t\tp = N;\n\n\t\tstatic Point q[MAXC];\n\t\tPoint *l = q, *r = q;\n\t\t*l = Point(x, y);\n\t\twhile (l <= r) {\n\t\t\tPoint p = *l++;\n\n#ifdef DBG\n\t\t\tstr[p.x][p.y] = id + '0';\n#endif\n\n\t\t\tmap[HASH(p.x, p.y)] = NULL;\n\t\t\tvec[cnt++] = p;\n\n\t\t\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(p.x + fx < 1 || p.x + fx > n || p.y + fy < 1 || p.y + fy > m)) {\n\t\t\t\tregister int nx = p.x + fx, ny = p.y + fy;\n\t\t\t\tHashMap<unsigned long long, bool>::iterator it = map2.find(HASH(nx, ny));\n\t\t\t\tif (it != map2.end() && it->second == false) {\n\t\t\t\t\tit->second = true;\n\t\t\t\t\t*++r = Point(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) getNodes(vec[i].x, vec[i].y);\n\t\taddEdges();\n\t\tif (bfsCount()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmap.clear();\n\treturn ans;\n}\n\ninline bool isInvalid() {\n\tconst unsigned long long r = static_cast<unsigned long long>(n) * m - c;\n\tif (r < 2) return true;\n\telse if (r == 2) {\n\t\tstatic bool flag[MAXC];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tflag[(a[i].x - 1) * m + a[i].y - 1] = true;\n\t\t}\n\n\t\tPoint pts[2];\n\t\tfor (int i = 0, cnt = 0; i < n; i++) for (int j = 0; j < m; j++) {\n\t\t\tif (!flag[i * m + j]) pts[cnt++] = Point(i, j);\n\t\t\tflag[i * m + j] = false;\n\t\t}\n\n\t\treturn abs(pts[0].x - pts[1].x) + abs(pts[0].y - pts[1].y) == 1;\n\t} else return false;\n}\n\ninline const char *special() {\n\tstd::sort(a, a + c);\n\tint last = 0, cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (a[i].y != last + 1) {\n\t\t\tcnt++;\n\t\t}\n\t\tlast = a[i].y;\n\t}\n\tif (last != m) cnt++;\n\treturn cnt == 1 ? \"1\" : \"0\";\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar_unlocked(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar_unlocked(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tint t;\n\tread(t);\n\twhile (t--) {\n\t\tread(n), read(m), read(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tread(a[i].x), read(a[i].y);\n\t\t\tif (n > m) std::swap(a[i].x, a[i].y);\n\t\t}\n\n\t\tif (n > m) std::swap(n, m);\n\n\t\tif (isInvalid()) puts(\"-1\");\n\t\telse if (n == 1) puts(special());\n\t\telse if (isZero()) puts(\"0\");\n\t\telse if (isOne()) puts(\"1\");\n\t\telse puts(\"2\");\n\n#ifdef DBG\n\t\tfor (Node *v = N; v != p; v++) {\n\t\t\tprintf(\"[%d, %d] => %d\\n\", v->x, v->y, v->type);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tHashMap<unsigned long long, Node *>::iterator it = map.find(HASH(i, j));\n\t\t\t\tif (it == map.end()) putchar('-');\n\t\t\t\telse if (!it->second) putchar('X');\n\t\t\t\telse putchar('0' + it->second->type);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tputchar(str[i][j] ? str[i][j] : '-');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n#endif\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2016-grid.md","raw":"title: 「NOI2016」网格 - 图连通性\ncategories: OI\ntags: \n  - BZOJ\n  - NOI\n  - Tarjan\n  - 图论\n  - 割点\npermalink: noi2016-grid\ndate: 2016-09-08 19:40:00\n---\n\n在一个 $ n \\times m $ 的网格上，有 $ c $ 个障碍，其余均为空地。求至少需要将多少空地转化为障碍，可以使得存在两个空地在四连通意义下不在同一连通块中。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4651](http://www.lydsy.com/JudgeOnline/problem.php?id=4651)  \n[UOJ #220](http://uoj.ac/problem/220)\n\n### 题解\n显然，如果有解，则答案最大为 $ 2 $。我们只需要依次判断答案是否为无解、$ -1 $、$ 0 $、$ 1 $ 即可。\n\n#### 判断无解\n无解有两种情况：\n\n1. 没有空地；\n2. 只有两块在四连通意义下相邻的空地。\n\n对于第一种情况，只需要判断 $ n \\times m = c $ 即可，第二种情况，因为 $ n $ 和 $ m $ 不大（$ n \\times m = c + 2 $），可以标记所有障碍格子，取出两块空地格子的坐标，判断 $ | x_1 - x_2 | + | y_1 - y_2 | = 1 $ 即可。\n\n#### 判断答案为 $ 0 $\n答案为 $ 0 $ 的充要条件为，存在一圈障碍（或边界），把内部和外部的空地隔开。即，**空地被障碍分成了多个连通块**。\n\n因为空地非常多，所以不能直接对空地做 FloodFill。但很多空地是多余的，「有用」的空地只会有 $ O(c) $ 个。\n\n考虑什么情况下障碍可以围成一个圈 —— **围成圈的障碍块一定是一个八连通块**，很显然，如果存在两个障碍块不在同一个八连通块中，则这个「圈」至少有两个缺口。\n\n我们从第一块障碍开始，向八连通方向对障碍块做 FloodFill。会得到一个极大的八连通分量。使用这个八连通分量中**与每个障碍块八连通的空地**建图，四连通空地建连边，如果图不连通，则答案为 $ 0 $。\n\n#### 判断答案为 $ 1 $\n答案为 $ 1 $ 的充要条件为，整个图存在一个点，将这个点变为障碍后，图不连通，即存在**割点**。\n\n和刚才一样，需要取出「有用」的空地来建图。考虑与每个障碍八连通的空地，如果整个图存在割点，则这些点中一定存在割点。\n\n但我们不能简单地使用这些点来建图，考虑下面这种情况：\n\n```plain\n.......\n...111.\n...1*1.\n.11111.\n.1*1...\n.111...\n.......\n```\n\n如果只使用所有被标为的 $ 1 $ 的点来建图，则中间的点为割点 —— 但它不是整个图的割点。\n\n我们可以再加一层空地，即将所有与**与障碍块八连通的空地**八连通的空地加到图中：\n\n```plain\n..22222\n..21112\n2221*12\n2111112\n21*1222\n21112..\n22222..\n```\n\n可以证明，这样建出的图，如果**被标为 $ 1 $ 的点**中有割点，则整个图有割点。\n\n#### 只有一行或一列时\n只有一行或一列时，如果有解，则答案最大为 $ 1 $。考虑如何判断。\n\n如果答案为 $ 0 $，则序列上存在一个由障碍组成的子序列，它的两边均为空地。排序后线性扫描即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define HASH(x, y) (static_cast<unsigned long long>(x) << 32) | static_cast<unsigned long long>(y)\n#define inline inline __attribute__((always_inline))\n\nconst int MAXC = 100000;\nconst int MAXN = MAXC * 24;\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\ntemplate <typename Tk, typename Tv>\nstruct HashMap {\n\tconst static size_t HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tstruct Pair {\n\t\t\tTk first;\n\t\t\tTv second;\n\t\t} p;\n\t\tint time;\n\t} N[HASH_SIZE];\n\n\ttypedef typename Node::Pair *iterator;\n\n\tint time;\n\n\tinline HashMap() : time(1) {}\n\n\tinline int hash(const Tk &k) {\n\t\treturn k % HASH_SIZE;\n\t}\n\n\tinline Node *locate(const Tk &k) {\n\t\tregister int i;\n\t\tfor (i = hash(k); N[i].time == time && N[i].p.first != k; (++i == HASH_SIZE) && (i = 0));\n\t\treturn &N[i];\n\t}\n\n\tinline iterator find(const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) return end();\n\t\treturn &v->p;\n\t}\n\n\tinline Tv &operator[](const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) {\n\t\t\tv->time = time, v->p.first = k, v->p.second = Tv();\n\t\t}\n\t\treturn v->p.second;\n\t}\n\n\tinline void clear() { time++; }\n\n\tinline iterator end() const { return NULL; }\n};\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint type, dfn, low;\n\tbool v, pushed, flag;\n\tint x, y;\n} N[MAXN], *p = N;\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tinline Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(Node *s, Node *t) {\n\ts->e = new Edge(s, t);\n}\n\nint n, m, c;\nstruct Point {\n\tint x, y;\n\n\tinline Point(const int x = 0, const int y = 0) : x(x), y(y) {}\n\n\tinline bool operator<(const Point &other) const {\n\t\treturn y < other.y;\n\t}\n} a[MAXN];\n\nHashMap<unsigned long long, Node *> map;\n\ninline Node *clear(Node *p) {\n\tfor (Edge *&e = p->e, *next; e; next = e->next, delete e, e = next);\n\tmemset(p, 0, sizeof(Node));\n\treturn p;\n}\n\n#ifdef DBG\nchar str[1000][1000];\n#endif\n\ninline void getNodes(const int x, const int y, const bool second = false) {\n\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(x + fx < 1 || x + fx > n || y + fy < 1 || y + fy > m)) {\n\t\tregister int nx = x + fx, ny = y + fy;\n\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx, ny));\n\t\tif (it == map.end() || it->second != NULL) {\n\t\t\tNode *v;\n\t\t\tif (it == map.end()) {\n\t\t\t\tv = map[HASH(nx, ny)] = clear(p++);\n\t\t\t\tv->x = nx, v->y = ny;\n\t\t\t} else v = it->second;\n\t\t\tv->type = 1;\n#ifdef DBG\n\t\t\tstr[v->x][v->y] = 'A';\n#endif\n\t\t\tif (second) for (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(nx + fx < 1 || nx + fx > n || ny + fy < 1 || ny + fy > m)) {\n\t\t\t\tregister int nx2 = nx + fx, ny2 = ny + fy;\n\t\t\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx2, ny2));\n\t\t\t\tif (it == map.end()) {\n\t\t\t\t\tclear(p);\n\t\t\t\t\tp->type = 2;\n\t\t\t\t\tp->x = nx2, p->y = ny2;\n#ifdef DBG\n\t\t\t\t\tstr[p->x][p->y] = 'B';\n#endif\n\t\t\t\t\tmap[HASH(nx2, ny2)] = p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void addEdges() {\n\t// for (HashMap<unsigned long long, Node *>::iterator it = map.begin(); it != map.end(); it++) if (it->second) {\n\tfor (Node *v = N; v != p; v++) {\n\t\tregister int &x = v->x, &y = v->y;\n\t\tfor (register int i = 0; i < 4; i++) if (!(x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m)) {\n\t\t\tregister int nx = x + dx[i], ny = y + dy[i];\n\t\t\tregister HashMap<unsigned long long, Node *>::iterator it2 = map.find(HASH(nx, ny));\n\t\t\tif (it2 != map.end() && it2->second) {\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d] -> [%d, %d]\\n\", v->x, v->y, it2->second->x, it2->second->y);\n#endif\n\t\t\t\taddEdge(v, it2->second);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int tarjan() {\n\tregister int ts = 0, cnt = 0;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\n\t\tstatic Node *s[MAXN];\n\t\tNode **top = s;\n\t\tstart->pushed = true;\n\t\t*top = start;\n\n\t\twhile (top != s - 1) {\n\t\t\tNode *v = *top;\n\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v && e->t != v->p) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) *++top = e->t, e->t->pushed = true, e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != start) for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t->low >= v->dfn) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v->flag && v->type == 1) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ttop--;\n\t\t\t}\n\t\t}\n\n\t\tint ch = 0;\n\t\tfor (Edge *e = start->e; e; e = e->next) if (e->t->p == start) ch++;\n\t\tstart->flag = ch >= 2;\n\t\tif (start->flag && start->type == 1) cnt++;\n\t}\n\n\treturn cnt;\n}\n\ninline bool isOne() {\n\tfor (register int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tmap[HASH(x, y)] = NULL;\n\t}\n\n\tp = N;\n\n\tfor (register int i = 0; i < c; i++) {\n\t\tgetNodes(a[i].x, a[i].y, true);\n\t}\n\n\taddEdges();\n\n\treturn tarjan() != 0;\n}\n\ninline bool bfsCount() {\n\tbool flag = false;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\t\tif (flag) return true;\n\t\tflag = true;\n\n\t\tstatic Node *q[MAXN];\n\t\tNode **l = q, **r = q;\n\t\tstart->v = true;\n\t\t*l = start;\n\n\t\twhile (l <= r) {\n\t\t\tNode *v = *l++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->v) {\n\t\t\t\te->t->v = true;\n\t\t\t\t*++r = e->t;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline bool isZero() {\n\tstatic HashMap<unsigned long long, bool> map2;\n\tmap2.clear();\n\tfor (register int i = 0; i < c; i++) {\n\t\tmap2[HASH(a[i].x, a[i].y)] = false;\n\t}\n\tbool ans = false;\n#ifdef DBG\n\tint id = 0;\n#endif\n\tfor (int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tregister bool &f = map2[HASH(x, y)];\n\t\tif (f) continue;\n\t\tf = true;\n\n#ifdef DBG\n\t\tid++;\n#endif\n\n\t\tstatic Point vec[MAXC];\n\t\tint cnt = 0;\n\n\t\tmap.clear();\n\t\tp = N;\n\n\t\tstatic Point q[MAXC];\n\t\tPoint *l = q, *r = q;\n\t\t*l = Point(x, y);\n\t\twhile (l <= r) {\n\t\t\tPoint p = *l++;\n\n#ifdef DBG\n\t\t\tstr[p.x][p.y] = id + '0';\n#endif\n\n\t\t\tmap[HASH(p.x, p.y)] = NULL;\n\t\t\tvec[cnt++] = p;\n\n\t\t\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(p.x + fx < 1 || p.x + fx > n || p.y + fy < 1 || p.y + fy > m)) {\n\t\t\t\tregister int nx = p.x + fx, ny = p.y + fy;\n\t\t\t\tHashMap<unsigned long long, bool>::iterator it = map2.find(HASH(nx, ny));\n\t\t\t\tif (it != map2.end() && it->second == false) {\n\t\t\t\t\tit->second = true;\n\t\t\t\t\t*++r = Point(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) getNodes(vec[i].x, vec[i].y);\n\t\taddEdges();\n\t\tif (bfsCount()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmap.clear();\n\treturn ans;\n}\n\ninline bool isInvalid() {\n\tconst unsigned long long r = static_cast<unsigned long long>(n) * m - c;\n\tif (r < 2) return true;\n\telse if (r == 2) {\n\t\tstatic bool flag[MAXC];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tflag[(a[i].x - 1) * m + a[i].y - 1] = true;\n\t\t}\n\n\t\tPoint pts[2];\n\t\tfor (int i = 0, cnt = 0; i < n; i++) for (int j = 0; j < m; j++) {\n\t\t\tif (!flag[i * m + j]) pts[cnt++] = Point(i, j);\n\t\t\tflag[i * m + j] = false;\n\t\t}\n\n\t\treturn abs(pts[0].x - pts[1].x) + abs(pts[0].y - pts[1].y) == 1;\n\t} else return false;\n}\n\ninline const char *special() {\n\tstd::sort(a, a + c);\n\tint last = 0, cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (a[i].y != last + 1) {\n\t\t\tcnt++;\n\t\t}\n\t\tlast = a[i].y;\n\t}\n\tif (last != m) cnt++;\n\treturn cnt == 1 ? \"1\" : \"0\";\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar_unlocked(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar_unlocked(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tint t;\n\tread(t);\n\twhile (t--) {\n\t\tread(n), read(m), read(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tread(a[i].x), read(a[i].y);\n\t\t\tif (n > m) std::swap(a[i].x, a[i].y);\n\t\t}\n\n\t\tif (n > m) std::swap(n, m);\n\n\t\tif (isInvalid()) puts(\"-1\");\n\t\telse if (n == 1) puts(special());\n\t\telse if (isZero()) puts(\"0\");\n\t\telse if (isOne()) puts(\"1\");\n\t\telse puts(\"2\");\n\n#ifdef DBG\n\t\tfor (Node *v = N; v != p; v++) {\n\t\t\tprintf(\"[%d, %d] => %d\\n\", v->x, v->y, v->type);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tHashMap<unsigned long long, Node *>::iterator it = map.find(HASH(i, j));\n\t\t\t\tif (it == map.end()) putchar('-');\n\t\t\t\telse if (!it->second) putchar('X');\n\t\t\t\telse putchar('0' + it->second->type);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tputchar(str[i][j] ? str[i][j] : '-');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n#endif\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2016-grid","published":1,"updated":"2016-09-11T23:54:29.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnz00prooxl7q1qk4o8"},{"title":"「NOI2016」优秀的拆分 - Hash","date":"2016-09-05T23:34:00.000Z","_content":"\n如果一个字符串可以被拆分为 `AABB` 的形式，其中 $ A $ 和 $ B $ 是任意非空字符串，则我们称该字符串的这种拆分是优秀的。\n\n例如，对于字符串 `aabaabaa`，如果令 $ A = \\texttt{aab}, B = \\texttt{a} $，我们就找到了这个字符串拆分成 `AABB` 的一种方式。\n\n一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。比如我们令 $ A = \\texttt{a}, B = \\texttt{baa} $，也可以用 `AABB` 表示出上述字符串；但是，字符串 `abaabaa` 就没有优秀的拆分。\n\n现在给出一个长度为 $ n $ 的字符串 $ S $，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。\n\n<!-- more -->\n\n### 题解\n[点我去看题解](https://blog.sengxian.com/solutions/bzoj-4650)\n\n### 代码\nHash T 飞了 ……\n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\ntypedef unsigned __int128 hash1_t;\n\nconst int MAXN = 30000;\nconst hash1_t BASE1 = 233;\n// const hash2_t BASE2 = 233;\n// const hash3_t BASE3 = 53;\n\nchar s[MAXN];\nint n;\nlong long forward[MAXN + 1], backward[MAXN + 1];\n\nhash1_t hash1[MAXN], base1[MAXN + 1];\n// hash2_t hash2[MAXN], base2[MAXN + 1];\n// hash3_t hash3[MAXN], base3[MAXN + 1];\n\ninline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) {\n\treturn hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len];\n\t\t// && hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len]\n\t\t// && hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len];\n\t// register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len];\n\t// register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len];\n\t// const bool res = h1 == h2;\n\t// assert(res == (memcmp(&s[a], &s[b], len) == 0));\n\t// return h1 == h2;\n\t// return memcmp(&s[a], &s[b], len) == 0;\n}\n\ninline __attribute__((always_inline)) int lcp(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = n - b;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a, b, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\ninline __attribute__((always_inline)) int lcs(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = a + 1;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a - m + 1, b - m + 1, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\t// base1[0] = base2[0] = base3[0] = 1;\n\tbase1[0] = 1;\n\t// for (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE % MOD;\n\tfor (register int i = 1; i <= MAXN; i++) {\n\t\tbase1[i] = base1[i - 1] * BASE1;\n\t\t// base2[i] = base2[i - 1] * BASE2;\n\t\t// base3[i] = base3[i - 1] * BASE3;\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tfor (register int i = 0; i < n; i++) s[i] -= 'a' - 1;\n\n\t\t// hash1[0] = hash2[0] = hash3[0] = s[0];\n\t\thash1[0] = s[0];\n\t\t// for (int i = 1; i < n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD;\n\t\tfor (register int i = 1; i < n; i++) {\n\t\t\thash1[i] = (hash1[i - 1] * BASE1 + s[i]);\n\t\t\t// hash2[i] = (hash2[i - 1] * BASE2 + s[i]);\n\t\t\t// hash3[i] = (hash3[i - 1] * BASE3 + s[i]);\n\t\t}\n\n\t\tfor (register int k = 1; k <= n / 2; k++) {\n\t\t\t// printf(\"k = %d\\n\", k);\n\t\t\tfor (register int i = 0; i < n; i += k) {\n\t\t\t\tconst register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k);\n\t\t\t\t// printf(\"lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\\n\", i, i + k, a, i, i + k, b);\n\t\t\t\tif (a + b >= k) {\n\t\t\t\t\tregister int l, r;\n\t\t\t\t\tl = i + k + k - a - 1, r = l + (a + b - k);\n\t\t\t\t\t// l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1);\n\t\t\t\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\t\t\t\t// for (int i = l; i <= r; i++) backward[i]++;\n\t\t\t\t\tbackward[l]++, backward[r + 1]--;\n\t\t\t\t\tr = r - 2 * k + 1, l = l - 2 * k + 1;\n\t\t\t\t\t// for (int i = l; i <= r; i++) forward[i]++;\n\t\t\t\t\tforward[l]++, forward[r + 1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (register int i = 1; i < n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1];\n\n\t\tregister long long ans = 0;\n\t\tfor (register int i = 1; i < n; i++) ans += backward[i - 1] * forward[i];\n\n\t\tfor (register int i = 0; i < n; i++) {\n\t\t\thash1[i] = 0;\n\t\t\t// hash2[i] = 0;\n\t\t\t// hash3[i] = 0;\n\t\t\tbackward[i] = forward[i] = 0;\n\t\t}\n\t\tforward[n] = backward[n] = 0;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2016-excellent.md","raw":"title: 「NOI2016」优秀的拆分 - Hash\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - 字符串\n  - Hash\npermalink: noi2016-excellent\ndate: 2016-09-06 07:34:00\n---\n\n如果一个字符串可以被拆分为 `AABB` 的形式，其中 $ A $ 和 $ B $ 是任意非空字符串，则我们称该字符串的这种拆分是优秀的。\n\n例如，对于字符串 `aabaabaa`，如果令 $ A = \\texttt{aab}, B = \\texttt{a} $，我们就找到了这个字符串拆分成 `AABB` 的一种方式。\n\n一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。比如我们令 $ A = \\texttt{a}, B = \\texttt{baa} $，也可以用 `AABB` 表示出上述字符串；但是，字符串 `abaabaa` 就没有优秀的拆分。\n\n现在给出一个长度为 $ n $ 的字符串 $ S $，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。\n\n<!-- more -->\n\n### 题解\n[点我去看题解](https://blog.sengxian.com/solutions/bzoj-4650)\n\n### 代码\nHash T 飞了 ……\n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\ntypedef unsigned __int128 hash1_t;\n\nconst int MAXN = 30000;\nconst hash1_t BASE1 = 233;\n// const hash2_t BASE2 = 233;\n// const hash3_t BASE3 = 53;\n\nchar s[MAXN];\nint n;\nlong long forward[MAXN + 1], backward[MAXN + 1];\n\nhash1_t hash1[MAXN], base1[MAXN + 1];\n// hash2_t hash2[MAXN], base2[MAXN + 1];\n// hash3_t hash3[MAXN], base3[MAXN + 1];\n\ninline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) {\n\treturn hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len];\n\t\t// && hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len]\n\t\t// && hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len];\n\t// register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len];\n\t// register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len];\n\t// const bool res = h1 == h2;\n\t// assert(res == (memcmp(&s[a], &s[b], len) == 0));\n\t// return h1 == h2;\n\t// return memcmp(&s[a], &s[b], len) == 0;\n}\n\ninline __attribute__((always_inline)) int lcp(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = n - b;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a, b, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\ninline __attribute__((always_inline)) int lcs(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = a + 1;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a - m + 1, b - m + 1, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\t// base1[0] = base2[0] = base3[0] = 1;\n\tbase1[0] = 1;\n\t// for (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE % MOD;\n\tfor (register int i = 1; i <= MAXN; i++) {\n\t\tbase1[i] = base1[i - 1] * BASE1;\n\t\t// base2[i] = base2[i - 1] * BASE2;\n\t\t// base3[i] = base3[i - 1] * BASE3;\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tfor (register int i = 0; i < n; i++) s[i] -= 'a' - 1;\n\n\t\t// hash1[0] = hash2[0] = hash3[0] = s[0];\n\t\thash1[0] = s[0];\n\t\t// for (int i = 1; i < n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD;\n\t\tfor (register int i = 1; i < n; i++) {\n\t\t\thash1[i] = (hash1[i - 1] * BASE1 + s[i]);\n\t\t\t// hash2[i] = (hash2[i - 1] * BASE2 + s[i]);\n\t\t\t// hash3[i] = (hash3[i - 1] * BASE3 + s[i]);\n\t\t}\n\n\t\tfor (register int k = 1; k <= n / 2; k++) {\n\t\t\t// printf(\"k = %d\\n\", k);\n\t\t\tfor (register int i = 0; i < n; i += k) {\n\t\t\t\tconst register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k);\n\t\t\t\t// printf(\"lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\\n\", i, i + k, a, i, i + k, b);\n\t\t\t\tif (a + b >= k) {\n\t\t\t\t\tregister int l, r;\n\t\t\t\t\tl = i + k + k - a - 1, r = l + (a + b - k);\n\t\t\t\t\t// l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1);\n\t\t\t\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\t\t\t\t// for (int i = l; i <= r; i++) backward[i]++;\n\t\t\t\t\tbackward[l]++, backward[r + 1]--;\n\t\t\t\t\tr = r - 2 * k + 1, l = l - 2 * k + 1;\n\t\t\t\t\t// for (int i = l; i <= r; i++) forward[i]++;\n\t\t\t\t\tforward[l]++, forward[r + 1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (register int i = 1; i < n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1];\n\n\t\tregister long long ans = 0;\n\t\tfor (register int i = 1; i < n; i++) ans += backward[i - 1] * forward[i];\n\n\t\tfor (register int i = 0; i < n; i++) {\n\t\t\thash1[i] = 0;\n\t\t\t// hash2[i] = 0;\n\t\t\t// hash3[i] = 0;\n\t\t\tbackward[i] = forward[i] = 0;\n\t\t}\n\t\tforward[n] = backward[n] = 0;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2016-excellent","published":1,"updated":"2016-09-05T23:42:03.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ro300pyooxlz2chxlgs"},{"title":"「NOI2015」品酒大会 - 后缀数组 + 并查集","date":"2016-06-26T10:14:00.000Z","_content":"\n给定字符串 $ S $ 和序列 $ f(i) $，对于 $ r \\in [0,\\ n - 1] $，求：\n\n1. 满足 $ \\mathrm {LCP}(\\mathrm{suffix}(i),\\ \\mathrm{suffix}(j)) \\geq r $ 的无序二元组 $ (i,\\ j) $ 数量；\n2. 上述二元组 $ (i, j) $ 使 $ f(i) \\times f(j) $ 取得的最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4199](http://www.lydsy.com/JudgeOnline/problem.php?id=4199)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### 题解\n使用后缀数组求出排名相邻后缀的 LCP，打出表，可以发现如果连续的一段后缀的相邻 LCP 长度都 $ \\geq r $，那么这其中任意两个后缀都是**第一问**的一组解。进而得出，一个大小为 $ x $ 的块对答案的贡献为 $ \\frac{x (x + 1)}{2} $。\n\n对于第二问，每个块内两个 $ f(i) $ 值最大（或最小，因为有负数）的对应 $ f(i) $ 值乘积对答案有贡献。\n\n使用带权并查集维护每个块的大小、最大值、次大值、最小值、次小值。\n\n考虑到 $ r $ 较大时答案较小，且 $ r $ 减小时答案可累加。从大到小枚举 $ \\mathrm{height}(i) $，每次判断当前后缀可否和前一个或后一个后缀所在块合并（可以合并的条件是对应的后缀的 $ \\mathrm{height} $ 值大于等于当前后缀），并统计答案。注意，**连续两次被前后合并同一个块可能导致答案被统计多次**。\n\n两问都需要 `long long`。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 300000;\n\nchar s[MAXN + 1];\nint a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\t\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%3d %2d %s\\n\", ::a[sa[i]], ht[i], &s[sa[i]]);\n\tputs(\"----------------\");\n#endif\n}\n\nstruct UnionFindSet {\n\tint f[MAXN], size[MAXN];\n\tint max[MAXN], max2[MAXN], min[MAXN], min2[MAXN];\n#ifdef DBG\n\tbool invalid[MAXN];\n\tint top[MAXN], bottom[MAXN];\n#endif\n\n\tvoid init() {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ti[f] = i;\n\t\t\ti[size] = 1;\n\t\t\tif (A[i] > A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1;\n\t\t\telse i[max] = i[min2] = i - 1, i[min] = i[max2] = i;\n#ifdef DBG\n\t\t\ti[top] = i[bottom] = i;\n\t\t\ti[invalid] = false;\n#endif\n\t\t}\n\t}\n\n\ttemplate <typename T>\n\tvoid updateMinMax(int &m, int &m2, const int x, T compare) {\n\t\tif (compare(A[x], A[m])) m2 = m, m = x;\n\t\telse if (x != m && compare(A[x], A[m2])) m2 = x;\n\t}\n\n\tvoid addTo(const int a, const int b) {\n#ifdef DBG\n\t\ta[invalid] = true;\n\t\tb[top] = std::min(b[top], a[top]);\n\t\tb[bottom] = std::max(b[bottom], a[bottom]);\n#endif\n\t\tb[size] = a[size] + b[size];\n\t\ta[size] = 0;\n\n\t\tupdateMinMax(b[max], b[max2], a[max], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[max2], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min2], std::greater<int>());\n\n\t\tupdateMinMax(b[min], b[min2], a[min], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[min2], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max2], std::less<int>());\n\t}\n\n\tint find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) {\n\t\tint res = x;\n\t\twhile (res[f] != res) res = res[f];\n\t\tfor (int i = x, tmp; i != res; ) {\n\t\t\ttmp = i[f];\n\t\t\taddTo(i, res);\n\t\t\ti[f] = res;\n\t\t\ti = tmp;\n\t\t}\n\n\t\tif (size) *size = this->size[res];\n\t\tif (max) *max = A[this->max[res]];\n\t\tif (max2) *max2 = A[this->max2[res]];\n\t\tif (min) *min = A[this->min[res]];\n\t\tif (min2) *min2 = A[this->min2[res]];\n\n\t\treturn res;\n\t}\n\n\tbool test(const int a, const int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(const int a, const int b) {\n\t\t// printf(\"merge(%d, %d)\\n\", a, b);\n\t\tint x = find(a), y = find(b);\n\t\t// printf(\"-- merge(%d, %d)\\n\", x, y);\n\t\tassert(x != y);\n\t\taddTo(x, y);\n\t\tx[f] = y;\n\t}\n\n#ifdef DBG\n\tvoid print() {\n\t\tfor (int i = 1; i < n; i++) find(i);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (invalid[i]) continue;\n\t\t\tprintf(\"[%d]: \", i);\n\t\t\tif (f[i] == i) printf(\"root, \");\n\t\t\telse printf(\"f = %d, \", f[i]);\n\n\t\t\tprintf(\"[%d, %d], size = %d, max = [%d] -> %d, max2 = [%d] -> %d, min = [%d] -> %d, min2 = [%d] -> %d\\n\", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]);\n\t\t}\n\t}\n#endif\n} ufs;\n\ninline long long calcCnt(const int x) {\n\tint size;\n\tufs.find(x, &size);\n\tlong long cnt = static_cast<long long>(size) * (size + 1) / 2;\n\t// printf(\"cnt(%d) = %d\\n\", x, cnt);\n\treturn cnt;\n}\n\ninline long long calcMax(const int x) {\n\tint max, max2, min, min2;\n\tufs.find(x, NULL, &max, &max2, &min, &min2);\n\treturn std::max(static_cast<long long>(max) * max2, static_cast<long long>(min) * min2);\n}\n\nint main() {\n\tscanf(\"%d\\n%s\", &n, s);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) A[i] = a[sa[i]];\n\n\tufs.init();\n\n\tstd::vector<int> v[MAXN];\n\tfor (int i = 1; i < n; i++) v[ht[i]].push_back(i);\n\n\tlong long cnt = 0, max = LLONG_MIN;\n\tstd::stack< std::pair<long long, long long> > stack;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t// printf(\"ht[%d] = %d\\n\", *it, ht[*it]);\n\n\t\t\tif (!(it != v[i].end() - 1 && ufs.test(*(it + 1), *it + 1))) {\n\t\t\t\tif (*it != n - 1) {\n\t\t\t\t\tif (ht[*it + 1] >= ht[*it] && !ufs.test(*it + 1, *it)) {\n\t\t\t\t\t\t// puts(\"------- + 1\");\n\t\t\t\t\t\tcnt -= calcCnt(*it + 1);\n\t\t\t\t\t\tufs.merge(*it, *it + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*it != 1 && ht[*it - 1] >= ht[*it] && !ufs.test(*it - 1, *it)) {\n\t\t\t\t// puts(\"------- - 1\");\n\t\t\t\tcnt -= calcCnt(*it - 1);\n\t\t\t\tufs.merge(*it, *it - 1);\n\t\t\t}\n\n\t\t\t// puts(\"+++++++\");\n\t\t\tcnt += calcCnt(*it);\n\t\t\tmax = std::max(max, calcMax(*it));\n#ifdef DBG\n\t\t\tprintf(\"calcMax(%d) = %lld\\n\", *it, calcMax(*it));\n#endif\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", cnt, max == LLONG_MIN ? 0 : max);\n\t\tif (cnt != 0) ufs.print();\n#else\n\t\tstack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max));\n#endif\n\t}\n\n#ifndef DBG\n\twhile (!stack.empty()) {\n\t\tprintf(\"%lld %lld\\n\", stack.top().first, stack.top().second);\n\t\tstack.pop();\n\t}\n#endif\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-savour.md","raw":"title: 「NOI2015」品酒大会 - 后缀数组 + 并查集\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - 后缀数组\n  - 并查集\n  - 字符串\npermalink: noi2015-savour\ndate: 2016-06-26 18:14:00\n---\n\n给定字符串 $ S $ 和序列 $ f(i) $，对于 $ r \\in [0,\\ n - 1] $，求：\n\n1. 满足 $ \\mathrm {LCP}(\\mathrm{suffix}(i),\\ \\mathrm{suffix}(j)) \\geq r $ 的无序二元组 $ (i,\\ j) $ 数量；\n2. 上述二元组 $ (i, j) $ 使 $ f(i) \\times f(j) $ 取得的最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4199](http://www.lydsy.com/JudgeOnline/problem.php?id=4199)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### 题解\n使用后缀数组求出排名相邻后缀的 LCP，打出表，可以发现如果连续的一段后缀的相邻 LCP 长度都 $ \\geq r $，那么这其中任意两个后缀都是**第一问**的一组解。进而得出，一个大小为 $ x $ 的块对答案的贡献为 $ \\frac{x (x + 1)}{2} $。\n\n对于第二问，每个块内两个 $ f(i) $ 值最大（或最小，因为有负数）的对应 $ f(i) $ 值乘积对答案有贡献。\n\n使用带权并查集维护每个块的大小、最大值、次大值、最小值、次小值。\n\n考虑到 $ r $ 较大时答案较小，且 $ r $ 减小时答案可累加。从大到小枚举 $ \\mathrm{height}(i) $，每次判断当前后缀可否和前一个或后一个后缀所在块合并（可以合并的条件是对应的后缀的 $ \\mathrm{height} $ 值大于等于当前后缀），并统计答案。注意，**连续两次被前后合并同一个块可能导致答案被统计多次**。\n\n两问都需要 `long long`。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 300000;\n\nchar s[MAXN + 1];\nint a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\t\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%3d %2d %s\\n\", ::a[sa[i]], ht[i], &s[sa[i]]);\n\tputs(\"----------------\");\n#endif\n}\n\nstruct UnionFindSet {\n\tint f[MAXN], size[MAXN];\n\tint max[MAXN], max2[MAXN], min[MAXN], min2[MAXN];\n#ifdef DBG\n\tbool invalid[MAXN];\n\tint top[MAXN], bottom[MAXN];\n#endif\n\n\tvoid init() {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ti[f] = i;\n\t\t\ti[size] = 1;\n\t\t\tif (A[i] > A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1;\n\t\t\telse i[max] = i[min2] = i - 1, i[min] = i[max2] = i;\n#ifdef DBG\n\t\t\ti[top] = i[bottom] = i;\n\t\t\ti[invalid] = false;\n#endif\n\t\t}\n\t}\n\n\ttemplate <typename T>\n\tvoid updateMinMax(int &m, int &m2, const int x, T compare) {\n\t\tif (compare(A[x], A[m])) m2 = m, m = x;\n\t\telse if (x != m && compare(A[x], A[m2])) m2 = x;\n\t}\n\n\tvoid addTo(const int a, const int b) {\n#ifdef DBG\n\t\ta[invalid] = true;\n\t\tb[top] = std::min(b[top], a[top]);\n\t\tb[bottom] = std::max(b[bottom], a[bottom]);\n#endif\n\t\tb[size] = a[size] + b[size];\n\t\ta[size] = 0;\n\n\t\tupdateMinMax(b[max], b[max2], a[max], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[max2], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min2], std::greater<int>());\n\n\t\tupdateMinMax(b[min], b[min2], a[min], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[min2], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max2], std::less<int>());\n\t}\n\n\tint find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) {\n\t\tint res = x;\n\t\twhile (res[f] != res) res = res[f];\n\t\tfor (int i = x, tmp; i != res; ) {\n\t\t\ttmp = i[f];\n\t\t\taddTo(i, res);\n\t\t\ti[f] = res;\n\t\t\ti = tmp;\n\t\t}\n\n\t\tif (size) *size = this->size[res];\n\t\tif (max) *max = A[this->max[res]];\n\t\tif (max2) *max2 = A[this->max2[res]];\n\t\tif (min) *min = A[this->min[res]];\n\t\tif (min2) *min2 = A[this->min2[res]];\n\n\t\treturn res;\n\t}\n\n\tbool test(const int a, const int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(const int a, const int b) {\n\t\t// printf(\"merge(%d, %d)\\n\", a, b);\n\t\tint x = find(a), y = find(b);\n\t\t// printf(\"-- merge(%d, %d)\\n\", x, y);\n\t\tassert(x != y);\n\t\taddTo(x, y);\n\t\tx[f] = y;\n\t}\n\n#ifdef DBG\n\tvoid print() {\n\t\tfor (int i = 1; i < n; i++) find(i);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (invalid[i]) continue;\n\t\t\tprintf(\"[%d]: \", i);\n\t\t\tif (f[i] == i) printf(\"root, \");\n\t\t\telse printf(\"f = %d, \", f[i]);\n\n\t\t\tprintf(\"[%d, %d], size = %d, max = [%d] -> %d, max2 = [%d] -> %d, min = [%d] -> %d, min2 = [%d] -> %d\\n\", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]);\n\t\t}\n\t}\n#endif\n} ufs;\n\ninline long long calcCnt(const int x) {\n\tint size;\n\tufs.find(x, &size);\n\tlong long cnt = static_cast<long long>(size) * (size + 1) / 2;\n\t// printf(\"cnt(%d) = %d\\n\", x, cnt);\n\treturn cnt;\n}\n\ninline long long calcMax(const int x) {\n\tint max, max2, min, min2;\n\tufs.find(x, NULL, &max, &max2, &min, &min2);\n\treturn std::max(static_cast<long long>(max) * max2, static_cast<long long>(min) * min2);\n}\n\nint main() {\n\tscanf(\"%d\\n%s\", &n, s);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) A[i] = a[sa[i]];\n\n\tufs.init();\n\n\tstd::vector<int> v[MAXN];\n\tfor (int i = 1; i < n; i++) v[ht[i]].push_back(i);\n\n\tlong long cnt = 0, max = LLONG_MIN;\n\tstd::stack< std::pair<long long, long long> > stack;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t// printf(\"ht[%d] = %d\\n\", *it, ht[*it]);\n\n\t\t\tif (!(it != v[i].end() - 1 && ufs.test(*(it + 1), *it + 1))) {\n\t\t\t\tif (*it != n - 1) {\n\t\t\t\t\tif (ht[*it + 1] >= ht[*it] && !ufs.test(*it + 1, *it)) {\n\t\t\t\t\t\t// puts(\"------- + 1\");\n\t\t\t\t\t\tcnt -= calcCnt(*it + 1);\n\t\t\t\t\t\tufs.merge(*it, *it + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*it != 1 && ht[*it - 1] >= ht[*it] && !ufs.test(*it - 1, *it)) {\n\t\t\t\t// puts(\"------- - 1\");\n\t\t\t\tcnt -= calcCnt(*it - 1);\n\t\t\t\tufs.merge(*it, *it - 1);\n\t\t\t}\n\n\t\t\t// puts(\"+++++++\");\n\t\t\tcnt += calcCnt(*it);\n\t\t\tmax = std::max(max, calcMax(*it));\n#ifdef DBG\n\t\t\tprintf(\"calcMax(%d) = %lld\\n\", *it, calcMax(*it));\n#endif\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", cnt, max == LLONG_MIN ? 0 : max);\n\t\tif (cnt != 0) ufs.print();\n#else\n\t\tstack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max));\n#endif\n\t}\n\n#ifndef DBG\n\twhile (!stack.empty()) {\n\t\tprintf(\"%lld %lld\\n\", stack.top().first, stack.top().second);\n\t\tstack.pop();\n\t}\n#endif\n\n\treturn 0;\n}\n```\n","slug":"noi2015-savour","published":1,"updated":"2016-07-01T01:28:39.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ro700q4ooxl1wfasfhv"},{"title":"「NOI2015」程序自动分析 - 离散化 + 并查集","id":"34","updated":"2016-01-21T13:36:13.000Z","date":"2016-01-21T13:32:49.000Z","_content":"\n给定 `n` 个形如$x_i=x_j$或$x_i≠x_j$的变量相等 / 不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### 题解\n首先，`x` 的值很大，我们要把它离散化掉。\n\n然后用一个并查集，要离线做，先把相等的都并掉，然后枚举所有不相等的，如果某一对被并了说明不成立。\n\n### 代码\n#### 手写哈希表\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-prog.md","raw":"title: 「NOI2015」程序自动分析 - 离散化 + 并查集\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - 离散化\n  - 并查集\n  - 哈希\n  - map\npermalink: noi2015-prog\nid: 34\nupdated: '2016-01-21 21:36:13'\ndate: 2016-01-21 21:32:49\n---\n\n给定 `n` 个形如$x_i=x_j$或$x_i≠x_j$的变量相等 / 不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### 题解\n首先，`x` 的值很大，我们要把它离散化掉。\n\n然后用一个并查集，要离线做，先把相等的都并掉，然后枚举所有不相等的，如果某一对被并了说明不成立。\n\n### 代码\n#### 手写哈希表\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2015-prog","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rob00qbooxle38fb1mx"},{"title":"「NOI2015」软件包管理器 - 树链剖分","id":"35","updated":"2016-01-29T00:22:32.000Z","date":"2016-01-23T02:10:12.000Z","_content":"\n你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环，当然也不会有一个软件包依赖自己。用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### 题解\n首先，两种操作抽象为树上询问与修改：\n\n1. 询问某节点到根的一条链上有多少个节点打了标记；\n2. 将某节点到根的一条链上所有节点打上标记；\n3. 询问某节点的整棵子树上有多少个节点打了标记；\n4. 将某节点的整棵子树上所有节点打上标记。\n\n对于前两种，普通的树链剖分就可以了，但是对于后两种，我们还需要维护一个 DFS 序。DFS 序和轻重路径划分的维护看起来是有冲突的，实际上只要按照 DFS 的方式连接路径，并且在 DFS 时先遍历重链连接的子树，同时记录 DFS 序，这样得到的 DFS 序中，同一条路径是连续的，同一棵子树也是连续的。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2015-manager.md","raw":"title: 「NOI2015」软件包管理器 - 树链剖分\ncategories: OI\ntags: \n  - NOI\n  - CodeVS\n  - BZOJ\n  - 树链剖分\n  - 数据结构\n  - 高级数据结构\npermalink: noi2015-manager\nid: 35\nupdated: '2016-01-29 08:22:32'\ndate: 2016-01-23 10:10:12\n---\n\n你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环，当然也不会有一个软件包依赖自己。用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### 题解\n首先，两种操作抽象为树上询问与修改：\n\n1. 询问某节点到根的一条链上有多少个节点打了标记；\n2. 将某节点到根的一条链上所有节点打上标记；\n3. 询问某节点的整棵子树上有多少个节点打了标记；\n4. 将某节点的整棵子树上所有节点打上标记。\n\n对于前两种，普通的树链剖分就可以了，但是对于后两种，我们还需要维护一个 DFS 序。DFS 序和轻重路径划分的维护看起来是有冲突的，实际上只要按照 DFS 的方式连接路径，并且在 DFS 时先遍历重链连接的子树，同时记录 DFS 序，这样得到的 DFS 序中，同一条路径是连续的，同一棵子树也是连续的。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2015-manager","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9roi00qnooxl0d6iws72"},{"title":"「NOI2015」小园丁与老司机 - DP + 上下界网络流","date":"2016-06-29T10:33:00.000Z","_content":"\n在坐标系的第一象限内有 $ n $ 个点。\n\n1. 从原点开始，每次向左、右、上、左上 $ 45 ^ \\circ $、右上 $ 45 ^ \\circ $ **任意一个方向**走到**第一个未到过**的点，重复这个过程，求最多能经过多少点；\n2. 求 (1) 中的一个最优方案；\n3. 对于 (1) 中的**所有**最优方案，其所有上、左上 $ 45 ^ \\circ $、右上 $ 45 ^ \\circ $ 的边组成了一个 DAG，求该 DAG 的可重叠最小路径覆盖。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4200](http://www.lydsy.com/JudgeOnline/problem.php?id=4200)  \n[UOJ #132](http://uoj.ac/problem/132)\n\n### 题解\n#### 第一问\n我们可以发现，对于两个点 $ (x_1, y_1) $ 和 $ (x_2, y_2) $，如果 $ y_1 = y_2 $，则它们在同一行，如果 $ x_1 + y_1 = x_2 + y_2 $ 或 $ x_1 - y_1 = x_2 - y_2 $，说明它们在同一对角线上。\n\n记录每一行、每一主对角线、每一副对角线上的点，并进行排序，处理行之间的转移时，可以直接由这些方向上前一个点转移而来。\n\n显而易见的两个结论：\n\n1. 除最后一行外，同一行的若干次移动完成后，一定继续移动到上面的某一行上；\n2. 每一行内，任意两个点都可以通过左右移动到达。\n\n这为我们提供了一个计算顺序 —— 对于每一行，先计算出每个点向上移动的最多步数，再计算同一行以每个点开始到另一个点最多移动的步数，取最大值。\n\n但是，这样做时间复杂度太高，需要优化。考虑到对于同一行的两个点 $ a $、$ b $（$ a $ 在 $ b $ 左侧），从 $ a $ 到达 $ b $ 的最优方案为：先从 $ a $ 经过若干个点移动到一行中的最左端点，然后移动到 $ a $ 右边最近的点，继续向右移动到 $ b $。\n\n打出从 $ a $ 到达 $ b $ 的最多步数表可以发现，当 $ a $ 增大 $ 1 $ 时，到所有 $ b $ 的步数，只有两个会改变：\n\n|   | 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 5 | 0 | 1 | 2 | 3 | 4 |\n| 5 | 4 | 0 | 2 | 3 | 4 |\n| 5 | 4 | 3 | 0 | 3 | 4 |\n| 5 | 4 | 3 | 2 | 0 | 4 |\n| 5 | 4 | 3 | 2 | 1 | 0 |\n\n使用线段树维护当前点到 $ b $ 的步数加 $ b $ 向上走的最大步数，可以在 $ O(\\log n) $ 的时间内求出每个点的结果。\n\n算上排序，第一问的总时间复杂度为 $ O(n \\log n) $。\n\n#### 第二问\n要求出一种方案，我们可以在第一问的转移中记录每个状态的前驱。不同行间的转移可以直接找到前驱，同一行内的转移需要找到行内的目标点后，模拟出走到行首（行尾）后走回目标点的过程。\n\n一个细节是如何判断应该向上走还是走同一行。如果上一次走了同一行到达当前点，那么这一次一定向上走，否则可能会死循环。\n\n#### 第三问\n要求出所有方案中可能的上、左上、右上的边。\n\n从源点的一行开始向上考虑。对于每一行，枚举所有从下面转移过来的点，在与第一问相同的线段树上为所有最大值的点打标记，枚举完一整行后，取出所有被打标记的点，并以这些点开始向上继续考虑。枚举三个方向，对于可以取得最大值的方向，在网络上连一条流量下界为 $ 1 $，上界为 $ +\\infty $ 的边，并对这些方向上的目标点打上标记。\n\n最终，网络的最小可行流为第三问答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <tr1/functional>\n\nconst int MAXN = 50000 + 1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, in;\n} N[MAXN + 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f;\n\t\t\t\te->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"dinic(%d, %d, %d) = %d\\n\", s, t, n, res);\n#endif\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n#ifdef DBG\n\tprintf(\"E(%d, %d, %d)\\n\", s, t, c);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void addEdge(const int s, const int t, const int l, const int r) {\n\tN[s].in -= l;\n\tN[t].in += l;\n\taddEdge(s, t, r - l);\n}\n\ninline int minFlow(const int s, const int t, const int n) {\n\tconst int S = n, T = n + 1;\n\tint full = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].in > 0) addEdge(S, i, N[i].in), full += N[i].in;\n\t\telse if (N[i].in < 0) addEdge(i, T, -N[i].in);\n\t}\n\tEdge *e = addEdge(t, s, INT_MAX);\n\n\tassert(dinic(S, T, n + 2) == full);\n\n\tint f = e->f;\n\n\te->c = e->r->c = 0;\n\tfor (e = N[s].e; e; e = e->next) e->c = e->r->c = 0;\n\tfor (e = N[t].e; e; e = e->next) e->c = e->r->c = 0;\n\n\treturn f - dinic(t, s, n);\n}\n\nstruct DPValue;\nstruct Point;\n\nstruct DPValue {\n\tPoint *prec;\n\tint x;\n\n\tDPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {}\n\n\tDPValue extend(Point &p, const int delta) { return DPValue(&p, x + delta); }\n\n\toperator int() const { return x; }\n};\n\nstruct Point {\n\tint id, x, y, lineIndex;\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator itX, itDiagonal1, itDiagonal2;\n\tDPValue dpUp, dpInline;\n\tbool flagUp, flagInline;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorY() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorX() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal1() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal2() const;\n};\n\nbool compareByY(const Point &a, const Point &b) { return a.y > b.y; }\nbool compareByX(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal1(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal2(const Point &a, const Point &b) { return a.x < b.x; }\n\nint n, lineCnt;\nPoint a[MAXN];\nstd::vector< std::tr1::reference_wrapper<Point> > lines[MAXN];\nstd::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > > mapX, mapDiagonal1, mapDiagonal2;\n\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorY() const { return lines[lineIndex]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorX() const { return mapX[x]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; }\n\ninline void dpUp(const int lineIndex) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = v.begin(); it != v.end(); it++) {\n\t\tPoint &p = it->get();\n\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\tif (p.itX != p.getVectorX().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itX - 1)->get().dpInline.extend((p.itX - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)->get().dpInline.extend((p.itDiagonal1 - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)->get().dpInline.extend((p.itDiagonal2 - 1)->get(), 1));\n\t\t}\n\t}\n}\n\ninline void dpInline(const int lineIndex) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\n\tsegment = SegmentTree::build(0, v.size() - 1);\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), i));\n\t}\n\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i].get().dpInline = segment->query();\n\t\tif (i < v.size() - 1) {\n\t\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1));\n\t\t\tsegment->update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0));\n\t\t}\n\t}\n\n\tdelete segment;\n}\n\ninline void dp() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != 0) dpUp(i);\n\t\tdpInline(i);\n\t}\n}\n\ninline void getInlinePath(std::vector<Point *> &v, Point *s, Point *t) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &line = s->getVectorY();\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator a = std::lower_bound(line.begin(), line.end(), *s, &compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &compareByX);\n\n\tassert(&a->get() == s);\n\tassert(&b->get() == t);\n\n#ifdef DBG\n\tprintf(\"getInlinePath(%d(%d, %d), %d(%d, %d))\\n\", s->id, s->x, s->y, t->id, t->x, t->y);\n#endif\n\n\tif (a < b) {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= line.begin(); it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it <= b; it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t} else {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it != line.end(); it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= b; it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t}\n}\n\ninline void getPath(std::vector<Point *> &v) {\n\tPoint *p = &a[n - 1];\n\tbool flag = false;\n\twhile (p->dpUp.x || (!flag && p->dpInline.x && p->dpInline.prec != p)) {\n\t\tif (flag || p->dpInline.prec == p || p->dpInline.x <= p->dpUp.x) {\n#ifdef DBG\n\t\t\tprintf(\"%d(%d, %d) -> %d(%d, %d)\\n\", p->id, p->x, p->y, p->dpUp.prec->id, p->dpUp.prec->x, p->dpUp.prec->y);\n#endif\n\t\t\tp = p->dpUp.prec;\n\t\t\tv.push_back(p);\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tgetInlinePath(v, p, p->dpInline.prec);\n\t\t\tp = p->dpInline.prec;\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\ninline void getEdges(std::vector< std::pair<Point *, Point *> > &E) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\t\tbool flag;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (flag) pushDown();\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (flag) {\n\t\t\t\tif (lc || rc) {\n\t\t\t\t\tif (val.x == lc->val.x) lc->flag = true;\n\t\t\t\t\tif (val.x == rc->val.x) rc->flag = true;\n\t\t\t\t} else {\n\t\t\t\t\tval.prec->flagInline = true;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tpushDown();\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tvoid mark() { flag = true; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\ta[n - 1].flagUp = true;\n\n\tfor (int i = lineCnt - 1; i >= 0; i--) {\n\t\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[i];\n\t\tsegment = SegmentTree::build(0, v.size() - 1);\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), j));\n\t\t}\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagUp) {\n\t\t\t\tsegment->mark();\n\t\t\t}\n\n\t\t\tif (j < v.size() - 1) {\n\t\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1));\n\t\t\t\tsegment->update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0));\n\t\t\t}\n\t\t}\n\n\t\tdelete segment;\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagInline) {\n\t\t\t\tPoint &p = v[j].get();\n\t\t\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\t\t\tif (p.itX != p.getVectorX().begin() && p.dpUp.x == (p.itX - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itX - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itX - 1)->get().x, (p.itX - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itX - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin() && p.dpUp.x == (p.itDiagonal1 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal1 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal1 - 1)->get().x, (p.itDiagonal1 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal1 - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin() && p.dpUp.x == (p.itDiagonal2 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal2 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal2 - 1)->get().x, (p.itDiagonal2 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal2 - 1)->get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void sort() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tstd::sort(lines[i].begin(), lines[i].end(), &compareByX);\n\t}\n\t\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByY);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itX = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal2);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal1 = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal1);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal2 = it2;\n\t\t}\n\t}\n}\n\n#ifdef DBG\ninline void debugPrint() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tprintf(\"lines[%d] = { \", i);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) {\n\t\t\tconst Point &p = *it;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it + 1 == lines[i].end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tprintf(\"x[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tprintf(\"diagonal1[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tprintf(\"diagonal2[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"(%d, %d): \", a[i].x, a[i].y);\n\t\tif (a[i].dpUp.prec) printf(\"dpUp[%d] = { (%d, %d), %d }, \", i, a[i].dpUp.prec->x, a[i].dpUp.prec->y, a[i].dpUp.x);\n\t\telse printf(\"dpUp[%d] = { nullptr, %d }, \", i, a[i].dpUp.x);\n\t\tif (a[i].dpInline.prec) printf(\"dpInline[%d] = { (%d, %d), %d }\\n\", i, a[i].dpInline.prec->x, a[i].dpInline.prec->y, a[i].dpInline.x);\n\t\telse printf(\"dpInline[%d] = { nullptr, %d }\\n\", i, a[i].dpInline.x);\n\t}\n}\n#endif\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t\ta[i].id = i;\n\t}\n\ta[n].x = 0, a[n].y = 0, a[n].id = n, n++;\n\n\tstd::sort(a, a + n, &compareByY);\n\n\tfor (int i = 0, last; i < n; i++) {\n\t\tPoint &p = a[i];\n\n\t\tif (!i || p.y != a[last].y) ++lineCnt;\n\t\tlines[lineCnt - 1].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tp.lineIndex = lineCnt - 1;\n\n\t\tmapX[p.x].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\n\t\tlast = i;\n\t}\n\n\tsort();\n\n\n#ifdef DBG\n\tdebugPrint();\n#endif\n\t\n\tdp();\n\n\tint cnt = a[n - 1].dpInline.x;\n\tprintf(\"%d\\n\", cnt);\n\n\tstd::vector<Point *> v;\n\tgetPath(v);\n#ifdef DBG\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d: (%d, %d)\\n\", v[i]->id + 1, v[i]->x, v[i]->y);\n#else\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d%c\", v[i]->id + 1, i == v.size() - 1 ? '\\n' : ' ');\n#endif\n\n\tstd::vector< std::pair<Point *, Point *> > E;\n\tgetEdges(E);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX);\n\tfor (std::vector< std::pair<Point *, Point *> >::const_iterator it = E.begin(); it != E.end(); it++) {\n\t\taddEdge(it->first->id + 1, it->second->id + 1, 1, INT_MAX);\n\t}\n\n\tprintf(\"%d\\n\", minFlow(s, t, n + 2));\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-farm.md","raw":"title: 「NOI2015」小园丁与老司机 - DP + 上下界网络流\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - DP\n  - 网络流\n  - 上下界网络流\n  - Dinic\npermalink: noi2015-farm\ndate: 2016-06-29 18:33:00\n---\n\n在坐标系的第一象限内有 $ n $ 个点。\n\n1. 从原点开始，每次向左、右、上、左上 $ 45 ^ \\circ $、右上 $ 45 ^ \\circ $ **任意一个方向**走到**第一个未到过**的点，重复这个过程，求最多能经过多少点；\n2. 求 (1) 中的一个最优方案；\n3. 对于 (1) 中的**所有**最优方案，其所有上、左上 $ 45 ^ \\circ $、右上 $ 45 ^ \\circ $ 的边组成了一个 DAG，求该 DAG 的可重叠最小路径覆盖。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4200](http://www.lydsy.com/JudgeOnline/problem.php?id=4200)  \n[UOJ #132](http://uoj.ac/problem/132)\n\n### 题解\n#### 第一问\n我们可以发现，对于两个点 $ (x_1, y_1) $ 和 $ (x_2, y_2) $，如果 $ y_1 = y_2 $，则它们在同一行，如果 $ x_1 + y_1 = x_2 + y_2 $ 或 $ x_1 - y_1 = x_2 - y_2 $，说明它们在同一对角线上。\n\n记录每一行、每一主对角线、每一副对角线上的点，并进行排序，处理行之间的转移时，可以直接由这些方向上前一个点转移而来。\n\n显而易见的两个结论：\n\n1. 除最后一行外，同一行的若干次移动完成后，一定继续移动到上面的某一行上；\n2. 每一行内，任意两个点都可以通过左右移动到达。\n\n这为我们提供了一个计算顺序 —— 对于每一行，先计算出每个点向上移动的最多步数，再计算同一行以每个点开始到另一个点最多移动的步数，取最大值。\n\n但是，这样做时间复杂度太高，需要优化。考虑到对于同一行的两个点 $ a $、$ b $（$ a $ 在 $ b $ 左侧），从 $ a $ 到达 $ b $ 的最优方案为：先从 $ a $ 经过若干个点移动到一行中的最左端点，然后移动到 $ a $ 右边最近的点，继续向右移动到 $ b $。\n\n打出从 $ a $ 到达 $ b $ 的最多步数表可以发现，当 $ a $ 增大 $ 1 $ 时，到所有 $ b $ 的步数，只有两个会改变：\n\n|   | 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 5 | 0 | 1 | 2 | 3 | 4 |\n| 5 | 4 | 0 | 2 | 3 | 4 |\n| 5 | 4 | 3 | 0 | 3 | 4 |\n| 5 | 4 | 3 | 2 | 0 | 4 |\n| 5 | 4 | 3 | 2 | 1 | 0 |\n\n使用线段树维护当前点到 $ b $ 的步数加 $ b $ 向上走的最大步数，可以在 $ O(\\log n) $ 的时间内求出每个点的结果。\n\n算上排序，第一问的总时间复杂度为 $ O(n \\log n) $。\n\n#### 第二问\n要求出一种方案，我们可以在第一问的转移中记录每个状态的前驱。不同行间的转移可以直接找到前驱，同一行内的转移需要找到行内的目标点后，模拟出走到行首（行尾）后走回目标点的过程。\n\n一个细节是如何判断应该向上走还是走同一行。如果上一次走了同一行到达当前点，那么这一次一定向上走，否则可能会死循环。\n\n#### 第三问\n要求出所有方案中可能的上、左上、右上的边。\n\n从源点的一行开始向上考虑。对于每一行，枚举所有从下面转移过来的点，在与第一问相同的线段树上为所有最大值的点打标记，枚举完一整行后，取出所有被打标记的点，并以这些点开始向上继续考虑。枚举三个方向，对于可以取得最大值的方向，在网络上连一条流量下界为 $ 1 $，上界为 $ +\\infty $ 的边，并对这些方向上的目标点打上标记。\n\n最终，网络的最小可行流为第三问答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <tr1/functional>\n\nconst int MAXN = 50000 + 1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, in;\n} N[MAXN + 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f;\n\t\t\t\te->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"dinic(%d, %d, %d) = %d\\n\", s, t, n, res);\n#endif\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n#ifdef DBG\n\tprintf(\"E(%d, %d, %d)\\n\", s, t, c);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void addEdge(const int s, const int t, const int l, const int r) {\n\tN[s].in -= l;\n\tN[t].in += l;\n\taddEdge(s, t, r - l);\n}\n\ninline int minFlow(const int s, const int t, const int n) {\n\tconst int S = n, T = n + 1;\n\tint full = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].in > 0) addEdge(S, i, N[i].in), full += N[i].in;\n\t\telse if (N[i].in < 0) addEdge(i, T, -N[i].in);\n\t}\n\tEdge *e = addEdge(t, s, INT_MAX);\n\n\tassert(dinic(S, T, n + 2) == full);\n\n\tint f = e->f;\n\n\te->c = e->r->c = 0;\n\tfor (e = N[s].e; e; e = e->next) e->c = e->r->c = 0;\n\tfor (e = N[t].e; e; e = e->next) e->c = e->r->c = 0;\n\n\treturn f - dinic(t, s, n);\n}\n\nstruct DPValue;\nstruct Point;\n\nstruct DPValue {\n\tPoint *prec;\n\tint x;\n\n\tDPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {}\n\n\tDPValue extend(Point &p, const int delta) { return DPValue(&p, x + delta); }\n\n\toperator int() const { return x; }\n};\n\nstruct Point {\n\tint id, x, y, lineIndex;\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator itX, itDiagonal1, itDiagonal2;\n\tDPValue dpUp, dpInline;\n\tbool flagUp, flagInline;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorY() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorX() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal1() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal2() const;\n};\n\nbool compareByY(const Point &a, const Point &b) { return a.y > b.y; }\nbool compareByX(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal1(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal2(const Point &a, const Point &b) { return a.x < b.x; }\n\nint n, lineCnt;\nPoint a[MAXN];\nstd::vector< std::tr1::reference_wrapper<Point> > lines[MAXN];\nstd::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > > mapX, mapDiagonal1, mapDiagonal2;\n\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorY() const { return lines[lineIndex]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorX() const { return mapX[x]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; }\n\ninline void dpUp(const int lineIndex) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = v.begin(); it != v.end(); it++) {\n\t\tPoint &p = it->get();\n\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\tif (p.itX != p.getVectorX().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itX - 1)->get().dpInline.extend((p.itX - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)->get().dpInline.extend((p.itDiagonal1 - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)->get().dpInline.extend((p.itDiagonal2 - 1)->get(), 1));\n\t\t}\n\t}\n}\n\ninline void dpInline(const int lineIndex) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\n\tsegment = SegmentTree::build(0, v.size() - 1);\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), i));\n\t}\n\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i].get().dpInline = segment->query();\n\t\tif (i < v.size() - 1) {\n\t\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1));\n\t\t\tsegment->update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0));\n\t\t}\n\t}\n\n\tdelete segment;\n}\n\ninline void dp() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != 0) dpUp(i);\n\t\tdpInline(i);\n\t}\n}\n\ninline void getInlinePath(std::vector<Point *> &v, Point *s, Point *t) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &line = s->getVectorY();\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator a = std::lower_bound(line.begin(), line.end(), *s, &compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &compareByX);\n\n\tassert(&a->get() == s);\n\tassert(&b->get() == t);\n\n#ifdef DBG\n\tprintf(\"getInlinePath(%d(%d, %d), %d(%d, %d))\\n\", s->id, s->x, s->y, t->id, t->x, t->y);\n#endif\n\n\tif (a < b) {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= line.begin(); it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it <= b; it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t} else {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it != line.end(); it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= b; it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t}\n}\n\ninline void getPath(std::vector<Point *> &v) {\n\tPoint *p = &a[n - 1];\n\tbool flag = false;\n\twhile (p->dpUp.x || (!flag && p->dpInline.x && p->dpInline.prec != p)) {\n\t\tif (flag || p->dpInline.prec == p || p->dpInline.x <= p->dpUp.x) {\n#ifdef DBG\n\t\t\tprintf(\"%d(%d, %d) -> %d(%d, %d)\\n\", p->id, p->x, p->y, p->dpUp.prec->id, p->dpUp.prec->x, p->dpUp.prec->y);\n#endif\n\t\t\tp = p->dpUp.prec;\n\t\t\tv.push_back(p);\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tgetInlinePath(v, p, p->dpInline.prec);\n\t\t\tp = p->dpInline.prec;\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\ninline void getEdges(std::vector< std::pair<Point *, Point *> > &E) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\t\tbool flag;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (flag) pushDown();\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (flag) {\n\t\t\t\tif (lc || rc) {\n\t\t\t\t\tif (val.x == lc->val.x) lc->flag = true;\n\t\t\t\t\tif (val.x == rc->val.x) rc->flag = true;\n\t\t\t\t} else {\n\t\t\t\t\tval.prec->flagInline = true;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tpushDown();\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tvoid mark() { flag = true; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\ta[n - 1].flagUp = true;\n\n\tfor (int i = lineCnt - 1; i >= 0; i--) {\n\t\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[i];\n\t\tsegment = SegmentTree::build(0, v.size() - 1);\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), j));\n\t\t}\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagUp) {\n\t\t\t\tsegment->mark();\n\t\t\t}\n\n\t\t\tif (j < v.size() - 1) {\n\t\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1));\n\t\t\t\tsegment->update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0));\n\t\t\t}\n\t\t}\n\n\t\tdelete segment;\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagInline) {\n\t\t\t\tPoint &p = v[j].get();\n\t\t\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\t\t\tif (p.itX != p.getVectorX().begin() && p.dpUp.x == (p.itX - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itX - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itX - 1)->get().x, (p.itX - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itX - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin() && p.dpUp.x == (p.itDiagonal1 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal1 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal1 - 1)->get().x, (p.itDiagonal1 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal1 - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin() && p.dpUp.x == (p.itDiagonal2 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal2 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal2 - 1)->get().x, (p.itDiagonal2 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal2 - 1)->get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void sort() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tstd::sort(lines[i].begin(), lines[i].end(), &compareByX);\n\t}\n\t\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByY);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itX = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal2);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal1 = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal1);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal2 = it2;\n\t\t}\n\t}\n}\n\n#ifdef DBG\ninline void debugPrint() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tprintf(\"lines[%d] = { \", i);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) {\n\t\t\tconst Point &p = *it;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it + 1 == lines[i].end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tprintf(\"x[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tprintf(\"diagonal1[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tprintf(\"diagonal2[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"(%d, %d): \", a[i].x, a[i].y);\n\t\tif (a[i].dpUp.prec) printf(\"dpUp[%d] = { (%d, %d), %d }, \", i, a[i].dpUp.prec->x, a[i].dpUp.prec->y, a[i].dpUp.x);\n\t\telse printf(\"dpUp[%d] = { nullptr, %d }, \", i, a[i].dpUp.x);\n\t\tif (a[i].dpInline.prec) printf(\"dpInline[%d] = { (%d, %d), %d }\\n\", i, a[i].dpInline.prec->x, a[i].dpInline.prec->y, a[i].dpInline.x);\n\t\telse printf(\"dpInline[%d] = { nullptr, %d }\\n\", i, a[i].dpInline.x);\n\t}\n}\n#endif\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t\ta[i].id = i;\n\t}\n\ta[n].x = 0, a[n].y = 0, a[n].id = n, n++;\n\n\tstd::sort(a, a + n, &compareByY);\n\n\tfor (int i = 0, last; i < n; i++) {\n\t\tPoint &p = a[i];\n\n\t\tif (!i || p.y != a[last].y) ++lineCnt;\n\t\tlines[lineCnt - 1].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tp.lineIndex = lineCnt - 1;\n\n\t\tmapX[p.x].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\n\t\tlast = i;\n\t}\n\n\tsort();\n\n\n#ifdef DBG\n\tdebugPrint();\n#endif\n\t\n\tdp();\n\n\tint cnt = a[n - 1].dpInline.x;\n\tprintf(\"%d\\n\", cnt);\n\n\tstd::vector<Point *> v;\n\tgetPath(v);\n#ifdef DBG\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d: (%d, %d)\\n\", v[i]->id + 1, v[i]->x, v[i]->y);\n#else\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d%c\", v[i]->id + 1, i == v.size() - 1 ? '\\n' : ' ');\n#endif\n\n\tstd::vector< std::pair<Point *, Point *> > E;\n\tgetEdges(E);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX);\n\tfor (std::vector< std::pair<Point *, Point *> >::const_iterator it = E.begin(); it != E.end(); it++) {\n\t\taddEdge(it->first->id + 1, it->second->id + 1, 1, INT_MAX);\n\t}\n\n\tprintf(\"%d\\n\", minFlow(s, t, n + 2));\n\n\treturn 0;\n}\n```\n","slug":"noi2015-farm","published":1,"updated":"2016-11-01T11:59:21.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ron00qvooxltvmba5m0"},{"title":"「NOI2015」荷马史诗 - 哈夫曼树","date":"2016-07-01T01:27:00.000Z","_content":"\n有 $ n $ 种不同的单词，从 $ 1 $ 到 $ n $ 进行编号。其中第 $ i $ 种单词出现的总次数为 $ W_i $。要用 $ k $ 进制串 $ S_i $ 来替换第 $ i $ 种单词，满足对于任意的 $ 1 \\leq i,j \\leq n,\\ i \\neq j $，都有：$ S_i $ 不是 $ S_j $ 的前缀。\n\n1. 替换以后得到的新的长度最小为多少；\n2. 在确保总长度最小的情况下，最长的 $ S_i $ 的最短长度是多少？\n\n<!-- more -->\n\n### 链接\n[BZOJ 4198](http://www.lydsy.com/JudgeOnline/problem.php?id=4198)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### 题解\n考虑当 $ k = 2 $ 时，其最优化条件相当于哈夫曼树，即：将所有单词作为一棵树放在集合中，每次取出两个最小的合并起来，放回集合，直到集合中只剩下一个元素。\n\n显然，$ k \\neq 2 $ 时，将「两个最小的」换成「$ k $ 个」即可。\n\n考虑第二个条件，使最长的 $ S_i $ 最短。在哈夫曼树算法中 $ S_i $ 的长度体现在一个节点被合并的次数上，只需要将每一个节点被合并的次数作为第二关键字即可。\n\n最后一个问题，如果每次取出 $ k $ 个，加入 $ 1 $ 个，最后不够 $ k $ 个怎么办。考虑到每次减少了 $ k - 1 $ 个，需要将 $ n - 1 $ 个减掉 —— 只需加入一些空节点（$ W_i = 0 $）使 $ (n - 1) \\bmod (k - 1) = 0 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100000;\nconst int MAXK = 9;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tstd::priority_queue< std::pair<long long, int>, std::vector< std::pair<long long, int> >, std::greater< std::pair<long long, int> > > q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long x;\n\t\tscanf(\"%lld\", &x);\n\t\tq.push(std::make_pair(x, 0));\n\t}\n\n\twhile ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0));\n\n\tlong long ans = 0;\n\twhile (q.size() > 1) {\n\t\tstd::pair<long long, int> newNode;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstd::pair<long long, int> p = q.top();\n\t\t\tq.pop();\n\t\t\tans += p.first;\n\t\t\tnewNode.first += p.first;\n\t\t\tnewNode.second = std::max(newNode.second, p.second);\n\t\t}\n\n\t\tnewNode.second++;\n\n\t\tq.push(newNode);\n\t}\n\n\tstd::pair<long long, int> p = q.top();\n\tprintf(\"%lld\\n%d\\n\", ans, p.second);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-epic.md","raw":"title: 「NOI2015」荷马史诗 - 哈夫曼树\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - 哈夫曼树\n  - 数据结构\n  - 堆\npermalink: noi2015-epic\ndate: 2016-07-01 09:27:00\n---\n\n有 $ n $ 种不同的单词，从 $ 1 $ 到 $ n $ 进行编号。其中第 $ i $ 种单词出现的总次数为 $ W_i $。要用 $ k $ 进制串 $ S_i $ 来替换第 $ i $ 种单词，满足对于任意的 $ 1 \\leq i,j \\leq n,\\ i \\neq j $，都有：$ S_i $ 不是 $ S_j $ 的前缀。\n\n1. 替换以后得到的新的长度最小为多少；\n2. 在确保总长度最小的情况下，最长的 $ S_i $ 的最短长度是多少？\n\n<!-- more -->\n\n### 链接\n[BZOJ 4198](http://www.lydsy.com/JudgeOnline/problem.php?id=4198)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### 题解\n考虑当 $ k = 2 $ 时，其最优化条件相当于哈夫曼树，即：将所有单词作为一棵树放在集合中，每次取出两个最小的合并起来，放回集合，直到集合中只剩下一个元素。\n\n显然，$ k \\neq 2 $ 时，将「两个最小的」换成「$ k $ 个」即可。\n\n考虑第二个条件，使最长的 $ S_i $ 最短。在哈夫曼树算法中 $ S_i $ 的长度体现在一个节点被合并的次数上，只需要将每一个节点被合并的次数作为第二关键字即可。\n\n最后一个问题，如果每次取出 $ k $ 个，加入 $ 1 $ 个，最后不够 $ k $ 个怎么办。考虑到每次减少了 $ k - 1 $ 个，需要将 $ n - 1 $ 个减掉 —— 只需加入一些空节点（$ W_i = 0 $）使 $ (n - 1) \\bmod (k - 1) = 0 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100000;\nconst int MAXK = 9;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tstd::priority_queue< std::pair<long long, int>, std::vector< std::pair<long long, int> >, std::greater< std::pair<long long, int> > > q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long x;\n\t\tscanf(\"%lld\", &x);\n\t\tq.push(std::make_pair(x, 0));\n\t}\n\n\twhile ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0));\n\n\tlong long ans = 0;\n\twhile (q.size() > 1) {\n\t\tstd::pair<long long, int> newNode;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstd::pair<long long, int> p = q.top();\n\t\t\tq.pop();\n\t\t\tans += p.first;\n\t\t\tnewNode.first += p.first;\n\t\t\tnewNode.second = std::max(newNode.second, p.second);\n\t\t}\n\n\t\tnewNode.second++;\n\n\t\tq.push(newNode);\n\t}\n\n\tstd::pair<long long, int> p = q.top();\n\tprintf(\"%lld\\n%d\\n\", ans, p.second);\n\n\treturn 0;\n}\n```\n","slug":"noi2015-epic","published":1,"updated":"2016-07-01T01:28:31.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rou00r4ooxl3cv5u0r4"},{"title":"「NOI2015」寿司晚宴 - 状压 DP","date":"2016-07-01T05:23:00.000Z","_content":"\n给定 $ 2 $ ~ $ n $ 这 $ n - 1 $ 个数，让两个人分别选出一些数，使得对于第一个人选择的任意一个数 $ a $ 和第二个人选择的任意一个数 $ b $，有 $ \\gcd(a, b) = 1 $，求方案数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4197](http://www.lydsy.com/JudgeOnline/problem.php?id=4197)  \n[UOJ #129](http://uoj.ac/problem/129)\n\n### 题解\n因为题目要求的条件不互质就是指没有相同的质因子，一个显然的思路是求出这些数的所有质因子，用 $ f(a, b) $（$ a $、$ b $ 为二进制集合）表示第一个人选择的质因子集合为 $ a $、第二个人为 $ b $ 的方案数。\n\n但是这些数的质因子太多，无法进行状压，如果我们不考虑每个数 $ x $ 的（最多一个的）大于 $ \\sqrt x $ 的质因子，则质因子只有 $ 8 $ 个 —— $ 2, 3, 5, 7, 11, 13, 17, 19 $，将这些质因子状压。\n\n考虑另一个质因子的影响，设它为 $ z $，则如果一个人选了一个含有质因子 $ z $ 的数，另一个人不能选取任何含有质因子 $ z $ 的数。\n\n将所有数按照 $ z $ 分组，对于每一组，以二进制集合的方式储存其所有数的其它质因子，设第 $ i $ 个数为 $ S_i $。一组数中，最多由某一个人选若干个。\n\n设 $ f(a, b) $ 表示**不选**当前组的情况下，第一个人所选集合为 $ a $，第二个人所选集合为 $ b $ 的方案总数。\n\n对于每一个集合，设 $ g(i, k, a, b) $ 表示组内前 $ i $ 个数，全部由第 $ k $ 个人来选，第一个人所选集合为 $ a $，第二个人所选集合为 $ b $ 的方案总数。\n\n转移时，枚举组内每个数 $ x $，分别以 $ g(i - 1, 0) $ 和 $ g(i - 1, 1) $ 更新 $ g(i, 0) $ 和 $ g(i, 1) $。\n\n$$\n\\begin{aligned}\ng(i, 0, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap b \\neq \\emptyset \\\\\n  \\sum\\limits_{a' \\cup S_i = a} g(i - 1, a', b) + f(a, b) & S_i \\cap b = \\emptyset\n  \\end{cases} \\\\\ng(i, 1, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap a \\neq \\emptyset \\\\\n  \\sum\\limits_{b' \\cup S_i = b} g(i - 1, a, b') + f(a, b) & S_i \\cap a = \\emptyset\n  \\end{cases}\n\\end{aligned}\n$$\n\n注意到枚举 $ a' $ 和 $ b' $ 时，所枚举到的 $ a' $ 或 $ b' $ 均为 $ a $ 或 $ b $ 的字集，体现在十进制意义下，即 $ a' \\leq a $、$ b' \\leq b $。这启发我们可以像背包一样，滚动掉第一维 $ i $，从大到小枚举 $ a $ 和 $ b $，同时刷表更新 $ g(0) $ 和 $ g(1) $。\n\n$$\n\\mathrm {for \\ each} \\ i.\\ a = U \\to \\emptyset,\\ b = U \\to \\emptyset \\\\\n\\begin{aligned}\ng(0, a \\cup S_i, b) \\leftarrow g(0, a \\cup S_i, b) + g(0, a, b) && S_i \\cap b = \\emptyset \\\\\ng(0, a, b \\cup S_i) \\leftarrow g(0, a, b \\cup S_i) + g(0, a, b) && S_i \\cap a = \\emptyset \\\\\n\\end{aligned}\n$$\n\n最后一个问题，对于每个没有大于 $ \\sqrt x $ 的因子的数 $ x $，将这些数每个单独分一组即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 500;\nconst int MAXK = 8;\nconst int MAXSTAT = 1 << 8;\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };\n\nint main() {\n\tint n, p;\n\tscanf(\"%d %d\", &n, &p);\n\n\tstd::vector< std::vector<int> > v;\n\tstd::vector< std::pair<int, int> > tmp;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x = i, t = 0;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (x % PRIMES[j] == 0) {\n\t\t\t\twhile (x % PRIMES[j] == 0) x /= PRIMES[j];\n\t\t\t\tt |= 1 << j;\n\t\t\t}\n\t\t}\n\n\t\ttmp.push_back(std::make_pair(x, t));\n\t}\n\n\tstd::sort(tmp.begin(), tmp.end());\n\n\tfor (std::vector< std::pair<int, int> >::const_iterator it = tmp.begin(); it != tmp.end(); it++) {\n\t\tif (it == tmp.begin() || it->first == 1 || it->first != (it - 1)->first) {\n\t\t\tv.resize(v.size() + 1);\n\t\t}\n\t\tv.back().push_back(it->second);\n\t}\n\n\tstatic int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT];\n\tf[0][0] = 1;\n\tfor (std::vector< std::vector<int> >::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tmemcpy(g[0], f, sizeof(f));\n\t\tmemcpy(g[1], f, sizeof(f));\n\n\t\t// puts(\"new\");\n\t\tfor (std::vector<int>::const_iterator it2 = it->begin(); it2 != it->end(); it2++) {\n\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\t\t// printf(\"%d %d\\n\", a, b);\n\t\t\t\t\tif (!(b & *it2)) /* printf(\"[0] += %d\\n\", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p;\n\t\t\t\t\tif (!(a & *it2)) /* printf(\"[1] += %d\\n\", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p;\n\t\t\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\t\t\t// printf(\"%d %d\\n\", g[0][a][b], g[1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\tf[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\tif (!(a & b)) (ans += f[a][b]) %= p;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-dinner.md","raw":"title: 「NOI2015」寿司晚宴 - 状压 DP\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - DP\n  - 状压 DP\n  - 背包 DP\npermalink: noi2015-dinner\ndate: 2016-07-01 13:23:00\n---\n\n给定 $ 2 $ ~ $ n $ 这 $ n - 1 $ 个数，让两个人分别选出一些数，使得对于第一个人选择的任意一个数 $ a $ 和第二个人选择的任意一个数 $ b $，有 $ \\gcd(a, b) = 1 $，求方案数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4197](http://www.lydsy.com/JudgeOnline/problem.php?id=4197)  \n[UOJ #129](http://uoj.ac/problem/129)\n\n### 题解\n因为题目要求的条件不互质就是指没有相同的质因子，一个显然的思路是求出这些数的所有质因子，用 $ f(a, b) $（$ a $、$ b $ 为二进制集合）表示第一个人选择的质因子集合为 $ a $、第二个人为 $ b $ 的方案数。\n\n但是这些数的质因子太多，无法进行状压，如果我们不考虑每个数 $ x $ 的（最多一个的）大于 $ \\sqrt x $ 的质因子，则质因子只有 $ 8 $ 个 —— $ 2, 3, 5, 7, 11, 13, 17, 19 $，将这些质因子状压。\n\n考虑另一个质因子的影响，设它为 $ z $，则如果一个人选了一个含有质因子 $ z $ 的数，另一个人不能选取任何含有质因子 $ z $ 的数。\n\n将所有数按照 $ z $ 分组，对于每一组，以二进制集合的方式储存其所有数的其它质因子，设第 $ i $ 个数为 $ S_i $。一组数中，最多由某一个人选若干个。\n\n设 $ f(a, b) $ 表示**不选**当前组的情况下，第一个人所选集合为 $ a $，第二个人所选集合为 $ b $ 的方案总数。\n\n对于每一个集合，设 $ g(i, k, a, b) $ 表示组内前 $ i $ 个数，全部由第 $ k $ 个人来选，第一个人所选集合为 $ a $，第二个人所选集合为 $ b $ 的方案总数。\n\n转移时，枚举组内每个数 $ x $，分别以 $ g(i - 1, 0) $ 和 $ g(i - 1, 1) $ 更新 $ g(i, 0) $ 和 $ g(i, 1) $。\n\n$$\n\\begin{aligned}\ng(i, 0, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap b \\neq \\emptyset \\\\\n  \\sum\\limits_{a' \\cup S_i = a} g(i - 1, a', b) + f(a, b) & S_i \\cap b = \\emptyset\n  \\end{cases} \\\\\ng(i, 1, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap a \\neq \\emptyset \\\\\n  \\sum\\limits_{b' \\cup S_i = b} g(i - 1, a, b') + f(a, b) & S_i \\cap a = \\emptyset\n  \\end{cases}\n\\end{aligned}\n$$\n\n注意到枚举 $ a' $ 和 $ b' $ 时，所枚举到的 $ a' $ 或 $ b' $ 均为 $ a $ 或 $ b $ 的字集，体现在十进制意义下，即 $ a' \\leq a $、$ b' \\leq b $。这启发我们可以像背包一样，滚动掉第一维 $ i $，从大到小枚举 $ a $ 和 $ b $，同时刷表更新 $ g(0) $ 和 $ g(1) $。\n\n$$\n\\mathrm {for \\ each} \\ i.\\ a = U \\to \\emptyset,\\ b = U \\to \\emptyset \\\\\n\\begin{aligned}\ng(0, a \\cup S_i, b) \\leftarrow g(0, a \\cup S_i, b) + g(0, a, b) && S_i \\cap b = \\emptyset \\\\\ng(0, a, b \\cup S_i) \\leftarrow g(0, a, b \\cup S_i) + g(0, a, b) && S_i \\cap a = \\emptyset \\\\\n\\end{aligned}\n$$\n\n最后一个问题，对于每个没有大于 $ \\sqrt x $ 的因子的数 $ x $，将这些数每个单独分一组即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 500;\nconst int MAXK = 8;\nconst int MAXSTAT = 1 << 8;\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };\n\nint main() {\n\tint n, p;\n\tscanf(\"%d %d\", &n, &p);\n\n\tstd::vector< std::vector<int> > v;\n\tstd::vector< std::pair<int, int> > tmp;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x = i, t = 0;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (x % PRIMES[j] == 0) {\n\t\t\t\twhile (x % PRIMES[j] == 0) x /= PRIMES[j];\n\t\t\t\tt |= 1 << j;\n\t\t\t}\n\t\t}\n\n\t\ttmp.push_back(std::make_pair(x, t));\n\t}\n\n\tstd::sort(tmp.begin(), tmp.end());\n\n\tfor (std::vector< std::pair<int, int> >::const_iterator it = tmp.begin(); it != tmp.end(); it++) {\n\t\tif (it == tmp.begin() || it->first == 1 || it->first != (it - 1)->first) {\n\t\t\tv.resize(v.size() + 1);\n\t\t}\n\t\tv.back().push_back(it->second);\n\t}\n\n\tstatic int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT];\n\tf[0][0] = 1;\n\tfor (std::vector< std::vector<int> >::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tmemcpy(g[0], f, sizeof(f));\n\t\tmemcpy(g[1], f, sizeof(f));\n\n\t\t// puts(\"new\");\n\t\tfor (std::vector<int>::const_iterator it2 = it->begin(); it2 != it->end(); it2++) {\n\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\t\t// printf(\"%d %d\\n\", a, b);\n\t\t\t\t\tif (!(b & *it2)) /* printf(\"[0] += %d\\n\", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p;\n\t\t\t\t\tif (!(a & *it2)) /* printf(\"[1] += %d\\n\", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p;\n\t\t\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\t\t\t// printf(\"%d %d\\n\", g[0][a][b], g[1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\tf[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\tif (!(a & b)) (ans += f[a][b]) %= p;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2015-dinner","published":1,"updated":"2016-10-24T23:37:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rp300rdooxlqbidw1i1"},{"title":"「NOI2014」动物园 - KMP","date":"2016-07-11T15:41:00.000Z","_content":"\n对于字符串 $ S $ 的前 $ i $ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $ \\mathrm {num}(i) $，求\n\n$$\n\\prod\\limits_{i = 1} ^ n (\\mathrm{num}(i) + 1) \\pmod {1000000007}\n$$\n\n<!-- more -->\n\n### 链接\n[BZOJ 3670](http://www.lydsy.com/JudgeOnline/problem.php?id=3670)  \n[UOJ #5](http://uoj.ac/problem/5)\n\n### 题解\n考虑简化问题，去除「该后缀与该前缀不重叠」的限制后，问题变成了一个简单的 DP —— $ \\mathrm{num}(i) = \\mathrm{num}(\\mathrm{next}(i)) + 1 $。\n\n考虑限制条件 —— 我们需要对 $ \\mathrm{next} $ 数组设置同样的限制条件，并设其为 $ \\mathrm{next2} $。然后对于带限制的 $ \\mathrm{num} $（设为 $ \\mathrm{num2} $），发现 $ \\mathrm{num2}(i) = \\mathrm{num2}(\\mathrm{next2}(i)) + 1 $ 并不成立，观察后可发现\n\n$$ \\mathrm{num2}(i) = \\mathrm{num}(\\mathrm{next2}(i)) + 1 $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 5;\nconst int MAXN = 1000000;\nconst unsigned long long MOD = 1000000007;\n\nint n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1];\nchar s[MAXN + 1];\n\ninline unsigned long long kmp() {\n\tnext[0] = next[1] = num[0] = num[1] = 0;\n\tfor (int i = 2, t = 0, k = 0; i <= n; i++) {\n\t\twhile (t && s[t] != s[i - 1]) t = next[t];\n\t\twhile ((k && s[k] != s[i - 1]) || k >= i / 2) k = next[k];\n\n\t\tif (s[k] == s[i - 1]) num2[i] = num[++k] + 1;\n\t\telse num2[i] = 0;\n\n\t\tif (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1;\n\t\telse next[i] = num[i] = 0;\n\t}\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", f[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num2[i], i == n ? '\\n' : ' ');\n\n\tunsigned long long ans = 1;\n\tfor (int i = 1; i <= n; i++) (ans *= (num2[i] + 1)) %= MOD;\n\treturn ans;\n}\n\nint main() {\n\tint t = 1;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\n\t\tprintf(\"%llu\\n\", kmp());\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-zoo.md","raw":"title: 「NOI2014」动物园 - KMP\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - KMP\n  - 字符串\npermalink: noi2014-zoo\ndate: 2016-07-11 23:41:00\n---\n\n对于字符串 $ S $ 的前 $ i $ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $ \\mathrm {num}(i) $，求\n\n$$\n\\prod\\limits_{i = 1} ^ n (\\mathrm{num}(i) + 1) \\pmod {1000000007}\n$$\n\n<!-- more -->\n\n### 链接\n[BZOJ 3670](http://www.lydsy.com/JudgeOnline/problem.php?id=3670)  \n[UOJ #5](http://uoj.ac/problem/5)\n\n### 题解\n考虑简化问题，去除「该后缀与该前缀不重叠」的限制后，问题变成了一个简单的 DP —— $ \\mathrm{num}(i) = \\mathrm{num}(\\mathrm{next}(i)) + 1 $。\n\n考虑限制条件 —— 我们需要对 $ \\mathrm{next} $ 数组设置同样的限制条件，并设其为 $ \\mathrm{next2} $。然后对于带限制的 $ \\mathrm{num} $（设为 $ \\mathrm{num2} $），发现 $ \\mathrm{num2}(i) = \\mathrm{num2}(\\mathrm{next2}(i)) + 1 $ 并不成立，观察后可发现\n\n$$ \\mathrm{num2}(i) = \\mathrm{num}(\\mathrm{next2}(i)) + 1 $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 5;\nconst int MAXN = 1000000;\nconst unsigned long long MOD = 1000000007;\n\nint n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1];\nchar s[MAXN + 1];\n\ninline unsigned long long kmp() {\n\tnext[0] = next[1] = num[0] = num[1] = 0;\n\tfor (int i = 2, t = 0, k = 0; i <= n; i++) {\n\t\twhile (t && s[t] != s[i - 1]) t = next[t];\n\t\twhile ((k && s[k] != s[i - 1]) || k >= i / 2) k = next[k];\n\n\t\tif (s[k] == s[i - 1]) num2[i] = num[++k] + 1;\n\t\telse num2[i] = 0;\n\n\t\tif (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1;\n\t\telse next[i] = num[i] = 0;\n\t}\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", f[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num2[i], i == n ? '\\n' : ' ');\n\n\tunsigned long long ans = 1;\n\tfor (int i = 1; i <= n; i++) (ans *= (num2[i] + 1)) %= MOD;\n\treturn ans;\n}\n\nint main() {\n\tint t = 1;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\n\t\tprintf(\"%llu\\n\", kmp());\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2014-zoo","published":1,"updated":"2016-07-11T15:41:47.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rp900rkooxl4329aiu2"},{"title":"「NOI2014」起床困难综合征 - 位运算 + 贪心","date":"2016-04-03T14:39:31.000Z","_content":"\ndrd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $ n $ 扇防御门组成。每扇防御门包括一个运算 $ \\rm op $ 和一个参数 $ t $，其中运算一定是 $ \\rm OR $，$ \\rm XOR $，$ \\rm AND $ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $ x $，则其通过这扇防御门后攻击力将变为 $ x ~ {\\rm op} ~ t $。最终 drd 受到的伤害为对方初始攻击力 $ x $ 依次经过所有 $ n $ 扇防御门后转变得到的攻击力。\n由于 atm 水平有限，他的初始攻击力只能为 $ 0 $ 到 $ m $ 之间的一个整数（即他的初始攻击力只能在 $ 0 $，$ 1 $，$ … $，$ m $ 中任选，但在通过防御门之后的攻击力不受 $ m $ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### 题解\n贪心从高位到低位枚举，检验当前位在初始值为 $ 0 $ 情况下的答案是否可以为 $ 1 $，如果不能则检验当前位初始值能否为 $ 1 $，并检验当前位在初始值为 $ 1 $ 情况下的答案是否可以为 $ 1 $。\n\n注意要用 `unsigned int`，否则会变成负数。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-sleep.md","raw":"title: 「NOI2014」起床困难综合征 - 位运算 + 贪心\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - 位运算\n  - 贪心\npermalink: noi2014-sleep\ndate: 2016-04-03 22:39:31\n---\n\ndrd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $ n $ 扇防御门组成。每扇防御门包括一个运算 $ \\rm op $ 和一个参数 $ t $，其中运算一定是 $ \\rm OR $，$ \\rm XOR $，$ \\rm AND $ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $ x $，则其通过这扇防御门后攻击力将变为 $ x ~ {\\rm op} ~ t $。最终 drd 受到的伤害为对方初始攻击力 $ x $ 依次经过所有 $ n $ 扇防御门后转变得到的攻击力。\n由于 atm 水平有限，他的初始攻击力只能为 $ 0 $ 到 $ m $ 之间的一个整数（即他的初始攻击力只能在 $ 0 $，$ 1 $，$ … $，$ m $ 中任选，但在通过防御门之后的攻击力不受 $ m $ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### 题解\n贪心从高位到低位枚举，检验当前位在初始值为 $ 0 $ 情况下的答案是否可以为 $ 1 $，如果不能则检验当前位初始值能否为 $ 1 $，并检验当前位在初始值为 $ 1 $ 情况下的答案是否可以为 $ 1 $。\n\n注意要用 `unsigned int`，否则会变成负数。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-sleep","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rpe00rqooxltmjb81r9"},{"title":"「NOI2014」魔法森林 - LCT","date":"2016-07-11T15:50:00.000Z","_content":"\n魔法森林是一个 $ N $ 个节点 $ M $ 条边的无向图，节点标号为 $ 1 \\ldots N $，边标号为 $ 1 \\ldots M $。初始时小 E 同学在号节点 $ 1 $，隐士在节点 $ N $。\n\n无向图中的每一条边 $ E_i $ 包含两个权值 $ A_i $ 与 $ B_i $。若身上携带的 A 型守护精灵个数不少于 $ A_i $，且 B 型守护精灵个数不少于 $ B_i $，这条边上的妖怪就发起攻击。\n\n小 E 想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3669](http://www.lydsy.com/JudgeOnline/problem.php?id=3669)  \n[UOJ #3](http://uoj.ac/problem/3)\n\n### 题解\n将边按照 $ A_i $ 排序，以 $ B_i $ 作为边权，加入到 LCT 中（每条边拆成一个点和两条边，分别与两个端点相连）。每当出现环时，删除环上 $ B_i $ 最大的边。每次判断 $ 1 $ 到 $ n $ 是否联通，更新答案。\n\n注意自环。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *p, *pp, *max;\n\t\tint w;\n\t\tbool rev;\n\n\t\tNode() : p(NULL), pp(NULL), max(this), w(0) {}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid maintain() {\n\t\t\tmax = this;\n\t\t\tif (c[0] && c[0]->max->w > max->w) max = c[0]->max;\n\t\t\tif (c[1] && c[1]->max->w > max->w) max = c[1]->max;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pp, p->pp);\n\t\t\tint r = relation();\n\t\t\tNode *o = p;\n\t\t\t\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[r] = c[r ^ 1];\n\t\t\tif (c[r ^ 1]) c[r ^ 1]->p = o;\n\n\t\t\tc[r ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (p) {\n\t\t\t\tif (p->p) p->p->pushDown();\n\t\t\t\tp->pushDown(), pushDown();\n\n\t\t\t\tif (!p->p) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->p, c[1]->pp);\n\t\t\t\tc[1] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pp) return false;\n\t\t\tpp->expose();\n\t\t\tpp->c[1] = this;\n\t\t\tpp->maintain();\n\t\t\tstd::swap(p, pp);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\trev ^= 1;\n\t\t}\n\t} N[MAXN], E[MAXM], *a[MAXM][2];\n\n\tvoid link(Node *u, Node *v) {\n\t\t// printf(\"Linking %ld as %ld's parent.\\n\", u - N + 1, v - N + 1);\n\t\tv->evert();\n\t\tu->expose();\n\t\tv->pp = u;\n\t}\n\n\tvoid link(const int u, const int v, const int i, const int w) {\n\t\tE[i].w = w;\n\t\ta[i][0] = &N[u];\n\t\ta[i][1] = &N[v];\n\t\tlink(&N[u], &E[i]);\n\t\tlink(&E[i], &N[v]);\n\t}\n\n\tvoid cut(Node *u, Node *v) {\n\t\tv->evert();\n\t\tv->expose();\n\t\tu->splay();\n\t\tu->pp = NULL;\n\t}\n\n\tvoid cut(const int i) {\n\t\tcut(a[i][0], &E[i]);\n\t\tcut(&E[i], a[i][1]);\n\t}\n\n\tNode *find(const int u) {\n\t\tNode *v = &N[u];\n\t\tv->access();\n\t\tv->splay();\n\t\tif (!v->c[0]) {\n\t\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\t\treturn v;\n\t\t}\n\t\twhile (v->c[0]) v = v->c[0];\n\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\treturn v;\n\t}\n\n\tbool test(const int u, const int v) {\n\t\treturn find(u) == find(v);\n\t}\n\n\tint queryMax(const int u, const int v) {\n\t\tN[u].evert();\n\t\tN[v].access();\n\t\tN[v].splay();\n\t\tassert(N[v].max >= E);\n\t\treturn N[v].max - E;\n\t}\n} lct;\n\nstruct Edge {\n\tint u, v, a, b;\n\n\tbool operator<(const Edge &other) const { return a < other.a; }\n} E[MAXM];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b), E[i].u--, E[i].v--;\n\tstd::sort(E, E + m);\n\n\tint ans = INT_MAX;\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tif (e.u == e.v) continue;\n\t\tif (lct.test(e.u, e.v)) {\n\t\t\t// printf(\"[%d, %d, %d, %d] will lead to a circle!\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tint max = lct.queryMax(e.u, e.v);\n\t\t\t// printf(\"max = %d\\n\", max);\n\t\t\tif (E[max].b > e.b) {\n\t\t\t\tlct.cut(max);\n\t\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t\t}\n\t\t} else {\n\t\t\t// printf(\"Connecting [%d, %d, %d, %d] ...\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t}\n\n\t\tif (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b);\n\t}\n\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-forest.md","raw":"title: 「NOI2014」魔法森林 - LCT\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - LCT\n  - 数据结构\npermalink: noi2014-forest\ndate: 2016-07-11 23:50:00\n---\n\n魔法森林是一个 $ N $ 个节点 $ M $ 条边的无向图，节点标号为 $ 1 \\ldots N $，边标号为 $ 1 \\ldots M $。初始时小 E 同学在号节点 $ 1 $，隐士在节点 $ N $。\n\n无向图中的每一条边 $ E_i $ 包含两个权值 $ A_i $ 与 $ B_i $。若身上携带的 A 型守护精灵个数不少于 $ A_i $，且 B 型守护精灵个数不少于 $ B_i $，这条边上的妖怪就发起攻击。\n\n小 E 想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3669](http://www.lydsy.com/JudgeOnline/problem.php?id=3669)  \n[UOJ #3](http://uoj.ac/problem/3)\n\n### 题解\n将边按照 $ A_i $ 排序，以 $ B_i $ 作为边权，加入到 LCT 中（每条边拆成一个点和两条边，分别与两个端点相连）。每当出现环时，删除环上 $ B_i $ 最大的边。每次判断 $ 1 $ 到 $ n $ 是否联通，更新答案。\n\n注意自环。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *p, *pp, *max;\n\t\tint w;\n\t\tbool rev;\n\n\t\tNode() : p(NULL), pp(NULL), max(this), w(0) {}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid maintain() {\n\t\t\tmax = this;\n\t\t\tif (c[0] && c[0]->max->w > max->w) max = c[0]->max;\n\t\t\tif (c[1] && c[1]->max->w > max->w) max = c[1]->max;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pp, p->pp);\n\t\t\tint r = relation();\n\t\t\tNode *o = p;\n\t\t\t\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[r] = c[r ^ 1];\n\t\t\tif (c[r ^ 1]) c[r ^ 1]->p = o;\n\n\t\t\tc[r ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (p) {\n\t\t\t\tif (p->p) p->p->pushDown();\n\t\t\t\tp->pushDown(), pushDown();\n\n\t\t\t\tif (!p->p) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->p, c[1]->pp);\n\t\t\t\tc[1] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pp) return false;\n\t\t\tpp->expose();\n\t\t\tpp->c[1] = this;\n\t\t\tpp->maintain();\n\t\t\tstd::swap(p, pp);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\trev ^= 1;\n\t\t}\n\t} N[MAXN], E[MAXM], *a[MAXM][2];\n\n\tvoid link(Node *u, Node *v) {\n\t\t// printf(\"Linking %ld as %ld's parent.\\n\", u - N + 1, v - N + 1);\n\t\tv->evert();\n\t\tu->expose();\n\t\tv->pp = u;\n\t}\n\n\tvoid link(const int u, const int v, const int i, const int w) {\n\t\tE[i].w = w;\n\t\ta[i][0] = &N[u];\n\t\ta[i][1] = &N[v];\n\t\tlink(&N[u], &E[i]);\n\t\tlink(&E[i], &N[v]);\n\t}\n\n\tvoid cut(Node *u, Node *v) {\n\t\tv->evert();\n\t\tv->expose();\n\t\tu->splay();\n\t\tu->pp = NULL;\n\t}\n\n\tvoid cut(const int i) {\n\t\tcut(a[i][0], &E[i]);\n\t\tcut(&E[i], a[i][1]);\n\t}\n\n\tNode *find(const int u) {\n\t\tNode *v = &N[u];\n\t\tv->access();\n\t\tv->splay();\n\t\tif (!v->c[0]) {\n\t\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\t\treturn v;\n\t\t}\n\t\twhile (v->c[0]) v = v->c[0];\n\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\treturn v;\n\t}\n\n\tbool test(const int u, const int v) {\n\t\treturn find(u) == find(v);\n\t}\n\n\tint queryMax(const int u, const int v) {\n\t\tN[u].evert();\n\t\tN[v].access();\n\t\tN[v].splay();\n\t\tassert(N[v].max >= E);\n\t\treturn N[v].max - E;\n\t}\n} lct;\n\nstruct Edge {\n\tint u, v, a, b;\n\n\tbool operator<(const Edge &other) const { return a < other.a; }\n} E[MAXM];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b), E[i].u--, E[i].v--;\n\tstd::sort(E, E + m);\n\n\tint ans = INT_MAX;\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tif (e.u == e.v) continue;\n\t\tif (lct.test(e.u, e.v)) {\n\t\t\t// printf(\"[%d, %d, %d, %d] will lead to a circle!\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tint max = lct.queryMax(e.u, e.v);\n\t\t\t// printf(\"max = %d\\n\", max);\n\t\t\tif (E[max].b > e.b) {\n\t\t\t\tlct.cut(max);\n\t\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t\t}\n\t\t} else {\n\t\t\t// printf(\"Connecting [%d, %d, %d, %d] ...\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t}\n\n\t\tif (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b);\n\t}\n\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-forest","published":1,"updated":"2016-07-11T15:54:43.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rpi00rwooxll1nhr5tg"},{"title":"「NOI2012」随机数生成器 - 矩阵乘法","date":"2016-10-07T23:29:00.000Z","_content":"\n已知\n\n$$ x_{n + 1} = (a x_n + c) \\bmod m $$\n\n给定 $ m, a, c, x_0, n, g $，求 $ x_n \\bmod g $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2875](www.lydsy.com/JudgeOnline/problem.php?id=2875)  \n[COGS 963](http://cogs.pro/cogs/problem/problem.php?pid=963)\n\n### 题解\n用矩阵乘法计算递推。\n\n两个数相乘结果可能溢出，需要使用类似快速幂的方法拆成二进制每次乘 $ 2 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst long long MAXN = 1e18;\nconst long long MAXG = 1e8;\n\nlong long mod;\n\nstruct Matrix {\n\tlong long a[2][2];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\n\tlong long &operator()(const int i, const int j) { return a[i][j]; }\n\tconst long long &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"randoma.in\", \"r\", stdin);\n\tfreopen(\"randoma.out\", \"w\", stdout);\n\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld %lld %lld %lld %lld %lld\", &mod, &a, &c, &x, &n, &g);\n\t// mod = 1e9 + 7;\n\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\n\tMatrix shift(false);\n\tshift(0, 0) = a, shift(0, 1) = 1;\n\tshift(1, 0) = 0, shift(1, 1) = 1;\n\n#ifdef FORCE\n\tMatrix res = init;\n\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\tputs(\"----------------------\");\n\tfor (int i = 0; i < n; i++) {\n\t\tres = shift * res;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\t\tputs(\"----------------------\");\n\t}\n#else\n\tMatrix res = pow(shift, n) * init;\n#endif\n\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/noi2012-random.md","raw":"title: 「NOI2012」随机数生成器 - 矩阵乘法\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - COGS\n  - 矩阵乘法\npermalink: noi2012-random\ndate: 2016-10-08 07:29:00\n---\n\n已知\n\n$$ x_{n + 1} = (a x_n + c) \\bmod m $$\n\n给定 $ m, a, c, x_0, n, g $，求 $ x_n \\bmod g $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2875](www.lydsy.com/JudgeOnline/problem.php?id=2875)  \n[COGS 963](http://cogs.pro/cogs/problem/problem.php?pid=963)\n\n### 题解\n用矩阵乘法计算递推。\n\n两个数相乘结果可能溢出，需要使用类似快速幂的方法拆成二进制每次乘 $ 2 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst long long MAXN = 1e18;\nconst long long MAXG = 1e8;\n\nlong long mod;\n\nstruct Matrix {\n\tlong long a[2][2];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\n\tlong long &operator()(const int i, const int j) { return a[i][j]; }\n\tconst long long &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"randoma.in\", \"r\", stdin);\n\tfreopen(\"randoma.out\", \"w\", stdout);\n\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld %lld %lld %lld %lld %lld\", &mod, &a, &c, &x, &n, &g);\n\t// mod = 1e9 + 7;\n\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\n\tMatrix shift(false);\n\tshift(0, 0) = a, shift(0, 1) = 1;\n\tshift(1, 0) = 0, shift(1, 1) = 1;\n\n#ifdef FORCE\n\tMatrix res = init;\n\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\tputs(\"----------------------\");\n\tfor (int i = 0; i < n; i++) {\n\t\tres = shift * res;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\t\tputs(\"----------------------\");\n\t}\n#else\n\tMatrix res = pow(shift, n) * init;\n#endif\n\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"noi2012-random","published":1,"updated":"2016-10-07T23:36:47.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rpn00s3ooxllpwfew4u"},{"title":"「NOI2011」阿狸的打字机 - AC 自动机","date":"2016-09-11T23:38:00.000Z","_content":"\n打字机上只有 $ 28 $ 个按键，分别印有 $ 26 $ 个小写英文字母和 `B`、`P` 两个字母。\n\n经阿狸研究发现，这个打字机是这样工作的：\n\n* 输入小写字母，打字机的一个凹槽中会加入这个字母（这个字母加在凹槽的最后）。\n* 按一下印有 `B` 的按键，打字机凹槽中最后一个字母会消失。\n* 按一下印有 `P` 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。\n\n我们把纸上打印出来的字符串从 $ 1 $ 开始顺序编号，一直到 $ n $。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 $ (x, y) $（其中 $ 1 \\leq x, y \\leq n $），打字机会显示第 $ x $ 个打印的字符串在第 $ y $ 个打印的字符串中出现了多少次。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2434](http://www.lydsy.com/JudgeOnline/problem.php?id=2434)\n\n### 题解\n使用 Trie 储存操作序列，问题转化为，在 Trie 上求一个单词在另一个单词中的出现次数。\n\n建立 AC 自动机，可以发现如果 $ y $ 中出现了 $ x $，那么 $ y $ 到根路径上的某个节点的 `fail` 指针（直接或间接地）指向 $ x $。问题转化为，在 AC 自动机上求 $ y $ 到根的路径上有多少节点可以经过 `fail` 指针转移到 $ x $。\n\n将 `fail` 指针反向，形成一棵树，称为 Fail 树。在 Fail 树上，子节点可以在 AC 自动机上经过 `fail` 指针转移到父节点上。问题转化，AC 自动机中在 $ y $ 到根路径上的节点，有多少个在 Fail 树上对应节点在 $ x $ 的子树中。\n\n考虑这样一种暴力 —— 在 AC 自动机上从根走到 $ y $，对于经过的每一个节点，将它在 Fail 树上对应节点的权值置为 $ 1 $，之后枚举要对 $ y $ 查询的所有 $ x $，每一次的答案即为 $ x $ 在 Fail 树上子树中所有节点的权值和。\n\n对于子树权值和，我们可以用 DFS 序 + 树状数组维护。根据按照操作序列重新遍历 AC 自动机，进入每个节点时，它在 Fail 树上对应节点的权值置为 $ 1 $，退出时置为 $ 0 $，每次走到一个单词节点时，处理由该节点作为 $ y $ 的所有询问。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next, *p;\n\t\tint id;\n\t\tbool isWord;\n\t\tstruct Query {\n\t\t\tNode *x;\n\t\t\tint *ans;\n\n\t\t\tQuery(Node *x, int *ans) : x(x), ans(ans) {}\n\t\t};\n\t\tstd::vector<Query> q;\n\n\t\tNode(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tint init(const char *s, std::vector<Node *> &vec) {\n\t\tint cnt = 0;\n\t\tNode *v = root = new Node(NULL, false, cnt++);\n\t\tfor (const char *p = s; *p; p++) {\n\t\t\tassert(*p == 'P' || *p == 'B' || (*p >= 'a' && *p <= 'z'));\n\t\t\tif (*p == 'P') v->isWord = true, vec.push_back(v);\n\t\t\telse if (*p == 'B') v = v->p;\n\t\t\telse {\n\t\t\t\tif (!v->c[*p - BASE_CHAR]) v->c[*p - BASE_CHAR] = new Node(v, false, cnt++);\n\t\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root, root->next = NULL;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tassert(v->q.size() < MAXN);\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t\tassert(v->q.size() < MAXN);\n\t\t\t\tassert(c->q.size() < MAXN);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tNode *p, *c, *next;\n\tint l, r;\n\tbool v;\n} N[MAXN];\n\nint n;\n\ninline void addEdge(const int p, const int c) {\n\t// printf(\"addEdge(%d, %d)\\n\", p, c);\n\tN[c].next = N[p].c;\n\tN[p].c = &N[c];\n\tN[c].p = &N[p];\n}\n\ninline void buildFailTree() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *&c = v->c[i];\n\t\t\tif (!c) continue;\n\t\t\taddEdge(c->fail->id, c->id);\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void dfs() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->v) {\n\t\t\tv->v = true;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Node *c = v->c; c; c = c->next) s.push(c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint query(const int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) ans += a[i];\n\t\treturn ans;\n\t}\n} bit;\n\nchar op[MAXN + 1];\ninline void solve() {\n\tbit.init(n);\n\tTrie::Node *y = t.root;\n\tfor (const char *p = op; *p; p++) {\n\t\tif (*p == 'P') {\n\t\t\tfor (std::vector<Trie::Node::Query>::iterator it = y->q.begin(); it != y->q.end(); it++) {\n\t\t\t\t*it->ans = bit.query(N[it->x->id].r) - bit.query(N[it->x->id].l - 1);\n\t\t\t}\n\t\t} else if (*p == 'B') {\n\t\t\tbit.update(N[y->id].l, -1);\n\t\t\ty = y->p;\n\t\t} else {\n\t\t\ty = y->c[*p - BASE_CHAR];\n\t\t\tbit.update(N[y->id].l, 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", op);\n\n\tstd::vector<Trie::Node *> vec;\n\tn = t.init(op, vec);\n\tt.build();\n\n\tbuildFailTree();\n\tdfs();\n\n\tint m;\n\tstatic int ans[MAXN];\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\t\tvec[y]->q.push_back(Trie::Node::Query(vec[x], &ans[i]));\n\t}\n\n\tsolve();\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","source":"_posts/noi2011-type.md","raw":"title: 「NOI2011」阿狸的打字机 - AC 自动机\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - 字符串\n  - AC 自动机\npermalink: noi2011-type\ndate: 2016-09-12 07:38:00\n---\n\n打字机上只有 $ 28 $ 个按键，分别印有 $ 26 $ 个小写英文字母和 `B`、`P` 两个字母。\n\n经阿狸研究发现，这个打字机是这样工作的：\n\n* 输入小写字母，打字机的一个凹槽中会加入这个字母（这个字母加在凹槽的最后）。\n* 按一下印有 `B` 的按键，打字机凹槽中最后一个字母会消失。\n* 按一下印有 `P` 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。\n\n我们把纸上打印出来的字符串从 $ 1 $ 开始顺序编号，一直到 $ n $。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 $ (x, y) $（其中 $ 1 \\leq x, y \\leq n $），打字机会显示第 $ x $ 个打印的字符串在第 $ y $ 个打印的字符串中出现了多少次。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2434](http://www.lydsy.com/JudgeOnline/problem.php?id=2434)\n\n### 题解\n使用 Trie 储存操作序列，问题转化为，在 Trie 上求一个单词在另一个单词中的出现次数。\n\n建立 AC 自动机，可以发现如果 $ y $ 中出现了 $ x $，那么 $ y $ 到根路径上的某个节点的 `fail` 指针（直接或间接地）指向 $ x $。问题转化为，在 AC 自动机上求 $ y $ 到根的路径上有多少节点可以经过 `fail` 指针转移到 $ x $。\n\n将 `fail` 指针反向，形成一棵树，称为 Fail 树。在 Fail 树上，子节点可以在 AC 自动机上经过 `fail` 指针转移到父节点上。问题转化，AC 自动机中在 $ y $ 到根路径上的节点，有多少个在 Fail 树上对应节点在 $ x $ 的子树中。\n\n考虑这样一种暴力 —— 在 AC 自动机上从根走到 $ y $，对于经过的每一个节点，将它在 Fail 树上对应节点的权值置为 $ 1 $，之后枚举要对 $ y $ 查询的所有 $ x $，每一次的答案即为 $ x $ 在 Fail 树上子树中所有节点的权值和。\n\n对于子树权值和，我们可以用 DFS 序 + 树状数组维护。根据按照操作序列重新遍历 AC 自动机，进入每个节点时，它在 Fail 树上对应节点的权值置为 $ 1 $，退出时置为 $ 0 $，每次走到一个单词节点时，处理由该节点作为 $ y $ 的所有询问。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next, *p;\n\t\tint id;\n\t\tbool isWord;\n\t\tstruct Query {\n\t\t\tNode *x;\n\t\t\tint *ans;\n\n\t\t\tQuery(Node *x, int *ans) : x(x), ans(ans) {}\n\t\t};\n\t\tstd::vector<Query> q;\n\n\t\tNode(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tint init(const char *s, std::vector<Node *> &vec) {\n\t\tint cnt = 0;\n\t\tNode *v = root = new Node(NULL, false, cnt++);\n\t\tfor (const char *p = s; *p; p++) {\n\t\t\tassert(*p == 'P' || *p == 'B' || (*p >= 'a' && *p <= 'z'));\n\t\t\tif (*p == 'P') v->isWord = true, vec.push_back(v);\n\t\t\telse if (*p == 'B') v = v->p;\n\t\t\telse {\n\t\t\t\tif (!v->c[*p - BASE_CHAR]) v->c[*p - BASE_CHAR] = new Node(v, false, cnt++);\n\t\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root, root->next = NULL;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tassert(v->q.size() < MAXN);\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t\tassert(v->q.size() < MAXN);\n\t\t\t\tassert(c->q.size() < MAXN);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tNode *p, *c, *next;\n\tint l, r;\n\tbool v;\n} N[MAXN];\n\nint n;\n\ninline void addEdge(const int p, const int c) {\n\t// printf(\"addEdge(%d, %d)\\n\", p, c);\n\tN[c].next = N[p].c;\n\tN[p].c = &N[c];\n\tN[c].p = &N[p];\n}\n\ninline void buildFailTree() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *&c = v->c[i];\n\t\t\tif (!c) continue;\n\t\t\taddEdge(c->fail->id, c->id);\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void dfs() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->v) {\n\t\t\tv->v = true;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Node *c = v->c; c; c = c->next) s.push(c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint query(const int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) ans += a[i];\n\t\treturn ans;\n\t}\n} bit;\n\nchar op[MAXN + 1];\ninline void solve() {\n\tbit.init(n);\n\tTrie::Node *y = t.root;\n\tfor (const char *p = op; *p; p++) {\n\t\tif (*p == 'P') {\n\t\t\tfor (std::vector<Trie::Node::Query>::iterator it = y->q.begin(); it != y->q.end(); it++) {\n\t\t\t\t*it->ans = bit.query(N[it->x->id].r) - bit.query(N[it->x->id].l - 1);\n\t\t\t}\n\t\t} else if (*p == 'B') {\n\t\t\tbit.update(N[y->id].l, -1);\n\t\t\ty = y->p;\n\t\t} else {\n\t\t\ty = y->c[*p - BASE_CHAR];\n\t\t\tbit.update(N[y->id].l, 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", op);\n\n\tstd::vector<Trie::Node *> vec;\n\tn = t.init(op, vec);\n\tt.build();\n\n\tbuildFailTree();\n\tdfs();\n\n\tint m;\n\tstatic int ans[MAXN];\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\t\tvec[y]->q.push_back(Trie::Node::Query(vec[x], &ans[i]));\n\t}\n\n\tsolve();\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","slug":"noi2011-type","published":1,"updated":"2016-09-11T23:53:53.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rpt00s9ooxl7iak3jm3"},{"title":"「NOI2008」糖果雨 - 坐标变换 + 二维树状数组","date":"2016-12-23T10:00:00.000Z","_content":"\n在一个长度为 $ \\mathrm{len} $ 的区间上，有以下操作：\n\n1. 在 $ t $ 时刻，出现一条线段 $ [l, r] $，这条线段将要向左或向右移动；\n2. 在 $ t $ 时刻查询与线段 $ [l, r] $ 有公共点的线段有多少；\n3. 在 $ t $ 时刻某条线段消失。\n\n每一时刻，每条线段都会移动，线段的左端点最小为 $ 0 $，当一条向左移动的线段**左端点**碰到 $ 0 $ 时，下一时刻它会改为向右移动；当一条向右移动的线段**左端点**碰到 $ \\mathrm{len} $ 时，下一时刻它会改为向左移动。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1062](http://www.lydsy.com/JudgeOnline/problem.php?id=1062)\n\n### 题解\n首先，考虑将整个区间翻倍，变成 $ [0, 2\\mathrm{len}] $。原本向右移动的线段，仍然在原来的位置上；原本移动到当线段左端点触碰右边界时改变移动方向，现在使这些线段继续向右移动，直到左端点触碰到 $ 2\\mathrm{len} $，立即回到 $ 0 $ 位置。这样转化保证了以 $ 2\\mathrm{len} $ 为周期的性质不变。\n\n![以 2len 为周期的循环](noi2008-candy/1.svg?)\n\n对于一条在 $ t $ 时刻出现的线段 $ [l, r] $，我们可以求出它到达 $ 0 $ 位置（在模 $ 2\\mathrm{len} $ 的意义下）时的时刻，设它为 $ x $（$ x \\in [0, 2\\mathrm{len}) $）。如果线段向右移动，则 $ x \\equiv t - l \\pmod {2\\mathrm{len}} $，否则 $ x \\equiv t + l \\pmod {2\\mathrm{len}} $。设 $ y = r - l $，即线段长度。这样，所有线段均可化为 $ (x, y) $ 的形式。\n\n考虑对每一次查询有贡献的点，在 $ t $ 时刻查询与 $ [l, r] $ 有公共点的线段数量，首先考虑当 $ t = 0 $ 时的简化问题，并且只考虑题意中在 $ 0 $ 时刻向右运动的线段（转化后左端点在 $ [0, \\mathrm{len}] $ 内）：\n\n* 如果一条线段在 $ 0 $ 时刻出现在 $ 0 $ 位置，那么它的长度至少需要至少 $ l $；\n* 如果一条线段在 $ -1 $ 时刻出现在 $ 0 $ 位置，注意这里是模意义下的 $ -1 $ 时刻，实际上它可能是在整体时间的前一个周期的 $ 2 \\mathrm{len} - 1 $ 时刻出现在 $ 0 $ 位置，这个周期的 $ 0 $ 时刻，它移动到 $ 1 $ 位置，所以只需要长度至少为 $ l - 1 $；\n* 如果在 $ -2 $ 位置，以此类推，需要线段的长度至少为 $ l - 2 $。\n* ……\n* 如果在 $ -l $ 时刻出现，需要线段的长度至少为 $ 0 $；\n* ……\n* 如果在 $ -r $ 时刻出现，需要线段的长度至少为 $ 0 $；\n* 如果在 $ -r - 1 $ 时刻出现，这个周期的 $ 0 $ 时刻，它移动到 $ r + 1 $ 位置，已经越过查询的区间，此时这条线段对答案没有贡献。\n\n对答案有贡献的区域在平面上组成了一个五边形，它是由一个矩形去掉一个等腰三角形后得到的（图中的棕黄色部分）。在它的上边和下边分别补上一个三角形，得到一个如下的平行四边形：\n\n![将五边形补为平行四边形](noi2008-candy/2.svg)\n\n继续考虑正时刻出现的线段，如果一条线段 $ A $ 在 $ 1 $ 时刻出现在 $ 0 $ 位置，并开始向右移动，那么考虑原题中对移动方向的描述，假设有另一条线段 $ B $ 在 $ 0 $ 时刻出现在 $ 0 $ 位置，那么最初向右移动时，$ A $ 总在 $ B $ 左边一个单位处（$ B $ 较早开始移动）。$ B $ 移动到右边界时，比 $ A $ 早一个单位时间开始变为向左移动，所以，在向左移动的过程中，$ A $ 总在 $ B $ 右边一个单位处。\n\n线段 $ A $ 一定是在上一个周期或之前周期的 $ 1 $ 时刻出现的，在这个周期的 $ 0 $ 时刻，它移动了 $ 2\\mathrm{len} - 1 $ 个单位，到达 $ 2\\mathrm{len} - 1 $ 处，而这里恰好对应了原题中向左移动且左端点在 $ 1 $ 位置处。这时线段 $ A $ 的长度至少要 $ l - 1 $ 才能对答案有贡献。\n\n以此类推：\n\n* 如果一条线段在 $ 0 $ 时刻出现在 $ 2 $ 位置，那么它的长度至少需要 $ l - 2 $；\n* ……\n* 如果在 $ l $ 时刻出现，需要线段的长度为 $ 0 $；\n* ……\n* 如果在 $ r $ 时刻出现，需要线段的长度为 $ 0 $；\n* 如果在 $ r + 1 $ 时刻出现，这个周期的 $ 0 $ 时刻，它移动到 $ r + 1 $ 位置，还没有到达查询的区间，此时这条线段对答案没有贡献。\n\n对答案有贡献的区域在平面上组成了一个与之前的五边形对称的图形，使用类似的方法将其补为一个平行四边形：\n\n![另一个平行四边形（右）](noi2008-candy/3.svg)\n\n现在考虑查询 $ t \\neq 0 $ 的情况，显然在模意义下，$ t \\in [0, 2\\mathrm{len}) $。如果查询 $ 1 $ 时刻的某个区间，则相当于让所有线段多移动 $ 1 $ 个单位时间，然后查询 $ 0 $ 时刻的这个区间，即相当于所有线段的产生时间都早了一个单位时间，即把坐标系内所有点向左平移一个单位 —— 将查询的平行四边形向右平移一个单位即可。\n\n在上图的坐标系中，横坐标表示线段出现在 $ 1 $ 位置的时刻，而时刻是关于 $ 2\\mathrm{len} $ 取模的，所以我们可以把左边的平行四边形向右平移 $ 2\\mathrm{len} $ 个单位，即：\n\n![将左边的平行四边形根据模系平移](noi2008-candy/4.svg)\n\n**注意：**右边的平行四边形在 $ t \\neq 0 $ 时，右边会有一部分不在 $ [0, 2\\mathrm{len}) $ 内，但是在模的意义下，这一部分应该对应左边紧靠 $ 0 $ 的一部分，为了保证这一部分能计算出正确结果，我们把坐标系的 $ [0, 2\\mathrm{len}) $ 复制到 $ [2\\mathrm{len}, 4\\mathrm{len}) $。\n\n当查询的 $ r = \\mathrm{len} $ 时，两个平行四边形在有一条公共边，如下图：\n\n![两个平行四边形的公共边](noi2008-candy/5.svg)\n\n为了不重复统计，需要把右边的平行四边形的左边界 $ +1 $。\n\n当查询的 $ l = r = 0 $ 时，两个平行四边形均退化成线段，并且重合，此时可以直接忽略掉右边的平行四边形。\n\n现在问题转化为，在平面内，每次插入或删除一个点，查询两个平行四边形的并的点的数量。\n\n平行四边形很难用数据结构来维护，所以考虑变换坐标，将平行四边形变成矩形 —— 因为两个平行四边形除与 $ y $ 轴平行的边以外，斜率均为 $ 1 $ 或 $ -1 $。所以将左边平行四边形的所有点纵座标加上横坐标，右边平行四边形上所有点的纵座标减去横坐标，得到两个矩形：\n\n![坐标变换的第一步](noi2008-candy/6.svg)\n\n发现右边的矩形在第四象限内，为了使它的坐标全部为正，我们对其纵座标全部加上 $ 2\\mathrm{len} $。\n\n![坐标变换的第二步](noi2008-candy/7.svg)\n\n如果将原坐标系的内容复制一份接到右边，则需要加上 $ 4\\mathrm{len} $ 才能使四个矩形的纵座标全部为正，此时整个坐标系的范围长宽均为 $ 4\\mathrm{len} $。\n\n因为两边的平行四边形坐标变换的方式不完全相同，所以需要两个坐标系，分别对所有插入的点做对应的坐标变换。\n\n问题最终转化为，在平面内插入一个点，删除一个点，查询一个矩形范围内的点的数量 —— 使用二维树状数组解决即可。\n\n时间复杂度为 $ O(n \\log ^ 2 \\mathrm{len}) $，空间复杂度为 $ O(\\mathrm{len} ^ 2) $，空间大约带一个 $ 32 $ 倍的常数。\n\n### 代码\n无调试代码版：\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n\t\treturn res;\n\t}\n} bit1, bit2;\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n\ninline void transform(int &x, int &y, int i) {\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n}\n\ninline void add(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n带调试代码版：\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\n#ifndef FORCE\nstruct BinaryIndexedTree;\nBinaryIndexedTree *_bit1, *_bit2;\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n#ifdef DBG_BIT\n\t\tprintf(\"init(%d, %d)\\n\", n, m);\n#endif\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n#ifdef DBG_BIT\n\t\tprintf(\"update(%d, %d, %d, %d)\\n\", this == ::_bit1 ? 1 : 2, x, y, delta);\n#endif\n\t\tassert(x >= 0);\n\t\tassert(y >= 0);\n#ifdef FORCE_BIT\n\t\ta[x][y] += delta;\n#else\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n#ifdef FORCE_BIT\n\t\tfor (int i = x; i >= 0; i--) {\n\t\t\tfor (int j = y; j >= 0; j--) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n#endif\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n#ifdef FORCE_BIT\n\t\tint res = 0;\n\t\tfor (int i = x1; i <= x2; i++) {\n\t\t\tfor (int j = y1; j <= y2; j++) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n#endif\n#ifdef DBG_BIT\n\t\tprintf(\"query(%d, %d, %d, %d, %d) = %d\\n\", this == ::_bit1 ? 1 : 2, x1, y1, x2, y2, res);\n#endif\n\t\treturn res;\n\t}\n} bit1, bit2;\n#endif\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n#ifdef FORCE\nint a[MAXLEN * 4 + 5][MAXLEN * 2 + 5];\n#endif\n\ninline void transform(int &x, int &y, int i) {\n#ifdef DBG\n\tprintf(\"transform(%d, %d, %d) = \", x, y, i);\n#endif\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n#ifdef DBG\n\tprintf(\"(%d, %d)\\n\", x, y);\n#endif\n}\n\ninline void add(int x, int y) {\n\t// printf(\"add(%d, %d)\\n\", x, y);\n#ifdef FORCE\n\ta[x][y]++;\n\t// a[x + len * 2][y]++;\n#else\n#ifdef DBG\n\tprintf(\"add(%d, %d)\\n\", x, y);\n#endif\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\t/*\n\tbit1.update(x, y + x, 1);\n\tbit2.update(x, y + (len * 2 - x), 1);\n\n\tbit1.update(x + len * 2, y + x, 1);\n\tbit2.update(x + len * 2, y + (len * 2 - x), 1);\n\t*/\n#endif\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n#ifdef FORCE\n\ta[x][y]--;\n\t// a[x + len * 2][y]--;\n#else\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n#endif\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n#ifdef FORCE\n\t// printf(\"query(%d, %d, %d)\\n\", t, l, r);\n\tstatic bool added[MAXLEN * 2 + 5][MAXLEN + 5];\n\tmemset(added, 0, sizeof(added));\n\tint ans = 0;\n\tfor (int i = 0, start = l; i <= r; i++, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = len * 2, start = l; i >= len * 2 - r; i--, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n#else\n#ifdef DBG\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r, //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r);  //\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r,   //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r);//\n#endif\n\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n#endif\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n#ifndef FORCE_BIT\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\t_bit1 = &bit1, _bit2 = &bit2;\n#endif\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2008-candy.md","raw":"title: 「NOI2008」糖果雨 - 坐标变换 + 二维树状数组\ncategories: OI\ntags: \n  - BZOJ\n  - NOI\n  - 坐标变换\n  - 树状数组\n  - 二维树状数组\npermalink: noi2008-candy\ndate: 2016-12-23 18:00:00\n---\n\n在一个长度为 $ \\mathrm{len} $ 的区间上，有以下操作：\n\n1. 在 $ t $ 时刻，出现一条线段 $ [l, r] $，这条线段将要向左或向右移动；\n2. 在 $ t $ 时刻查询与线段 $ [l, r] $ 有公共点的线段有多少；\n3. 在 $ t $ 时刻某条线段消失。\n\n每一时刻，每条线段都会移动，线段的左端点最小为 $ 0 $，当一条向左移动的线段**左端点**碰到 $ 0 $ 时，下一时刻它会改为向右移动；当一条向右移动的线段**左端点**碰到 $ \\mathrm{len} $ 时，下一时刻它会改为向左移动。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1062](http://www.lydsy.com/JudgeOnline/problem.php?id=1062)\n\n### 题解\n首先，考虑将整个区间翻倍，变成 $ [0, 2\\mathrm{len}] $。原本向右移动的线段，仍然在原来的位置上；原本移动到当线段左端点触碰右边界时改变移动方向，现在使这些线段继续向右移动，直到左端点触碰到 $ 2\\mathrm{len} $，立即回到 $ 0 $ 位置。这样转化保证了以 $ 2\\mathrm{len} $ 为周期的性质不变。\n\n![以 2len 为周期的循环](noi2008-candy/1.svg?)\n\n对于一条在 $ t $ 时刻出现的线段 $ [l, r] $，我们可以求出它到达 $ 0 $ 位置（在模 $ 2\\mathrm{len} $ 的意义下）时的时刻，设它为 $ x $（$ x \\in [0, 2\\mathrm{len}) $）。如果线段向右移动，则 $ x \\equiv t - l \\pmod {2\\mathrm{len}} $，否则 $ x \\equiv t + l \\pmod {2\\mathrm{len}} $。设 $ y = r - l $，即线段长度。这样，所有线段均可化为 $ (x, y) $ 的形式。\n\n考虑对每一次查询有贡献的点，在 $ t $ 时刻查询与 $ [l, r] $ 有公共点的线段数量，首先考虑当 $ t = 0 $ 时的简化问题，并且只考虑题意中在 $ 0 $ 时刻向右运动的线段（转化后左端点在 $ [0, \\mathrm{len}] $ 内）：\n\n* 如果一条线段在 $ 0 $ 时刻出现在 $ 0 $ 位置，那么它的长度至少需要至少 $ l $；\n* 如果一条线段在 $ -1 $ 时刻出现在 $ 0 $ 位置，注意这里是模意义下的 $ -1 $ 时刻，实际上它可能是在整体时间的前一个周期的 $ 2 \\mathrm{len} - 1 $ 时刻出现在 $ 0 $ 位置，这个周期的 $ 0 $ 时刻，它移动到 $ 1 $ 位置，所以只需要长度至少为 $ l - 1 $；\n* 如果在 $ -2 $ 位置，以此类推，需要线段的长度至少为 $ l - 2 $。\n* ……\n* 如果在 $ -l $ 时刻出现，需要线段的长度至少为 $ 0 $；\n* ……\n* 如果在 $ -r $ 时刻出现，需要线段的长度至少为 $ 0 $；\n* 如果在 $ -r - 1 $ 时刻出现，这个周期的 $ 0 $ 时刻，它移动到 $ r + 1 $ 位置，已经越过查询的区间，此时这条线段对答案没有贡献。\n\n对答案有贡献的区域在平面上组成了一个五边形，它是由一个矩形去掉一个等腰三角形后得到的（图中的棕黄色部分）。在它的上边和下边分别补上一个三角形，得到一个如下的平行四边形：\n\n![将五边形补为平行四边形](noi2008-candy/2.svg)\n\n继续考虑正时刻出现的线段，如果一条线段 $ A $ 在 $ 1 $ 时刻出现在 $ 0 $ 位置，并开始向右移动，那么考虑原题中对移动方向的描述，假设有另一条线段 $ B $ 在 $ 0 $ 时刻出现在 $ 0 $ 位置，那么最初向右移动时，$ A $ 总在 $ B $ 左边一个单位处（$ B $ 较早开始移动）。$ B $ 移动到右边界时，比 $ A $ 早一个单位时间开始变为向左移动，所以，在向左移动的过程中，$ A $ 总在 $ B $ 右边一个单位处。\n\n线段 $ A $ 一定是在上一个周期或之前周期的 $ 1 $ 时刻出现的，在这个周期的 $ 0 $ 时刻，它移动了 $ 2\\mathrm{len} - 1 $ 个单位，到达 $ 2\\mathrm{len} - 1 $ 处，而这里恰好对应了原题中向左移动且左端点在 $ 1 $ 位置处。这时线段 $ A $ 的长度至少要 $ l - 1 $ 才能对答案有贡献。\n\n以此类推：\n\n* 如果一条线段在 $ 0 $ 时刻出现在 $ 2 $ 位置，那么它的长度至少需要 $ l - 2 $；\n* ……\n* 如果在 $ l $ 时刻出现，需要线段的长度为 $ 0 $；\n* ……\n* 如果在 $ r $ 时刻出现，需要线段的长度为 $ 0 $；\n* 如果在 $ r + 1 $ 时刻出现，这个周期的 $ 0 $ 时刻，它移动到 $ r + 1 $ 位置，还没有到达查询的区间，此时这条线段对答案没有贡献。\n\n对答案有贡献的区域在平面上组成了一个与之前的五边形对称的图形，使用类似的方法将其补为一个平行四边形：\n\n![另一个平行四边形（右）](noi2008-candy/3.svg)\n\n现在考虑查询 $ t \\neq 0 $ 的情况，显然在模意义下，$ t \\in [0, 2\\mathrm{len}) $。如果查询 $ 1 $ 时刻的某个区间，则相当于让所有线段多移动 $ 1 $ 个单位时间，然后查询 $ 0 $ 时刻的这个区间，即相当于所有线段的产生时间都早了一个单位时间，即把坐标系内所有点向左平移一个单位 —— 将查询的平行四边形向右平移一个单位即可。\n\n在上图的坐标系中，横坐标表示线段出现在 $ 1 $ 位置的时刻，而时刻是关于 $ 2\\mathrm{len} $ 取模的，所以我们可以把左边的平行四边形向右平移 $ 2\\mathrm{len} $ 个单位，即：\n\n![将左边的平行四边形根据模系平移](noi2008-candy/4.svg)\n\n**注意：**右边的平行四边形在 $ t \\neq 0 $ 时，右边会有一部分不在 $ [0, 2\\mathrm{len}) $ 内，但是在模的意义下，这一部分应该对应左边紧靠 $ 0 $ 的一部分，为了保证这一部分能计算出正确结果，我们把坐标系的 $ [0, 2\\mathrm{len}) $ 复制到 $ [2\\mathrm{len}, 4\\mathrm{len}) $。\n\n当查询的 $ r = \\mathrm{len} $ 时，两个平行四边形在有一条公共边，如下图：\n\n![两个平行四边形的公共边](noi2008-candy/5.svg)\n\n为了不重复统计，需要把右边的平行四边形的左边界 $ +1 $。\n\n当查询的 $ l = r = 0 $ 时，两个平行四边形均退化成线段，并且重合，此时可以直接忽略掉右边的平行四边形。\n\n现在问题转化为，在平面内，每次插入或删除一个点，查询两个平行四边形的并的点的数量。\n\n平行四边形很难用数据结构来维护，所以考虑变换坐标，将平行四边形变成矩形 —— 因为两个平行四边形除与 $ y $ 轴平行的边以外，斜率均为 $ 1 $ 或 $ -1 $。所以将左边平行四边形的所有点纵座标加上横坐标，右边平行四边形上所有点的纵座标减去横坐标，得到两个矩形：\n\n![坐标变换的第一步](noi2008-candy/6.svg)\n\n发现右边的矩形在第四象限内，为了使它的坐标全部为正，我们对其纵座标全部加上 $ 2\\mathrm{len} $。\n\n![坐标变换的第二步](noi2008-candy/7.svg)\n\n如果将原坐标系的内容复制一份接到右边，则需要加上 $ 4\\mathrm{len} $ 才能使四个矩形的纵座标全部为正，此时整个坐标系的范围长宽均为 $ 4\\mathrm{len} $。\n\n因为两边的平行四边形坐标变换的方式不完全相同，所以需要两个坐标系，分别对所有插入的点做对应的坐标变换。\n\n问题最终转化为，在平面内插入一个点，删除一个点，查询一个矩形范围内的点的数量 —— 使用二维树状数组解决即可。\n\n时间复杂度为 $ O(n \\log ^ 2 \\mathrm{len}) $，空间复杂度为 $ O(\\mathrm{len} ^ 2) $，空间大约带一个 $ 32 $ 倍的常数。\n\n### 代码\n无调试代码版：\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n\t\treturn res;\n\t}\n} bit1, bit2;\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n\ninline void transform(int &x, int &y, int i) {\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n}\n\ninline void add(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n带调试代码版：\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\n#ifndef FORCE\nstruct BinaryIndexedTree;\nBinaryIndexedTree *_bit1, *_bit2;\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n#ifdef DBG_BIT\n\t\tprintf(\"init(%d, %d)\\n\", n, m);\n#endif\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n#ifdef DBG_BIT\n\t\tprintf(\"update(%d, %d, %d, %d)\\n\", this == ::_bit1 ? 1 : 2, x, y, delta);\n#endif\n\t\tassert(x >= 0);\n\t\tassert(y >= 0);\n#ifdef FORCE_BIT\n\t\ta[x][y] += delta;\n#else\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n#ifdef FORCE_BIT\n\t\tfor (int i = x; i >= 0; i--) {\n\t\t\tfor (int j = y; j >= 0; j--) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n#endif\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n#ifdef FORCE_BIT\n\t\tint res = 0;\n\t\tfor (int i = x1; i <= x2; i++) {\n\t\t\tfor (int j = y1; j <= y2; j++) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n#endif\n#ifdef DBG_BIT\n\t\tprintf(\"query(%d, %d, %d, %d, %d) = %d\\n\", this == ::_bit1 ? 1 : 2, x1, y1, x2, y2, res);\n#endif\n\t\treturn res;\n\t}\n} bit1, bit2;\n#endif\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n#ifdef FORCE\nint a[MAXLEN * 4 + 5][MAXLEN * 2 + 5];\n#endif\n\ninline void transform(int &x, int &y, int i) {\n#ifdef DBG\n\tprintf(\"transform(%d, %d, %d) = \", x, y, i);\n#endif\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n#ifdef DBG\n\tprintf(\"(%d, %d)\\n\", x, y);\n#endif\n}\n\ninline void add(int x, int y) {\n\t// printf(\"add(%d, %d)\\n\", x, y);\n#ifdef FORCE\n\ta[x][y]++;\n\t// a[x + len * 2][y]++;\n#else\n#ifdef DBG\n\tprintf(\"add(%d, %d)\\n\", x, y);\n#endif\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\t/*\n\tbit1.update(x, y + x, 1);\n\tbit2.update(x, y + (len * 2 - x), 1);\n\n\tbit1.update(x + len * 2, y + x, 1);\n\tbit2.update(x + len * 2, y + (len * 2 - x), 1);\n\t*/\n#endif\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n#ifdef FORCE\n\ta[x][y]--;\n\t// a[x + len * 2][y]--;\n#else\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n#endif\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n#ifdef FORCE\n\t// printf(\"query(%d, %d, %d)\\n\", t, l, r);\n\tstatic bool added[MAXLEN * 2 + 5][MAXLEN + 5];\n\tmemset(added, 0, sizeof(added));\n\tint ans = 0;\n\tfor (int i = 0, start = l; i <= r; i++, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = len * 2, start = l; i >= len * 2 - r; i--, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n#else\n#ifdef DBG\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r, //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r);  //\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r,   //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r);//\n#endif\n\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n#endif\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n#ifndef FORCE_BIT\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\t_bit1 = &bit1, _bit2 = &bit2;\n#endif\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2008-candy","published":1,"updated":"2016-12-23T10:00:56.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rq200sfooxly4o781l4"},{"title":"「NOI2006」最大获利 - 最大权闭合图","date":"2016-03-10T11:33:42.000Z","_content":"\n在前期市场调查和站址勘测之后，公司得到了一共 $ N $ 个可以作为通讯信号中转站的地址，建立第 $ i $ 个通讯中转站需要的成本为 $ Pi $（$ 1 ≤ i ≤ N $）。另外公司调查得出了所有期望中的用户群，一共 $ M $ 个。关于第 $ i $ 个用户群的信息概括为 $ Ai $, $ Bi $ 和 $ Ci $：这些用户会使用中转站 $ Ai $ 和中转站 $ Bi $ 进行通讯，公司可以获益 $ Ci $。（$ 1 ≤ i ≤ M $，$ 1 ≤ Ai $，$ Bi ≤ N $）公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？\n\n<!-- more -->\n\n### 链接\n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### 题解\n裸的最大权闭合图，用最小割。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2006-profit.md","raw":"title: 「NOI2006」最大获利 - 最大权闭合图\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - 图论\n  - 网络流\n  - 最小割\n  - 最大权闭合图\n  - Dinic\npermalink: noi2006-profit\ndate: 2016-03-10 19:33:42\n---\n\n在前期市场调查和站址勘测之后，公司得到了一共 $ N $ 个可以作为通讯信号中转站的地址，建立第 $ i $ 个通讯中转站需要的成本为 $ Pi $（$ 1 ≤ i ≤ N $）。另外公司调查得出了所有期望中的用户群，一共 $ M $ 个。关于第 $ i $ 个用户群的信息概括为 $ Ai $, $ Bi $ 和 $ Ci $：这些用户会使用中转站 $ Ai $ 和中转站 $ Bi $ 进行通讯，公司可以获益 $ Ci $。（$ 1 ≤ i ≤ M $，$ 1 ≤ Ai $，$ Bi ≤ N $）公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？\n\n<!-- more -->\n\n### 链接\n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### 题解\n裸的最大权闭合图，用最小割。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"noi2006-profit","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rqx00soooxllb590yw9"},{"title":"「NOI2004」郁闷的出纳员 - Splay","id":"37","updated":"2016-01-24T15:11:06.000Z","date":"2016-01-24T15:09:03.000Z","_content":"\n工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，现在工资第 `k` 多的员工拿多少工资。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### 题解\n这是道 Splay 入门题，多思考思考还是挺容易的。\n\n唯一的难点貌似在同时修改工资，这时候只要像维护数列那样弄一个标记，然后向下传就好咯。扣工资时直接删掉 $[-{\\infty}+1,min-1]$ 范围内的节点就好。\n\n还有统计离开公司人数，一开始还在想删除时用了辅助节点，不知道该怎么算，一想才知道，直接看整棵树的大小变了多少嘛！\n\n第四次敲 Splay，在从临沂经西安到成都的飞机上用了一个小时。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","source":"_posts/noi2004-cashier.md","raw":"title: 「NOI2004」郁闷的出纳员 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - Splay\n  - 高级数据结构\n  - 数据结构\npermalink: noi2004-cashier\nid: 37\nupdated: '2016-01-24 23:11:06'\ndate: 2016-01-24 23:09:03\n---\n\n工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，现在工资第 `k` 多的员工拿多少工资。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### 题解\n这是道 Splay 入门题，多思考思考还是挺容易的。\n\n唯一的难点貌似在同时修改工资，这时候只要像维护数列那样弄一个标记，然后向下传就好咯。扣工资时直接删掉 $[-{\\infty}+1,min-1]$ 范围内的节点就好。\n\n还有统计离开公司人数，一开始还在想删除时用了辅助节点，不知道该怎么算，一想才知道，直接看整棵树的大小变了多少嘛！\n\n第四次敲 Splay，在从临沂经西安到成都的飞机上用了一个小时。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","slug":"noi2004-cashier","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rr500szooxl5spvxvdd"},{"title":"「NOI2003」文本编辑器 - Splay","date":"2016-03-06T11:49:35.000Z","_content":"\n|        操作名称        | 输入文件中的格式 | 功能 |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         | 将光标移动到第 $ k $ 个字符之后，如果 $ k=0 $，将光标移到文本第一个字符之前 |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     | 在光标后插入长度为 $ n $ 的字符串 $ s $，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       | 删除光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          | 输出光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | 光标前移一个字符\n| $ {\\rm NEXT}() $       | `Next`           | 光标后移一个字符\n\n<!-- more -->\n\n### 链接\n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### 题解\n块状链表太鬼畜辣！还是 Splay 比较好写好调w\n\n一点小技巧，插入的时候可以照着选择区间的方法选出一段空白区间，然后 `build` 出一棵子树给接上去，可以少一个 $ \\log $。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2003-editor.md","raw":"title: 「NOI2003」文本编辑器 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - Splay\n  - 高级数据结构\n  - 数据结构\npermalink: noi2003-editor\ndate: 2016-03-06 19:49:35\n---\n\n|        操作名称        | 输入文件中的格式 | 功能 |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         | 将光标移动到第 $ k $ 个字符之后，如果 $ k=0 $，将光标移到文本第一个字符之前 |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     | 在光标后插入长度为 $ n $ 的字符串 $ s $，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       | 删除光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          | 输出光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | 光标前移一个字符\n| $ {\\rm NEXT}() $       | `Next`           | 光标后移一个字符\n\n<!-- more -->\n\n### 链接\n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### 题解\n块状链表太鬼畜辣！还是 Splay 比较好写好调w\n\n一点小技巧，插入的时候可以照着选择区间的方法选出一段空白区间，然后 `build` 出一棵子树给接上去，可以少一个 $ \\log $。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2003-editor","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rrk00t7ooxlvthp0h3z"},{"title":"「NOI2002」银河英雄传说 - 并查集","id":"2","updated":"2016-01-19T13:08:24.000Z","date":"2015-11-22T17:14:53.000Z","_content":"\n有 30000 个元素，初始时每个元素以单独的队列形式存在，支持一下两种操作：\n\n1.动态合并两条队列，将 `x` 元素所在队列首合并在 `y` 元素所在队列尾；  \n2.查询 `x` 与 `y` 是否在同一条队列中，若是，查询 `x` 与 `y` 间隔元素数量。\n\n共 500,000 次操作。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### 题解\n由「查询」操作，考虑到使用并查集。用并查集维护两个元素是否在同一队列中，可以对查询是否在同一队列中作出回答。  \n考虑将并查集扩展，维护每一个元素**所在队列**的队首和队尾。\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n然后就是查询间隔数量，这里采用前缀和的方式。\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)` 的计算方法，根据合并时对 `head` 数组进行的修改，可得 `find_head(x)` 的迭代次数即为 `x` 到 `x` 所在队队首的元素数量。\n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n使用这种方式维护并查集，不能对并查集使用路径压缩的优化，故整个算法时间复杂度为 $O(nm)$。  \n所以 …… Boom！  \n\n解决方法：在进行路径压缩的同时，维护每一个 `x` 到 `head[x]` 的「距离」 `prefix[x]`。  \n在 `find(x)` 或者 `pre(x)` 每一次迭代时，进行路径压缩，并把 `prefix[x]` 加上 `pre(head[x])`，即**队列中在 `x` 元素之前的元素的「前缀和」**。  \n\n注意：  \n 1.**当迭代到根节点下时，不能对 `prefix[x]` 做修改。**  \n 2.队首元素，即**满足 `head[x] == x` 的元素**的前缀和应总是0。  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn prefix[x];\n}\n```\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### 吐槽\n这是当年 NOI2002 的一道水（大雾）题。  \n刚开始学并查集的时候尝试做过这题，然后 …… 然后就没有然后了。  \n今天突然想起这题，就用了一个小时把它 A 掉了。","source":"_posts/noi2002-galaxy.md","raw":"title: 「NOI2002」银河英雄传说 - 并查集\ncategories: OI\ntags: \n  - CodeVS\n  - NOI\n  - 并查集\npermalink: noi2002-galaxy\nid: 2\nupdated: '2016-01-19 21:08:24'\ndate: 2015-11-23 01:14:53\n---\n\n有 30000 个元素，初始时每个元素以单独的队列形式存在，支持一下两种操作：\n\n1.动态合并两条队列，将 `x` 元素所在队列首合并在 `y` 元素所在队列尾；  \n2.查询 `x` 与 `y` 是否在同一条队列中，若是，查询 `x` 与 `y` 间隔元素数量。\n\n共 500,000 次操作。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### 题解\n由「查询」操作，考虑到使用并查集。用并查集维护两个元素是否在同一队列中，可以对查询是否在同一队列中作出回答。  \n考虑将并查集扩展，维护每一个元素**所在队列**的队首和队尾。\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n然后就是查询间隔数量，这里采用前缀和的方式。\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)` 的计算方法，根据合并时对 `head` 数组进行的修改，可得 `find_head(x)` 的迭代次数即为 `x` 到 `x` 所在队队首的元素数量。\n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n使用这种方式维护并查集，不能对并查集使用路径压缩的优化，故整个算法时间复杂度为 $O(nm)$。  \n所以 …… Boom！  \n\n解决方法：在进行路径压缩的同时，维护每一个 `x` 到 `head[x]` 的「距离」 `prefix[x]`。  \n在 `find(x)` 或者 `pre(x)` 每一次迭代时，进行路径压缩，并把 `prefix[x]` 加上 `pre(head[x])`，即**队列中在 `x` 元素之前的元素的「前缀和」**。  \n\n注意：  \n 1.**当迭代到根节点下时，不能对 `prefix[x]` 做修改。**  \n 2.队首元素，即**满足 `head[x] == x` 的元素**的前缀和应总是0。  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn prefix[x];\n}\n```\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### 吐槽\n这是当年 NOI2002 的一道水（大雾）题。  \n刚开始学并查集的时候尝试做过这题，然后 …… 然后就没有然后了。  \n今天突然想起这题，就用了一个小时把它 A 掉了。","slug":"noi2002-galaxy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rrp00teooxlvdm3u5f0"},{"title":"点分治学习笔记","date":"2016-06-17T08:36:00.000Z","_content":"\n点分治是用来解决树上路径问题的一种方法。\n\n<!-- more -->\n\n在解决树上路径问题时，我们可以选取一点为根，将树转化为有根树，然后考虑**经过根**的所有路径（有时将两条从根出发的路径连接为一条）。统计完这些路径的答案后，将根节点标记为删除，对剩下的若干棵树进行同样的操作。\n\n![](node-devide-notes/tree1.svg)\n\n如图，我们可以先考虑经过节点 $ 1 $ 的路径，之后将节点 $ 1 $ 标记为删除，此时可以认为考虑过的路径均已被删除。继续对其它子树做相同处理即可。\n\n每次确认一个根节点后，共有 $ n $ 条需要考虑的路径（$ n $ 为当前子树大小）。上图中将 $ 1 $ 删除后，剩下左侧的子树较大，和原树大小相当，继续处理这棵子树时仍然需要与前一过程相当的时间。\n\n最严重的情况，当整棵树是一条链时，每次需要考虑的路径数量是 $ O(n) $ 级别的，如果每条路径需要常数时间进行统计，则总时间复杂度为 $ O(n ^ 2) $。而对于形态随机的树，则远远小于这个级别。\n\n如果我们选择 $ 5 $ 作为这棵树的根节点，情况会好很多 —— 删除 $ 5 $ 后剩余的最大一棵子树的大小比删除 $ 1 $ 时要小。这说明「科学地」选择点作为根节点可以有效的降低复杂度。\n\n### 重心\n我们定义一棵树的**重心**为以该点为根时**最大子树最小**的点。\n\n> 性质：以重心为根，任意一棵子树的大小都不超过整棵树大小的一半。\n\n证明：从树上任取一点，以它为根，如果最大的一棵子树大小不超过整棵树大小的一半，则它为重心。否则选择最大子树的根节点，继续这个过程，最终会得到一个点，它满足重心的性质，从这个点向任何方向走，最多有一个点同样满足重心的性质。  \n注意不会出现来回走，两个点都不满足性质的情况。假设有，则删掉这两个点后，剩下的两棵树的大小都至少为 $ n \\over 2 $，整棵树至少有 $ n + 2 $ 的点，不成立。\n\n求重心可以用一次 DFS 完成 —— 任选一个点为根做 DFS，记录每个节点的大小 $ {\\rm size}(i) = \\sum\\limits_{j \\in {\\rm child}(i)} {\\rm size}(j) + 1 $，记录最大子节点子树的大小 $ {\\rm max}(i) = \\max\\limits_{j \\in {\\rm child}(i)} \\{ {\\rm size}(j) \\} $。因为要同时考虑某个点的祖先（以这个点为根时这些点为它的一棵子树），所以使 $ \\max \\{ \\max(i),\\ n - \\max(i) \\} $ 最小的 $ i $ 即为重心。\n\n如果在点分治时每次使用重心为根，则最大的子树大小不会超过原树的二分之一，考虑到处理较小子树的代价原小于最大子树，若每个节点需要常数时间，根据主定理有\n\n$$ T(n) = 2 T(\\frac{n}{2}) + O(n) = O(n \\log n) $$\n\n如图，蓝色点为第一次选取的重心，删除蓝色点后，剩余几棵子树的重心为红色点，再向下一层的重心为黄色点，最后剩下一个白色点\n\n![](node-devide-notes/tree2.svg)\n\n### 模板\n已处理过的根将被置为 `solved`，任何时候不要经过这些点，这保证了复杂度分析中的 $ n $ 是当前子树的大小，而不是整棵树的大小。\n\n```c++\ninline Node *center(Node *start) {\n    std::stack<Node *> s;\n    s.push(start);\n    start->parent = NULL;\n    start->visited = false;\n\n    static Node *a[MAXN];\n    int cnt = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            a[cnt++] = v;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n                e->t->parent = v;\n                e->t->visited = false;\n                s.push(e->t);\n            }\n        } else {\n            v->size = 1;\n            v->max = 0;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n                v->size += e->t->size;\n                v->max = std::max(v->max, e->t->size);\n            }\n            s.pop();\n        }\n    }\n\n\n    Node *res = NULL;\n    for (int i = 0; i < cnt; i++) {\n        a[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n\n    return res;\n}\n\ninline int solve() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    int ans = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        s.pop();\n\n        Node *root = center(v);\n        root->solved = true;\n\n        ans += calc(root);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n            s.push(e->t);\n        }\n    }\n\n    return ans;\n}\n```\n","source":"_posts/node-devide-notes.md","raw":"title: 点分治学习笔记\ncategories: OI\ntags: \n  - 点分治\n  - 学习笔记\n  - 算法模板\n  - 数据结构\npermalink: node-devide-notes\ndate: 2016-06-17 16:36:00\n---\n\n点分治是用来解决树上路径问题的一种方法。\n\n<!-- more -->\n\n在解决树上路径问题时，我们可以选取一点为根，将树转化为有根树，然后考虑**经过根**的所有路径（有时将两条从根出发的路径连接为一条）。统计完这些路径的答案后，将根节点标记为删除，对剩下的若干棵树进行同样的操作。\n\n![](node-devide-notes/tree1.svg)\n\n如图，我们可以先考虑经过节点 $ 1 $ 的路径，之后将节点 $ 1 $ 标记为删除，此时可以认为考虑过的路径均已被删除。继续对其它子树做相同处理即可。\n\n每次确认一个根节点后，共有 $ n $ 条需要考虑的路径（$ n $ 为当前子树大小）。上图中将 $ 1 $ 删除后，剩下左侧的子树较大，和原树大小相当，继续处理这棵子树时仍然需要与前一过程相当的时间。\n\n最严重的情况，当整棵树是一条链时，每次需要考虑的路径数量是 $ O(n) $ 级别的，如果每条路径需要常数时间进行统计，则总时间复杂度为 $ O(n ^ 2) $。而对于形态随机的树，则远远小于这个级别。\n\n如果我们选择 $ 5 $ 作为这棵树的根节点，情况会好很多 —— 删除 $ 5 $ 后剩余的最大一棵子树的大小比删除 $ 1 $ 时要小。这说明「科学地」选择点作为根节点可以有效的降低复杂度。\n\n### 重心\n我们定义一棵树的**重心**为以该点为根时**最大子树最小**的点。\n\n> 性质：以重心为根，任意一棵子树的大小都不超过整棵树大小的一半。\n\n证明：从树上任取一点，以它为根，如果最大的一棵子树大小不超过整棵树大小的一半，则它为重心。否则选择最大子树的根节点，继续这个过程，最终会得到一个点，它满足重心的性质，从这个点向任何方向走，最多有一个点同样满足重心的性质。  \n注意不会出现来回走，两个点都不满足性质的情况。假设有，则删掉这两个点后，剩下的两棵树的大小都至少为 $ n \\over 2 $，整棵树至少有 $ n + 2 $ 的点，不成立。\n\n求重心可以用一次 DFS 完成 —— 任选一个点为根做 DFS，记录每个节点的大小 $ {\\rm size}(i) = \\sum\\limits_{j \\in {\\rm child}(i)} {\\rm size}(j) + 1 $，记录最大子节点子树的大小 $ {\\rm max}(i) = \\max\\limits_{j \\in {\\rm child}(i)} \\{ {\\rm size}(j) \\} $。因为要同时考虑某个点的祖先（以这个点为根时这些点为它的一棵子树），所以使 $ \\max \\{ \\max(i),\\ n - \\max(i) \\} $ 最小的 $ i $ 即为重心。\n\n如果在点分治时每次使用重心为根，则最大的子树大小不会超过原树的二分之一，考虑到处理较小子树的代价原小于最大子树，若每个节点需要常数时间，根据主定理有\n\n$$ T(n) = 2 T(\\frac{n}{2}) + O(n) = O(n \\log n) $$\n\n如图，蓝色点为第一次选取的重心，删除蓝色点后，剩余几棵子树的重心为红色点，再向下一层的重心为黄色点，最后剩下一个白色点\n\n![](node-devide-notes/tree2.svg)\n\n### 模板\n已处理过的根将被置为 `solved`，任何时候不要经过这些点，这保证了复杂度分析中的 $ n $ 是当前子树的大小，而不是整棵树的大小。\n\n```c++\ninline Node *center(Node *start) {\n    std::stack<Node *> s;\n    s.push(start);\n    start->parent = NULL;\n    start->visited = false;\n\n    static Node *a[MAXN];\n    int cnt = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            a[cnt++] = v;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n                e->t->parent = v;\n                e->t->visited = false;\n                s.push(e->t);\n            }\n        } else {\n            v->size = 1;\n            v->max = 0;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n                v->size += e->t->size;\n                v->max = std::max(v->max, e->t->size);\n            }\n            s.pop();\n        }\n    }\n\n\n    Node *res = NULL;\n    for (int i = 0; i < cnt; i++) {\n        a[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n\n    return res;\n}\n\ninline int solve() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    int ans = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        s.pop();\n\n        Node *root = center(v);\n        root->solved = true;\n\n        ans += calc(root);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n            s.push(e->t);\n        }\n    }\n\n    return ans;\n}\n```\n","slug":"node-devide-notes","published":1,"updated":"2016-06-17T08:37:21.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rrt00tjooxl26si2srg"},{"title":"乘法逆元的几种计算方法","date":"2016-04-13T04:11:17.000Z","_content":"\n乘法逆元是数论中重要的内容，也是 OI 中常用到的数论算法之一。所以，如何高效的求出乘法逆元是一个值得研究的问题。\n\n这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。\n\n<!-- more -->\n\n### 定义\n在 $ {\\rm mod} \\ p $ 的意义下我们把 $ x $ 的乘法逆元写作 $ x ^ {-1} $。  \n乘法逆元有如下的性质：\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n乘法逆元的一大应用是模意义下的除法，除法在模意义下并不是封闭的，但我们可以根据上述公式，将其转化为乘法。\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### 费马小定理\n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n要求 $ p $ 为素数。\n\n上述公式可变形为\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n由乘法逆元的定义，$ a ^ {p - 2} $ 即为 $ a $ 的乘法逆元。\n\n使用快速幂计算 $ a ^ {p - 2} $，总时间复杂度为 $ O(\\log a) $。\n\n#### 代码\n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得（EXGCD）算法可以在 $ O(\\log \\max(a, b)) $ 的时间内求出关于 $ x $、$ y $ 的方程\n\n\n$$ ax + by = \\gcd(a, b) $$\n\n的一组整数解\n\n当 $ b $ 为素数时，$ \\gcd(a, b) = 1 $，此时有\n\n$$ ax \\equiv 1 \\pmod b $$\n\n时间复杂度为 $ O(\\log a) $。\n\n#### 代码\n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### 递推法\n设 $ p = k \\times i + r $，（$ r < i $，$ 1 < i < p $），则有\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n两边同时乘上 $ r ^ {-1} + i ^ {-1} $，得\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n移项，得\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n即\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n我们可以利用这个式子进行递推，边界条件为 $ 1 ^ {-1} \\equiv 1 \\pmod p $，时间复杂度为 $ O(n) $。\n\n#### 代码\n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","source":"_posts/mul-inverse.md","raw":"title: 乘法逆元的几种计算方法\ncategories: OI\ntags: \n  - 数学\n  - 数论\n  - 学习笔记\n  - 算法模板\n  - 乘法逆元\npermalink: mul-inverse\ndate: 2016-04-13 12:11:17\n---\n\n乘法逆元是数论中重要的内容，也是 OI 中常用到的数论算法之一。所以，如何高效的求出乘法逆元是一个值得研究的问题。\n\n这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。\n\n<!-- more -->\n\n### 定义\n在 $ {\\rm mod} \\ p $ 的意义下我们把 $ x $ 的乘法逆元写作 $ x ^ {-1} $。  \n乘法逆元有如下的性质：\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n乘法逆元的一大应用是模意义下的除法，除法在模意义下并不是封闭的，但我们可以根据上述公式，将其转化为乘法。\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### 费马小定理\n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n要求 $ p $ 为素数。\n\n上述公式可变形为\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n由乘法逆元的定义，$ a ^ {p - 2} $ 即为 $ a $ 的乘法逆元。\n\n使用快速幂计算 $ a ^ {p - 2} $，总时间复杂度为 $ O(\\log a) $。\n\n#### 代码\n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得（EXGCD）算法可以在 $ O(\\log \\max(a, b)) $ 的时间内求出关于 $ x $、$ y $ 的方程\n\n\n$$ ax + by = \\gcd(a, b) $$\n\n的一组整数解\n\n当 $ b $ 为素数时，$ \\gcd(a, b) = 1 $，此时有\n\n$$ ax \\equiv 1 \\pmod b $$\n\n时间复杂度为 $ O(\\log a) $。\n\n#### 代码\n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### 递推法\n设 $ p = k \\times i + r $，（$ r < i $，$ 1 < i < p $），则有\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n两边同时乘上 $ r ^ {-1} + i ^ {-1} $，得\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n移项，得\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n即\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n我们可以利用这个式子进行递推，边界条件为 $ 1 ^ {-1} \\equiv 1 \\pmod p $，时间复杂度为 $ O(n) $。\n\n#### 代码\n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","slug":"mul-inverse","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rs100tqooxl5k76m1y3"},{"title":"单调队列学习笔记","date":"2016-01-14T21:44:45.000Z","_content":"\n单调队列，就是单调的队列，通常用来解决滑动窗口的最值问题，可以应用到 DP 的优化上。一个单调队列中的元素总是单调递增（或递减）的。\n\n<!-- more -->\n\n### 滑动窗口\n例：有一个队列，每次从队尾加入一个元素，或从队首删除一个元素，并在任何时刻求整个队列的最大值。\n\n一个很直接的想法是使用优先队列 `priority_queue` 即堆，堆可以在 $O(1)$ 的时间内求出最大值，但每次加入或删除时需要 $O({\\log}n)$ 的时间完成堆的调整，但是用了堆后就不能按照进队的顺序出队了！这时候你可以大胆地写一个平衡树或者 `set`——如果你不怕多出来的 $\\log$ 和平衡树常数带来的 TLE 的话。\n\n单调队列就是解决这类问题的数据结构，我们用一个辅助队列，使该队列的首元素总是原队列的最大值，这样就可以 $O(1)$ 地求出队列的最大值了。\n\n### 维护单调队列\n现有需要维护最大值的队列 `Q`，和辅助队列 `M`，设计算法使任何时刻时 `M` 队首元素都是当前 `Q` 的最大值。\n\n每次在 `Q` 的队尾加入元素 `x` 时，也将其加入到 `M` 中，从 `M` 的队尾向前遍历，将遍历到的所有 **小于等 `x` 的元素**全部删除，因为它们在 `x` 之前被加入到队列中，在 `x` 出队前它们就已经都出队了，即**在 `x` 出队前这些元素不可能成为队列中的最大值**。\n\n每次在 `Q` 的队首删除元素时，将要删除的元素与 `M` 的队首元素比较，如果该元素与 `M` 队首元素相等，即**该元素为执行删除操作前队列的最大值**，则同时也要将 `M` 的队首元素删除，使原 `Q` 的次小值成为 `M` 的队首元素，保证 `M` 的队首元素是删除操作后 `Q` 中最大的元素。\n\n### 应用\n状态转移方程形如 $f[x]=\\max\\{g(k)\\}+w[x]$ 的动态规划可以使用单调队列来优化。\n\n### 实现\n因为同时要从队列的两端添加、删除，所以要使用 `deque` 实现，而不是 `queue`。\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","source":"_posts/monotone-queue-notes.md","raw":"title: 单调队列学习笔记\ncategories: OI\ntags: \n  - 单调队列\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\n  - 算法模板  \npermalink: monotone-queue-notes\ndate: 2016-01-15 05:44:45\n---\n\n单调队列，就是单调的队列，通常用来解决滑动窗口的最值问题，可以应用到 DP 的优化上。一个单调队列中的元素总是单调递增（或递减）的。\n\n<!-- more -->\n\n### 滑动窗口\n例：有一个队列，每次从队尾加入一个元素，或从队首删除一个元素，并在任何时刻求整个队列的最大值。\n\n一个很直接的想法是使用优先队列 `priority_queue` 即堆，堆可以在 $O(1)$ 的时间内求出最大值，但每次加入或删除时需要 $O({\\log}n)$ 的时间完成堆的调整，但是用了堆后就不能按照进队的顺序出队了！这时候你可以大胆地写一个平衡树或者 `set`——如果你不怕多出来的 $\\log$ 和平衡树常数带来的 TLE 的话。\n\n单调队列就是解决这类问题的数据结构，我们用一个辅助队列，使该队列的首元素总是原队列的最大值，这样就可以 $O(1)$ 地求出队列的最大值了。\n\n### 维护单调队列\n现有需要维护最大值的队列 `Q`，和辅助队列 `M`，设计算法使任何时刻时 `M` 队首元素都是当前 `Q` 的最大值。\n\n每次在 `Q` 的队尾加入元素 `x` 时，也将其加入到 `M` 中，从 `M` 的队尾向前遍历，将遍历到的所有 **小于等 `x` 的元素**全部删除，因为它们在 `x` 之前被加入到队列中，在 `x` 出队前它们就已经都出队了，即**在 `x` 出队前这些元素不可能成为队列中的最大值**。\n\n每次在 `Q` 的队首删除元素时，将要删除的元素与 `M` 的队首元素比较，如果该元素与 `M` 队首元素相等，即**该元素为执行删除操作前队列的最大值**，则同时也要将 `M` 的队首元素删除，使原 `Q` 的次小值成为 `M` 的队首元素，保证 `M` 的队首元素是删除操作后 `Q` 中最大的元素。\n\n### 应用\n状态转移方程形如 $f[x]=\\max\\{g(k)\\}+w[x]$ 的动态规划可以使用单调队列来优化。\n\n### 实现\n因为同时要从队列的两端添加、删除，所以要使用 `deque` 实现，而不是 `queue`。\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","slug":"monotone-queue-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rs700txooxlxitu2z26"},{"title":"莫队算法学习笔记","date":"2016-05-01T00:14:50.000Z","_content":"\n算法竞赛中有这样一类题目，给定一个序列 $ [1,\\ n] $，每次查询 $ [l,\\ r] $ 区间的信息。这类题目没有修改操作，只有查询，并且操作没有加密（允许离线），莫队算法就是针对这类题目的一个离线算法。\n\n<!-- more -->\n\n莫队算法的核心思想是，假如我们已经知道了 $ [l,\\ r] $ 的答案，又可以很方便地向 $ [l,\\ r + 1] $、$ [l,\\ r - 1] $、$ [l - 1,\\ r] $、$ [l + 1,\\ r] $ 扩展，就可以实现让答案在每个询问之间转移。假设每次扩展的时间为 $ O(1) $，又因为每次转移最多有 $ O(n) $ 次扩展，所以算法总时间复杂度为 $ O(n ^ 2) $，通常会超时。\n\n我们可以将区间分为 $ \\sqrt n $ 块，每块的大小为 $ \\sqrt n $，并且将询问以**左端点所在的块**为第一关键字、以**右端点**为第二关键字排序，之后再进行上述算法。\n\n排序后，只有第一关键字不同的询问之间才会产生块之间的转移，而又因为共有 $ O(\\sqrt n) $ 块，所以不同块之间的转移最多发生 $ O(\\sqrt n) $ 次，不同块之间转移的总次数为 $ O((\\sqrt n) ^ 2) = O(n) $。每一块的大小为 $ O(\\sqrt n) $，即每一块内最多有 $ O((\\sqrt n) ^ 2) = O(n) $ 个不同的区间。所以，每经过一个块，都要进行 $ O(n) $ 次转移，乘上总块数 $ O(\\sqrt n) $，即相同块内的转移的总次数为 $ O(n \\sqrt n) $。\n\n每次扩展的时间复杂度不同时，适当调整块的大小，可以降低使整个算法的时间复杂度。\n","source":"_posts/mo-algorithm-notes.md","raw":"title: 莫队算法学习笔记\ncategories: OI\ntags: \n  - 莫队\n  - 学习笔记\n  - 数据结构\npermalink: mo-algorithm-notes\ndate: 2016-05-01 08:14:50\n---\n\n算法竞赛中有这样一类题目，给定一个序列 $ [1,\\ n] $，每次查询 $ [l,\\ r] $ 区间的信息。这类题目没有修改操作，只有查询，并且操作没有加密（允许离线），莫队算法就是针对这类题目的一个离线算法。\n\n<!-- more -->\n\n莫队算法的核心思想是，假如我们已经知道了 $ [l,\\ r] $ 的答案，又可以很方便地向 $ [l,\\ r + 1] $、$ [l,\\ r - 1] $、$ [l - 1,\\ r] $、$ [l + 1,\\ r] $ 扩展，就可以实现让答案在每个询问之间转移。假设每次扩展的时间为 $ O(1) $，又因为每次转移最多有 $ O(n) $ 次扩展，所以算法总时间复杂度为 $ O(n ^ 2) $，通常会超时。\n\n我们可以将区间分为 $ \\sqrt n $ 块，每块的大小为 $ \\sqrt n $，并且将询问以**左端点所在的块**为第一关键字、以**右端点**为第二关键字排序，之后再进行上述算法。\n\n排序后，只有第一关键字不同的询问之间才会产生块之间的转移，而又因为共有 $ O(\\sqrt n) $ 块，所以不同块之间的转移最多发生 $ O(\\sqrt n) $ 次，不同块之间转移的总次数为 $ O((\\sqrt n) ^ 2) = O(n) $。每一块的大小为 $ O(\\sqrt n) $，即每一块内最多有 $ O((\\sqrt n) ^ 2) = O(n) $ 个不同的区间。所以，每经过一个块，都要进行 $ O(n) $ 次转移，乘上总块数 $ O(\\sqrt n) $，即相同块内的转移的总次数为 $ O(n \\sqrt n) $。\n\n每次扩展的时间复杂度不同时，适当调整块的大小，可以降低使整个算法的时间复杂度。\n","slug":"mo-algorithm-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rsc00u4ooxlj8ab512z"},{"title":"最小生成树 && 次小生成树","date":"2016-01-01T22:08:50.000Z","_content":"\n最近回顾了一下图论中的最小生成树算法，又学习了神奇（个卵）的“次小生成树”的算法。\n\n总体来说，图论里面的东西还是挺灵活的嘛 ~\n\n<!-- more -->\n\n### 最小生成树\n\n#### Kruskal 算法\n对所有边进行排序，用**并查集**维护连通性，从小到大枚举边，判断当前边的起止点是否在同一连通块中，若不是，则加入这条边，否则放弃这条边。\n\n图结构需要以边集数组储存。\n\n时间复杂度为 $O(m{\\log}m)$（其中 `m` 为边数）。\n\n据说适用于稀疏图。\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim 算法\nPrim 算法相对于 Kruskal 算法而言有一定难度，它把所有的点分为两个集合：在最小生成树中和不在最小生成树中，每次找到一条连接两个集合的**权值最小**的边，将它添加到最小生成树中。\n\n对于 Prim 算法，可以考虑类似于 Dijkstra 单源最短路算法的堆优化，即设置一个优先队列，初始时将从源点（可任取）出发的边加进优先队列中，每次从优先队列中不断弹出权值最小的边，直至得到一条边连接两个集合，则将这条边添加到最小生成树中，然后将这条边的出点的所有出边加入优先队列中。\n\n图结构需要以邻接表储存。\n\n使用优先队列的时间复杂度为 $O(m{\\log}n)$（其中 `n` 为结点数，`m` 为边数）。  \n不使用任何优化的时间复杂度为 $O(n^2)$（其中 `n` 为结点数）。\n\n据说适用于稠密图。\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### 次小生成树\n一个图的次小生成树，是指**异于该图的最小生成树**的**边权和最小**的生成树。\n\n注意，这里的次小生成树是**非严格**次小，即可能存在一个图，其最小生成树与次小生成树的边权和相等。\n\n#### 算法\n不难得出，次小生成树可以由最小生成树更换一条边得到。\n\n首先构造原图的最小生成树，然后枚举每一条**不在最小生成树中**的边 `(u, v, w)`，尝试将这条边加入生成树，因为直接加入边会产生环，所以我们需要在加边之前删去最小生成树上 `u` 到 `v` 的路径上**权值最大**的边。在枚举每一条边时我们都会得到一棵生成树，这些生成树中边权和最小的即为要求的次小生成树。\n\n需要在构造最小生成树时将完整的树结构构造出来，并且使用树上倍增算法查询两点间边权值最大的值。\n\n#### 代码（POJ 1679）\n链接：[POJ 1679](http://poj.org/problem?id=1679)\n\n题目要求判断最小生成树的唯一性。求出该图的非严格次小生成树，与最小生成树的权值和作比较即可。\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/minimum-spanning-tree-notes.md","raw":"title: '最小生成树 && 次小生成树'\ncategories: OI\ntags: \n  - Kruskal\n  - POJ\n  - Prim\n  - 倍增\n  - 图论\n  - 学习笔记\n  - 并查集\n  - 最小生成树\n  - 算法模板  \npermalink: minimum-spanning-tree-notes\ndate: 2016-01-02 06:08:50\n---\n\n最近回顾了一下图论中的最小生成树算法，又学习了神奇（个卵）的“次小生成树”的算法。\n\n总体来说，图论里面的东西还是挺灵活的嘛 ~\n\n<!-- more -->\n\n### 最小生成树\n\n#### Kruskal 算法\n对所有边进行排序，用**并查集**维护连通性，从小到大枚举边，判断当前边的起止点是否在同一连通块中，若不是，则加入这条边，否则放弃这条边。\n\n图结构需要以边集数组储存。\n\n时间复杂度为 $O(m{\\log}m)$（其中 `m` 为边数）。\n\n据说适用于稀疏图。\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim 算法\nPrim 算法相对于 Kruskal 算法而言有一定难度，它把所有的点分为两个集合：在最小生成树中和不在最小生成树中，每次找到一条连接两个集合的**权值最小**的边，将它添加到最小生成树中。\n\n对于 Prim 算法，可以考虑类似于 Dijkstra 单源最短路算法的堆优化，即设置一个优先队列，初始时将从源点（可任取）出发的边加进优先队列中，每次从优先队列中不断弹出权值最小的边，直至得到一条边连接两个集合，则将这条边添加到最小生成树中，然后将这条边的出点的所有出边加入优先队列中。\n\n图结构需要以邻接表储存。\n\n使用优先队列的时间复杂度为 $O(m{\\log}n)$（其中 `n` 为结点数，`m` 为边数）。  \n不使用任何优化的时间复杂度为 $O(n^2)$（其中 `n` 为结点数）。\n\n据说适用于稠密图。\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### 次小生成树\n一个图的次小生成树，是指**异于该图的最小生成树**的**边权和最小**的生成树。\n\n注意，这里的次小生成树是**非严格**次小，即可能存在一个图，其最小生成树与次小生成树的边权和相等。\n\n#### 算法\n不难得出，次小生成树可以由最小生成树更换一条边得到。\n\n首先构造原图的最小生成树，然后枚举每一条**不在最小生成树中**的边 `(u, v, w)`，尝试将这条边加入生成树，因为直接加入边会产生环，所以我们需要在加边之前删去最小生成树上 `u` 到 `v` 的路径上**权值最大**的边。在枚举每一条边时我们都会得到一棵生成树，这些生成树中边权和最小的即为要求的次小生成树。\n\n需要在构造最小生成树时将完整的树结构构造出来，并且使用树上倍增算法查询两点间边权值最大的值。\n\n#### 代码（POJ 1679）\n链接：[POJ 1679](http://poj.org/problem?id=1679)\n\n题目要求判断最小生成树的唯一性。求出该图的非严格次小生成树，与最小生成树的权值和作比较即可。\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"minimum-spanning-tree-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rsg00uaooxljndn1qui"},{"title":"Manacher 学习笔记","date":"2017-01-02T12:14:00.000Z","_content":"\nManacher 可在 $ O(n) $ 的时间内求出一个字符串**以每个位置为中心**的最长回文子串。\n\n<!-- more -->\n\n为了避免分类讨论，在字符串的首部的尾部添加两个不同的在串中没有出现过的字符（这里分别使用 `@` 和空白字符 `\\0`），每两个字符之间加入另一个在串中没有出现过的字符（这里使用 `$`）。这样，原串中长度为奇数和偶数的回文串的长度均变为奇数，且原串中回文串的长度为新串回文串半径减一。\n\n设置两个状态 $ \\max $ 和 $ p $，$ p $ 表示当前已找到的回文串中，向右延伸最远的中心位置，$ \\max $ 表示其右端点。\n\n设 $ r(i) $ 表示（新串中）第 $ i $ 个位置的回文半径（回文串长度的一半，包括第 $ i $ 个字符）按从左到右的顺序求解，枚举到第 $ i $ 个字符时，分三种情况考虑：\n\n设 $ j $ 为 $ i $ 关于 $ p $ 的对称点，即 $ j = 2p - i $。\n\n![](manacher-notes/1.svg)\n\n$ \\max < i $，即向右延伸最远的回文子串（黑色）没有覆盖 $ i $，此时只有 $ r(i) \\geq 1 $。\n\n![](manacher-notes/2.svg)\n\n$ \\max \\geq i $ 且 $ \\max - i \\geq r(j) $，即向右延伸最远的回文子串（黑色）覆盖了 $ i $，并且以 $ j $ 为中心的最长回文子串完全与以 $ i $ 为中心的最长回文子串对称（蓝色），此时一定有 $ r(i) = r(j) $，即 $ r(i) \\geq r(j) $。\n\n![](manacher-notes/3.svg)\n\n$ \\max \\geq i $ 且 $ \\max - i \\geq r(j) $，即向右延伸最远的回文子串（黑色）覆盖了 $ i $，但没有覆盖以 $ j $ 为中心的最长回文子串的对称位置串，所以 $ r(i) $ 只能取被覆盖的（黄色）一部分，即 $ r(i) \\geq \\max - i $。\n\n### 代码（[POJ 3974](http://poj.org/problem?id=3974)）\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\n// s1 原串，s2 新串\nchar s1[MAXN + 2], s2[MAXN * 2 + 3];\nint n, len, r[MAXN * 2 + 3];\n\ninline void prepare()\n{\n\tn = strlen(s1);\n\n\ts2[++len] = '@'; // 边界字符\n\ts2[++len] = '$';\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ts2[++len] = s1[i];\n\t\ts2[++len] = '$';\n\t}\n\n\ts2[len + 1] = '\\0'; // 使用 0 作为结束字符和边界字符\n}\n\ninline void manacher()\n{\n\t// 新字符串首部为 '@'，尾部为 '\\0'（空字符），中间为 '$'\n\tint right = 0, mid = 0; // right 当前回文最右点，mid 是 right 对应的回文中心\n\tfor (int i = 1; i <= len; i++)\n\t{\n\t\tint x;\n\t\tif (right < i) x = 1;\n\t\telse x = std::min(r[mid * 2 - i], right - i);\n\n\t\t// 逐位匹配\n\t\twhile (s2[i + x] == s2[i - x]) ++x;\n\n\t\t// 更新最右点\n\t\tif (i + x > right)\n\t\t{\n\t\t\tright = i + x;\n\t\t\tmid = i;\n\t\t}\n\n\t\tr[i] = x;\n\t}\n}\n\nint main() {\n\tint T = 0;\n\twhile (scanf(\"%s\", s1), memcmp(s1, \"END\", 4) != 0)\n\t{\n\t\tprepare();\n\t\tmanacher();\n\n\t\t// printf(\"%s\\n\", s2 + 1);\n\t\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", r[i], i == len ? '\\n' : ' ');\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= len; i++) ans = std::max(ans, r[i] - 1);\n\t\tprintf(\"Case %d: %d\\n\", ++T, ans);\n\n\t\tlen = 0;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/manacher-notes.md","raw":"title: Manacher 学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 字符串\n  - Manacher\n  - 算法模板\npermalink: manacher-notes\ndate: 2017-01-02 20:14:00\n---\n\nManacher 可在 $ O(n) $ 的时间内求出一个字符串**以每个位置为中心**的最长回文子串。\n\n<!-- more -->\n\n为了避免分类讨论，在字符串的首部的尾部添加两个不同的在串中没有出现过的字符（这里分别使用 `@` 和空白字符 `\\0`），每两个字符之间加入另一个在串中没有出现过的字符（这里使用 `$`）。这样，原串中长度为奇数和偶数的回文串的长度均变为奇数，且原串中回文串的长度为新串回文串半径减一。\n\n设置两个状态 $ \\max $ 和 $ p $，$ p $ 表示当前已找到的回文串中，向右延伸最远的中心位置，$ \\max $ 表示其右端点。\n\n设 $ r(i) $ 表示（新串中）第 $ i $ 个位置的回文半径（回文串长度的一半，包括第 $ i $ 个字符）按从左到右的顺序求解，枚举到第 $ i $ 个字符时，分三种情况考虑：\n\n设 $ j $ 为 $ i $ 关于 $ p $ 的对称点，即 $ j = 2p - i $。\n\n![](manacher-notes/1.svg)\n\n$ \\max < i $，即向右延伸最远的回文子串（黑色）没有覆盖 $ i $，此时只有 $ r(i) \\geq 1 $。\n\n![](manacher-notes/2.svg)\n\n$ \\max \\geq i $ 且 $ \\max - i \\geq r(j) $，即向右延伸最远的回文子串（黑色）覆盖了 $ i $，并且以 $ j $ 为中心的最长回文子串完全与以 $ i $ 为中心的最长回文子串对称（蓝色），此时一定有 $ r(i) = r(j) $，即 $ r(i) \\geq r(j) $。\n\n![](manacher-notes/3.svg)\n\n$ \\max \\geq i $ 且 $ \\max - i \\geq r(j) $，即向右延伸最远的回文子串（黑色）覆盖了 $ i $，但没有覆盖以 $ j $ 为中心的最长回文子串的对称位置串，所以 $ r(i) $ 只能取被覆盖的（黄色）一部分，即 $ r(i) \\geq \\max - i $。\n\n### 代码（[POJ 3974](http://poj.org/problem?id=3974)）\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\n// s1 原串，s2 新串\nchar s1[MAXN + 2], s2[MAXN * 2 + 3];\nint n, len, r[MAXN * 2 + 3];\n\ninline void prepare()\n{\n\tn = strlen(s1);\n\n\ts2[++len] = '@'; // 边界字符\n\ts2[++len] = '$';\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ts2[++len] = s1[i];\n\t\ts2[++len] = '$';\n\t}\n\n\ts2[len + 1] = '\\0'; // 使用 0 作为结束字符和边界字符\n}\n\ninline void manacher()\n{\n\t// 新字符串首部为 '@'，尾部为 '\\0'（空字符），中间为 '$'\n\tint right = 0, mid = 0; // right 当前回文最右点，mid 是 right 对应的回文中心\n\tfor (int i = 1; i <= len; i++)\n\t{\n\t\tint x;\n\t\tif (right < i) x = 1;\n\t\telse x = std::min(r[mid * 2 - i], right - i);\n\n\t\t// 逐位匹配\n\t\twhile (s2[i + x] == s2[i - x]) ++x;\n\n\t\t// 更新最右点\n\t\tif (i + x > right)\n\t\t{\n\t\t\tright = i + x;\n\t\t\tmid = i;\n\t\t}\n\n\t\tr[i] = x;\n\t}\n}\n\nint main() {\n\tint T = 0;\n\twhile (scanf(\"%s\", s1), memcmp(s1, \"END\", 4) != 0)\n\t{\n\t\tprepare();\n\t\tmanacher();\n\n\t\t// printf(\"%s\\n\", s2 + 1);\n\t\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", r[i], i == len ? '\\n' : ' ');\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= len; i++) ans = std::max(ans, r[i] - 1);\n\t\tprintf(\"Case %d: %d\\n\", ++T, ans);\n\n\t\tlen = 0;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"manacher-notes","published":1,"updated":"2017-01-02T12:15:15.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rso00unooxlniigyuwv"},{"title":"Link-Cut Tree 学习笔记","date":"2016-01-19T12:50:40.000Z","_content":"\nLink-Cut Tree 是一种用来维护动态森林连通性的数据结构，适用于动态树问题。它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 $O({\\log}n)$，但常数因子较大，一般效率会低于树链剖分。\n\n<!-- more -->\n\n### 定义\n一棵 Link-Cut Tree 上的边分为两种：实边和虚边。每一种边都是有向的，由子节点指向父节点。首尾相连的实边组成的不可延伸的链叫做路径。路径中**深度最大**的节点称为路径头部，**深度最小**的节点称为路径尾部。\n\n将每一条路径上的节点按照深度排序，得到一个序列，用 Splay 来维护这个序列。\n\n每一条链对应着一棵 Splay，每棵 Splay 的根节点有一个成员 `Path Parent`，表示该 Splay 维护的路径的尾部的节点的**父节点**，整棵树的根节点所对应的 Splay 节点的 `Path Parent` 为空；其他节点（不是其所在 Splay 的根节点的节点）的 `Path Parent` 也为空。\n\n`value` 用于维护点权，`sum` 和 `max` 是根据题目要求维护的链上的区间信息。`reversed` 表示以该节点为根的 Splay 有没有被翻转。\n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### 操作\nLink-Cut Tree 支持以下几种基本操作：\n\n1. `Access(u)`，“访问”某个节点 `u`，被“访问”过的节点会与根节点之间以路径相连，并且该节点为路径头部（最下端）；\n2. `Evert(u)`，将某个节点 `u` 置为其所在树的根节点，该操作等价于把该节点到根节点所经过的所有边方向取反；\n3. `Link(u, v)`，将某两个节点 `u` 和 `v` 连接，执行操作后 `u` 成为 `v` 的父节点；\n4. `Cut(u, v)`，将某两个节点 `u` 和 `v` 分离，执行操作后 `v` 及其子节点组成单独的一棵树；\n5. `FindRoot(u)`，查找某个节点 `u` 所在树的根节点；\n6. `MakeTree()`，向森林中种植一棵新的树。\n\n### `Access` 操作\n#### `Expose` 操作\n在实现 `Access` 操作前，我们先来实现 `Expose` 操作，它的作用是将当前节点置为其所在路径的头部节点，即切断自该节点向下的部分路径。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点有右孩子，那么断开其与其右孩子的连接。\n\n不要忘了各种标记的下放和值的维护。\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` 操作\n接下来，我们来实现 `Splice` 操作，它的作用是将**当前节点**所在的路径与**其尾部节点的父节点**所在的路径合并，即实现了路径的向上延长。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点没有 `Path Parent`，那么说明该节点所在路径中包含根节点，即 `Splice` 操作失败。\n3. 对该节点的 `Path Parent` 执行 `Expose` 操作，将其原有的路径断开；\n4. 将该节点连接到其 `Path Parent` 的右孩子上，并将 `Path Parent` 置为空。\n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` 操作\n有了 `Expose` 和 `Splice`，`Access` 就简单多了，`Expose` 后执行 `Splice` 直到失败即可。\n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` 操作\n首先执行 `Access`，将该节点与根节点之间用一条完整的路径连接，然后翻转这条路径即可。\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` 操作\n将节点 `v` 置为其所在树的根，然后将其 `Path Parent` 置为节点 `u` 即可。\n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` 操作\n`Cut` 操作稍微复杂一点：\n\n1. 将节点 `u` 置为其所在树的根节点，以保证 `v` 是 `u` 的子节点；\n2. 对 `v` 执行 `Access` 操作，将 `v` 与 `u` 之间用一条完整的路径连接；\n3. 对 `v` 执行 `Splay` 操作，将 `v` 置于**其所在 Splay 的根节点**；\n4. 将 `v` 与其左子树分离，即将路径断开。\n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query` 和 `Update` 操作\n以 `QueryMax(u, v)` 查询两个点之间的点权最大值为例。首先在 `Node` 结构体中存储 `max` 成员，并在 `Maintain()` 中维护它。\n\n首先，如果需要查询某个点到根节点之间的点权最大值，只需先访问这个节点，即 `Access(u)`，然后对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，此时 `u` 的 `max` 存储的值即为 `u` 到其所在树的根节点的路径上的点权最大值。\n\n如果要查询任意两点间的点权最大值，只需要先对其中一个节点执行 `Evert` 操作，将其置为树根，就可以转化为上述情况进行处理。\n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n要修改某个点的点权值，只需要对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，然后直接修改即可，这样可以避免修改时标记的向上传递。\n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` 操作\n直接新建节点就可以。\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n### 其他操作 & 注意事项\n1. 进行 `Splay` 和 `Rotate` 时，要注意标记的传递；\n2. `Rotate` 时，需要将自己的 `Path Parent` 与父节点的 `Path Parent` 互换，以保证 `Path Parent` 成员的有效值总在一棵 Splay 的根节点上。\n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### 完整代码（树的统计）\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/link-cut-tree-notes.md","raw":"title: Link-Cut Tree 学习笔记\ncategories: OI\ntags: \n  - Link-Cut Tree\n  - 动态树\n  - Splay\n  - 数据结构\n  - 高级数据结构\n  - 算法模板  \npermalink: link-cut-tree-notes\ndate: 2016-01-19 20:50:40\n---\n\nLink-Cut Tree 是一种用来维护动态森林连通性的数据结构，适用于动态树问题。它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 $O({\\log}n)$，但常数因子较大，一般效率会低于树链剖分。\n\n<!-- more -->\n\n### 定义\n一棵 Link-Cut Tree 上的边分为两种：实边和虚边。每一种边都是有向的，由子节点指向父节点。首尾相连的实边组成的不可延伸的链叫做路径。路径中**深度最大**的节点称为路径头部，**深度最小**的节点称为路径尾部。\n\n将每一条路径上的节点按照深度排序，得到一个序列，用 Splay 来维护这个序列。\n\n每一条链对应着一棵 Splay，每棵 Splay 的根节点有一个成员 `Path Parent`，表示该 Splay 维护的路径的尾部的节点的**父节点**，整棵树的根节点所对应的 Splay 节点的 `Path Parent` 为空；其他节点（不是其所在 Splay 的根节点的节点）的 `Path Parent` 也为空。\n\n`value` 用于维护点权，`sum` 和 `max` 是根据题目要求维护的链上的区间信息。`reversed` 表示以该节点为根的 Splay 有没有被翻转。\n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### 操作\nLink-Cut Tree 支持以下几种基本操作：\n\n1. `Access(u)`，“访问”某个节点 `u`，被“访问”过的节点会与根节点之间以路径相连，并且该节点为路径头部（最下端）；\n2. `Evert(u)`，将某个节点 `u` 置为其所在树的根节点，该操作等价于把该节点到根节点所经过的所有边方向取反；\n3. `Link(u, v)`，将某两个节点 `u` 和 `v` 连接，执行操作后 `u` 成为 `v` 的父节点；\n4. `Cut(u, v)`，将某两个节点 `u` 和 `v` 分离，执行操作后 `v` 及其子节点组成单独的一棵树；\n5. `FindRoot(u)`，查找某个节点 `u` 所在树的根节点；\n6. `MakeTree()`，向森林中种植一棵新的树。\n\n### `Access` 操作\n#### `Expose` 操作\n在实现 `Access` 操作前，我们先来实现 `Expose` 操作，它的作用是将当前节点置为其所在路径的头部节点，即切断自该节点向下的部分路径。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点有右孩子，那么断开其与其右孩子的连接。\n\n不要忘了各种标记的下放和值的维护。\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` 操作\n接下来，我们来实现 `Splice` 操作，它的作用是将**当前节点**所在的路径与**其尾部节点的父节点**所在的路径合并，即实现了路径的向上延长。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点没有 `Path Parent`，那么说明该节点所在路径中包含根节点，即 `Splice` 操作失败。\n3. 对该节点的 `Path Parent` 执行 `Expose` 操作，将其原有的路径断开；\n4. 将该节点连接到其 `Path Parent` 的右孩子上，并将 `Path Parent` 置为空。\n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` 操作\n有了 `Expose` 和 `Splice`，`Access` 就简单多了，`Expose` 后执行 `Splice` 直到失败即可。\n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` 操作\n首先执行 `Access`，将该节点与根节点之间用一条完整的路径连接，然后翻转这条路径即可。\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` 操作\n将节点 `v` 置为其所在树的根，然后将其 `Path Parent` 置为节点 `u` 即可。\n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` 操作\n`Cut` 操作稍微复杂一点：\n\n1. 将节点 `u` 置为其所在树的根节点，以保证 `v` 是 `u` 的子节点；\n2. 对 `v` 执行 `Access` 操作，将 `v` 与 `u` 之间用一条完整的路径连接；\n3. 对 `v` 执行 `Splay` 操作，将 `v` 置于**其所在 Splay 的根节点**；\n4. 将 `v` 与其左子树分离，即将路径断开。\n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query` 和 `Update` 操作\n以 `QueryMax(u, v)` 查询两个点之间的点权最大值为例。首先在 `Node` 结构体中存储 `max` 成员，并在 `Maintain()` 中维护它。\n\n首先，如果需要查询某个点到根节点之间的点权最大值，只需先访问这个节点，即 `Access(u)`，然后对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，此时 `u` 的 `max` 存储的值即为 `u` 到其所在树的根节点的路径上的点权最大值。\n\n如果要查询任意两点间的点权最大值，只需要先对其中一个节点执行 `Evert` 操作，将其置为树根，就可以转化为上述情况进行处理。\n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n要修改某个点的点权值，只需要对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，然后直接修改即可，这样可以避免修改时标记的向上传递。\n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` 操作\n直接新建节点就可以。\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n### 其他操作 & 注意事项\n1. 进行 `Splay` 和 `Rotate` 时，要注意标记的传递；\n2. `Rotate` 时，需要将自己的 `Path Parent` 与父节点的 `Path Parent` 互换，以保证 `Path Parent` 成员的有效值总在一棵 Splay 的根节点上。\n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### 完整代码（树的统计）\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"link-cut-tree-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rsx00uuooxlshkbqrni"},{"title":"KMP 学习笔记","date":"2015-12-29T20:19:36.000Z","_content":"\nKMP（Knuth-Morris-Pratt）是算法竞赛中常用的字符串匹配算法之一，它可以有效地利用失配信息来使得匹配全过程中不回溯，从而在线性时间内完成匹配。\n\n<!-- more -->\n\n### 原理\n设模式串 `pattern` 为 `\"utqqutnu\"`，目标串 `target` 为 `\"utqlwutqqutnu`\"，使用朴素算法进行匹配时（`\"-\"` 表示匹配成功，`\"|\"` 表示在此字符失配）：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n首先，将两串首部对齐，逐个字符匹配，可见在字符 `'l'` 处失配，按照朴素算法的思想，我们需要把模式串右移一个字符，然后再从模式串首部开始匹配，即：\n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n这时发现从第一个字符起就不匹配，还要继续右移 ……\n\n但是，似乎有一种更好的策略：我们可以直接把模式串的开头对齐目标串的 `\"ut\"` 处，就可以一次跳过几个字符，并且模式串无需回溯：\n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n而接下来这次失配后，本来需要将模式串与 `'t'` 对齐，但事实上并不需要，将模式串直接与 `'l'` 对齐即可。\n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP 算法就是利用了失配后的**部分匹配**信息来选择模式串的移动方式，尽可能地避免无用的匹配。\n\n### 失配信息的利用\n通过上述例子我们可以观察到，如果**部分匹配**的串有对称的**前后缀**，则我们可以直接将**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐，如：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n例子中的部分匹配串为 `\"utqqut\"`，有对称的前后缀 `\"ut\"`，则可以直接将目标串的第二个 `\"ut\"` 与模式串的第一个 `\"ut\"` 对齐。\n\n再来看这个例子，模式串为 `\"ttitty\"`，目标串为 `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n此时的部分匹配串为 `\"ttitt\"`，它有两个对称的前后缀，分别是 `\"tt\"` 和 `\"t\"`，我们会想，以 `\"t\"` 对齐，可以移动更长的距离，事实上呢？\n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n在模式串第二个 `'t'` 处失配后，继续匹配，最终结果是匹配失败。\n\n然而，如果我们以 `\"tt\"` 对齐，则有：\n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n结果是匹配成功。\n\n这个例子告诉我们，当部分匹配串有多个对称前后缀时，需要选择**最长的**，以保证匹配结果的正确。\n\n### 失配信息的推导\n事实上，KMP 算法利用的**失配信息**是与目标串无关的，它仅与模式串有关，我们可以用递推的方法在线性的时间内求出模式串的**每个可能的部分匹配串（即所有前缀）**前缀的失配信息。\n\n我们定义 `fail` 数组是一个长度等于模式串长度的数组，它的第 `i` 个成员代表以模式串前 `i` 个字符作为部分匹配串时，部分匹配串的**最长对称前后缀**长度。\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nfail  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n推导 `fail[i]` 的方法如下：\n\n1. 如果 `fail[i - 1]` 不为 0，且第 `i` 个字符与第 `fail[i - 1] +　１` 个字符相同，则 `fail[i]` 即为 `fail[i - 1] + 1`；\n2. 如果 `fail[i - 1]` 为 0，且第 `i` 个字符与首个字符相同，则 `fail[i] = 1`，否则 `fail[i] = 0`；\n3. 难点：如果 `fail[i - 1]` 不为 0，且第 `i` 个字符与第 `fail[i - 1] +　１` 个字符**不同**，则继续对比第 `i` 个字符与 `fail[fail[i - 1]] + 1` 个字符，一直向前找直到匹配或者找到了 0。\n\n如模式串：*agct*agc**a**gct*agct*\n\n加粗的 `'a'` 与最后一个 `'t'` 不匹配，此时向前找找到 `\"agctagc\"` 的最后一个 `'c'` 的**对称位置的后一个字符**，发现是 `'t'`，则找到前后的 `\"agct\"` 是一个对称的前后缀。\n\n### 匹配\n有了 `fail` 数组，匹配就简单多了，只要根据以下三种情况对应处理即可：\n\n1. 如果当前字符匹配，则继续匹配下一个字符；\n2. 如果当前在**模式串的首字符处**不匹配，则直接将模式串右移一个字符；\n3. 否则移动模式串，使**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐。\n\n### 完整代码（POJ 3461）\n更新于 2016 年 12 月 26 日。\n\n![zyz 大佬的评价](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\n\ninline int kmp(char *a, char *b) // 在 a 中寻找 b\n{\n\t// 求出字符串长度\n\tint na = strlen(a + 1), nb = strlen(b + 1);\n\tstatic int fail[MAXN + 1];\n\n\tfail[1] = 0;\n\tfor (int i = 2; i <= nb; i++)\n\t{\n\t\t// 取上一位置的 fail 位置之后的字符，判断是否和该位相同\n\t\tint j = fail[i - 1];\n\t\t// 不断地向前找 fail 位置，直到找到 0 位置或可以匹配当前字符\n\t\twhile (j != 0 && b[j + 1] != b[i]) j = fail[j];\n\n\t\t// 如果能匹配，设置当前位置的 fail 位置\n\t\tif (b[j + 1] == b[i]) fail[i] = j + 1;\n\t\telse fail[i] = 0; // 找不到匹配位置\n\t}\n\n\tint res = 0; // 匹配次数\n\tfor (int i = 1, j = 0; i <= na; i++)\n\t{\n\t\t// 取上一位置的 fail 位置之后的字符，判断是否和要匹配的字符相同\n\t\twhile (j != 0 && b[j + 1] != a[i]) j = fail[j];\n\n\t\t// 这一位可以匹配上\n\t\tif (b[j + 1] == a[i]) j++;\n\n\t\t// 匹配成功\n\t\tif (j == nb)\n\t\t{\n\t\t\tres++;\n\t\t\tj = fail[j]; // 为了能匹配重叠串\n\t\t\t// j = 0 // 如果不允许重叠匹配\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tstatic char a[MAXN + 2], b[MAXN + 2];\n\t\t// 下标从 1 开始\n\t\tscanf(\"%s %s\", a + 1, b + 1);\n\t\tprintf(\"%d\\n\", kmp(b, a));\n\t}\n\treturn 0;\n}\n```\n\n<!--\n### 完整代码（CodeVS 1204）\n因为 C++ 中数组从 `0` 开始，所以有些地方与上文中的表示不同。\n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint fail[MAXN] = { 0 };\n\n\tfail[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = fail[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = fail[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tfail[i] = k + 1;\n\t\t} else {\n\t\t\tfail[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << fail[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = fail[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n-->\n","source":"_posts/kmp-notes.md","raw":"title: KMP 学习笔记\ncategories: OI\ntags: \n  - CodeVS\n  - KMP\n  - 字符串\n  - 学习笔记\n  - 算法模板  \npermalink: kmp-notes\ndate: 2015-12-30 04:19:36\n---\n\nKMP（Knuth-Morris-Pratt）是算法竞赛中常用的字符串匹配算法之一，它可以有效地利用失配信息来使得匹配全过程中不回溯，从而在线性时间内完成匹配。\n\n<!-- more -->\n\n### 原理\n设模式串 `pattern` 为 `\"utqqutnu\"`，目标串 `target` 为 `\"utqlwutqqutnu`\"，使用朴素算法进行匹配时（`\"-\"` 表示匹配成功，`\"|\"` 表示在此字符失配）：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n首先，将两串首部对齐，逐个字符匹配，可见在字符 `'l'` 处失配，按照朴素算法的思想，我们需要把模式串右移一个字符，然后再从模式串首部开始匹配，即：\n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n这时发现从第一个字符起就不匹配，还要继续右移 ……\n\n但是，似乎有一种更好的策略：我们可以直接把模式串的开头对齐目标串的 `\"ut\"` 处，就可以一次跳过几个字符，并且模式串无需回溯：\n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n而接下来这次失配后，本来需要将模式串与 `'t'` 对齐，但事实上并不需要，将模式串直接与 `'l'` 对齐即可。\n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP 算法就是利用了失配后的**部分匹配**信息来选择模式串的移动方式，尽可能地避免无用的匹配。\n\n### 失配信息的利用\n通过上述例子我们可以观察到，如果**部分匹配**的串有对称的**前后缀**，则我们可以直接将**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐，如：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n例子中的部分匹配串为 `\"utqqut\"`，有对称的前后缀 `\"ut\"`，则可以直接将目标串的第二个 `\"ut\"` 与模式串的第一个 `\"ut\"` 对齐。\n\n再来看这个例子，模式串为 `\"ttitty\"`，目标串为 `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n此时的部分匹配串为 `\"ttitt\"`，它有两个对称的前后缀，分别是 `\"tt\"` 和 `\"t\"`，我们会想，以 `\"t\"` 对齐，可以移动更长的距离，事实上呢？\n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n在模式串第二个 `'t'` 处失配后，继续匹配，最终结果是匹配失败。\n\n然而，如果我们以 `\"tt\"` 对齐，则有：\n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n结果是匹配成功。\n\n这个例子告诉我们，当部分匹配串有多个对称前后缀时，需要选择**最长的**，以保证匹配结果的正确。\n\n### 失配信息的推导\n事实上，KMP 算法利用的**失配信息**是与目标串无关的，它仅与模式串有关，我们可以用递推的方法在线性的时间内求出模式串的**每个可能的部分匹配串（即所有前缀）**前缀的失配信息。\n\n我们定义 `fail` 数组是一个长度等于模式串长度的数组，它的第 `i` 个成员代表以模式串前 `i` 个字符作为部分匹配串时，部分匹配串的**最长对称前后缀**长度。\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nfail  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n推导 `fail[i]` 的方法如下：\n\n1. 如果 `fail[i - 1]` 不为 0，且第 `i` 个字符与第 `fail[i - 1] +　１` 个字符相同，则 `fail[i]` 即为 `fail[i - 1] + 1`；\n2. 如果 `fail[i - 1]` 为 0，且第 `i` 个字符与首个字符相同，则 `fail[i] = 1`，否则 `fail[i] = 0`；\n3. 难点：如果 `fail[i - 1]` 不为 0，且第 `i` 个字符与第 `fail[i - 1] +　１` 个字符**不同**，则继续对比第 `i` 个字符与 `fail[fail[i - 1]] + 1` 个字符，一直向前找直到匹配或者找到了 0。\n\n如模式串：*agct*agc**a**gct*agct*\n\n加粗的 `'a'` 与最后一个 `'t'` 不匹配，此时向前找找到 `\"agctagc\"` 的最后一个 `'c'` 的**对称位置的后一个字符**，发现是 `'t'`，则找到前后的 `\"agct\"` 是一个对称的前后缀。\n\n### 匹配\n有了 `fail` 数组，匹配就简单多了，只要根据以下三种情况对应处理即可：\n\n1. 如果当前字符匹配，则继续匹配下一个字符；\n2. 如果当前在**模式串的首字符处**不匹配，则直接将模式串右移一个字符；\n3. 否则移动模式串，使**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐。\n\n### 完整代码（POJ 3461）\n更新于 2016 年 12 月 26 日。\n\n![zyz 大佬的评价](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\n\ninline int kmp(char *a, char *b) // 在 a 中寻找 b\n{\n\t// 求出字符串长度\n\tint na = strlen(a + 1), nb = strlen(b + 1);\n\tstatic int fail[MAXN + 1];\n\n\tfail[1] = 0;\n\tfor (int i = 2; i <= nb; i++)\n\t{\n\t\t// 取上一位置的 fail 位置之后的字符，判断是否和该位相同\n\t\tint j = fail[i - 1];\n\t\t// 不断地向前找 fail 位置，直到找到 0 位置或可以匹配当前字符\n\t\twhile (j != 0 && b[j + 1] != b[i]) j = fail[j];\n\n\t\t// 如果能匹配，设置当前位置的 fail 位置\n\t\tif (b[j + 1] == b[i]) fail[i] = j + 1;\n\t\telse fail[i] = 0; // 找不到匹配位置\n\t}\n\n\tint res = 0; // 匹配次数\n\tfor (int i = 1, j = 0; i <= na; i++)\n\t{\n\t\t// 取上一位置的 fail 位置之后的字符，判断是否和要匹配的字符相同\n\t\twhile (j != 0 && b[j + 1] != a[i]) j = fail[j];\n\n\t\t// 这一位可以匹配上\n\t\tif (b[j + 1] == a[i]) j++;\n\n\t\t// 匹配成功\n\t\tif (j == nb)\n\t\t{\n\t\t\tres++;\n\t\t\tj = fail[j]; // 为了能匹配重叠串\n\t\t\t// j = 0 // 如果不允许重叠匹配\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tstatic char a[MAXN + 2], b[MAXN + 2];\n\t\t// 下标从 1 开始\n\t\tscanf(\"%s %s\", a + 1, b + 1);\n\t\tprintf(\"%d\\n\", kmp(b, a));\n\t}\n\treturn 0;\n}\n```\n\n<!--\n### 完整代码（CodeVS 1204）\n因为 C++ 中数组从 `0` 开始，所以有些地方与上文中的表示不同。\n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint fail[MAXN] = { 0 };\n\n\tfail[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = fail[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = fail[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tfail[i] = k + 1;\n\t\t} else {\n\t\t\tfail[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << fail[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = fail[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n-->\n","slug":"kmp-notes","published":1,"updated":"2017-01-01T01:44:17.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rt500v2ooxlyhxrer1o"},{"title":"「JSOI2016」灯塔 - 分块 + RMQ","date":"2016-04-20T14:56:35.000Z","_content":"\nJSOI 的国境线上有 $ N $ 一座连续的山峰，其中第 $ i $ 座的高度是 $ h_i $。为了简单起见，我们认为这 $ N $ 座山峰排成了连续一条直线。\n\n如果在第 $ i $ 座山峰上建立一座高度为 $ p \\ (p \\geq 0) $ 的灯塔，JYY 发现，这座灯塔能够照亮第 $ j $ 座山峰，当且仅当满足如下不等式：\n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI 国王希望对于每一座山峰，JYY 都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度。你能帮助 JYY 么？\n\n<!-- more -->\n\n### 题解\n题目要求计算所有\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n打表可以发现 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 的取值有 $ O(\\sqrt{n}) $ 种，而对于每种取值，$ j $ 总是连续的最多两段区间。\n\n考虑每个 $ j $ 对 $ p_i $ 的影响，当 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 相同时，只有 $ h_j $ 最大的 $ j $ 会对 $ p_j $ 有影响。\n\n枚举 i，然后枚举 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 的值，问题转化为求一段区间内 $ h_j $ 的最大值，即 RMQ 问题，使用稀疏表即可解决。\n\n总时间复杂度为 $ O(n \\log n + n \\sqrt n) $，最大的数据要跑接近 3s ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-light.md","raw":"title: 「JSOI2016」灯塔 - 分块 + RMQ\ncategories: OI\ntags: \n  - JSOI\n  - 分块\n  - 乱搞\n  - RMQ\npermalink: jsoi2016-light\ndate: 2016-04-20 22:56:35\n---\n\nJSOI 的国境线上有 $ N $ 一座连续的山峰，其中第 $ i $ 座的高度是 $ h_i $。为了简单起见，我们认为这 $ N $ 座山峰排成了连续一条直线。\n\n如果在第 $ i $ 座山峰上建立一座高度为 $ p \\ (p \\geq 0) $ 的灯塔，JYY 发现，这座灯塔能够照亮第 $ j $ 座山峰，当且仅当满足如下不等式：\n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI 国王希望对于每一座山峰，JYY 都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度。你能帮助 JYY 么？\n\n<!-- more -->\n\n### 题解\n题目要求计算所有\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n打表可以发现 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 的取值有 $ O(\\sqrt{n}) $ 种，而对于每种取值，$ j $ 总是连续的最多两段区间。\n\n考虑每个 $ j $ 对 $ p_i $ 的影响，当 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 相同时，只有 $ h_j $ 最大的 $ j $ 会对 $ p_j $ 有影响。\n\n枚举 i，然后枚举 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 的值，问题转化为求一段区间内 $ h_j $ 的最大值，即 RMQ 问题，使用稀疏表即可解决。\n\n总时间复杂度为 $ O(n \\log n + n \\sqrt n) $，最大的数据要跑接近 3s ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-light","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rta00v9ooxl9eodp9pp"},{"title":"「JSOI2016」飞机调度 - 最短路 + 网络流","date":"2016-04-23T16:41:33.000Z","_content":"\nJSOI 王国里有 $ N $ 个机场，编号为 $ 1 $ 到 $ N $。从 $ i $ 号机场到 $ j $ 号机场需要飞行 $ T_{i, j} $ 的时间。由于风向，地理位置和航空管制的因素，$ T_{i, j} $ 和 $ T_{j, i} $ 并不一定相同。\n\n此外，由于飞机降落之后需要例行维修和加油。当一架飞机降落 $ k $ 号机场时，需要花费 $ P_k $ 的维护时间才能再次起飞。\n\nJS Airways 一共运营 $ M $ 条航线，其中第 $ i $ 条直飞航线需要在 $ D_i $ 时刻从 $ X_i $ 机场起飞，不经停，飞往 $ Y_i $ 机场。\n\n为了简化问题，我们假设 JS Airway 可以在 $ 0 $ 时刻在任意机场布置任意多架加油维护完毕的飞机；为了减少飞机的使用数，我们允许 JS Airways 增开任意多条临时航线以满足飞机的调度需求。\n\nJYY 想知道，理论上 JS Airways 最少需要多少架飞机才能完成所有这 $ M $ 个航班。\n\n<!-- more -->\n\n### 题解\n根据题意，从 $ i $ 机场经过 $ k $ 机场飞往 $ j $ 机场（不计在 $ i $、$ j $ 的维护时间）所需时间为 $ T[i][k] + P[k] + T[k][j] $，所以我们可以先使用 Floyd 求出任意两个机场之间经过若干次中转可以到达的最短时间。\n\n考虑两条航线 $ A $ 和 $ B $，若一架飞机飞完 $ A $ 后可以接着飞 $ B $，则需要满足的条件为（二者之一）：\n\n1. $ A $ 的终点为 $ B $ 的起点，且 $ A $ 的着陆时间加上维护时间早于 $ B $ 的起飞时间；\n2. $ A $ 的着陆时间加上从 $ A $ 的终点经过若干次中转到 $ B $ 的起点所用时间加上若干次维护时间早于 $ B $ 的起飞时间。\n\n根据上述两个条件，可以建立一张有向无环图，$ A \\Rightarrow B $ 有边当且仅当一架飞机飞完 $ A $ 航线后可以接着飞 $ B $ 航线。即一架飞机连续飞的航线组成了图中的一条路径，题目中要求飞机数最少，即可转化为使用最少的路径覆盖整个图，转化为二分图匹配模型，使用网络流解决即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-flight.md","raw":"title: 「JSOI2016」飞机调度 - 最短路 + 网络流\ncategories: OI\ntags: \n  - JSOI\n  - 网络流\n  - Dinic\n  - 最短路\n  - Floyd\npermalink: jsoi2016-flight\ndate: 2016-04-24 00:41:33\n---\n\nJSOI 王国里有 $ N $ 个机场，编号为 $ 1 $ 到 $ N $。从 $ i $ 号机场到 $ j $ 号机场需要飞行 $ T_{i, j} $ 的时间。由于风向，地理位置和航空管制的因素，$ T_{i, j} $ 和 $ T_{j, i} $ 并不一定相同。\n\n此外，由于飞机降落之后需要例行维修和加油。当一架飞机降落 $ k $ 号机场时，需要花费 $ P_k $ 的维护时间才能再次起飞。\n\nJS Airways 一共运营 $ M $ 条航线，其中第 $ i $ 条直飞航线需要在 $ D_i $ 时刻从 $ X_i $ 机场起飞，不经停，飞往 $ Y_i $ 机场。\n\n为了简化问题，我们假设 JS Airway 可以在 $ 0 $ 时刻在任意机场布置任意多架加油维护完毕的飞机；为了减少飞机的使用数，我们允许 JS Airways 增开任意多条临时航线以满足飞机的调度需求。\n\nJYY 想知道，理论上 JS Airways 最少需要多少架飞机才能完成所有这 $ M $ 个航班。\n\n<!-- more -->\n\n### 题解\n根据题意，从 $ i $ 机场经过 $ k $ 机场飞往 $ j $ 机场（不计在 $ i $、$ j $ 的维护时间）所需时间为 $ T[i][k] + P[k] + T[k][j] $，所以我们可以先使用 Floyd 求出任意两个机场之间经过若干次中转可以到达的最短时间。\n\n考虑两条航线 $ A $ 和 $ B $，若一架飞机飞完 $ A $ 后可以接着飞 $ B $，则需要满足的条件为（二者之一）：\n\n1. $ A $ 的终点为 $ B $ 的起点，且 $ A $ 的着陆时间加上维护时间早于 $ B $ 的起飞时间；\n2. $ A $ 的着陆时间加上从 $ A $ 的终点经过若干次中转到 $ B $ 的起点所用时间加上若干次维护时间早于 $ B $ 的起飞时间。\n\n根据上述两个条件，可以建立一张有向无环图，$ A \\Rightarrow B $ 有边当且仅当一架飞机飞完 $ A $ 航线后可以接着飞 $ B $ 航线。即一架飞机连续飞的航线组成了图中的一条路径，题目中要求飞机数最少，即可转化为使用最少的路径覆盖整个图，转化为二分图匹配模型，使用网络流解决即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-flight","published":1,"updated":"2016-05-11T09:33:58.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rtf00vgooxlnbkd5can"},{"title":"「JSOI2009」有趣的游戏 - AC 自动机 + 概率与期望","date":"2016-09-18T09:29:00.000Z","_content":"\n现有 $ n $ 个单词，均由前 $ m $ 个大写字母组成。每一时刻随机产生一个字母，产生第 $ i $ 个字母的概率为 $ {p_i \\over q_i} (0 \\leq p_i \\leq q_i) $。$ T $ 时刻后会产生一个长度为 $ T $ 的串。\n\n如果某个时刻，有一个单词在这个串中出现了，则过程结束。求产生的串中出现每个单词的概率。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1444](http://www.lydsy.com/JudgeOnline/problem.php?id=1444)\n\n### 题解\n对所有单词建立 AC 自动机，则问题转化为，在 AC 自动机上匹配产生的串，有多大概率使状态转移到每一个单词上。而每一个单词最多转移一次，问题又可以转化为，求在 AC 自动机上转移到每一个单词末尾节点上的期望次数。\n\n考虑从一个节点转移到另一个节点的概率。设 $ p(i) = \\frac{p_i}{q_i} $，节点 $ u $ 能在加入后转移到节点 $ v $ 的字母集合为 $ \\{ c_i \\} $，则从 $ u $ 转移到 $ v $ 的概率 $ P(u, v) = \\sum p(c_i) $。\n\n设转移到 AC 自动机上**非根**节点 $ i $ 的期望次数为 $ x_i $，则\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= 0 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= 0 \\\\\n\\end{aligned}\n$$\n\n对于根节点，因为它是自动机的起始状态，所以初始有 $ 1 $ 的期望次数。\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) + 1 \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= -1 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= -1 \\\\\n\\end{aligned}\n$$\n\n列出方程组，高斯消元求解即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst int BASE_CHAR = 'A';\nconst double EPS = 0.005;\n\nint charsetSize, n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < charsetSize; i++) c[i] = NULL;\n\t\t\tthis->id = n++;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\t// c = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\ndouble p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1];\n\ninline void buildMatrix() {\n\tfor (int i = 1; i < n; i++) matrix[i][i] = -1;\n\tmatrix[0][0] = -1, matrix[0][n] = -1;\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) continue;\n\n\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t// printf(\"%d -> %d\\n\", v->id, v->c[i]->id);\n\t\t\tmatrix[v->c[i]->id][v->id] += p[i];\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void gauss() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (fabs(matrix[i][i]) < EPS) {\n\t\t\tfor (int j = i + 1; j < n; j++) if (matrix[j][i] >= EPS) {\n\t\t\t\tstd::swap(matrix[i], matrix[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for (int j = i + 1; j < n; j++) if (max == -1 || fabs(matrix[j][i]) > fabs(matrix[max][i])) max = j;\n\t\t// if (max != i) std::swap(matrix[max], matrix[i]);\n\n\t\tdouble t = matrix[i][i];\n\t\tfor (int j = 0; j < n + 1; j++) matrix[i][j] /= t;\n\n\t\tfor (int j = 0; j < n; j++) if (j != i) {\n\t\t\tdouble t = matrix[j][i];\n\t\t\tfor (int k = i; k < n + 1; k++) matrix[j][k] -= t * matrix[i][k];\n\t\t}\n\t}\n}\n\nbool gauss_jordan() {\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = 0; j < n; ++j) if (fabs(matrix[j][i]) > fabs(matrix[idx][i])) idx = j;\n        // if (fabs(matrix[idx][i]) <= eps) return false;\n        if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j <= n; ++j) std::swap(matrix[i][j], matrix[idx][j]);\n        for (int j = 0; j < n; ++j) if (i != j) {\n            double tmp = matrix[j][i] / matrix[i][i];\n            for (int k = n; k >= i; --k) matrix[j][k] -= matrix[i][k] * tmp;\n        }\n    }\n    return true;\n}\n\nint main() {\n\tint m, l;\n\tscanf(\"%d %d %d\", &m, &l, &charsetSize);\n\tfor (int i = 0; i < charsetSize; i++) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf %lf\", &a, &b);\n\t\tp[i] = a / b;\n\t}\n\n\tstatic Trie::Node *a[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tchar s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\ts[i] -= BASE_CHAR;\n\t\t\tif (p[s[i]] == 0) cnt++;\n\t\t}\n\t\ta[i] = t.insert(s, s + l);\n\t}\n\n\t/*\n\tif (cnt == m) {\n\t\tfor (int i = 0; i < m; i++) puts(\"0.00\");\n\t\treturn 0;\n\t}\n\t*/\n\n\tt.build();\n\n\tbuildMatrix();\n\t// for (int i = 0; i <= n; i++) matrix[0][i] = -matrix[0][i];\n\tgauss();\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) printf(\"%.2lf%c\", matrix[i][j], j == n ? '\\n' : ' ');\n\t}\n\t*/\n\n\tfor (int i = 0; i < m; i++) printf(\"%.2lf\\n\", matrix[a[i]->id][n] < EPS ? 0.0f : matrix[a[i]->id][n]);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2009-game2.md","raw":"title: 「JSOI2009」有趣的游戏 - AC 自动机 + 概率与期望\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 字符串\n  - AC 自动机\n  - 概率与期望\n  - 数学\n  - 高斯消元\npermalink: jsoi2009-game2\ndate: 2016-09-18 17:29:00\n---\n\n现有 $ n $ 个单词，均由前 $ m $ 个大写字母组成。每一时刻随机产生一个字母，产生第 $ i $ 个字母的概率为 $ {p_i \\over q_i} (0 \\leq p_i \\leq q_i) $。$ T $ 时刻后会产生一个长度为 $ T $ 的串。\n\n如果某个时刻，有一个单词在这个串中出现了，则过程结束。求产生的串中出现每个单词的概率。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1444](http://www.lydsy.com/JudgeOnline/problem.php?id=1444)\n\n### 题解\n对所有单词建立 AC 自动机，则问题转化为，在 AC 自动机上匹配产生的串，有多大概率使状态转移到每一个单词上。而每一个单词最多转移一次，问题又可以转化为，求在 AC 自动机上转移到每一个单词末尾节点上的期望次数。\n\n考虑从一个节点转移到另一个节点的概率。设 $ p(i) = \\frac{p_i}{q_i} $，节点 $ u $ 能在加入后转移到节点 $ v $ 的字母集合为 $ \\{ c_i \\} $，则从 $ u $ 转移到 $ v $ 的概率 $ P(u, v) = \\sum p(c_i) $。\n\n设转移到 AC 自动机上**非根**节点 $ i $ 的期望次数为 $ x_i $，则\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= 0 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= 0 \\\\\n\\end{aligned}\n$$\n\n对于根节点，因为它是自动机的起始状态，所以初始有 $ 1 $ 的期望次数。\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) + 1 \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= -1 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= -1 \\\\\n\\end{aligned}\n$$\n\n列出方程组，高斯消元求解即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst int BASE_CHAR = 'A';\nconst double EPS = 0.005;\n\nint charsetSize, n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < charsetSize; i++) c[i] = NULL;\n\t\t\tthis->id = n++;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\t// c = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\ndouble p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1];\n\ninline void buildMatrix() {\n\tfor (int i = 1; i < n; i++) matrix[i][i] = -1;\n\tmatrix[0][0] = -1, matrix[0][n] = -1;\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) continue;\n\n\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t// printf(\"%d -> %d\\n\", v->id, v->c[i]->id);\n\t\t\tmatrix[v->c[i]->id][v->id] += p[i];\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void gauss() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (fabs(matrix[i][i]) < EPS) {\n\t\t\tfor (int j = i + 1; j < n; j++) if (matrix[j][i] >= EPS) {\n\t\t\t\tstd::swap(matrix[i], matrix[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for (int j = i + 1; j < n; j++) if (max == -1 || fabs(matrix[j][i]) > fabs(matrix[max][i])) max = j;\n\t\t// if (max != i) std::swap(matrix[max], matrix[i]);\n\n\t\tdouble t = matrix[i][i];\n\t\tfor (int j = 0; j < n + 1; j++) matrix[i][j] /= t;\n\n\t\tfor (int j = 0; j < n; j++) if (j != i) {\n\t\t\tdouble t = matrix[j][i];\n\t\t\tfor (int k = i; k < n + 1; k++) matrix[j][k] -= t * matrix[i][k];\n\t\t}\n\t}\n}\n\nbool gauss_jordan() {\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = 0; j < n; ++j) if (fabs(matrix[j][i]) > fabs(matrix[idx][i])) idx = j;\n        // if (fabs(matrix[idx][i]) <= eps) return false;\n        if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j <= n; ++j) std::swap(matrix[i][j], matrix[idx][j]);\n        for (int j = 0; j < n; ++j) if (i != j) {\n            double tmp = matrix[j][i] / matrix[i][i];\n            for (int k = n; k >= i; --k) matrix[j][k] -= matrix[i][k] * tmp;\n        }\n    }\n    return true;\n}\n\nint main() {\n\tint m, l;\n\tscanf(\"%d %d %d\", &m, &l, &charsetSize);\n\tfor (int i = 0; i < charsetSize; i++) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf %lf\", &a, &b);\n\t\tp[i] = a / b;\n\t}\n\n\tstatic Trie::Node *a[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tchar s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\ts[i] -= BASE_CHAR;\n\t\t\tif (p[s[i]] == 0) cnt++;\n\t\t}\n\t\ta[i] = t.insert(s, s + l);\n\t}\n\n\t/*\n\tif (cnt == m) {\n\t\tfor (int i = 0; i < m; i++) puts(\"0.00\");\n\t\treturn 0;\n\t}\n\t*/\n\n\tt.build();\n\n\tbuildMatrix();\n\t// for (int i = 0; i <= n; i++) matrix[0][i] = -matrix[0][i];\n\tgauss();\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) printf(\"%.2lf%c\", matrix[i][j], j == n ? '\\n' : ' ');\n\t}\n\t*/\n\n\tfor (int i = 0; i < m; i++) printf(\"%.2lf\\n\", matrix[a[i]->id][n] < EPS ? 0.0f : matrix[a[i]->id][n]);\n\n\treturn 0;\n}\n```","slug":"jsoi2009-game2","published":1,"updated":"2016-09-18T09:30:31.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rtk00vnooxl69lpu6t0"},{"title":"「JSOI2009」游戏 - 博弈 + 二分图匹配","date":"2016-04-28T14:10:42.000Z","_content":"\n在 $ N \\times M $ 的迷宫中有一个棋子，AA 首先任意选择棋子放置的位置。然后，YY 和 AA 轮流将棋子移动到相邻的格子里。\n\n游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。\n\n求 AA 初始将棋子放在哪些格子会有必胜策略。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### 题解\n题目要求 AA 初始放置棋子的位置，使得 AA 有必胜策略，即为求必败态（因为 AA 是后手）。\n\n对网格图进行奇偶染色，建立二分图，求出有效格子的最大匹配。\n\n考虑将初始点放置在非匹配点上，如果此时没有任何边与其相连，则 YY 负，否则 YY 一定会沿着一条**非匹配**边走向另一个**匹配**点（如果这个点是非匹配点，则匹配这条边后，总匹配数可以增加，显然与最大匹配相矛盾），此时 AA 一定可以沿着一条匹配边走回来，状态恢复到初始状态，最终 YY 找不到一条非匹配边，负。\n\n我们得到结论：不在最大匹配上的点，一定是先手必败点。\n\n而如果一个点在最大匹配上，我们考虑这样一条路径，从该点开始沿着匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 走下去，如果这条路径的长度（边的数量）为偶数，则终点和起点在（二分图划分中的）同一集合中。此时将整个路径中每条边时候匹配取反，则整张图仍然是一个最大匹配。\n\n另一个结论：如果一个点**不一定**在最大匹配上，则它一定是先手必败点。\n\n使用 Dinic 算法求出二分图最大匹配后，在残量网络上进行 BFS，从源点开始，始终沿着**不满流**的边走，所有经过的且在左侧的点均**不一定在最大匹配上**，右边同理。\n\n考虑上述算法的正确性，从源点走向的第一个点一定是**非匹配点**，继续走一步，一定是沿着**非匹配边**会走到右侧点，再走一步，一定是沿着**匹配边的反向边**走回左侧。显然，每次走到左侧的点时，路径长度均为偶数，且沿着二分图中的匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 得证。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","source":"_posts/jsoi2009-game.md","raw":"title: 「JSOI2009」游戏 - 博弈 + 二分图匹配\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 博弈\n  - 二分图匹配\n  - 网络流\n  - Dinic\npermalink: jsoi2009-game\ndate: 2016-04-28 22:10:42\n---\n\n在 $ N \\times M $ 的迷宫中有一个棋子，AA 首先任意选择棋子放置的位置。然后，YY 和 AA 轮流将棋子移动到相邻的格子里。\n\n游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。\n\n求 AA 初始将棋子放在哪些格子会有必胜策略。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### 题解\n题目要求 AA 初始放置棋子的位置，使得 AA 有必胜策略，即为求必败态（因为 AA 是后手）。\n\n对网格图进行奇偶染色，建立二分图，求出有效格子的最大匹配。\n\n考虑将初始点放置在非匹配点上，如果此时没有任何边与其相连，则 YY 负，否则 YY 一定会沿着一条**非匹配**边走向另一个**匹配**点（如果这个点是非匹配点，则匹配这条边后，总匹配数可以增加，显然与最大匹配相矛盾），此时 AA 一定可以沿着一条匹配边走回来，状态恢复到初始状态，最终 YY 找不到一条非匹配边，负。\n\n我们得到结论：不在最大匹配上的点，一定是先手必败点。\n\n而如果一个点在最大匹配上，我们考虑这样一条路径，从该点开始沿着匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 走下去，如果这条路径的长度（边的数量）为偶数，则终点和起点在（二分图划分中的）同一集合中。此时将整个路径中每条边时候匹配取反，则整张图仍然是一个最大匹配。\n\n另一个结论：如果一个点**不一定**在最大匹配上，则它一定是先手必败点。\n\n使用 Dinic 算法求出二分图最大匹配后，在残量网络上进行 BFS，从源点开始，始终沿着**不满流**的边走，所有经过的且在左侧的点均**不一定在最大匹配上**，右边同理。\n\n考虑上述算法的正确性，从源点走向的第一个点一定是**非匹配点**，继续走一步，一定是沿着**非匹配边**会走到右侧点，再走一步，一定是沿着**匹配边的反向边**走回左侧。显然，每次走到左侧的点时，路径长度均为偶数，且沿着二分图中的匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 得证。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","slug":"jsoi2009-game","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rtq00vxooxl8iv12hvc"},{"title":"「JSOI2008」星球大战 - 离线 + 并查集","date":"2016-10-18T13:14:00.000Z","_content":"\n给一个图，每次删除一个点，求连通块数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015)\n\n### 题解\n记录所有被删除的点，将除这些点邻边之外所有的边加入并查集，将操作离线变为加边，每次加入一个点的一些邻边，当某个邻边指向的点已被加入时，加入这条边。\n\n### 代码\n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXM = 200000;\nconst int MAXN = 2 * MAXM;\n\nstruct UnionFindSet {\n\tint a[MAXN], rk[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i, rk[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n\n\tvoid merge(const int x, const int y) {\n\t\tconst int p = find(x), q = find(y);\n\t\tif (p == q) return;\n\t\tif (rk[p] > rk[q]) a[q] = p;\n\t\telse if (rk[q] > rk[p]) a[p] = q;\n\t\telse a[p] = q, rk[q]++;\n\t}\n} ufs;\n\nstruct Edge {\n\tbool added;\n\tint u, v;\n} E[MAXM];\n\nstruct Node {\n\tstd::vector<Edge *> e;\n\tbool added;\n\tbool willDelete;\n} N[MAXN];\n\ninline void addAllEdge(Node *v, int &ans) {\n\tans++;\n\tfor (std::vector<Edge *>::const_iterator it = v->e.begin(); it != v->e.end(); it++) {\n\t\tEdge *const &e = *it;\n\t\tif (!e->added && N[e->u].added && N[e->v].added && !ufs.test(e->u, e->v)) {\n\t\t\tufs.merge(e->u, e->v);\n\t\t\t// printf(\"merge(%d, %d)\\n\", e->u, e->v);\n\t\t\tans--;\n\t\t\te->added = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k, ans;\n\tstatic int a[MAXN];\n\tscanf(\"%d %d\", &n, &m), ans = 0;\n\n\tufs.init(n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v), N[E[i].u].e.push_back(&E[i]), N[E[i].v].e.push_back(&E[i]);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = k - 1; i >= 0; i--) scanf(\"%d\", &a[i]), N[a[i]].willDelete = true;\n\n\tfor (int i = 0; i < n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&N[i], ans);\n\n\tstd::vector<int> anses;\n\tanses.push_back(ans);\n\t\n\tfor (int i = 0; i < k; i++) {\n\t\t// printf(\"before %d\\n\", a[i]);\n\t\tNode *v = &N[a[i]];\n\t\tv->added = true;\n\t\taddAllEdge(v, ans);\n\t\tanses.push_back(ans);\n\t}\n\n\tfor (std::vector<int>::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-starwar.md","raw":"title: 「JSOI2008」星球大战 - 离线 + 并查集\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 并查集\n  - 离线\npermalink: jsoi2008-starwar\ndate: 2016-10-18 21:14:00\n---\n\n给一个图，每次删除一个点，求连通块数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015)\n\n### 题解\n记录所有被删除的点，将除这些点邻边之外所有的边加入并查集，将操作离线变为加边，每次加入一个点的一些邻边，当某个邻边指向的点已被加入时，加入这条边。\n\n### 代码\n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXM = 200000;\nconst int MAXN = 2 * MAXM;\n\nstruct UnionFindSet {\n\tint a[MAXN], rk[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i, rk[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n\n\tvoid merge(const int x, const int y) {\n\t\tconst int p = find(x), q = find(y);\n\t\tif (p == q) return;\n\t\tif (rk[p] > rk[q]) a[q] = p;\n\t\telse if (rk[q] > rk[p]) a[p] = q;\n\t\telse a[p] = q, rk[q]++;\n\t}\n} ufs;\n\nstruct Edge {\n\tbool added;\n\tint u, v;\n} E[MAXM];\n\nstruct Node {\n\tstd::vector<Edge *> e;\n\tbool added;\n\tbool willDelete;\n} N[MAXN];\n\ninline void addAllEdge(Node *v, int &ans) {\n\tans++;\n\tfor (std::vector<Edge *>::const_iterator it = v->e.begin(); it != v->e.end(); it++) {\n\t\tEdge *const &e = *it;\n\t\tif (!e->added && N[e->u].added && N[e->v].added && !ufs.test(e->u, e->v)) {\n\t\t\tufs.merge(e->u, e->v);\n\t\t\t// printf(\"merge(%d, %d)\\n\", e->u, e->v);\n\t\t\tans--;\n\t\t\te->added = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k, ans;\n\tstatic int a[MAXN];\n\tscanf(\"%d %d\", &n, &m), ans = 0;\n\n\tufs.init(n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v), N[E[i].u].e.push_back(&E[i]), N[E[i].v].e.push_back(&E[i]);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = k - 1; i >= 0; i--) scanf(\"%d\", &a[i]), N[a[i]].willDelete = true;\n\n\tfor (int i = 0; i < n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&N[i], ans);\n\n\tstd::vector<int> anses;\n\tanses.push_back(ans);\n\t\n\tfor (int i = 0; i < k; i++) {\n\t\t// printf(\"before %d\\n\", a[i]);\n\t\tNode *v = &N[a[i]];\n\t\tv->added = true;\n\t\taddAllEdge(v, ans);\n\t\tanses.push_back(ans);\n\t}\n\n\tfor (std::vector<int>::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","slug":"jsoi2008-starwar","published":1,"updated":"2016-10-18T13:20:00.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rtw00w6ooxlkgx27f4e"},{"title":"「JSOI2008」火星人 - Splay + Hash","date":"2016-10-18T12:16:00.000Z","_content":"\n给定一个字符串，每次修改一个字符、插入一个字符、查询某两个后缀的最长公共前缀。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1014](http://www.lydsy.com/JudgeOnline/problem.php?id=1014)\n\n### 题解\n使用 Splay 维护字符串 Hash，在每个节点上维护整棵子树的 Hash 值，合并两棵子树的 Hash 值时，右子树的 Hash 值乘以一个较高次幂。\n\n二分求 LCP 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid rotate() {\n\t\t\tNode *o = p;\n\t\t\tint x = relation();\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (relation() == p->relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = 1;\n\t\t\tif (c[0]) size += c[0]->size;\n\t\t\tif (c[1]) size += c[1]->size;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() { return c[0] ? c[0]->size : 0; }\n\n\t\tvoid print(const int depth = 0) {\n\t\t\tif (c[1]) c[1]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\tprintf(\"%c\\n\", val == 0 ? ' ' : val);\n\t\t\tif (c[0]) c[0]->print(depth + 1);\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {}\n\n\tNode *build(const char *first, const char *last, Node *p) {\n\t\tif (first > last) return NULL;\n\t\tif (first == last) return new Node(p, &r, *first);\n\t\telse {\n\t\t\tconst char *mid = first + (last - first) / 2;\n\t\t\tNode *v = new Node(p, &r, *mid);\n\t\t\tv->c[0] = build(first, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, last, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBounds(const int x) {\n\t\tNode *v = r;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &r, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->p;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *first, const char *last) {\n\t\tr = build(first, last, NULL);\n\t\tbuildBounds(0);\n\t\tbuildBounds(1);\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x < v->lsize() + 1) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(const int l, const int r) {\n\t\tNode *a = select(l - 1), *b = select(r + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\treturn b->c[0];\n\t}\n\n\tNode *insert(const int pos, const char ch) {\n\t\tNode *a = select(pos), *b = select(pos + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\tb->c[0] = new Node(b, &r, ch);\n\t\tNode *v = b->c[0];\n\t\tdo {\n\t\t\tv->maintain();\n\t\t\tv = v->p;\n\t\t} while (v);\n\t\treturn b->c[0]->splay();\n\t}\n\n\tvoid update(const int pos, const char ch) {\n\t\tNode *v = select(pos);\n\t\tv->val = ch;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(const int l, const int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() { return r->size - 2; }\n} splay;\n\ninline void print() {\n\tsplay.r->print();\n\tputs(\"------------------------\");\n}\n\ninline int lcp(const int a, const int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE;\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.update(pos, ch[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.insert(pos, ch[0]);\n\t\t}\n\n\t\t// print();\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-prefix.md","raw":"title: 「JSOI2008」火星人 - Splay + Hash\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - Hash\n  - 字符串\npermalink: jsoi2008-prefix\ndate: 2016-10-18 20:16:00\n---\n\n给定一个字符串，每次修改一个字符、插入一个字符、查询某两个后缀的最长公共前缀。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1014](http://www.lydsy.com/JudgeOnline/problem.php?id=1014)\n\n### 题解\n使用 Splay 维护字符串 Hash，在每个节点上维护整棵子树的 Hash 值，合并两棵子树的 Hash 值时，右子树的 Hash 值乘以一个较高次幂。\n\n二分求 LCP 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid rotate() {\n\t\t\tNode *o = p;\n\t\t\tint x = relation();\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (relation() == p->relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = 1;\n\t\t\tif (c[0]) size += c[0]->size;\n\t\t\tif (c[1]) size += c[1]->size;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() { return c[0] ? c[0]->size : 0; }\n\n\t\tvoid print(const int depth = 0) {\n\t\t\tif (c[1]) c[1]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\tprintf(\"%c\\n\", val == 0 ? ' ' : val);\n\t\t\tif (c[0]) c[0]->print(depth + 1);\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {}\n\n\tNode *build(const char *first, const char *last, Node *p) {\n\t\tif (first > last) return NULL;\n\t\tif (first == last) return new Node(p, &r, *first);\n\t\telse {\n\t\t\tconst char *mid = first + (last - first) / 2;\n\t\t\tNode *v = new Node(p, &r, *mid);\n\t\t\tv->c[0] = build(first, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, last, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBounds(const int x) {\n\t\tNode *v = r;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &r, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->p;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *first, const char *last) {\n\t\tr = build(first, last, NULL);\n\t\tbuildBounds(0);\n\t\tbuildBounds(1);\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x < v->lsize() + 1) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(const int l, const int r) {\n\t\tNode *a = select(l - 1), *b = select(r + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\treturn b->c[0];\n\t}\n\n\tNode *insert(const int pos, const char ch) {\n\t\tNode *a = select(pos), *b = select(pos + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\tb->c[0] = new Node(b, &r, ch);\n\t\tNode *v = b->c[0];\n\t\tdo {\n\t\t\tv->maintain();\n\t\t\tv = v->p;\n\t\t} while (v);\n\t\treturn b->c[0]->splay();\n\t}\n\n\tvoid update(const int pos, const char ch) {\n\t\tNode *v = select(pos);\n\t\tv->val = ch;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(const int l, const int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() { return r->size - 2; }\n} splay;\n\ninline void print() {\n\tsplay.r->print();\n\tputs(\"------------------------\");\n}\n\ninline int lcp(const int a, const int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE;\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.update(pos, ch[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.insert(pos, ch[0]);\n\t\t}\n\n\t\t// print();\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-prefix","published":1,"updated":"2016-10-18T13:10:35.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ru100wcooxlcqqts8cq"},{"title":"「JSOI2008」最大数 - Splay","id":"56","updated":"2016-02-20T02:13:55.000Z","date":"2016-02-20T02:11:00.000Z","_content":"\n现在请求你维护一个数列，要求提供以下两种操作：\n\n1. 查询操作。  \n   语法：`Q L`  \n   功能：查询当前数列中末尾 `L` 个数中的最大的数，并输出这个数的值。  \n   限制：`L` 不超过当前数列的长度。\n2. 插入操作。\n   语法：`A n`  \n   功能：将 `n` 加上 `t`，其中 `t` 是最近一次查询操作的答案（如果还未执行过查询操作，则 `t = 0`)，并将所得结果对一个固定的常数 `D` 取模，将所得答案插入到数列的末尾。  \n   限制：`n` 是非负整数并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### 题解\nSplay 裸题不用说了吧 ……\n\n话说开一棵大线段树也资磁吧？\n\n敲个 Splay 练练代码能力，结果折腾了俩小时，这段时间代码能力急剧下降啊！qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-maxnumber.md","raw":"title: 「JSOI2008」最大数 - Splay\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - 数据结构\n  - 高级数据结构\npermalink: jsoi2008-maxnumber\nid: 56\nupdated: '2016-02-20 10:13:55'\ndate: 2016-02-20 10:11:00\n---\n\n现在请求你维护一个数列，要求提供以下两种操作：\n\n1. 查询操作。  \n   语法：`Q L`  \n   功能：查询当前数列中末尾 `L` 个数中的最大的数，并输出这个数的值。  \n   限制：`L` 不超过当前数列的长度。\n2. 插入操作。\n   语法：`A n`  \n   功能：将 `n` 加上 `t`，其中 `t` 是最近一次查询操作的答案（如果还未执行过查询操作，则 `t = 0`)，并将所得结果对一个固定的常数 `D` 取模，将所得答案插入到数列的末尾。  \n   限制：`n` 是非负整数并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### 题解\nSplay 裸题不用说了吧 ……\n\n话说开一棵大线段树也资磁吧？\n\n敲个 Splay 练练代码能力，结果折腾了俩小时，这段时间代码能力急剧下降啊！qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-maxnumber","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ru700wjooxldpiytopo"},{"title":"「JSOI2008」魔兽地图 - 背包 DP","date":"2016-07-11T15:10:00.000Z","_content":"\n游戏中，一些装备有价格，可以无限购买；另一些装备需要其它装备合成，这些装备有合成次数限制。每个装备都有膜法值，求 $ M $ 个金币最多能得到多少膜法值的装备。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1017](http://www.lydsy.com/JudgeOnline/problem.php?id=1017)\n\n### 题解\n对于每个装备，$ f(i, j) $ 表示先获取 $ i $ 个用于合成其它装备，一共最多用 $ j $ 个金币，的最大收益。\n\n对于需要合成的装备，用 $ g(i, j) $ 表示前 $ i $ 棵子树用 $ j $ 个金币的最大收益。用类似背包的方法转移。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 51;\nconst int MAXM = 2000;\nconst int MAXK = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, val, ind;\n\tbool basic; // , visited;\n\tint f[MAXK + 1][MAXM + 1];\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\t// printf(\"E(%d, %d, %d)\\n\", s, t, w);\n\tN[t].ind++;\n\tN[s].e = new Edge(&N[s], &N[t], w);\n}\n\nint n, m, ans;\n\ninline void bfs() {\n\tint pos = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].ind) continue;\n\t\t// printf(\"%d\\n\", i);\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\t// N[i].visited = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tfor (Edge *e = (seq[--pos] = q.front())->e; e; e = e->next) q.push(e->t); // , e->t->visited = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n}\n\ninline void dp1() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tif (!v->basic) {\n\t\t\tv->cnt = INT_MAX;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->cnt = std::min(v->cnt, e->t->cnt / e->w);\n\t\t\t\tv->cost += e->t->cost * e->w;\n\t\t\t}\n\t\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\t}\n\t}\n}\n\ninline void dp2() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tint (&f)[MAXK + 1][MAXM + 1] = v->f;\n\t\tstatic int g[MAXN + 1][MAXM + 1];\n\n\t\tif (v->basic) {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\tfor (int j = v->cost * i; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::max(f[i][j], std::min(v->cnt - i, (j - v->cost * i) / v->cost) * v->val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\t// memset(g, 0, sizeof(g));\n\t\t\t\tfor (int i = 0; i <= MAXN; i++) for (int j = 0; j <= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN;\n\t\t\t\t// if (!v->e) {\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\t\tf[j][k] = std::max(f[j][k], v->val * (i - j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t// } else {\n\t\t\t\t\t// for (int j = v->cost * i; j <= m; j++) g[j] = v->val * i;\n\n\t\t\t\tint id = 0;\n\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\tid++;\n\t\t\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\t\t\tfor (int k = i * e->w * e->t->cost; k <= j; k++) {\n\t\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->t->f[e->w * i][k]);\n\t\t\t\t\t\t\t// if (j - k * e->t->cost >= v->cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e->t->cost]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// printf(\"g[%d][%d] = %d\\n\", i, j, g[i][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\tf[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v->val);\n\t\t\t\t\t\tans = std::max(ans, f[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &N[i].val);\n\t\tchar s[2];\n\t\tscanf(\"%s\", s);\n\n\t\tif (s[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\twhile (t--) {\n\t\t\t\tint u, w;\n\t\t\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\t\t\taddEdge(i, u, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs();\n\tdp1();\n\tdp2();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2008-dotr.md","raw":"title: 「JSOI2008」魔兽地图 - 背包 DP\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - DP\n  - 背包 DP\npermalink: jsoi2008-dotr\ndate: 2016-07-11 23:10:00\n---\n\n游戏中，一些装备有价格，可以无限购买；另一些装备需要其它装备合成，这些装备有合成次数限制。每个装备都有膜法值，求 $ M $ 个金币最多能得到多少膜法值的装备。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1017](http://www.lydsy.com/JudgeOnline/problem.php?id=1017)\n\n### 题解\n对于每个装备，$ f(i, j) $ 表示先获取 $ i $ 个用于合成其它装备，一共最多用 $ j $ 个金币，的最大收益。\n\n对于需要合成的装备，用 $ g(i, j) $ 表示前 $ i $ 棵子树用 $ j $ 个金币的最大收益。用类似背包的方法转移。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 51;\nconst int MAXM = 2000;\nconst int MAXK = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, val, ind;\n\tbool basic; // , visited;\n\tint f[MAXK + 1][MAXM + 1];\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\t// printf(\"E(%d, %d, %d)\\n\", s, t, w);\n\tN[t].ind++;\n\tN[s].e = new Edge(&N[s], &N[t], w);\n}\n\nint n, m, ans;\n\ninline void bfs() {\n\tint pos = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].ind) continue;\n\t\t// printf(\"%d\\n\", i);\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\t// N[i].visited = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tfor (Edge *e = (seq[--pos] = q.front())->e; e; e = e->next) q.push(e->t); // , e->t->visited = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n}\n\ninline void dp1() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tif (!v->basic) {\n\t\t\tv->cnt = INT_MAX;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->cnt = std::min(v->cnt, e->t->cnt / e->w);\n\t\t\t\tv->cost += e->t->cost * e->w;\n\t\t\t}\n\t\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\t}\n\t}\n}\n\ninline void dp2() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tint (&f)[MAXK + 1][MAXM + 1] = v->f;\n\t\tstatic int g[MAXN + 1][MAXM + 1];\n\n\t\tif (v->basic) {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\tfor (int j = v->cost * i; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::max(f[i][j], std::min(v->cnt - i, (j - v->cost * i) / v->cost) * v->val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\t// memset(g, 0, sizeof(g));\n\t\t\t\tfor (int i = 0; i <= MAXN; i++) for (int j = 0; j <= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN;\n\t\t\t\t// if (!v->e) {\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\t\tf[j][k] = std::max(f[j][k], v->val * (i - j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t// } else {\n\t\t\t\t\t// for (int j = v->cost * i; j <= m; j++) g[j] = v->val * i;\n\n\t\t\t\tint id = 0;\n\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\tid++;\n\t\t\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\t\t\tfor (int k = i * e->w * e->t->cost; k <= j; k++) {\n\t\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->t->f[e->w * i][k]);\n\t\t\t\t\t\t\t// if (j - k * e->t->cost >= v->cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e->t->cost]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// printf(\"g[%d][%d] = %d\\n\", i, j, g[i][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\tf[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v->val);\n\t\t\t\t\t\tans = std::max(ans, f[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &N[i].val);\n\t\tchar s[2];\n\t\tscanf(\"%s\", s);\n\n\t\tif (s[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\twhile (t--) {\n\t\t\t\tint u, w;\n\t\t\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\t\t\taddEdge(i, u, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs();\n\tdp1();\n\tdp2();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2008-dotr","published":1,"updated":"2016-10-24T23:37:01.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ruc00wqooxlpzw8wzrg"},{"title":"「JSOI2008」最小生成树计数 - 搜索","date":"2016-10-18T13:34:00.000Z","_content":"\n求一个图的不同的最小生成树的数量，保证相同权值的边数量 $ \\leq 10 $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1016](http://www.lydsy.com/JudgeOnline/problem.php?id=1016)\n\n### 题解\n> 对于一个最小生成树，使用相同数量的一些边替换掉其中与其权值相同的边，如果得到的图没有环，则仍然是一棵最小生成树。\n\n详细证明见：https://blog.sengxian.com/solutions/bzoj-1016\n\n对于每一种权值，枚举所有不在最小生成树中的边，乘法原理即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nconst int MAXN = 100;\nconst int MAXM = 1000;\nconst int MAXC = 1000000000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool used;\n\n\tbool operator<(const Edge &other) const { return w < other.w; }\n} E[MAXM];\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tvoid merge(const int x, const int y) {\n\t\ta[find(x)] = find(y);\n\t}\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n} ufs;\n\nstruct EdgeGroup {\n\tint used;\n\tstd::vector<Edge> edges;\n};\n\nint n, m, graph[MAXN][MAXN];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.test(E[i].u, E[i].v)) {\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tE[i].used = true;\n\t\t\tgroups[E[i].w].used++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].edges.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w), E[i].u--, E[i].v--;\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.used == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.edges.size()); s++) {\n\t\t\t\tint popcount = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.edges.size(); i++) if (s & (1 << i)) popcount++;\n\t\t\t\tif (popcount != it->second.used) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tif (!(s & (1 << (e - it->second.edges.begin())))) continue;\n\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tif (graph[i][j]) {\n\t\t\t\t\t\t\tif (ufs.test(i, j)) {\n\t\t\t\t\t\t\t\tgoto nextLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\nnextLoop:;\n\t\t\t}\n\t\t\t// printf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = e->used;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-award.md","raw":"title: 「JSOI2008」最小生成树计数 - 搜索\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 最小生成树\n  - 搜索\npermalink: jsoi2008-award\ndate: 2016-10-18 21:34:00\n---\n\n求一个图的不同的最小生成树的数量，保证相同权值的边数量 $ \\leq 10 $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1016](http://www.lydsy.com/JudgeOnline/problem.php?id=1016)\n\n### 题解\n> 对于一个最小生成树，使用相同数量的一些边替换掉其中与其权值相同的边，如果得到的图没有环，则仍然是一棵最小生成树。\n\n详细证明见：https://blog.sengxian.com/solutions/bzoj-1016\n\n对于每一种权值，枚举所有不在最小生成树中的边，乘法原理即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nconst int MAXN = 100;\nconst int MAXM = 1000;\nconst int MAXC = 1000000000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool used;\n\n\tbool operator<(const Edge &other) const { return w < other.w; }\n} E[MAXM];\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tvoid merge(const int x, const int y) {\n\t\ta[find(x)] = find(y);\n\t}\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n} ufs;\n\nstruct EdgeGroup {\n\tint used;\n\tstd::vector<Edge> edges;\n};\n\nint n, m, graph[MAXN][MAXN];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.test(E[i].u, E[i].v)) {\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tE[i].used = true;\n\t\t\tgroups[E[i].w].used++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].edges.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w), E[i].u--, E[i].v--;\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.used == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.edges.size()); s++) {\n\t\t\t\tint popcount = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.edges.size(); i++) if (s & (1 << i)) popcount++;\n\t\t\t\tif (popcount != it->second.used) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tif (!(s & (1 << (e - it->second.edges.begin())))) continue;\n\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tif (graph[i][j]) {\n\t\t\t\t\t\t\tif (ufs.test(i, j)) {\n\t\t\t\t\t\t\t\tgoto nextLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\nnextLoop:;\n\t\t\t}\n\t\t\t// printf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = e->used;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-award","published":1,"updated":"2016-10-18T13:41:02.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ruh00wwooxlfh07q9na"},{"title":"「JSOI2007」建筑抢修 - 贪心","date":"2016-11-13T01:11:00.000Z","_content":"\n部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029)\n\n### 题解\n将所有建筑按照最晚修理时间排序，维护当前时间点，枚举每个建筑，如果当前安时间足够修理这个建筑，则修理这个建筑，并将当前时间加上修理所用时间。如果当前时间不足以修改这个建筑，则尝试替换之前修理的**所用时间最多**的一个建筑。因为当前建筑的最晚修理时间更大，且用时更短，所以这样替换一定合法，并且这样替换可以使答案不变的情况下当前时间点尽量小。\n\n使用优先队列维护最大值。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 150000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic std::pair<int, int> a[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].second, &a[i].first);\n\n\tstd::sort(a, a + n);\n\n\tstd::priority_queue<int> q;\n\tlong long t = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t + a[i].second <= a[i].first) {\n\t\t\tt += a[i].second;\n\t\t\tq.push(a[i].second);\n\t\t\tans++;\n\t\t} else if (!q.empty() && q.top() > a[i].second) {\n\t\t\tt -= q.top();\n\t\t\tt += a[i].second;\n\t\t\tq.pop();\n\t\t\tq.push(a[i].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-repair.md","raw":"title: 「JSOI2007」建筑抢修 - 贪心\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 贪心\npermalink: jsoi2007-repair\ndate: 2016-11-13 09:11:00\n---\n\n部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029)\n\n### 题解\n将所有建筑按照最晚修理时间排序，维护当前时间点，枚举每个建筑，如果当前安时间足够修理这个建筑，则修理这个建筑，并将当前时间加上修理所用时间。如果当前时间不足以修改这个建筑，则尝试替换之前修理的**所用时间最多**的一个建筑。因为当前建筑的最晚修理时间更大，且用时更短，所以这样替换一定合法，并且这样替换可以使答案不变的情况下当前时间点尽量小。\n\n使用优先队列维护最大值。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 150000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic std::pair<int, int> a[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].second, &a[i].first);\n\n\tstd::sort(a, a + n);\n\n\tstd::priority_queue<int> q;\n\tlong long t = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t + a[i].second <= a[i].first) {\n\t\t\tt += a[i].second;\n\t\t\tq.push(a[i].second);\n\t\t\tans++;\n\t\t} else if (!q.empty() && q.top() > a[i].second) {\n\t\t\tt -= q.top();\n\t\t\tt += a[i].second;\n\t\t\tq.pop();\n\t\t\tq.push(a[i].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"jsoi2007-repair","published":1,"updated":"2016-11-13T01:25:57.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rum00x2ooxlk70b6ezl"},{"title":"「JSOI2007」麻将 - 枚举 + 贪心","date":"2016-11-13T00:27:00.000Z","_content":"\n在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数\n不被限制在一到九的范围内，而是在 $ 1 $ 到 $ n $ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $ 3m + 2 $ 张牌组成，其中两张组成对子，其余 $ 3m $ 张组成三张一组的 $ m $ 组，每组须为顺子或刻子。现给出一组 $ 3m + 1 $ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028)\n\n### 题解\n枚举答案，将这种牌数量 $ +1 $，枚举对子，判断剩余的牌能否出完，即优先出三张相同的牌，不足三张的判断能否与之后的牌组成顺子。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 1000;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN];\n\tfor (int i = 0; i < m * 3 + 1; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1]++;\n\t}\n\n\tstatic int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic int b[MAXN];\n\t\tstd::copy(a, a + n, b);\n\t\tb[i]++;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (b[j] >= 2) {\n\t\t\t\tstatic int c[MAXN + 2];\n\t\t\t\tstd::copy(b, b + n, c);\n\t\t\t\tc[j] -= 2;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (c[k] == 0) continue;\n\t\t\t\t\tc[k] %= 3;\n\t\t\t\t\tint x = std::min(std::min(c[k], c[k + 1]), c[k + 2]);\n\t\t\t\t\tif (x < c[k]) goto fail;\n\t\t\t\t\tc[k] -= x, c[k + 1] -= x, c[k + 2] -= x;\n\t\t\t\t}\n\n\t\t\t\tgoto success;\n\nfail:;\n\t\t\t}\n\t\t}\n\n\t\tcontinue;\n\nsuccess:\n\t\tans[cnt++] = i + 1;\n\t}\n\n\tif (cnt) {\n\t\tfor (int i = 0; i < cnt; i++) printf(\"%d%c\", ans[i], i == cnt - 1 ? '\\n' : ' ');\n\t} else puts(\"NO\");\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-mahjong.md","raw":"title: 「JSOI2007」麻将 - 枚举 + 贪心\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 枚举\n  - 贪心\npermalink: jsoi2007-mahjong\ndate: 2016-11-13 08:27:00\n---\n\n在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数\n不被限制在一到九的范围内，而是在 $ 1 $ 到 $ n $ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $ 3m + 2 $ 张牌组成，其中两张组成对子，其余 $ 3m $ 张组成三张一组的 $ m $ 组，每组须为顺子或刻子。现给出一组 $ 3m + 1 $ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028)\n\n### 题解\n枚举答案，将这种牌数量 $ +1 $，枚举对子，判断剩余的牌能否出完，即优先出三张相同的牌，不足三张的判断能否与之后的牌组成顺子。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 1000;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN];\n\tfor (int i = 0; i < m * 3 + 1; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1]++;\n\t}\n\n\tstatic int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic int b[MAXN];\n\t\tstd::copy(a, a + n, b);\n\t\tb[i]++;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (b[j] >= 2) {\n\t\t\t\tstatic int c[MAXN + 2];\n\t\t\t\tstd::copy(b, b + n, c);\n\t\t\t\tc[j] -= 2;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (c[k] == 0) continue;\n\t\t\t\t\tc[k] %= 3;\n\t\t\t\t\tint x = std::min(std::min(c[k], c[k + 1]), c[k + 2]);\n\t\t\t\t\tif (x < c[k]) goto fail;\n\t\t\t\t\tc[k] -= x, c[k + 1] -= x, c[k + 2] -= x;\n\t\t\t\t}\n\n\t\t\t\tgoto success;\n\nfail:;\n\t\t\t}\n\t\t}\n\n\t\tcontinue;\n\nsuccess:\n\t\tans[cnt++] = i + 1;\n\t}\n\n\tif (cnt) {\n\t\tfor (int i = 0; i < cnt; i++) printf(\"%d%c\", ans[i], i == cnt - 1 ? '\\n' : ' ');\n\t} else puts(\"NO\");\n\n\treturn 0;\n}\n```","slug":"jsoi2007-mahjong","published":1,"updated":"2016-11-13T00:32:35.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rur00x7ooxlhuw5oi9f"},{"title":"「JSOI2007」文本生成器 - AC 自动机","date":"2016-09-11T23:19:00.000Z","_content":"\n「文本生成器」可以随机生成一些文章 ―― 总是生成一篇长度固定且完全随机的文章 —— 也就是说，生成的文章中每个字节都是完全随机的。\n\n如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $ a $ 包含单词 $ b $，当且仅当单词 $ b $ 是文章 $ a $ 的子串）。\n\n求生成的所有文本中可读文本的数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030)\n\n### 题解\n首先，考虑只有一个单词的情况，这个单词出现了，当且仅当之前连续若干个位置匹配了单词的前面若干个字符，并且当前字符是单词的最后一个字符。\n\n我们可以设计 DP 状态 —— 还要生成 $ i $ 个字符，在这之前生成的最后若干个字符匹配了单词中的前 $ j $ 个字符，最终生成串不包含单词串方案数。枚举第一个字符，尝试继续匹配，如果不能匹配则跳转到 KMP 的失配位置。\n\n对于多个单词的情况，只需要将 KMP 改为 AC 自动机即可，「匹配了单词中的前 $ j $ 个字符」改为「当前状态为 AC 自动机的节点 $ j $」。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 60;\nconst int MAXM = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\n\nstruct Trie {\n\tstruct Node {\n\t\tint id;\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool next(Node *v, const char ch, Node *&next) {\n\t\twhile (v != root && !v->c[ch]) v = v->fail;\n\t\tnext = v->c[ch] ? v->c[ch] : root;\n\t\tif (!v->c[ch]) return false;\n\t\telse if (v->c[ch]->isWord) return true;\n\t\telse if (v->c[ch]->next) return true;\n\t\telse return false;\n\t}\n\n\tvoid getNodeList(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tvec.push_back(v);\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) if (v->c[i]) q.push(v->c[i]);\n\t\t}\n\t}\n} t;\n\ninline int pow(int x, int n) {\n\tint ans = 1;\n\tfor (; n; n >>= 1, x = x * x % MOD) if (n & 1) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (n--) {\n\t\tchar s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\n\tstd::vector<Trie::Node *> vec;\n\tt.getNodeList(vec);\n\n\t// std::tr1::unordered_map<Trie::Node *, int> f[MAXM + 1];\n\tstatic int f[MAXM + 1][MAXM * MAXN + 1];\n\t// for (size_t i = 0; i < vec.size(); i++) for (int j = 0; j < CHARSET_SIZE; j++) if (!vec[i]->c[j] || !vec[i]->c[j]->isWord) f[1][vec[i]]++;\n\tfor (size_t i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tTrie::Node *next;\n\t\t\t\tif (!t.next(vec[j], k, next)) {\n\t\t\t\t\t(f[i][j] += f[i - 1][next->id]) %= MOD;\n\t\t\t\t\t// if (k <= 5) printf(\"(%d, %lu) => %d (%d)\\n\", i, j, k, f[i - 1][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) printf(\"f(%d, %lu) = %d\\n\", i, j, f[i][vec[j]]);\n\t\tputchar('\\n');\n\t}\n\t// */\n\n\t// printf(\"%d\\n\", f[m][t.root]);\n\tprintf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id]) % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-generator.md","raw":"title: 「JSOI2007」文本生成器 - AC 自动机\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 字符串\n  - AC 自动机\n  - DP\npermalink: jsoi2007-generator\ndate: 2016-09-12 07:19:00\n---\n\n「文本生成器」可以随机生成一些文章 ―― 总是生成一篇长度固定且完全随机的文章 —— 也就是说，生成的文章中每个字节都是完全随机的。\n\n如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章 $ a $ 包含单词 $ b $，当且仅当单词 $ b $ 是文章 $ a $ 的子串）。\n\n求生成的所有文本中可读文本的数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030)\n\n### 题解\n首先，考虑只有一个单词的情况，这个单词出现了，当且仅当之前连续若干个位置匹配了单词的前面若干个字符，并且当前字符是单词的最后一个字符。\n\n我们可以设计 DP 状态 —— 还要生成 $ i $ 个字符，在这之前生成的最后若干个字符匹配了单词中的前 $ j $ 个字符，最终生成串不包含单词串方案数。枚举第一个字符，尝试继续匹配，如果不能匹配则跳转到 KMP 的失配位置。\n\n对于多个单词的情况，只需要将 KMP 改为 AC 自动机即可，「匹配了单词中的前 $ j $ 个字符」改为「当前状态为 AC 自动机的节点 $ j $」。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 60;\nconst int MAXM = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\n\nstruct Trie {\n\tstruct Node {\n\t\tint id;\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool next(Node *v, const char ch, Node *&next) {\n\t\twhile (v != root && !v->c[ch]) v = v->fail;\n\t\tnext = v->c[ch] ? v->c[ch] : root;\n\t\tif (!v->c[ch]) return false;\n\t\telse if (v->c[ch]->isWord) return true;\n\t\telse if (v->c[ch]->next) return true;\n\t\telse return false;\n\t}\n\n\tvoid getNodeList(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tvec.push_back(v);\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) if (v->c[i]) q.push(v->c[i]);\n\t\t}\n\t}\n} t;\n\ninline int pow(int x, int n) {\n\tint ans = 1;\n\tfor (; n; n >>= 1, x = x * x % MOD) if (n & 1) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (n--) {\n\t\tchar s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\n\tstd::vector<Trie::Node *> vec;\n\tt.getNodeList(vec);\n\n\t// std::tr1::unordered_map<Trie::Node *, int> f[MAXM + 1];\n\tstatic int f[MAXM + 1][MAXM * MAXN + 1];\n\t// for (size_t i = 0; i < vec.size(); i++) for (int j = 0; j < CHARSET_SIZE; j++) if (!vec[i]->c[j] || !vec[i]->c[j]->isWord) f[1][vec[i]]++;\n\tfor (size_t i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tTrie::Node *next;\n\t\t\t\tif (!t.next(vec[j], k, next)) {\n\t\t\t\t\t(f[i][j] += f[i - 1][next->id]) %= MOD;\n\t\t\t\t\t// if (k <= 5) printf(\"(%d, %lu) => %d (%d)\\n\", i, j, k, f[i - 1][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) printf(\"f(%d, %lu) = %d\\n\", i, j, f[i][vec[j]]);\n\t\tputchar('\\n');\n\t}\n\t// */\n\n\t// printf(\"%d\\n\", f[m][t.root]);\n\tprintf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id]) % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```","slug":"jsoi2007-generator","published":1,"updated":"2016-09-11T23:28:09.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ruw00xeooxlo4d9l9wm"},{"title":"「JSOI2007」字符加密 - 后缀数组","date":"2016-09-29T13:00:00.000Z","_content":"\n把一个字符串 $ S $ 排成一圈，从每个字符开始读一圈，把每次读到的字符串排序，按顺序将每个串的最后一个字符排成一个新字符串，求新字符串。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031)\n\n### 题解\n将串翻倍，建立后缀数组，得到循环意义下每个串的排序，找到每个串的最后一个字符输出即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5 * 2;\n\nchar s[MAXN];\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\n\ninline void print(const int *a) {\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(fir);\n\t\t// print(sec);\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\t\t// print(tmp);\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(buc);\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\t\t// print(sa);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\t// print(rk);\n\n\t\t// return;\n\t}\n\t// puts(\"----------------\");\n\t// print(sa);\n\t// print(rk);\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", s + sa[i]);\n\t\n\t/*\n\tfor (int i = 0, j, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tj = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\t// k = 0;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\t*/\n\t// print(ht);\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++) s[i + n] = s[i];\n\tn *= 2;\n\tsuffixArray();\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i] + 1, i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 1; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sa[i] < n / 2) {\n\t\t\tputchar(s[sa[i] + n / 2 - 1]);\n\t\t}\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-cipher.md","raw":"title: 「JSOI2007」字符加密 - 后缀数组\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 字符串\n  - 后缀数组\npermalink: jsoi2007-cipher\ndate: 2016-09-29 21:00:00\n---\n\n把一个字符串 $ S $ 排成一圈，从每个字符开始读一圈，把每次读到的字符串排序，按顺序将每个串的最后一个字符排成一个新字符串，求新字符串。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031)\n\n### 题解\n将串翻倍，建立后缀数组，得到循环意义下每个串的排序，找到每个串的最后一个字符输出即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5 * 2;\n\nchar s[MAXN];\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\n\ninline void print(const int *a) {\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(fir);\n\t\t// print(sec);\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\t\t// print(tmp);\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(buc);\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\t\t// print(sa);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\t// print(rk);\n\n\t\t// return;\n\t}\n\t// puts(\"----------------\");\n\t// print(sa);\n\t// print(rk);\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", s + sa[i]);\n\t\n\t/*\n\tfor (int i = 0, j, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tj = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\t// k = 0;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\t*/\n\t// print(ht);\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++) s[i + n] = s[i];\n\tn *= 2;\n\tsuffixArray();\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i] + 1, i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 1; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sa[i] < n / 2) {\n\t\t\tputchar(s[sa[i] + n / 2 - 1]);\n\t\t}\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","slug":"jsoi2007-cipher","published":1,"updated":"2016-09-29T13:06:01.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rv100xlooxlpu5l47dr"},{"title":"「IOI2011」Race - 点分治","date":"2016-06-16T12:01:00.000Z","_content":"\n给一棵树，每条边有权。求一条**简单**路径，权值和等于 $ K $，且边的数量最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2599](http://www.lydsy.com/JudgeOnline/problem.php?id=2599)\n\n### 题解\n点分治，考虑经过根的路径中权值和等于 $ K $ 的路径。\n\n遍历整棵树，记录到达每一个点时的经过的边数 $ {\\rm depth}(v) $ 和边权和 $ {\\rm dist}(v) $。\n\n设 $ f(i) $ 表示当前根的**之前几棵子树**中从根到某个节点边权和为 $ i $ 的路径经过的最少边数。\n\n枚举当前子树的所有节点，用 $ {\\rm depth}(i) + f(K - {\\rm dist}(i)) $ 更新答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n// #include \"rand.h\"\n#include <queue>\n#include <stack>\n\nconst int MAXN = 200000;\nconst int MAXK = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist, depth, size, max;\n\tbool visited, solved;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\nint f[MAXK + 1];\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->visited = false;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// return a[rand(0, cnt - 1)];\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"%d %d\\n\", cnt, start->size);\n\t\tassert(cnt == start->size);\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\treturn res;\n}\n\ninline int calc(Node *root) {\n\tstatic int A[MAXN];\n\tint tot = 0, res = INT_MAX;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(e->t);\n\t\te->t->parent = root;\n\t\te->t->dist = e->w;\n\t\te->t->depth = 1;\n\n\t\tstatic Node *a[MAXN];\n\t\tint cnt = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tif (v->dist > k) continue;\n\n\t\t\tA[tot++] = v->dist;\n\t\t\ta[cnt++] = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t// assert(k - a[i]->dist >= 0 && k - a[i]->dist <= k);\n\t\t\tif (f[k - a[i]->dist] != INT_MAX) res = std::min(res, f[k - a[i]->dist] + a[i]->depth);\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tf[a[i]->dist] = std::min(f[a[i]->dist], a[i]->depth);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) {\n\t\t// assert(A[i] >= 0 && A[i] <= k);\n\t\tf[A[i]] = INT_MAX;\n\t}\n\n\t// printf(\"calc(%ld) = %d\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = INT_MAX;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans = std::min(ans, calc(root));\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\t// assert(n <= MAXN);\n\t// assert(k <= MAXK);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w);\n\t}\n\n\tfor (int i = 1; i <= k; i++) f[i] = INT_MAX;\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/ioi2011-race.md","raw":"title: 「IOI2011」Race - 点分治\ncategories: OI\ntags: \n  - IOI\n  - BZOJ\n  - 点分治\n  - 数据结构\npermalink: ioi2011-race\ndate: 2016-06-16 20:01:00\n---\n\n给一棵树，每条边有权。求一条**简单**路径，权值和等于 $ K $，且边的数量最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2599](http://www.lydsy.com/JudgeOnline/problem.php?id=2599)\n\n### 题解\n点分治，考虑经过根的路径中权值和等于 $ K $ 的路径。\n\n遍历整棵树，记录到达每一个点时的经过的边数 $ {\\rm depth}(v) $ 和边权和 $ {\\rm dist}(v) $。\n\n设 $ f(i) $ 表示当前根的**之前几棵子树**中从根到某个节点边权和为 $ i $ 的路径经过的最少边数。\n\n枚举当前子树的所有节点，用 $ {\\rm depth}(i) + f(K - {\\rm dist}(i)) $ 更新答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n// #include \"rand.h\"\n#include <queue>\n#include <stack>\n\nconst int MAXN = 200000;\nconst int MAXK = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist, depth, size, max;\n\tbool visited, solved;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\nint f[MAXK + 1];\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->visited = false;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// return a[rand(0, cnt - 1)];\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"%d %d\\n\", cnt, start->size);\n\t\tassert(cnt == start->size);\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\treturn res;\n}\n\ninline int calc(Node *root) {\n\tstatic int A[MAXN];\n\tint tot = 0, res = INT_MAX;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(e->t);\n\t\te->t->parent = root;\n\t\te->t->dist = e->w;\n\t\te->t->depth = 1;\n\n\t\tstatic Node *a[MAXN];\n\t\tint cnt = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tif (v->dist > k) continue;\n\n\t\t\tA[tot++] = v->dist;\n\t\t\ta[cnt++] = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t// assert(k - a[i]->dist >= 0 && k - a[i]->dist <= k);\n\t\t\tif (f[k - a[i]->dist] != INT_MAX) res = std::min(res, f[k - a[i]->dist] + a[i]->depth);\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tf[a[i]->dist] = std::min(f[a[i]->dist], a[i]->depth);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) {\n\t\t// assert(A[i] >= 0 && A[i] <= k);\n\t\tf[A[i]] = INT_MAX;\n\t}\n\n\t// printf(\"calc(%ld) = %d\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = INT_MAX;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans = std::min(ans, calc(root));\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\t// assert(n <= MAXN);\n\t// assert(k <= MAXK);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w);\n\t}\n\n\tfor (int i = 1; i <= k; i++) f[i] = INT_MAX;\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","slug":"ioi2011-race","published":1,"updated":"2016-06-16T12:01:55.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rv700xrooxl1oxktl3f"},{"title":"「IOI2008」岛屿 - 基环树 DP","date":"2016-10-24T13:39:00.000Z","_content":"\n给一个由多个基环树构成的图，求所有基环树最长链之和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1791](http://www.lydsy.com/JudgeOnline/problem.php?id=1791)\n\n### 题解\n首先，考虑没有环的情况，也就是说，求一棵树的最长链。\n\n设 $ f(i) $ 表示从节点 $ i $ 向子树延伸的最长路径，显然，对于 $ i $ 的每个子节点 $ j $，$ f(i) = \\max\\{ f(j) + d(i, j) \\} $。\n\n对于每个节点，用两个不同的子树 $ u $、$ v $ 的路径和 $ f(u) + d(i, u) + f(v) + d(i, v) $ 来更新答案。\n\n如果没有环，则每个连通块就是一棵树，答案是从某一个点向下延伸的两条最长路径之和。有了环之后，拓扑排序找出环，以环为根做树形 DP，答案可能是环上两个点向下延伸的最长路径之和，加上这两个点在环上的距离。\n\n任选一个节点开始，把环断成链，设 $ f'(i) $ 表示环上的第 $ i $ 个点的 $ f $ 值。$ s(i) $ 表示环上第 $ i $ 个点与第一个点的距离。答案可以表示为\n\n走完 $ i $ 向下延伸的最长链，从 $ i $ 沿着链的方向走到 $ j $，再走 $ i $ 向下延伸的最长链：\n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + s(i) - s(j) \\pod {i > j} \\\\\n= & f'(j) - s(j) + f'(i) + s(i)\n\\end{aligned}\n$$\n\n沿着环的另一个方向（顺时针、逆时针）从 $ i $ 走到 $ j $（$ S $ 表示整个环的长度）：\n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + S - (s(i) - s(j)) \\pod {i > j} \\\\\n= & f'(i) + f'(j) + S - s(i) + s(j) \\\\\n= & f'(j) + s(j) + S + f'(i) - s(i)\n\\end{aligned}\n$$\n\n按照链的顺序扫描环上的节点，维护 $ f'(j) + s(j) + S $ 的最大值，更新答案即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tbool inCircle, solved, visited, pushed;\n\tint depth, inDegree;\n\tlong long len;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long w;\n\tEdge *next, *r;\n\tbool disabled;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nint n;\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline std::vector<Node *> getBlock(Node *start) {\n\tstd::queue<Node *> q;\n\tq.push(start);\n\tstart->inDegree = 0;\n\tstart->visited = true;\n\n\tstd::vector<Node *> block;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tblock.push_back(v);\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e == v->in || e->t->solved) continue;\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->inDegree = 1;\n\t\t\t\te->t->in = e;\n\t\t\t\tq.push(e->t);\n\t\t\t} else e->t->inDegree++;\n\t\t}\n\t}\n\n\treturn block;\n}\n\ninline void toposort(std::vector<Node *> &v) {\n\tstd::queue<Node *> q;\n\tfor (size_t i = 0; i < v.size(); i++) {\n#ifdef DBG\n\t\tprintf(\"toposort(): inDegree[%lu] = %d\\n\", v[i] - N + 1, v[i]->inDegree);\n#endif\n\t\tif (v[i]->inDegree == 1) q.push(v[i]);\n\t\telse v[i]->inCircle = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tv->inCircle = false;\n#ifdef CHECK\n\t\tprintf(\"%lu\\n\", v - N);\n#endif\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->solved) continue;\n\t\t\tif (--e->t->inDegree == 1) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calcTree(std::vector<Node *> &v) {\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i]->visited = false;\n\t\tv[i]->inDegree = 0;\n\t\tv[i]->depth = 0;\n\t}\n\n\tstd::stack<Node *> s;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->depth = 1;\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t}\n\t\t\n\t\twhile (v->c && (v->c->t->inCircle || v->c->t->pushed || v->c->t->solved)) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\te->t->pushed = true;\n\t\t\te->t->parent = v;\n\t\t\ts.push(e->t);\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tv->len = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->inCircle || e->t->parent != v) continue;\n\n\t\t\t\tans = std::max(ans, v->len + e->t->len + e->w);\n\t\t\t\tv->len = std::max(v->len, e->t->len + e->w);\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\"calcTree(size = %lu) = %lld\\n\", v.size(), ans);\n#endif\n\treturn ans;\n}\n\ninline long long calcCircle(std::vector<Node *> &v) {\n\tNode *start;\n\tfor (size_t i = 0; i < v.size(); i++) v[i]->visited = false;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->visited = true;\n\t\t\tstart = v[i];\n\t\t\tbreak;\n\t\t}\n\t\tfor (Edge *e = v[i]->e; e; e = e->next) e->disabled = false;\n\t}\n\n\tstatic Node *c[MAXN];\n\tstatic long long s[MAXN];\n\tint cnt = 0;\n\tlong long sum = 0;\n\n#ifdef DBG\n\tfor (int i = 0; i < MAXN; i++) c[i] = NULL, s[i] = 0;\n#endif\n\n\tNode *u = start;\n\tc[cnt++] = u;\n\twhile (1) {\n\t\tNode *next = NULL;\n\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\tif (!e->t->visited && e->t->inCircle) {\n\t\t\t\tc[cnt] = e->t;\n\t\t\t\ts[cnt] = e->w;\n\t\t\t\tsum += e->w;\n\t\t\t\tcnt++;\n\t\t\t\te->t->visited = true;\n\t\t\t\te->r->disabled = true;\n\t\t\t\tnext = e->t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tu = next;\n\t\t} else {\n\t\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\t\tif (e->t == start) {\n\t\t\t\t\tsum += e->w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n == 0) return 0;\n\t/*\n\tif (cnt == 2) {\n\t\tlong long ans = c[0]->len + c[1]->len + std::max(s[1], sum - s[1]);\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", s[1], sum);\n\t\tprintf(\"calcCircle(size = 2) = %lld\\n\", ans);\n#endif\n\t\treturn ans;\n\t}\n\t*/\n\n\tfor (int i = 1; i < cnt; i++) s[i] += s[i - 1];\n\n\t// ans1 = f[a] + f[b] + s[a] - s[b]\n\t// ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b]\n\t// maintain the max of f[b] - s[b] and f[b] + s[b]\n\tlong long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans = std::max(ans, c[i]->len + s[i] + max1);\n\t\tans = std::max(ans, sum + c[i]->len - s[i] + max2);\n\n\t\tmax1 = std::max(max1, c[i]->len - s[i]);\n\t\tmax2 = std::max(max2, c[i]->len + s[i]);\n\n#ifdef DBG\n\t\tprintf(\"ans = %lld, max1 = %lld, max2 = %lld\\n\", ans, max1, max2);\n#endif\n\t}\n\n#ifdef DBG\n\tprintf(\"calcCircle(size = %lu, cnt = %d) = %lld\\n\", v.size(), cnt, ans);\n#endif\n\treturn ans;\n}\n\ninline long long solve() {\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].solved) continue;\n\n\t\tstd::vector<Node *> block = getBlock(&N[i]);\n\t\ttoposort(block);\n\n\t\tlong long tmp = calcTree(block);\n\t\ttmp = std::max(tmp, calcCircle(block));\n\t\tans += tmp;\n\n\t\tfor (size_t i = 0; i < block.size(); i++) block[i]->solved = true;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u, w;\n\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\taddEdge(i, u, w);\n\t}\n\n\tprintf(\"%lld\\n\", solve());\n\n#ifdef CHECK\n\tfor (int i = 0; i < n; i++) printf(\"f[%d] = %lld\\n\", i, N[i].len);\n#endif\n\n\treturn 0;\n}\n```\n","source":"_posts/ioi2008-island.md","raw":"title: 「IOI2008」岛屿 - 基环树 DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\n  - 基环树\n  - Tarjan\npermalink: ioi2008-island\ndate: 2016-10-24 21:39:00\n---\n\n给一个由多个基环树构成的图，求所有基环树最长链之和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1791](http://www.lydsy.com/JudgeOnline/problem.php?id=1791)\n\n### 题解\n首先，考虑没有环的情况，也就是说，求一棵树的最长链。\n\n设 $ f(i) $ 表示从节点 $ i $ 向子树延伸的最长路径，显然，对于 $ i $ 的每个子节点 $ j $，$ f(i) = \\max\\{ f(j) + d(i, j) \\} $。\n\n对于每个节点，用两个不同的子树 $ u $、$ v $ 的路径和 $ f(u) + d(i, u) + f(v) + d(i, v) $ 来更新答案。\n\n如果没有环，则每个连通块就是一棵树，答案是从某一个点向下延伸的两条最长路径之和。有了环之后，拓扑排序找出环，以环为根做树形 DP，答案可能是环上两个点向下延伸的最长路径之和，加上这两个点在环上的距离。\n\n任选一个节点开始，把环断成链，设 $ f'(i) $ 表示环上的第 $ i $ 个点的 $ f $ 值。$ s(i) $ 表示环上第 $ i $ 个点与第一个点的距离。答案可以表示为\n\n走完 $ i $ 向下延伸的最长链，从 $ i $ 沿着链的方向走到 $ j $，再走 $ i $ 向下延伸的最长链：\n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + s(i) - s(j) \\pod {i > j} \\\\\n= & f'(j) - s(j) + f'(i) + s(i)\n\\end{aligned}\n$$\n\n沿着环的另一个方向（顺时针、逆时针）从 $ i $ 走到 $ j $（$ S $ 表示整个环的长度）：\n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + S - (s(i) - s(j)) \\pod {i > j} \\\\\n= & f'(i) + f'(j) + S - s(i) + s(j) \\\\\n= & f'(j) + s(j) + S + f'(i) - s(i)\n\\end{aligned}\n$$\n\n按照链的顺序扫描环上的节点，维护 $ f'(j) + s(j) + S $ 的最大值，更新答案即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tbool inCircle, solved, visited, pushed;\n\tint depth, inDegree;\n\tlong long len;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long w;\n\tEdge *next, *r;\n\tbool disabled;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nint n;\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline std::vector<Node *> getBlock(Node *start) {\n\tstd::queue<Node *> q;\n\tq.push(start);\n\tstart->inDegree = 0;\n\tstart->visited = true;\n\n\tstd::vector<Node *> block;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tblock.push_back(v);\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e == v->in || e->t->solved) continue;\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->inDegree = 1;\n\t\t\t\te->t->in = e;\n\t\t\t\tq.push(e->t);\n\t\t\t} else e->t->inDegree++;\n\t\t}\n\t}\n\n\treturn block;\n}\n\ninline void toposort(std::vector<Node *> &v) {\n\tstd::queue<Node *> q;\n\tfor (size_t i = 0; i < v.size(); i++) {\n#ifdef DBG\n\t\tprintf(\"toposort(): inDegree[%lu] = %d\\n\", v[i] - N + 1, v[i]->inDegree);\n#endif\n\t\tif (v[i]->inDegree == 1) q.push(v[i]);\n\t\telse v[i]->inCircle = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tv->inCircle = false;\n#ifdef CHECK\n\t\tprintf(\"%lu\\n\", v - N);\n#endif\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->solved) continue;\n\t\t\tif (--e->t->inDegree == 1) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calcTree(std::vector<Node *> &v) {\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i]->visited = false;\n\t\tv[i]->inDegree = 0;\n\t\tv[i]->depth = 0;\n\t}\n\n\tstd::stack<Node *> s;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->depth = 1;\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t}\n\t\t\n\t\twhile (v->c && (v->c->t->inCircle || v->c->t->pushed || v->c->t->solved)) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\te->t->pushed = true;\n\t\t\te->t->parent = v;\n\t\t\ts.push(e->t);\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tv->len = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->inCircle || e->t->parent != v) continue;\n\n\t\t\t\tans = std::max(ans, v->len + e->t->len + e->w);\n\t\t\t\tv->len = std::max(v->len, e->t->len + e->w);\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\"calcTree(size = %lu) = %lld\\n\", v.size(), ans);\n#endif\n\treturn ans;\n}\n\ninline long long calcCircle(std::vector<Node *> &v) {\n\tNode *start;\n\tfor (size_t i = 0; i < v.size(); i++) v[i]->visited = false;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->visited = true;\n\t\t\tstart = v[i];\n\t\t\tbreak;\n\t\t}\n\t\tfor (Edge *e = v[i]->e; e; e = e->next) e->disabled = false;\n\t}\n\n\tstatic Node *c[MAXN];\n\tstatic long long s[MAXN];\n\tint cnt = 0;\n\tlong long sum = 0;\n\n#ifdef DBG\n\tfor (int i = 0; i < MAXN; i++) c[i] = NULL, s[i] = 0;\n#endif\n\n\tNode *u = start;\n\tc[cnt++] = u;\n\twhile (1) {\n\t\tNode *next = NULL;\n\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\tif (!e->t->visited && e->t->inCircle) {\n\t\t\t\tc[cnt] = e->t;\n\t\t\t\ts[cnt] = e->w;\n\t\t\t\tsum += e->w;\n\t\t\t\tcnt++;\n\t\t\t\te->t->visited = true;\n\t\t\t\te->r->disabled = true;\n\t\t\t\tnext = e->t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tu = next;\n\t\t} else {\n\t\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\t\tif (e->t == start) {\n\t\t\t\t\tsum += e->w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n == 0) return 0;\n\t/*\n\tif (cnt == 2) {\n\t\tlong long ans = c[0]->len + c[1]->len + std::max(s[1], sum - s[1]);\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", s[1], sum);\n\t\tprintf(\"calcCircle(size = 2) = %lld\\n\", ans);\n#endif\n\t\treturn ans;\n\t}\n\t*/\n\n\tfor (int i = 1; i < cnt; i++) s[i] += s[i - 1];\n\n\t// ans1 = f[a] + f[b] + s[a] - s[b]\n\t// ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b]\n\t// maintain the max of f[b] - s[b] and f[b] + s[b]\n\tlong long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans = std::max(ans, c[i]->len + s[i] + max1);\n\t\tans = std::max(ans, sum + c[i]->len - s[i] + max2);\n\n\t\tmax1 = std::max(max1, c[i]->len - s[i]);\n\t\tmax2 = std::max(max2, c[i]->len + s[i]);\n\n#ifdef DBG\n\t\tprintf(\"ans = %lld, max1 = %lld, max2 = %lld\\n\", ans, max1, max2);\n#endif\n\t}\n\n#ifdef DBG\n\tprintf(\"calcCircle(size = %lu, cnt = %d) = %lld\\n\", v.size(), cnt, ans);\n#endif\n\treturn ans;\n}\n\ninline long long solve() {\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].solved) continue;\n\n\t\tstd::vector<Node *> block = getBlock(&N[i]);\n\t\ttoposort(block);\n\n\t\tlong long tmp = calcTree(block);\n\t\ttmp = std::max(tmp, calcCircle(block));\n\t\tans += tmp;\n\n\t\tfor (size_t i = 0; i < block.size(); i++) block[i]->solved = true;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u, w;\n\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\taddEdge(i, u, w);\n\t}\n\n\tprintf(\"%lld\\n\", solve());\n\n#ifdef CHECK\n\tfor (int i = 0; i < n; i++) printf(\"f[%d] = %lld\\n\", i, N[i].len);\n#endif\n\n\treturn 0;\n}\n```\n","slug":"ioi2008-island","published":1,"updated":"2016-10-25T13:32:29.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvd00xyooxltd7l4l7c"},{"title":"「HNOI2016」树 - 最近公共祖先 + 主席树","date":"2016-05-11T09:28:00.000Z","_content":"\n小 A 想做一棵很大的树，但是他手上的材料有限，只好用点小技巧了。开始，小 A 只有一棵结点数为 $ N $ 的树，结点的编号为 $ 1,\\ 2,\\ \\dots,\\ N $，其中结点 $ 1 $ 为根；我们称这颗树为模板树。小 A 决定通过这棵模板树来构建一颗大树。构建过程如下：\n\n1. 将模板树复制为初始的大树；\n2. 以下 3，4，5 步循环执行 $ M $ 次；\n3. 选择两个数字 $ a,\\ b $，其中 $ 1 \\leq a \\leq N $，$ 1 \\leq b \\leq $ 当前大树的结点数；\n4. 将模板树中以结点 $ a $ 为根的子树复制一遍，挂到大树中结点 $ b $ 的下方（也就是说，模板树中的结点 $ a $ 为根的子树复制到大树中后，将成为大树中结点 $ b $ 的子树)；\n5. 将新加入大树的结点按照在模板树中编号的顺序重新编号。例如，假设在进行 4 步之前大树有 $ L $ 个结点，模板树中以 $ a $ 为根的子树共有 $ C $ 个结点，那么新加入模板树的 $ C $ 个结点在大树中的编号将是 $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $；大树中这 $ C $ 个结点编号的大小顺序和模板树中对应的 $ C $ 个结点的大小顺序是一致的。\n\n现在他想问你，树中一些结点对的距离是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### 题解\n在新树中用一个节点代表模板树中的一棵子树，存储每个节点在模板树中的根，其真实父节点在模板树中的节点，边设置为新节点到其新树中父节点的根节点的距离。对新树和模板树分别进行树链剖分。\n\n需要从编号求出在新树中的节点时，记录新树中每个节点代表的区间，进行二分查找。需要求出模板树中的节点时，先求出在区间内的编号，再做区间第 $ k $ 大查询，使用主席树即可。\n\n求距离时，分三种情况讨论：\n\n1. 两个点在新树中的统一节点内，直接在模板树中找最近公共租先；\n2. 两个点在新树中的节点的的最近公共租先为其中一个节点，分别求出多段距离相加减；\n3. 其他情况，比情况 2 复杂一些，方法类似。\n\n总时间复杂度为 $ O((m + q) \\log n) $，具体实现细节见代码。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-tree.md","raw":"title: 「HNOI2016」树 - 最近公共祖先 + 主席树\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - 树链剖分\n  - 主席树\n  - 最近公共祖先\npermalink: hnoi2016-tree\ndate: 2016-05-11 17:28:00\n---\n\n小 A 想做一棵很大的树，但是他手上的材料有限，只好用点小技巧了。开始，小 A 只有一棵结点数为 $ N $ 的树，结点的编号为 $ 1,\\ 2,\\ \\dots,\\ N $，其中结点 $ 1 $ 为根；我们称这颗树为模板树。小 A 决定通过这棵模板树来构建一颗大树。构建过程如下：\n\n1. 将模板树复制为初始的大树；\n2. 以下 3，4，5 步循环执行 $ M $ 次；\n3. 选择两个数字 $ a,\\ b $，其中 $ 1 \\leq a \\leq N $，$ 1 \\leq b \\leq $ 当前大树的结点数；\n4. 将模板树中以结点 $ a $ 为根的子树复制一遍，挂到大树中结点 $ b $ 的下方（也就是说，模板树中的结点 $ a $ 为根的子树复制到大树中后，将成为大树中结点 $ b $ 的子树)；\n5. 将新加入大树的结点按照在模板树中编号的顺序重新编号。例如，假设在进行 4 步之前大树有 $ L $ 个结点，模板树中以 $ a $ 为根的子树共有 $ C $ 个结点，那么新加入模板树的 $ C $ 个结点在大树中的编号将是 $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $；大树中这 $ C $ 个结点编号的大小顺序和模板树中对应的 $ C $ 个结点的大小顺序是一致的。\n\n现在他想问你，树中一些结点对的距离是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### 题解\n在新树中用一个节点代表模板树中的一棵子树，存储每个节点在模板树中的根，其真实父节点在模板树中的节点，边设置为新节点到其新树中父节点的根节点的距离。对新树和模板树分别进行树链剖分。\n\n需要从编号求出在新树中的节点时，记录新树中每个节点代表的区间，进行二分查找。需要求出模板树中的节点时，先求出在区间内的编号，再做区间第 $ k $ 大查询，使用主席树即可。\n\n求距离时，分三种情况讨论：\n\n1. 两个点在新树中的统一节点内，直接在模板树中找最近公共租先；\n2. 两个点在新树中的节点的的最近公共租先为其中一个节点，分别求出多段距离相加减；\n3. 其他情况，比情况 2 复杂一些，方法类似。\n\n总时间复杂度为 $ O((m + q) \\log n) $，具体实现细节见代码。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-tree","published":1,"updated":"2016-09-10T05:51:35.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvi00y6ooxlkshkth0r"},{"title":"「HNOI2016」序列 - 莫队 + RMQ","date":"2016-04-30T13:23:18.000Z","_content":"\n给定长度为 $ n $ 的序列：$ a_1,\\ a_2,\\ \\dots,\\ a_n $，记为 $ a[1:n] $。类似的，$ a[l:r] $（$ 1 \\leq l \\leq r \\leq n $）是指序列：$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $。若 $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $，则称 $ a[s:t] $ 是 $ a[l:r] $ 的子序列。\n\n现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \\leq l \\leq r \\leq n $，求 $ a[l:r] $ 的不同子序列的最小值之和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### 题解\n[Sengxian 的题解](https://blog.sengxian.com/solutions/bzoj-4540)\n\n对于无修改的区间询问，我们可以将操作离线，采用莫队算法解决。\n\n为便于叙述，定义 $ [i] $ 为位置 $ i $ 处的元素（即 $ a_i $）；$ [ \\ [l,\\ r],\\ R \\ ] $ 为左端点属于 $ [l,\\ r] $，右端点为 $ R $ 的所有子序列。\n\n已知区间 $ [l,\\ r - 1] $ 的答案，考虑新加入的元素 $ [r] $ 对询问的影响。新元素加入后，产生了 $ r - l + 1 $ 个子序列，它们是 $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $。\n\n$ [l, r] $ 中存在一个最小值 $ [m] $，使得 $ [ \\ [l,\\ m],\\ r \\ ] $ 的最小值均为 $ [m] $，举个例子\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n区间 $ [ \\ [1,\\ 4],\\ 6 \\ ] $ 的最小值均为 $ [4] $，即 $ 1 $。\n\n考虑剩下的 $ r - m $ 个子序列，从 $ r $ 向左走，经过的所有比 $ [r] $ **大**的元素，以这些元素的位置为左端点，$ r $ 为右端点的所有子序列的最小值均为 $ [r] $。直到到达第一个比 $ [r] $ 小的元素（例子中的 $ [8] = 3 $），其位置记做 $ {\\rm left}(r) = p $。\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $ 右边有 $ r - p = 10 - 8 = 2 $ 个子序列，他们的最小值均为 $ [10] = 4 $，这些子序列对答案的贡献为 $ (r - p) \\times [r] $。\n\n仿照刚才的做法，继续向左找第一个小于 $ [p] = 3 $ 的元素，其值为 $ [6] = 2 $，即 $ {\\rm left}(p) = p' = 6 $。\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $ 右边有 $ p - p' = 8 - 6 = 2 $ 个子序列，他们的最小值均为 $ [8] = 3 $，这些子序列对答案的贡献为 $ (p - p') \\times [p] $。\n\n继续向左找，找到第一个比 $ p' $ 小的元素，其值为 $ 1 $，即 $ {\\rm left}(p') = m = 4 $，注意此时已经找到整个区间内的最小值，左端点在 $ m $ 及其左侧的所有子序列对答案的贡献已经被考虑过，恰好只剩下 $ p' - m = 6 - 4 = 2 $ 个子序列，其最小值均为 $ [p'] = 2 $，这些子序列对答案的贡献为 $ (p' - m) \\times [p'] $。\n\n若直接使用上述算法计算每个元素的贡献，单次计算的时间复杂度为 $ O(n) $，超时。\n\n定义 $ m = \\min[l,\\ r] $ 为区间 $ [l,\\ r] $ 的最小值所在的位置，设 $ f(l, r) $ 为区间 $ [l,\\ r] $ 内除最小值之外的其它值对答案的贡献，则有\n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n注意到整个式子除边界条件中的 $ m $ 之外，和 $ l $ 是无关的。\n\n设 $ s(i) $ 为从 $ i $ 位置一直向左跳，直到跳到所有元素中的最小值，用上述方法计算出的贡献总和，则有\n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n注意到刚才的例子中，$ {\\rm left}(p') = {\\rm left}(m + 1) = m $，即**最后一跳的位置**和**最小值的右边一个位置**向左跳跳到的位置相同。所以\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n使用单调栈算法（保持栈底到栈顶的元素单调递增）预处理出每个 $ {\\rm left}(i) $，之后可以在 $ O(n) $ 的时间内递推出 $ s(i) $。区间向左扩展时同理，向右边跳即可。\n\n而对于 RMQ，使用稀疏表在 $ O(n \\log n) $ 的时间内预处理后，即可在 $ O(1) $ 的时间内回答每次查询。最终，每次转移的时间降为 $ O(1) $，总时间复杂度为 $ O(q \\log q + n \\sqrt n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-sequence.md","raw":"title: 「HNOI2016」序列 - 莫队 + RMQ\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - 莫队\n  - RMQ\npermalink: hnoi2016-sequence\ndate: 2016-04-30 21:23:18\n---\n\n给定长度为 $ n $ 的序列：$ a_1,\\ a_2,\\ \\dots,\\ a_n $，记为 $ a[1:n] $。类似的，$ a[l:r] $（$ 1 \\leq l \\leq r \\leq n $）是指序列：$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $。若 $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $，则称 $ a[s:t] $ 是 $ a[l:r] $ 的子序列。\n\n现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \\leq l \\leq r \\leq n $，求 $ a[l:r] $ 的不同子序列的最小值之和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### 题解\n[Sengxian 的题解](https://blog.sengxian.com/solutions/bzoj-4540)\n\n对于无修改的区间询问，我们可以将操作离线，采用莫队算法解决。\n\n为便于叙述，定义 $ [i] $ 为位置 $ i $ 处的元素（即 $ a_i $）；$ [ \\ [l,\\ r],\\ R \\ ] $ 为左端点属于 $ [l,\\ r] $，右端点为 $ R $ 的所有子序列。\n\n已知区间 $ [l,\\ r - 1] $ 的答案，考虑新加入的元素 $ [r] $ 对询问的影响。新元素加入后，产生了 $ r - l + 1 $ 个子序列，它们是 $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $。\n\n$ [l, r] $ 中存在一个最小值 $ [m] $，使得 $ [ \\ [l,\\ m],\\ r \\ ] $ 的最小值均为 $ [m] $，举个例子\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n区间 $ [ \\ [1,\\ 4],\\ 6 \\ ] $ 的最小值均为 $ [4] $，即 $ 1 $。\n\n考虑剩下的 $ r - m $ 个子序列，从 $ r $ 向左走，经过的所有比 $ [r] $ **大**的元素，以这些元素的位置为左端点，$ r $ 为右端点的所有子序列的最小值均为 $ [r] $。直到到达第一个比 $ [r] $ 小的元素（例子中的 $ [8] = 3 $），其位置记做 $ {\\rm left}(r) = p $。\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $ 右边有 $ r - p = 10 - 8 = 2 $ 个子序列，他们的最小值均为 $ [10] = 4 $，这些子序列对答案的贡献为 $ (r - p) \\times [r] $。\n\n仿照刚才的做法，继续向左找第一个小于 $ [p] = 3 $ 的元素，其值为 $ [6] = 2 $，即 $ {\\rm left}(p) = p' = 6 $。\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $ 右边有 $ p - p' = 8 - 6 = 2 $ 个子序列，他们的最小值均为 $ [8] = 3 $，这些子序列对答案的贡献为 $ (p - p') \\times [p] $。\n\n继续向左找，找到第一个比 $ p' $ 小的元素，其值为 $ 1 $，即 $ {\\rm left}(p') = m = 4 $，注意此时已经找到整个区间内的最小值，左端点在 $ m $ 及其左侧的所有子序列对答案的贡献已经被考虑过，恰好只剩下 $ p' - m = 6 - 4 = 2 $ 个子序列，其最小值均为 $ [p'] = 2 $，这些子序列对答案的贡献为 $ (p' - m) \\times [p'] $。\n\n若直接使用上述算法计算每个元素的贡献，单次计算的时间复杂度为 $ O(n) $，超时。\n\n定义 $ m = \\min[l,\\ r] $ 为区间 $ [l,\\ r] $ 的最小值所在的位置，设 $ f(l, r) $ 为区间 $ [l,\\ r] $ 内除最小值之外的其它值对答案的贡献，则有\n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n注意到整个式子除边界条件中的 $ m $ 之外，和 $ l $ 是无关的。\n\n设 $ s(i) $ 为从 $ i $ 位置一直向左跳，直到跳到所有元素中的最小值，用上述方法计算出的贡献总和，则有\n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n注意到刚才的例子中，$ {\\rm left}(p') = {\\rm left}(m + 1) = m $，即**最后一跳的位置**和**最小值的右边一个位置**向左跳跳到的位置相同。所以\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n使用单调栈算法（保持栈底到栈顶的元素单调递增）预处理出每个 $ {\\rm left}(i) $，之后可以在 $ O(n) $ 的时间内递推出 $ s(i) $。区间向左扩展时同理，向右边跳即可。\n\n而对于 RMQ，使用稀疏表在 $ O(n \\log n) $ 的时间内预处理后，即可在 $ O(1) $ 的时间内回答每次查询。最终，每次转移的时间降为 $ O(1) $，总时间复杂度为 $ O(q \\log q + n \\sqrt n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-sequence","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvp00yfooxldumqyx55"},{"title":"「HNOI2016」网络 - 树链剖分 + DFS 序","date":"2016-05-11T09:08:00.000Z","_content":"\n一个简单的网络系统可以被描述成一棵无根树。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度。在每一个时刻，只有可能出现下列三种事件中的一种：\n\n1. 在某两个服务器之间出现一条新的数据交互请求；\n2. 某个数据交互结束请求；\n3. 某个服务器出现故障。\n\n系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### 题解\n对树进行树链剖分，并得到其 DFS 序。树上的一条路经转化为 DFS 序上的 $ O(\\log n) $ 个区间。\n\n考虑一条未完成的交互请求**不**会受到某服务器故障的影响，当且仅当这条交互请求**不**经过这台服务器。所以只需要维护不经过某台服务器的请求即可。一条请求会影响树的 DFS 序上 $ O(\\log n) $ 个区间，其补集即为不经过的服务器，仍然是 $ O(\\log n) $ 个区间。\n\n再就是维护重要度最大的请求，可以在线段树的每个节点上维护一个堆，并将标记永久化（不下传标记，用从根到叶子的一条链上的值更新答案），同时存储每条请求是否已结束，并及时将堆顶已结束的请求删除。\n\n总时间复杂度为 $ O(n \\log ^ 3 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","source":"_posts/hnoi2016-network.md","raw":"title: 「HNOI2016」网络 - 树链剖分 + DFS 序\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - 树链剖分\n  - DFS 序\npermalink: hnoi2016-network\ndate: 2016-05-11 17:08:00\n---\n\n一个简单的网络系统可以被描述成一棵无根树。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度。在每一个时刻，只有可能出现下列三种事件中的一种：\n\n1. 在某两个服务器之间出现一条新的数据交互请求；\n2. 某个数据交互结束请求；\n3. 某个服务器出现故障。\n\n系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### 题解\n对树进行树链剖分，并得到其 DFS 序。树上的一条路经转化为 DFS 序上的 $ O(\\log n) $ 个区间。\n\n考虑一条未完成的交互请求**不**会受到某服务器故障的影响，当且仅当这条交互请求**不**经过这台服务器。所以只需要维护不经过某台服务器的请求即可。一条请求会影响树的 DFS 序上 $ O(\\log n) $ 个区间，其补集即为不经过的服务器，仍然是 $ O(\\log n) $ 个区间。\n\n再就是维护重要度最大的请求，可以在线段树的每个节点上维护一个堆，并将标记永久化（不下传标记，用从根到叶子的一条链上的值更新答案），同时存储每条请求是否已结束，并及时将堆顶已结束的请求删除。\n\n总时间复杂度为 $ O(n \\log ^ 3 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","slug":"hnoi2016-network","published":1,"updated":"2016-05-11T09:39:49.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvt00ylooxlsots6p61"},{"title":"「HNOI2016」最小公倍数 - 分块 + 并查集","date":"2016-05-11T08:39:00.000Z","_content":"\n给定一张 $ N $ 个顶点 $ M $ 条边的无向图（顶点编号为 $ 1,\\ 2,\\ \\dots,\\ n $），每条边上带有权值。所有权值都可以分解成 $ 2 ^ a 3 ^ b $ 的形式。现在有 $ q $ 个询问，每次询问给定四个参数 $ u $、$ v $、$ a $ 和 $ b $，请你求出是否存在一条顶点 $ u $ 到 $ v $ 之间的路径，使得路径依次经过的边上的权值的最小公倍数为 $ 2 ^ a 3 ^ b $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### 题解\n因为**路径**可以不是**简单路径**，所以只要两个点在同一连通块内，就一定可以找到一条连接它们的路径。多个数写成 $ 2 $ 和 $ 3 $ 的幂的积的形式的数 $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $ 的最小公倍数，为这些数中 $ 2 $ 的最高次幂乘以 $ 3 $ 的最高次幂，即 $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $。\n\n问题转化为，判断是否能选取若干条组成同一连通块的边，保证给定的两个点相连通，并且连通块内 $ a $ 和 $ b $ 的最大值分别等于给定的值。\n\n显然，边上的 $ a $ 和 $ b $ 中的任意一个比询问的对应值要大，则这条边不会对询问产生影响。考虑对于某一次询问，从小到大加入 $ a $ 和 $ b $ 均小于等于询问值的边，使用并查集维护连通性和连通块内的最大值，并在加入所有边后判断连通块内最大值是否等于询问值。总时间复杂度为 $ O(qm \\  \\alpha(m)) $，超时。\n\n注意到，如果我们将边按照 $ a $ 排序，并离线处理所有询问，可以每次将 $ a $ 小于等于某个询问的边按照 $ b $ 再次排序，得到所有对答案有贡献的边。\n\n考虑将所有边按照 $ a $ 排序后分为 $ T $ 块，每次处理某一块时，取出之前所有块中的边（这些边中的 $ a $ 均小于等于当前块内的所有询问中的 $ a $），并将其按照 $ b $ 排序。取出询问值 $ a $ 在当前块范围内的所有询问，也将其按照 $ b $ 排序。将取出的所有边增量加入并查集，并同时依次处理所有取出的询问。而块内的边也会对块内询问有影响，每处理一次询问时，枚举块内所有边，用上文中的暴力方式将其加入并查集，并在处理完一次询问后将操作**撤销**。\n\n撤销并查集的方法是，维护一个栈，栈内存储所有被修改的位置及其原本的值，以栈的大小作为状态。恢复时，从栈顶弹出，每次将原本的值修改回去，直到栈大小等于原本的栈大小。注意这里**不能**使用路径压缩，而是要使用**按秩合并**。\n\n分析一下上述算法的时间复杂度：每个询问只会被处理最多一次，处理每次询问时遍历了大小为 $ O(\\frac{n}{T}) $ 的块，其中对并查集进行了最多 $ O(\\frac{n}{T}) $ 次，这部分的时间复杂度为 $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $。处理块之前的边时，每条边最多参与 $ T $ 次排序，每个询问最多参与 $ 1 $ 次排序，这部分的时间复杂度为 $ O(T m \\log m + q \\log q) $。取 $ T = \\sqrt m $，则总时间复杂度为 $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-multiple.md","raw":"title: 「HNOI2016」最小公倍数 - 分块 + 并查集\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - CodeVS\n  - HNOI\n  - 分块\n  - 并查集\npermalink: hnoi2016-multiple\ndate: 2016-05-11 16:39:00\n---\n\n给定一张 $ N $ 个顶点 $ M $ 条边的无向图（顶点编号为 $ 1,\\ 2,\\ \\dots,\\ n $），每条边上带有权值。所有权值都可以分解成 $ 2 ^ a 3 ^ b $ 的形式。现在有 $ q $ 个询问，每次询问给定四个参数 $ u $、$ v $、$ a $ 和 $ b $，请你求出是否存在一条顶点 $ u $ 到 $ v $ 之间的路径，使得路径依次经过的边上的权值的最小公倍数为 $ 2 ^ a 3 ^ b $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### 题解\n因为**路径**可以不是**简单路径**，所以只要两个点在同一连通块内，就一定可以找到一条连接它们的路径。多个数写成 $ 2 $ 和 $ 3 $ 的幂的积的形式的数 $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $ 的最小公倍数，为这些数中 $ 2 $ 的最高次幂乘以 $ 3 $ 的最高次幂，即 $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $。\n\n问题转化为，判断是否能选取若干条组成同一连通块的边，保证给定的两个点相连通，并且连通块内 $ a $ 和 $ b $ 的最大值分别等于给定的值。\n\n显然，边上的 $ a $ 和 $ b $ 中的任意一个比询问的对应值要大，则这条边不会对询问产生影响。考虑对于某一次询问，从小到大加入 $ a $ 和 $ b $ 均小于等于询问值的边，使用并查集维护连通性和连通块内的最大值，并在加入所有边后判断连通块内最大值是否等于询问值。总时间复杂度为 $ O(qm \\  \\alpha(m)) $，超时。\n\n注意到，如果我们将边按照 $ a $ 排序，并离线处理所有询问，可以每次将 $ a $ 小于等于某个询问的边按照 $ b $ 再次排序，得到所有对答案有贡献的边。\n\n考虑将所有边按照 $ a $ 排序后分为 $ T $ 块，每次处理某一块时，取出之前所有块中的边（这些边中的 $ a $ 均小于等于当前块内的所有询问中的 $ a $），并将其按照 $ b $ 排序。取出询问值 $ a $ 在当前块范围内的所有询问，也将其按照 $ b $ 排序。将取出的所有边增量加入并查集，并同时依次处理所有取出的询问。而块内的边也会对块内询问有影响，每处理一次询问时，枚举块内所有边，用上文中的暴力方式将其加入并查集，并在处理完一次询问后将操作**撤销**。\n\n撤销并查集的方法是，维护一个栈，栈内存储所有被修改的位置及其原本的值，以栈的大小作为状态。恢复时，从栈顶弹出，每次将原本的值修改回去，直到栈大小等于原本的栈大小。注意这里**不能**使用路径压缩，而是要使用**按秩合并**。\n\n分析一下上述算法的时间复杂度：每个询问只会被处理最多一次，处理每次询问时遍历了大小为 $ O(\\frac{n}{T}) $ 的块，其中对并查集进行了最多 $ O(\\frac{n}{T}) $ 次，这部分的时间复杂度为 $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $。处理块之前的边时，每条边最多参与 $ T $ 次排序，每个询问最多参与 $ 1 $ 次排序，这部分的时间复杂度为 $ O(T m \\log m + q \\log q) $。取 $ T = \\sqrt m $，则总时间复杂度为 $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-multiple","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvz00ytooxlfpvqw87o"},{"title":"「HNOI2012」矿场搭建 - 割点","date":"2016-09-07T23:52:00.000Z","_content":"\n煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。\n\n请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2730](http://www.lydsy.com/JudgeOnline/problem.php?id=2730)\n\n### 题解\n考虑删掉所有割点，图被分成若干个连通块，如果一个连通块与两个以上的割点连通，则不需要单独建设出口，否则需要单独建设一个出口。\n\n如果图没有割点，需要任意找两个点建设出口。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// if (v->flag) printf(\"!!!: %lu\\n\", v - N + 1);\n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n\ninline void solve(int &min, long long &cnt) {\n\tmin = 0, cnt = 1;\n\tfor (int i = 0; i < n; i++) N[i].v = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v || N[i].flag) continue;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].v = true;\n\n\t\tstd::tr1::unordered_set<unsigned long> s;\n\t\tint size = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tsize++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->flag) s.insert(e->t - N);\n\t\t\t\telse if (!e->t->v) q.push(e->t), e->t->v = true;\n\t\t\t}\n\t\t}\n\n\t\tif (s.size() == 1) min++, cnt *= size;\n\t}\n\n\tif (!min) min = 2, cnt = n * (n - 1) / 2;\n}\n\nint main() {\n\tfor (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n\t\tn = 0;\n\t\twhile (m--) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tn = std::max(n, std::max(u, v));\n\t\t\tu--, v--;\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\ttarjan();\n\n\t\tint min;\n\t\tlong long cnt;\n\t\tsolve(min, cnt);\n\t\tprintf(\"Case %d: %d %lld\\n\", i, min, cnt);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].v = N[i].pushed = N[i].flag = false;\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].p = NULL;\n\t\t\tEdge *next;\n\t\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2012-mine.md","raw":"title: 「HNOI2012」矿场搭建 - 割点\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Tarjan\n  - 图论\n  - 割点\npermalink: hnoi2012-mine\ndate: 2016-09-08 07:52:00\n---\n\n煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。\n\n请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2730](http://www.lydsy.com/JudgeOnline/problem.php?id=2730)\n\n### 题解\n考虑删掉所有割点，图被分成若干个连通块，如果一个连通块与两个以上的割点连通，则不需要单独建设出口，否则需要单独建设一个出口。\n\n如果图没有割点，需要任意找两个点建设出口。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// if (v->flag) printf(\"!!!: %lu\\n\", v - N + 1);\n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n\ninline void solve(int &min, long long &cnt) {\n\tmin = 0, cnt = 1;\n\tfor (int i = 0; i < n; i++) N[i].v = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v || N[i].flag) continue;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].v = true;\n\n\t\tstd::tr1::unordered_set<unsigned long> s;\n\t\tint size = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tsize++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->flag) s.insert(e->t - N);\n\t\t\t\telse if (!e->t->v) q.push(e->t), e->t->v = true;\n\t\t\t}\n\t\t}\n\n\t\tif (s.size() == 1) min++, cnt *= size;\n\t}\n\n\tif (!min) min = 2, cnt = n * (n - 1) / 2;\n}\n\nint main() {\n\tfor (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n\t\tn = 0;\n\t\twhile (m--) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tn = std::max(n, std::max(u, v));\n\t\t\tu--, v--;\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\ttarjan();\n\n\t\tint min;\n\t\tlong long cnt;\n\t\tsolve(min, cnt);\n\t\tprintf(\"Case %d: %d %lld\\n\", i, min, cnt);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].v = N[i].pushed = N[i].flag = false;\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].p = NULL;\n\t\t\tEdge *next;\n\t\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","slug":"hnoi2012-mine","published":1,"updated":"2016-09-07T23:53:21.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rw500z1ooxleae4rpj2"},{"title":"「HNOI2010」合唱队 - 区间 DP","date":"2016-07-06T04:08:00.000Z","_content":"\n合唱队的排队方式为：\n\n1. 第一个人直接插入空的队形中；\n2. 对于第二个人开始的每一个人，如果他比上一个人高，则站到最右边，否则站到最左边。\n\n求对于某一个排好的序列，可以被多少种初始序列构建出，答案对任意数取模。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1996](http://www.lydsy.com/JudgeOnline/problem.php?id=1996)\n\n### 题解\n显然，某一个人是站在前面还是后面，只与上一个人有关。对于一个区间，考虑最后一个站进去的人，一定是最左边或者最右边的，并且这个人站在哪里，受到子区间两端的人的影响。\n\n假设区间 $ [l, r] $ 中最后一个人 $ A $ 站在最右边，即 $ A $ 比 $ [l, r - 1] $ 的最后一个人要高。即，区间 $ [l, r - 1] $ 中，站在两边的比 $ A $ 矮的人都有可能是最后一个站进去的。\n\n设 $ f(l, r, flag) $ 表示 $ [l, r] $ 内，按照 $ flag $ 的方式确定最后一个人是否可放在最左边或最右边，的方案总数。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MOD = 19650827;\n\nconst int DP_L = 0;\nconst int DP_R = 1;\nconst int DP_LR = 2;\n\nint n, a[MAXN];\n\ninline int dp(const int l, const int r, const int flag) {\n\tstatic int mem[MAXN][MAXN][3];\n\tstatic bool calced[MAXN][MAXN][3];\n\tint &ans = mem[l][r][flag];\n\tif (calced[l][r][flag]) return ans;\n\tcalced[l][r][flag] = true;\n\n\tif (r - l + 1 == 2) {\n\t\tif (a[l] > a[r]) return ans = 0;\n\t\telse if (flag == DP_LR) return ans = 2;\n\t\telse return ans = 1;\n\t}\n\n\tif (flag != DP_L) {\n\t\tconst int L = l, R = r - 1;\n\t\tif (a[r] > a[L] && a[r] > a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[r] > a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[r] > a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\tif (flag != DP_R) {\n\t\tconst int L = l + 1, R = r;\n\t\tif (a[l] < a[L] && a[l] < a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[l] < a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[l] < a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\treturn ans %= MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", dp(0, n - 1, DP_LR));\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2010-chorus.md","raw":"title: 「HNOI2010」合唱队 - 区间 DP\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - DP\n  - 区间 DP\npermalink: hnoi2010-chorus\ndate: 2016-07-06 12:08:00\n---\n\n合唱队的排队方式为：\n\n1. 第一个人直接插入空的队形中；\n2. 对于第二个人开始的每一个人，如果他比上一个人高，则站到最右边，否则站到最左边。\n\n求对于某一个排好的序列，可以被多少种初始序列构建出，答案对任意数取模。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1996](http://www.lydsy.com/JudgeOnline/problem.php?id=1996)\n\n### 题解\n显然，某一个人是站在前面还是后面，只与上一个人有关。对于一个区间，考虑最后一个站进去的人，一定是最左边或者最右边的，并且这个人站在哪里，受到子区间两端的人的影响。\n\n假设区间 $ [l, r] $ 中最后一个人 $ A $ 站在最右边，即 $ A $ 比 $ [l, r - 1] $ 的最后一个人要高。即，区间 $ [l, r - 1] $ 中，站在两边的比 $ A $ 矮的人都有可能是最后一个站进去的。\n\n设 $ f(l, r, flag) $ 表示 $ [l, r] $ 内，按照 $ flag $ 的方式确定最后一个人是否可放在最左边或最右边，的方案总数。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MOD = 19650827;\n\nconst int DP_L = 0;\nconst int DP_R = 1;\nconst int DP_LR = 2;\n\nint n, a[MAXN];\n\ninline int dp(const int l, const int r, const int flag) {\n\tstatic int mem[MAXN][MAXN][3];\n\tstatic bool calced[MAXN][MAXN][3];\n\tint &ans = mem[l][r][flag];\n\tif (calced[l][r][flag]) return ans;\n\tcalced[l][r][flag] = true;\n\n\tif (r - l + 1 == 2) {\n\t\tif (a[l] > a[r]) return ans = 0;\n\t\telse if (flag == DP_LR) return ans = 2;\n\t\telse return ans = 1;\n\t}\n\n\tif (flag != DP_L) {\n\t\tconst int L = l, R = r - 1;\n\t\tif (a[r] > a[L] && a[r] > a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[r] > a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[r] > a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\tif (flag != DP_R) {\n\t\tconst int L = l + 1, R = r;\n\t\tif (a[l] < a[L] && a[l] < a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[l] < a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[l] < a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\treturn ans %= MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", dp(0, n - 1, DP_LR));\n\n\treturn 0;\n}\n```\n","slug":"hnoi2010-chorus","published":1,"updated":"2016-10-24T23:36:49.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rwc00z8ooxlcaf0w1yj"},{"title":"「HNOI2008」明明的烦恼 - Prüfer 序列","date":"2016-10-11T10:51:00.000Z","_content":"\n给出标号为 $ 1 $ 到 $ N $ 的点，以及某些点最终的度数，允许在任意两点间连线，求可产生多少棵度数满足要求的树。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005)\n\n### 题解\n此题用到一个东西叫「Prufer 序列」，虽然不懂是什么东西，但只需要一个结论：\n\n> 对于一个 $ n $ 个节点的树，其 Prufer 序列的长度为 $ n - 2 $，且一个点的度数 $ -1 $ 等于它在 Prufer 序列中的出现次数。\n\n设共有 $ k $ 个点被限制度，$ d_i $ 表示节点 $ i $ 的度，$ s = \\sum\\limits_{d_i \\neq -1} d_i - 1 $。即被限制度的点共出现了 $ s $ 次。\n\n考虑他们在 Prufer 序列中的出现位置，并乘上一个重复元素排列，即\n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} $$\n\n继续考虑剩余的 $ n - k $ 个无度限制的点，剩余的 $ n - 2 - s $ 个位置可以任意放这些点，即\n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} $$\n\n整理，得\n\n$$\n\\begin{aligned}\n&= \\frac{(n - 2)!}{s!(n - 2 - s)!} \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} \\\\\n&= \\frac{(n - 2)! (n - k) ^ {n - 2 - s}}{(n - 2 - s)! \\prod\\limits_{i = 1} ^ k (d_i - 1) !}\n\\end{aligned}\n$$\n\n### 代码\n```java\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint d[] = new int[n], s = 0, k = 0;\n\t\tboolean invalid = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t\tif (d[i] != -1) {\n\t\t\t\tk++;\n\t\t\t\tif (d[i] <= 0 || d[i] >= n + 1) invalid = true;\n\t\t\t\ts += d[i] - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tif (d[0] == 0 || d[0] == -1) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (n == 2) {\n\t\t\tif ((d[0] == 1 || d[0] == -1) && (d[1] == 1 || d[1] == -1)) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (invalid) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tBigInteger fac[] = new BigInteger[n - 1];\n\t\t\tfac[0] = BigInteger.ONE;\n\t\t\tfor (int i = 1; i <= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i));\n\n\t\t\tBigInteger ans = BigInteger.ONE;\n\t\t\tans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]);\n\t\t\tfor (int i = 0; i < n; i++) if (d[i] > 1) ans = ans.divide(fac[d[i] - 1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n```\n","source":"_posts/hnoi2008-tree.md","raw":"title: 「HNOI2008」明明的烦恼 - Prüfer 序列\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Prüfer 序列\n  - 数学\n  - 高精度\npermalink: hnoi2008-tree\ndate: 2016-10-11 18:51:00\n---\n\n给出标号为 $ 1 $ 到 $ N $ 的点，以及某些点最终的度数，允许在任意两点间连线，求可产生多少棵度数满足要求的树。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005)\n\n### 题解\n此题用到一个东西叫「Prufer 序列」，虽然不懂是什么东西，但只需要一个结论：\n\n> 对于一个 $ n $ 个节点的树，其 Prufer 序列的长度为 $ n - 2 $，且一个点的度数 $ -1 $ 等于它在 Prufer 序列中的出现次数。\n\n设共有 $ k $ 个点被限制度，$ d_i $ 表示节点 $ i $ 的度，$ s = \\sum\\limits_{d_i \\neq -1} d_i - 1 $。即被限制度的点共出现了 $ s $ 次。\n\n考虑他们在 Prufer 序列中的出现位置，并乘上一个重复元素排列，即\n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} $$\n\n继续考虑剩余的 $ n - k $ 个无度限制的点，剩余的 $ n - 2 - s $ 个位置可以任意放这些点，即\n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} $$\n\n整理，得\n\n$$\n\\begin{aligned}\n&= \\frac{(n - 2)!}{s!(n - 2 - s)!} \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} \\\\\n&= \\frac{(n - 2)! (n - k) ^ {n - 2 - s}}{(n - 2 - s)! \\prod\\limits_{i = 1} ^ k (d_i - 1) !}\n\\end{aligned}\n$$\n\n### 代码\n```java\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint d[] = new int[n], s = 0, k = 0;\n\t\tboolean invalid = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t\tif (d[i] != -1) {\n\t\t\t\tk++;\n\t\t\t\tif (d[i] <= 0 || d[i] >= n + 1) invalid = true;\n\t\t\t\ts += d[i] - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tif (d[0] == 0 || d[0] == -1) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (n == 2) {\n\t\t\tif ((d[0] == 1 || d[0] == -1) && (d[1] == 1 || d[1] == -1)) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (invalid) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tBigInteger fac[] = new BigInteger[n - 1];\n\t\t\tfac[0] = BigInteger.ONE;\n\t\t\tfor (int i = 1; i <= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i));\n\n\t\t\tBigInteger ans = BigInteger.ONE;\n\t\t\tans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]);\n\t\t\tfor (int i = 0; i < n; i++) if (d[i] > 1) ans = ans.divide(fac[d[i] - 1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n```\n","slug":"hnoi2008-tree","published":1,"updated":"2016-10-17T03:06:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rwh00zeooxl94ccbys0"},{"title":"「HNOI2008」玩具装箱 - 斜率优化 DP","date":"2016-04-24T03:23:41.000Z","_content":"\nP 教授有编号为 $ 1 $ ~ $ N $ 的 $ N $ 件玩具，第 $ i $ 件玩具经过压缩后变成一维长度为 $ C_i $。为了方便整理，P 教授要求在一个一维容器中的玩具编号是连续的。如果将第 $ i $ 件玩具到第 $ j $ 个玩具放到一个容器中，那么容器的长度将为 $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $。如果容器长度为 $ x $。其制作费用为 $ (x - L) ^ 2 $。其中 $ L $ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容\n器，甚至超过 $ L $。但他希望费用最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### 题解\n动态规划，设 $ f[i] $ 表示前 i 件玩具放进若干个容器中的最小费用，前缀和 $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $。\n\n转移时枚举前面多少个装在同一个箱子里，设它为 $ j $，则第 $ j + 1 $ ~ $ i $ 个装在同一个箱子里，长度为 $ i - j - 1 + s(i) - s(j) $，即\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n直接计算的复杂度为 $ O(n ^ 2) $，超时，考虑优化。\n\n设 $ g(i) = s(i) + i - L - 1 $，$ h(j) = s(j) + j $，上面的方程可以转化为\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n考虑两个决策 $ j = a $ 和 $ j = b $（$ a > b $），若 a 比 b 优，当且仅当\n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n左边成为了斜率的形式，三个式子都是单调的，因此可以用一个单调队列维护每个决策，保证最优决策在队首，两两决策点形成的斜率递增，每次状态转移复杂度降为 $ O(1) $，总时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2008-toy.md","raw":"title: 「HNOI2008」玩具装箱 - 斜率优化 DP\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - COGS\n  - HNOI\n  - 斜率优化\n  - 单调队列\n  - DP\npermalink: hnoi2008-toy\ndate: 2016-04-24 11:23:41\n---\n\nP 教授有编号为 $ 1 $ ~ $ N $ 的 $ N $ 件玩具，第 $ i $ 件玩具经过压缩后变成一维长度为 $ C_i $。为了方便整理，P 教授要求在一个一维容器中的玩具编号是连续的。如果将第 $ i $ 件玩具到第 $ j $ 个玩具放到一个容器中，那么容器的长度将为 $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $。如果容器长度为 $ x $。其制作费用为 $ (x - L) ^ 2 $。其中 $ L $ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容\n器，甚至超过 $ L $。但他希望费用最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### 题解\n动态规划，设 $ f[i] $ 表示前 i 件玩具放进若干个容器中的最小费用，前缀和 $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $。\n\n转移时枚举前面多少个装在同一个箱子里，设它为 $ j $，则第 $ j + 1 $ ~ $ i $ 个装在同一个箱子里，长度为 $ i - j - 1 + s(i) - s(j) $，即\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n直接计算的复杂度为 $ O(n ^ 2) $，超时，考虑优化。\n\n设 $ g(i) = s(i) + i - L - 1 $，$ h(j) = s(j) + j $，上面的方程可以转化为\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n考虑两个决策 $ j = a $ 和 $ j = b $（$ a > b $），若 a 比 b 优，当且仅当\n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n左边成为了斜率的形式，三个式子都是单调的，因此可以用一个单调队列维护每个决策，保证最优决策在队首，两两决策点形成的斜率递增，每次状态转移复杂度降为 $ O(1) $，总时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"hnoi2008-toy","published":1,"updated":"2016-10-24T23:36:27.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rwo00zmooxl4rjkgjx8"},{"title":"「HNOI2008」神奇的国度 - 最大势","date":"2016-10-17T03:07:00.000Z","_content":"\n给一个弦图，求它的最小染色数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006)\n\n### 题解\n使用最大势（MCS）算法，求出一个**弦图**的**完美消除序列**，染色时，对完美消除序列从后向前染当前能染的最小颜色，即为最优方案。\n\n最大势算法的流程是：\n\n1. 选一个点作为初始点，排在完美消除序列的最后一个；\n2. 将这个点邻接点的势 $ +1 $；\n3. 从它的邻接点中选择一个势最大的，且未被选中过的点，作为完美消除序列的下一个点；\n4. 返回 (2)，直到完美消除序列构造完毕。\n\n朴素算法的时间复杂度为 $ O(n ^ 2 + m) $ 使用链表优化，可将时间复杂度降为 $ O(n + m) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <set>\n#include <list>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nstruct Node {\n\tstruct Edge *e;\n\tint d, color;\n\tbool visited;\n\tstd::list<Node *>::iterator iterator;\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, m;\n\ninline void mcs() {\n\tstatic std::list<Node *> lists[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tN[i].d = 0;\n\t\tN[i].visited = false;\n\t\tlists[0].push_front(&N[i]);\n\t\tN[i].iterator = lists[0].begin();\n\t}\n\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (lists[max].empty()) max--;\n\t\tNode *v = lists[max].front();\n\t\tlists[max].pop_front();\n\t\tseq[i] = v;\n\t\t// printf(\"%lu\\n\", seq[i] - N + 1);\n\t\tv->visited = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\tlists[e->t->d].erase(e->t->iterator);\n\t\t\t\te->t->d++;\n\t\t\t\tlists[e->t->d].push_front(e->t);\n\t\t\t\te->t->iterator = lists[e->t->d].begin();\n\t\t\t\tmax = std::max(max, e->t->d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tmcs();\n\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tstd::set<int> s;\n\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\tif (e->t->color) s.insert(e->t->color);\n\t\t}\n\t\ts.insert(INT_MAX);\n\n\t\tint last = 0;\n\t\tfor (std::set<int>::const_iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tif (last + 1 != *it) {\n\t\t\t\tseq[i]->color = last + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = *it;\n\t\t}\n\n\t\tans = std::max(ans, seq[i]->color);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-kingdom.md","raw":"title: 「HNOI2008」神奇的国度 - 最大势\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - 弦图\n  - 最大势\npermalink: hnoi2008-kingdom\ndate: 2016-10-17 11:07:00\n---\n\n给一个弦图，求它的最小染色数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006)\n\n### 题解\n使用最大势（MCS）算法，求出一个**弦图**的**完美消除序列**，染色时，对完美消除序列从后向前染当前能染的最小颜色，即为最优方案。\n\n最大势算法的流程是：\n\n1. 选一个点作为初始点，排在完美消除序列的最后一个；\n2. 将这个点邻接点的势 $ +1 $；\n3. 从它的邻接点中选择一个势最大的，且未被选中过的点，作为完美消除序列的下一个点；\n4. 返回 (2)，直到完美消除序列构造完毕。\n\n朴素算法的时间复杂度为 $ O(n ^ 2 + m) $ 使用链表优化，可将时间复杂度降为 $ O(n + m) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <set>\n#include <list>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nstruct Node {\n\tstruct Edge *e;\n\tint d, color;\n\tbool visited;\n\tstd::list<Node *>::iterator iterator;\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, m;\n\ninline void mcs() {\n\tstatic std::list<Node *> lists[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tN[i].d = 0;\n\t\tN[i].visited = false;\n\t\tlists[0].push_front(&N[i]);\n\t\tN[i].iterator = lists[0].begin();\n\t}\n\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (lists[max].empty()) max--;\n\t\tNode *v = lists[max].front();\n\t\tlists[max].pop_front();\n\t\tseq[i] = v;\n\t\t// printf(\"%lu\\n\", seq[i] - N + 1);\n\t\tv->visited = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\tlists[e->t->d].erase(e->t->iterator);\n\t\t\t\te->t->d++;\n\t\t\t\tlists[e->t->d].push_front(e->t);\n\t\t\t\te->t->iterator = lists[e->t->d].begin();\n\t\t\t\tmax = std::max(max, e->t->d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tmcs();\n\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tstd::set<int> s;\n\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\tif (e->t->color) s.insert(e->t->color);\n\t\t}\n\t\ts.insert(INT_MAX);\n\n\t\tint last = 0;\n\t\tfor (std::set<int>::const_iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tif (last + 1 != *it) {\n\t\t\t\tseq[i]->color = last + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = *it;\n\t\t}\n\n\t\tans = std::max(ans, seq[i]->color);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"hnoi2008-kingdom","published":1,"updated":"2016-10-17T09:25:23.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rwu00zvooxlp3x9im32"},{"title":"「HNOI2008」GT考试 - KMP + 矩阵乘法","date":"2016-10-07T22:43:00.000Z","_content":"\n给一个长度为 $ m $ 的字符串 $ T $，求长度为 $ n $ 且不包含 $ T $ 的字符串的数量。\n\n<!-- more -->\n\n### 连接\n[BZOJ 1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009)\n\n### 题解\n对 $ T $ 串进行 KMP 预处理，设状态 $ f(i, j) $ 表示目标串的前 $ i $ 个字符，匹配到 $ T $ 串的第 $ j $ 个字符，的方案数。每次枚举下一个字符，刷表转移。\n\n显然，每一阶段的结果都是与上一阶段结果呈线性的，可以使用矩阵快速幂优化，时间复杂度为 $ O(m ^ 3 \\log n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e9;\nconst int MAXM = 20;\nconst int MAXK = 1000;\n\nstruct Matrix {\n\tint a[MAXM][MAXM];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i < MAXM; i++) a[i][i] = 1;\n\t\t}\n\t}\n\n\tint &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\n\tconst int &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\n\nint mod;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) for (int k = 0; k < MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tchar s[MAXM + 2];\n\tscanf(\"%d %d %d\\n%s\", &n, &m, &mod, s + 1);\n\n\tint fail[MAXM + 1];\n\tfail[0] = fail[1] = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\tint k = fail[i - 1];\n\t\twhile (k && s[k + 1] != s[i]) k = fail[k];\n\t\tif (s[k + 1] == s[i]) fail[i] = k + 1;\n\t\telse fail[i] = 0;\n\t}\n\n\t// for (int i = 0; i <= m; i++) printf(\"%d%c\", fail[i], i == m ? '\\n' : ' ');\n\n\t/*\n\tint f[50][MAXM + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\t\tint k = j;\n\t\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\t\tif (s[k + 1] == c) k++;\n\n\t\t\t\tf[i + 1][k] += f[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tint k = i;\n\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\tif (s[k + 1] == c) k++;\n\t\t\tif (k < m) shift(i, k)++;\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\tMatrix res = init * pow(shift, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res(0, i)) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\t// for (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) printf(\"%d%c\", res(i, j), j == MAXM - 1 ? '\\n' : ' ');\n\n\t/*\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\t*/\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-gt.md","raw":"title: 「HNOI2008」GT考试 - KMP + 矩阵乘法\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - DP\n  - KMP\n  - 字符串\n  - 矩阵乘法\n  - 快速幂\npermalink: hnoi2008-gt\ndate: 2016-10-08 06:43:00\n---\n\n给一个长度为 $ m $ 的字符串 $ T $，求长度为 $ n $ 且不包含 $ T $ 的字符串的数量。\n\n<!-- more -->\n\n### 连接\n[BZOJ 1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009)\n\n### 题解\n对 $ T $ 串进行 KMP 预处理，设状态 $ f(i, j) $ 表示目标串的前 $ i $ 个字符，匹配到 $ T $ 串的第 $ j $ 个字符，的方案数。每次枚举下一个字符，刷表转移。\n\n显然，每一阶段的结果都是与上一阶段结果呈线性的，可以使用矩阵快速幂优化，时间复杂度为 $ O(m ^ 3 \\log n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e9;\nconst int MAXM = 20;\nconst int MAXK = 1000;\n\nstruct Matrix {\n\tint a[MAXM][MAXM];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i < MAXM; i++) a[i][i] = 1;\n\t\t}\n\t}\n\n\tint &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\n\tconst int &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\n\nint mod;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) for (int k = 0; k < MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tchar s[MAXM + 2];\n\tscanf(\"%d %d %d\\n%s\", &n, &m, &mod, s + 1);\n\n\tint fail[MAXM + 1];\n\tfail[0] = fail[1] = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\tint k = fail[i - 1];\n\t\twhile (k && s[k + 1] != s[i]) k = fail[k];\n\t\tif (s[k + 1] == s[i]) fail[i] = k + 1;\n\t\telse fail[i] = 0;\n\t}\n\n\t// for (int i = 0; i <= m; i++) printf(\"%d%c\", fail[i], i == m ? '\\n' : ' ');\n\n\t/*\n\tint f[50][MAXM + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\t\tint k = j;\n\t\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\t\tif (s[k + 1] == c) k++;\n\n\t\t\t\tf[i + 1][k] += f[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tint k = i;\n\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\tif (s[k + 1] == c) k++;\n\t\t\tif (k < m) shift(i, k)++;\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\tMatrix res = init * pow(shift, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res(0, i)) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\t// for (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) printf(\"%d%c\", res(i, j), j == MAXM - 1 ? '\\n' : ' ');\n\n\t/*\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\t*/\n\n\treturn 0;\n}\n```","slug":"hnoi2008-gt","published":1,"updated":"2016-10-07T22:52:45.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rx00103ooxl8nvl0ffh"},{"title":"「HNOI2008」Cards - Burnside 引理","date":"2016-10-17T02:57:00.000Z","_content":"\n给 $ n $ 张牌，3 种颜色，和 $ m $ 种洗牌方案，求本质不同的染色方案数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004)\n\n### 题解\nBurnside 引理，求出对于每一种洗牌方案，洗完牌后不变的方案数 —— 将每种洗牌方案拆成若干个循环，只需保证每个循环中的牌颜色相同即可，对每个循环的长度做背包即可。\n\n求出这些方案数后，在模意义下除以 $ m $ 得到答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXX = 20;\nconst int MAXN = 60;\nconst int MAXM = 60;\n\nint a, b, c, n, mod;\n\ninline int calc(const int *map) {\n\tbool flag[MAXM] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = 0;\n\t\tfor (int t = i; !flag[t]; t = map[t]) {\n\t\t\tflag[t] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAXX + 1][MAXX + 1][MAXX + 1];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"calc() = %d\\n\", f[a][b][c]);\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int x) {\n\tint tmp1, tmp2, res;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint map[MAXN];\n\t\tfor (int j = 0; j < n; j++) scanf(\"%d\", &map[j]), map[j]--;\n\t\t(sum += calc(map)) %= mod;\n\t}\n\n\tint map[MAXN];\n\tfor (int i = 0; i < n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-cards.md","raw":"title: 「HNOI2008」Cards - Burnside 引理\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Burnside 引理\n  - 群论\n  - 数学\npermalink: hnoi2008-cards\ndate: 2016-10-17 10:57:00\n---\n\n给 $ n $ 张牌，3 种颜色，和 $ m $ 种洗牌方案，求本质不同的染色方案数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004)\n\n### 题解\nBurnside 引理，求出对于每一种洗牌方案，洗完牌后不变的方案数 —— 将每种洗牌方案拆成若干个循环，只需保证每个循环中的牌颜色相同即可，对每个循环的长度做背包即可。\n\n求出这些方案数后，在模意义下除以 $ m $ 得到答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXX = 20;\nconst int MAXN = 60;\nconst int MAXM = 60;\n\nint a, b, c, n, mod;\n\ninline int calc(const int *map) {\n\tbool flag[MAXM] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = 0;\n\t\tfor (int t = i; !flag[t]; t = map[t]) {\n\t\t\tflag[t] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAXX + 1][MAXX + 1][MAXX + 1];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"calc() = %d\\n\", f[a][b][c]);\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int x) {\n\tint tmp1, tmp2, res;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint map[MAXN];\n\t\tfor (int j = 0; j < n; j++) scanf(\"%d\", &map[j]), map[j]--;\n\t\t(sum += calc(map)) %= mod;\n\t}\n\n\tint map[MAXN];\n\tfor (int i = 0; i < n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"hnoi2008-cards","published":1,"updated":"2016-10-17T03:03:37.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rx6010cooxlj2093ofg"},{"title":"「HNOI2004」宠物收养所 - set","id":"5","updated":"2016-01-19T13:08:01.000Z","date":"2015-12-15T21:14:20.000Z","_content":"\n有 `N`（<= 80000）个宠物或领养者，每个宠物或者领养者有一个特点值 `a`，每次当宠物或领养者到来时，从已有的当中匹配一个与其特点值相差最小（且特点值较小）的并删除，计算所有的领养特点值差的总和。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### 题解\n匹配相差最小的元素，很容易联想到复杂度为$O({\\log} n)$的二分查找，但是题目要求动态插入删除，考虑使用 STL 中的 set。\n\n为宠物和领养者各维护一个 set，每当有新的到来时，从另一个 set 中 `lower_bound` 找出**第一个大于等于**该特点值的元素，该元素的上一个即为**第一个小于**该特点值的元素，取二者与新加入的特点值相差较小的即可。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2004-pet.md","raw":"title: 「HNOI2004」宠物收养所 - set\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - HNOI\n  - set\n  - STL\npermalink: hnoi2004-pet\nid: 5\nupdated: '2016-01-19 21:08:01'\ndate: 2015-12-16 05:14:20\n---\n\n有 `N`（<= 80000）个宠物或领养者，每个宠物或者领养者有一个特点值 `a`，每次当宠物或领养者到来时，从已有的当中匹配一个与其特点值相差最小（且特点值较小）的并删除，计算所有的领养特点值差的总和。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### 题解\n匹配相差最小的元素，很容易联想到复杂度为$O({\\log} n)$的二分查找，但是题目要求动态插入删除，考虑使用 STL 中的 set。\n\n为宠物和领养者各维护一个 set，每当有新的到来时，从另一个 set 中 `lower_bound` 找出**第一个大于等于**该特点值的元素，该元素的上一个即为**第一个小于**该特点值的元素，取二者与新加入的特点值相差较小的即可。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"hnoi2004-pet","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rxd010kooxl8kwyqo81"},{"title":"「HNOI2004」L语言 - Trie","date":"2016-09-12T23:40:00.000Z","_content":"\n我们称一段文章 $ T $ 在某个字典 $ D $ 下是可以被理解的，是指如果文章 $ T $ 可以被分成若干部分，且每一个部分都是字典 $ D $ 中的单词。\n\n给定一个字典 $ D $，你的程序需要判断若干段文章在字典 $ D $ 下是否能够被理解。并给出其在字典 $ D $ 下能够被理解的最长前缀的位置。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1212](http://www.lydsy.com/JudgeOnline/problem.php?id=1212)\n\n### 题解\n设 $ f_i $ 表示文章的前 $ i $ 个字符是否可被理解，如果 $ f_{i - 1} $ 为真，则对于每一个长度为 $ m $ 单词，若它能从 $ i $ 位置开始完全匹配，则 $ f_{i + m - 1} $ 为真。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1024 * 1024;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAT = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE]; //, *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\t/*\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a';\n\t\tt.insert(s, s + len);\n\t}\n\n\t// t.build();\n\n\twhile (m--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tstatic bool _f[MAXN + 1], *f = _f + 1;\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a', f[i] = false;\n\t\tint ans = -1;\n\t\tf[-1] = true;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!f[i - 1]) continue;\n\t\t\tTrie::Node *v = t.root;\n\t\t\tfor (int j = i; j < len; j++) {\n\t\t\t\t// while (v != t.root && !v->c[s[j]]) v = v->fail;\n\t\t\t\tif (!v->c[s[j]]) break;\n\t\t\t\tv = v->c[s[j]];\n\t\t\t\tif (v->isWord) f[j] = true, ans = std::max(ans, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans + 1);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2004-language.md","raw":"title: 「HNOI2004」L语言 - Trie\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - 字符串\n  - Trie\npermalink: hnoi2004-language\ndate: 2016-09-13 07:40:00\n---\n\n我们称一段文章 $ T $ 在某个字典 $ D $ 下是可以被理解的，是指如果文章 $ T $ 可以被分成若干部分，且每一个部分都是字典 $ D $ 中的单词。\n\n给定一个字典 $ D $，你的程序需要判断若干段文章在字典 $ D $ 下是否能够被理解。并给出其在字典 $ D $ 下能够被理解的最长前缀的位置。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1212](http://www.lydsy.com/JudgeOnline/problem.php?id=1212)\n\n### 题解\n设 $ f_i $ 表示文章的前 $ i $ 个字符是否可被理解，如果 $ f_{i - 1} $ 为真，则对于每一个长度为 $ m $ 单词，若它能从 $ i $ 位置开始完全匹配，则 $ f_{i + m - 1} $ 为真。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1024 * 1024;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAT = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE]; //, *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\t/*\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a';\n\t\tt.insert(s, s + len);\n\t}\n\n\t// t.build();\n\n\twhile (m--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tstatic bool _f[MAXN + 1], *f = _f + 1;\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a', f[i] = false;\n\t\tint ans = -1;\n\t\tf[-1] = true;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!f[i - 1]) continue;\n\t\t\tTrie::Node *v = t.root;\n\t\t\tfor (int j = i; j < len; j++) {\n\t\t\t\t// while (v != t.root && !v->c[s[j]]) v = v->fail;\n\t\t\t\tif (!v->c[s[j]]) break;\n\t\t\t\tv = v->c[s[j]];\n\t\t\t\tif (v->isWord) f[j] = true, ans = std::max(ans, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans + 1);\n\t}\n\n\treturn 0;\n}\n```","slug":"hnoi2004-language","published":1,"updated":"2016-09-12T23:45:11.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rxj010rooxlb78fqxbl"},{"title":"风景这边独好","date":"2017-01-01T15:30:00.000Z","_content":"\n晚饭后回到学校，在楼前停了下来，驻足观赏着这里的夜景。自己学校的风景早已习以为常，而对这边的一草一木，都有一种莫名的向往。\n\n![](here-the-best-sight/1.jpg)\n\n<!-- more -->\n\n大概这是一种自然的美，好像已经很久没有这样接近自然了。闷在屋子里久了，出来走走，也是一种不一样的心情吧。\n\n周围一个人都没有，虫鸣声声声入耳，显得格外的清静。好像一下子远离了周围的繁华街市。\n\n似乎一切不快乐的事都忘掉了，不需要去想任何事，仿佛置身于这个忙碌的世界之外，来到了心中的仙境一般。\n\n![](here-the-best-sight/2.jpg)\n\n突然感觉，自己的压力太大了，从来没有过什么机会去放松，这样散一散心，的确轻快了许多。大概，只有这片天空，会一直陪伴着我，见证我的成长吧。\n\n这便是最简单，而又最难得的，幸福吧。\n\n![](here-the-best-sight/3.jpg)\n","source":"_posts/here-the-best-sight.md","raw":"title: 风景这边独好\ncategories: \n  - Diary\npermalink: here-the-best-sight\ndate: 2017-01-01 23:30:00\n---\n\n晚饭后回到学校，在楼前停了下来，驻足观赏着这里的夜景。自己学校的风景早已习以为常，而对这边的一草一木，都有一种莫名的向往。\n\n![](here-the-best-sight/1.jpg)\n\n<!-- more -->\n\n大概这是一种自然的美，好像已经很久没有这样接近自然了。闷在屋子里久了，出来走走，也是一种不一样的心情吧。\n\n周围一个人都没有，虫鸣声声声入耳，显得格外的清静。好像一下子远离了周围的繁华街市。\n\n似乎一切不快乐的事都忘掉了，不需要去想任何事，仿佛置身于这个忙碌的世界之外，来到了心中的仙境一般。\n\n![](here-the-best-sight/2.jpg)\n\n突然感觉，自己的压力太大了，从来没有过什么机会去放松，这样散一散心，的确轻快了许多。大概，只有这片天空，会一直陪伴着我，见证我的成长吧。\n\n这便是最简单，而又最难得的，幸福吧。\n\n![](here-the-best-sight/3.jpg)\n","slug":"here-the-best-sight","published":1,"updated":"2017-01-01T23:47:32.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rxo010xooxlim11g2sa"},{"title":"「HEOI2013」Eden 的新背包问题 - 背包 DP","date":"2016-07-11T15:10:00.000Z","_content":"\n有 $ n $ 个玩偶，每个玩偶有对应的价值、价钱，每个玩偶都可以被买有限次，在携带的价钱 $ m $ 固定的情况下，如何选择买哪些玩偶以及每个玩偶买多少个，才能使得选择的玩偶总价钱不超过 $ m $，且价值和最大。\n\n多次询问，每次询问都将给出新的总价钱，并且会去掉某个玩偶（即这个玩偶不能被选择），再问此时的多重背包的答案。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3163](http://www.lydsy.com/JudgeOnline/problem.php?id=3163)\n\n### 题解\n用 $ f(i, j) $ 表示第 $ i $ 件**及其之前**物品装进容量为 $ j $ 的背包中的最大收益；用 $ g(i, j) $ 表示第 $ i $ 件**及其之后**物品装进容量为 $ j $ 的背包中的最大收益；\n\n对于无法选择 $ a $ 物品，背包容量为 $ m $，答案为\n\n$$\n\\max\\limits_{i = 0} ^ {m} \\{ f(a - 1, i) + g(a + 1, m - i) \\}\n$$\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\nconst int MAXLOGN = 10;\nconst int MAXQ = 300000;\n\nint main() {\n\tint n;\n\tstatic int w[MAXN], v[MAXN], cnt[MAXN];\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &w[i], &v[i], &cnt[i]);\n\n\tstatic std::pair<int, int> r[MAXN];\n\tstatic int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN];\n\tint N = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i].first = N + 1;\n\t\tfor (int j = 1; j <= cnt[i]; cnt[i] -= j, j *= 2) {\n\t\t// for (int j = 1; cnt[i]; cnt[i]--) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * j;\n\t\t\tV[N] = v[i] * j;\n\t\t}\n\t\tif (cnt[i]) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * cnt[i];\n\t\t\tV[N] = v[i] * cnt[i];\n\t\t}\n\t\tr[i].second = N;\n\t}\n\n\tstatic int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1];\n\t// for (int i = 0; i <= N; i++) f[i][0] = 1;\n\t// for (int i = 1; i <= N + 1; i++) g[i][0] = 1;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) g[i][j] = g[i + 1][j];\n\t\t\telse g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint id, m;\n\t\tscanf(\"%d %d\", &id, &m);\n\n\t\tint ans = 0, a = r[id].first - 1, b = r[id].second + 1;\n\t\tfor (int j = 0; j <= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/heoi2013-bag.md","raw":"title: 「HEOI2013」Eden 的新背包问题 - 背包 DP\ncategories: OI\ntags: \n  - BZOJ\n  - HEOI\n  - DP\n  - 背包 DP\npermalink: heoi2013-bag\ndate: 2016-07-11 23:10:00\n---\n\n有 $ n $ 个玩偶，每个玩偶有对应的价值、价钱，每个玩偶都可以被买有限次，在携带的价钱 $ m $ 固定的情况下，如何选择买哪些玩偶以及每个玩偶买多少个，才能使得选择的玩偶总价钱不超过 $ m $，且价值和最大。\n\n多次询问，每次询问都将给出新的总价钱，并且会去掉某个玩偶（即这个玩偶不能被选择），再问此时的多重背包的答案。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3163](http://www.lydsy.com/JudgeOnline/problem.php?id=3163)\n\n### 题解\n用 $ f(i, j) $ 表示第 $ i $ 件**及其之前**物品装进容量为 $ j $ 的背包中的最大收益；用 $ g(i, j) $ 表示第 $ i $ 件**及其之后**物品装进容量为 $ j $ 的背包中的最大收益；\n\n对于无法选择 $ a $ 物品，背包容量为 $ m $，答案为\n\n$$\n\\max\\limits_{i = 0} ^ {m} \\{ f(a - 1, i) + g(a + 1, m - i) \\}\n$$\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\nconst int MAXLOGN = 10;\nconst int MAXQ = 300000;\n\nint main() {\n\tint n;\n\tstatic int w[MAXN], v[MAXN], cnt[MAXN];\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &w[i], &v[i], &cnt[i]);\n\n\tstatic std::pair<int, int> r[MAXN];\n\tstatic int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN];\n\tint N = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i].first = N + 1;\n\t\tfor (int j = 1; j <= cnt[i]; cnt[i] -= j, j *= 2) {\n\t\t// for (int j = 1; cnt[i]; cnt[i]--) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * j;\n\t\t\tV[N] = v[i] * j;\n\t\t}\n\t\tif (cnt[i]) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * cnt[i];\n\t\t\tV[N] = v[i] * cnt[i];\n\t\t}\n\t\tr[i].second = N;\n\t}\n\n\tstatic int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1];\n\t// for (int i = 0; i <= N; i++) f[i][0] = 1;\n\t// for (int i = 1; i <= N + 1; i++) g[i][0] = 1;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) g[i][j] = g[i + 1][j];\n\t\t\telse g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint id, m;\n\t\tscanf(\"%d %d\", &id, &m);\n\n\t\tint ans = 0, a = r[id].first - 1, b = r[id].second + 1;\n\t\tfor (int j = 0; j <= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"heoi2013-bag","published":1,"updated":"2016-10-24T23:36:40.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rxv010zooxl992znn8t"},{"title":"「HDU 5906」Square Revolution - 后缀数组 + 并查集 + 树状数组","date":"2016-09-30T10:00:00.000Z","_content":"\n对于一个给定的字符串 $ S $，有多少连续子串是 prefix-suffix-square free 的。\n\n一个字符串被称为 square 当且仅当它可以由两个相同的串连接而成。例如，`abab`，`aa` 是 square，而 `aaa`，`abba` 不是。一个字符串是 prefix-suffix-square free 的当且仅当他的任何前缀或者后缀都不是 square。\n\n<!-- more -->\n\n### 链接\n[HDU 5906](http://acm.hdu.edu.cn/showproblem.php?pid=5906)\n\n### 题解\n求出从每个位置开始、结束的最短 square，进而求出从第 $ i $ 个位置结束的子串，其开始位置的最小值。设从第 $ i $ 个位置开始的最短 square 为 $ f(i) $，从第 $ i $ 个位置结束的子串，其开始位置的最小值为 $ g(i) $，则答案为对于每个 $ i $，在 $ j \\in [i, i + f(i) - 2] $ 内满足 $ i \\geq g(j) $ 的 $ j $ 的数量之和。\n\n考虑如何求 square：类似「NOI2016 优秀的拆分」一题，枚举 $ k $，枚举每个长度为 $ k $ 的区间，则所有长度为 $ 2k $ 的 square 都会跨越这个区间 $ [l, r] $，从端点分别向前、后求最长公共后缀、前缀。进而可以求出若干个 square。如，从 $ [L, R] $ 内一点开始，均有一个长度为 $ 2k $ 的 square，此时用 $ 2k $ 更新 $ f(i), i \\in[L, R] $。\n\n因为是从小到大枚举的 $ k $，所以每个位置只会被赋值一次，使用并查集维护所有赋值过的点，赋值过的点合并，之后直接跳过这些区间即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\tinline void build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tinline int rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n\n\tinline int lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint n, forward[MAXN], backward[MAXN];\n\ninline int lcp(const int i, const int j) { return sa1.lcp(i, j); }\ninline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); }\n\ninline void prepare(const int n) {\n\t/*\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int l, const int r, const int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) this->val = std::min(this->val, x);\n\t\t\telse lc->update(l, r, x), rc->update(l, r, x);\n\t\t}\n\n\t\tint query(const int pos) {\n\t\t\treturn (l == r) ? val : std::min(val, ((pos <= mid) ? lc : rc)->query(pos));\n\t\t}\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t\t}\n\t\t}\n\t} *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1);\n\t*/\n\n\tstatic struct UnionFindSet {\n\t\tint a[MAXN], n;\n\n\t\tvoid init(const int n) {\n\t\t\tthis->n = n;\n\t\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t\t}\n\n\t\tint find(const int x) {\n\t\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t\t}\n\n\t\tvoid merge(const int child, const int parent) {\n#ifdef DBG\n\t\t\tprintf(\"merge: %d => %d\\n\", child, parent);\n#endif\n\t\t\tconst int _child = find(child), _parent = find(parent);\n\t\t\ta[_child] = _parent;\n\t\t}\n\n\t\tvoid cover(const int l, const int r, const int x, int *val) {\n#ifdef DBG\n\t\t\tprintf(\"cover(%d, %d, %d)\\n\", l, r, x);\n#endif\n\t\t\tfor (int i = find(l); i <= r; i = find(i + 1)) {\n\t\t\t\tval[i] = std::min(val[i], x);\n\t\t\t\tif (i != n - 1) merge(i, i + 1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t} sForawrd, sBackward;\n\n\tsForawrd.init(n);\n\tsBackward.init(n);\n\n\tfor (int i = 0; i < n; i++) forward[i] = backward[i] = INT_MAX;\n\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i + len < n; i += len) {\n\t\t\tconst int j = i + len;\n\t\t\tconst int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1;\n\t\t\t// const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1;\n#ifdef DBG\n\t\t\tprintf(\"s = %d, len = %d\\n\", s, len);\n#endif\n\t\t\tif (s >= len) {\n#ifdef DBG\n\t\t\t\tprintf(\"!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\\n\", i, j, a, b, len);\n#endif\n\t\t\t\tconst int l = i - a + 1, r = j + b - 1;\n\t\t\t\tsForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward);\n\t\t\t\tsBackward.cover(l + len * 2 - 1, r, len * 2, backward);\n\t\t\t\t// sForawrd->update(l, l + (r - (l + len * 2 - 1)), len * 2);\n\t\t\t\t// sBackward->update(l + len * 2 - 1, r, len * 2);\n\t\t\t\t/*\n\t\t\t\tfor (int i = l + len * 2 - 1; i <= r; i++) {\n\t\t\t\t\tprintf(\"[%d, %d]\\n\", i - len * 2 + 1, i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) forward[i] = sForawrd->query(i);\n\t// for (int i = 0; i < n; i++) backward[i] = sBackward->query(i);\n\n#ifdef DBG\n\tputs(\"forward / backward\");\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\n/*\nstruct ChairmanTree {\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint cnt, refCnt;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc && lc->unRef()) delete lc;\n\t\t\tif (rc && rc->unRef()) delete rc;\n\t\t}\n\n\t\tSegmentTree *ref() {\n\t\t\trefCnt++;\n\t\t\treturn this;\n\t\t}\n\n\t\tbool unRef() {\n\t\t\treturn !refCnt--;\n\t\t}\n\n\t\tint query(const int l, const int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\t\telse return (lc ? lc->query(l, r) : 0) + (rc ? rc->query(l, r) : 0);\n\t\t}\n\n\t\tSegmentTree *insertSelf(const int x) {\n\t\t\tif (l == r) return this;\n\t\t\tif (x <= mid) {\n\t\t\t\tthis->lc = (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x);\n\t\t\t} else {\n\t\t\t\tthis->rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tSegmentTree *insert(const int x) {\n\t\t\tif (x <= mid) {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\t\t} else {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x), cnt + 1);\n\t\t\t}\n\t\t}\n\n\t\tint lcount() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n, l, r;\n\n\tvoid clear() {\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tdelete root[i];\n\t\t}\n\t}\n\n\t// Build tree with array a, whose elements are limited in [l, r]\n\tvoid build(const int *a, const int n, const int l, const int r) {\n\t\tthis->n = n, this->l = l, this->r = r;\n\t\troot[0] = new SegmentTree(0, n, NULL, NULL, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, const int x) {\n\t\t// Adjust input [0, n - 1] to [1, n]\n\t\tSegmentTree *vr = root[r + 1], *vl = root[l];\n\t\tint ans = vr->query(this->l, x);\n\t\tif (vl) ans -= vl->query(this->l, x);\n\t\treturn ans;\n\n\t\t/ *\n\t\twhile (min != max) {\n\t\t\tconst int mid = mid + (max - min) / 2, t = vr->lcount() - (vl ? vl->lcount() : 0);\n\t\t\tif (t < k) {\n\t\t\t\tk -= t, vr = vr->rc;\n\t\t\t\tif (vl) vl = vl->rc;\n\t\t\t} else {\n\t\t\t\tvr = vr->lc;\n\t\t\t\tif (vl) vl = vl->lc;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t\t* /\n\t}\n} t;\n*/\n\ninline unsigned long long solve(const int *limit, const int *forward, const int n) {\n\tstatic struct Query {\n\t\tint type;\n\t\tint pos, val;\n\n\t\tbool operator<(const Query &other) const {\n\t\t\tif (pos < other.pos) return true;\n\t\t\telse if (pos == other.pos && !type && other.type) return true;\n\t\t\telse return false;\n\t\t}\n\t} Q[MAXN * 3];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[i].pos = i;\n\t\tQ[i].type = 0;\n\t\tQ[i].val = limit[i];\n\n#ifdef DBG\n\t\tprintf(\"add(pos = %d, val = %d)\\n\", Q[i].pos, Q[i].val);\n#endif\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[n + i].pos = i - 1;\n\t\tQ[n + i].val = i;\n\t\tQ[n + i].type = -1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i].pos, Q[n + i].val, Q[n + i].type);\n#endif\n\n\t\tQ[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1);\n\t\tQ[n + i + n].val = i;\n\t\tQ[n + i + n].type = 1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type);\n#endif\n\t}\n\n\tstd::sort(Q, Q + n * 3);\n\n\tstatic struct BinaryIndexedTree {\n\t\tint a[MAXN], n;\n\n\t\tstatic int lowbit(const int x) {\n\t\t\treturn x & -x;\n\t\t}\n\n\t\tvoid update(const int x, const int delta) {\n\t\t\t/*\n\t\t\ta[x - 1] += delta;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t\t}\n\n\t\tint query(const int x) {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t\t/*\n\t\t\tfor (int i = 1; i <= x; i++) ans += a[i - 1];\n\t\t\t*/\n\t\t\treturn ans;\n\t\t}\n\n\t\tvoid clear(const int x) {\n\t\t\t/*\n\t\t\ta[x - 1] = 0;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\t\tif (!a[i - 1]) break;\n\t\t\t\ta[i - 1] = 0;\n\t\t\t}\n\t\t}\n\t} bit;\n\n\tbit.n = n;\n\n\tunsigned long long ans = 0;\n\tfor (int i = 0; i < n * 3; i++) {\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].type, Q[i].pos, Q[i].val);\n#endif\n\t\tif (Q[i].type) {\n\t\t\tint t = bit.query(Q[i].val + 1) * Q[i].type;\n\t\t\tans += t;\n#ifdef DBG\n\t\t\tprintf(\"t = %d\\n\", t);\n#endif\n\t\t} else bit.update(Q[i].val + 1, 1);\n\t\t/*\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].l, Q[i].r, Q[i].val);\n#endif\n\t\tif (Q[i].l == -1) bit.update(Q[i].val + 1, 1);\n\t\telse ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l);\n#ifdef DBG\n\t\tprintf(\"ans = %d\\n\", ans);\n#endif\n\t\t*/\n\t}\n\n\tfor (int i = 0; i < n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1);\n\n\treturn ans;\n}\n\nint main() {\n\tint testcase;\n\tscanf(\"%d\", &testcase);\n\n\twhile (testcase--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsa1.build(s, n);\n\t\tstd::reverse(s, s + n);\n\t\tsa2.build(s, n);\n\n\t\tprepare(n);\n\t\tstatic int limit[MAXN];\n\t\tfor (int i = 0; i < n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2);\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", limit[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\n\t\t// t.clear();\n\t\t// t.build(limit, n, 0, n - 1);\n\n\t\t/*\n\t\tunsigned long long ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i);\n\t\t}\n\t\t*/\n\n\t\tunsigned long long ans = solve(limit, forward, n);\n\t\tprintf(\"%llu\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/hdu-5906.md","raw":"title: 「HDU 5906」Square Revolution - 后缀数组 + 并查集 + 树状数组\ncategories: OI\ntags: \n  - HDU\n  - Bestcoder\n  - 字符串\n  - 后缀数组\n  - 并查集\n  - 离线\n  - 树状数组\npermalink: hdu-5906\ndate: 2016-09-30 18:00:00\n---\n\n对于一个给定的字符串 $ S $，有多少连续子串是 prefix-suffix-square free 的。\n\n一个字符串被称为 square 当且仅当它可以由两个相同的串连接而成。例如，`abab`，`aa` 是 square，而 `aaa`，`abba` 不是。一个字符串是 prefix-suffix-square free 的当且仅当他的任何前缀或者后缀都不是 square。\n\n<!-- more -->\n\n### 链接\n[HDU 5906](http://acm.hdu.edu.cn/showproblem.php?pid=5906)\n\n### 题解\n求出从每个位置开始、结束的最短 square，进而求出从第 $ i $ 个位置结束的子串，其开始位置的最小值。设从第 $ i $ 个位置开始的最短 square 为 $ f(i) $，从第 $ i $ 个位置结束的子串，其开始位置的最小值为 $ g(i) $，则答案为对于每个 $ i $，在 $ j \\in [i, i + f(i) - 2] $ 内满足 $ i \\geq g(j) $ 的 $ j $ 的数量之和。\n\n考虑如何求 square：类似「NOI2016 优秀的拆分」一题，枚举 $ k $，枚举每个长度为 $ k $ 的区间，则所有长度为 $ 2k $ 的 square 都会跨越这个区间 $ [l, r] $，从端点分别向前、后求最长公共后缀、前缀。进而可以求出若干个 square。如，从 $ [L, R] $ 内一点开始，均有一个长度为 $ 2k $ 的 square，此时用 $ 2k $ 更新 $ f(i), i \\in[L, R] $。\n\n因为是从小到大枚举的 $ k $，所以每个位置只会被赋值一次，使用并查集维护所有赋值过的点，赋值过的点合并，之后直接跳过这些区间即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\tinline void build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tinline int rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n\n\tinline int lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint n, forward[MAXN], backward[MAXN];\n\ninline int lcp(const int i, const int j) { return sa1.lcp(i, j); }\ninline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); }\n\ninline void prepare(const int n) {\n\t/*\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int l, const int r, const int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) this->val = std::min(this->val, x);\n\t\t\telse lc->update(l, r, x), rc->update(l, r, x);\n\t\t}\n\n\t\tint query(const int pos) {\n\t\t\treturn (l == r) ? val : std::min(val, ((pos <= mid) ? lc : rc)->query(pos));\n\t\t}\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t\t}\n\t\t}\n\t} *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1);\n\t*/\n\n\tstatic struct UnionFindSet {\n\t\tint a[MAXN], n;\n\n\t\tvoid init(const int n) {\n\t\t\tthis->n = n;\n\t\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t\t}\n\n\t\tint find(const int x) {\n\t\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t\t}\n\n\t\tvoid merge(const int child, const int parent) {\n#ifdef DBG\n\t\t\tprintf(\"merge: %d => %d\\n\", child, parent);\n#endif\n\t\t\tconst int _child = find(child), _parent = find(parent);\n\t\t\ta[_child] = _parent;\n\t\t}\n\n\t\tvoid cover(const int l, const int r, const int x, int *val) {\n#ifdef DBG\n\t\t\tprintf(\"cover(%d, %d, %d)\\n\", l, r, x);\n#endif\n\t\t\tfor (int i = find(l); i <= r; i = find(i + 1)) {\n\t\t\t\tval[i] = std::min(val[i], x);\n\t\t\t\tif (i != n - 1) merge(i, i + 1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t} sForawrd, sBackward;\n\n\tsForawrd.init(n);\n\tsBackward.init(n);\n\n\tfor (int i = 0; i < n; i++) forward[i] = backward[i] = INT_MAX;\n\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i + len < n; i += len) {\n\t\t\tconst int j = i + len;\n\t\t\tconst int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1;\n\t\t\t// const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1;\n#ifdef DBG\n\t\t\tprintf(\"s = %d, len = %d\\n\", s, len);\n#endif\n\t\t\tif (s >= len) {\n#ifdef DBG\n\t\t\t\tprintf(\"!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\\n\", i, j, a, b, len);\n#endif\n\t\t\t\tconst int l = i - a + 1, r = j + b - 1;\n\t\t\t\tsForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward);\n\t\t\t\tsBackward.cover(l + len * 2 - 1, r, len * 2, backward);\n\t\t\t\t// sForawrd->update(l, l + (r - (l + len * 2 - 1)), len * 2);\n\t\t\t\t// sBackward->update(l + len * 2 - 1, r, len * 2);\n\t\t\t\t/*\n\t\t\t\tfor (int i = l + len * 2 - 1; i <= r; i++) {\n\t\t\t\t\tprintf(\"[%d, %d]\\n\", i - len * 2 + 1, i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) forward[i] = sForawrd->query(i);\n\t// for (int i = 0; i < n; i++) backward[i] = sBackward->query(i);\n\n#ifdef DBG\n\tputs(\"forward / backward\");\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\n/*\nstruct ChairmanTree {\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint cnt, refCnt;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc && lc->unRef()) delete lc;\n\t\t\tif (rc && rc->unRef()) delete rc;\n\t\t}\n\n\t\tSegmentTree *ref() {\n\t\t\trefCnt++;\n\t\t\treturn this;\n\t\t}\n\n\t\tbool unRef() {\n\t\t\treturn !refCnt--;\n\t\t}\n\n\t\tint query(const int l, const int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\t\telse return (lc ? lc->query(l, r) : 0) + (rc ? rc->query(l, r) : 0);\n\t\t}\n\n\t\tSegmentTree *insertSelf(const int x) {\n\t\t\tif (l == r) return this;\n\t\t\tif (x <= mid) {\n\t\t\t\tthis->lc = (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x);\n\t\t\t} else {\n\t\t\t\tthis->rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tSegmentTree *insert(const int x) {\n\t\t\tif (x <= mid) {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\t\t} else {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x), cnt + 1);\n\t\t\t}\n\t\t}\n\n\t\tint lcount() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n, l, r;\n\n\tvoid clear() {\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tdelete root[i];\n\t\t}\n\t}\n\n\t// Build tree with array a, whose elements are limited in [l, r]\n\tvoid build(const int *a, const int n, const int l, const int r) {\n\t\tthis->n = n, this->l = l, this->r = r;\n\t\troot[0] = new SegmentTree(0, n, NULL, NULL, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, const int x) {\n\t\t// Adjust input [0, n - 1] to [1, n]\n\t\tSegmentTree *vr = root[r + 1], *vl = root[l];\n\t\tint ans = vr->query(this->l, x);\n\t\tif (vl) ans -= vl->query(this->l, x);\n\t\treturn ans;\n\n\t\t/ *\n\t\twhile (min != max) {\n\t\t\tconst int mid = mid + (max - min) / 2, t = vr->lcount() - (vl ? vl->lcount() : 0);\n\t\t\tif (t < k) {\n\t\t\t\tk -= t, vr = vr->rc;\n\t\t\t\tif (vl) vl = vl->rc;\n\t\t\t} else {\n\t\t\t\tvr = vr->lc;\n\t\t\t\tif (vl) vl = vl->lc;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t\t* /\n\t}\n} t;\n*/\n\ninline unsigned long long solve(const int *limit, const int *forward, const int n) {\n\tstatic struct Query {\n\t\tint type;\n\t\tint pos, val;\n\n\t\tbool operator<(const Query &other) const {\n\t\t\tif (pos < other.pos) return true;\n\t\t\telse if (pos == other.pos && !type && other.type) return true;\n\t\t\telse return false;\n\t\t}\n\t} Q[MAXN * 3];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[i].pos = i;\n\t\tQ[i].type = 0;\n\t\tQ[i].val = limit[i];\n\n#ifdef DBG\n\t\tprintf(\"add(pos = %d, val = %d)\\n\", Q[i].pos, Q[i].val);\n#endif\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[n + i].pos = i - 1;\n\t\tQ[n + i].val = i;\n\t\tQ[n + i].type = -1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i].pos, Q[n + i].val, Q[n + i].type);\n#endif\n\n\t\tQ[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1);\n\t\tQ[n + i + n].val = i;\n\t\tQ[n + i + n].type = 1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type);\n#endif\n\t}\n\n\tstd::sort(Q, Q + n * 3);\n\n\tstatic struct BinaryIndexedTree {\n\t\tint a[MAXN], n;\n\n\t\tstatic int lowbit(const int x) {\n\t\t\treturn x & -x;\n\t\t}\n\n\t\tvoid update(const int x, const int delta) {\n\t\t\t/*\n\t\t\ta[x - 1] += delta;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t\t}\n\n\t\tint query(const int x) {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t\t/*\n\t\t\tfor (int i = 1; i <= x; i++) ans += a[i - 1];\n\t\t\t*/\n\t\t\treturn ans;\n\t\t}\n\n\t\tvoid clear(const int x) {\n\t\t\t/*\n\t\t\ta[x - 1] = 0;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\t\tif (!a[i - 1]) break;\n\t\t\t\ta[i - 1] = 0;\n\t\t\t}\n\t\t}\n\t} bit;\n\n\tbit.n = n;\n\n\tunsigned long long ans = 0;\n\tfor (int i = 0; i < n * 3; i++) {\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].type, Q[i].pos, Q[i].val);\n#endif\n\t\tif (Q[i].type) {\n\t\t\tint t = bit.query(Q[i].val + 1) * Q[i].type;\n\t\t\tans += t;\n#ifdef DBG\n\t\t\tprintf(\"t = %d\\n\", t);\n#endif\n\t\t} else bit.update(Q[i].val + 1, 1);\n\t\t/*\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].l, Q[i].r, Q[i].val);\n#endif\n\t\tif (Q[i].l == -1) bit.update(Q[i].val + 1, 1);\n\t\telse ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l);\n#ifdef DBG\n\t\tprintf(\"ans = %d\\n\", ans);\n#endif\n\t\t*/\n\t}\n\n\tfor (int i = 0; i < n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1);\n\n\treturn ans;\n}\n\nint main() {\n\tint testcase;\n\tscanf(\"%d\", &testcase);\n\n\twhile (testcase--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsa1.build(s, n);\n\t\tstd::reverse(s, s + n);\n\t\tsa2.build(s, n);\n\n\t\tprepare(n);\n\t\tstatic int limit[MAXN];\n\t\tfor (int i = 0; i < n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2);\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", limit[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\n\t\t// t.clear();\n\t\t// t.build(limit, n, 0, n - 1);\n\n\t\t/*\n\t\tunsigned long long ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i);\n\t\t}\n\t\t*/\n\n\t\tunsigned long long ans = solve(limit, forward, n);\n\t\tprintf(\"%llu\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"hdu-5906","published":1,"updated":"2016-09-30T10:00:52.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ry00116ooxl48j4l9aq"},{"title":"「HDU 5462」King's Order - 数位 DP","date":"2016-05-11T23:47:00.000Z","_content":"\n由于国王的口吃并没有治愈，所以传令中可能出现：“让第三军-军-军，到前线去”这样的命令。由于大洋国在军队中安插了间谍，战事紧急，很多时候前线的指挥官不能分清哪些命令真正来自国王。但国王的命令有一个特点，他每次连续重复的字符最多 $ 3 $ 次. 所以说他的命令中没有：“让第三军-军-军-军，到前线去”，但是可以有：“让第三军-军 ，到前线去”。\n\n此时将军找到了你，你需要告诉他，给定命令的长度长度为 $ n $，有多少种不同的命令可以是国王发出的。（也就是求长度为 $ n $ 的合格字符串的个数）当然，国王可能说出一句话没有犯任何口吃，就像他那次演讲一样。\n\n<!-- more -->\n\n### 链接\n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### 题解\n数位 DP，设\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n表示长度为 $ n $ 的字符串，最后四个字符中两两是否相等，最后一个字符是 $ lastChar $，状态转移时，枚举最后一个字符，如果三个标志位均为真，则状态非法，答案为零。\n\n每次不需要重新计算，利用之前计算过的值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5642.md","raw":"title: 「HDU 5462」King's Order - 数位 DP\ncategories: OI\ntags: \n  - HDU\n  - BestCoder\n  - 数位 DP\n  - DP\npermalink: hdu-5642\ndate: 2016-05-12 07:47:00\n---\n\n由于国王的口吃并没有治愈，所以传令中可能出现：“让第三军-军-军，到前线去”这样的命令。由于大洋国在军队中安插了间谍，战事紧急，很多时候前线的指挥官不能分清哪些命令真正来自国王。但国王的命令有一个特点，他每次连续重复的字符最多 $ 3 $ 次. 所以说他的命令中没有：“让第三军-军-军-军，到前线去”，但是可以有：“让第三军-军 ，到前线去”。\n\n此时将军找到了你，你需要告诉他，给定命令的长度长度为 $ n $，有多少种不同的命令可以是国王发出的。（也就是求长度为 $ n $ 的合格字符串的个数）当然，国王可能说出一句话没有犯任何口吃，就像他那次演讲一样。\n\n<!-- more -->\n\n### 链接\n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### 题解\n数位 DP，设\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n表示长度为 $ n $ 的字符串，最后四个字符中两两是否相等，最后一个字符是 $ lastChar $，状态转移时，枚举最后一个字符，如果三个标志位均为真，则状态非法，答案为零。\n\n每次不需要重新计算，利用之前计算过的值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5642","published":1,"updated":"2016-10-24T23:36:12.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ry8011hooxlyt6940cs"},{"title":"「HDU 632」Rikka with Array - 数位 DP","date":"2016-05-12T14:11:00.000Z","_content":"\n设 $ A(x) $ 表示 $ x $ 的二进制表示中 $ 1 $ 的数量，求满足 $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $ 的数对 $ [i, j] $ 的数量。\n\n<!-- more -->\n\n### 链接\n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### 题解\n数位 DP，设\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n表示二进制表示的最后 $ n $ 位，之前各位组成的数的差（$ j - i $）为 $ gap $，是否 $ i \\lt j $ 或 $ i = j $，$ i $、$ j $ 的之前所有位是否均达到上界的合法数对数量。\n\n转移时枚举 $ i $、$ j $ 的下一位分别是 $ 0 $ 或者 $ 1 $ 即可。\n\n注意，不需要考虑 $ i \\gt j $ 的情况，因为确定了二进制较高位满足一大一小后，较低位不会使其大小关系更改，即这种状态不可能合法。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5632.md","raw":"title: 「HDU 632」Rikka with Array - 数位 DP\ncategories: OI\ntags: \n  - HDU\n  - 数位 DP\n  - DP\npermalink: hdu-5632\ndate: 2016-05-12 22:11:00\n---\n\n设 $ A(x) $ 表示 $ x $ 的二进制表示中 $ 1 $ 的数量，求满足 $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $ 的数对 $ [i, j] $ 的数量。\n\n<!-- more -->\n\n### 链接\n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### 题解\n数位 DP，设\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n表示二进制表示的最后 $ n $ 位，之前各位组成的数的差（$ j - i $）为 $ gap $，是否 $ i \\lt j $ 或 $ i = j $，$ i $、$ j $ 的之前所有位是否均达到上界的合法数对数量。\n\n转移时枚举 $ i $、$ j $ 的下一位分别是 $ 0 $ 或者 $ 1 $ 即可。\n\n注意，不需要考虑 $ i \\gt j $ 的情况，因为确定了二进制较高位满足一大一小后，较低位不会使其大小关系更改，即这种状态不可能合法。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5632","published":1,"updated":"2016-10-24T23:36:02.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rye011oooxljwdrbzgj"},{"title":"「HDU 2089」不要 62 - 数位 DP","date":"2016-05-12T03:56:00.000Z","_content":"\n不吉利的数字为所有含有 $ 4 $ 或 $ 62 $ 的号码。例如：$ 62315,\\ 73418,\\ 88914 $ 都属于不吉利号码。但是，$ 61152 $ 虽然含有 $ 6 $ 和 $ 2 $，但不是 $ 62 $ 连号，所以不属于不吉利数字之列。\n\n你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\n\n<!-- more -->\n\n### 链接\n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### 题解\n数位 DP，设\n\n$$ f[n][last][flag] $$\n\n表示号码的最后 $ n $ 位，这 $ n $ 位的上一个字符是 $ last $，之前的字符是否全部紧贴上界，的总数量。\n\n每次枚举这 $ n $ 位的最高位，特判 $ 4 $，特判连续的 $ 62 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-2089.md","raw":"title: 「HDU 2089」不要 62 - 数位 DP\ncategories: OI\ntags: \n  - HDU\n  - 数位 DP\n  - DP\npermalink: hdu-2089\ndate: 2016-05-12 11:56:00\n---\n\n不吉利的数字为所有含有 $ 4 $ 或 $ 62 $ 的号码。例如：$ 62315,\\ 73418,\\ 88914 $ 都属于不吉利号码。但是，$ 61152 $ 虽然含有 $ 6 $ 和 $ 2 $，但不是 $ 62 $ 连号，所以不属于不吉利数字之列。\n\n你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\n\n<!-- more -->\n\n### 链接\n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### 题解\n数位 DP，设\n\n$$ f[n][last][flag] $$\n\n表示号码的最后 $ n $ 位，这 $ n $ 位的上一个字符是 $ last $，之前的字符是否全部紧贴上界，的总数量。\n\n每次枚举这 $ n $ 位的最高位，特判 $ 4 $，特判连续的 $ 62 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-2089","published":1,"updated":"2016-10-24T23:35:53.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ryj011tooxlqxng4x0m"},{"title":"「HAOI2016」食物链 - 拓扑排序 + DP","date":"2016-04-28T14:20:45.000Z","_content":"\n给 $ n $ 个物种和 $ m $ 条能量流动关系，求其中的食物链条数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### 题解\n题意中没有说清楚**食物链**的概念，根据样例可知，由生产者走向最高级消费者的简单路径，多条食物链可以有重叠。\n\n我们令边的方向为生产者到最高级消费者，对整张图进行拓扑排序，同时 DP 出从入度为零的点（生产者）到该点的路径条数（一定是简单路径）。\n\n所有出度为零（保证是最高级消费者）且原入度不为零（保证**不是**生产者，单独一个生产者没有消费者不算食物链）的点上的路径条数和即为食物链数量。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/haoi2016-chain.md","raw":"title: 「HAOI2016」食物链 - 拓扑排序 + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - 拓扑排序\n  - DP\npermalink: haoi2016-chain\ndate: 2016-04-28 22:20:45\n---\n\n给 $ n $ 个物种和 $ m $ 条能量流动关系，求其中的食物链条数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### 题解\n题意中没有说清楚**食物链**的概念，根据样例可知，由生产者走向最高级消费者的简单路径，多条食物链可以有重叠。\n\n我们令边的方向为生产者到最高级消费者，对整张图进行拓扑排序，同时 DP 出从入度为零的点（生产者）到该点的路径条数（一定是简单路径）。\n\n所有出度为零（保证是最高级消费者）且原入度不为零（保证**不是**生产者，单独一个生产者没有消费者不算食物链）的点上的路径条数和即为食物链数量。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"haoi2016-chain","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ryn011yooxl4lnh3tww"},{"title":"「HAOI2015」树上操作 - 树链剖分 + DFS序","date":"2016-04-03T14:32:45.000Z","_content":"\n有一棵点数为 $ N $ 的树，以点 $ 1 $ 为根，且树点有边权。然后有 $ M $ 个操作，分为三种：\n\n1. 把某个节点 $ x $ 的点权增加 $ a $。\n2. 把某个节点 $ x $ 为根的子树中所有点的点权都增加 $ a $。\n3. 询问某个节点 $ x $ 到根的路径中所有点的点权和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### 题解\n裸树剖 + DFS 序，注意要开 `long long`，要不然和暴力分一样 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2015-t2.md","raw":"title: 「HAOI2015」树上操作 - 树链剖分 + DFS序\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 树链剖分\n  - 线段树\n  - DFS 序\npermalink: haoi2015-t2\ndate: 2016-04-03 22:32:45\n---\n\n有一棵点数为 $ N $ 的树，以点 $ 1 $ 为根，且树点有边权。然后有 $ M $ 个操作，分为三种：\n\n1. 把某个节点 $ x $ 的点权增加 $ a $。\n2. 把某个节点 $ x $ 为根的子树中所有点的点权都增加 $ a $。\n3. 询问某个节点 $ x $ 到根的路径中所有点的点权和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### 题解\n裸树剖 + DFS 序，注意要开 `long long`，要不然和暴力分一样 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2015-t2","published":1,"updated":"2016-09-10T09:44:45.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ryt0126ooxlyqbk9q9y"},{"title":"「HAOI2011」Problem b - 莫比乌斯反演","date":"2016-04-08T03:32:33.000Z","_content":"\n对于给出的 $ n $ 个询问，每次求有多少个数对 $ (x, y) $，满足 $ a \\leq x \\leq b $，$ c \\leq y \\leq d $，且 $ \\gcd(x, y) = k $，$ \\gcd(x, y) $函数为 $ x $ 和 $ y $ 的最大公约数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### 题解\n问题为：求\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n设\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n根据容斥原理，答案即为\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n现在的问题就是求出 $ F $ 函数的值\n\n设\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n构造函数 $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n由莫比乌斯反演得\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n这时候我们已经可以暴力计算 $ F(n, m, k) $ 了\n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n但是这样的复杂度还是会超时的，我们考虑分块计算。\n\n注意到我们的代码中多次出现了形如 $ \\frac{n}{k} $ 的式子，考虑构造一个新函数 $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n此时的 $ F' $ 已经可以分块计算了，通过预处理 $ \\mu(T) $ 的前缀和，我们可以在 $ O(\\sqrt{n}) $ 的时间内回答一组询问。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2011-problemb.md","raw":"title: 「HAOI2011」Problem b - 莫比乌斯反演\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - 莫比乌斯反演\n  - 数论\n  - 数学\n  - 线性筛\npermalink: haoi2011-problemb\ndate: 2016-04-08 11:32:33\n---\n\n对于给出的 $ n $ 个询问，每次求有多少个数对 $ (x, y) $，满足 $ a \\leq x \\leq b $，$ c \\leq y \\leq d $，且 $ \\gcd(x, y) = k $，$ \\gcd(x, y) $函数为 $ x $ 和 $ y $ 的最大公约数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### 题解\n问题为：求\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n设\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n根据容斥原理，答案即为\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n现在的问题就是求出 $ F $ 函数的值\n\n设\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n构造函数 $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n由莫比乌斯反演得\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n这时候我们已经可以暴力计算 $ F(n, m, k) $ 了\n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n但是这样的复杂度还是会超时的，我们考虑分块计算。\n\n注意到我们的代码中多次出现了形如 $ \\frac{n}{k} $ 的式子，考虑构造一个新函数 $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n此时的 $ F' $ 已经可以分块计算了，通过预处理 $ \\mu(T) $ 的前缀和，我们可以在 $ O(\\sqrt{n}) $ 的时间内回答一组询问。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2011-problemb","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ryz012dooxlzzp4ojvx"},{"title":"「HAOI2008」木棍分割 - 二分 + DP","date":"2016-11-13T03:31:00.000Z","_content":"\n有 $ n $ 根木棍，第 $ i $ 根木棍的长度为 $ L_i $，$ n $ 根木棍依次连结了一起，总共有 $ n - 1 $ 个连接处。现在允许你最多砍断 $ m $ 个连接处，砍完后 $ n $ 根木棍被分成了很多段，要求满足总长度最大的一段长度最小，和有多少种砍的方法使得总长度最大的一段长度最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1044](http://www.lydsy.com/JudgeOnline/problem.php?id=1044)\n\n### 题解\n第一问，求最大一段长度最小，二分答案，设答案为 $ t $。\n\n第二问，求方案数，设 $ f(i, j) $ 表示前 $ i $ 根木棍，分成 $ j $ 段，最大长度不大于 $ t $ 的方案数。\n\n设前缀和 $ s(i) $ 为前 $ i $ 根木棍的和\n\n$$ f(i, j) = \\sum\\limits_{s(i) - s(k - 1) \\leq t} f(k - 1, j - 1)  $$\n\n显然，满足条件的 $ k $ 一定是紧贴着 $ i $ 的连续的一段，并且对于同一个 $ j $，最小的 $ k $ 是不降的。\n\n对 $ f(i, j - 1) $ 的 $ i $ 做前缀和，每次找到满足条件的 $ k $ 即可。\n\n需要滚动数组。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 1000;\nconst int MO = 10007;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\n\ninline bool check(int limit) {\n\tint k = m, s = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s + a[i] > limit) k--, s = a[i];\n\t\telse s += a[i];\n\t}\n\treturn k >= 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m), m++;\n\n\tint max = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), max = std::max(max, a[i]);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n\tint l = max, r = s[n];\n\twhile (r - l >= 5) {\n\t\tint mid = l + (r - l) / 2;\n\t\t// printf(\"[%d, %d, %d]\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tint ans;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (check(i)) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d \", ans);\n\n\tint tot = 0;\n\tstatic int f[MAXN + 1][2];\n\tfor (int i = 1; i <= n; i++) f[i][1] = s[i] <= ans ? 1 : 0;\n\tfor (int j = 2; j <= m; j++) {\n\t\tfor (int i = 1; i <= n; i++) (f[i][(j - 1) & 1] += f[i - 1][(j - 1) & 1]) %= MO;\n\t\tfor (int i = 1, k = j; i <= n; i++) {\n\t\t\tf[i][j & 1] = 0;\n\t\t\twhile (k <= i && s[i] - s[k - 1] > ans) k++;\n\t\t\tif (k <= i && s[i] - s[k - 1] <= ans) {\n\t\t\t\t// printf(\"f(%d, %d) += f([%d, %d], %d)\\n\", i, j, i - 1, k - 1, j - 1);\n\t\t\t\t(f[i][j & 1] += f[i - 1][(j - 1) & 1] - f[k - 2][(j - 1) & 1]) %= MO;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = j; k <= i; k++) {\n\t\t\t\tif (s[i] - s[k - 1] <= ans) {\n\t\t\t\t\tf[i][j] += f[k - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\t\t\t// f[i][j] += f[i - 1][j];\n\t\t}\n\t\t(tot += f[n][j & 1]) %= MO;\n\t}\n\n\t// for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\tprintf(\"%d\\n\", (tot + MO) % MO);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-stick.md","raw":"title: 「HAOI2008」木棍分割 - 二分 + DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 二分\n  - DP\npermalink: haoi2008-stick\ndate: 2016-11-13 11:31:00\n---\n\n有 $ n $ 根木棍，第 $ i $ 根木棍的长度为 $ L_i $，$ n $ 根木棍依次连结了一起，总共有 $ n - 1 $ 个连接处。现在允许你最多砍断 $ m $ 个连接处，砍完后 $ n $ 根木棍被分成了很多段，要求满足总长度最大的一段长度最小，和有多少种砍的方法使得总长度最大的一段长度最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1044](http://www.lydsy.com/JudgeOnline/problem.php?id=1044)\n\n### 题解\n第一问，求最大一段长度最小，二分答案，设答案为 $ t $。\n\n第二问，求方案数，设 $ f(i, j) $ 表示前 $ i $ 根木棍，分成 $ j $ 段，最大长度不大于 $ t $ 的方案数。\n\n设前缀和 $ s(i) $ 为前 $ i $ 根木棍的和\n\n$$ f(i, j) = \\sum\\limits_{s(i) - s(k - 1) \\leq t} f(k - 1, j - 1)  $$\n\n显然，满足条件的 $ k $ 一定是紧贴着 $ i $ 的连续的一段，并且对于同一个 $ j $，最小的 $ k $ 是不降的。\n\n对 $ f(i, j - 1) $ 的 $ i $ 做前缀和，每次找到满足条件的 $ k $ 即可。\n\n需要滚动数组。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 1000;\nconst int MO = 10007;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\n\ninline bool check(int limit) {\n\tint k = m, s = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s + a[i] > limit) k--, s = a[i];\n\t\telse s += a[i];\n\t}\n\treturn k >= 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m), m++;\n\n\tint max = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), max = std::max(max, a[i]);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n\tint l = max, r = s[n];\n\twhile (r - l >= 5) {\n\t\tint mid = l + (r - l) / 2;\n\t\t// printf(\"[%d, %d, %d]\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tint ans;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (check(i)) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d \", ans);\n\n\tint tot = 0;\n\tstatic int f[MAXN + 1][2];\n\tfor (int i = 1; i <= n; i++) f[i][1] = s[i] <= ans ? 1 : 0;\n\tfor (int j = 2; j <= m; j++) {\n\t\tfor (int i = 1; i <= n; i++) (f[i][(j - 1) & 1] += f[i - 1][(j - 1) & 1]) %= MO;\n\t\tfor (int i = 1, k = j; i <= n; i++) {\n\t\t\tf[i][j & 1] = 0;\n\t\t\twhile (k <= i && s[i] - s[k - 1] > ans) k++;\n\t\t\tif (k <= i && s[i] - s[k - 1] <= ans) {\n\t\t\t\t// printf(\"f(%d, %d) += f([%d, %d], %d)\\n\", i, j, i - 1, k - 1, j - 1);\n\t\t\t\t(f[i][j & 1] += f[i - 1][(j - 1) & 1] - f[k - 2][(j - 1) & 1]) %= MO;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = j; k <= i; k++) {\n\t\t\t\tif (s[i] - s[k - 1] <= ans) {\n\t\t\t\t\tf[i][j] += f[k - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\t\t\t// f[i][j] += f[i - 1][j];\n\t\t}\n\t\t(tot += f[n][j & 1]) %= MO;\n\t}\n\n\t// for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\tprintf(\"%d\\n\", (tot + MO) % MO);\n\n\treturn 0;\n}\n```","slug":"haoi2008-stick","published":1,"updated":"2016-11-13T03:31:51.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rz7012nooxlpm9o4mdc"},{"title":"「HAOI2008」排名系统 - map + Splay","date":"2016-12-13T09:08:00.000Z","_content":"\n排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $ 10 $ 条记录。对于得分相同的，上传时间早的排名高。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1056](http://www.lydsy.com/JudgeOnline/problem.php?id=1056)\n\n### 题解\n使用 Splay 存储每个用户的分数，查询记录时提取区间即可。使用 `map` 建立从用户名到 Splay 节点指针的关系。\n\n### 代码\n```c++\n#include <cstdio>\n// #include <cassert>\n#include <climits>\n#include <vector>\n#include <map>\n#include <iostream>\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *fa, **root;\n\t\tconst std::map<std::string, Node *>::iterator it;\n\t\tstd::pair<int, int> x;\n\t\tint size;\n\n\t\tNode(Node **root, Node *fa, const std::pair<int, int> &x, const std::map<std::string, Node *>::iterator it) : fa(fa), root(root), it(it), x(x), size(0) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tNode *o = fa;\n\t\t\tint x = relation();\n\t\t\t\n\t\t\tif (o->fa) o->fa->c[o->relation()] = this;\n\t\t\tfa = o->fa;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->fa = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!fa) *root = this;\n\t\t}\n\n\t\tNode *splay(Node *target = NULL) {\n\t\t\twhile (fa != target) {\n\t\t\t\tif (fa->fa == target) rotate();\n\t\t\t\telse if (relation() == fa->relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prev() {\n\t\t\tNode *v = splay()->c[0];\n\t\t\twhile (v->c[1]) v = v->c[1];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tNode *v = splay()->c[1];\n\t\t\twhile (v->c[0]) v = v->c[0];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[0] ? c[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay(const std::map<std::string, Node *>::iterator null) : root(NULL) {\n\t\tinsert(std::make_pair(INT_MIN, INT_MIN), null);\n\t\tinsert(std::make_pair(INT_MAX, INT_MAX), null);\n\t}\n\n\tNode *insert(const std::pair<int, int> &x, std::map<std::string, Node *>::iterator it) {\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v) {\n\t\t\tfa = *v;\n\t\t\tfa->size++;\n\t\t\tv = &fa->c[x > fa->x];\n\t\t}\n\t\t*v = new Node(&root, fa, x, it);\n\t\treturn (*v)->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tNode *l = v->prev(), *r = v->succ();\n\t\tr->splay();\n\t\tl->splay(r);\n\t\t// assert(v == l->c[1]);\n\t\tdelete v;\n\t\tl->c[1] = NULL;\n\t\tl->size--, r->size--;\n\t}\n\n\tNode *select(int k) {\n\t\tint x = k;\n\t\tNode *v = root;\n\t\twhile (v->rank() != x) {\n\t\t\tif (v->rank() > x) v = v->c[0];\n\t\t\telse x -= v->rank() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *prev = select(l - 1), *succ = select(r + 1);\n\t\tsucc->splay();\n\t\tprev->splay(succ);\n\t\treturn prev->c[1];\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nstd::map<std::string, Splay::Node *> map;\nSplay splay(map.end());\n\nvoid dfs(Splay::Node *v, std::vector<const std::string *> &vec) {\n\tif (!v) return;\n\tdfs(v->c[0], vec);\n\tif (v->it != map.end()) vec.push_back(&v->it->first);\n\tdfs(v->c[1], vec);\n}\n\ninline int parseInt(std::string s) {\n\tint x = 0;\n\tfor (std::string::iterator it = s.begin(); it != s.end(); it++) x = x * 10 + (*it - '0');\n\treturn x;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile (n--) {\n\t\tstd::string cmd;\n\t\tstd::cin >> cmd;\n\t\tif (cmd[0] == '+') {\n\t\t\tstd::string name = cmd.substr(1, cmd.length() - 1);\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tstd::map<std::string, Splay::Node *>::iterator it = map.find(name);\n\t\t\tif (it != map.end()) {\n\t\t\t\tsplay.erase(it->second);\n\t\t\t} else {\n\t\t\t\tit = map.insert(std::make_pair(name, static_cast<Splay::Node *>(NULL))).first;\n\t\t\t}\n\n\t\t\tit->second = splay.insert(std::make_pair(-x, -n), it);\n\t\t} else if (cmd[0] == '?') {\n\t\t\tstd::string arg = cmd.substr(1, cmd.length() - 1);\n\t\t\tif (arg[0] >= '0' && arg[0] <= '9') {\n\t\t\t\tint x = parseInt(arg);\n\t\t\t\tSplay::Node *v = splay.select(x, std::min(splay.size(), x + 10 - 1));\n\n\t\t\t\tstd::vector<const std::string *> vec;\n\t\t\t\tdfs(v, vec);\n\n\t\t\t\tfor (std::vector<const std::string *>::iterator it = vec.begin(); it != vec.end(); it++) std::cout << **it << (it == vec.end() - 1 ? '\\n' : ' ');\n\t\t\t} else {\n\t\t\t\tSplay::Node *v = map[arg];\n\t\t\t\tprintf(\"%d\\n\", v->splay()->rank());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-rank.md","raw":"title: 「HAOI2008」排名系统 - map + Splay\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - map\n  - Splay\n  - 数据结构\npermalink: haoi2008-rank\ndate: 2016-12-13 17:08:00\n---\n\n排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $ 10 $ 条记录。对于得分相同的，上传时间早的排名高。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1056](http://www.lydsy.com/JudgeOnline/problem.php?id=1056)\n\n### 题解\n使用 Splay 存储每个用户的分数，查询记录时提取区间即可。使用 `map` 建立从用户名到 Splay 节点指针的关系。\n\n### 代码\n```c++\n#include <cstdio>\n// #include <cassert>\n#include <climits>\n#include <vector>\n#include <map>\n#include <iostream>\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *fa, **root;\n\t\tconst std::map<std::string, Node *>::iterator it;\n\t\tstd::pair<int, int> x;\n\t\tint size;\n\n\t\tNode(Node **root, Node *fa, const std::pair<int, int> &x, const std::map<std::string, Node *>::iterator it) : fa(fa), root(root), it(it), x(x), size(0) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tNode *o = fa;\n\t\t\tint x = relation();\n\t\t\t\n\t\t\tif (o->fa) o->fa->c[o->relation()] = this;\n\t\t\tfa = o->fa;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->fa = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!fa) *root = this;\n\t\t}\n\n\t\tNode *splay(Node *target = NULL) {\n\t\t\twhile (fa != target) {\n\t\t\t\tif (fa->fa == target) rotate();\n\t\t\t\telse if (relation() == fa->relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prev() {\n\t\t\tNode *v = splay()->c[0];\n\t\t\twhile (v->c[1]) v = v->c[1];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tNode *v = splay()->c[1];\n\t\t\twhile (v->c[0]) v = v->c[0];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[0] ? c[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay(const std::map<std::string, Node *>::iterator null) : root(NULL) {\n\t\tinsert(std::make_pair(INT_MIN, INT_MIN), null);\n\t\tinsert(std::make_pair(INT_MAX, INT_MAX), null);\n\t}\n\n\tNode *insert(const std::pair<int, int> &x, std::map<std::string, Node *>::iterator it) {\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v) {\n\t\t\tfa = *v;\n\t\t\tfa->size++;\n\t\t\tv = &fa->c[x > fa->x];\n\t\t}\n\t\t*v = new Node(&root, fa, x, it);\n\t\treturn (*v)->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tNode *l = v->prev(), *r = v->succ();\n\t\tr->splay();\n\t\tl->splay(r);\n\t\t// assert(v == l->c[1]);\n\t\tdelete v;\n\t\tl->c[1] = NULL;\n\t\tl->size--, r->size--;\n\t}\n\n\tNode *select(int k) {\n\t\tint x = k;\n\t\tNode *v = root;\n\t\twhile (v->rank() != x) {\n\t\t\tif (v->rank() > x) v = v->c[0];\n\t\t\telse x -= v->rank() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *prev = select(l - 1), *succ = select(r + 1);\n\t\tsucc->splay();\n\t\tprev->splay(succ);\n\t\treturn prev->c[1];\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nstd::map<std::string, Splay::Node *> map;\nSplay splay(map.end());\n\nvoid dfs(Splay::Node *v, std::vector<const std::string *> &vec) {\n\tif (!v) return;\n\tdfs(v->c[0], vec);\n\tif (v->it != map.end()) vec.push_back(&v->it->first);\n\tdfs(v->c[1], vec);\n}\n\ninline int parseInt(std::string s) {\n\tint x = 0;\n\tfor (std::string::iterator it = s.begin(); it != s.end(); it++) x = x * 10 + (*it - '0');\n\treturn x;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile (n--) {\n\t\tstd::string cmd;\n\t\tstd::cin >> cmd;\n\t\tif (cmd[0] == '+') {\n\t\t\tstd::string name = cmd.substr(1, cmd.length() - 1);\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tstd::map<std::string, Splay::Node *>::iterator it = map.find(name);\n\t\t\tif (it != map.end()) {\n\t\t\t\tsplay.erase(it->second);\n\t\t\t} else {\n\t\t\t\tit = map.insert(std::make_pair(name, static_cast<Splay::Node *>(NULL))).first;\n\t\t\t}\n\n\t\t\tit->second = splay.insert(std::make_pair(-x, -n), it);\n\t\t} else if (cmd[0] == '?') {\n\t\t\tstd::string arg = cmd.substr(1, cmd.length() - 1);\n\t\t\tif (arg[0] >= '0' && arg[0] <= '9') {\n\t\t\t\tint x = parseInt(arg);\n\t\t\t\tSplay::Node *v = splay.select(x, std::min(splay.size(), x + 10 - 1));\n\n\t\t\t\tstd::vector<const std::string *> vec;\n\t\t\t\tdfs(v, vec);\n\n\t\t\t\tfor (std::vector<const std::string *>::iterator it = vec.begin(); it != vec.end(); it++) std::cout << **it << (it == vec.end() - 1 ? '\\n' : ' ');\n\t\t\t} else {\n\t\t\t\tSplay::Node *v = map[arg];\n\t\t\t\tprintf(\"%d\\n\", v->splay()->rank());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"haoi2008-rank","published":1,"updated":"2016-12-13T09:08:05.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rzc012tooxlsxa4uvxb"},{"title":"「HAOI2008」玩具取名 - 区间 DP","date":"2016-07-06T03:37:00.000Z","_content":"\n某人有一套玩具，并想法给玩具命名。首先他选择 `WING` 四个字母中的任意一个字母作为玩具的基本名字。然后他会根据自己的喜好，将名字中任意一个字母用 `WING` 中任意两个字母代替，使得自己的名字能够扩充得很长。\n\n现在，他想请你猜猜某一个很长的名字，最初可能是由哪几个字母变形过来的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1055](http://www.lydsy.com/JudgeOnline/problem.php?id=1055)\n\n### 题解\n用四个二进制位表示一个名字可能由哪些字母变形而来。设 $ f(l, r) $ 表示 $ [l, r] $ 这段区间能由哪些字母变形而来。枚举断点，并枚举左右区间可能由哪些字母变形而来，推出整个区间的答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 200;\nconst int K = 4;\n\nint n, a[MAXN];\nbool map[K][K][K];\n\ninline int id(const char ch) {\n\tswitch (ch) {\n\t\tcase 'W': return 0;\n\t\tcase 'I': return 1;\n\t\tcase 'N': return 2;\n\t\tcase 'G': return 3;\n\t\tdefault: return -1;\n\t}\n}\n\ninline char letter(const int x) {\n\treturn (\"WING\")[x];\n}\n\ninline void setMap(const int x, const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tmap[id(s[0])][id(s[1])][x] = true;\n\t}\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tstatic bool calced[MAXN][MAXN];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1 << a[l];\n\n\tfor (int i = l; i < r; i++) {\n\t\tconst int a = dp(l, i), b = dp(i + 1, r);\n\n\t\tfor (int i = 0; i < K; i++) if (a & (1 << i)) for (int j = 0; j < K; j++) if (b & (1 << j)) {\n\t\t\tfor (int k = 0; k < K; k++) if (map[i][j][k]) ans |= 1 << k;\n\t\t}\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\treturn ans;\n}\n\nint main() {\n\tint cnt[K];\n\tfor (int i = 0; i < K; i++) scanf(\"%d\", &cnt[i]);\n\tfor (int i = 0; i < K; i++) setMap(i, cnt[i]);\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = id(s[i]);\n\n\tint res = dp(0, n - 1);\n\tbool flag = false;\n\tfor (int i = 0; i < K; i++) if (res & (1 << i)) putchar(letter(i)), flag = true;\n\n\tif (flag) putchar('\\n');\n\telse puts(\"The name is wrong!\");\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2008-name.md","raw":"title: 「HAOI2008」玩具取名 - 区间 DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  - 区间 DP\npermalink: haoi2008-name\ndate: 2016-07-06 11:37:00\n---\n\n某人有一套玩具，并想法给玩具命名。首先他选择 `WING` 四个字母中的任意一个字母作为玩具的基本名字。然后他会根据自己的喜好，将名字中任意一个字母用 `WING` 中任意两个字母代替，使得自己的名字能够扩充得很长。\n\n现在，他想请你猜猜某一个很长的名字，最初可能是由哪几个字母变形过来的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1055](http://www.lydsy.com/JudgeOnline/problem.php?id=1055)\n\n### 题解\n用四个二进制位表示一个名字可能由哪些字母变形而来。设 $ f(l, r) $ 表示 $ [l, r] $ 这段区间能由哪些字母变形而来。枚举断点，并枚举左右区间可能由哪些字母变形而来，推出整个区间的答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 200;\nconst int K = 4;\n\nint n, a[MAXN];\nbool map[K][K][K];\n\ninline int id(const char ch) {\n\tswitch (ch) {\n\t\tcase 'W': return 0;\n\t\tcase 'I': return 1;\n\t\tcase 'N': return 2;\n\t\tcase 'G': return 3;\n\t\tdefault: return -1;\n\t}\n}\n\ninline char letter(const int x) {\n\treturn (\"WING\")[x];\n}\n\ninline void setMap(const int x, const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tmap[id(s[0])][id(s[1])][x] = true;\n\t}\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tstatic bool calced[MAXN][MAXN];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1 << a[l];\n\n\tfor (int i = l; i < r; i++) {\n\t\tconst int a = dp(l, i), b = dp(i + 1, r);\n\n\t\tfor (int i = 0; i < K; i++) if (a & (1 << i)) for (int j = 0; j < K; j++) if (b & (1 << j)) {\n\t\t\tfor (int k = 0; k < K; k++) if (map[i][j][k]) ans |= 1 << k;\n\t\t}\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\treturn ans;\n}\n\nint main() {\n\tint cnt[K];\n\tfor (int i = 0; i < K; i++) scanf(\"%d\", &cnt[i]);\n\tfor (int i = 0; i < K; i++) setMap(i, cnt[i]);\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = id(s[i]);\n\n\tint res = dp(0, n - 1);\n\tbool flag = false;\n\tfor (int i = 0; i < K; i++) if (res & (1 << i)) putchar(letter(i)), flag = true;\n\n\tif (flag) putchar('\\n');\n\telse puts(\"The name is wrong!\");\n\n\treturn 0;\n}\n```\n","slug":"haoi2008-name","published":1,"updated":"2016-10-24T23:35:44.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rzi0130ooxlwf551u6z"},{"title":"「HAOI2008」移动玩具 - 状态压缩 + BFS","date":"2016-12-13T09:01:00.000Z","_content":"\n在一个 $ 4 \\times 4 $ 的方框内摆放了若干个相同的玩具，要将这些玩具重新摆放成为理想的状态，规定移动时只能将玩具向上下左右四个方向移动，并且移动到的位置不能有玩具，求最小移动次数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1054](http://www.lydsy.com/JudgeOnline/problem.php?id=1054)\n\n### 题解\n将所有 $ 16 $ 个方框的状态存入一个整数的二进制位中，BFS 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 16;\n\ninline unsigned int read() {\n\tunsigned int res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tchar s[4 + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[j] == '1') res |= (1 << (4 * i + j));\n\t\t}\n\t}\n\treturn res;\n}\n\ninline int bfs(unsigned int s, unsigned int t) {\n\tstatic int dist[1 << MAXN];\n\tfor (int i = 0; i < (1 << MAXN); i++) dist[i] = INT_MAX;\n\n\tstd::queue<unsigned int> q;\n\tdist[s] = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tunsigned int v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return dist[v];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint a = 4 * i + j;\n\t\t\t\tunsigned int va = !!(v & (1 << a));\n\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tint b = 4 * (i + 1) + j;\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j != 3) {\n\t\t\t\t\tint b = 4 * i + (j + 1);\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tunsigned int s = read(), t = read();\n\tprintf(\"%d\\n\", bfs(s, t));\n\treturn 0;\n}\n```\n","source":"_posts/haoi2008-move.md","raw":"title: 「HAOI2008」移动玩具 - 状态压缩 + BFS\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 状态压缩\n  - BFS\npermalink: haoi2008-move\ndate: 2016-12-13 17:01:00\n---\n\n在一个 $ 4 \\times 4 $ 的方框内摆放了若干个相同的玩具，要将这些玩具重新摆放成为理想的状态，规定移动时只能将玩具向上下左右四个方向移动，并且移动到的位置不能有玩具，求最小移动次数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1054](http://www.lydsy.com/JudgeOnline/problem.php?id=1054)\n\n### 题解\n将所有 $ 16 $ 个方框的状态存入一个整数的二进制位中，BFS 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 16;\n\ninline unsigned int read() {\n\tunsigned int res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tchar s[4 + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[j] == '1') res |= (1 << (4 * i + j));\n\t\t}\n\t}\n\treturn res;\n}\n\ninline int bfs(unsigned int s, unsigned int t) {\n\tstatic int dist[1 << MAXN];\n\tfor (int i = 0; i < (1 << MAXN); i++) dist[i] = INT_MAX;\n\n\tstd::queue<unsigned int> q;\n\tdist[s] = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tunsigned int v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return dist[v];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint a = 4 * i + j;\n\t\t\t\tunsigned int va = !!(v & (1 << a));\n\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tint b = 4 * (i + 1) + j;\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j != 3) {\n\t\t\t\t\tint b = 4 * i + (j + 1);\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tunsigned int s = read(), t = read();\n\tprintf(\"%d\\n\", bfs(s, t));\n\treturn 0;\n}\n```\n","slug":"haoi2008-move","published":1,"updated":"2016-12-13T09:08:17.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rzp0136ooxl1yz71ohq"},{"title":"「HAOI2008」硬币购物 - 背包 DP + 容斥原理","date":"2016-11-13T03:11:00.000Z","_content":"\n一共有 $ 4 $ 种硬币。面值分别为 $ c_1, c_2, c_3, c_4 $。某人去商店买东西，去了 $ n $ 次。每次带 $ d_i $ 枚 $ c_i $ 硬币，买 $ s_i $ 的价格的东西。请问每次有多少种付款方法？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1042](http://www.lydsy.com/JudgeOnline/problem.php?id=1042)\n\n### 题解\n首先，求出不限制使用次数，购买价值为 $ c $ 时的方案数，设它为 $ f(c) $。\n\n对于每次询问，我们可以用不限制使用次数，购买价值 $ s_i $ 的方案数，减去任意一种硬币超过限制的方案数。任意一种硬币超过限制的方案数可以使用容斥原理求出，即 —— 每一种硬币超过限制的方案数之和 - 每两种硬币超过限制的方案数之和 + 每三种硬币超过限制的方案数之和 - 四种硬币全部超过限制的方案数。\n\n考虑如何求出第 $ i $ 种硬币超过限制的方案数 —— 我们至少要使用 $ d_i + 1 $ 个第 $ i $ 种硬币，剩余的 $ s - (d_i + 1) \\times c_i $ 元可以任意选择，即 $ f(s - (d_i + 1) \\times c_i) $。多种硬币同理。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MAXM = 100000;\n\nint main() {\n\tint c[4 + 1], n;\n\tscanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &n);\n\n\tstatic long long f[4 + 1][MAXM + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < c[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n\t\t}\n\t}\n\n\twhile (n--) {\n\t\tint d[4 + 1], m;\n\t\tscanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &m);\n\n\t\tlong long ans = f[4][m];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tif (m - (d[i] + 1) * c[i] >= 0) ans -= f[4][m - (d[i] + 1) * c[i]];\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] >= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tfor (int k = j + 1; k <= 4; k++) {\n\t\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] >= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] >= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-coins.md","raw":"title: 「HAOI2008」硬币购物 - 背包 DP + 容斥原理\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 数学\n  - DP\n  - 背包 DP\n  - 容斥原理\npermalink: haoi2008-coins\ndate: 2016-11-13 11:11:00\n---\n\n一共有 $ 4 $ 种硬币。面值分别为 $ c_1, c_2, c_3, c_4 $。某人去商店买东西，去了 $ n $ 次。每次带 $ d_i $ 枚 $ c_i $ 硬币，买 $ s_i $ 的价格的东西。请问每次有多少种付款方法？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1042](http://www.lydsy.com/JudgeOnline/problem.php?id=1042)\n\n### 题解\n首先，求出不限制使用次数，购买价值为 $ c $ 时的方案数，设它为 $ f(c) $。\n\n对于每次询问，我们可以用不限制使用次数，购买价值 $ s_i $ 的方案数，减去任意一种硬币超过限制的方案数。任意一种硬币超过限制的方案数可以使用容斥原理求出，即 —— 每一种硬币超过限制的方案数之和 - 每两种硬币超过限制的方案数之和 + 每三种硬币超过限制的方案数之和 - 四种硬币全部超过限制的方案数。\n\n考虑如何求出第 $ i $ 种硬币超过限制的方案数 —— 我们至少要使用 $ d_i + 1 $ 个第 $ i $ 种硬币，剩余的 $ s - (d_i + 1) \\times c_i $ 元可以任意选择，即 $ f(s - (d_i + 1) \\times c_i) $。多种硬币同理。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MAXM = 100000;\n\nint main() {\n\tint c[4 + 1], n;\n\tscanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &n);\n\n\tstatic long long f[4 + 1][MAXM + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < c[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n\t\t}\n\t}\n\n\twhile (n--) {\n\t\tint d[4 + 1], m;\n\t\tscanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &m);\n\n\t\tlong long ans = f[4][m];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tif (m - (d[i] + 1) * c[i] >= 0) ans -= f[4][m - (d[i] + 1) * c[i]];\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] >= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tfor (int k = j + 1; k <= 4; k++) {\n\t\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] >= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] >= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"haoi2008-coins","published":1,"updated":"2016-11-13T03:11:42.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rzu013cooxlvok6je2x"},{"title":"「HAOI2008」圆上的整点 - 数学","date":"2016-11-13T02:56:00.000Z","_content":"\n求一个给定的圆 $ x ^ 2 + y ^ 2 = r ^ 2 $，在圆周上有多少个点的坐标是整数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1041](http://www.lydsy.com/JudgeOnline/problem.php?id=1041)\n\n### 题解\n$$\n\\begin{aligned}\nx ^ 2 + y ^ 2 &= r ^ 2 \\\\\ny ^ 2 &= r ^ 2 - x ^ 2 \\\\\ny ^ 2 &= (r + x) \\times (r - x)\n\\end{aligned}\n$$\n\n设 $ d = \\gcd(r + x, r - x) $，$ a = \\frac{r - x}{d} $，$ b = \\frac{r + x}{d} $，必有 $ \\gcd(a, b) = 1 $。\n\n$$\n\\begin{aligned}\ny ^ 2 &= (r + x) \\times (r - x) \\\\\n&= d ^ 2 \\times a \\times b\n\\end{aligned}\n$$\n\n$ d ^ 2 $ 和 $ y ^ 2 $ 是完全平方数，所以 $ a \\times b $ 是完全平方数；又因为 $ \\gcd(a, b) = 1 $，所以 $ a $ 和 $ b $ 分别是完全平方数。\n\n$$\n\\begin{aligned}\na + b &= \\frac{r - x}{d} + \\frac{r + x}{d} \\\\\na + b &= \\frac{2r}{d}\n\\end{aligned}\n$$\n\n即，每一个整点都对应了一组 $ \\{ a, b, d \\} $，满足 $ a $ 和 $ b $ 是完全平方数，且 $ d $ 是 $ 2r $ 的约数。\n\n枚举 $ d $，枚举 $ \\sqrt a $，求出 $ b $，判断 $ \\gcd(a, b) = 1 $ 即可。\n\n这样求出的是第一象限的整点数量，设它为 $ k $，则答案为 $ 4k + 4 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 2e9;\nconst double EPS = 1e-6;\n\nint main() {\n\tlong long r;\n\tscanf(\"%lld\", &r);\n\n\t// 2 * r = d * (a ^ 2 + b ^ 2)\n\tlong long cnt = 0;\n\tfor (long long i = 1; i * i <= r * 2; i++) {\n\t\tif (2 * r % i != 0) continue;\n\n\t\tlong long d = i;\n\t\tlong long t = 2 * r / i;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (long long a = 1; a * a < t / 2; a++) {\n\t\t\t\tdouble b = sqrt(t - a * a);\n\t\t\t\tlong long _b = static_cast<long long>(b);\n\t\t\t\tif (fabs(b - _b) <= EPS && std::__gcd(a, _b) == 1) {\n\t\t\t\t\t// printf(\"d = %lld, a = %lld, b = %lld\\n\", d, a, _b);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != d) std::swap(t, d);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", cnt * 4 + 4);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-cir.md","raw":"title: 「HAOI2008」圆上的整点 - 数学\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 数学\npermalink: haoi2008-cir\ndate: 2016-11-13 10:56:00\n---\n\n求一个给定的圆 $ x ^ 2 + y ^ 2 = r ^ 2 $，在圆周上有多少个点的坐标是整数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1041](http://www.lydsy.com/JudgeOnline/problem.php?id=1041)\n\n### 题解\n$$\n\\begin{aligned}\nx ^ 2 + y ^ 2 &= r ^ 2 \\\\\ny ^ 2 &= r ^ 2 - x ^ 2 \\\\\ny ^ 2 &= (r + x) \\times (r - x)\n\\end{aligned}\n$$\n\n设 $ d = \\gcd(r + x, r - x) $，$ a = \\frac{r - x}{d} $，$ b = \\frac{r + x}{d} $，必有 $ \\gcd(a, b) = 1 $。\n\n$$\n\\begin{aligned}\ny ^ 2 &= (r + x) \\times (r - x) \\\\\n&= d ^ 2 \\times a \\times b\n\\end{aligned}\n$$\n\n$ d ^ 2 $ 和 $ y ^ 2 $ 是完全平方数，所以 $ a \\times b $ 是完全平方数；又因为 $ \\gcd(a, b) = 1 $，所以 $ a $ 和 $ b $ 分别是完全平方数。\n\n$$\n\\begin{aligned}\na + b &= \\frac{r - x}{d} + \\frac{r + x}{d} \\\\\na + b &= \\frac{2r}{d}\n\\end{aligned}\n$$\n\n即，每一个整点都对应了一组 $ \\{ a, b, d \\} $，满足 $ a $ 和 $ b $ 是完全平方数，且 $ d $ 是 $ 2r $ 的约数。\n\n枚举 $ d $，枚举 $ \\sqrt a $，求出 $ b $，判断 $ \\gcd(a, b) = 1 $ 即可。\n\n这样求出的是第一象限的整点数量，设它为 $ k $，则答案为 $ 4k + 4 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 2e9;\nconst double EPS = 1e-6;\n\nint main() {\n\tlong long r;\n\tscanf(\"%lld\", &r);\n\n\t// 2 * r = d * (a ^ 2 + b ^ 2)\n\tlong long cnt = 0;\n\tfor (long long i = 1; i * i <= r * 2; i++) {\n\t\tif (2 * r % i != 0) continue;\n\n\t\tlong long d = i;\n\t\tlong long t = 2 * r / i;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (long long a = 1; a * a < t / 2; a++) {\n\t\t\t\tdouble b = sqrt(t - a * a);\n\t\t\t\tlong long _b = static_cast<long long>(b);\n\t\t\t\tif (fabs(b - _b) <= EPS && std::__gcd(a, _b) == 1) {\n\t\t\t\t\t// printf(\"d = %lld, a = %lld, b = %lld\\n\", d, a, _b);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != d) std::swap(t, d);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", cnt * 4 + 4);\n\n\treturn 0;\n}\n```","slug":"haoi2008-cir","published":1,"updated":"2016-11-13T02:56:51.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s01013kooxlpt7nhhab"},{"title":"「HAOI2008」糖果传递 - 数学","date":"2016-11-13T03:45:00.000Z","_content":"\n有 $ n $ 个小朋友坐成一圈，每人有 $ a_i $ 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 $ 1 $。求使所有人获得均等糖果的最小代价。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1045](http://www.lydsy.com/JudgeOnline/problem.php?id=1045)\n\n### 题解\n设 $ v = \\frac{\\sum\\limits_{i = 1} ^ n a_i}{n} $，$ x_1 $ 表示第 $ i - 1 $ 个人给第 $ i $ 个人的数量，则有\n\n$$\n\\begin{aligned}\nv &= a_i + x_i - x_{i - 1} \\\\\nx_{i + 1} &= x_i - v + a_i\n\\end{aligned}\n$$\n\n即\n\n$$\n\\begin{aligned}\nx_2 &= x_1 - v + a_1 \\\\\nx_3 &= x_2 - v + a_2 \\\\\n    &= x_1 - v + a_1 - v + a_2 \\\\\nx_4 &= x_3 - v + a_3 \\\\\n    &= x_1 - v + a_1 - v + a_2 - v + a_3\n\\end{aligned}\n$$\n\n我们的目标是最小化 $ \\sum\\limits_{i = 1} ^ n | x_i | $。\n\n设 $ c_0 = 0, c_i = c_{i - 1} + v - a_i $，则\n\n$$\n\\begin{aligned}\nx_1 &= x_1 - c_0 \\\\\nx_2 &= x_1 - c_1 \\\\\nx_3 &= x_1 - c_2 \\\\\nx_4 &= x_1 - c_3\n\\end{aligned}\n$$\n\n即，最小化\n\n$$ \\sum\\limits_{i = 1} ^ n | x_1 - c_{i - 1} | $$\n\n问题转化为，在数轴上找一个点，到给定一些点的距离之和最小。答案即为 $ c_i $ 的中位数。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic long long a[MAXN];\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tlong long avg = sum / n;\n\tstatic long long c[MAXN];\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i++) c[i] = c[i - 1] - a[i] + avg;\n\n\tstd::sort(c, c + n);\n\n\tlong long mid = c[n / 2], ans = 0;\n\tfor (int i = 0; i < n; i++) ans += llabs(c[i] - mid);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-candy.md","raw":"title: 「HAOI2008」糖果传递 - 数学\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 数学\npermalink: haoi2008-candy\ndate: 2016-11-13 11:45:00\n---\n\n有 $ n $ 个小朋友坐成一圈，每人有 $ a_i $ 个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为 $ 1 $。求使所有人获得均等糖果的最小代价。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1045](http://www.lydsy.com/JudgeOnline/problem.php?id=1045)\n\n### 题解\n设 $ v = \\frac{\\sum\\limits_{i = 1} ^ n a_i}{n} $，$ x_1 $ 表示第 $ i - 1 $ 个人给第 $ i $ 个人的数量，则有\n\n$$\n\\begin{aligned}\nv &= a_i + x_i - x_{i - 1} \\\\\nx_{i + 1} &= x_i - v + a_i\n\\end{aligned}\n$$\n\n即\n\n$$\n\\begin{aligned}\nx_2 &= x_1 - v + a_1 \\\\\nx_3 &= x_2 - v + a_2 \\\\\n    &= x_1 - v + a_1 - v + a_2 \\\\\nx_4 &= x_3 - v + a_3 \\\\\n    &= x_1 - v + a_1 - v + a_2 - v + a_3\n\\end{aligned}\n$$\n\n我们的目标是最小化 $ \\sum\\limits_{i = 1} ^ n | x_i | $。\n\n设 $ c_0 = 0, c_i = c_{i - 1} + v - a_i $，则\n\n$$\n\\begin{aligned}\nx_1 &= x_1 - c_0 \\\\\nx_2 &= x_1 - c_1 \\\\\nx_3 &= x_1 - c_2 \\\\\nx_4 &= x_1 - c_3\n\\end{aligned}\n$$\n\n即，最小化\n\n$$ \\sum\\limits_{i = 1} ^ n | x_1 - c_{i - 1} | $$\n\n问题转化为，在数轴上找一个点，到给定一些点的距离之和最小。答案即为 $ c_i $ 的中位数。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic long long a[MAXN];\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tlong long avg = sum / n;\n\tstatic long long c[MAXN];\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i++) c[i] = c[i - 1] - a[i] + avg;\n\n\tstd::sort(c, c + n);\n\n\tlong long mid = c[n / 2], ans = 0;\n\tfor (int i = 0; i < n; i++) ans += llabs(c[i] - mid);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2008-candy","published":1,"updated":"2016-11-13T07:24:37.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s06013pooxll1sqek1m"},{"title":"「HAOI2007」理想的正方形 - 单调队列","date":"2016-12-01T23:16:00.000Z","_content":"\n有一个 $ n \\times m $ 的整数组成的矩阵，现请你从中找出一个 $ k \\times k $ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047)\n\n### 题解\n对每一行应用单调队列，求出 $ b(i, j) = \\max\\limits_{t = j - k + 1} ^ j a(i, t) $（即每个数向左 $ k $ 个数以内的最大值）。对每一列应用单调队列，求出 $ c(i, j) = \\max\\limits_{t = i - k + 1} ^ i b(t, j) $（即每个数向上 $ k $ 个数以内的最大值）。两次操作的结果是每个数向上 $ k $ 个数以内的每个数向左 $ k $ 个数以内的最大值，即一个 $ k \\times k $ 的正方形的最大值。\n\n用相同的方法求出最小值，枚举每个 $ k \\times k $ 的正方形，即可得到答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 1000;\n\nint n, m, k, a[MAXN + 1][MAXN + 1];\n\ntemplate <typename T>\ninline void workColumns(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[i][j], a[i][*r])) r--;\n\t\t\t*++r = j;\n\t\t\tb[i][j] = a[i][*l];\n#ifdef DBG\n\t\t\tprintf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n\t\t}\n\t}\n}\n\ntemplate <typename T>\ninline void workRows(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[j][i], a[*r][i])) r--;\n\t\t\t*++r = j;\n\t\t\tb[j][i] = a[*l][i];\n\t\t}\n\t}\n#ifdef DBG\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tstatic int columnMax[MAXN + 1][MAXN + 1], rowMax[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMax, std::greater<int>());\n\tworkRows(columnMax, rowMax, std::greater<int>());\n\n\tstatic int columnMin[MAXN + 1][MAXN + 1], rowMin[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMin, std::less<int>());\n\tworkRows(columnMin, rowMin, std::less<int>());\n\n\tint ans = INT_MAX;\n\tfor (int i = k; i <= n; i++) for (int j = k; j <= m; j++) ans = std::min(ans, rowMax[i][j] - rowMin[i][j]);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-square.md","raw":"title: 「HAOI2007」理想的正方形 - 单调队列\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 单调队列\npermalink: haoi2007-square\ndate: 2016-12-02 07:16:00\n---\n\n有一个 $ n \\times m $ 的整数组成的矩阵，现请你从中找出一个 $ k \\times k $ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047)\n\n### 题解\n对每一行应用单调队列，求出 $ b(i, j) = \\max\\limits_{t = j - k + 1} ^ j a(i, t) $（即每个数向左 $ k $ 个数以内的最大值）。对每一列应用单调队列，求出 $ c(i, j) = \\max\\limits_{t = i - k + 1} ^ i b(t, j) $（即每个数向上 $ k $ 个数以内的最大值）。两次操作的结果是每个数向上 $ k $ 个数以内的每个数向左 $ k $ 个数以内的最大值，即一个 $ k \\times k $ 的正方形的最大值。\n\n用相同的方法求出最小值，枚举每个 $ k \\times k $ 的正方形，即可得到答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 1000;\n\nint n, m, k, a[MAXN + 1][MAXN + 1];\n\ntemplate <typename T>\ninline void workColumns(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[i][j], a[i][*r])) r--;\n\t\t\t*++r = j;\n\t\t\tb[i][j] = a[i][*l];\n#ifdef DBG\n\t\t\tprintf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n\t\t}\n\t}\n}\n\ntemplate <typename T>\ninline void workRows(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[j][i], a[*r][i])) r--;\n\t\t\t*++r = j;\n\t\t\tb[j][i] = a[*l][i];\n\t\t}\n\t}\n#ifdef DBG\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tstatic int columnMax[MAXN + 1][MAXN + 1], rowMax[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMax, std::greater<int>());\n\tworkRows(columnMax, rowMax, std::greater<int>());\n\n\tstatic int columnMin[MAXN + 1][MAXN + 1], rowMin[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMin, std::less<int>());\n\tworkRows(columnMin, rowMin, std::less<int>());\n\n\tint ans = INT_MAX;\n\tfor (int i = k; i <= n; i++) for (int j = k; j <= m; j++) ans = std::min(ans, rowMax[i][j] - rowMin[i][j]);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2007-square","published":1,"updated":"2016-12-01T23:16:57.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0a013uooxlg37nsti1"},{"title":"「HAOI2007」分割矩阵 - 搜索","date":"2016-12-04T23:52:00.000Z","_content":"\n将一个 $ n \\times m $ 的数字矩阵进行如下分割：将原矩阵沿某一条直线分割成两个矩阵，再将生成的两个矩阵继续如此分割（当然也可以只分割其中的一个），这样分割了 $ k - 1 $ 次后，原矩阵被分割成了 $ k $ 个矩阵。（每次分割都只能沿着数字间的缝隙进行）原矩阵中每一位置上有一个分值，一个矩阵的总分为其所含各位置上分值之和。现在需要把矩阵按上述规则分割成 $ n $ 个矩阵，并使各矩阵总分的均方差最小。请编程对给出的矩阵及 $ n $，求出均方差的最小值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1048](http://www.lydsy.com/JudgeOnline/problem.php?id=1048)\n\n### 题解\n设答案为 $ s $，分割出的所有矩阵分数分别为 $ x_1 \\sim x_k $，设总和 $ S = \\sum\\limits_{i = 1} ^ k x_i $ 平均值 $ x' = \\frac{S}{k} $，则有\n\n$$\n\\begin{aligned}\ns ^ 2 &= \\frac{\\sum\\limits_{i = 1} ^ k (x_i - \\frac{S}{k}) ^ 2}{k} \\\\\n&= \\frac{\\sum\\limits_{i = 1} ^ k(x_i ^ 2 + (\\frac{S}{k}) ^ 2 + 2x_i\\frac{S}{k})}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\sum\\limits_{i = 1} ^ k \\frac{\\frac{S ^ 2}{k ^ 2}}{k} - 2(\\sum\\limits_{i = 1} ^ k x_i) \\frac{\\frac{S}{k}}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\frac{S ^ 2}{k^ 2} - 2 \\frac{(\\sum\\limits_{i = 1} ^ k x_i) S}{k ^ 2} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} - \\frac{S ^ 2}{k ^ 2} \\\\\n&= \\frac{k \\sum\\limits_{i = 1} ^ k x_i ^ 2 - S ^ 2}{k ^ 2}\n\\end{aligned}\n$$\n\n最小化 $ \\sum\\limits_{i = 1} ^ k x_i ^ 2 $，即每一块的平方和，即可。\n\n记忆化搜索，$ f(i_1, j_1, i_2, j_2, k) $ 表示左上角为 $ (i_1, j_1) $，右下角为 $ (i_2, j_2) $ 的矩阵，切 $ k $ 刀得到的每一块的平方和的最小值。转移时枚举横切或纵切的位置，枚举切出的两块继续切的次数。\n\n$ n $ 与 $ m $ 同阶，时间复杂度为 $ O(n ^ 4 k \\times nk) $\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10;\n\nint n, m, k, a[MAXN + 1][MAXN + 1], s[MAXN + 1][MAXN + 1];\n\ninline int sum(int i1, int j1, int i2, int j2) {\n\treturn s[i2][j2] - s[i1 - 1][j2] - s[i2][j1 - 1] + s[i1 - 1][j1 - 1];\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sumLine = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tsumLine += a[i][j];\n\t\t\ts[i][j] = s[i - 1][j] + sumLine;\n\t\t}\n\t}\n}\n\ntemplate <typename T> T sqr(T x) { return x * x; }\n\ninline int search(int i1, int j1, int i2, int j2, int cnt) {\n\tstatic int mem[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tstatic bool calced[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tint &ans = mem[i1][j1][i2][j2][cnt];\n\tif (calced[i1][j1][i2][j2][cnt]) return ans;\n\tcalced[i1][j1][i2][j2][cnt] = true;\n\n\tif (!cnt) {\n\t\treturn ans = sqr(sum(i1, j1, i2, j2));\n\t}\n\n\tans = INT_MAX;\n\n\tfor (int i = i1; i < i2; i++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i + 1, j1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i, j2, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\tfor (int j = j1; j < j2; j++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i1, j + 1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i2, j, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\t// printf(\"search(%d, %d, %d, %d, %d) = %d\\n\", i1, j1, i2, j2, cnt, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprepare();\n\n\tint ans = search(1, 1, n, m, k - 1);\n\n\t// printf(\"%d\\n\", ans);\n\tprintf(\"%.2lf\\n\", sqrt((ans * k - sqr(s[n][m])) / static_cast<double>(sqr(k))));\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-separation.md","raw":"title: 「HAOI2007」分割矩阵 - 搜索\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  - 搜索\n  - DFS\npermalink: haoi2007-separation\ndate: 2016-12-05 07:52:00\n---\n\n将一个 $ n \\times m $ 的数字矩阵进行如下分割：将原矩阵沿某一条直线分割成两个矩阵，再将生成的两个矩阵继续如此分割（当然也可以只分割其中的一个），这样分割了 $ k - 1 $ 次后，原矩阵被分割成了 $ k $ 个矩阵。（每次分割都只能沿着数字间的缝隙进行）原矩阵中每一位置上有一个分值，一个矩阵的总分为其所含各位置上分值之和。现在需要把矩阵按上述规则分割成 $ n $ 个矩阵，并使各矩阵总分的均方差最小。请编程对给出的矩阵及 $ n $，求出均方差的最小值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1048](http://www.lydsy.com/JudgeOnline/problem.php?id=1048)\n\n### 题解\n设答案为 $ s $，分割出的所有矩阵分数分别为 $ x_1 \\sim x_k $，设总和 $ S = \\sum\\limits_{i = 1} ^ k x_i $ 平均值 $ x' = \\frac{S}{k} $，则有\n\n$$\n\\begin{aligned}\ns ^ 2 &= \\frac{\\sum\\limits_{i = 1} ^ k (x_i - \\frac{S}{k}) ^ 2}{k} \\\\\n&= \\frac{\\sum\\limits_{i = 1} ^ k(x_i ^ 2 + (\\frac{S}{k}) ^ 2 + 2x_i\\frac{S}{k})}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\sum\\limits_{i = 1} ^ k \\frac{\\frac{S ^ 2}{k ^ 2}}{k} - 2(\\sum\\limits_{i = 1} ^ k x_i) \\frac{\\frac{S}{k}}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\frac{S ^ 2}{k^ 2} - 2 \\frac{(\\sum\\limits_{i = 1} ^ k x_i) S}{k ^ 2} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} - \\frac{S ^ 2}{k ^ 2} \\\\\n&= \\frac{k \\sum\\limits_{i = 1} ^ k x_i ^ 2 - S ^ 2}{k ^ 2}\n\\end{aligned}\n$$\n\n最小化 $ \\sum\\limits_{i = 1} ^ k x_i ^ 2 $，即每一块的平方和，即可。\n\n记忆化搜索，$ f(i_1, j_1, i_2, j_2, k) $ 表示左上角为 $ (i_1, j_1) $，右下角为 $ (i_2, j_2) $ 的矩阵，切 $ k $ 刀得到的每一块的平方和的最小值。转移时枚举横切或纵切的位置，枚举切出的两块继续切的次数。\n\n$ n $ 与 $ m $ 同阶，时间复杂度为 $ O(n ^ 4 k \\times nk) $\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10;\n\nint n, m, k, a[MAXN + 1][MAXN + 1], s[MAXN + 1][MAXN + 1];\n\ninline int sum(int i1, int j1, int i2, int j2) {\n\treturn s[i2][j2] - s[i1 - 1][j2] - s[i2][j1 - 1] + s[i1 - 1][j1 - 1];\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sumLine = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tsumLine += a[i][j];\n\t\t\ts[i][j] = s[i - 1][j] + sumLine;\n\t\t}\n\t}\n}\n\ntemplate <typename T> T sqr(T x) { return x * x; }\n\ninline int search(int i1, int j1, int i2, int j2, int cnt) {\n\tstatic int mem[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tstatic bool calced[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tint &ans = mem[i1][j1][i2][j2][cnt];\n\tif (calced[i1][j1][i2][j2][cnt]) return ans;\n\tcalced[i1][j1][i2][j2][cnt] = true;\n\n\tif (!cnt) {\n\t\treturn ans = sqr(sum(i1, j1, i2, j2));\n\t}\n\n\tans = INT_MAX;\n\n\tfor (int i = i1; i < i2; i++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i + 1, j1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i, j2, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\tfor (int j = j1; j < j2; j++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i1, j + 1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i2, j, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\t// printf(\"search(%d, %d, %d, %d, %d) = %d\\n\", i1, j1, i2, j2, cnt, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprepare();\n\n\tint ans = search(1, 1, n, m, k - 1);\n\n\t// printf(\"%d\\n\", ans);\n\tprintf(\"%.2lf\\n\", sqrt((ans * k - sqr(s[n][m])) / static_cast<double>(sqr(k))));\n\n\treturn 0;\n}\n```","slug":"haoi2007-separation","published":1,"updated":"2016-12-04T23:52:39.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0f013zooxl6lho0k0m"},{"title":"「HAOI2007」上升序列 - DP + 贪心","date":"2016-12-01T03:43:00.000Z","_content":"\n对于一个给定的 $ S = \\{ a_1, a_2, a_3, \\ldots , a_n \\} $，若有 $ P = \\{ a_{x_1},a_{x_2}, a_{x_3}, \\ldots, a_{x_m} \\} $，满足 $ x_1 < x_2 < \\ldots < x_m $ 且 $ a_{x_1} < a_{x_2} < \\ldots < a_{x_m} $，那么就称 $ P $ 为 $ S $ 的一个上升序列。如果有多个 $ P $ 满足条件，那么我们想求字典序最小的那个。\n\n任务给出 $ S $ 序列，给出若干询问。对于第 $ i $ 个询问，求出长度为 $ L_i $ 的上升序列，如有多个，求出**下标**字典序最小的那个。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1046](http://www.lydsy.com/JudgeOnline/problem.php?id=1046)\n\n### 题解\n动态规划求出 $ f(i) $ 表示以第 $ i $ 个数**开始**的最长上升子序列长度，即\n\n$$ f(i) = \\max\\limits_{j > i, a_j > a_i}\\{ f(j) \\} + 1 $$\n\n对于每个询问，按顺序扫描整个序列，如果从当前位置开始的最长上升序列长度 $ \\leq l $，则将当前位置的数加入答案序列中，并将 $ l $ 减去 $ 1 $。如果最终 $ l \\neq 0 $，则无解。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int f[MAXN + 1];\n\tfor (int i = n; i >= 1; i--) {\n\t\tf[i] = 1;\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"f[%d] = %d\\n\", i, f[i]);\n#endif\n\t}\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\n\t\tstatic int tmp[MAXN + 1];\n\t\tint cnt = 0;\n\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[i] >= l && a[i] > last) {\n\t\t\t\tl--;\n\t\t\t\tlast = a[i];\n\t\t\t\ttmp[++cnt] = a[i];\n\t\t\t}\n\t\t\tif (!l) break;\n\t\t}\n\n\t\tif (l) puts(\"Impossible\");\n\t\telse for (int i = 1; i <= cnt; i++) printf(\"%d%c\", tmp[i], i == cnt ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2007-lis.md","raw":"title: 「HAOI2007」上升序列 - DP + 贪心\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  - 贪心\npermalink: haoi2007-lis\ndate: 2016-12-01 11:43:00\n---\n\n对于一个给定的 $ S = \\{ a_1, a_2, a_3, \\ldots , a_n \\} $，若有 $ P = \\{ a_{x_1},a_{x_2}, a_{x_3}, \\ldots, a_{x_m} \\} $，满足 $ x_1 < x_2 < \\ldots < x_m $ 且 $ a_{x_1} < a_{x_2} < \\ldots < a_{x_m} $，那么就称 $ P $ 为 $ S $ 的一个上升序列。如果有多个 $ P $ 满足条件，那么我们想求字典序最小的那个。\n\n任务给出 $ S $ 序列，给出若干询问。对于第 $ i $ 个询问，求出长度为 $ L_i $ 的上升序列，如有多个，求出**下标**字典序最小的那个。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1046](http://www.lydsy.com/JudgeOnline/problem.php?id=1046)\n\n### 题解\n动态规划求出 $ f(i) $ 表示以第 $ i $ 个数**开始**的最长上升子序列长度，即\n\n$$ f(i) = \\max\\limits_{j > i, a_j > a_i}\\{ f(j) \\} + 1 $$\n\n对于每个询问，按顺序扫描整个序列，如果从当前位置开始的最长上升序列长度 $ \\leq l $，则将当前位置的数加入答案序列中，并将 $ l $ 减去 $ 1 $。如果最终 $ l \\neq 0 $，则无解。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int f[MAXN + 1];\n\tfor (int i = n; i >= 1; i--) {\n\t\tf[i] = 1;\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"f[%d] = %d\\n\", i, f[i]);\n#endif\n\t}\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\n\t\tstatic int tmp[MAXN + 1];\n\t\tint cnt = 0;\n\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[i] >= l && a[i] > last) {\n\t\t\t\tl--;\n\t\t\t\tlast = a[i];\n\t\t\t\ttmp[++cnt] = a[i];\n\t\t\t}\n\t\t\tif (!l) break;\n\t\t}\n\n\t\tif (l) puts(\"Impossible\");\n\t\telse for (int i = 1; i <= cnt; i++) printf(\"%d%c\", tmp[i], i == cnt ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2007-lis","published":1,"updated":"2016-12-01T08:25:25.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0l0146ooxlgvaxaqja"},{"title":"「HAOI2007」覆盖问题 - 二分答案 + 枚举","date":"2016-12-13T08:37:00.000Z","_content":"\n用三个 $ L \\times L $ 的正方形覆盖一些点，使最大正方形的边长最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1052](http://www.lydsy.com/JudgeOnline/problem.php?id=1052)\n\n### 题解\n二分答案，考虑如何检验。\n\n首先，求出一个能覆盖所有点的最小矩形。\n\n考虑到第一个正方形一定放在一个角上（第一个正方形不放在角上一定不会比放在角上更优），枚举四个角，将覆盖到的点做标记后再求出能覆盖剩下所有点的最小矩形，再枚举这个矩形的四个角，放置第二个正方形，之后只需要判定剩余的点是否可以被一个正方形围住即可。\n\n时间复杂度 $ O(4 \\times 4 \\times n \\log n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Point {\n\tint x, y;\n\tbool covered[2];\n} a[MAXN + 1];\n\nstruct Rectangle {\n\tint x1, y1, x2, y2;\n};\n\nint n;\n\ninline Rectangle getBound() {\n\tRectangle rect;\n\trect.x1 = rect.y1 = INT_MAX, rect.x2 = rect.y2 = INT_MIN;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].covered[0] || a[i].covered[1]) continue;\n\t\trect.x1 = std::min(rect.x1, a[i].x);\n\t\trect.y1 = std::min(rect.y1, a[i].y);\n\t\trect.x2 = std::max(rect.x2, a[i].x);\n\t\trect.y2 = std::max(rect.y2, a[i].y);\n\t}\n\treturn rect;\n}\n\ninline void cover(int x, int y, int len, int index, bool flag) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].x >= x && a[i].x <= x + len && a[i].y >= y && a[i].y <= y + len) {\n\t\t\ta[i].covered[index] = flag;\n\t\t}\n\t}\n}\n\ninline void cover(Rectangle rect, int limit, int corner, int index, bool flag) {\n\tif (corner == 1) cover(rect.x1, rect.y1, limit, index, flag);\n\telse if (corner == 2) cover(rect.x2 - limit, rect.y1, limit, index, flag);\n\telse if (corner == 3) cover(rect.x2 - limit, rect.y2 - limit, limit, index, flag);\n\telse cover(rect.x1, rect.y2 - limit, limit, index, flag);\n}\n\ninline bool check(int limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].covered[0] = a[i].covered[1] = false;\n\t}\n\n\tRectangle rect1 = getBound();\n\tfor (int i = 1; i <= 4; i++) {\n\t\tcover(rect1, limit, i, 0, true);\n\n\t\tRectangle rect2 = getBound();\n\t\tfor (int j = 1; j <= 4; j++) {\n\t\t\tcover(rect2, limit, j, 1, true);\n\n\t\t\tRectangle rect3 = getBound();\n\t\t\tif (std::max(rect3.x2 - rect3.x1, rect3.y2 - rect3.y1) <= limit) return true;\n\n\t\t\tcover(rect2, limit, j, 1, false);\n\t\t}\n\n\t\tcover(rect1, limit, i, 0, false);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t}\n\n\tRectangle rect = getBound();\n\n\tint l = 0, r = std::max(rect.x2 - rect.x1, rect.y2 - rect.y1);\n\twhile (l < r) {\n\t\tint mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-cover.md","raw":"title: 「HAOI2007」覆盖问题 - 二分答案 + 枚举\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 二分答案\n  - 枚举\npermalink: haoi2007-cover\ndate: 2016-12-13 16:37:00\n---\n\n用三个 $ L \\times L $ 的正方形覆盖一些点，使最大正方形的边长最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1052](http://www.lydsy.com/JudgeOnline/problem.php?id=1052)\n\n### 题解\n二分答案，考虑如何检验。\n\n首先，求出一个能覆盖所有点的最小矩形。\n\n考虑到第一个正方形一定放在一个角上（第一个正方形不放在角上一定不会比放在角上更优），枚举四个角，将覆盖到的点做标记后再求出能覆盖剩下所有点的最小矩形，再枚举这个矩形的四个角，放置第二个正方形，之后只需要判定剩余的点是否可以被一个正方形围住即可。\n\n时间复杂度 $ O(4 \\times 4 \\times n \\log n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Point {\n\tint x, y;\n\tbool covered[2];\n} a[MAXN + 1];\n\nstruct Rectangle {\n\tint x1, y1, x2, y2;\n};\n\nint n;\n\ninline Rectangle getBound() {\n\tRectangle rect;\n\trect.x1 = rect.y1 = INT_MAX, rect.x2 = rect.y2 = INT_MIN;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].covered[0] || a[i].covered[1]) continue;\n\t\trect.x1 = std::min(rect.x1, a[i].x);\n\t\trect.y1 = std::min(rect.y1, a[i].y);\n\t\trect.x2 = std::max(rect.x2, a[i].x);\n\t\trect.y2 = std::max(rect.y2, a[i].y);\n\t}\n\treturn rect;\n}\n\ninline void cover(int x, int y, int len, int index, bool flag) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].x >= x && a[i].x <= x + len && a[i].y >= y && a[i].y <= y + len) {\n\t\t\ta[i].covered[index] = flag;\n\t\t}\n\t}\n}\n\ninline void cover(Rectangle rect, int limit, int corner, int index, bool flag) {\n\tif (corner == 1) cover(rect.x1, rect.y1, limit, index, flag);\n\telse if (corner == 2) cover(rect.x2 - limit, rect.y1, limit, index, flag);\n\telse if (corner == 3) cover(rect.x2 - limit, rect.y2 - limit, limit, index, flag);\n\telse cover(rect.x1, rect.y2 - limit, limit, index, flag);\n}\n\ninline bool check(int limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].covered[0] = a[i].covered[1] = false;\n\t}\n\n\tRectangle rect1 = getBound();\n\tfor (int i = 1; i <= 4; i++) {\n\t\tcover(rect1, limit, i, 0, true);\n\n\t\tRectangle rect2 = getBound();\n\t\tfor (int j = 1; j <= 4; j++) {\n\t\t\tcover(rect2, limit, j, 1, true);\n\n\t\t\tRectangle rect3 = getBound();\n\t\t\tif (std::max(rect3.x2 - rect3.x1, rect3.y2 - rect3.y1) <= limit) return true;\n\n\t\t\tcover(rect2, limit, j, 1, false);\n\t\t}\n\n\t\tcover(rect1, limit, i, 0, false);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t}\n\n\tRectangle rect = getBound();\n\n\tint l = 0, r = std::max(rect.x2 - rect.x1, rect.y2 - rect.y1);\n\twhile (l < r) {\n\t\tint mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```","slug":"haoi2007-cover","published":1,"updated":"2016-12-13T08:37:24.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0q014cooxluoph4st4"},{"title":"「HAOI2007」反素数 - 搜索","date":"2016-12-13T08:57:00.000Z","_content":"\n对于任何正整数 $ x $，其约数的个数记作 $ g(x) $，例如 $ g(1) = 1 $、$ g(6) = 4 $。如果某个正整数 $ x $ 对于任何 $ i \\in (0, x) $ 都满足 $ g(x) > g(i) $，则称 $ x $ 为反质数。\n\n给定一个数 $ N $，求最大的不超过 $ N $ 的反质数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1053](http://www.lydsy.com/JudgeOnline/problem.php?id=1053)\n\n### 题解\n一个反质数 $ x $ 一定是 $ [1, x] $ 内约数个数最多的数，并且不存在一个 $ y < x $ 使 $ y $ 的约数个数与 $ x $ 的相等。\n\n所以，对于因子数量相同的数，较小的才有可能是反质数。由此可知，反质数的质因子一定是从 $ 2 $ 开始连续的若干个质数。\n\n设 $ x $ 的唯一分解式为 $ x = 2 ^ {t_1} \\times 3 ^ {t_2} \\times \\ldots \\times p_k ^ {t_k} $。则 $ x $ 的约数个数 $ g(x) = \\prod\\limits_{i = 1} ^ k t_i $。假设存在一个 $ j $ 满足 $ p_j $ 和 $ p_{j + 1} $ 不是连续的质数，则令 $ p_{j + 1} $ 为 $ p_j $ 的下一个质数，$ p_{j + 2} \\sim p_k $ 向后顺延，这样得到的唯一分解式中，$ \\{ t_i \\} $ 不变，而 $ x $ 变小了。上述推论得证。\n\n所以，本题的答案的质因子一定是前若干个质数，通过计算可知，前 $ 11 $ 个质数（$ \\{ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 \\} $）的积大于 $ 2 \\times 10 ^ 9 $。\n\n搜索每个质数的次数，如果得到一个比当前答案约数数量更多的数，或者得到一个与当前答案约数数量相等但本身更小的数，则更新答案。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 2e9;\n\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\nconst int PRIMES_CNT = 11;\n\nint n, cntAns;\nlong long ans;\n\ninline void search(int i, long long x, int cnt) {\n\tif (i == PRIMES_CNT) {\n\t\tif ((cnt == cntAns && x < ans) || (cnt > cntAns)) {\n\t\t\tans = x;\n\t\t\tcntAns = cnt;\n\t\t\t// printf(\"%lld\\n\", ans);\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long t = 1;\n\tfor (int j = 0; x * t <= n; j++) {\n\t\tsearch(i + 1, x * t, cnt * (j + 1));\n\t\tt *= PRIMES[i];\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsearch(0, 1, 1);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-ant.md","raw":"title: 「HAOI2007」反素数 - 搜索\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 搜索\n  - 数学\npermalink: haoi2007-ant\ndate: 2016-12-13 16:57:00\n---\n\n对于任何正整数 $ x $，其约数的个数记作 $ g(x) $，例如 $ g(1) = 1 $、$ g(6) = 4 $。如果某个正整数 $ x $ 对于任何 $ i \\in (0, x) $ 都满足 $ g(x) > g(i) $，则称 $ x $ 为反质数。\n\n给定一个数 $ N $，求最大的不超过 $ N $ 的反质数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1053](http://www.lydsy.com/JudgeOnline/problem.php?id=1053)\n\n### 题解\n一个反质数 $ x $ 一定是 $ [1, x] $ 内约数个数最多的数，并且不存在一个 $ y < x $ 使 $ y $ 的约数个数与 $ x $ 的相等。\n\n所以，对于因子数量相同的数，较小的才有可能是反质数。由此可知，反质数的质因子一定是从 $ 2 $ 开始连续的若干个质数。\n\n设 $ x $ 的唯一分解式为 $ x = 2 ^ {t_1} \\times 3 ^ {t_2} \\times \\ldots \\times p_k ^ {t_k} $。则 $ x $ 的约数个数 $ g(x) = \\prod\\limits_{i = 1} ^ k t_i $。假设存在一个 $ j $ 满足 $ p_j $ 和 $ p_{j + 1} $ 不是连续的质数，则令 $ p_{j + 1} $ 为 $ p_j $ 的下一个质数，$ p_{j + 2} \\sim p_k $ 向后顺延，这样得到的唯一分解式中，$ \\{ t_i \\} $ 不变，而 $ x $ 变小了。上述推论得证。\n\n所以，本题的答案的质因子一定是前若干个质数，通过计算可知，前 $ 11 $ 个质数（$ \\{ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 \\} $）的积大于 $ 2 \\times 10 ^ 9 $。\n\n搜索每个质数的次数，如果得到一个比当前答案约数数量更多的数，或者得到一个与当前答案约数数量相等但本身更小的数，则更新答案。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 2e9;\n\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\nconst int PRIMES_CNT = 11;\n\nint n, cntAns;\nlong long ans;\n\ninline void search(int i, long long x, int cnt) {\n\tif (i == PRIMES_CNT) {\n\t\tif ((cnt == cntAns && x < ans) || (cnt > cntAns)) {\n\t\t\tans = x;\n\t\t\tcntAns = cnt;\n\t\t\t// printf(\"%lld\\n\", ans);\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long t = 1;\n\tfor (int j = 0; x * t <= n; j++) {\n\t\tsearch(i + 1, x * t, cnt * (j + 1));\n\t\tt *= PRIMES[i];\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsearch(0, 1, 1);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2007-ant","published":1,"updated":"2016-12-13T08:57:07.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0w014iooxl1n7w1ay9"},{"title":"「HAOI2006」数字序列 - DP","date":"2016-12-07T00:35:00.000Z","_content":"\n现在我们有一个长度为 $ n $ 的整数序列 $ \\{ a_i \\} $。我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1049](http://www.lydsy.com/JudgeOnline/problem.php?id=1049)\n\n### 题解\n为了方便处理边界，我们在序列最左侧添加一个 $ a_0 = \\min\\limits_{i = 1} ^ n\\{ a_i \\} $，最右侧添加一个 $ a_{n + 1} = \\max\\limits_{i = 1} ^ n\\{ a_i \\} $。\n\n第一问，在一个单调上升序列中，对于每一个 $ a_i $，它至少要比它左边的第 $ k $ 个数大 $ k $，即 $ a_i \\geq a_{i - k} + k $。如果我们确定了一个子序列满足该条件，则只需修改剩余的数，设 $ f(i) $ 表示前 $ i $ 个数中最长的满足该条件的序列，可以写出 DP 方程\n\n$$ f(i) = \\max\\limits_{j = 0} ^ {i - 1} \\{ f(j) + 1, a_i - a_j \\geq i - j \\} $$\n\n第一问答案即为 $ n - f(n + 1) + 1 $。\n\n第二问要求在第一问的前提下使修改幅度最小，即我们需要保证有一个最长的满足原单调上升条件的子序列不变。\n\n考虑将每个数 $ a_i $ 减去 $ i $，即令 $ b_i = a_i - i $，显然如果 $ \\{ b_i \\} $ 为单调不下降序列，则 $ \\{ a_i \\} $ 为单调上升序列。问题转化为求在保证 $ b_i $ 的一个最长单调不下降子序列不变的前提下，使 $ b_i $ 单调不下降的最小修改幅度。\n\n设 $ \\mathrm{cost}(l, r) $ 表示**在 $ l $ 位置和 $ r $ 位置不变的前提下**，将 $ [l, r] $ 一段区间修改为单调不下降序列的最小修改幅度。设 $ g(i) $ 为保证 $ i $ 位置不变的前提下，将 $ [1, i] $ 修改为单调不下降序列的最小修改幅度。\n\n$$ g(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ g(j) + \\mathrm{cost}(j, i), f(i) = f(j) + 1 \\} $$\n\n注意到对于方程中任意一对 $ (i, j) $，不可能存在一个 $ k \\in (i, j) $ 满足 $ b_i \\leq b_k \\leq b_j $，即对于任意的 $ k \\in (i, j) $，满足 $ b_k > b_i $ 或 $ b_k < b_j $，即\n\n![](haoi2006-sequence/1.svg)\n\n所以最优策略一定是令左边若干个改变为 $ b_j $，右边若干个改变为 $ b_i $，即\n\n![](haoi2006-sequence/2.svg)\n\n枚举中间这条扫描线，维护左边若干个改变为 $ b_j $，右边若干个改变为 $ b_i $ 的最小代价，更新 $ g(i) $。\n\n时间复杂度（上界）为 $ O(n ^ 3) $，但实际上远远达不到这个上界。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 35000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int b[MAXN + 2];\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i] = a[i] - i;\n\n\t\tb[0] = std::min(b[0], b[i]);\n\t\tb[n + 1] = std::max(b[n + 1], b[i]);\n\t}\n\n\tstatic int f[MAXN + 2];\n\tint maxLen = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 > f[i]) {\n\t\t\t\tf[i] = f[j] + 1;\n\t\t\t\tmaxLen = std::max(maxLen, f[i]);\n\t\t\t}\n\t\t}\n#ifdef DBG\n\t\tprintf(\"b[%d] = %d, f[%d] = %d\\n\", i, b[i], i, f[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", n - f[n + 1] + 1);\n\n\tstatic int g[MAXN + 2];\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tg[i] = INT_MAX;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 == f[i]) {\n\t\t\t\tint w = 0;\n\t\t\t\tfor (int k = i - 1; k > j; k--) w += abs(b[k] - b[j]);\n\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\tfor (int k = i - 1; k > j; k--) {\n\t\t\t\t\tw -= abs(b[k] - b[j]);\n\t\t\t\t\tw += abs(b[k] - b[i]);\n\t\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(g[i] != INT_MAX);\n#ifdef DBG\n\t\tprintf(\"g[%d] = %d\\n\", i, g[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", g[n + 1]);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2006-sequence.md","raw":"title: 「HAOI2006」数字序列 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\npermalink: haoi2006-sequence\ndate: 2016-12-07 08:35:00\n---\n\n现在我们有一个长度为 $ n $ 的整数序列 $ \\{ a_i \\} $。我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1049](http://www.lydsy.com/JudgeOnline/problem.php?id=1049)\n\n### 题解\n为了方便处理边界，我们在序列最左侧添加一个 $ a_0 = \\min\\limits_{i = 1} ^ n\\{ a_i \\} $，最右侧添加一个 $ a_{n + 1} = \\max\\limits_{i = 1} ^ n\\{ a_i \\} $。\n\n第一问，在一个单调上升序列中，对于每一个 $ a_i $，它至少要比它左边的第 $ k $ 个数大 $ k $，即 $ a_i \\geq a_{i - k} + k $。如果我们确定了一个子序列满足该条件，则只需修改剩余的数，设 $ f(i) $ 表示前 $ i $ 个数中最长的满足该条件的序列，可以写出 DP 方程\n\n$$ f(i) = \\max\\limits_{j = 0} ^ {i - 1} \\{ f(j) + 1, a_i - a_j \\geq i - j \\} $$\n\n第一问答案即为 $ n - f(n + 1) + 1 $。\n\n第二问要求在第一问的前提下使修改幅度最小，即我们需要保证有一个最长的满足原单调上升条件的子序列不变。\n\n考虑将每个数 $ a_i $ 减去 $ i $，即令 $ b_i = a_i - i $，显然如果 $ \\{ b_i \\} $ 为单调不下降序列，则 $ \\{ a_i \\} $ 为单调上升序列。问题转化为求在保证 $ b_i $ 的一个最长单调不下降子序列不变的前提下，使 $ b_i $ 单调不下降的最小修改幅度。\n\n设 $ \\mathrm{cost}(l, r) $ 表示**在 $ l $ 位置和 $ r $ 位置不变的前提下**，将 $ [l, r] $ 一段区间修改为单调不下降序列的最小修改幅度。设 $ g(i) $ 为保证 $ i $ 位置不变的前提下，将 $ [1, i] $ 修改为单调不下降序列的最小修改幅度。\n\n$$ g(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ g(j) + \\mathrm{cost}(j, i), f(i) = f(j) + 1 \\} $$\n\n注意到对于方程中任意一对 $ (i, j) $，不可能存在一个 $ k \\in (i, j) $ 满足 $ b_i \\leq b_k \\leq b_j $，即对于任意的 $ k \\in (i, j) $，满足 $ b_k > b_i $ 或 $ b_k < b_j $，即\n\n![](haoi2006-sequence/1.svg)\n\n所以最优策略一定是令左边若干个改变为 $ b_j $，右边若干个改变为 $ b_i $，即\n\n![](haoi2006-sequence/2.svg)\n\n枚举中间这条扫描线，维护左边若干个改变为 $ b_j $，右边若干个改变为 $ b_i $ 的最小代价，更新 $ g(i) $。\n\n时间复杂度（上界）为 $ O(n ^ 3) $，但实际上远远达不到这个上界。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 35000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int b[MAXN + 2];\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i] = a[i] - i;\n\n\t\tb[0] = std::min(b[0], b[i]);\n\t\tb[n + 1] = std::max(b[n + 1], b[i]);\n\t}\n\n\tstatic int f[MAXN + 2];\n\tint maxLen = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 > f[i]) {\n\t\t\t\tf[i] = f[j] + 1;\n\t\t\t\tmaxLen = std::max(maxLen, f[i]);\n\t\t\t}\n\t\t}\n#ifdef DBG\n\t\tprintf(\"b[%d] = %d, f[%d] = %d\\n\", i, b[i], i, f[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", n - f[n + 1] + 1);\n\n\tstatic int g[MAXN + 2];\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tg[i] = INT_MAX;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 == f[i]) {\n\t\t\t\tint w = 0;\n\t\t\t\tfor (int k = i - 1; k > j; k--) w += abs(b[k] - b[j]);\n\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\tfor (int k = i - 1; k > j; k--) {\n\t\t\t\t\tw -= abs(b[k] - b[j]);\n\t\t\t\t\tw += abs(b[k] - b[i]);\n\t\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(g[i] != INT_MAX);\n#ifdef DBG\n\t\tprintf(\"g[%d] = %d\\n\", i, g[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", g[n + 1]);\n\n\treturn 0;\n}\n```","slug":"haoi2006-sequence","published":1,"updated":"2016-12-07T00:36:12.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s11014oooxlk15ca9gr"},{"title":"「HAOI2006」受欢迎的牛 - 强联通分量","date":"2016-03-04T13:28:17.000Z","_content":"\n每一头牛的愿望就是变成一头最受欢迎的牛。现在有 $ N $ 头牛，给你 $ M $ 对整数 $ (A,B) $，表示牛 $ A $ 认为牛 $ B $ 受欢迎。 这种关系是具有传递性的，如果 $ A $ 认为 $ B $ 受欢迎，$ B $ 认为 $ C $ 受欢迎，那么牛 $ A $ 也认为牛 $ C $ 受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### 题解\n求出强联通分量，缩点，然后判断是不是只有一个出度为零的点，如果是输出它的大小。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2006-cow.md","raw":"title: 「HAOI2006」受欢迎的牛 - 强联通分量\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 强联通分量\n  - Tarjan\n  - 缩点\npermalink: haoi2006-cow\ndate: 2016-03-04 21:28:17\n---\n\n每一头牛的愿望就是变成一头最受欢迎的牛。现在有 $ N $ 头牛，给你 $ M $ 对整数 $ (A,B) $，表示牛 $ A $ 认为牛 $ B $ 受欢迎。 这种关系是具有传递性的，如果 $ A $ 认为 $ B $ 受欢迎，$ B $ 认为 $ C $ 受欢迎，那么牛 $ A $ 也认为牛 $ C $ 受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### 题解\n求出强联通分量，缩点，然后判断是不是只有一个出度为零的点，如果是输出它的大小。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","slug":"haoi2006-cow","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s1a014tooxlrxx0i9sh"},{"title":"GDB 入门教程","id":"41","updated":"2016-02-05T02:59:41.000Z","date":"2016-02-05T02:58:07.000Z","_content":"\nGDB（GNU Debugger）是 GNU 计划中的标准调试器，可以在 UNIX、Linux 和 Windows 下运行，支持多种语言（如 C、C++、Pascal 等）程序的调试。\n\n<!-- more -->\n\n### 安装\n#### Linux\n在 Ubuntu 及其衍生版本下，使用 `apt` 安装 GDB。\n```bash\nsudo apt-get install gdb\n```\n另外，NOI Linux 也中有预装的 GDB。\n\n在 RHEL/Fedora/Archlinux 下，使用其各自的包管理器来安装 GDB。\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n在 Windows 下，可选择 Cygwin/MSYS2 环境，也需使用其各自的包管理器来安装 GDB，但通常使用更加轻量的 MinGW 工具集。\n\n一般地，Dev-C++ 安装时会配带 MinGW，我们可以在其 `bin` 目录下找到 `gdb.exe`，为了方便，我们通常将 `bin` 目录的路径添加进 `PATH` 环境变量中，这样我们就可以直接在 `cmd` 中执行 `gdb` 命令。\n\n### 启动\n在控制台中输入 `gdb` 命令（Windows 系统有时需要手动配置环境变量），启动 GDB：\n```bash\ngdb\n```\n在 GDB 中，用 `file` 命令指定需要被调试的程序：\n```bash\n(gdb) file test\n```\n或者，也可以直接在启动 GDB 的时候指定需要被调试的程序：\n```bash\ngdb test\n```\n其中 `test` 为被调试的程序的可执行文件名。\n\n需要注意的是，被 GDB 调试的程序，**在编译时需要加上 `-g` 选项，表示在生成的可执行文件中包含调试信息**。\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB 启动时的提示大概是酱紫的：\n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### 运行\n使用 `run`（简写为 `r`）命令运行被调试的程序。\n```bash\n(gdb) run\n```\n之后可以像直接运行程序一样输入数据并获得输出，程序正常退出时，会得到类似于以下的提示：\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\n如果程序出现运行时错误（Runtime Error，RE），则会有一下提示，此时程序中断（以访问无效内存为例）：\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n其中 `SIGSEGV` 表示程序中断的信号，后面跟着解释文本“Segmentation fault”，即“段错误”。中间一行是程序中断所在函数及其调用参数，下面一行是程序中断所在行的代码，开头 `6` 为行号。\n\n出现这种情况时，我们可以使用各种调试命令对其进行调♂试。\n\n### 退出\n使用 `quit`（简写为 `q`）命令退出。\n\n如果程序正常运行结束，则 `q` 命令会成功退出 GDB，否则我们将会收到类似如下的提示：\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n这时候输入 `y` 后回车，可以强制杀死被调试的进行并退出 GDB。\n\n### 断点\n使用 `break`（简写为 `b`）命令设置断点，后跟一个行号或者函数名，之后程序会在执行到该行时中断。\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` 命令也可以在断点位置后跟一个条件，仅当该条件为真时程序中断。\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n使用 `r` 运行程序，当你输入 `528` 时，程序中断，否则程序继续运行。\n\nPascal 在设置条件断点时会有所不同，如这里的 `==` 需要改为 `=`。\n\n### 控制\n使用 `continue`（简写为 `c`）命令使中断的程序继续运行。\n\n注意，这里“中断的程序”指的是**通过断点中断**的程序，而不是**运行时错误**而中断的，如果我们强制让一个运行时错误的程序继续运行 …… 你猜它会怎样 ……\n\n使用 `step`（简写为 `s`）命令使中断的程序执行一行，如果该行有函数调用，程序将跟踪进入函数，在函数体的第一行中断。\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n或者，你想让我用 Pascal 来演示一下的话，是酱紫的：\n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n使用 `next`（简写为 `n`）命令使中断的程序执行一行，如果该行有函数调用，程序将**不**跟踪进入函数，直接在下一行中断。\n\n源程序不变，执行效果如下：\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### 监视\n在 GDB 中，可以对表达式的值进行监视。\n\n使用 `print`（简写为 `p`）命令输出一个表达式的值，这里的表达式可以只是一个变量，也可以是包含了多个函数调用的复杂表达式。\n\n来看这个经典的 A + B 问题：\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n使用 `display`（简写为 `disp`）命令持续监视某个表达式的值。\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n在 GDB 7.0 之后的版本，可以直接使用 `p` 命令输出 STL 容器的内容。\n\n### 栈\n在函数调用时，系统栈会储存函数的调用信息，使用 `backtrace`（简写为 `bt`）命令查看调用栈。\n\n为了方便演示，我们写一个使系统栈溢出的函数来演示。\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n（以上省略 272043 行）\n\n`bt` 命令可以看到函数的调用信息，同时调用参数、调用位置（行号）也会被显示。\n\n使用 `frame` 命令切换正在调试的函数上下文。\n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n从例子中我们看到，`frame 3` 命令使当前上下文切换到了 `d(x)` 函数中，此时 `p x` 输出的值为 `4`，与我们调用时所传递的值相同。\n\n`frame` 命令在调试在 STL 中崩溃的程序时有很大作用，我们需要切换到自己的函数的上下文中，而不是对 STL 进行调试。\n\n### 查看代码\n使用 `list`（简写为 `l`）命令查看部分代码，后跟一个行号，表示查看从该行开始若干行的代码。\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","source":"_posts/gnu-debugger.md","raw":"title: GDB 入门教程\ncategories: OI\ntags: \n  - GDB\n  - 调试\n  - C++\npermalink: gnu-debugger\nid: 41\nupdated: '2016-02-05 10:59:41'\ndate: 2016-02-05 10:58:07\n---\n\nGDB（GNU Debugger）是 GNU 计划中的标准调试器，可以在 UNIX、Linux 和 Windows 下运行，支持多种语言（如 C、C++、Pascal 等）程序的调试。\n\n<!-- more -->\n\n### 安装\n#### Linux\n在 Ubuntu 及其衍生版本下，使用 `apt` 安装 GDB。\n```bash\nsudo apt-get install gdb\n```\n另外，NOI Linux 也中有预装的 GDB。\n\n在 RHEL/Fedora/Archlinux 下，使用其各自的包管理器来安装 GDB。\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n在 Windows 下，可选择 Cygwin/MSYS2 环境，也需使用其各自的包管理器来安装 GDB，但通常使用更加轻量的 MinGW 工具集。\n\n一般地，Dev-C++ 安装时会配带 MinGW，我们可以在其 `bin` 目录下找到 `gdb.exe`，为了方便，我们通常将 `bin` 目录的路径添加进 `PATH` 环境变量中，这样我们就可以直接在 `cmd` 中执行 `gdb` 命令。\n\n### 启动\n在控制台中输入 `gdb` 命令（Windows 系统有时需要手动配置环境变量），启动 GDB：\n```bash\ngdb\n```\n在 GDB 中，用 `file` 命令指定需要被调试的程序：\n```bash\n(gdb) file test\n```\n或者，也可以直接在启动 GDB 的时候指定需要被调试的程序：\n```bash\ngdb test\n```\n其中 `test` 为被调试的程序的可执行文件名。\n\n需要注意的是，被 GDB 调试的程序，**在编译时需要加上 `-g` 选项，表示在生成的可执行文件中包含调试信息**。\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB 启动时的提示大概是酱紫的：\n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### 运行\n使用 `run`（简写为 `r`）命令运行被调试的程序。\n```bash\n(gdb) run\n```\n之后可以像直接运行程序一样输入数据并获得输出，程序正常退出时，会得到类似于以下的提示：\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\n如果程序出现运行时错误（Runtime Error，RE），则会有一下提示，此时程序中断（以访问无效内存为例）：\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n其中 `SIGSEGV` 表示程序中断的信号，后面跟着解释文本“Segmentation fault”，即“段错误”。中间一行是程序中断所在函数及其调用参数，下面一行是程序中断所在行的代码，开头 `6` 为行号。\n\n出现这种情况时，我们可以使用各种调试命令对其进行调♂试。\n\n### 退出\n使用 `quit`（简写为 `q`）命令退出。\n\n如果程序正常运行结束，则 `q` 命令会成功退出 GDB，否则我们将会收到类似如下的提示：\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n这时候输入 `y` 后回车，可以强制杀死被调试的进行并退出 GDB。\n\n### 断点\n使用 `break`（简写为 `b`）命令设置断点，后跟一个行号或者函数名，之后程序会在执行到该行时中断。\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` 命令也可以在断点位置后跟一个条件，仅当该条件为真时程序中断。\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n使用 `r` 运行程序，当你输入 `528` 时，程序中断，否则程序继续运行。\n\nPascal 在设置条件断点时会有所不同，如这里的 `==` 需要改为 `=`。\n\n### 控制\n使用 `continue`（简写为 `c`）命令使中断的程序继续运行。\n\n注意，这里“中断的程序”指的是**通过断点中断**的程序，而不是**运行时错误**而中断的，如果我们强制让一个运行时错误的程序继续运行 …… 你猜它会怎样 ……\n\n使用 `step`（简写为 `s`）命令使中断的程序执行一行，如果该行有函数调用，程序将跟踪进入函数，在函数体的第一行中断。\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n或者，你想让我用 Pascal 来演示一下的话，是酱紫的：\n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n使用 `next`（简写为 `n`）命令使中断的程序执行一行，如果该行有函数调用，程序将**不**跟踪进入函数，直接在下一行中断。\n\n源程序不变，执行效果如下：\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### 监视\n在 GDB 中，可以对表达式的值进行监视。\n\n使用 `print`（简写为 `p`）命令输出一个表达式的值，这里的表达式可以只是一个变量，也可以是包含了多个函数调用的复杂表达式。\n\n来看这个经典的 A + B 问题：\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n使用 `display`（简写为 `disp`）命令持续监视某个表达式的值。\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n在 GDB 7.0 之后的版本，可以直接使用 `p` 命令输出 STL 容器的内容。\n\n### 栈\n在函数调用时，系统栈会储存函数的调用信息，使用 `backtrace`（简写为 `bt`）命令查看调用栈。\n\n为了方便演示，我们写一个使系统栈溢出的函数来演示。\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n（以上省略 272043 行）\n\n`bt` 命令可以看到函数的调用信息，同时调用参数、调用位置（行号）也会被显示。\n\n使用 `frame` 命令切换正在调试的函数上下文。\n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n从例子中我们看到，`frame 3` 命令使当前上下文切换到了 `d(x)` 函数中，此时 `p x` 输出的值为 `4`，与我们调用时所传递的值相同。\n\n`frame` 命令在调试在 STL 中崩溃的程序时有很大作用，我们需要切换到自己的函数的上下文中，而不是对 STL 进行调试。\n\n### 查看代码\n使用 `list`（简写为 `l`）命令查看部分代码，后跟一个行号，表示查看从该行开始若干行的代码。\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","slug":"gnu-debugger","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s1g0150ooxltpgq3ka0"},{"title":"计算几何学习笔记","date":"2017-01-06T08:30:00.000Z","_content":"\n计算几何（Computational Geometry），是一系列使用计算机解决几何问题的算法。与解析几何相比，计算几何更适合计算机运算，精度较高，运算速度较快，并且易于编写。\n\n本文只包含二维计算几何在 OI 中的部分应用。\n\n<!-- more -->\n\n### 浮点误差\n程序设计中，考虑到浮点数 `double` 有精度误差，在比较时，通常允许一定的误差，即对于两个数 $ a $、$ b $，如果 $ | a - b | \\leq d $，则认为 $ a = b $。一般根据题目要求，$ d $（代码中命名为 `EPS`）取一个较小值，如 $ 10 ^ {-8} $。\n\n```c++\nconst double EPS = 1e-8;\n\n// 带误差比较，返回 x 是否等于 y\ninline bool dcmp(double x, double y = 0)\n{\n\treturn fabs(x - y) <= EPS;\n}\n```\n\n### 向量\n向量（vector）是一个有大小和方向的量，在几何中，它被表示为带箭头的线段。向量可以用**起点**和**终点**的坐标来表示 —— 从点 $ A $ 到点 $ B $ 的向量表示为 $ \\overrightarrow{AB} $。\n\n向量的书写，两个大写字母上加一个箭头（表示方向）$ \\overrightarrow{AB} $，或者加粗的小写字母 $ \\boldsymbol{a} $。\n\n向量没有位置，即向量可以在平面内任意平移而保持其本身的性质不变 —— 所以我们可以将向量平移至其起点与原点 $ (0, 0) $ 重合，用终点坐标表示这个向量，下文称此方法为**坐标表示法**，除特殊说明外，下文表示向量均使用此方法。\n\n两个向量的夹角 $ \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $ 定义为从 $ \\boldsymbol{a} $ 旋转到 $ \\boldsymbol{b} $ 所经过的角度，逆时针为正，顺时针为负。\n\n向量范数（norm），这里简单定义向量 $ \\overrightarrow{AB} = (x, y) $ 的范数为 $ x ^ 2 + y ^ 2 $，即长度的平方 $ | \\overrightarrow{AB} | ^ 2 $。这样定义的好处是，可以方便地比较两个向量的长度，而不需要开平方。\n\n与向量相对的概念是**标量**（scalar），标量只有大小没有方向。\n\n### 向量的基本运算\n两个向量相加，遵循平行四边形定则（或三角形定则），$ (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2) $。\n\n两个向量相减与相加类似，除此之外，点可以加减一个向量，表示将点按照向量所指向的方向进行平移。\n\n向量的数乘，将一个向量乘或除以 $ k $，表示将向量所对应的有向线段长度变为原来的 $ k $ 倍或 $ k $ 分之一。\n\n可以发现，向量和点的运算是相似的，在程序中，可以使用同一种类型来表示向量和点：\n\n```c++\n/* \n * 向量（Vector）或点\n *\n * 使用原点到一个点 (x, y) 的有向线段表示向量\n * 从点 A 到点 B 的向量表示为 A - B\n */\ntypedef struct Vec\n{\n\tdouble x, y;\n\n\tVec(double x = 0, double y = 0) : x(x), y(y) {}\n\n\t// 相加\n\tVec operator+(const Vec &v) const\n\t{\n\t\treturn Vec(x + v.x, y - v.y);\n\t}\n\n\t// 相减\n\tVec operator-(const Vec &v) const\n\t{\n\t\treturn Vec(x - v.x, y - v.y);\n\t}\n\n\t// 数乘（伸长、缩短）\n\tVec operator*(double d) const\n\t{\n\t\treturn Vec(x * d, y * d);\n\t}\n\n\tVec operator/(const double d) const\n\t{\n\t\treturn Vec(x / d, y / d);\n\t}\n\n\t// 范数，用来比较长度，等于长度的平方\n\tdouble norm() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n} Pt;\n```\n\n为了方便阅读，我们定义类型点 `Pt` 为向量 `Vec` 的别名，在代码中区别「点」和「向量」。同时，应记住点与向量的运算中的类型：\n\n* 向量 $ + $ 向量 $ = $ 向量\n* 点 $ + $ 向量 $ = $ 点\n* 向量 $ \\times $ 数 $ = $ 向量\n\n### 向量乘法\n向量的乘法分为两种 —— 点乘（Dot）和叉乘（Cross）。\n\n#### 点乘\n向量的点乘表示为 $ \\boldsymbol{a} \\cdot \\boldsymbol{b} $，设 $ \\boldsymbol{a} = (x_1, y_1), \\boldsymbol{b} = (x_2, y_2) $，则\n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = x_1x_2 + y_1y_2 $$\n\n点乘的结果是一个标量，它表示 $ \\boldsymbol{a} $ 在 $ \\boldsymbol{b} $ 所在直线上的投影长度与 $ \\boldsymbol{b} $ 长度的乘积，即\n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\cos \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $$\n\n从上式中可以看出，因为 $ \\cos-\\alpha = \\cos \\alpha $，所以 $ \\cos \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle = \\cos \\langle \\boldsymbol{b}, \\boldsymbol{a} \\rangle $，即点乘**满足交换律**。\n\n#### 叉乘\n向量的叉乘表示为 $ \\boldsymbol{a} \\times \\boldsymbol{b} $，设 $ \\boldsymbol{a} = (x_1, y_1), \\boldsymbol{b} = (x_2, y_2) $，则\n\n$$ \\boldsymbol{a} \\times \\boldsymbol{b} = x_1y_2 - x_2y_1 $$\n\n叉乘的结果是一个标量，它表示以 $ \\boldsymbol{a} $ 与 $ \\boldsymbol{b} $ 为邻边的平行四边形的（有向）面积，即\n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $$\n\n![叉乘的几何意义](geometry-notes/1.svg)\n\n这个平行四边形可以以 $ \\boldsymbol{b} $ 为底，底边上的高即为 $ \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $。\n\n结果的符号与 $ \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $ 相同，即当 $ \\boldsymbol{b} $ 在 $ \\boldsymbol{a} $ 逆时针方向时，结果为正。\n\n如果需要求以两向量为两边的三角形面积，可以求出平行四边形面积后除以二。\n\n#### 代码实现\n```c++\n// 点乘\ndouble dot(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 叉乘\ndouble cross(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n```\n\n### 直线与线段\n用直线上的两个点表示直线，用线段的两端点表示线段。\n\n直线上的两个点组成的向量，被称为这条直线的一个**方向向量**。\n\n#### 点在直线上的判定\n如果点 $ P $ 在直线上，则以 $ \\overrightarrow{PA} $、$ \\overrightarrow{PB} $ 为邻边的平行四边形不存在（面积为零），即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} = 0 $。\n\n```c++\nbool include(const Pt &p) const\n{\n    return dcmp(cross(a - p, b - p));\n}\n```\n\n#### 判断两直线关系\n* 如果一条直线上的两个点都在另一条实现上，则两条直线重合；\n* 如果不重合的两条直线的方向向量叉乘得零（无法组成平行四边形），则两条直线平行。\n\n```c++\n// 两直线关系（交点个数）\n// 0 表示平行（无交点）\n// 1 表示相交（一个交点）\n// -1 表示重合（无数个交点）\nstatic int relation(const Line &a, const Line &b)\n{\n    if (a.include(b.a) && a.include(b.b)) return -1;\n    else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0;\n    else return 1;\n}\n```\n\n#### 求两直线交点\n在判断相交后，可以求两直线 $ AB $、$ CD $ 的交点。设其交点为 $ P $，分别过点 $ A $、$ B $ 作 $ CD $ 的垂线，连接 $ AB $、$ BC $、$ CD $、$ DA $。作向量 $ \\overrightarrow{AP} $，只需要求出 $ \\overrightarrow{AP} $，即可得到 $ P = A + \\overrightarrow{AP} $。\n\n![两直线交点](geometry-notes/5.svg)\n\n因为 $ \\angle AFP = \\angle BGP = 90 ^\\circ, \\angle APF = \\angle BPG $  \n所以 $ \\triangle AFP \\sim \\triangle BGP $  \n所以 $ \\frac{\\overrightarrow{AP}}{\\overrightarrow{PB}} = \\frac{|AF|}{|BG|} = \\frac{S_{\\triangle ACD}}{S_{\\triangle BCD}} $  \n即 $ \\frac{\\overrightarrow{AP}}{\\overrightarrow{AB}} = \\frac{\\overrightarrow{AP}}{\\overrightarrow{AP} + \\overrightarrow{PB}} = \\frac{S_{\\triangle ACD}}{S_{\\triangle ACD} + S_{\\triangle BCD}} = \\frac{2S_{\\triangle ACD}}{2S_{\\triangle ACD} + 2S_{\\triangle BCD}} $\n\n用叉乘计算面积，求出向量 $ \\overrightarrow{AP} $ 即可，注意计算面积时的方向。\n\n```c++\n// 求两直线交点（需要保证两直线有交点）\nstatic Pt intersect(const Line &a, const Line &b)\n{\n    double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b);\n    return a.a + (a.b - a.a) * s1 / (s1 + s2);\n}\n```\n\n#### 点在线段上的判定\n如果点 $ P $ 在线段 $ AB $ 所在的直线上，则以 $ \\overrightarrow{PA} $、$ \\overrightarrow{PB} $ 为邻边的平行四边形不存在（面积为零），即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} = 0 $。\n\n此时还需判断 $ P $ 是否在 $ A $ 与 $ B $ 之间。\n\n* 如果 $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} > 0 $，则表示 $ \\langle \\overrightarrow{PA}, \\overrightarrow{PB} \\rangle = 0 ^\\circ $（$ \\cos 0 ^\\circ = 1 > 0 $）；\n* 如果 $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} < 0 $，则表示 $ \\langle \\overrightarrow{PA}, \\overrightarrow{PB} \\rangle = \\pm180 ^\\circ $（$ \\cos \\pm180 ^\\circ = -1 $）；\n* 如果 $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} = 0 $，则表示 $ \\overrightarrow{PA} = 0 $ 或 $ \\overrightarrow{PB} = 0 $，即 $ P $ 与 $ A $ 或 $ B $ 重合。\n\n后两种情况表明点 $ P $ 在 $ AB $ 上。\n\n```c++\n// 线段包含点（点在线段上）\nbool include(const Pt &p) const\n{\n    // PA × PB = 0：PA 与 PB 共线，即点在线段所在的直线上\n    // PA · PB = 0：PA 与 PB 方向不同（A 和 B 分别在 P 的两边），如果 PA · PB = 0 则 P = A 或 P = B\n    return dcmp(cross(a - p, b - p)) && dot(a - p, b - p) <= 0;\n}\n```\n\n#### 线段相交 / 求交点\n求对应所在直线的交点，判断是否在线段上即可。\n\n### 多边形\n多边形（polygon）通常用顺时针或逆时针排列的顶点来表示。\n\n```c++\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n};\n```\n\n#### 点在多边形内的判定\n判断点是否在多边形内部，常使用**射线法**，即从该点引一条平行于 $ x $ 轴的射线，如果它与多边形有奇数个交点，则该点在多边形内，否则在多边形外。\n\n考虑相邻两个顶点 $ A $ 与 $ B $，判断由 $ P $ 引出的水平向右的射线有没有与线段 $ AB $ 相交。作向量 $ \\overrightarrow{PA}, \\overrightarrow{PB} $，分别过 $ A $、$ B $ 作 $ x $ 轴的垂线，垂足分别为 $ C $、$ D $，设 $ \\overrightarrow{CA} = d_1, \\overrightarrow{DB} = d_2 $\n\n如果 $ \\overrightarrow{PB} $ 在 $ \\overrightarrow{PA} $ 的顺时针方向上，即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} < 0 $，则需要 $ A $ 在 $ C $ 上方，$ B $ 在 $ D $ 下方，即 $ d_1 \\leq 0, d_2 > 0 $\n\n![点在多边形内 1](geometry-notes/2.svg)\n\n注意到 $ d_1 $ 可以为 $ 0 $，即射线穿过 $ A $ 被认为与当前边相交，因为可能会有这种情况\n\n![点在多边形内的特殊情况](geometry-notes/4.svg)\n\n此时不应认为 $ D $ 在多边形内，如果因为 $ B $ 被认为被射线穿过了一次，则会误判。解决方案是对于每一条边，只将射线穿过上方点（也可以取下方点）的情况下认为射线与边相交，这样 $ B $ 会被统计两次（或零次），不会影响判断。\n\n如果 $ \\overrightarrow{PB} $ 在 $ \\overrightarrow{PA} $ 的逆时针方向上，即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} > 0 $，则需要 $ A $ 在 $ C $ 下方，$ B $ 在 $ D $ 上方，即 $ d_1 < 0, d_2 \\geq 0 $。\n\n![点在多边形内 2](geometry-notes/3.svg)\n\n##### 代码实现\n```c++\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\tbool include(const Pt &p) const\n\t{\n\t\tint cnt = 0;\n\t\t// 判断与每条边有没有交点\n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// 枚举相邻的每两个点\n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\n\t\t\t// 如果点 P 在边 AB 上\n\t\t\tif (Seg(a, b).include(p)) return true;\n\n\t\t\t// 详见图\n\t\t\tdouble d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p);\n\t\t\tif ((tmp >= 0 && d1 >= 0 && d2 < 0) || (tmp <= 0 && d1 < 0 && d2 >= 0)) cnt++;\n\t\t}\n\n\t\t// 奇数的交点\n\t\treturn cnt % 2 == 1;\n\t}\n};\n```\n\n#### 多边形面积\n按顺序枚举每两个相邻的顶点，将每两个相邻的顶点与原点围成的三角形面积累加起来。因为所有不包含在多边形内的区域都被一正一负计算了偶数次，所以最终结果只包含多边形内的部分。\n\n![多边形面积](geometry-notes/6.svg)\n\n如图，浅蓝色部分被计算了两次，点 $ E $ 左下深色部分，在多边形内的部分被计算了三次，不在多边形内的部分被计算了四次，其它在多边形内部的部分被计算了一次。\n\n如果按照逆时针顺序枚举，则结果为正，否则结果为负。\n\n```c++\n// 多边形面积（有向面积）\ndouble area() const\n{\n    double res = 0;\n    for (size_t i = 0; i < pts.size(); i++)\n    {\n        // 枚举每两个点\n        const Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n        res += cross(a, b);\n    }\n    return res / 2;\n}\n```\n\n### 凸包\n在平面内，对于给定的一些点，包含这些点的最小凸多边形被称为**凸包**（Convex Hull）。\n\n求凸包的一种方法是 Graham's Scan，算法的流程为：\n\n1. 选出横坐标最小（横坐标相同时纵座标最小）的点，作为极点，该点一定在凸包上；\n2. 对其它点按照与极点的极角排序，极角相同的按照与极点的距离排序；\n3. 用栈维护当前在凸包上的点，按顺序考虑每一个点是否可以替换栈顶的点。\n\n这里极角是指，过极点 $ P $ 作水平向右的向量 $ \\boldsymbol{a} $，则点 $ A $ 的极角为 $ \\langle \\boldsymbol{a}, \\overrightarrow{PA} \\rangle $。比较两个点 $ A $、$ B $ 的极角，如果 $ \\overrightarrow{PA} $ 经过逆时针旋转到 $ \\overrightarrow{PB} $，即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} > 0 $，则 $ A $ 极角序较小。\n\n枚举每一个点，考虑新加入一个点的影响：\n\n![凸包](geometry-notes/7.svg)\n\n当前已被加入到凸包中的点为 $ A $（极点）、$ B $、$ C $、$ D $，考虑新加入点 $ E $ 的影响 —— $ \\overrightarrow{DE} $ 相对于 $ \\overrightarrow{CD} $ 向顺时针方向旋转了（即 $ \\overrightarrow{CD} \\times \\overrightarrow{DE} \\leq 0 $），此时这些边一定无法组成一个凸多边形。所以要将 $ D $ 点从凸包中删除，加入 $ E $ 点。这种情况我们称 $ DE $ 的连线不合法。\n\n加入一个点时，应当考虑与栈顶点的连线是否合法，如果不合法，则将栈顶点删除，继续考虑栈顶点，直到栈中只剩一个点或连线合法。\n\n```c++\n// 求凸包用的点\nint n;\nPt a[MAXN + 1];\n\n// 凸包极角排序的比较函数\ninline bool compare(const Pt &a, const Pt &b)\n{\n\t// 两个向量\n\tVec va = a - ::a[1], vb = b - ::a[1];\n\tdouble t = cross(va, vb);\n\tif (!dcmp(t)) return t > 0; // OA -> OB 是逆时针，则 A 极角序在先\n\telse return va.norm() < vb.norm(); // norm 较小的长度较小\n}\n\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\t// 求凸包（Convex），结果储存在自身 pts 中\n\tvoid convex()\n\t{\n\t\t// 找出最左下角的点\n\t\tint id = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i].x < a[id].x || (a[i].x == a[id].x && a[i].y < a[id].y)) id = i;\n\t\t}\n\t\tif (id != 1) std::swap(a[1], a[id]);\n\n\t\t// 排序\n\t\tstd::sort(a + 2, a + n + 1, &compare);\n\n\t\t// 极角序扫描\n\t\tpts.push_back(a[1]);\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\t// 比较，如果最后一个点需要被删掉则弹出（pop_back）\n\t\t\twhile (pts.size() >= 2 && cross(pts.back() - pts[pts.size() - 2], a[i] - pts.back()) <= 0) pts.pop_back();\n\t\t\tpts.push_back(a[i]);\n\t\t}\n\t}\n};\n```\n\n### 完整代码\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 100000;\nconst double EPS = 1e-8;\n\n// 带误差比较\ninline bool dcmp(double x, double y = 0)\n{\n\treturn fabs(x - y) <= EPS;\n}\n\n/* \n * 向量（Vector）或点\n *\n * 使用原点到一个点 (x, y) 的有向线段表示向量\n * 从点 A 到点 B 的向量表示为 A - B\n */\ntypedef struct Vec\n{\n\tdouble x, y;\n\n\tVec(double x = 0, double y = 0) : x(x), y(y) {}\n\n\t// 相加\n\tVec operator+(const Vec &v) const\n\t{\n\t\treturn Vec(x + v.x, y - v.y);\n\t}\n\n\t// 相减\n\tVec operator-(const Vec &v) const\n\t{\n\t\treturn Vec(x - v.x, y - v.y);\n\t}\n\n\t// 数乘（伸长、缩短）\n\tVec operator*(double d) const\n\t{\n\t\treturn Vec(x * d, y * d);\n\t}\n\n\tVec operator/(const double d) const\n\t{\n\t\treturn Vec(x / d, y / d);\n\t}\n\n\t// 范数，用来比较长度，等于长度的平方\n\tdouble norm() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n} Pt;\n\n// 点乘\ndouble dot(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 叉乘\ndouble cross(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 线段（Segment），用两个点表示\nstruct Seg\n{\n\tPt a, b;\n\n\tSeg(const Pt &a, const Pt &b) : a(a), b(b) {}\n\n\t// 线段包含点（点在线段上）\n\tbool include(const Pt &p)\n\t{\n\t\t// PA × PB = 0：PA 与 PB 共线，即点在线段所在的直线上\n\t\t// PA · PB = 0：PA 与 PB 方向不同（A 和 B 分别在 P 的两边），如果 PA · PB = 0 则 P = A 或 P = B\n\t\treturn dcmp(cross(a - p, b - p)) && dot(a - p, b - p) <= 0;\n\t}\n};\n\n// 直线，用两个点表示\nstruct Line\n{\n\tPt a, b;\n\n\tLine() {} // 提供一个不需要参数的构造函数\n\tLine(const Pt &a, const Pt &b) : a(a), b(b) {}\n\n\tbool include(const Pt &p) const\n\t{\n\t\treturn dcmp(cross(a - p, b - p));\n\t}\n\n\t// 两直线关系（交点个数）\n\t// 0 表示平行（无交点）\n\t// 1 表示相交（一个交点）\n\t// -1 表示重合（无数个交点）\n\tstatic int relation(const Line &a, const Line &b)\n\t{\n\t\tif (a.include(b.a) && a.include(b.b)) return -1;\n\t\telse if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0;\n\t\telse return 1;\n\t}\n\n\t// 求两直线交点（需要保证两直线有交点）\n\tstatic Pt intersect(const Line &a, const Line &b)\n\t{\n\t\tdouble s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b);\n\t\treturn a.a + (a.b - a.a) * s1 / (s1 + s2);\n\t}\n};\n\n// 求凸包用的点\nint n;\nPt a[MAXN + 1];\n\n// 凸包极角排序的比较函数\ninline bool compare(const Pt &a, const Pt &b)\n{\n\t// 两个向量\n\tVec va = a - ::a[1], vb = b - ::a[1];\n\tdouble t = cross(va, vb);\n\tif (!dcmp(t)) return t > 0; // OA -> OB 是逆时针，则 A 极角序在先\n\telse return va.norm() < vb.norm(); // norm 较小的长度较小\n}\n\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\tbool include(const Pt &p) const\n\t{\n\t\tint cnt = 0;\n\t\t// 判断与每条边有没有交点\n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// 枚举相邻的每两个点\n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\n\t\t\t// 如果点 P 在边 AB 上\n\t\t\tif (Seg(a, b).include(p)) return true;\n\n\t\t\t// 详见图\n\t\t\tdouble d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p);\n\t\t\tif ((tmp >= 0 && d1 >= 0 && d2 < 0) || (tmp <= 0 && d1 < 0 && d2 >= 0)) cnt++;\n\t\t}\n\n\t\t// 奇数的交点\n\t\treturn cnt % 2 == 1;\n\t}\n\n\t// 多边形面积（有向面积）\n\tdouble area() const\n\t{\n\t\tdouble res = 0;\n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// 枚举每两个点\n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\t\t\tres += cross(a, b);\n\t\t}\n\t\treturn res / 2;\n\t}\n\n\t// 求凸包（Convex），结果储存在自身 pts 中\n\tvoid convex()\n\t{\n\t\t// 找出最左下角的点\n\t\tint id = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i].x < a[id].x || (a[i].x == a[id].x && a[i].y < a[id].y)) id = i;\n\t\t}\n\t\tif (id != 1) std::swap(a[1], a[id]);\n\n\t\t// 排序\n\t\tstd::sort(a + 2, a + n + 1, &compare);\n\n\t\t// 极角序扫描\n\t\tpts.push_back(a[1]);\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\t// 比较，如果最后一个点需要被删掉则弹出（pop_back）\n\t\t\twhile (pts.size() >= 2 && cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) >= 0) pts.pop_back();\n\t\t\tpts.push_back(a[i]);\n\t\t}\n\t}\n};\n```\n","source":"_posts/geometry-notes.md","raw":"title: 计算几何学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 计算几何\n  - 数学\n  - 算法模板\npermalink: geometry-notes\ndate: 2017-01-06 16:30:00\n---\n\n计算几何（Computational Geometry），是一系列使用计算机解决几何问题的算法。与解析几何相比，计算几何更适合计算机运算，精度较高，运算速度较快，并且易于编写。\n\n本文只包含二维计算几何在 OI 中的部分应用。\n\n<!-- more -->\n\n### 浮点误差\n程序设计中，考虑到浮点数 `double` 有精度误差，在比较时，通常允许一定的误差，即对于两个数 $ a $、$ b $，如果 $ | a - b | \\leq d $，则认为 $ a = b $。一般根据题目要求，$ d $（代码中命名为 `EPS`）取一个较小值，如 $ 10 ^ {-8} $。\n\n```c++\nconst double EPS = 1e-8;\n\n// 带误差比较，返回 x 是否等于 y\ninline bool dcmp(double x, double y = 0)\n{\n\treturn fabs(x - y) <= EPS;\n}\n```\n\n### 向量\n向量（vector）是一个有大小和方向的量，在几何中，它被表示为带箭头的线段。向量可以用**起点**和**终点**的坐标来表示 —— 从点 $ A $ 到点 $ B $ 的向量表示为 $ \\overrightarrow{AB} $。\n\n向量的书写，两个大写字母上加一个箭头（表示方向）$ \\overrightarrow{AB} $，或者加粗的小写字母 $ \\boldsymbol{a} $。\n\n向量没有位置，即向量可以在平面内任意平移而保持其本身的性质不变 —— 所以我们可以将向量平移至其起点与原点 $ (0, 0) $ 重合，用终点坐标表示这个向量，下文称此方法为**坐标表示法**，除特殊说明外，下文表示向量均使用此方法。\n\n两个向量的夹角 $ \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $ 定义为从 $ \\boldsymbol{a} $ 旋转到 $ \\boldsymbol{b} $ 所经过的角度，逆时针为正，顺时针为负。\n\n向量范数（norm），这里简单定义向量 $ \\overrightarrow{AB} = (x, y) $ 的范数为 $ x ^ 2 + y ^ 2 $，即长度的平方 $ | \\overrightarrow{AB} | ^ 2 $。这样定义的好处是，可以方便地比较两个向量的长度，而不需要开平方。\n\n与向量相对的概念是**标量**（scalar），标量只有大小没有方向。\n\n### 向量的基本运算\n两个向量相加，遵循平行四边形定则（或三角形定则），$ (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2) $。\n\n两个向量相减与相加类似，除此之外，点可以加减一个向量，表示将点按照向量所指向的方向进行平移。\n\n向量的数乘，将一个向量乘或除以 $ k $，表示将向量所对应的有向线段长度变为原来的 $ k $ 倍或 $ k $ 分之一。\n\n可以发现，向量和点的运算是相似的，在程序中，可以使用同一种类型来表示向量和点：\n\n```c++\n/* \n * 向量（Vector）或点\n *\n * 使用原点到一个点 (x, y) 的有向线段表示向量\n * 从点 A 到点 B 的向量表示为 A - B\n */\ntypedef struct Vec\n{\n\tdouble x, y;\n\n\tVec(double x = 0, double y = 0) : x(x), y(y) {}\n\n\t// 相加\n\tVec operator+(const Vec &v) const\n\t{\n\t\treturn Vec(x + v.x, y - v.y);\n\t}\n\n\t// 相减\n\tVec operator-(const Vec &v) const\n\t{\n\t\treturn Vec(x - v.x, y - v.y);\n\t}\n\n\t// 数乘（伸长、缩短）\n\tVec operator*(double d) const\n\t{\n\t\treturn Vec(x * d, y * d);\n\t}\n\n\tVec operator/(const double d) const\n\t{\n\t\treturn Vec(x / d, y / d);\n\t}\n\n\t// 范数，用来比较长度，等于长度的平方\n\tdouble norm() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n} Pt;\n```\n\n为了方便阅读，我们定义类型点 `Pt` 为向量 `Vec` 的别名，在代码中区别「点」和「向量」。同时，应记住点与向量的运算中的类型：\n\n* 向量 $ + $ 向量 $ = $ 向量\n* 点 $ + $ 向量 $ = $ 点\n* 向量 $ \\times $ 数 $ = $ 向量\n\n### 向量乘法\n向量的乘法分为两种 —— 点乘（Dot）和叉乘（Cross）。\n\n#### 点乘\n向量的点乘表示为 $ \\boldsymbol{a} \\cdot \\boldsymbol{b} $，设 $ \\boldsymbol{a} = (x_1, y_1), \\boldsymbol{b} = (x_2, y_2) $，则\n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = x_1x_2 + y_1y_2 $$\n\n点乘的结果是一个标量，它表示 $ \\boldsymbol{a} $ 在 $ \\boldsymbol{b} $ 所在直线上的投影长度与 $ \\boldsymbol{b} $ 长度的乘积，即\n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\cos \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $$\n\n从上式中可以看出，因为 $ \\cos-\\alpha = \\cos \\alpha $，所以 $ \\cos \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle = \\cos \\langle \\boldsymbol{b}, \\boldsymbol{a} \\rangle $，即点乘**满足交换律**。\n\n#### 叉乘\n向量的叉乘表示为 $ \\boldsymbol{a} \\times \\boldsymbol{b} $，设 $ \\boldsymbol{a} = (x_1, y_1), \\boldsymbol{b} = (x_2, y_2) $，则\n\n$$ \\boldsymbol{a} \\times \\boldsymbol{b} = x_1y_2 - x_2y_1 $$\n\n叉乘的结果是一个标量，它表示以 $ \\boldsymbol{a} $ 与 $ \\boldsymbol{b} $ 为邻边的平行四边形的（有向）面积，即\n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $$\n\n![叉乘的几何意义](geometry-notes/1.svg)\n\n这个平行四边形可以以 $ \\boldsymbol{b} $ 为底，底边上的高即为 $ \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $。\n\n结果的符号与 $ \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $ 相同，即当 $ \\boldsymbol{b} $ 在 $ \\boldsymbol{a} $ 逆时针方向时，结果为正。\n\n如果需要求以两向量为两边的三角形面积，可以求出平行四边形面积后除以二。\n\n#### 代码实现\n```c++\n// 点乘\ndouble dot(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 叉乘\ndouble cross(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n```\n\n### 直线与线段\n用直线上的两个点表示直线，用线段的两端点表示线段。\n\n直线上的两个点组成的向量，被称为这条直线的一个**方向向量**。\n\n#### 点在直线上的判定\n如果点 $ P $ 在直线上，则以 $ \\overrightarrow{PA} $、$ \\overrightarrow{PB} $ 为邻边的平行四边形不存在（面积为零），即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} = 0 $。\n\n```c++\nbool include(const Pt &p) const\n{\n    return dcmp(cross(a - p, b - p));\n}\n```\n\n#### 判断两直线关系\n* 如果一条直线上的两个点都在另一条实现上，则两条直线重合；\n* 如果不重合的两条直线的方向向量叉乘得零（无法组成平行四边形），则两条直线平行。\n\n```c++\n// 两直线关系（交点个数）\n// 0 表示平行（无交点）\n// 1 表示相交（一个交点）\n// -1 表示重合（无数个交点）\nstatic int relation(const Line &a, const Line &b)\n{\n    if (a.include(b.a) && a.include(b.b)) return -1;\n    else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0;\n    else return 1;\n}\n```\n\n#### 求两直线交点\n在判断相交后，可以求两直线 $ AB $、$ CD $ 的交点。设其交点为 $ P $，分别过点 $ A $、$ B $ 作 $ CD $ 的垂线，连接 $ AB $、$ BC $、$ CD $、$ DA $。作向量 $ \\overrightarrow{AP} $，只需要求出 $ \\overrightarrow{AP} $，即可得到 $ P = A + \\overrightarrow{AP} $。\n\n![两直线交点](geometry-notes/5.svg)\n\n因为 $ \\angle AFP = \\angle BGP = 90 ^\\circ, \\angle APF = \\angle BPG $  \n所以 $ \\triangle AFP \\sim \\triangle BGP $  \n所以 $ \\frac{\\overrightarrow{AP}}{\\overrightarrow{PB}} = \\frac{|AF|}{|BG|} = \\frac{S_{\\triangle ACD}}{S_{\\triangle BCD}} $  \n即 $ \\frac{\\overrightarrow{AP}}{\\overrightarrow{AB}} = \\frac{\\overrightarrow{AP}}{\\overrightarrow{AP} + \\overrightarrow{PB}} = \\frac{S_{\\triangle ACD}}{S_{\\triangle ACD} + S_{\\triangle BCD}} = \\frac{2S_{\\triangle ACD}}{2S_{\\triangle ACD} + 2S_{\\triangle BCD}} $\n\n用叉乘计算面积，求出向量 $ \\overrightarrow{AP} $ 即可，注意计算面积时的方向。\n\n```c++\n// 求两直线交点（需要保证两直线有交点）\nstatic Pt intersect(const Line &a, const Line &b)\n{\n    double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b);\n    return a.a + (a.b - a.a) * s1 / (s1 + s2);\n}\n```\n\n#### 点在线段上的判定\n如果点 $ P $ 在线段 $ AB $ 所在的直线上，则以 $ \\overrightarrow{PA} $、$ \\overrightarrow{PB} $ 为邻边的平行四边形不存在（面积为零），即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} = 0 $。\n\n此时还需判断 $ P $ 是否在 $ A $ 与 $ B $ 之间。\n\n* 如果 $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} > 0 $，则表示 $ \\langle \\overrightarrow{PA}, \\overrightarrow{PB} \\rangle = 0 ^\\circ $（$ \\cos 0 ^\\circ = 1 > 0 $）；\n* 如果 $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} < 0 $，则表示 $ \\langle \\overrightarrow{PA}, \\overrightarrow{PB} \\rangle = \\pm180 ^\\circ $（$ \\cos \\pm180 ^\\circ = -1 $）；\n* 如果 $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} = 0 $，则表示 $ \\overrightarrow{PA} = 0 $ 或 $ \\overrightarrow{PB} = 0 $，即 $ P $ 与 $ A $ 或 $ B $ 重合。\n\n后两种情况表明点 $ P $ 在 $ AB $ 上。\n\n```c++\n// 线段包含点（点在线段上）\nbool include(const Pt &p) const\n{\n    // PA × PB = 0：PA 与 PB 共线，即点在线段所在的直线上\n    // PA · PB = 0：PA 与 PB 方向不同（A 和 B 分别在 P 的两边），如果 PA · PB = 0 则 P = A 或 P = B\n    return dcmp(cross(a - p, b - p)) && dot(a - p, b - p) <= 0;\n}\n```\n\n#### 线段相交 / 求交点\n求对应所在直线的交点，判断是否在线段上即可。\n\n### 多边形\n多边形（polygon）通常用顺时针或逆时针排列的顶点来表示。\n\n```c++\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n};\n```\n\n#### 点在多边形内的判定\n判断点是否在多边形内部，常使用**射线法**，即从该点引一条平行于 $ x $ 轴的射线，如果它与多边形有奇数个交点，则该点在多边形内，否则在多边形外。\n\n考虑相邻两个顶点 $ A $ 与 $ B $，判断由 $ P $ 引出的水平向右的射线有没有与线段 $ AB $ 相交。作向量 $ \\overrightarrow{PA}, \\overrightarrow{PB} $，分别过 $ A $、$ B $ 作 $ x $ 轴的垂线，垂足分别为 $ C $、$ D $，设 $ \\overrightarrow{CA} = d_1, \\overrightarrow{DB} = d_2 $\n\n如果 $ \\overrightarrow{PB} $ 在 $ \\overrightarrow{PA} $ 的顺时针方向上，即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} < 0 $，则需要 $ A $ 在 $ C $ 上方，$ B $ 在 $ D $ 下方，即 $ d_1 \\leq 0, d_2 > 0 $\n\n![点在多边形内 1](geometry-notes/2.svg)\n\n注意到 $ d_1 $ 可以为 $ 0 $，即射线穿过 $ A $ 被认为与当前边相交，因为可能会有这种情况\n\n![点在多边形内的特殊情况](geometry-notes/4.svg)\n\n此时不应认为 $ D $ 在多边形内，如果因为 $ B $ 被认为被射线穿过了一次，则会误判。解决方案是对于每一条边，只将射线穿过上方点（也可以取下方点）的情况下认为射线与边相交，这样 $ B $ 会被统计两次（或零次），不会影响判断。\n\n如果 $ \\overrightarrow{PB} $ 在 $ \\overrightarrow{PA} $ 的逆时针方向上，即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} > 0 $，则需要 $ A $ 在 $ C $ 下方，$ B $ 在 $ D $ 上方，即 $ d_1 < 0, d_2 \\geq 0 $。\n\n![点在多边形内 2](geometry-notes/3.svg)\n\n##### 代码实现\n```c++\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\tbool include(const Pt &p) const\n\t{\n\t\tint cnt = 0;\n\t\t// 判断与每条边有没有交点\n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// 枚举相邻的每两个点\n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\n\t\t\t// 如果点 P 在边 AB 上\n\t\t\tif (Seg(a, b).include(p)) return true;\n\n\t\t\t// 详见图\n\t\t\tdouble d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p);\n\t\t\tif ((tmp >= 0 && d1 >= 0 && d2 < 0) || (tmp <= 0 && d1 < 0 && d2 >= 0)) cnt++;\n\t\t}\n\n\t\t// 奇数的交点\n\t\treturn cnt % 2 == 1;\n\t}\n};\n```\n\n#### 多边形面积\n按顺序枚举每两个相邻的顶点，将每两个相邻的顶点与原点围成的三角形面积累加起来。因为所有不包含在多边形内的区域都被一正一负计算了偶数次，所以最终结果只包含多边形内的部分。\n\n![多边形面积](geometry-notes/6.svg)\n\n如图，浅蓝色部分被计算了两次，点 $ E $ 左下深色部分，在多边形内的部分被计算了三次，不在多边形内的部分被计算了四次，其它在多边形内部的部分被计算了一次。\n\n如果按照逆时针顺序枚举，则结果为正，否则结果为负。\n\n```c++\n// 多边形面积（有向面积）\ndouble area() const\n{\n    double res = 0;\n    for (size_t i = 0; i < pts.size(); i++)\n    {\n        // 枚举每两个点\n        const Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n        res += cross(a, b);\n    }\n    return res / 2;\n}\n```\n\n### 凸包\n在平面内，对于给定的一些点，包含这些点的最小凸多边形被称为**凸包**（Convex Hull）。\n\n求凸包的一种方法是 Graham's Scan，算法的流程为：\n\n1. 选出横坐标最小（横坐标相同时纵座标最小）的点，作为极点，该点一定在凸包上；\n2. 对其它点按照与极点的极角排序，极角相同的按照与极点的距离排序；\n3. 用栈维护当前在凸包上的点，按顺序考虑每一个点是否可以替换栈顶的点。\n\n这里极角是指，过极点 $ P $ 作水平向右的向量 $ \\boldsymbol{a} $，则点 $ A $ 的极角为 $ \\langle \\boldsymbol{a}, \\overrightarrow{PA} \\rangle $。比较两个点 $ A $、$ B $ 的极角，如果 $ \\overrightarrow{PA} $ 经过逆时针旋转到 $ \\overrightarrow{PB} $，即 $ \\overrightarrow{PA} \\times \\overrightarrow{PB} > 0 $，则 $ A $ 极角序较小。\n\n枚举每一个点，考虑新加入一个点的影响：\n\n![凸包](geometry-notes/7.svg)\n\n当前已被加入到凸包中的点为 $ A $（极点）、$ B $、$ C $、$ D $，考虑新加入点 $ E $ 的影响 —— $ \\overrightarrow{DE} $ 相对于 $ \\overrightarrow{CD} $ 向顺时针方向旋转了（即 $ \\overrightarrow{CD} \\times \\overrightarrow{DE} \\leq 0 $），此时这些边一定无法组成一个凸多边形。所以要将 $ D $ 点从凸包中删除，加入 $ E $ 点。这种情况我们称 $ DE $ 的连线不合法。\n\n加入一个点时，应当考虑与栈顶点的连线是否合法，如果不合法，则将栈顶点删除，继续考虑栈顶点，直到栈中只剩一个点或连线合法。\n\n```c++\n// 求凸包用的点\nint n;\nPt a[MAXN + 1];\n\n// 凸包极角排序的比较函数\ninline bool compare(const Pt &a, const Pt &b)\n{\n\t// 两个向量\n\tVec va = a - ::a[1], vb = b - ::a[1];\n\tdouble t = cross(va, vb);\n\tif (!dcmp(t)) return t > 0; // OA -> OB 是逆时针，则 A 极角序在先\n\telse return va.norm() < vb.norm(); // norm 较小的长度较小\n}\n\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\t// 求凸包（Convex），结果储存在自身 pts 中\n\tvoid convex()\n\t{\n\t\t// 找出最左下角的点\n\t\tint id = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i].x < a[id].x || (a[i].x == a[id].x && a[i].y < a[id].y)) id = i;\n\t\t}\n\t\tif (id != 1) std::swap(a[1], a[id]);\n\n\t\t// 排序\n\t\tstd::sort(a + 2, a + n + 1, &compare);\n\n\t\t// 极角序扫描\n\t\tpts.push_back(a[1]);\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\t// 比较，如果最后一个点需要被删掉则弹出（pop_back）\n\t\t\twhile (pts.size() >= 2 && cross(pts.back() - pts[pts.size() - 2], a[i] - pts.back()) <= 0) pts.pop_back();\n\t\t\tpts.push_back(a[i]);\n\t\t}\n\t}\n};\n```\n\n### 完整代码\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 100000;\nconst double EPS = 1e-8;\n\n// 带误差比较\ninline bool dcmp(double x, double y = 0)\n{\n\treturn fabs(x - y) <= EPS;\n}\n\n/* \n * 向量（Vector）或点\n *\n * 使用原点到一个点 (x, y) 的有向线段表示向量\n * 从点 A 到点 B 的向量表示为 A - B\n */\ntypedef struct Vec\n{\n\tdouble x, y;\n\n\tVec(double x = 0, double y = 0) : x(x), y(y) {}\n\n\t// 相加\n\tVec operator+(const Vec &v) const\n\t{\n\t\treturn Vec(x + v.x, y - v.y);\n\t}\n\n\t// 相减\n\tVec operator-(const Vec &v) const\n\t{\n\t\treturn Vec(x - v.x, y - v.y);\n\t}\n\n\t// 数乘（伸长、缩短）\n\tVec operator*(double d) const\n\t{\n\t\treturn Vec(x * d, y * d);\n\t}\n\n\tVec operator/(const double d) const\n\t{\n\t\treturn Vec(x / d, y / d);\n\t}\n\n\t// 范数，用来比较长度，等于长度的平方\n\tdouble norm() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n} Pt;\n\n// 点乘\ndouble dot(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// 叉乘\ndouble cross(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// 线段（Segment），用两个点表示\nstruct Seg\n{\n\tPt a, b;\n\n\tSeg(const Pt &a, const Pt &b) : a(a), b(b) {}\n\n\t// 线段包含点（点在线段上）\n\tbool include(const Pt &p)\n\t{\n\t\t// PA × PB = 0：PA 与 PB 共线，即点在线段所在的直线上\n\t\t// PA · PB = 0：PA 与 PB 方向不同（A 和 B 分别在 P 的两边），如果 PA · PB = 0 则 P = A 或 P = B\n\t\treturn dcmp(cross(a - p, b - p)) && dot(a - p, b - p) <= 0;\n\t}\n};\n\n// 直线，用两个点表示\nstruct Line\n{\n\tPt a, b;\n\n\tLine() {} // 提供一个不需要参数的构造函数\n\tLine(const Pt &a, const Pt &b) : a(a), b(b) {}\n\n\tbool include(const Pt &p) const\n\t{\n\t\treturn dcmp(cross(a - p, b - p));\n\t}\n\n\t// 两直线关系（交点个数）\n\t// 0 表示平行（无交点）\n\t// 1 表示相交（一个交点）\n\t// -1 表示重合（无数个交点）\n\tstatic int relation(const Line &a, const Line &b)\n\t{\n\t\tif (a.include(b.a) && a.include(b.b)) return -1;\n\t\telse if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0;\n\t\telse return 1;\n\t}\n\n\t// 求两直线交点（需要保证两直线有交点）\n\tstatic Pt intersect(const Line &a, const Line &b)\n\t{\n\t\tdouble s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b);\n\t\treturn a.a + (a.b - a.a) * s1 / (s1 + s2);\n\t}\n};\n\n// 求凸包用的点\nint n;\nPt a[MAXN + 1];\n\n// 凸包极角排序的比较函数\ninline bool compare(const Pt &a, const Pt &b)\n{\n\t// 两个向量\n\tVec va = a - ::a[1], vb = b - ::a[1];\n\tdouble t = cross(va, vb);\n\tif (!dcmp(t)) return t > 0; // OA -> OB 是逆时针，则 A 极角序在先\n\telse return va.norm() < vb.norm(); // norm 较小的长度较小\n}\n\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\tbool include(const Pt &p) const\n\t{\n\t\tint cnt = 0;\n\t\t// 判断与每条边有没有交点\n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// 枚举相邻的每两个点\n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\n\t\t\t// 如果点 P 在边 AB 上\n\t\t\tif (Seg(a, b).include(p)) return true;\n\n\t\t\t// 详见图\n\t\t\tdouble d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p);\n\t\t\tif ((tmp >= 0 && d1 >= 0 && d2 < 0) || (tmp <= 0 && d1 < 0 && d2 >= 0)) cnt++;\n\t\t}\n\n\t\t// 奇数的交点\n\t\treturn cnt % 2 == 1;\n\t}\n\n\t// 多边形面积（有向面积）\n\tdouble area() const\n\t{\n\t\tdouble res = 0;\n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// 枚举每两个点\n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\t\t\tres += cross(a, b);\n\t\t}\n\t\treturn res / 2;\n\t}\n\n\t// 求凸包（Convex），结果储存在自身 pts 中\n\tvoid convex()\n\t{\n\t\t// 找出最左下角的点\n\t\tint id = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i].x < a[id].x || (a[i].x == a[id].x && a[i].y < a[id].y)) id = i;\n\t\t}\n\t\tif (id != 1) std::swap(a[1], a[id]);\n\n\t\t// 排序\n\t\tstd::sort(a + 2, a + n + 1, &compare);\n\n\t\t// 极角序扫描\n\t\tpts.push_back(a[1]);\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\t// 比较，如果最后一个点需要被删掉则弹出（pop_back）\n\t\t\twhile (pts.size() >= 2 && cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) >= 0) pts.pop_back();\n\t\t\tpts.push_back(a[i]);\n\t\t}\n\t}\n};\n```\n","slug":"geometry-notes","published":1,"updated":"2017-01-06T08:43:19.588Z","_id":"cixlg9s1m0157ooxlhi08t0uw","comments":1,"layout":"post","photos":[],"link":""},{"title":"「FJOI2007」轮状病毒 - 高精度","date":"2016-10-17T02:54:00.000Z","_content":"\n一个 $ N $ 轮状基由圆环上 $ N $ 个不同的基原子和圆心处一个核原子构成的，2 个原子之间的边表示这 2 个原子之间的信息通道。 $ N $ 轮状病毒的产生规律是在一个 $ N $ 轮状基中删去若干条边，使得各原子之间有唯一的信息通道，编程计算有多少个不同的 $ N $ 轮状病毒。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002)\n\n### 题解\n公式：$ f(i) = 3f(i - 1) - f(i - 2) + 2 $\n\n需要高精度。\n\n### 代码\n```c++\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MAXN = 100;\n\nstruct BigInt {\n\tstd::vector<int> v;\n\n\tBigInt(const int n = 0) { *this = n; }\n\tBigInt(const std::string &s) { *this = s; }\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n\n\tBigInt &operator=(const std::string &s) {\n\t\tv.resize(s.length());\n\t\tfor (size_t i = 0; i < s.length(); i++) v[i] = s[s.length() - i - 1] - '0';\n\t}\n\n\tvoid print() {\n\t\tfor (int i = v.size() - 1; i >= 0; i--) printf(\"%d\", v[i]);\n\t\tputchar('\\n');\n\t}\n};\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t += b.v[i];\n\t\tif (flag) t++, flag = false;\n\t\tif (t >= 10) t -= 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\tif (flag) res.v.push_back(1);\n\treturn res;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t -= b.v[i];\n\t\tif (flag) t--, flag = false;\n\t\tif (t < 0) t += 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\treturn res;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.resize(a.v.size() + b.v.size() + 1);\n\tfor (size_t i = 0; i < a.v.size(); i++) {\n\t\tfor (size_t j = 0; j < b.v.size(); j++) {\n\t\t\tres.v[i + j] += a.v[i] * b.v[j];\n\t\t\tres.v[i + j + 1] += res.v[i + j] / 10;\n\t\t\tres.v[i + j] %= 10;\n\t\t}\n\t}\n\twhile (res.v.size() > 1 && res.v.back() == 0) res.v.pop_back();\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBigInt f[MAXN + 1];\n\tf[1] = 1, f[2] = 5;\n\tfor (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2;\n\tf[n].print();\n\treturn 0;\n}\n```\n","source":"_posts/fjoi2007-wheel.md","raw":"title: 「FJOI2007」轮状病毒 - 高精度\ncategories: OI\ntags: \n  - BZOJ\n  - FJOI\n  - 高精度\npermalink: fjoi2007-wheel\ndate: 2016-10-17 10:54:00\n---\n\n一个 $ N $ 轮状基由圆环上 $ N $ 个不同的基原子和圆心处一个核原子构成的，2 个原子之间的边表示这 2 个原子之间的信息通道。 $ N $ 轮状病毒的产生规律是在一个 $ N $ 轮状基中删去若干条边，使得各原子之间有唯一的信息通道，编程计算有多少个不同的 $ N $ 轮状病毒。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002)\n\n### 题解\n公式：$ f(i) = 3f(i - 1) - f(i - 2) + 2 $\n\n需要高精度。\n\n### 代码\n```c++\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MAXN = 100;\n\nstruct BigInt {\n\tstd::vector<int> v;\n\n\tBigInt(const int n = 0) { *this = n; }\n\tBigInt(const std::string &s) { *this = s; }\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n\n\tBigInt &operator=(const std::string &s) {\n\t\tv.resize(s.length());\n\t\tfor (size_t i = 0; i < s.length(); i++) v[i] = s[s.length() - i - 1] - '0';\n\t}\n\n\tvoid print() {\n\t\tfor (int i = v.size() - 1; i >= 0; i--) printf(\"%d\", v[i]);\n\t\tputchar('\\n');\n\t}\n};\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t += b.v[i];\n\t\tif (flag) t++, flag = false;\n\t\tif (t >= 10) t -= 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\tif (flag) res.v.push_back(1);\n\treturn res;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t -= b.v[i];\n\t\tif (flag) t--, flag = false;\n\t\tif (t < 0) t += 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\treturn res;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.resize(a.v.size() + b.v.size() + 1);\n\tfor (size_t i = 0; i < a.v.size(); i++) {\n\t\tfor (size_t j = 0; j < b.v.size(); j++) {\n\t\t\tres.v[i + j] += a.v[i] * b.v[j];\n\t\t\tres.v[i + j + 1] += res.v[i + j] / 10;\n\t\t\tres.v[i + j] %= 10;\n\t\t}\n\t}\n\twhile (res.v.size() > 1 && res.v.back() == 0) res.v.pop_back();\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBigInt f[MAXN + 1];\n\tf[1] = 1, f[2] = 5;\n\tfor (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2;\n\tf[n].print();\n\treturn 0;\n}\n```\n","slug":"fjoi2007-wheel","published":1,"updated":"2016-10-17T09:26:27.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s2d015eooxloob8hphs"},{"title":"从傅里叶变换到数论变换","date":"2016-06-17T13:38:00.000Z","_content":"\nFFT 可以用来计算多项式乘法，但复数的运算会产生浮点误差。对于只有整数参与的多项式运算，有时，使用数论变换（Number-Theoretic Transform）会是更好的选择。\n\n<!-- more -->\n\n### 原根\nFFT 中，我们使用单位复根 $ \\omega_n ^ k = \\cos \\frac{2 \\pi}{n}k + i \\sin\\frac{2 \\pi}{n}k $。我们需要单位复根的以下性质。\n\n1. $ \\omega_n ^ t (0 \\leq t \\leq n - 1) $ 互不相同，保证点值表示的合法；\n2. $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $，用于分治；\n3. $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $，用于分治；\n3. 当 $ k \\neq 0 $ 时，$ 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} = 0 $，用于逆变换。\n\n在数论中，考虑一个质数 $ p = qn + 1 $（其中 $ n $ 为 $ 2 $ 的幂）。定义其**原根** $ g $ 为使得 $ g ^ i(0 \\leq i \\leq p - 1) $ 互不相同的数。\n\n#### 性质一\n\n令 $ \\omega_n = g ^ q $，由于 $ 1,\\ g ^ q,\\ g ^ {2q},\\ \\dots,\\ g ^ {(n - 1)q} $ 互不相同，满足**性质一**。\n\n#### 性质二\n\n由 $ \\omega_n = g ^ q $ 可知 $ \\omega_{2n} = g ^ { \\frac{q}{2} } $（$ p = \\frac{q}{2} \\times 2n + 1 $），故 $ \\omega_{2n} ^ {2k} = g ^ {2k \\frac{q}{2} } = g ^ {kq} = \\omega_n ^ k $，满足**性质二**。\n\n#### 性质三\n\n根据费马小定理得\n\n$$ \\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \\equiv 1 \\pmod p $$\n\n又因为 $ (\\omega_{n} ^ { \\frac{n}{2} }) ^ 2 = \\omega_n ^ n $，所以 $ \\omega_n ^ { \\frac{n}{2} } \\equiv \\pm 1 \\pmod p $，而根据性质一可得 $ \\omega_n ^ { \\frac{n}{2} } \\neq \\omega_n ^ 0 \\ $，即 $ \\omega_n ^ { \\frac{n}{2} } \\equiv -1 \\pmod p $。可推出 $ \\omega_n ^ { k + \\frac{n}{2} } = \\omega_n ^ k \\times \\omega_n ^ { \\frac{n}{2} } \\equiv -\\omega_n ^ k \\pmod p $，满足**性质三**。\n\n#### 性质四\n当 $ k \\neq 0 $ 时\n\n$$\n\\begin{aligned}\nS(\\omega_n ^ k) &= 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} \\\\\n\\omega_n ^ k S(\\omega_n ^ k) &= \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n \\\\\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{aligned}\n$$\n\n由**性质三**中的推论可知，$ (\\omega_n ^ k) ^ n - 1 \\equiv 0 \\pmod p $，故 $ S(\\omega_n ^ k) \\equiv 0  \\pmod p $，**性质四**成立。\n\n### 求原根\n求一个质数的原根，可以使用枚举法 —— 枚举 $ g $，检验 $ g $ 是否为 $ p $ 的原根。\n\n> 对于一个数 $ g $，最小的满足 $ g ^ k \\equiv 1 \\pmod p $ 的正整数 $ k $ 一定是 $ p - 1 $ 的约数。\n\n证明：假设最小的 $ k $ 不是 $ p - 1 $ 的约数，找到 $ x $ 满足 $ xk > p - 1 > (x - 1)k $，由费马小定理可知\n\n$$ g ^ {xk} \\equiv g ^ {p - 1} \\equiv 1 \\equiv g ^ {xk - (p - 1)} \\pmod p $$\n\n$ xk - (p - 1) < k $，与假设矛盾。\n\n检验时，只需要枚举 $ p - 1 $ 的所有约数 $ q $，检验 $ g ^ q \\not\\equiv 1 \\pmod p $ 即可。\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n```\n\n### 模板\n把原有的复数运算改为模意义下的运算即可。\n\n注意 $ \\div n $ 要改为 $ \\times n ^ {-1} $。\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n} ntt;\n```\n","source":"_posts/fft-to-ntt.md","raw":"title: 从傅里叶变换到数论变换\ncategories: OI\ntags: \n  - 数学\n  - 学习笔记\n  - 算法模板\n  - 多项式\n  - 数论\n  - 原根\npermalink: fft-to-ntt\ndate: 2016-06-17 21:38:00\n---\n\nFFT 可以用来计算多项式乘法，但复数的运算会产生浮点误差。对于只有整数参与的多项式运算，有时，使用数论变换（Number-Theoretic Transform）会是更好的选择。\n\n<!-- more -->\n\n### 原根\nFFT 中，我们使用单位复根 $ \\omega_n ^ k = \\cos \\frac{2 \\pi}{n}k + i \\sin\\frac{2 \\pi}{n}k $。我们需要单位复根的以下性质。\n\n1. $ \\omega_n ^ t (0 \\leq t \\leq n - 1) $ 互不相同，保证点值表示的合法；\n2. $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $，用于分治；\n3. $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $，用于分治；\n3. 当 $ k \\neq 0 $ 时，$ 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} = 0 $，用于逆变换。\n\n在数论中，考虑一个质数 $ p = qn + 1 $（其中 $ n $ 为 $ 2 $ 的幂）。定义其**原根** $ g $ 为使得 $ g ^ i(0 \\leq i \\leq p - 1) $ 互不相同的数。\n\n#### 性质一\n\n令 $ \\omega_n = g ^ q $，由于 $ 1,\\ g ^ q,\\ g ^ {2q},\\ \\dots,\\ g ^ {(n - 1)q} $ 互不相同，满足**性质一**。\n\n#### 性质二\n\n由 $ \\omega_n = g ^ q $ 可知 $ \\omega_{2n} = g ^ { \\frac{q}{2} } $（$ p = \\frac{q}{2} \\times 2n + 1 $），故 $ \\omega_{2n} ^ {2k} = g ^ {2k \\frac{q}{2} } = g ^ {kq} = \\omega_n ^ k $，满足**性质二**。\n\n#### 性质三\n\n根据费马小定理得\n\n$$ \\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \\equiv 1 \\pmod p $$\n\n又因为 $ (\\omega_{n} ^ { \\frac{n}{2} }) ^ 2 = \\omega_n ^ n $，所以 $ \\omega_n ^ { \\frac{n}{2} } \\equiv \\pm 1 \\pmod p $，而根据性质一可得 $ \\omega_n ^ { \\frac{n}{2} } \\neq \\omega_n ^ 0 \\ $，即 $ \\omega_n ^ { \\frac{n}{2} } \\equiv -1 \\pmod p $。可推出 $ \\omega_n ^ { k + \\frac{n}{2} } = \\omega_n ^ k \\times \\omega_n ^ { \\frac{n}{2} } \\equiv -\\omega_n ^ k \\pmod p $，满足**性质三**。\n\n#### 性质四\n当 $ k \\neq 0 $ 时\n\n$$\n\\begin{aligned}\nS(\\omega_n ^ k) &= 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} \\\\\n\\omega_n ^ k S(\\omega_n ^ k) &= \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n \\\\\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{aligned}\n$$\n\n由**性质三**中的推论可知，$ (\\omega_n ^ k) ^ n - 1 \\equiv 0 \\pmod p $，故 $ S(\\omega_n ^ k) \\equiv 0  \\pmod p $，**性质四**成立。\n\n### 求原根\n求一个质数的原根，可以使用枚举法 —— 枚举 $ g $，检验 $ g $ 是否为 $ p $ 的原根。\n\n> 对于一个数 $ g $，最小的满足 $ g ^ k \\equiv 1 \\pmod p $ 的正整数 $ k $ 一定是 $ p - 1 $ 的约数。\n\n证明：假设最小的 $ k $ 不是 $ p - 1 $ 的约数，找到 $ x $ 满足 $ xk > p - 1 > (x - 1)k $，由费马小定理可知\n\n$$ g ^ {xk} \\equiv g ^ {p - 1} \\equiv 1 \\equiv g ^ {xk - (p - 1)} \\pmod p $$\n\n$ xk - (p - 1) < k $，与假设矛盾。\n\n检验时，只需要枚举 $ p - 1 $ 的所有约数 $ q $，检验 $ g ^ q \\not\\equiv 1 \\pmod p $ 即可。\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n```\n\n### 模板\n把原有的复数运算改为模意义下的运算即可。\n\n注意 $ \\div n $ 要改为 $ \\times n ^ {-1} $。\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n} ntt;\n```\n","slug":"fft-to-ntt","published":1,"updated":"2016-06-17T13:38:12.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s2j015kooxlno9phes2"},{"title":"FFT 学习笔记","date":"2016-06-03T11:41:00.000Z","_content":"\n快速傅里叶变换（Fast Fourier Transform，FFT）是一种可在 $ O(n \\log n) $ 时间内完成的离散傅里叶变换（Discrete Fourier transform，DFT）算法，在 OI 中的主要应用之一是加速多项式乘法的计算。\n\n<!-- more -->\n\n### 定义\n#### 多项式\n##### 系数表示与点值表示\n多项式的系数表示，设 $ A(x) $ 表示一个 $ n - 1 $ 次多项式，所有项的系数组成的 $ n $ 维向量 $ ( a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1} ) $ 唯一确定了这个多项式。\n\n$$\n\\begin{align*}\nA(x) &= \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i \\\\\n&= a_0 + a_1 x + a_2 x ^ 2 + \\dots + a_{n - 1} x ^ {n - 1}\n\\end{align*}\n$$\n\n多项式的点值表示，将一组**互不相同**的 $ n $ 个 $ x $ 带入多项式，得到的 $ n $ 个值。设它们组成的 $ n $ 维向量分别为 $ ( x_0,\\ x_1,\\ x_2,\\ \\dots,\\ x_{n - 1} ) $、$ ( y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1} ) $。\n\n$$\n\\begin{align*}\ny_i &= A(x_i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j x_i ^ j\n\\end{align*}\n$$\n\n##### 求值与插值\n> 定理：一个 $ n - 1 $ 次多项式在 $ n $ 个不同点的取值唯一确定了该多项式。\n\n证明：假设命题不成立，存在两个不同的 $ n - 1 $ 次多项式 $ A(x) $、$ B(x) $，满足对于任何 $ i \\in [0,\\ n - 1] $，有 $ A(x_i) = B(x_i) $。\n\n令 $ C(x) = A(x) - B(x) $，则 $ C(x) $ 也是一个 $ n - 1 $ 次多项式。对于任何 $ i \\in [0,\\ n - 1] $，有 $ C(x_i) = 0 $。\n\n即 $ C(x) $ 有 $ n $ 个根，这与代数基本定理（一个 $ n - 1 $ 次多项式在复数域上有且仅有 $ n - 1 $ 个根）相矛盾，故 $ C(x) $ 并不是一个 $ n - 1 $ 次多项式，原命题成立，证毕。\n\n如果我们按照定义求一个多项式的点值表示，时间复杂度为 $ O(n ^ 2) $。\n\n已知多项式的点值表示，求其系数表示，可以使用**插值**。朴素的插值算法时间复杂度为 $ O(n ^ 2) $。\n\n##### 多项式乘法\n我们定义两个多项式 $ A(x) = \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i $ 与 $ B(x) = \\sum\\limits_{i = 0} ^ {n - 1} b_i x ^ i $ 相乘的结果为 $ C(x) $（假设两个多项式次数相同，若不同可在后面补零）。\n\n$$ C(x) = A(x) \\times B(x) = \\sum\\limits_{k = 0} ^ {2n - 2} (\\sum\\limits_{k = i + j} a_i b_j) x ^ k $$\n\n两个 $ n - 1 $ 次多项式相乘，得到的是一个 $ 2n - 2 $ 次多项式，时间复杂度为 $ O(n ^ 2) $。\n\n如果使用两个多项式在 $ 2n - 1 $ 个点处取得的点值表示，那么\n\n$$ {y_3}_i = (\\sum\\limits_{j = 0} ^ {2n - 1} a_j x_i ^ j) \\times (\\sum\\limits_{j = 0} ^ {2n - 1} b_j x_i ^ j) = {y_1}_i \\times {y_2}_i $$\n\n时间复杂度为 $ O(n) $。\n\n#### 复数\n设 $ a $、$ b $ 为实数，$ i ^ 2 = -1 $，形如 $ a + bi $ 的数叫做**复数**，其中 $ i $ 被称为**虚数单位**。复数域是已知最大的域。\n\n##### 复平面\n在复平面中，$ x $ 轴代表实数、$ y $ 轴（除原点外的所有点）代表虚数。每一个复数 $ a + bi $ 对应复平面上一个从 $ (0,\\ 0) $ 指向 $ (a,\\ b) $ 的向量。\n\n该向量的长度 $ \\sqrt {a ^ 2 + b ^ 2} $ 叫做模长。表示从 $ x $ 轴正半轴到该向量的转角的有向（以逆时针为正方向）角叫做幅角。\n\n复数相加遵循平行四边形定则。\n\n复数相乘时，模长相乘，幅角相加。\n\n### 单位根\n下文中，如不特殊指明，均设 $ n $ 为 $ 2 $ 的正整数次幂。\n\n在复平面上，以原点为圆心，$ 1 $ 为半径作圆，所得的圆叫做单位圆。以原点为起点，单位圆的 $ n $ 等分点为终点，作 $ n $ 个向量。设所得的**幅角为正且最小**的向量对应的复数为 $ \\omega_n $，称为 $ n $ 次单位根。\n\n由复数乘法的定义（模长相乘，幅角相加）可知，其与的 $ n - 1 $ 个向量对应的复数分别为 $ \\omega_n ^ 2,\\ \\omega_n ^ 3,\\ \\dots,\\ \\omega_n ^ n $，其中 $ \\omega_n ^ n = \\omega_n ^ 0 = 1 $。\n\n单位根的幅角为周角的 $ 1 \\over n $，这为我们提供了一个计算单位根及其幂的公式\n\n$$ \\omega_n ^ k = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n#### 单位根的性质\n\n> 性质一：$ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n\n从几何意义上看，在复平面上，二者表示的向量终点相同。\n\n更具体的，有\n\n$$ \\cos 2k \\frac{2 \\pi}{2n} + i\\sin 2k \\frac{2 \\pi}{2n} = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n> 性质二：$ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n\n等式左边相当于 $ \\omega_n ^ k $ 乘上 $ \\omega_n ^ { \\frac{n}{2} } $，考虑其值\n\n$$\n\\begin{align*}\n\\omega_n ^ { \\frac{n}{2} } &= \\cos \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} + i\\sin \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} \\\\\n&= \\cos \\pi + i\\sin \\pi \\\\\n&= -1\n\\end{align*}\n$$\n\n### 快速傅里叶变换\n考虑多项式 $ A(x) $ 的表示。将 $ n $ 次单位根的 $ 0 $ 到 $ n - 1 $ 次幂带入多项式的系数表示，所得点值向量 $ (A(\\omega_n ^ 0),\\ A(\\omega_n ^ 1),\\ \\dots,\\ A(\\omega_n ^ {n - 1})) $ 称为其系数向量 $ (a_0,\\ a_1,\\ \\dots,\\ a_{n - 1}) $ 的**离散傅里叶变换**。\n\n按照朴素算法来求离散傅里叶变换，时间复杂度仍然为 $ O(n ^ 2) $。\n\n考虑将多项式按照系数下标的奇偶分为两部分\n\n$$ A(x) = (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + \\dots + a_{n - 2} x ^ {n - 2}) + (a_1 x + a_3 x ^ 3 + a_5 x ^ 5 + \\dots + a_{n - 1} x ^ {n - 1}) $$\n\n令\n\n$$\n\\begin{align*}\nA_1(x) &= a_0 + a_2 x + a_4 x ^ 2 + \\dots + a_{n - 2} x ^ {\\frac{n}{2} - 1} \\\\\nA_2(x) &= a_1 + a_3 x + a_5 x ^ 2 + \\dots + a_{n - 1} x ^ {\\frac{n}{2} - 1}\n\\end{align*}\n$$\n\n则有\n\n$$ A(x) = A_1(x ^ 2) + x A_2(x ^ 2) $$\n\n假设 $ k < \\frac{n}{2} $，现在要求 $ A(\\omega_n ^ k) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ k) &= A_1(\\omega_n ^ {2k}) + \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) + \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n这一步转化利用了单位根的性质一。\n\n对于 $ A(\\omega_n ^ {k + \\frac{n}{2}}) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ {k + \\frac{n}{2}}) &= A_1(\\omega_n ^ {2k + n}) + \\omega_n ^ {k + \\frac{n}{2}} A_2(\\omega_n ^ {2k + n}) \\\\\n&= A_1(\\omega_n ^ {2k} \\times \\omega_n ^ n) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k} \\times \\omega_n ^ n) \\\\\n&= A_1(\\omega_n ^ {2k}) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) - \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n这一步转化除性质一外，还利用到了性质二和 $ \\omega_n ^ n = 1 $ 这一显然的结论。\n\n注意到，当 $ k $ 取遍 $ [0,\\ \\frac{n}{2} - 1] $ 时，$ k $ 和 $ k + \\frac{n}{2} $ 取遍了 $ [0,\\ n - 1] $。\n\n也就是说，如果已知 $ A_1(x) $ 和 $ A_2(x) $ 在 $ \\omega_{ \\frac{n}{2} } ^ 0,\\ \\omega_{ \\frac{n}{2} } ^ 1,\\ \\dots,\\ \\omega_{ \\frac{n}{2} } ^ { \\frac{n}{2} - 1 } $ 处的点值，就可以在 $ O(n) $ 的时间内求得 $ A(x) $ 在 $ \\omega_n ^ 0,\\ \\omega_n ^ 1,\\ \\dots,\\ \\omega_n ^ {n - 1} $ 处的取值。而关于 $ A_1(x) $ 和 $ A_2(x) $ 的问题都是相对于原问题规模缩小了一半的子问题，分治的边界为一个常数项 $ a_0 $。\n\n根据主定理，该分治算法的时间复杂度为\n\n$$ T(n) = 2T( \\frac{n}{2} ) + O(n) = O(n \\log n) $$\n\n这就是最常用的 FFT 算法 —— Cooley-Tukey 算法。\n\n### 傅里叶逆变换\n将点值表示的多项式转化为系数表示，同样可以使用快速傅里叶变换，这个过程叫做**傅里叶逆变换**。\n\n设 $ (y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1}) $ 为 $ (a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1}) $ 的傅里叶变换。考虑另一个向量 $ (c_0,\\ c_1,\\ c_2,\\ \\dots,\\ c_{n - 1}) $ 满足\n\n$$\nc_k = \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i\n$$\n\n即多项式 $ B(x) = y_0 + y_1 x + y_2 x ^ 2 + \\dots + y_{n - 1} x ^ {n - 1} $ 在 $ \\omega_n ^ 0,\\ \\omega_n ^ {-1},\\ \\omega_n ^ {-2},\\ \\dots,\\  \\omega_n ^ {-(n - 1)} $ 处的点值表示。\n\n将上式展开，得\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ i) ^ j) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i (\\omega_n ^ {-k}) ^ i) \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ {j - k}) ^ i \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i)\n\\end{align*}\n$$\n\n考虑一个式子\n\n$$ S(\\omega_n ^ k) = 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} $$\n\n当 $ k \\neq 0 $ 时，两边同时乘上 $ \\omega_n ^ k $ 得\n\n$$ \\omega_n ^ k S(\\omega_n ^ k) = \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n $$\n\n两式相减，整理后得\n\n$$\n\\begin{align*}\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{align*}\n$$\n\n分子为零，分母不为零，所以\n\n$$ S(\\omega_n ^ k) = 0 $$\n\n当 $ k = 0 $ 时，显然 $ S(\\omega_n ^ k) = n $。\n\n继续考虑上式\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j S(\\omega_n ^ {j - k})\n\\end{align*}\n$$\n\n当 $ j = k $ 时，$ S(\\omega_n ^ {j - k}) = n $，否则 $ S(\\omega_n ^ {j - k}) = 0 $，即\n\n$$\n\\begin{align*}\nc_i &= n a_i \\\\\na_i &= \\frac{1}{n} c_i\n\\end{align*}\n$$\n\n所以，使用单位根的倒数代替单位根，做一次类似快速傅里叶变换的过程，再将结果每个数除以 $ n $，即为傅里叶逆变换的结果。\n\n### 实现\nC++ 的 STL 在头文件 `complex` 中提供一个复数的模板实现 `std::complex<T>`，其中 `T` 为实数类型，一般取 `double`，在对精度要求较高的时候可以使用 `long double` 或 `__float128`（不常用）。\n\n考虑到单位根的倒数等于其共轭复数，在程序实现中，为了减小误差，通常使用 `std::conj()` 取得 IDFT 所需的「单位根的倒数」。\n\n#### 递归实现\n直接按照上面得到的结论来实现即可，比较直观。\n\n##### 代码\n\n```c++\nconst double PI = acos(-1);\n\nbool inversed = false;\n\ninline std::complex<double> omega(const int n, const int k) {\n    if (!inversed) return std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k));\n    else return std::conj(std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k)));\n}\n\ninline void transform(std::complex<double> *a, const int n) {\n    if (n == 1) return;\n\n    static std::complex<double> buf[MAXN];\n    const int m = n / 2;\n    // 按照系数奇偶划分为两半\n    for (int i = 0; i < m; i++) {\n        buf[i] = a[i * 2];\n        buf[i + m] = a[i * 2 + 1];\n    }\n    std::copy(buf, buf + n, a);\n\n    // 分治\n    std::complex<double> *a1 = a, *a2 = a + m;\n    fft(a1, m);\n    fft(a2, m);\n\n    // 合并两个子问题\n    for (int i = 0; i < m; i++) {\n        std::complex<double> x = omega(n, i);\n        buf[i] = a1[i] + x * a2[i];\n        buf[i + m] = a1[i] - x * a2[i];\n    }\n\n    std::copy(buf, buf + n, a);\n}\n```\n\n#### 迭代实现\n递归实现的 FFT 效率不高，实际中一般采用迭代实现。\n\n##### 二进制位翻转\n考虑递归 FFT 分治到边界时，每个数的顺序，及其二进制位。\n\n```plain\n000 001 010 011 100 101 110 111\n 0   1   2   3   4   5   6   7\n 0   2   4   6 - 1   3   5   7\n 0   4 - 2   6 - 1   5 - 3   7\n 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7\n000 100 010 110 001 101 011 111\n```\n\n发现规律，分治到边界后的下标等于原下标的二进制位翻转。\n\n代码实现，枚举每个二进制位即可。\n\n```c++\nint k = 0;\nwhile ((1 << k) < n) k++;\nfor (int i = 0; i < n; i++) {\n    int t = 0;\n    for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n    if (i < t) std::swap(a[i], a[t]);\n}\n```\n\n##### 蝴蝶操作\n考虑合并两个子问题的过程，假设 $ A_1(\\omega_{ \\frac{n}{2} } ^ k) $ 和 $ A_2(\\omega_{ \\frac{n}{2} } ^ k) $ 分别存在 $ a(k) $ 和 $ a(\\frac{n}{2} + k) $ 中，$ A(\\omega_n ^ {k}) $ 和 $ A(\\omega_n ^ {k + \\frac{n}{2} }) $ 将要被存放在 $ b(k) $ 和 $ b(\\frac{n}{2} + k) $ 中，合并的单位操作可表示为\n\n$$\n\\begin{align*}\nb(k) & \\leftarrow a(k) + \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\nb(\\frac{n}{2} + k) & \\leftarrow a(k) - \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\n\\end{align*}\n$$\n\n考虑加入一个临时变量 $ t $，使得这个过程可以在原地完成，不需要另一个数组 $ b $，也就是说，将 $ A(\\omega_n ^ {k}) $ 和 $ A(\\omega_n ^ {k + \\frac{n}{2} }) $ 存放在 $ a(k) $ 和 $ a(\\frac{n}{2} + k) $ 中，覆盖原来的值\n\n$$\n\\begin{align*}\nt & \\leftarrow \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\na(\\frac{n}{2} + k) & \\leftarrow a(k) - t \\\\\na(k) & \\leftarrow a(k) + t \\\\\n\\end{align*}\n$$\n\n这一过程被称为**蝴蝶操作**。\n\n##### 代码\n`omega[k]` 中保存 $ \\omega_n ^ k $（IDFT 时保存 $ \\omega_n ^ {-k} $）。\n\n枚举 $ l $，表示一次要将 $ \\frac{l}{2} $ 长度的序列答案合并为长度为 $ l $ 的，根据单位根的性质一，有 $ \\omega_l ^ k = \\omega_n ^ { \\frac{n}{l} k } $。\n\n```c++\nvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n    // 此处省略二进制位翻转的代码\n    for (int l = 2; l <= n; l *= 2) {\n        int m = l / 2;\n        // 将两个长度为 m 的序列的答案合并为长度为 l 的序列的答案\n        for (std::complex<double> *p = a; p != a + n; p += l) {\n            for (int i = 0; i < m; i++) {\n                // 蝴蝶操作\n                std::complex<double> t = omega[n / l * i] * p[m + i];\n                p[m + i] = p[i] - t;\n                p[i] += t;\n            }\n        }\n    }\n}\n```\n\n### 模板\n需要注意的是，在求两个次数分别为 $ n_1 - 1 $ 和 $ n_2 - 1 $ 的多项式的乘积时，需要分别求出其在**至少** $ n_1 + n_2 - 1 $ 个点处的点值，因为这样才能保证相乘后的点值能唯一确定一个 $ n_1 + n_2 - 2 $ 次多项式。\n\n```c++\nstruct FastFourierTransform {\n    std::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n    void init(const int n) {\n        for (int i = 0; i < n; i++) {\n            omega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n            omegaInverse[i] = std::conj(omega[i]);\n        }\n    }\n\n    void transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n            if (i < t) std::swap(a[i], a[t]);\n        }\n\n        for (int l = 2; l <= n; l *= 2) {\n            int m = l / 2;\n            for (std::complex<double> *p = a; p != a + n; p += l) {\n                for (int i = 0; i < m; i++) {\n                    std::complex<double> t = omega[n / l * i] * p[m + i];\n                    p[m + i] = p[i] - t;\n                    p[i] += t;\n                }\n            }\n        }\n    }\n\n    void dft(std::complex<double> *a, const int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(std::complex<double> *a, const int n) {\n        transform(a, n, omegaInverse);\n        for (int i = 0; i < n; i++) a[i] /= n;\n    }\n} fft;\n\ninline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) {\n    int n = 1;\n    while (n < n1 + n2) n *= 2;\n    static std::complex<double> c1[MAXN], c2[MAXN];\n    for (int i = 0; i < n1; i++) c1[i].real(a1[i]);\n    for (int i = 0; i < n2; i++) c2[i].real(a2[i]);\n    fft.init(n);\n    fft.dft(c1, n), fft.dft(c2, n);\n    for (int i = 0; i < n; i++) c1[i] *= c2[i];\n    fft.idft(c1, n);\n    for (int i = 0; i < n1 + n2 - 1; i++) res[i] = static_cast<int>(floor(c1[i].real() + 0.5));\n}\n```\n\n### 参考资料\n* [多項式 - 维基百科，自由的百科全书](https://zh.wikipedia.org/zh/%E5%A4%9A%E9%A0%85%E5%BC%8F)，Wikipedia\n* [复平面 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%B9%B3%E9%9D%A2)，Wikipedia\n* [复数 (数学) - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))，Wikipedia\n* [快速傅里叶变换 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)，Wikipedia\n* [FFT & NTT | ZYK1997](http://zyk1997.github.io/2015/06/08/FFT/)，ZYK1997\n* [BZOJ 3992 SDOI2015 序列统计 - Fuxey - 博客频道 - CSDN.NET](http://blog.csdn.net/fuxey/article/details/50840881)，Fuxey\n* [从多项式乘法到快速傅里叶变换 - Miskcoo's Space](http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform)，Miskcoo\n* [OI 中的 FFT - zball - 博客园](http://www.cnblogs.com/tmzbot/p/4320955.html)，zball\n* [Fourier transform](https://pan.baidu.com/wap/album/file?uk=3325080974&album_id=2474841267539644259&fsid=845742707277510&adapt=pc&fr=ftw)，郭晓旭\n","source":"_posts/fft-notes.md","raw":"title: FFT 学习笔记\ncategories: OI\ntags: \n  - FFT\n  - 数学\n  - 学习笔记\n  - 算法模板\n  - 多项式\npermalink: fft-notes\ndate: 2016-06-03 19:41:00\n---\n\n快速傅里叶变换（Fast Fourier Transform，FFT）是一种可在 $ O(n \\log n) $ 时间内完成的离散傅里叶变换（Discrete Fourier transform，DFT）算法，在 OI 中的主要应用之一是加速多项式乘法的计算。\n\n<!-- more -->\n\n### 定义\n#### 多项式\n##### 系数表示与点值表示\n多项式的系数表示，设 $ A(x) $ 表示一个 $ n - 1 $ 次多项式，所有项的系数组成的 $ n $ 维向量 $ ( a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1} ) $ 唯一确定了这个多项式。\n\n$$\n\\begin{align*}\nA(x) &= \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i \\\\\n&= a_0 + a_1 x + a_2 x ^ 2 + \\dots + a_{n - 1} x ^ {n - 1}\n\\end{align*}\n$$\n\n多项式的点值表示，将一组**互不相同**的 $ n $ 个 $ x $ 带入多项式，得到的 $ n $ 个值。设它们组成的 $ n $ 维向量分别为 $ ( x_0,\\ x_1,\\ x_2,\\ \\dots,\\ x_{n - 1} ) $、$ ( y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1} ) $。\n\n$$\n\\begin{align*}\ny_i &= A(x_i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j x_i ^ j\n\\end{align*}\n$$\n\n##### 求值与插值\n> 定理：一个 $ n - 1 $ 次多项式在 $ n $ 个不同点的取值唯一确定了该多项式。\n\n证明：假设命题不成立，存在两个不同的 $ n - 1 $ 次多项式 $ A(x) $、$ B(x) $，满足对于任何 $ i \\in [0,\\ n - 1] $，有 $ A(x_i) = B(x_i) $。\n\n令 $ C(x) = A(x) - B(x) $，则 $ C(x) $ 也是一个 $ n - 1 $ 次多项式。对于任何 $ i \\in [0,\\ n - 1] $，有 $ C(x_i) = 0 $。\n\n即 $ C(x) $ 有 $ n $ 个根，这与代数基本定理（一个 $ n - 1 $ 次多项式在复数域上有且仅有 $ n - 1 $ 个根）相矛盾，故 $ C(x) $ 并不是一个 $ n - 1 $ 次多项式，原命题成立，证毕。\n\n如果我们按照定义求一个多项式的点值表示，时间复杂度为 $ O(n ^ 2) $。\n\n已知多项式的点值表示，求其系数表示，可以使用**插值**。朴素的插值算法时间复杂度为 $ O(n ^ 2) $。\n\n##### 多项式乘法\n我们定义两个多项式 $ A(x) = \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i $ 与 $ B(x) = \\sum\\limits_{i = 0} ^ {n - 1} b_i x ^ i $ 相乘的结果为 $ C(x) $（假设两个多项式次数相同，若不同可在后面补零）。\n\n$$ C(x) = A(x) \\times B(x) = \\sum\\limits_{k = 0} ^ {2n - 2} (\\sum\\limits_{k = i + j} a_i b_j) x ^ k $$\n\n两个 $ n - 1 $ 次多项式相乘，得到的是一个 $ 2n - 2 $ 次多项式，时间复杂度为 $ O(n ^ 2) $。\n\n如果使用两个多项式在 $ 2n - 1 $ 个点处取得的点值表示，那么\n\n$$ {y_3}_i = (\\sum\\limits_{j = 0} ^ {2n - 1} a_j x_i ^ j) \\times (\\sum\\limits_{j = 0} ^ {2n - 1} b_j x_i ^ j) = {y_1}_i \\times {y_2}_i $$\n\n时间复杂度为 $ O(n) $。\n\n#### 复数\n设 $ a $、$ b $ 为实数，$ i ^ 2 = -1 $，形如 $ a + bi $ 的数叫做**复数**，其中 $ i $ 被称为**虚数单位**。复数域是已知最大的域。\n\n##### 复平面\n在复平面中，$ x $ 轴代表实数、$ y $ 轴（除原点外的所有点）代表虚数。每一个复数 $ a + bi $ 对应复平面上一个从 $ (0,\\ 0) $ 指向 $ (a,\\ b) $ 的向量。\n\n该向量的长度 $ \\sqrt {a ^ 2 + b ^ 2} $ 叫做模长。表示从 $ x $ 轴正半轴到该向量的转角的有向（以逆时针为正方向）角叫做幅角。\n\n复数相加遵循平行四边形定则。\n\n复数相乘时，模长相乘，幅角相加。\n\n### 单位根\n下文中，如不特殊指明，均设 $ n $ 为 $ 2 $ 的正整数次幂。\n\n在复平面上，以原点为圆心，$ 1 $ 为半径作圆，所得的圆叫做单位圆。以原点为起点，单位圆的 $ n $ 等分点为终点，作 $ n $ 个向量。设所得的**幅角为正且最小**的向量对应的复数为 $ \\omega_n $，称为 $ n $ 次单位根。\n\n由复数乘法的定义（模长相乘，幅角相加）可知，其与的 $ n - 1 $ 个向量对应的复数分别为 $ \\omega_n ^ 2,\\ \\omega_n ^ 3,\\ \\dots,\\ \\omega_n ^ n $，其中 $ \\omega_n ^ n = \\omega_n ^ 0 = 1 $。\n\n单位根的幅角为周角的 $ 1 \\over n $，这为我们提供了一个计算单位根及其幂的公式\n\n$$ \\omega_n ^ k = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n#### 单位根的性质\n\n> 性质一：$ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n\n从几何意义上看，在复平面上，二者表示的向量终点相同。\n\n更具体的，有\n\n$$ \\cos 2k \\frac{2 \\pi}{2n} + i\\sin 2k \\frac{2 \\pi}{2n} = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n> 性质二：$ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n\n等式左边相当于 $ \\omega_n ^ k $ 乘上 $ \\omega_n ^ { \\frac{n}{2} } $，考虑其值\n\n$$\n\\begin{align*}\n\\omega_n ^ { \\frac{n}{2} } &= \\cos \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} + i\\sin \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} \\\\\n&= \\cos \\pi + i\\sin \\pi \\\\\n&= -1\n\\end{align*}\n$$\n\n### 快速傅里叶变换\n考虑多项式 $ A(x) $ 的表示。将 $ n $ 次单位根的 $ 0 $ 到 $ n - 1 $ 次幂带入多项式的系数表示，所得点值向量 $ (A(\\omega_n ^ 0),\\ A(\\omega_n ^ 1),\\ \\dots,\\ A(\\omega_n ^ {n - 1})) $ 称为其系数向量 $ (a_0,\\ a_1,\\ \\dots,\\ a_{n - 1}) $ 的**离散傅里叶变换**。\n\n按照朴素算法来求离散傅里叶变换，时间复杂度仍然为 $ O(n ^ 2) $。\n\n考虑将多项式按照系数下标的奇偶分为两部分\n\n$$ A(x) = (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + \\dots + a_{n - 2} x ^ {n - 2}) + (a_1 x + a_3 x ^ 3 + a_5 x ^ 5 + \\dots + a_{n - 1} x ^ {n - 1}) $$\n\n令\n\n$$\n\\begin{align*}\nA_1(x) &= a_0 + a_2 x + a_4 x ^ 2 + \\dots + a_{n - 2} x ^ {\\frac{n}{2} - 1} \\\\\nA_2(x) &= a_1 + a_3 x + a_5 x ^ 2 + \\dots + a_{n - 1} x ^ {\\frac{n}{2} - 1}\n\\end{align*}\n$$\n\n则有\n\n$$ A(x) = A_1(x ^ 2) + x A_2(x ^ 2) $$\n\n假设 $ k < \\frac{n}{2} $，现在要求 $ A(\\omega_n ^ k) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ k) &= A_1(\\omega_n ^ {2k}) + \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) + \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n这一步转化利用了单位根的性质一。\n\n对于 $ A(\\omega_n ^ {k + \\frac{n}{2}}) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ {k + \\frac{n}{2}}) &= A_1(\\omega_n ^ {2k + n}) + \\omega_n ^ {k + \\frac{n}{2}} A_2(\\omega_n ^ {2k + n}) \\\\\n&= A_1(\\omega_n ^ {2k} \\times \\omega_n ^ n) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k} \\times \\omega_n ^ n) \\\\\n&= A_1(\\omega_n ^ {2k}) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) - \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n这一步转化除性质一外，还利用到了性质二和 $ \\omega_n ^ n = 1 $ 这一显然的结论。\n\n注意到，当 $ k $ 取遍 $ [0,\\ \\frac{n}{2} - 1] $ 时，$ k $ 和 $ k + \\frac{n}{2} $ 取遍了 $ [0,\\ n - 1] $。\n\n也就是说，如果已知 $ A_1(x) $ 和 $ A_2(x) $ 在 $ \\omega_{ \\frac{n}{2} } ^ 0,\\ \\omega_{ \\frac{n}{2} } ^ 1,\\ \\dots,\\ \\omega_{ \\frac{n}{2} } ^ { \\frac{n}{2} - 1 } $ 处的点值，就可以在 $ O(n) $ 的时间内求得 $ A(x) $ 在 $ \\omega_n ^ 0,\\ \\omega_n ^ 1,\\ \\dots,\\ \\omega_n ^ {n - 1} $ 处的取值。而关于 $ A_1(x) $ 和 $ A_2(x) $ 的问题都是相对于原问题规模缩小了一半的子问题，分治的边界为一个常数项 $ a_0 $。\n\n根据主定理，该分治算法的时间复杂度为\n\n$$ T(n) = 2T( \\frac{n}{2} ) + O(n) = O(n \\log n) $$\n\n这就是最常用的 FFT 算法 —— Cooley-Tukey 算法。\n\n### 傅里叶逆变换\n将点值表示的多项式转化为系数表示，同样可以使用快速傅里叶变换，这个过程叫做**傅里叶逆变换**。\n\n设 $ (y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1}) $ 为 $ (a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1}) $ 的傅里叶变换。考虑另一个向量 $ (c_0,\\ c_1,\\ c_2,\\ \\dots,\\ c_{n - 1}) $ 满足\n\n$$\nc_k = \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i\n$$\n\n即多项式 $ B(x) = y_0 + y_1 x + y_2 x ^ 2 + \\dots + y_{n - 1} x ^ {n - 1} $ 在 $ \\omega_n ^ 0,\\ \\omega_n ^ {-1},\\ \\omega_n ^ {-2},\\ \\dots,\\  \\omega_n ^ {-(n - 1)} $ 处的点值表示。\n\n将上式展开，得\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ i) ^ j) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i (\\omega_n ^ {-k}) ^ i) \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ {j - k}) ^ i \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i)\n\\end{align*}\n$$\n\n考虑一个式子\n\n$$ S(\\omega_n ^ k) = 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} $$\n\n当 $ k \\neq 0 $ 时，两边同时乘上 $ \\omega_n ^ k $ 得\n\n$$ \\omega_n ^ k S(\\omega_n ^ k) = \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n $$\n\n两式相减，整理后得\n\n$$\n\\begin{align*}\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{align*}\n$$\n\n分子为零，分母不为零，所以\n\n$$ S(\\omega_n ^ k) = 0 $$\n\n当 $ k = 0 $ 时，显然 $ S(\\omega_n ^ k) = n $。\n\n继续考虑上式\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j S(\\omega_n ^ {j - k})\n\\end{align*}\n$$\n\n当 $ j = k $ 时，$ S(\\omega_n ^ {j - k}) = n $，否则 $ S(\\omega_n ^ {j - k}) = 0 $，即\n\n$$\n\\begin{align*}\nc_i &= n a_i \\\\\na_i &= \\frac{1}{n} c_i\n\\end{align*}\n$$\n\n所以，使用单位根的倒数代替单位根，做一次类似快速傅里叶变换的过程，再将结果每个数除以 $ n $，即为傅里叶逆变换的结果。\n\n### 实现\nC++ 的 STL 在头文件 `complex` 中提供一个复数的模板实现 `std::complex<T>`，其中 `T` 为实数类型，一般取 `double`，在对精度要求较高的时候可以使用 `long double` 或 `__float128`（不常用）。\n\n考虑到单位根的倒数等于其共轭复数，在程序实现中，为了减小误差，通常使用 `std::conj()` 取得 IDFT 所需的「单位根的倒数」。\n\n#### 递归实现\n直接按照上面得到的结论来实现即可，比较直观。\n\n##### 代码\n\n```c++\nconst double PI = acos(-1);\n\nbool inversed = false;\n\ninline std::complex<double> omega(const int n, const int k) {\n    if (!inversed) return std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k));\n    else return std::conj(std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k)));\n}\n\ninline void transform(std::complex<double> *a, const int n) {\n    if (n == 1) return;\n\n    static std::complex<double> buf[MAXN];\n    const int m = n / 2;\n    // 按照系数奇偶划分为两半\n    for (int i = 0; i < m; i++) {\n        buf[i] = a[i * 2];\n        buf[i + m] = a[i * 2 + 1];\n    }\n    std::copy(buf, buf + n, a);\n\n    // 分治\n    std::complex<double> *a1 = a, *a2 = a + m;\n    fft(a1, m);\n    fft(a2, m);\n\n    // 合并两个子问题\n    for (int i = 0; i < m; i++) {\n        std::complex<double> x = omega(n, i);\n        buf[i] = a1[i] + x * a2[i];\n        buf[i + m] = a1[i] - x * a2[i];\n    }\n\n    std::copy(buf, buf + n, a);\n}\n```\n\n#### 迭代实现\n递归实现的 FFT 效率不高，实际中一般采用迭代实现。\n\n##### 二进制位翻转\n考虑递归 FFT 分治到边界时，每个数的顺序，及其二进制位。\n\n```plain\n000 001 010 011 100 101 110 111\n 0   1   2   3   4   5   6   7\n 0   2   4   6 - 1   3   5   7\n 0   4 - 2   6 - 1   5 - 3   7\n 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7\n000 100 010 110 001 101 011 111\n```\n\n发现规律，分治到边界后的下标等于原下标的二进制位翻转。\n\n代码实现，枚举每个二进制位即可。\n\n```c++\nint k = 0;\nwhile ((1 << k) < n) k++;\nfor (int i = 0; i < n; i++) {\n    int t = 0;\n    for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n    if (i < t) std::swap(a[i], a[t]);\n}\n```\n\n##### 蝴蝶操作\n考虑合并两个子问题的过程，假设 $ A_1(\\omega_{ \\frac{n}{2} } ^ k) $ 和 $ A_2(\\omega_{ \\frac{n}{2} } ^ k) $ 分别存在 $ a(k) $ 和 $ a(\\frac{n}{2} + k) $ 中，$ A(\\omega_n ^ {k}) $ 和 $ A(\\omega_n ^ {k + \\frac{n}{2} }) $ 将要被存放在 $ b(k) $ 和 $ b(\\frac{n}{2} + k) $ 中，合并的单位操作可表示为\n\n$$\n\\begin{align*}\nb(k) & \\leftarrow a(k) + \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\nb(\\frac{n}{2} + k) & \\leftarrow a(k) - \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\n\\end{align*}\n$$\n\n考虑加入一个临时变量 $ t $，使得这个过程可以在原地完成，不需要另一个数组 $ b $，也就是说，将 $ A(\\omega_n ^ {k}) $ 和 $ A(\\omega_n ^ {k + \\frac{n}{2} }) $ 存放在 $ a(k) $ 和 $ a(\\frac{n}{2} + k) $ 中，覆盖原来的值\n\n$$\n\\begin{align*}\nt & \\leftarrow \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\na(\\frac{n}{2} + k) & \\leftarrow a(k) - t \\\\\na(k) & \\leftarrow a(k) + t \\\\\n\\end{align*}\n$$\n\n这一过程被称为**蝴蝶操作**。\n\n##### 代码\n`omega[k]` 中保存 $ \\omega_n ^ k $（IDFT 时保存 $ \\omega_n ^ {-k} $）。\n\n枚举 $ l $，表示一次要将 $ \\frac{l}{2} $ 长度的序列答案合并为长度为 $ l $ 的，根据单位根的性质一，有 $ \\omega_l ^ k = \\omega_n ^ { \\frac{n}{l} k } $。\n\n```c++\nvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n    // 此处省略二进制位翻转的代码\n    for (int l = 2; l <= n; l *= 2) {\n        int m = l / 2;\n        // 将两个长度为 m 的序列的答案合并为长度为 l 的序列的答案\n        for (std::complex<double> *p = a; p != a + n; p += l) {\n            for (int i = 0; i < m; i++) {\n                // 蝴蝶操作\n                std::complex<double> t = omega[n / l * i] * p[m + i];\n                p[m + i] = p[i] - t;\n                p[i] += t;\n            }\n        }\n    }\n}\n```\n\n### 模板\n需要注意的是，在求两个次数分别为 $ n_1 - 1 $ 和 $ n_2 - 1 $ 的多项式的乘积时，需要分别求出其在**至少** $ n_1 + n_2 - 1 $ 个点处的点值，因为这样才能保证相乘后的点值能唯一确定一个 $ n_1 + n_2 - 2 $ 次多项式。\n\n```c++\nstruct FastFourierTransform {\n    std::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n    void init(const int n) {\n        for (int i = 0; i < n; i++) {\n            omega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n            omegaInverse[i] = std::conj(omega[i]);\n        }\n    }\n\n    void transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n            if (i < t) std::swap(a[i], a[t]);\n        }\n\n        for (int l = 2; l <= n; l *= 2) {\n            int m = l / 2;\n            for (std::complex<double> *p = a; p != a + n; p += l) {\n                for (int i = 0; i < m; i++) {\n                    std::complex<double> t = omega[n / l * i] * p[m + i];\n                    p[m + i] = p[i] - t;\n                    p[i] += t;\n                }\n            }\n        }\n    }\n\n    void dft(std::complex<double> *a, const int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(std::complex<double> *a, const int n) {\n        transform(a, n, omegaInverse);\n        for (int i = 0; i < n; i++) a[i] /= n;\n    }\n} fft;\n\ninline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) {\n    int n = 1;\n    while (n < n1 + n2) n *= 2;\n    static std::complex<double> c1[MAXN], c2[MAXN];\n    for (int i = 0; i < n1; i++) c1[i].real(a1[i]);\n    for (int i = 0; i < n2; i++) c2[i].real(a2[i]);\n    fft.init(n);\n    fft.dft(c1, n), fft.dft(c2, n);\n    for (int i = 0; i < n; i++) c1[i] *= c2[i];\n    fft.idft(c1, n);\n    for (int i = 0; i < n1 + n2 - 1; i++) res[i] = static_cast<int>(floor(c1[i].real() + 0.5));\n}\n```\n\n### 参考资料\n* [多項式 - 维基百科，自由的百科全书](https://zh.wikipedia.org/zh/%E5%A4%9A%E9%A0%85%E5%BC%8F)，Wikipedia\n* [复平面 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%B9%B3%E9%9D%A2)，Wikipedia\n* [复数 (数学) - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))，Wikipedia\n* [快速傅里叶变换 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)，Wikipedia\n* [FFT & NTT | ZYK1997](http://zyk1997.github.io/2015/06/08/FFT/)，ZYK1997\n* [BZOJ 3992 SDOI2015 序列统计 - Fuxey - 博客频道 - CSDN.NET](http://blog.csdn.net/fuxey/article/details/50840881)，Fuxey\n* [从多项式乘法到快速傅里叶变换 - Miskcoo's Space](http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform)，Miskcoo\n* [OI 中的 FFT - zball - 博客园](http://www.cnblogs.com/tmzbot/p/4320955.html)，zball\n* [Fourier transform](https://pan.baidu.com/wap/album/file?uk=3325080974&album_id=2474841267539644259&fsid=845742707277510&adapt=pc&fr=ftw)，郭晓旭\n","slug":"fft-notes","published":1,"updated":"2016-12-23T06:20:49.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s2r015tooxlois4c85n"},{"title":"线性筛法筛素数、莫比乌斯函数、欧拉函数","date":"2016-04-08T05:14:55.000Z","_content":"\n线性筛法（欧拉筛法）可以在 $ O(n) $ 的时间内获得 $ [1, n] $ 的所有素数。算法保证每个合数都会被它的最小质因子筛掉，所以复杂度是线性的。同时，我们可以利用这一特性，结合积性函数的性质，在 $ O(n) $ 的时间内筛出一些积性函数的值。\n\n<!-- more -->\n\n### 欧拉函数\n欧拉函数 $ \\phi(n) $ 的定义为：小于 $ n $ 的正整数中与 $ n $ 互质的数的个数，$ \\phi(1) = 1 $。\n\n当 $ n $ 为质数时，根据定义，显然有 $ \\phi(n) = n - 1 $。\n\n设 $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times … \\times p_N ^ {k_N} $，其中 $ p_i $ 为素数，则有\n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n设 $ p_1 $ 为 $ n $ 最小质因子，$ n' = \\frac{n}{p_1} $，在线性筛中，$ n $ 通过 $ n' \\times p_1 $ 被筛掉。\n\n当 $ n' \\ {\\rm mod} \\ p_1 = 0 $，即 $ k_1 \\gt 1 $ 时，$ n' $ 含有 $ n $ 的所有质因子，则有\n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n当 $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $，即 $ k_1 = 1 $ 时，$ n' $ 与 $ p_1 $ 互质，根据积性函数的性质有\n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### 莫比乌斯函数\n莫比乌斯函数 $ \\mu(n) $ 的定义：\n\n设 $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times … \\times p_N ^ {k_N} $，其中 $ p_i $ 为素数\n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n当 $ n $ 为质数时，根据定义，显然有 $ \\mu(n) = -1 $。\n\n设 $ p_1 $ 为 $ n $ 最小质因子，$ n' = \\frac{n}{p_1} $，在线性筛中，$ n $ 通过 $ n' \\times p_1 $ 被筛掉。\n\n当 $ n' \\ {\\rm mod} \\ p_1 = 0 $，即 $ k_1 \\gt 1 $ 时，由定义得\n\n$$ \\mu(n) = 0 $$\n\n当 $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $，即 $ k_1 = 1 $ 时，$ n' $ 有 $ N - 1 $ 个质因子，此时我们分情况讨论，若 $ \\mu(n') \\neq 0 $，即 $ n' $ 的所有质因子次数均为 $ 1 $，根据定义有\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n若 $ \\mu(n') = 0 $，说明 $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $，根据定义显然有\n\n$$ \\mu(n) = 0 $$\n\n此时 $ \\mu(n) = -\\mu(n') $ 仍然成立。\n\n\n### 模板\n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","source":"_posts/euler-sieve.md","raw":"title: 线性筛法筛素数、莫比乌斯函数、欧拉函数\ncategories: OI\ntags: \n  - 数学\n  - 数论\n  - 学习笔记\n  - 算法模板\n  - 线性筛\npermalink: euler-sieve\ndate: 2016-04-08 13:14:55\n---\n\n线性筛法（欧拉筛法）可以在 $ O(n) $ 的时间内获得 $ [1, n] $ 的所有素数。算法保证每个合数都会被它的最小质因子筛掉，所以复杂度是线性的。同时，我们可以利用这一特性，结合积性函数的性质，在 $ O(n) $ 的时间内筛出一些积性函数的值。\n\n<!-- more -->\n\n### 欧拉函数\n欧拉函数 $ \\phi(n) $ 的定义为：小于 $ n $ 的正整数中与 $ n $ 互质的数的个数，$ \\phi(1) = 1 $。\n\n当 $ n $ 为质数时，根据定义，显然有 $ \\phi(n) = n - 1 $。\n\n设 $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times … \\times p_N ^ {k_N} $，其中 $ p_i $ 为素数，则有\n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n设 $ p_1 $ 为 $ n $ 最小质因子，$ n' = \\frac{n}{p_1} $，在线性筛中，$ n $ 通过 $ n' \\times p_1 $ 被筛掉。\n\n当 $ n' \\ {\\rm mod} \\ p_1 = 0 $，即 $ k_1 \\gt 1 $ 时，$ n' $ 含有 $ n $ 的所有质因子，则有\n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n当 $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $，即 $ k_1 = 1 $ 时，$ n' $ 与 $ p_1 $ 互质，根据积性函数的性质有\n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### 莫比乌斯函数\n莫比乌斯函数 $ \\mu(n) $ 的定义：\n\n设 $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times … \\times p_N ^ {k_N} $，其中 $ p_i $ 为素数\n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n当 $ n $ 为质数时，根据定义，显然有 $ \\mu(n) = -1 $。\n\n设 $ p_1 $ 为 $ n $ 最小质因子，$ n' = \\frac{n}{p_1} $，在线性筛中，$ n $ 通过 $ n' \\times p_1 $ 被筛掉。\n\n当 $ n' \\ {\\rm mod} \\ p_1 = 0 $，即 $ k_1 \\gt 1 $ 时，由定义得\n\n$$ \\mu(n) = 0 $$\n\n当 $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $，即 $ k_1 = 1 $ 时，$ n' $ 有 $ N - 1 $ 个质因子，此时我们分情况讨论，若 $ \\mu(n') \\neq 0 $，即 $ n' $ 的所有质因子次数均为 $ 1 $，根据定义有\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n若 $ \\mu(n') = 0 $，说明 $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $，根据定义显然有\n\n$$ \\mu(n) = 0 $$\n\n此时 $ \\mu(n) = -\\mu(n') $ 仍然成立。\n\n\n### 模板\n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","slug":"euler-sieve","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s2x0160ooxlo3rwggjz"},{"title":"欧拉回路学习笔记","date":"2017-01-01T03:09:00.000Z","_content":"\n坑。\n\n<!-- more -->\n\n### 代码（[UOJ #117](http://uoj.ac/problem/117)）\n![zyz 大佬的评价](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 1e5;\n\nstruct Node\n{\n\tstruct Edge *e;\n\tint deg; // 无向图\n\tint inDeg, outDeg; // 有向图\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tint id;\n\tNode *s, *t;\n\tbool vis;\n\tEdge *next, *revEdge;\n\n\tEdge(int id, Node *s, Node *t) : id(id), s(s), t(t), vis(false), next(s->e) {}\n};\n\nint T;\n\ninline void addEdge(int id, int s, int t)\n{\n\tEdge *e1 = N[s].e = new Edge(id, &N[s], &N[t]);\n\n\tif (T == 1)\n\t{\n\t\tEdge *e2 = N[t].e = new Edge(-id, &N[t], &N[s]);\n\n\t\te1->revEdge = e2;\n\t\te2->revEdge = e1;\n\n\t\t// 因为有自环，不能简单地 N[s]->firstEdge->revEdge = N[t].e，此时正向边已经不是 firstEdge 了\n\n\t\tN[s].deg++;\n\t\tN[t].deg++;\n\t}\n\telse\n\t{\n\t\tN[s].outDeg++;\n\t\tN[t].inDeg++;\n\t}\n}\n\nstd::vector<Edge *> path;\n\n// 无向图\ninline void dfs1(Node *v)\n{\n\twhile (v->e)\n\t{\n\t\tEdge *e = v->e;\n\t\tv->e = v->e->next; // 从邻接表中删边，但实际上未释放内存\n\n\t\tif (e->vis) continue; // 如果它的反向边被删掉了，它的 vis 会被赋值为 true\n\n\t\te->revEdge->vis = true; // 标记反向边已被访问\n\n\t\tdfs1(e->t);\n\n\t\tpath.push_back(e);\n\t}\n}\n\n// 有向图\ninline void dfs2(Node *v)\n{\n\twhile (v->e)\n\t{\n\t\tEdge *e = v->e;\n\t\tv->e = v->e->next; // 从邻接表中删边，但实际上未释放内存\n\n\t\tdfs2(e->t);\n\n\t\tpath.push_back(e);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &T);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(i, u, v); // 带编号加边\n\t}\n\n\tint haveAns = true;\n\tif (T == 1)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].deg % 2 == 1) // 度为奇数\n\t\t\t{\n\t\t\t\thaveAns = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].inDeg != N[i].outDeg) // 入度不等于出度\n\t\t\t{\n\t\t\t\thaveAns = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!haveAns) puts(\"NO\");\n\telse\n\t{\n\t\tif (T == 1)\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (N[i].deg) // 从一个非孤立点开始搜\n\t\t\t\t{\n\t\t\t\t\tdfs1(&N[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (N[i].outDeg) // 从一个非孤立点开始搜\n\t\t\t\t{\n\t\t\t\t\tdfs2(&N[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (path.size() != m) // 如果不能经过所有边\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"YES\");\n\t\t\tfor (int i = path.size() - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tprintf(\"%d%c\", path[i]->id, i == 0 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/euler-circuit-notes.md","raw":"title: 欧拉回路学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 欧拉回路\n  - 算法模板\npermalink: euler-circuit-notes\ndate: 2017-01-01 11:09:00\n---\n\n坑。\n\n<!-- more -->\n\n### 代码（[UOJ #117](http://uoj.ac/problem/117)）\n![zyz 大佬的评价](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 1e5;\n\nstruct Node\n{\n\tstruct Edge *e;\n\tint deg; // 无向图\n\tint inDeg, outDeg; // 有向图\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tint id;\n\tNode *s, *t;\n\tbool vis;\n\tEdge *next, *revEdge;\n\n\tEdge(int id, Node *s, Node *t) : id(id), s(s), t(t), vis(false), next(s->e) {}\n};\n\nint T;\n\ninline void addEdge(int id, int s, int t)\n{\n\tEdge *e1 = N[s].e = new Edge(id, &N[s], &N[t]);\n\n\tif (T == 1)\n\t{\n\t\tEdge *e2 = N[t].e = new Edge(-id, &N[t], &N[s]);\n\n\t\te1->revEdge = e2;\n\t\te2->revEdge = e1;\n\n\t\t// 因为有自环，不能简单地 N[s]->firstEdge->revEdge = N[t].e，此时正向边已经不是 firstEdge 了\n\n\t\tN[s].deg++;\n\t\tN[t].deg++;\n\t}\n\telse\n\t{\n\t\tN[s].outDeg++;\n\t\tN[t].inDeg++;\n\t}\n}\n\nstd::vector<Edge *> path;\n\n// 无向图\ninline void dfs1(Node *v)\n{\n\twhile (v->e)\n\t{\n\t\tEdge *e = v->e;\n\t\tv->e = v->e->next; // 从邻接表中删边，但实际上未释放内存\n\n\t\tif (e->vis) continue; // 如果它的反向边被删掉了，它的 vis 会被赋值为 true\n\n\t\te->revEdge->vis = true; // 标记反向边已被访问\n\n\t\tdfs1(e->t);\n\n\t\tpath.push_back(e);\n\t}\n}\n\n// 有向图\ninline void dfs2(Node *v)\n{\n\twhile (v->e)\n\t{\n\t\tEdge *e = v->e;\n\t\tv->e = v->e->next; // 从邻接表中删边，但实际上未释放内存\n\n\t\tdfs2(e->t);\n\n\t\tpath.push_back(e);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &T);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(i, u, v); // 带编号加边\n\t}\n\n\tint haveAns = true;\n\tif (T == 1)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].deg % 2 == 1) // 度为奇数\n\t\t\t{\n\t\t\t\thaveAns = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].inDeg != N[i].outDeg) // 入度不等于出度\n\t\t\t{\n\t\t\t\thaveAns = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!haveAns) puts(\"NO\");\n\telse\n\t{\n\t\tif (T == 1)\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (N[i].deg) // 从一个非孤立点开始搜\n\t\t\t\t{\n\t\t\t\t\tdfs1(&N[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (N[i].outDeg) // 从一个非孤立点开始搜\n\t\t\t\t{\n\t\t\t\t\tdfs2(&N[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (path.size() != m) // 如果不能经过所有边\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"YES\");\n\t\t\tfor (int i = path.size() - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tprintf(\"%d%c\", path[i]->id, i == 0 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"euler-circuit-notes","published":1,"updated":"2017-01-02T06:38:41.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s360167ooxl1fok2ucx"},{"title":"Edmonds-Karp 费用流学习笔记","date":"2016-02-19T09:04:38.000Z","_content":"\n有一类网络流问题，最大流并不唯一，而每一条边都有一个单位流量的费用，最优解的目标是保证流量最大的前提下使总费用最小。单纯的最大流可以使用 Edmonds-Karp 算法求解，但这个算法不够优，最常用的是 Dinic 算法。但 Edmonds-Karp 确是最小费用流问题最常用的算法。\n\n<!-- more -->\n\n### 定义\n费用（$ \\mathrm{cost} $）：单位流量流过一条边需要支付的费用，算法的目标是使总流量最大的前提下总费用最小。\n\n其他的定义和 Dinic 中基本相同，但 Edmonds-Karp 中没有「层次」和「层次图」的概念。\n\nEdmonds-Karp 的反向边的费用是原边的费用相反数。\n\n### 算法\n1. 在残量网络中以「费用」为距离，沿着未满流边找出一条从源点到汇点的最短路，并进行增广。\n2. 增广时将总费用加上**汇点的距离** $ \\times $ **增广流量**。\n3. 无法找到增广路时算法结束，此时已找出网络的最小费用最大流。\n\n找最短路时，一般使用 Bellman-Ford 算法，因为网络中一般都会存在负权边，而不可能有负环 —— 当有负环时，最小费用最大流不存在。\n\nEdmonds-Karp 基于一个事实：如果当前费用是在当前流量下的最小费用，那么以最小费用增广之后的费用也为增广后的流量下的最小费用。不断增广找到的就是最小费用最大流。\n\n### 代码实现\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 400;\n\nstruct Node {\n\tstruct Edge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity, cost);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0, -cost);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge;\n\tN[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n\ninline void edmondskarp(int s, int t, int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].flow = 0;\n\t\t\tN[i].dist = INT_MAX;\n\t\t\tN[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].flow = INT_MAX;\n\t\tN[s].dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].dist == INT_MAX) break;\n\n\t\tfor (Edge *e = N[t].inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += N[t].flow;\n\t\t\te->reversedEdge->flow -= N[t].flow;\n\t\t}\n\n\t\tflow += N[t].flow;\n\t\tcost += N[t].dist * N[t].flow;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v, cap, cost;\n\t\tscanf(\"%d %d %d %d\", &u, &v, &cap, &cost);\n\t\taddEdge(u, v, cap, cost);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(1, n, n, flow, cost);\n\n\tprintf(\"%d %d\\n\", flow, cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/edmonds-karp-notes.md","raw":"title: Edmonds-Karp 费用流学习笔记\ncategories: OI\ntags: \n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 学习笔记\n  - 算法模板\npermalink: edmonds-karp-notes\ndate: 2016-02-19 17:04:38\n---\n\n有一类网络流问题，最大流并不唯一，而每一条边都有一个单位流量的费用，最优解的目标是保证流量最大的前提下使总费用最小。单纯的最大流可以使用 Edmonds-Karp 算法求解，但这个算法不够优，最常用的是 Dinic 算法。但 Edmonds-Karp 确是最小费用流问题最常用的算法。\n\n<!-- more -->\n\n### 定义\n费用（$ \\mathrm{cost} $）：单位流量流过一条边需要支付的费用，算法的目标是使总流量最大的前提下总费用最小。\n\n其他的定义和 Dinic 中基本相同，但 Edmonds-Karp 中没有「层次」和「层次图」的概念。\n\nEdmonds-Karp 的反向边的费用是原边的费用相反数。\n\n### 算法\n1. 在残量网络中以「费用」为距离，沿着未满流边找出一条从源点到汇点的最短路，并进行增广。\n2. 增广时将总费用加上**汇点的距离** $ \\times $ **增广流量**。\n3. 无法找到增广路时算法结束，此时已找出网络的最小费用最大流。\n\n找最短路时，一般使用 Bellman-Ford 算法，因为网络中一般都会存在负权边，而不可能有负环 —— 当有负环时，最小费用最大流不存在。\n\nEdmonds-Karp 基于一个事实：如果当前费用是在当前流量下的最小费用，那么以最小费用增广之后的费用也为增广后的流量下的最小费用。不断增广找到的就是最小费用最大流。\n\n### 代码实现\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 400;\n\nstruct Node {\n\tstruct Edge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity, cost);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0, -cost);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge;\n\tN[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n\ninline void edmondskarp(int s, int t, int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].flow = 0;\n\t\t\tN[i].dist = INT_MAX;\n\t\t\tN[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].flow = INT_MAX;\n\t\tN[s].dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].dist == INT_MAX) break;\n\n\t\tfor (Edge *e = N[t].inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += N[t].flow;\n\t\t\te->reversedEdge->flow -= N[t].flow;\n\t\t}\n\n\t\tflow += N[t].flow;\n\t\tcost += N[t].dist * N[t].flow;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v, cap, cost;\n\t\tscanf(\"%d %d %d %d\", &u, &v, &cap, &cost);\n\t\taddEdge(u, v, cap, cost);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(1, n, n, flow, cost);\n\n\tprintf(\"%d %d\\n\", flow, cost);\n\n\treturn 0;\n}\n```\n","slug":"edmonds-karp-notes","published":1,"updated":"2016-12-25T03:05:44.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s3c016eooxlotgt0e0n"},{"title":"基于 Docker 容器的沙盒化评测系统","date":"2016-12-13T13:19:00.000Z","_content":"\n在线评测系统（Online Judge）允许用户提交代码，在评测机上运行，并返回运行结果。而用户提交的代码有时是不安全的，它可能会无限创建进程或文件消耗评测机资源，或者建立到远程服务器的连接，给攻击者提供后门。保证评测机安全的方法之一，是使用沙盒（Sandbox）。\n\n<!-- more -->\n\n### 资源的限制\n一般的评测系统都会限制程序的运行资源，如内存、时间用量，进程、线程数量。资源的限制通常使用 `setrlimit()`（Set Resource Limit）来完成。\n\n`setrlimit()` 的帮助文档（Man Page）非常详细，此处不多做介绍。但值得一提的是，`setrlimit()` 限制的时间（`RLIMIT_RTTIME`）是 CPU 时间，而线程被挂起的时间并不计算在内 —— 如调用 `sleep()` 时的延时和 `scanf()` 等待用户输入的时间。为了正确限制目标程序的时间，我们创建一个监视线程，在指定的时间后将目标进程杀死。\n\n### 系统调用的限制\n程序的一切与操作系统有关的操作，比如输入输出，创建进程，获取系统信息等，都需要系统调用（System Call）。如果不限制系统调用，目标程序也可能会有一些危险的行为。比如，目标程序可以获得文件系统的一部分目录结构，如果它运行在与评测系统或 Web 服务器相同的用户下，可能会获取或修改一些影响服务器安全的信息。\n\n目前常用的两个限制系统调用的方案是 `ptrace()` 和 `seccamp`，前者的原理是在目标程序每次尝试进行系统调用时通知评测程序，如果发现危险的系统调用，可以及时将目标程序杀死。但 `ptrace()` 在每次系统调用时都会产生两次中断（进入系统调用前一次，系统调用返回后一次），影响效率。相比之下 `seccamp` 可能是更好的选择。\n\n使用 `ptrace()` 的评测系统有：[HustOJ](https://github.com/zhblue/hustoj)、[UOJ](https://github.com/vfleaking/uoj)；  \n使用 `seccamp` 的评测系统有：[QDUOJ](https://github.com/QingdaoU/Judger)、[TJudger](https://github.com/TimHsue/TJudger)。\n\n### 基于 Docker 的沙盒\n保护系统安全的另一种思路是将目标程序与系统环境隔离，形成一个沙盒（Sandbox）环境。如 `chroot` 可以保证程序只能访问某个目录下的内容，而 Docker 则可以实现完全隔离的容器。\n\n每次运行目标程序时，创建一个 Docker 容器，将输入数据与目标程序的可执行文件传入，创建一个监视进程，`fork()` 出子进程调用 `setrlimit()` 后使用 `exec` 载入目标程序。\n\n对于需要运行环境的语言（如基于 .Net 的语言和 Python 等脚本语言），我们需要把系统中的库目录映射到容器中 —— 一般不需要考虑这样做的安全性，因为容器中的目标程序也是以普通用户运行的，对系统目录没有写权限；而库目录中一般没有可以读到的配置文件等敏感信息。\n\nDocker 提供的网络功能可以用来禁止容器中的目标程序联网。\n\n因为命令行参数拼接可能导致命令注入，所以在实现中没有直接调用 `docker` 命令行工具，而是使用了 [`dockerode`](https://github.com/apocas/dockerode/) 库与 Docker 服务进行通信。\n\n基于 Docker 的沙盒的优点在于不需要限制系统调用，因为一些语言的运行库（如基于 .Net 的语言）或解释器（如 Python 等脚本语言）需要额外的系统调用，而使用对 C++ 等低级语言的限制方法来限制这些语言的程序，可能会将这些系统调用误认为恶意程序而杀死。  \n缺点在于，创建 Docker 容器需要一定开销，经过测试每次运行需要额外的大约一秒的时间。并且，Docker 不能在 32 位操作系统下运行。\n\n### 评测程序的实现\n沙盒只是评测系统的一部分，我们还需要一个评测程序来完成与沙盒和后端 Web 服务器的交互。\n\n评测程序的主要工作是：\n\n1. 循环请求 Web 服务器获取等待评测的记录；\n2. 如果需要，从 Web 服务器下载测试数据并解压；\n3. 根据语言选择编译器进行编译；\n4. 调用沙盒运行目标程序；\n5. 检验程序输出并评分；\n6. 将评测结果上传回 Web 服务器。\n\n最后，用一张图来描述整个评测系统的大致架构：\n\n![](docker-sandbox-judger/image.svg)\n","source":"_posts/docker-sandbox-judger.md","raw":"title: 基于 Docker 容器的沙盒化评测系统\ncategories: OI\ntags: \n  - Docker\n  - 评测系统\npermalink: docker-sandbox-judger\ndate: 2016-12-13 21:19:00\n---\n\n在线评测系统（Online Judge）允许用户提交代码，在评测机上运行，并返回运行结果。而用户提交的代码有时是不安全的，它可能会无限创建进程或文件消耗评测机资源，或者建立到远程服务器的连接，给攻击者提供后门。保证评测机安全的方法之一，是使用沙盒（Sandbox）。\n\n<!-- more -->\n\n### 资源的限制\n一般的评测系统都会限制程序的运行资源，如内存、时间用量，进程、线程数量。资源的限制通常使用 `setrlimit()`（Set Resource Limit）来完成。\n\n`setrlimit()` 的帮助文档（Man Page）非常详细，此处不多做介绍。但值得一提的是，`setrlimit()` 限制的时间（`RLIMIT_RTTIME`）是 CPU 时间，而线程被挂起的时间并不计算在内 —— 如调用 `sleep()` 时的延时和 `scanf()` 等待用户输入的时间。为了正确限制目标程序的时间，我们创建一个监视线程，在指定的时间后将目标进程杀死。\n\n### 系统调用的限制\n程序的一切与操作系统有关的操作，比如输入输出，创建进程，获取系统信息等，都需要系统调用（System Call）。如果不限制系统调用，目标程序也可能会有一些危险的行为。比如，目标程序可以获得文件系统的一部分目录结构，如果它运行在与评测系统或 Web 服务器相同的用户下，可能会获取或修改一些影响服务器安全的信息。\n\n目前常用的两个限制系统调用的方案是 `ptrace()` 和 `seccamp`，前者的原理是在目标程序每次尝试进行系统调用时通知评测程序，如果发现危险的系统调用，可以及时将目标程序杀死。但 `ptrace()` 在每次系统调用时都会产生两次中断（进入系统调用前一次，系统调用返回后一次），影响效率。相比之下 `seccamp` 可能是更好的选择。\n\n使用 `ptrace()` 的评测系统有：[HustOJ](https://github.com/zhblue/hustoj)、[UOJ](https://github.com/vfleaking/uoj)；  \n使用 `seccamp` 的评测系统有：[QDUOJ](https://github.com/QingdaoU/Judger)、[TJudger](https://github.com/TimHsue/TJudger)。\n\n### 基于 Docker 的沙盒\n保护系统安全的另一种思路是将目标程序与系统环境隔离，形成一个沙盒（Sandbox）环境。如 `chroot` 可以保证程序只能访问某个目录下的内容，而 Docker 则可以实现完全隔离的容器。\n\n每次运行目标程序时，创建一个 Docker 容器，将输入数据与目标程序的可执行文件传入，创建一个监视进程，`fork()` 出子进程调用 `setrlimit()` 后使用 `exec` 载入目标程序。\n\n对于需要运行环境的语言（如基于 .Net 的语言和 Python 等脚本语言），我们需要把系统中的库目录映射到容器中 —— 一般不需要考虑这样做的安全性，因为容器中的目标程序也是以普通用户运行的，对系统目录没有写权限；而库目录中一般没有可以读到的配置文件等敏感信息。\n\nDocker 提供的网络功能可以用来禁止容器中的目标程序联网。\n\n因为命令行参数拼接可能导致命令注入，所以在实现中没有直接调用 `docker` 命令行工具，而是使用了 [`dockerode`](https://github.com/apocas/dockerode/) 库与 Docker 服务进行通信。\n\n基于 Docker 的沙盒的优点在于不需要限制系统调用，因为一些语言的运行库（如基于 .Net 的语言）或解释器（如 Python 等脚本语言）需要额外的系统调用，而使用对 C++ 等低级语言的限制方法来限制这些语言的程序，可能会将这些系统调用误认为恶意程序而杀死。  \n缺点在于，创建 Docker 容器需要一定开销，经过测试每次运行需要额外的大约一秒的时间。并且，Docker 不能在 32 位操作系统下运行。\n\n### 评测程序的实现\n沙盒只是评测系统的一部分，我们还需要一个评测程序来完成与沙盒和后端 Web 服务器的交互。\n\n评测程序的主要工作是：\n\n1. 循环请求 Web 服务器获取等待评测的记录；\n2. 如果需要，从 Web 服务器下载测试数据并解压；\n3. 根据语言选择编译器进行编译；\n4. 调用沙盒运行目标程序；\n5. 检验程序输出并评分；\n6. 将评测结果上传回 Web 服务器。\n\n最后，用一张图来描述整个评测系统的大致架构：\n\n![](docker-sandbox-judger/image.svg)\n","slug":"docker-sandbox-judger","published":1,"updated":"2016-12-13T13:24:53.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s3i016mooxlfujpjwv5"},{"title":"Dinic 学习笔记","date":"2016-02-03T10:57:59.000Z","_content":"\nDinic 算法是一种对于网络流问题的增广路算法，它通过对残量网络进行分层，并在层次图上寻找增广路的方式，实现了在 $ O(n ^ 2m) $ 的时间内求出网络的最大流。\n\n<!-- more -->\n\n### 定义\n* 容量：$ \\mathrm{capacity}(e) $ 表示一条有向边 $ e(u, v) $ 的最大允许的流量。\n\n* 流量：$ \\mathrm{flow}(e) $ 表示一条有向边 $ e(u, v) $ 总容量中已被占用的流量。\n\n* 剩余容量：即 $ \\mathrm{capacity}(e) - \\mathrm{flow}(e) $，表示当前时刻某条有向边 $ \\mathrm{e}(u, v) $ 总流量中未被占用的部分。\n\n* 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 $ 0 $，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n\n* 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n\n* 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为**增广流量**。\n\n* 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上**增广流量**的过程。\n\n* 层次： $ \\mathrm{level}(u) $ 表示节点 $ u $ 在层次图中与源点的距离。\n\n* 层次图：在原残量网络中按照每个节点的层次来分层，只保留**相邻两层**的节点的图，**满载（即流量等于容量）的边不存在于层次图中**。\n\n### 算法\n1. 遍历残量网络，建立层次图；\n2. 在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；\n3. 重复第 2 步，直至层次图中不存在增广路，回到第 1 步重新建立层次图；\n4. 直到层次图无法建立，则当前流量即为最大流量。\n\n每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理。\n\n### 优化\nDinic 有一个常见的优化——当前弧优化。\n\n该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFS 这个点的时候直接可以从这条边的下一条边开始。\n\n### 代码实现\n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} N[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n        \tN[i].level = 0;\n            N[i].currentEdge = N[i].firstEdge;\n        }\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge, N[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n```\n","source":"_posts/dinic-notes.md","raw":"title: Dinic 学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 网络流\n  - Dinic\n  - 算法模板  \npermalink: dinic-notes\ndate: 2016-02-03 18:57:59\n---\n\nDinic 算法是一种对于网络流问题的增广路算法，它通过对残量网络进行分层，并在层次图上寻找增广路的方式，实现了在 $ O(n ^ 2m) $ 的时间内求出网络的最大流。\n\n<!-- more -->\n\n### 定义\n* 容量：$ \\mathrm{capacity}(e) $ 表示一条有向边 $ e(u, v) $ 的最大允许的流量。\n\n* 流量：$ \\mathrm{flow}(e) $ 表示一条有向边 $ e(u, v) $ 总容量中已被占用的流量。\n\n* 剩余容量：即 $ \\mathrm{capacity}(e) - \\mathrm{flow}(e) $，表示当前时刻某条有向边 $ \\mathrm{e}(u, v) $ 总流量中未被占用的部分。\n\n* 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 $ 0 $，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n\n* 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n\n* 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余容量为**增广流量**。\n\n* 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上**增广流量**的过程。\n\n* 层次： $ \\mathrm{level}(u) $ 表示节点 $ u $ 在层次图中与源点的距离。\n\n* 层次图：在原残量网络中按照每个节点的层次来分层，只保留**相邻两层**的节点的图，**满载（即流量等于容量）的边不存在于层次图中**。\n\n### 算法\n1. 遍历残量网络，建立层次图；\n2. 在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；\n3. 重复第 2 步，直至层次图中不存在增广路，回到第 1 步重新建立层次图；\n4. 直到层次图无法建立，则当前流量即为最大流量。\n\n每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理。\n\n### 优化\nDinic 有一个常见的优化——当前弧优化。\n\n该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFS 这个点的时候直接可以从这条边的下一条边开始。\n\n### 代码实现\n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} N[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n        \tN[i].level = 0;\n            N[i].currentEdge = N[i].firstEdge;\n        }\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge, N[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n```\n","slug":"dinic-notes","published":1,"updated":"2016-12-24T13:13:48.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s3q016sooxl1qscxmkg"},{"title":"全错位排列递推公式的推导","date":"2016-04-13T07:41:16.000Z","_content":"\n将按照顺序排列的 $ 1 $ ~ $ n $ 打乱，重新排列，要求每个元素都不能在自己原有的位置上，求方案总数。\n\n<!-- more -->\n\n设答案为 $ f(n) $。\n\n首先考虑第 $ n $ 号位置上放哪个元素，有 $ n - 1 $ 种方案，假设放的是 $ 1 $；\n\n考虑把 $ n $ 号元素放在哪个位置，如果我们删掉 $ n $ 号位置（不再考虑原有的 $ 1 $ 号元素），然后把 $ n $ 号元素的标号改为 $ 1 $，这样问题就成为了一个子问题 $ f(n - 1) $。\n\n但是这样考虑是有问题的 —— 原有的 $ n $ 号元素被编号为 1 后，就再也不可能被放到 1 号位置了，但原问题中，这是一种可行方案，所以要把这种情况加上。如果把 $ n $ 号元素放到 1 号位置，可以不再考虑这两个位置，问题转化为另一个子问题 $ f(n - 2) $。\n\n这样，我们得到一个递推式\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","source":"_posts/derangement-number.md","raw":"title: 全错位排列递推公式的推导\ncategories: OI\ntags: \n  - 数学\n  - 学习笔记\n  - 错位排列\npermalink: derangement-number\ndate: 2016-04-13 15:41:16\n---\n\n将按照顺序排列的 $ 1 $ ~ $ n $ 打乱，重新排列，要求每个元素都不能在自己原有的位置上，求方案总数。\n\n<!-- more -->\n\n设答案为 $ f(n) $。\n\n首先考虑第 $ n $ 号位置上放哪个元素，有 $ n - 1 $ 种方案，假设放的是 $ 1 $；\n\n考虑把 $ n $ 号元素放在哪个位置，如果我们删掉 $ n $ 号位置（不再考虑原有的 $ 1 $ 号元素），然后把 $ n $ 号元素的标号改为 $ 1 $，这样问题就成为了一个子问题 $ f(n - 1) $。\n\n但是这样考虑是有问题的 —— 原有的 $ n $ 号元素被编号为 1 后，就再也不可能被放到 1 号位置了，但原问题中，这是一种可行方案，所以要把这种情况加上。如果把 $ n $ 号元素放到 1 号位置，可以不再考虑这两个位置，问题转化为另一个子问题 $ f(n - 2) $。\n\n这样，我们得到一个递推式\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","slug":"derangement-number","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s3w016zooxl934kfe33"},{"title":"「CTSC1999」星际转移 - 网络流","id":"59","updated":"2016-02-24T13:42:46.000Z","date":"2016-02-24T13:41:36.000Z","_content":"\n现有 `n` 个太空站位于地球与月球之间，且有 `m` 艘太空船在其间来回穿梭。每个太空站可容纳无限多的人，第 `i` 个太空船只可容纳 `H[i]` 个人。每艘太空船将周期性地停靠一系列的太空站。每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。求让所有人尽快地全部转移到月球上的最短时间。\n\n<!-- more -->\n\n### 链接\n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### 题解\n话说这题真是难调 …… qwq\n\n考虑到『一个太空站和一个时间点』确定了一个状态，枚举答案 `t`，将每个太空站拆成 `t + 1` 个点（因为初始状态是在 0 时刻）。对于每一个时刻，从**上一时刻每个太空船的停留站**到**这一时刻每个太空船的停留站**连一条边，容量为该太空船载客量；对于任何一个太空站，从上一时刻到这一时刻连一条边，容量为正无穷（表示人停留在太空站）；对于任意时刻的地球，从源点向其连一条边，容量为正无穷；对于任意时刻的月球，从其向汇点连一条边，容量为正无穷。\n\n从小到大枚举答案，答案每增大 1，在原图中加入新边。直到汇点的流量大于等于总人数，则答案合法。\n\n也可以二分答案 …… 不过那样要拆掉图重建，总感觉数据小的情况下比枚举还要慢。qwq\n\n数据范围有坑！数据范围有坑！数据范围有坑！`n` 和 `m` 的最大值颠倒了！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/ctsc1999-home.md","raw":"title: 「CTSC1999」星际转移 - 网络流\ncategories: OI\ntags: \n  - COGS\n  - CTSC\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\n  - 枚举答案\npermalink: ctsc1999-home\nid: 59\nupdated: '2016-02-24 21:42:46'\ndate: 2016-02-24 21:41:36\n---\n\n现有 `n` 个太空站位于地球与月球之间，且有 `m` 艘太空船在其间来回穿梭。每个太空站可容纳无限多的人，第 `i` 个太空船只可容纳 `H[i]` 个人。每艘太空船将周期性地停靠一系列的太空站。每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。求让所有人尽快地全部转移到月球上的最短时间。\n\n<!-- more -->\n\n### 链接\n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### 题解\n话说这题真是难调 …… qwq\n\n考虑到『一个太空站和一个时间点』确定了一个状态，枚举答案 `t`，将每个太空站拆成 `t + 1` 个点（因为初始状态是在 0 时刻）。对于每一个时刻，从**上一时刻每个太空船的停留站**到**这一时刻每个太空船的停留站**连一条边，容量为该太空船载客量；对于任何一个太空站，从上一时刻到这一时刻连一条边，容量为正无穷（表示人停留在太空站）；对于任意时刻的地球，从源点向其连一条边，容量为正无穷；对于任意时刻的月球，从其向汇点连一条边，容量为正无穷。\n\n从小到大枚举答案，答案每增大 1，在原图中加入新边。直到汇点的流量大于等于总人数，则答案合法。\n\n也可以二分答案 …… 不过那样要拆掉图重建，总感觉数据小的情况下比枚举还要慢。qwq\n\n数据范围有坑！数据范围有坑！数据范围有坑！`n` 和 `m` 的最大值颠倒了！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"ctsc1999-home","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s410174ooxl2pkymw5v"},{"title":"「CTSC1997」选课 - 树形 DP","id":"15","updated":"2016-01-19T13:05:52.000Z","date":"2016-01-06T21:12:01.000Z","_content":"\n学校开设了 N（<= 300） 门课程，每门课程有不同的学分，每个学生最多可以选择 M 门课程，有些课程有“先修课”，即这门课必须在先修课选定之后再选，每门课程的先修课最多有一门。求获得学分最多的选课方案。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### 题解\n很显然，这里的依赖关系是以森林的形式给出的，我们增加一个虚拟节点作为所有无先修课的课程的父节点，搜索这棵树，用 $f[i][m]$ 表示选择第 `i` 个节点及其之后节点（兄弟或孩子）中的 `m` 个节点所对应的课程所获得的最大学分，则有两个转移方向：\n\n1. 给第 `i` 个节点和它的**一个或多个子节点**分配一定的课程数量 `k`，剩余课程数量 `m - k - 1` 分给**下一个兄弟节点**。\n2. 不选择第 `i` 个节点，全部课程数量 `m` 分配给**下一个兄弟节点**。\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n树结构储存时使用类似邻接表的结构，储存当前节点的第一个孩子节点，和下一个兄弟节点。\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### 代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","source":"_posts/ctsc1997-course.md","raw":"title: 「CTSC1997」选课 - 树形 DP\ncategories: OI\ntags: \n  - CodeVS\n  - CTSC\n  - DP\n  - 树形 DP\npermalink: ctsc1997-course\nid: 15\nupdated: '2016-01-19 21:05:52'\ndate: 2016-01-07 05:12:01\n---\n\n学校开设了 N（<= 300） 门课程，每门课程有不同的学分，每个学生最多可以选择 M 门课程，有些课程有“先修课”，即这门课必须在先修课选定之后再选，每门课程的先修课最多有一门。求获得学分最多的选课方案。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### 题解\n很显然，这里的依赖关系是以森林的形式给出的，我们增加一个虚拟节点作为所有无先修课的课程的父节点，搜索这棵树，用 $f[i][m]$ 表示选择第 `i` 个节点及其之后节点（兄弟或孩子）中的 `m` 个节点所对应的课程所获得的最大学分，则有两个转移方向：\n\n1. 给第 `i` 个节点和它的**一个或多个子节点**分配一定的课程数量 `k`，剩余课程数量 `m - k - 1` 分给**下一个兄弟节点**。\n2. 不选择第 `i` 个节点，全部课程数量 `m` 分配给**下一个兄弟节点**。\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n树结构储存时使用类似邻接表的结构，储存当前节点的第一个孩子节点，和下一个兄弟节点。\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### 代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","slug":"ctsc1997-course","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4b017fooxl29wv8xxx"},{"title":"CTSC2016 & APIO2016 行纪","date":"2016-05-09T10:18:13.000Z","_content":"\n第一次参加 CTSC & APIO，流水账如下。\n\n<!-- more -->\n\n### 5.1\n早上五点来到了北京，转了两路地铁一路公交又走了段路，终于到了昆泰酒店 ……  \n因为来的有点早，还不能开房，报名人员也没来，只好先在大厅坐下了，感觉这酒店网速不给力啊 QAQ  \n八点开了房，住在十楼，双人间。和我住一间屋的还没来，估计是莱芜或者青岛的神犇？qwq\n\n过了会青岛二中的来了，Oxer 和我住一间屋。去旁边屋里膜了一发 yts1999 大爷，RP++\n\n看了看报名表，看到 Teachk 来了，于是找他面基去了 ovo 还有大连的好几个神犇（虽然我都不认识\n\n和 HA 的小伙伴碰了碰头，CXC 并没有来（唉。。。）  \n中午一起去次饭了 QwQ 食堂的饭好评 只是学校有点远喔 ……\n\n下午睡了一会，醒来去他们那里，~~sui 和 Fancy 在给他们学校高一的同学讲课，讲完~~过了一会我们就去试机了  \nCOGS 观光团到齐了嘛 QwQ ~~然而好多人、姓名、ID 对不起来~~  \n顺便参观了一下八十中的教学楼，好高端 ovo  \n选手用机操作系统是 NOI Linux（Ubuntu 14.04 LTS）好评！  \n~~（想想 SDOI 连个像样的编程环境都没有真是太反人类了啊喂~~\n\nFancy 问我怎样才能把 vim 配置背下来，于是我把每一行的含义给她讲了一遍  \n然而 sui 表示缩写多好记呀~  \n~~我会告诉你们我第一次在 JSOI 考场上写 vim 配置的时候还列出所有命令找了一遍？~~\n\n过一会安师大附中的神犇们来了，在喊试机题目是哪年的 NOI 题目，水水水 …… ~~听不下去了就和小伙伴走了~~  \n逛了逛校园就去次下午饭了~~这里的饭真好次呀~~\n\n次完饭回到酒店，上完厕所发现自己 QQ 登不上了（smg ……  \n喂喂喂我刚才不就是说了一句 %fqk 吗怎么成不良信息了 ……  \n换了个 QQ 号，顺便找到 DQS 神犇加回了之前的群 ……  \n~~辣鸡腾讯，吃枣药丸！~~\n\n晚上找小伙伴们玩，然后被拉到另一个房间，发现 COGS 观光团的人都在。  \nsui：这就是 Menci！  \n众人：%%%%% ……  \n~~Menci：mdzz … &@!#@%~& ……~~\n\n他们说 wmd 明后天会来监考，然后我随口问了一句 Chenyao 怎么不来 ……  \n他们给我指了一下屋子里的某个人，说，这就是 Chenyao ……  \n~~mdzz ……~~\n~~Chenyao 真的好萌好帅呀 Orz！~~\n\n看他们玩了一个叫做『妙不可言』的神奇的卡牌游戏 ……  \n玩了一局之后他们墙裂要求我加入，于是我也没拒绝 ……  \n愉♂快地玩完一局之后发现时间不早了，回屋洗澡睡觉 …… qwq\n\n### 5.2\nCTSC2016 Day1\n\n七点钟从酒店出发，和他们一起去了学校  \n早饭还不错嘛，油条、鸡蛋、煎饼没有果子、豆浆、包子 ……\n\n怎么就我一个在图书馆考啊喂 …… 泥萌都在教学楼 ……  \n图书馆在哪里啊喂 ……  \n哦 …… 就在教学楼旁边 ……\n\n图书馆外面遇到了青岛二中的 dms 神犇，膜了一发 ……  \n诶怎么还不入场 …… 都八点半了啊喂 ……  \n入场之后看了下电脑上的时间，八点四十多 ……  \n~~mdzz ……~~\n\n喝水看题 ……\n\n第一题，蛤？题意都读不懂语文水平真是太差了 ……  \n第三题，提交答案？蛤？（此处省略一张 这题能做？.jpg）  \n第二题，Suffix Array？写个后缀数组打打暴力吧，怎么这么小气才给 5 分暴力分啊 ……  \n\n开始敲后缀数组 ……  \n二十分钟后，后缀数组敲完了 ……  \n对拍一下吧 ……  \n诶怎么显示出错的两行都一样？  \n自己看看输出文件吧，发现有两个排名被弄反了 ……  \n跟踪调试了好久，发现某个地方漏了个 `else` ……  \n~~mdzz ……~~\n\n码好爆搜，试试样例 ……  \n样例一过了 ……  \n样例二输出小了很多 ……  \n调了好久调不出来，最后输出了，诶发现字符串怎么变短了 …… 诶这个 `n` 怎么变小了 ……  \n~~mdzz~~，忘了清数组了 ……\n\n清了数组又试了下样例，怎么还是不对啊喂 ……  \n开始各种乱调 ……  \n调了一个小时，答案没变 ……  \n~~今天上午就杠这题了！杠出来就有 5 分了！~~\n\n『选手注意，第二题第二个样例改为 ……』  \n啊，所以说我的是对的？  \n~~mdzz 我都调了一个多小时了啊喂~~  \n\n看来第二题有 5 分了，冷静下来读了读第一题题意，发现能读懂了，尝试写了下 5 分暴力，很快调出来了 ……\n\n看到了一二两题都有好多部分分，但是不好搞啊 ……  \n看了下 T3，根本不可做啊，题答怎么玩啊我不会 ……\n\n还剩二十分钟了，想想把 T3 全填上随机数吧 …… 说不定能有几分 ……\n\n出了考场，外面下雨了，打开手机接着接到了 Fancy 的电话 ……  \nFancy：我们等了你十多分钟，没等到你，就先去食堂了  \nMenci：&@!#@%~& …… 要不让 sui 来接我吧 ……  \n~~mdzz 为什么只有图书馆延时了啊喂 ……~~\n\n和他们讨论了一下题  \n『第三题第一个点组合数、第二个点 01 背包、第 X 个点矩阵乘法，还真是十合一 ……』  \n蛤？  \n『第一题题意读不懂啊 …… 第二题中间的部分分可以打表找规律 ……』  \n蛤？  \n『第三题搞了搞前两个点，后面的全输出 0 ……』  \n蛤？  \n蛤？蛤？  \nmdzz …… 我为什么要输出随机数啊喂，输出 0 才能得分啊喂 ……\n\n~~我怎么感觉就我分数最低啊喂 ……~~\n\n下午讲题，全程听不懂 …… 听不懂 …… XD  \n第一题 yts1999 用一种奇怪的方法用超哥线段树搞了搞部分分 ……  \n蛤？  \n第三题十个点十个算法 …… 弃疗保平安 ……\n\n看了成绩，`5 + 5 + 2 = 12` 分，第三题随机数炸了 ……  \n果然就我分最低，Fancy 输出 0 拿了 15 分 ……\n\n感觉要 Fe 滚粗了 ……\n\n晚上，sui 给我讲了 HNOI 的几道题，于是我在调题，~~他们都去颓了~~。\n\n### 5.3\n上午，集训队论文答辩，听懂的东西不多啊 …… QAQ（窝还是太弱辣\n\nfaebdc 讲的网络流还是挺赞的 ……\n\n下午报告会，大家都说不想去了 …… 于是打算在酒店碎觉 ……  \n然后接到 Fancy 的电话，说不参加报告会取消明天比赛资格 ……\n\n蛤？赶紧起来走吧 ……  \n在讨论组里问了一下，他们表示都不去 ……  \n\n来到之后报告会已经开始了 …… 人好少 QAQ 看来是没这回事 …… mdzz ……  \n睡觉睡不着了还是打开电脑看题吧 qwq ……  \nsui 打开电脑打一个叫『以撒』（← 是不是这两个字啊喂 0.0）的游戏，好高端 ovo，Fancy 拿出 Kindle 看知乎日报，好高端 ovo ……\n\n放眼望去整个报告厅基本上都在干正事（大雾 ……\n\n晚上正在调题的时候，Fancy 拿起手机问我这人是谁 ……  \nwoc … 这不是 fqk 神犇么！！！  \nfqk：Fancy 是男的女的？  \nMenci：&@!#@%~& ……  \nfqk：wori … （躲在椅子下面.jpg）你常说的 HA 的小伙伴我以为都是男的 …… 我是 sb ……  \n（fqk 本来就是 s（hen）b（en）啊 2333\n\n### 5.4\nCTSC2016 Day2\n\n还是在图书馆，不过这次准时开考了\n\n喝水看题 ……\n\n第一题，蛤？  \n第二题，蛤？  \n第三题，提交答案，蛤？\n\n完了这是要爆零的节奏吗 QAQ 嗯先看看题答吧 …… XD\n\n第一个点数据好小，写个爆搜试试 ……  \n爆搜调出来了，10 分到手  \n搜了一下第二个点，爆内存了，爆内存前得到的最优解才 3 分，不行啊，看看数据试试 ……\n\n只有一个人，没有负边，没有限制 ……  \n这不是网络流么 2333  \n敲了个网络流，还没敲完 …… mdzz …… 啥网络流啊 ……\n\n嗯 …… 试试 SPFA 最长路 qwq ……  \n二十分钟后 …… md怎么一分多种还没跑完，该不会进环了吧 ……  \nmdzz …… 这数据有（you）环（du）！\n\n一想，这不是 APIO2009 的 atm 那题么 ……  \n无奈开始码 Tarjan ……\n\nTarjan 调了快一个小时，我真弱啊这么基础的算法都要调这么久 ……  \n缩点跑最长路，发现答案是对的，然后就是怎么输出路径的问题了 ……  \n脑补了一下，把一个强连通分量走完，然后走到下一个 ……\n\n嗯好像没错，开始写吧 ……  \n写完开始调，诶这个函数怎么没有被调用 ……\n\n~~mdzz ……~~ 怎么只有一个强连通分量啊喂 ……  \n不过这样简单一些，直接走完整个强连通分量就好了\n\n思路是，考虑一棵搜索树上，每条边都能被访问到  \n只要可以沿着原来的边回溯回去，就可以很容易地走完所有边  \n于是在每次回溯的时候再跑一遍另一个搜索，搜出一条路径来\n\n写完之后调了半个小时，开 `O3` 跑了一分多种终于跑出来了  \n打开输出文件一看，有大约 n 平方条边 …… 输出文件 3M+  \n`checker` 跑了一秒多，答案是对的，20 分有了 ……\n\n看了下，发现这个点和其他点不一样，这个程序跑不出其他的点 QAQ 只好爆搜，但每个点都连个可行解都搜不出来 ……  \n还剩不到二十分钟了，弃疗吧 …… XD\n\n前两题都没写 ……\n\n中午在食堂遇见 Dashgua，他说第三题直接 SPFA，遇到环就跳出来，就有 70 分了 ……  \n~~mdzz ……~~  \n感觉自己真的连 Cu 都拿不到啊 ……  \ndms 说他 A 了一提，太神啦！\n\n下午讲题，很多人吐槽题答被乱搞好几十分，个个的程序都比我简单 …… ~~mdzz ……~~\n\n晚上闭幕式，中间的游戏环节有个猜谜，明明我猜出来了但主持人没听到 qwq （`O(E)` 不是 SPFA 还能是啥啊喂  \n宣读获奖名单，果然 Fe 滚粗了 QAQ\n\n回到酒店，被青岛二中的拐走了，yts1999、Oxer、dms、heheda 等几位神犇都在 ……  \n于是他们教我一种叫做『够级』的扑克牌游戏 2333 ……\n\n玩了几局之后就跑下去了 qwq  \n想起来还没找胜利一中的 abclzr 神犇面基呢，于是就先去找到了他聊了一会，lzr 好神啊！\n\nKZ 要我帮他调一下 Ubuntu、Windows 双系统的时间设置 …… 虽然没搞过但听起来好简单的样子  \n调了好久最后发现改改时区就可以 ……\n\n### 5.5\n休息日。\n\n上午他们睡到很晚才起来 ……\n\n去学校次早饭回来的路上，讨论组里  \nKZ：把 Menci 叫过来，我们要吃饭 ……  \nFancy：Menci 能吃吗？  \n~~Menci：&@!#@%~&~~  \n~~此处应有『一脸茫然.jpg』~~\n\n回来之后调了一会题又该次中午饭了 qvq\n\nFancy 说她小姨要带她去天安门，好高端 ……  \n其他人商量着去香山，窝表示对此并不感兴趣 ……\n\n于是中午自己回来了，睡醒觉就四点多了，写了一会题，不知不觉一道题写了 N 天了 ……\n\n晚上看见 SDOI 群里有人搞大新闻 ……（此处省略 &@!#@%~&）…… 233333333\n\n### 5.6\n听说 fqk 的学长要来讲课？太神辣！\n\n到了讲厅，抢了第一排的座位近距离围观，然而并不能听懂什么高端的 XXXX 搜索算法 Orz，下课期间上去问了问，还真是 fqk 的学长（这还有假？\n\n唉，听不懂弃疗吧 qwq ……\n\n晚上把 HNOI 某树调出来了，又按照神兽的做法写了写 APIO 练习赛的交互，好水的题 qwq  \nAPIO 的题不可能这么水吧\n\n### 5.7\nAPIO2016 Day1\n\nAPIO 的开考时间晚一些，可以提前进场 qwq 于是就可以先写好 vim 配置了 ……\n\n省常中的 Johann 神犇坐我左边，%%% ……\n\n题目有纸张和 PDF 的，在线评测实时反馈，好高端 qwq\n\n喝水看题 ……\n\n第一题，蛤？打个暴力试试 ……  \n第二题，蛤？第一个子任务我都不会啊 ……  \n第三题，蛤？交互，限制啥啥啥次数？\n\n打好了第一题暴力，冷静下来想了想其实第一个子任务就是一个序列，求所有单调上升序列数量。怎么跟食物链这么像呢 …… 建图拓扑排序然后直接 DP 嘛 …… 半个小时才调出来（暴露水平了 XD\n\n第二题第一个子任务 …… 试试平均数？不行啊，打个暴力吧 …… 发现答案是全部变成这些数中的其中一个，那就枚举一遍这些数吧 ……\n\n两个半小时拿了 16 分了 ……\n\n看第三题，上来一个小时啥都不会，后来一想，~~mdzz~~ …… 直接从两边向中间逼近，然后得到整个序列不就好了 ……  \n提交，30.38 分 …… 这样就有 46.38 分了 …… 还不够啊，想想第二个子任务 ……\n\n脑补了一下感觉二分复杂度是对的，随便写了一个交上去发现才 42 分，哪里不对？卡卡常试试 ……  \n卡了卡常交上去发现 WA 了，发现漏情况了，改了之后又交上去 …… 诶，怎么不评测了 ……\n\n用 CMS 自带的提问功能问了一下主办方，被告知服务器不稳定 ……（~~辣鸡服务器，毁我比赛~~  \n于是只好自己对拍，发现是对的，继续卡常数，发现卡不到很低了，感觉这不是正解~~（当然不是）~~……\n\n最后又交了一下，还是评不出来，而且没给加时 …… 就这样结束了\n\n下午讲题，T3 正解分块 …… 我傻逼了都想到鸽笼原理的怎么就不分块呢 ……  \nT2 我原本想到的子任务 2 的树形 DP 是对的，没时间写了啊 …… QAQ\n\n发现又是就我分低，这是三题签到分啊，又要 Fe 滚粗了么 XD\n\n晚上他们都去 THU 看智能体大赛了，然而我表示并不想去，就会酒店找湖北的小伙伴玩了 QwQ  \n和 Fuxey 和 Sengxian 他们聊了一晚上，十一点多才回去 …… qwq  \nSengxian 表示他才是**真·签到分**，46.38 分 23333\n\n### 5.8\n听课。\n\n上午讲物理引擎 …… smg …… 拿出笔记本电脑准备写 sui 给我讲的题 …… 诶怎么开不了机 ……  \nmdzz …… 昨晚忘关机了，没电了 XD\n\n于是 Fancy 把笔记本电脑借给了我，写了一上午的题，还是没调出来 ……  \n下午还是听不懂课，继续调题 …… 然而 Fancy 的电脑也没电了 XD\n\n晚上闭幕式 …… Cu 线好低，46 分就有 ……\n\n回到酒店又被青岛二中的拐走了，zdw1999 竟然也被拐过去了 qvq  \n打了两局保皇 ……\n\n于是又去找 HA 的小伙伴了 …… 刚进房间大家都很兴奋的样子 …… ~~这是要搞个大新闻？~~\n\n~~（由于某些原因，此处删除若干字）~~\n\n然后继续调今天上午写的题，过了样例，交到 COGS 上，WWTTTTTTTT，弃疗 ……\n\n最后帮 Fancy 搞了搞 Ubuntu 下的指纹识别，KZ 表示也要我帮他弄弄，然而已经快十二点了 …… XD\n\n### 5.9\n早上八点去次饭，get 成就 最后一个走出食堂 23333\n\n晚上的火车，于是先在酒店待了一上午 ……\n\n考虑到车站环境并不太好，又在酒店大厅里待了一下午 …… qwq\n\n晚上就要坐车回去咯 ……\n\n再见 ……\n","source":"_posts/ctsc-apio-2016.md","raw":"title: CTSC2016 & APIO2016 行纪\ncategories: \n  - Diary\npermalink: ctsc-apio-2016\ndate: 2016-05-09 18:18:13\n---\n\n第一次参加 CTSC & APIO，流水账如下。\n\n<!-- more -->\n\n### 5.1\n早上五点来到了北京，转了两路地铁一路公交又走了段路，终于到了昆泰酒店 ……  \n因为来的有点早，还不能开房，报名人员也没来，只好先在大厅坐下了，感觉这酒店网速不给力啊 QAQ  \n八点开了房，住在十楼，双人间。和我住一间屋的还没来，估计是莱芜或者青岛的神犇？qwq\n\n过了会青岛二中的来了，Oxer 和我住一间屋。去旁边屋里膜了一发 yts1999 大爷，RP++\n\n看了看报名表，看到 Teachk 来了，于是找他面基去了 ovo 还有大连的好几个神犇（虽然我都不认识\n\n和 HA 的小伙伴碰了碰头，CXC 并没有来（唉。。。）  \n中午一起去次饭了 QwQ 食堂的饭好评 只是学校有点远喔 ……\n\n下午睡了一会，醒来去他们那里，~~sui 和 Fancy 在给他们学校高一的同学讲课，讲完~~过了一会我们就去试机了  \nCOGS 观光团到齐了嘛 QwQ ~~然而好多人、姓名、ID 对不起来~~  \n顺便参观了一下八十中的教学楼，好高端 ovo  \n选手用机操作系统是 NOI Linux（Ubuntu 14.04 LTS）好评！  \n~~（想想 SDOI 连个像样的编程环境都没有真是太反人类了啊喂~~\n\nFancy 问我怎样才能把 vim 配置背下来，于是我把每一行的含义给她讲了一遍  \n然而 sui 表示缩写多好记呀~  \n~~我会告诉你们我第一次在 JSOI 考场上写 vim 配置的时候还列出所有命令找了一遍？~~\n\n过一会安师大附中的神犇们来了，在喊试机题目是哪年的 NOI 题目，水水水 …… ~~听不下去了就和小伙伴走了~~  \n逛了逛校园就去次下午饭了~~这里的饭真好次呀~~\n\n次完饭回到酒店，上完厕所发现自己 QQ 登不上了（smg ……  \n喂喂喂我刚才不就是说了一句 %fqk 吗怎么成不良信息了 ……  \n换了个 QQ 号，顺便找到 DQS 神犇加回了之前的群 ……  \n~~辣鸡腾讯，吃枣药丸！~~\n\n晚上找小伙伴们玩，然后被拉到另一个房间，发现 COGS 观光团的人都在。  \nsui：这就是 Menci！  \n众人：%%%%% ……  \n~~Menci：mdzz … &@!#@%~& ……~~\n\n他们说 wmd 明后天会来监考，然后我随口问了一句 Chenyao 怎么不来 ……  \n他们给我指了一下屋子里的某个人，说，这就是 Chenyao ……  \n~~mdzz ……~~\n~~Chenyao 真的好萌好帅呀 Orz！~~\n\n看他们玩了一个叫做『妙不可言』的神奇的卡牌游戏 ……  \n玩了一局之后他们墙裂要求我加入，于是我也没拒绝 ……  \n愉♂快地玩完一局之后发现时间不早了，回屋洗澡睡觉 …… qwq\n\n### 5.2\nCTSC2016 Day1\n\n七点钟从酒店出发，和他们一起去了学校  \n早饭还不错嘛，油条、鸡蛋、煎饼没有果子、豆浆、包子 ……\n\n怎么就我一个在图书馆考啊喂 …… 泥萌都在教学楼 ……  \n图书馆在哪里啊喂 ……  \n哦 …… 就在教学楼旁边 ……\n\n图书馆外面遇到了青岛二中的 dms 神犇，膜了一发 ……  \n诶怎么还不入场 …… 都八点半了啊喂 ……  \n入场之后看了下电脑上的时间，八点四十多 ……  \n~~mdzz ……~~\n\n喝水看题 ……\n\n第一题，蛤？题意都读不懂语文水平真是太差了 ……  \n第三题，提交答案？蛤？（此处省略一张 这题能做？.jpg）  \n第二题，Suffix Array？写个后缀数组打打暴力吧，怎么这么小气才给 5 分暴力分啊 ……  \n\n开始敲后缀数组 ……  \n二十分钟后，后缀数组敲完了 ……  \n对拍一下吧 ……  \n诶怎么显示出错的两行都一样？  \n自己看看输出文件吧，发现有两个排名被弄反了 ……  \n跟踪调试了好久，发现某个地方漏了个 `else` ……  \n~~mdzz ……~~\n\n码好爆搜，试试样例 ……  \n样例一过了 ……  \n样例二输出小了很多 ……  \n调了好久调不出来，最后输出了，诶发现字符串怎么变短了 …… 诶这个 `n` 怎么变小了 ……  \n~~mdzz~~，忘了清数组了 ……\n\n清了数组又试了下样例，怎么还是不对啊喂 ……  \n开始各种乱调 ……  \n调了一个小时，答案没变 ……  \n~~今天上午就杠这题了！杠出来就有 5 分了！~~\n\n『选手注意，第二题第二个样例改为 ……』  \n啊，所以说我的是对的？  \n~~mdzz 我都调了一个多小时了啊喂~~  \n\n看来第二题有 5 分了，冷静下来读了读第一题题意，发现能读懂了，尝试写了下 5 分暴力，很快调出来了 ……\n\n看到了一二两题都有好多部分分，但是不好搞啊 ……  \n看了下 T3，根本不可做啊，题答怎么玩啊我不会 ……\n\n还剩二十分钟了，想想把 T3 全填上随机数吧 …… 说不定能有几分 ……\n\n出了考场，外面下雨了，打开手机接着接到了 Fancy 的电话 ……  \nFancy：我们等了你十多分钟，没等到你，就先去食堂了  \nMenci：&@!#@%~& …… 要不让 sui 来接我吧 ……  \n~~mdzz 为什么只有图书馆延时了啊喂 ……~~\n\n和他们讨论了一下题  \n『第三题第一个点组合数、第二个点 01 背包、第 X 个点矩阵乘法，还真是十合一 ……』  \n蛤？  \n『第一题题意读不懂啊 …… 第二题中间的部分分可以打表找规律 ……』  \n蛤？  \n『第三题搞了搞前两个点，后面的全输出 0 ……』  \n蛤？  \n蛤？蛤？  \nmdzz …… 我为什么要输出随机数啊喂，输出 0 才能得分啊喂 ……\n\n~~我怎么感觉就我分数最低啊喂 ……~~\n\n下午讲题，全程听不懂 …… 听不懂 …… XD  \n第一题 yts1999 用一种奇怪的方法用超哥线段树搞了搞部分分 ……  \n蛤？  \n第三题十个点十个算法 …… 弃疗保平安 ……\n\n看了成绩，`5 + 5 + 2 = 12` 分，第三题随机数炸了 ……  \n果然就我分最低，Fancy 输出 0 拿了 15 分 ……\n\n感觉要 Fe 滚粗了 ……\n\n晚上，sui 给我讲了 HNOI 的几道题，于是我在调题，~~他们都去颓了~~。\n\n### 5.3\n上午，集训队论文答辩，听懂的东西不多啊 …… QAQ（窝还是太弱辣\n\nfaebdc 讲的网络流还是挺赞的 ……\n\n下午报告会，大家都说不想去了 …… 于是打算在酒店碎觉 ……  \n然后接到 Fancy 的电话，说不参加报告会取消明天比赛资格 ……\n\n蛤？赶紧起来走吧 ……  \n在讨论组里问了一下，他们表示都不去 ……  \n\n来到之后报告会已经开始了 …… 人好少 QAQ 看来是没这回事 …… mdzz ……  \n睡觉睡不着了还是打开电脑看题吧 qwq ……  \nsui 打开电脑打一个叫『以撒』（← 是不是这两个字啊喂 0.0）的游戏，好高端 ovo，Fancy 拿出 Kindle 看知乎日报，好高端 ovo ……\n\n放眼望去整个报告厅基本上都在干正事（大雾 ……\n\n晚上正在调题的时候，Fancy 拿起手机问我这人是谁 ……  \nwoc … 这不是 fqk 神犇么！！！  \nfqk：Fancy 是男的女的？  \nMenci：&@!#@%~& ……  \nfqk：wori … （躲在椅子下面.jpg）你常说的 HA 的小伙伴我以为都是男的 …… 我是 sb ……  \n（fqk 本来就是 s（hen）b（en）啊 2333\n\n### 5.4\nCTSC2016 Day2\n\n还是在图书馆，不过这次准时开考了\n\n喝水看题 ……\n\n第一题，蛤？  \n第二题，蛤？  \n第三题，提交答案，蛤？\n\n完了这是要爆零的节奏吗 QAQ 嗯先看看题答吧 …… XD\n\n第一个点数据好小，写个爆搜试试 ……  \n爆搜调出来了，10 分到手  \n搜了一下第二个点，爆内存了，爆内存前得到的最优解才 3 分，不行啊，看看数据试试 ……\n\n只有一个人，没有负边，没有限制 ……  \n这不是网络流么 2333  \n敲了个网络流，还没敲完 …… mdzz …… 啥网络流啊 ……\n\n嗯 …… 试试 SPFA 最长路 qwq ……  \n二十分钟后 …… md怎么一分多种还没跑完，该不会进环了吧 ……  \nmdzz …… 这数据有（you）环（du）！\n\n一想，这不是 APIO2009 的 atm 那题么 ……  \n无奈开始码 Tarjan ……\n\nTarjan 调了快一个小时，我真弱啊这么基础的算法都要调这么久 ……  \n缩点跑最长路，发现答案是对的，然后就是怎么输出路径的问题了 ……  \n脑补了一下，把一个强连通分量走完，然后走到下一个 ……\n\n嗯好像没错，开始写吧 ……  \n写完开始调，诶这个函数怎么没有被调用 ……\n\n~~mdzz ……~~ 怎么只有一个强连通分量啊喂 ……  \n不过这样简单一些，直接走完整个强连通分量就好了\n\n思路是，考虑一棵搜索树上，每条边都能被访问到  \n只要可以沿着原来的边回溯回去，就可以很容易地走完所有边  \n于是在每次回溯的时候再跑一遍另一个搜索，搜出一条路径来\n\n写完之后调了半个小时，开 `O3` 跑了一分多种终于跑出来了  \n打开输出文件一看，有大约 n 平方条边 …… 输出文件 3M+  \n`checker` 跑了一秒多，答案是对的，20 分有了 ……\n\n看了下，发现这个点和其他点不一样，这个程序跑不出其他的点 QAQ 只好爆搜，但每个点都连个可行解都搜不出来 ……  \n还剩不到二十分钟了，弃疗吧 …… XD\n\n前两题都没写 ……\n\n中午在食堂遇见 Dashgua，他说第三题直接 SPFA，遇到环就跳出来，就有 70 分了 ……  \n~~mdzz ……~~  \n感觉自己真的连 Cu 都拿不到啊 ……  \ndms 说他 A 了一提，太神啦！\n\n下午讲题，很多人吐槽题答被乱搞好几十分，个个的程序都比我简单 …… ~~mdzz ……~~\n\n晚上闭幕式，中间的游戏环节有个猜谜，明明我猜出来了但主持人没听到 qwq （`O(E)` 不是 SPFA 还能是啥啊喂  \n宣读获奖名单，果然 Fe 滚粗了 QAQ\n\n回到酒店，被青岛二中的拐走了，yts1999、Oxer、dms、heheda 等几位神犇都在 ……  \n于是他们教我一种叫做『够级』的扑克牌游戏 2333 ……\n\n玩了几局之后就跑下去了 qwq  \n想起来还没找胜利一中的 abclzr 神犇面基呢，于是就先去找到了他聊了一会，lzr 好神啊！\n\nKZ 要我帮他调一下 Ubuntu、Windows 双系统的时间设置 …… 虽然没搞过但听起来好简单的样子  \n调了好久最后发现改改时区就可以 ……\n\n### 5.5\n休息日。\n\n上午他们睡到很晚才起来 ……\n\n去学校次早饭回来的路上，讨论组里  \nKZ：把 Menci 叫过来，我们要吃饭 ……  \nFancy：Menci 能吃吗？  \n~~Menci：&@!#@%~&~~  \n~~此处应有『一脸茫然.jpg』~~\n\n回来之后调了一会题又该次中午饭了 qvq\n\nFancy 说她小姨要带她去天安门，好高端 ……  \n其他人商量着去香山，窝表示对此并不感兴趣 ……\n\n于是中午自己回来了，睡醒觉就四点多了，写了一会题，不知不觉一道题写了 N 天了 ……\n\n晚上看见 SDOI 群里有人搞大新闻 ……（此处省略 &@!#@%~&）…… 233333333\n\n### 5.6\n听说 fqk 的学长要来讲课？太神辣！\n\n到了讲厅，抢了第一排的座位近距离围观，然而并不能听懂什么高端的 XXXX 搜索算法 Orz，下课期间上去问了问，还真是 fqk 的学长（这还有假？\n\n唉，听不懂弃疗吧 qwq ……\n\n晚上把 HNOI 某树调出来了，又按照神兽的做法写了写 APIO 练习赛的交互，好水的题 qwq  \nAPIO 的题不可能这么水吧\n\n### 5.7\nAPIO2016 Day1\n\nAPIO 的开考时间晚一些，可以提前进场 qwq 于是就可以先写好 vim 配置了 ……\n\n省常中的 Johann 神犇坐我左边，%%% ……\n\n题目有纸张和 PDF 的，在线评测实时反馈，好高端 qwq\n\n喝水看题 ……\n\n第一题，蛤？打个暴力试试 ……  \n第二题，蛤？第一个子任务我都不会啊 ……  \n第三题，蛤？交互，限制啥啥啥次数？\n\n打好了第一题暴力，冷静下来想了想其实第一个子任务就是一个序列，求所有单调上升序列数量。怎么跟食物链这么像呢 …… 建图拓扑排序然后直接 DP 嘛 …… 半个小时才调出来（暴露水平了 XD\n\n第二题第一个子任务 …… 试试平均数？不行啊，打个暴力吧 …… 发现答案是全部变成这些数中的其中一个，那就枚举一遍这些数吧 ……\n\n两个半小时拿了 16 分了 ……\n\n看第三题，上来一个小时啥都不会，后来一想，~~mdzz~~ …… 直接从两边向中间逼近，然后得到整个序列不就好了 ……  \n提交，30.38 分 …… 这样就有 46.38 分了 …… 还不够啊，想想第二个子任务 ……\n\n脑补了一下感觉二分复杂度是对的，随便写了一个交上去发现才 42 分，哪里不对？卡卡常试试 ……  \n卡了卡常交上去发现 WA 了，发现漏情况了，改了之后又交上去 …… 诶，怎么不评测了 ……\n\n用 CMS 自带的提问功能问了一下主办方，被告知服务器不稳定 ……（~~辣鸡服务器，毁我比赛~~  \n于是只好自己对拍，发现是对的，继续卡常数，发现卡不到很低了，感觉这不是正解~~（当然不是）~~……\n\n最后又交了一下，还是评不出来，而且没给加时 …… 就这样结束了\n\n下午讲题，T3 正解分块 …… 我傻逼了都想到鸽笼原理的怎么就不分块呢 ……  \nT2 我原本想到的子任务 2 的树形 DP 是对的，没时间写了啊 …… QAQ\n\n发现又是就我分低，这是三题签到分啊，又要 Fe 滚粗了么 XD\n\n晚上他们都去 THU 看智能体大赛了，然而我表示并不想去，就会酒店找湖北的小伙伴玩了 QwQ  \n和 Fuxey 和 Sengxian 他们聊了一晚上，十一点多才回去 …… qwq  \nSengxian 表示他才是**真·签到分**，46.38 分 23333\n\n### 5.8\n听课。\n\n上午讲物理引擎 …… smg …… 拿出笔记本电脑准备写 sui 给我讲的题 …… 诶怎么开不了机 ……  \nmdzz …… 昨晚忘关机了，没电了 XD\n\n于是 Fancy 把笔记本电脑借给了我，写了一上午的题，还是没调出来 ……  \n下午还是听不懂课，继续调题 …… 然而 Fancy 的电脑也没电了 XD\n\n晚上闭幕式 …… Cu 线好低，46 分就有 ……\n\n回到酒店又被青岛二中的拐走了，zdw1999 竟然也被拐过去了 qvq  \n打了两局保皇 ……\n\n于是又去找 HA 的小伙伴了 …… 刚进房间大家都很兴奋的样子 …… ~~这是要搞个大新闻？~~\n\n~~（由于某些原因，此处删除若干字）~~\n\n然后继续调今天上午写的题，过了样例，交到 COGS 上，WWTTTTTTTT，弃疗 ……\n\n最后帮 Fancy 搞了搞 Ubuntu 下的指纹识别，KZ 表示也要我帮他弄弄，然而已经快十二点了 …… XD\n\n### 5.9\n早上八点去次饭，get 成就 最后一个走出食堂 23333\n\n晚上的火车，于是先在酒店待了一上午 ……\n\n考虑到车站环境并不太好，又在酒店大厅里待了一下午 …… qwq\n\n晚上就要坐车回去咯 ……\n\n再见 ……\n","slug":"ctsc-apio-2016","published":1,"updated":"2016-11-20T15:49:31.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4g017looxld0m4k1w0"},{"title":"「CQOI2016」手机号码 - 数位 DP","date":"2016-04-21T15:31:24.000Z","_content":"\n工具需要检测的号码特征有两个：号码中要出现至少 $ 3 $ 个相邻的相同数字，号码中不能同时出现 $ 8 $ 和 $ 4 $。号码必须同时包含两个特征才满足条件。满足条件的号码例如：$ 3000988721 $、$ 23333333333 $、$ 14444101000 $。而不满足条件的号码例如：$ 1015400080 $、$ 10010012022 $。\n\n手机号码一定是 $ 11 $ 位数，前不含前导的 $ 0 $。工具接收两个数 $ L $ 和 $ R $，自动统计出 $ [L, R] $ 区间内所有满足条件的号码数量。$ L $ 和 $ R $ 也是 $ 11 $ 位的手机号码。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### 题解\n设 $ F(x) $ 表示小于等于 $ x $ 的电话号码中合法的数量，$ F(R) - F(L - 1) $ 即为答案。\n\n计算 $ F(x) $ 时枚举最高位，使用数位 DP，状态为：\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n从前到后依次表示：还剩几位、最高位最大是几（$ 10 $ 表示从这一位开始均不限制）、上一位是几、上一位与上上一位是否相等、是否已有三个相邻的相同数字、是否已有 $ 4 $、是否已有 $ 8 $。\n\n转移时，枚举最高位上的数，如果最高位 $ < limit $，则之后的位上的数的大小均无限制。如果上上一位于上一位相等且当前位于上一位相等，认为已有三个相邻的相同数字。\n\n每次数位 DP 的时间复杂度为 $ O(10 ^ 4 * 2 ^ 4) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-number.md","raw":"title: 「CQOI2016」手机号码 - 数位 DP\ndate: 2016-04-21 23:31:24\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - 数位 DP\n  - DP\npermalink: cqoi2016-number\n---\n\n工具需要检测的号码特征有两个：号码中要出现至少 $ 3 $ 个相邻的相同数字，号码中不能同时出现 $ 8 $ 和 $ 4 $。号码必须同时包含两个特征才满足条件。满足条件的号码例如：$ 3000988721 $、$ 23333333333 $、$ 14444101000 $。而不满足条件的号码例如：$ 1015400080 $、$ 10010012022 $。\n\n手机号码一定是 $ 11 $ 位数，前不含前导的 $ 0 $。工具接收两个数 $ L $ 和 $ R $，自动统计出 $ [L, R] $ 区间内所有满足条件的号码数量。$ L $ 和 $ R $ 也是 $ 11 $ 位的手机号码。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### 题解\n设 $ F(x) $ 表示小于等于 $ x $ 的电话号码中合法的数量，$ F(R) - F(L - 1) $ 即为答案。\n\n计算 $ F(x) $ 时枚举最高位，使用数位 DP，状态为：\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n从前到后依次表示：还剩几位、最高位最大是几（$ 10 $ 表示从这一位开始均不限制）、上一位是几、上一位与上上一位是否相等、是否已有三个相邻的相同数字、是否已有 $ 4 $、是否已有 $ 8 $。\n\n转移时，枚举最高位上的数，如果最高位 $ < limit $，则之后的位上的数的大小均无限制。如果上上一位于上一位相等且当前位于上一位相等，认为已有三个相邻的相同数字。\n\n每次数位 DP 的时间复杂度为 $ O(10 ^ 4 * 2 ^ 4) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-number","published":1,"updated":"2016-10-24T23:35:36.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4j017nooxl9ak6md5m"},{"title":"「CQOI2016」不同的最小割 - 分治 + 网络流","date":"2016-04-21T10:57:52.000Z","_content":"\n对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $ s $，$ t $ 不在同一个部分中，则称这个划分是关于 $ s $，$ t $ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $ s $，$ t $ 的最小割指的是在关于 $ s $，$ t $ 的割中容量最小的割。\n\n考虑有 $ N $ 个点的无向连通图中所有点对的最小割的容量，共能得到 $ \\frac{N(N − 1)}{2} $个数值。这些数值中互不相同的有多少个呢？\n\n<!-- more -->\n\n### 链接\n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### 题解\n首先从所有点中，任选两个点 $ s $、$ t $ 做最小割，可以得到 $ S $ 和 $ T $ 两个集合。\n\n然后从 $ S $ 集合（$ T $ 集合对应相同）中任选一个点 $ u $，做 $ s $ 和 $ u $ 的最小割（全局），得到两个集合 $ S' $、$ T' $，取出 $ S $ 和 $ S' $ 的交集，作为新的集合递归下去。直到集合中只剩下一个点为止。\n\n上述操作共进行了 $ N - 1 $ 次，所得的所有最小割容量中不同的数量即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-cuts.md","raw":"title: 「CQOI2016」不同的最小割 - 分治 + 网络流\ndate: 2016-04-21 18:57:52\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - 网络流\n  - Dinic\n  - 分治\npermalink: cqoi2016-cuts\n---\n\n对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $ s $，$ t $ 不在同一个部分中，则称这个划分是关于 $ s $，$ t $ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $ s $，$ t $ 的最小割指的是在关于 $ s $，$ t $ 的割中容量最小的割。\n\n考虑有 $ N $ 个点的无向连通图中所有点对的最小割的容量，共能得到 $ \\frac{N(N − 1)}{2} $个数值。这些数值中互不相同的有多少个呢？\n\n<!-- more -->\n\n### 链接\n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### 题解\n首先从所有点中，任选两个点 $ s $、$ t $ 做最小割，可以得到 $ S $ 和 $ T $ 两个集合。\n\n然后从 $ S $ 集合（$ T $ 集合对应相同）中任选一个点 $ u $，做 $ s $ 和 $ u $ 的最小割（全局），得到两个集合 $ S' $、$ T' $，取出 $ S $ 和 $ S' $ 的交集，作为新的集合递归下去。直到集合中只剩下一个点为止。\n\n上述操作共进行了 $ N - 1 $ 次，所得的所有最小割容量中不同的数量即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-cuts","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4q017uooxldtfgrhmn"},{"title":"「CQOI2011」动态逆序对 - CDQ","date":"2016-06-20T12:10:00.000Z","_content":"\n对于序列 $ A $，它的逆序对数定义为满足 $ i < j $，且 $ A_i > A_j $ 的数对 $ (i,\\ j) $ 的个数。给 $ 1 $ 到 $ n $ 的一个排列，按照某种顺序依次删除 $ m $ 个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3295](http://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n### 题解\n离线将删除转换为添加，并在开始将未被删除的元素加入。\n\n考虑加入一个元素时，增加的逆序对数量 —— 等于在它**左边**比它**大**的元素数量加在它**右边**比它**小**的元素数量。\n\n对于前一半，将每个数 $ a_i $ 改为 $ n - a_i + 1 $，则转化为在它**左边**比它**小**的数量，经典的三维（时间、位置、大小）偏序问题，使用 CDQ 分治解决。\n\n对于后一半，将每个数的位置 $ i $ 改为 $ n - i + 1 $，则同样转化为在它左边比它小的数量，同理用 CDQ 分治解决即可。\n\n求出每次对答案的贡献后做前缀和即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 50000;\n\nstruct Triple {\n\tint id, pos, num;\n\tunsigned int *ans;\n\n\tTriple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tTriple() {}\n\t\n\tbool operator<(const Triple &other) const { return id < other.id; }\n} a[MAXN];\n\nint n, m;\n\nstruct BinaryIndexedTree {\n\tunsigned int a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tunsigned int query(const int x) {\n\t\tunsigned int ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\t/*\n\tfor (Triple *a = l; a <= r; a++) {\n\t\tif (a->ans) {\n\t\t\tfor (Triple *b = l; b < a; b++) {\n\t\t\t\tif (b->pos < a->pos && b->num < a->num) (*a->ans)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tif (l == r) return;\n\n\tTriple *m = l + (r - l) / 2;\n\n\tcdq(l, m);\n\tcdq(m + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = m + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= m && p1->pos <= p2->pos) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tbit.update(q->num, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) *q->ans += bit.query(q->num);\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\tbit.clear(q->num);\n\t\t*p = *q;\n\t\tassert(p->num != 0);\n\t}\n}\n\n/*\ninline void print() {\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"[%d, %d, %d]%s\", a[i].id, a[i].pos, a[i].num, i == n - 1 ? \"\\n\" : \", \");\n\t}\n}\n*/\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int num[MAXN], pos[MAXN], del[MAXM];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &num[i]), pos[num[i] - 1] = i + 1;\n\n\tstatic bool deleted[MAXN];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdel[i] = pos[x - 1];\n\t\tdeleted[del[i] - 1] = true;\n\t}\n\n\tstatic unsigned int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) if (!deleted[i - 1]) {\n\t\ta[cnt] = Triple(i, num[i - 1], &ans[n - cnt - 1]); // , printf(\"ans[%d]\\n\", n - cnt - 1);\n\t\tcnt++;\n\t}\n\n\t// const int invalidCnt = cnt;\n\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\ta[cnt++] = Triple(del[i], num[del[i] - 1], &ans[i]); // , printf(\"ans[%d]\\n\", i);\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t}\n\t\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tstd::sort(a, a + cnt);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t\ta[i].num = n - a[i].num + 1;\n\t}\n\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tfor (int i = n - 2; i >= 0; i--) ans[i] += ans[i + 1];\n\tfor (int i = 0; i < m; i++) printf(\"%u\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2011-inverse.md","raw":"title: 「CQOI2011」动态逆序对 - CDQ\ndate: 2016-06-20 20:10:00\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - CDQ\n  - 数据结构\n  - 树状数组\n  - 分治\npermalink: cqoi2011-inverse\n---\n\n对于序列 $ A $，它的逆序对数定义为满足 $ i < j $，且 $ A_i > A_j $ 的数对 $ (i,\\ j) $ 的个数。给 $ 1 $ 到 $ n $ 的一个排列，按照某种顺序依次删除 $ m $ 个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3295](http://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n### 题解\n离线将删除转换为添加，并在开始将未被删除的元素加入。\n\n考虑加入一个元素时，增加的逆序对数量 —— 等于在它**左边**比它**大**的元素数量加在它**右边**比它**小**的元素数量。\n\n对于前一半，将每个数 $ a_i $ 改为 $ n - a_i + 1 $，则转化为在它**左边**比它**小**的数量，经典的三维（时间、位置、大小）偏序问题，使用 CDQ 分治解决。\n\n对于后一半，将每个数的位置 $ i $ 改为 $ n - i + 1 $，则同样转化为在它左边比它小的数量，同理用 CDQ 分治解决即可。\n\n求出每次对答案的贡献后做前缀和即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 50000;\n\nstruct Triple {\n\tint id, pos, num;\n\tunsigned int *ans;\n\n\tTriple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tTriple() {}\n\t\n\tbool operator<(const Triple &other) const { return id < other.id; }\n} a[MAXN];\n\nint n, m;\n\nstruct BinaryIndexedTree {\n\tunsigned int a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tunsigned int query(const int x) {\n\t\tunsigned int ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\t/*\n\tfor (Triple *a = l; a <= r; a++) {\n\t\tif (a->ans) {\n\t\t\tfor (Triple *b = l; b < a; b++) {\n\t\t\t\tif (b->pos < a->pos && b->num < a->num) (*a->ans)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tif (l == r) return;\n\n\tTriple *m = l + (r - l) / 2;\n\n\tcdq(l, m);\n\tcdq(m + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = m + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= m && p1->pos <= p2->pos) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tbit.update(q->num, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) *q->ans += bit.query(q->num);\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\tbit.clear(q->num);\n\t\t*p = *q;\n\t\tassert(p->num != 0);\n\t}\n}\n\n/*\ninline void print() {\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"[%d, %d, %d]%s\", a[i].id, a[i].pos, a[i].num, i == n - 1 ? \"\\n\" : \", \");\n\t}\n}\n*/\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int num[MAXN], pos[MAXN], del[MAXM];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &num[i]), pos[num[i] - 1] = i + 1;\n\n\tstatic bool deleted[MAXN];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdel[i] = pos[x - 1];\n\t\tdeleted[del[i] - 1] = true;\n\t}\n\n\tstatic unsigned int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) if (!deleted[i - 1]) {\n\t\ta[cnt] = Triple(i, num[i - 1], &ans[n - cnt - 1]); // , printf(\"ans[%d]\\n\", n - cnt - 1);\n\t\tcnt++;\n\t}\n\n\t// const int invalidCnt = cnt;\n\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\ta[cnt++] = Triple(del[i], num[del[i] - 1], &ans[i]); // , printf(\"ans[%d]\\n\", i);\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t}\n\t\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tstd::sort(a, a + cnt);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t\ta[i].num = n - a[i].num + 1;\n\t}\n\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tfor (int i = n - 2; i >= 0; i--) ans[i] += ans[i + 1];\n\tfor (int i = 0; i < m; i++) printf(\"%u\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2011-inverse","published":1,"updated":"2016-06-20T14:10:53.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4w0181ooxlklyp0pa2"},{"title":"组合数学学习笔记","date":"2016-03-15T09:16:12.000Z","_content":"\n计数原理、排列、组合、递推关系、等差数列求和公式、自然数平方和公式、二项式定理。\n\n<!-- more -->\n\n### 计数原理\n#### 加法原理\n做一件事有 $ n $ 种途径，每种途径有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### 乘法原理\n做一件事有 $ n $ 个步骤，每个步骤有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### 容斥原理\n统计多个集合的并的元素数量：先加上所有集合的元素的元素数量，再减去『多加的』每两个集合相交的元素数量，再加上『多减的』每三个集合相交的元素数量 ……\n\n即等式左边是多个集合的并的元素数量，等式右边每一项是几个几何的交的元素数量，每一项的符号取决于元素数量的奇偶。\n\n### 排列\n#### 全排列\n把 $ n $ 个元素按照不同顺序排列，设总方案数为 $ f(n) $（定义 $ f(0) = 1 $），考虑第一个元素摆放的位置，得出公式\n\n$$ f(n) = f(n - 1) * n $$\n\n即 $ f(n) = n! $。\n\n#### 普通排列\n从 $ n $ 个元素中取 $ k $ 个，按照不同顺序排列，设总方案数为 $ P(n, k) $，每次选一个数，第一次有 $ n $ 种选择，第二次有 $ n - 1 $ 种选择，直到第 $ k $ 次有 $ n - k + 1 $ 种选择，即\n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n将上式与 $ n! $ 对比，缺少 $ n - k $ 及之后的项，即\n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### 有重复元素的全排列\n从 $ k $ 种元素，第 $ i $ 种有 $ n_i $ 个，设 $ n = \\sum\\limits_{i = 1}^{k}n_i $，为了保证答案不重复，可以先求出 $ n! $，再除去每种元素重复的情况，即\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### 组合\n#### 组合数\n从 n 个元素中选择 k 个，顺序无关，设总方案数为 $ C(n, k) $。把排列数 $ P(n, k) $ 看做先从 n 各种选择 k 个元素，再对 k 个元素做全排列，即\n\n$$ P(n, k) = C(n, k) * k! $$\n\n移项得\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### 组合数的性质\n$ C(n, 0) = C(n, n) = 1 $ 全选或全不选只有一种方案。\n\n$ C(n, k) = C(n, n - k) $ 选择 $ k $ 个拿走相当于选择 $ n - k $ 个留下。\n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ 考虑最后一个选还是不选（Pascal 公式，常用来递推计算组合数表）。\n\n#### 可重复选择的组合\n从 n 种无限多的元素中选择 k 个，共有 $ C(n + k - 1, k) $ 种方案。\n\n#### 组合数的计算\n##### 组合数表\n用 Pascal 公式递推，组合数太大要开高精度或者取模。\n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### 单个计算\n书上有用 `double` 来算的，因为中间乘法 `long long` 可能会溢出，不知道那样会不会损失精度。\n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### 递推关系\n#### Fibonacci 数列\n楼梯上共有 $ n $ 个台阶，一次可以走一个或两个，总方案数为\n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n边界为\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan 数\n给定一个凸 $ n $ 边形，用 $ n - 3 $ 条不相交的直线将它剖分成 $ n - 2 $ 个三角形，设方案总数为 $ f(n) $。\n\n对每个顶点编号，第 $ i $ 个顶点编号为 $ V_i $。作三角形 $ {V_1}{V_k}{V_n} $（$ 1 \\lt k \\lt n $），该三角形左边是一个 $ k $ 边形，右边是一个 $ n - k + 1 $ 边形，即\n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### 公式\n#### 等差数列\n设数列 $ \\{ a_1, a_2, \\cdots, a_n \\} $ 对于任意的 $ 1 \\lt i \\leq n $ 满足 $ a_t - a_{i - 1} = d $，则有\n\n$$ a_i = a_i + (i - 1)d $$\n\n求和公式为\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### 自然数平方和\n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n不会证。\n\n#### 二项式定理\n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","source":"_posts/combinatorics-notes.md","raw":"title: 组合数学学习笔记\ncategories: OI\ntags: \n  - 数学\n  - 组合数学\n  - 学习笔记\n  - 算法模板  \npermalink: combinatorics-notes\ndate: 2016-03-15 17:16:12\n---\n\n计数原理、排列、组合、递推关系、等差数列求和公式、自然数平方和公式、二项式定理。\n\n<!-- more -->\n\n### 计数原理\n#### 加法原理\n做一件事有 $ n $ 种途径，每种途径有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### 乘法原理\n做一件事有 $ n $ 个步骤，每个步骤有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### 容斥原理\n统计多个集合的并的元素数量：先加上所有集合的元素的元素数量，再减去『多加的』每两个集合相交的元素数量，再加上『多减的』每三个集合相交的元素数量 ……\n\n即等式左边是多个集合的并的元素数量，等式右边每一项是几个几何的交的元素数量，每一项的符号取决于元素数量的奇偶。\n\n### 排列\n#### 全排列\n把 $ n $ 个元素按照不同顺序排列，设总方案数为 $ f(n) $（定义 $ f(0) = 1 $），考虑第一个元素摆放的位置，得出公式\n\n$$ f(n) = f(n - 1) * n $$\n\n即 $ f(n) = n! $。\n\n#### 普通排列\n从 $ n $ 个元素中取 $ k $ 个，按照不同顺序排列，设总方案数为 $ P(n, k) $，每次选一个数，第一次有 $ n $ 种选择，第二次有 $ n - 1 $ 种选择，直到第 $ k $ 次有 $ n - k + 1 $ 种选择，即\n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n将上式与 $ n! $ 对比，缺少 $ n - k $ 及之后的项，即\n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### 有重复元素的全排列\n从 $ k $ 种元素，第 $ i $ 种有 $ n_i $ 个，设 $ n = \\sum\\limits_{i = 1}^{k}n_i $，为了保证答案不重复，可以先求出 $ n! $，再除去每种元素重复的情况，即\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### 组合\n#### 组合数\n从 n 个元素中选择 k 个，顺序无关，设总方案数为 $ C(n, k) $。把排列数 $ P(n, k) $ 看做先从 n 各种选择 k 个元素，再对 k 个元素做全排列，即\n\n$$ P(n, k) = C(n, k) * k! $$\n\n移项得\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### 组合数的性质\n$ C(n, 0) = C(n, n) = 1 $ 全选或全不选只有一种方案。\n\n$ C(n, k) = C(n, n - k) $ 选择 $ k $ 个拿走相当于选择 $ n - k $ 个留下。\n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ 考虑最后一个选还是不选（Pascal 公式，常用来递推计算组合数表）。\n\n#### 可重复选择的组合\n从 n 种无限多的元素中选择 k 个，共有 $ C(n + k - 1, k) $ 种方案。\n\n#### 组合数的计算\n##### 组合数表\n用 Pascal 公式递推，组合数太大要开高精度或者取模。\n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### 单个计算\n书上有用 `double` 来算的，因为中间乘法 `long long` 可能会溢出，不知道那样会不会损失精度。\n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### 递推关系\n#### Fibonacci 数列\n楼梯上共有 $ n $ 个台阶，一次可以走一个或两个，总方案数为\n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n边界为\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan 数\n给定一个凸 $ n $ 边形，用 $ n - 3 $ 条不相交的直线将它剖分成 $ n - 2 $ 个三角形，设方案总数为 $ f(n) $。\n\n对每个顶点编号，第 $ i $ 个顶点编号为 $ V_i $。作三角形 $ {V_1}{V_k}{V_n} $（$ 1 \\lt k \\lt n $），该三角形左边是一个 $ k $ 边形，右边是一个 $ n - k + 1 $ 边形，即\n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### 公式\n#### 等差数列\n设数列 $ \\{ a_1, a_2, \\cdots, a_n \\} $ 对于任意的 $ 1 \\lt i \\leq n $ 满足 $ a_t - a_{i - 1} = d $，则有\n\n$$ a_i = a_i + (i - 1)d $$\n\n求和公式为\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### 自然数平方和\n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n不会证。\n\n#### 二项式定理\n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","slug":"combinatorics-notes","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s560189ooxl8r20eqsp"},{"title":"「COGS 746」骑士共存 - 二分图最大独立集","id":"53","updated":"2016-02-19T03:44:48.000Z","date":"2016-02-19T03:43:42.000Z","_content":"\n在一个 $ N * N $ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。问最多可以在棋盘上放多少个其实。\n\n<!-- more -->\n\n### 链接\n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### 题解\n在题图中可以发现，每个马可以攻击的格子都在与自身颜色不同的格子上，即整个棋盘可以建立为二分图，并使能互相攻击到的格子位于不同的两列。\n\n> 根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n> 建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n> ——摘自《「COGS 734」方格取数 - 二分图最大独立集》\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-746.md","raw":"title: 「COGS 746」骑士共存 - 二分图最大独立集\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\n  - 最大独立集\npermalink: cogs-746\nid: 53\nupdated: '2016-02-19 11:44:48'\ndate: 2016-02-19 11:43:42\n---\n\n在一个 $ N * N $ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。问最多可以在棋盘上放多少个其实。\n\n<!-- more -->\n\n### 链接\n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### 题解\n在题图中可以发现，每个马可以攻击的格子都在与自身颜色不同的格子上，即整个棋盘可以建立为二分图，并使能互相攻击到的格子位于不同的两列。\n\n> 根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n> 建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n> ——摘自《「COGS 734」方格取数 - 二分图最大独立集》\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-746","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s5d018fooxl5ozgscbd"},{"title":"「COGS 742」深海机器人 - 费用流","id":"58","updated":"2016-02-23T13:44:58.000Z","date":"2016-02-23T13:44:06.000Z","_content":"\n有多个深海机器人到达深海海底后离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n<!-- more -->\n\n### 链接\n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### 题解\n最大费用最大流建模，从源点向每个起点连一条边，流量为出发的机器人数量，费用为零；从每个终点向汇点连一条边，流量为到达的机器人数量，费用为零；把每个格点看做点，从每个格点向其东边、北边各连**两条**边，第一条容量为 1，费用为生物标本价值的相反数（保证第一个通过的机器人取走标本），另一条容量为正无穷，费用为 0（保证多个机器人可占据同一位置，并且路径可重叠）。\n\n计算坐标是个大坑。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-742.md","raw":"title: 「COGS 742」深海机器人 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - Edmonds-Karp\n  - 网络流 24 题\n  - 图论\n  - 网络流\n  - 费用流\npermalink: cogs-742\nid: 58\nupdated: '2016-02-23 21:44:58'\ndate: 2016-02-23 21:44:06\n---\n\n有多个深海机器人到达深海海底后离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n<!-- more -->\n\n### 链接\n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### 题解\n最大费用最大流建模，从源点向每个起点连一条边，流量为出发的机器人数量，费用为零；从每个终点向汇点连一条边，流量为到达的机器人数量，费用为零；把每个格点看做点，从每个格点向其东边、北边各连**两条**边，第一条容量为 1，费用为生物标本价值的相反数（保证第一个通过的机器人取走标本），另一条容量为正无穷，费用为 0（保证多个机器人可占据同一位置，并且路径可重叠）。\n\n计算坐标是个大坑。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-742","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s5p018oooxl27rq9qgn"},{"title":"「COGS 741」负载平衡 - 费用流","id":"61","updated":"2016-02-25T07:38:10.000Z","date":"2016-02-25T07:37:15.000Z","_content":"\nG 公司有 `n` 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 `n` 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。\n\n<!-- more -->\n\n### 链接\n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### 题解\n这道题猛地看上去有点像之前写过的一道贪心 —— 均分纸牌，那道题只要把每一个数减去平均数，然后从左到右累加，特判一下零就好。但这题难点在于是环形的。\n\n首先，还是要将每个仓库中的库存数量减去平均数，目标便转化为把正数全部加到负数中。『只能在相邻的仓库之间搬运』这一条件，让人很容易想到在相邻仓库之间连边，但稍微思考一下就会发现这样是不行的，因为有时候需要将货物重复移动多次才能到达目的仓库。\n\n不妨只考虑最终的结果 —— 正数最后都要被移动到负数里面。在相邻的仓库之间转移，单位代价是 1，则隔着多个位置的仓库之间转移的代价就是**两间仓库的最短距离**，环中两点的最短路只有两种情况，顺时针走或者逆时针走，预处理出来就好。\n\n从源点向每个库存量为正数的点连一条边，容量为库存量，费用为 0；从每个库存量为负数的点向汇点连一条边，容量为库存量的相反数，费用为 0；从每个库存量为正数的点向每个库存量为负数的点连一条边，容量为正无穷，费用为**两间仓库的最短距离**，求出最小费用最大流，则费用即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-741.md","raw":"title: 「COGS 741」负载平衡 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流 24 题\n  - Edmonds-Karp\n  - 费用流\npermalink: cogs-741\nid: 61\nupdated: '2016-02-25 15:38:10'\ndate: 2016-02-25 15:37:15\n---\n\nG 公司有 `n` 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 `n` 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。\n\n<!-- more -->\n\n### 链接\n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### 题解\n这道题猛地看上去有点像之前写过的一道贪心 —— 均分纸牌，那道题只要把每一个数减去平均数，然后从左到右累加，特判一下零就好。但这题难点在于是环形的。\n\n首先，还是要将每个仓库中的库存数量减去平均数，目标便转化为把正数全部加到负数中。『只能在相邻的仓库之间搬运』这一条件，让人很容易想到在相邻仓库之间连边，但稍微思考一下就会发现这样是不行的，因为有时候需要将货物重复移动多次才能到达目的仓库。\n\n不妨只考虑最终的结果 —— 正数最后都要被移动到负数里面。在相邻的仓库之间转移，单位代价是 1，则隔着多个位置的仓库之间转移的代价就是**两间仓库的最短距离**，环中两点的最短路只有两种情况，顺时针走或者逆时针走，预处理出来就好。\n\n从源点向每个库存量为正数的点连一条边，容量为库存量，费用为 0；从每个库存量为负数的点向汇点连一条边，容量为库存量的相反数，费用为 0；从每个库存量为正数的点向每个库存量为负数的点连一条边，容量为正无穷，费用为**两间仓库的最短距离**，求出最小费用最大流，则费用即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-741","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s5y018wooxl7i0ua8vq"},{"title":"「COGS 740」分配问题 - 二分图最大权匹配","id":"60","updated":"2016-02-25T00:10:00.000Z","date":"2016-02-25T00:08:29.000Z","_content":"\n有 `n` 件工作要分配给 `n` 个人做。第 `i` 个人做第 `j` 件工作产生的效益为 `c[i][j]`。试设计一个将 `n` 件工作分配给 `n` 个人做的分配方案，使产生的总效益最大。\n\n<!-- more -->\n\n### 链接\n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### 题解\n把工作和人放在网络流模型中，可以发现这是一张二分图，问题转化为从图中选取一些边，使这些边没有交点（没有人做重复的工作，没有工作被重复做），并且边权总和最大。即**二分图最大权匹配**。\n\n建立源点与汇点，从源点向每个人连一条边，容量为 1（每个人只能匹配一次），费用为 0；从每个工作到汇点连一条边，容量为 1（每个工作只能匹配一次），费用为 0；从每个人向每个工作连一条边，容量为 0，费用为效益的相反数。求出网络的最小费用最大流，所得费用的相反数即为最大权匹配。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","source":"_posts/cogs-740.md","raw":"title: 「COGS 740」分配问题 - 二分图最大权匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流 24 题\n  - Edmonds-Karp\n  - 费用流\n  - 二分图匹配\npermalink: cogs-740\nid: 60\nupdated: '2016-02-25 08:10:00'\ndate: 2016-02-25 08:08:29\n---\n\n有 `n` 件工作要分配给 `n` 个人做。第 `i` 个人做第 `j` 件工作产生的效益为 `c[i][j]`。试设计一个将 `n` 件工作分配给 `n` 个人做的分配方案，使产生的总效益最大。\n\n<!-- more -->\n\n### 链接\n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### 题解\n把工作和人放在网络流模型中，可以发现这是一张二分图，问题转化为从图中选取一些边，使这些边没有交点（没有人做重复的工作，没有工作被重复做），并且边权总和最大。即**二分图最大权匹配**。\n\n建立源点与汇点，从源点向每个人连一条边，容量为 1（每个人只能匹配一次），费用为 0；从每个工作到汇点连一条边，容量为 1（每个工作只能匹配一次），费用为 0；从每个人向每个工作连一条边，容量为 0，费用为效益的相反数。求出网络的最小费用最大流，所得费用的相反数即为最大权匹配。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","slug":"cogs-740","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s640194ooxl2r9h3e11"},{"title":"「COGS 739」运输问题 - 费用流","id":"57","updated":"2016-02-23T12:35:48.000Z","date":"2016-02-20T13:37:35.000Z","_content":"\nW 公司有 `m` 个仓库和 `n` 个零售商店。第 `i` 个仓库有 $ a_i $ 个货物，第 `j` 个商店需要 $ b_j $ 个货物，从第 `i` 个仓库运输到第 `j` 个零售商店的费用为 $ c_{ij} $，要将所有货物运到商店，最小费用是多少？\n\n<!-- more -->\n\n### 链接\n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### 题解\n裸费用流。\n\n从源点向每个仓库连接一条边，容量为仓库的货物数量；从每个商店向汇点连一条边，容量为商店需要的货物数量；在每一对仓库和商店之间连接一条边，容量为无穷大，费用为运输费用。分别求出最大、最小费用最大流就是答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-739.md","raw":"title: 「COGS 739」运输问题 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 网络流 24 题\npermalink: cogs-739\nid: 57\nupdated: '2016-02-23 20:35:48'\ndate: 2016-02-20 21:37:35\n---\n\nW 公司有 `m` 个仓库和 `n` 个零售商店。第 `i` 个仓库有 $ a_i $ 个货物，第 `j` 个商店需要 $ b_j $ 个货物，从第 `i` 个仓库运输到第 `j` 个零售商店的费用为 $ c_{ij} $，要将所有货物运到商店，最小费用是多少？\n\n<!-- more -->\n\n### 链接\n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### 题解\n裸费用流。\n\n从源点向每个仓库连接一条边，容量为仓库的货物数量；从每个商店向汇点连一条边，容量为商店需要的货物数量；在每一对仓库和商店之间连接一条边，容量为无穷大，费用为运输费用。分别求出最大、最小费用最大流就是答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-739","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s6c019dooxlmh2jkbae"},{"title":"「COGS 738」数字梯形 - 费用流","id":"52","updated":"2016-02-19T03:35:21.000Z","date":"2016-02-19T03:33:27.000Z","_content":"\n一个数字梯形，共有 `n` 行，第一行有 `m` 个数字，每一行都比上一行多一个数字。从第一行的每一个数字开始，每一次向左下方或左上方走，直到最后一行，有以下三种规则：\n\n1. 任意两条路径没有公共部分；\n2. 任意两条路径只能在点（数字）上有公共部分，不能在边（数字与数字之间）上有公共部分；\n3. 任意两条路径可以在点上或边上有公共部分。\n\n求分别在这三种规则下的路径所经过数字总和的最大值。\n\n<!-- more -->\n\n### 链接\n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### 题解\n因为是从第一行走到最后一行，对于路径有限制，并且最大化总和，所以考虑费用流建模。\n\n将每个数字拆成两个点，中间一条边容量为 1，费用为该数字的相反数；从源点到第一行每个数字的入点连一条边，容量为 1，费用为 0；从最后一行每个数字的出点向汇点连一条边，容量为 1，费用为 1；对于除最后一行外的每个数字，从其出点向其下方两个数字的入点分别连一条边，容量为 1，费用为 0。求出网络的最小费用最大流，则结果费用的相反数即为第一问答案。\n\n有了第一问的基础，后面两问就比较容易了，第二问因为可以在数字上重复，就把每个数字的入点和出点之间的边容量改为正无穷，把指向汇点的边容量也改为正无穷；第三问因为可以在边上重复，就在第二问的基础上把每个数字的出点向下方连接的两条边容量改为正无穷。\n\n一定要注意，计算网络流节点编号要用**梯形面积公式**，设源点 `s` 的编号为 0，则对数字进行拆点后所得的点数量为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $，即汇点的编号为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-738.md","raw":"title: 「COGS 738」数字梯形 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 网络流 24 题\npermalink: cogs-738\nid: 52\nupdated: '2016-02-19 11:35:21'\ndate: 2016-02-19 11:33:27\n---\n\n一个数字梯形，共有 `n` 行，第一行有 `m` 个数字，每一行都比上一行多一个数字。从第一行的每一个数字开始，每一次向左下方或左上方走，直到最后一行，有以下三种规则：\n\n1. 任意两条路径没有公共部分；\n2. 任意两条路径只能在点（数字）上有公共部分，不能在边（数字与数字之间）上有公共部分；\n3. 任意两条路径可以在点上或边上有公共部分。\n\n求分别在这三种规则下的路径所经过数字总和的最大值。\n\n<!-- more -->\n\n### 链接\n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### 题解\n因为是从第一行走到最后一行，对于路径有限制，并且最大化总和，所以考虑费用流建模。\n\n将每个数字拆成两个点，中间一条边容量为 1，费用为该数字的相反数；从源点到第一行每个数字的入点连一条边，容量为 1，费用为 0；从最后一行每个数字的出点向汇点连一条边，容量为 1，费用为 1；对于除最后一行外的每个数字，从其出点向其下方两个数字的入点分别连一条边，容量为 1，费用为 0。求出网络的最小费用最大流，则结果费用的相反数即为第一问答案。\n\n有了第一问的基础，后面两问就比较容易了，第二问因为可以在数字上重复，就把每个数字的入点和出点之间的边容量改为正无穷，把指向汇点的边容量也改为正无穷；第三问因为可以在边上重复，就在第二问的基础上把每个数字的出点向下方连接的两条边容量改为正无穷。\n\n一定要注意，计算网络流节点编号要用**梯形面积公式**，设源点 `s` 的编号为 0，则对数字进行拆点后所得的点数量为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $，即汇点的编号为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-738","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s6n019looxlzh13wmyd"},{"title":"「COGS 734」方格取数 - 二分图最大独立集","id":"51","updated":"2016-02-15T09:03:18.000Z","date":"2016-02-15T09:02:01.000Z","_content":"\n在一个有 $ M * N $ 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大。\n\n<!-- more -->\n\n### 链接\n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### 题解\n任意两个数所在的方格没有公共边，考虑把所有的格子建成图，不能同时选择的点之间两两连边，求出一个点权和最大的子图（最大独立集），其和即为答案。\n\n进一步分析，发现这个图是一个二分图 —— 因为每个点只会和**棋盘中与其相邻的点**连边。\n\n根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n建立二分图模型的时候注意细节。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-734.md","raw":"title: 「COGS 734」方格取数 - 二分图最大独立集\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\n  - 最大独立集\npermalink: cogs-734\nid: 51\nupdated: '2016-02-15 17:03:18'\ndate: 2016-02-15 17:02:01\n---\n\n在一个有 $ M * N $ 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大。\n\n<!-- more -->\n\n### 链接\n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### 题解\n任意两个数所在的方格没有公共边，考虑把所有的格子建成图，不能同时选择的点之间两两连边，求出一个点权和最大的子图（最大独立集），其和即为答案。\n\n进一步分析，发现这个图是一个二分图 —— 因为每个点只会和**棋盘中与其相邻的点**连边。\n\n根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n建立二分图模型的时候注意细节。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-734","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s6x019tooxl5anzrb2l"},{"title":"「COGS 731」最长递增子序列 - 线性 DP + 网络流","id":"48","updated":"2016-02-09T06:40:10.000Z","date":"2016-02-09T06:37:32.000Z","_content":"\n给定正整数序列 `X1 ~ Xn`。\n\n1. 计算其最长递增子序列的长度 `s`。\n2. 计算从给定的序列中最多可取出多少个长度为 `s` 的递增子序列。\n3. 如果允许在取出的序列中多次使用 `X1` 和 `Xn`，则从给定序列中最多可取出多少个长度为 `s` 的递增子序列。\n\n<!-- more -->\n\n### 链接\n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### 题解\n首先，重要的事情说三遍：**非严格递增！非严格递增！非严格递增！**\n\n设以 $X_i$ 结尾的最长递增子序列长度为 $F_i$，用动态规划求出每个 $F_i$，最大的一个就是第一问答案，设它为 $K$。\n\n第二问采用网络流建模：\n\n1. 对于每个满足 $F_i = K$ 的点，从该点向汇点连一条边，容量为 1；\n2. 对于每个满足 $F_i = 1$ 的点，从源点向该点连一条边，容量为 1；\n3. 对于第一问中每一次所有的有效状态转移（即满足$ X_j≤X_i $且$F_i=F_j+1$的点对 `i`、`j`）从 `j` 向 `i` 连一条边，容量为 1。\n\n求出最大流即为答案。\n\n但是这样做有个问题，某一个点可能被使用所次，不符合题目要求。解决方法是把每一个点 `i` 拆成两个点 `i` 和 `i'`，所有进入该点的边连接 `i`，所有出该点边从 `i'` 连出，并从 `i` 到 `i'` 连接一条容量为 1 的边，保证了流过每个点的流量最多为 1。\n\n第三问只需要在第二问的基础上做出一些修改，把所有与 `1`、`n` 两个点相关的边容量改为无穷大，就可以使这两个数“可多次使用”。\n\n**注意特判**，如果输入进来的是一个严格递降序列，答案就是 1、N、N。从这里我们可以看出细节的重要性以及出题人的恶意。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-731.md","raw":"title: 「COGS 731」最长递增子序列 - 线性 DP + 网络流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\npermalink: cogs-731\nid: 48\nupdated: '2016-02-09 14:40:10'\ndate: 2016-02-09 14:37:32\n---\n\n给定正整数序列 `X1 ~ Xn`。\n\n1. 计算其最长递增子序列的长度 `s`。\n2. 计算从给定的序列中最多可取出多少个长度为 `s` 的递增子序列。\n3. 如果允许在取出的序列中多次使用 `X1` 和 `Xn`，则从给定序列中最多可取出多少个长度为 `s` 的递增子序列。\n\n<!-- more -->\n\n### 链接\n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### 题解\n首先，重要的事情说三遍：**非严格递增！非严格递增！非严格递增！**\n\n设以 $X_i$ 结尾的最长递增子序列长度为 $F_i$，用动态规划求出每个 $F_i$，最大的一个就是第一问答案，设它为 $K$。\n\n第二问采用网络流建模：\n\n1. 对于每个满足 $F_i = K$ 的点，从该点向汇点连一条边，容量为 1；\n2. 对于每个满足 $F_i = 1$ 的点，从源点向该点连一条边，容量为 1；\n3. 对于第一问中每一次所有的有效状态转移（即满足$ X_j≤X_i $且$F_i=F_j+1$的点对 `i`、`j`）从 `j` 向 `i` 连一条边，容量为 1。\n\n求出最大流即为答案。\n\n但是这样做有个问题，某一个点可能被使用所次，不符合题目要求。解决方法是把每一个点 `i` 拆成两个点 `i` 和 `i'`，所有进入该点的边连接 `i`，所有出该点边从 `i'` 连出，并从 `i` 到 `i'` 连接一条容量为 1 的边，保证了流过每个点的流量最多为 1。\n\n第三问只需要在第二问的基础上做出一些修改，把所有与 `1`、`n` 两个点相关的边容量改为无穷大，就可以使这两个数“可多次使用”。\n\n**注意特判**，如果输入进来的是一个严格递降序列，答案就是 1、N、N。从这里我们可以看出细节的重要性以及出题人的恶意。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-731","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7501a1ooxlw7ha4em1"},{"title":"「COGS 729」圆桌聚餐 - 网络流","id":"47","updated":"2016-02-09T06:41:05.000Z","date":"2016-02-09T05:42:59.000Z","_content":"\n假设有来自 `m` 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 `ri`。会议餐厅共有 `n` 张餐桌，每张餐桌可容纳 `ci` 个代表就餐。\n\n为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。\n\n<!-- more -->\n\n### 链接\n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### 题解\n问题的关键就是：\n\n**每个单位最多有一个人做到一张单独的餐桌上！**\n\n进行网络流建模，建立源点 `S`，由 `S` 向每个代表单位的点连一条边，容量为单位人数；建立汇点 `T`，由每个代表餐桌的点向 `T` 连一条边，容量为餐桌容纳人数；分别从每个单位向所有餐桌连一条边，容量为 `1`。\n\n然后求出最大流，如果最大流小于所有单位人数总和，那么问题无解，否则有解，即所有由单位指向餐桌的边构成了一组解。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-729.md","raw":"title: 「COGS 729」圆桌聚餐 - 网络流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流 24 题\n  - Dinic\npermalink: cogs-729\nid: 47\nupdated: '2016-02-09 14:41:05'\ndate: 2016-02-09 13:42:59\n---\n\n假设有来自 `m` 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 `ri`。会议餐厅共有 `n` 张餐桌，每张餐桌可容纳 `ci` 个代表就餐。\n\n为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。\n\n<!-- more -->\n\n### 链接\n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### 题解\n问题的关键就是：\n\n**每个单位最多有一个人做到一张单独的餐桌上！**\n\n进行网络流建模，建立源点 `S`，由 `S` 向每个代表单位的点连一条边，容量为单位人数；建立汇点 `T`，由每个代表餐桌的点向 `T` 连一条边，容量为餐桌容纳人数；分别从每个单位向所有餐桌连一条边，容量为 `1`。\n\n然后求出最大流，如果最大流小于所有单位人数总和，那么问题无解，否则有解，即所有由单位指向餐桌的边构成了一组解。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-729","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7c01a8ooxl7adpki8y"},{"title":"「COGS 728」最小路径覆盖问题 - 二分图匹配","id":"45","updated":"2016-02-06T14:53:58.000Z","date":"2016-02-06T14:52:12.000Z","_content":"\n给定有向图 $G=(V,E)$ 。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。P 中路径可以从 V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。\n\n设计一个有效算法求一个有向无环图 G 的最小路径覆盖。\n\n<!-- more -->\n\n### 链接\n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### 题解\n用最少的路径覆盖所有的点。先从最简单的图开始，如果图中没有边，那么每个点都是一条独立的路径；如果添加一条边进去，那么需要的路径数量就减小 1；如果再添加一条边进去，并且这条边与上一条边有相同起点或终点的话，那么这条边对答案是没有贡献的，如果这条边与上一条边首尾相接或者不相交的话，那么需要的路径数量减小 1。\n\n综上所述，问题转化为，从一个有向无环图中选出尽量多的边，使任意两条边没有相同起点或终点。\n\n进一步将问题转化为二分图匹配，将每个点拆成左右两个，对于原图中任意一条有向边 `(u, v)`，在新图中将左边的 `u` 和右边的 `v` 连接，然后求出最大匹配，用总点数减去最大匹配就是答案。\n\n输出方案嘛，只要枚举起点然后沿着匹配边向下搜就好咯 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-728.md","raw":"title: 「COGS 728」最小路径覆盖问题 - 二分图匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 二分图匹配\n  - 网络流 24 题\npermalink: cogs-728\nid: 45\nupdated: '2016-02-06 22:53:58'\ndate: 2016-02-06 22:52:12\n---\n\n给定有向图 $G=(V,E)$ 。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。P 中路径可以从 V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。\n\n设计一个有效算法求一个有向无环图 G 的最小路径覆盖。\n\n<!-- more -->\n\n### 链接\n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### 题解\n用最少的路径覆盖所有的点。先从最简单的图开始，如果图中没有边，那么每个点都是一条独立的路径；如果添加一条边进去，那么需要的路径数量就减小 1；如果再添加一条边进去，并且这条边与上一条边有相同起点或终点的话，那么这条边对答案是没有贡献的，如果这条边与上一条边首尾相接或者不相交的话，那么需要的路径数量减小 1。\n\n综上所述，问题转化为，从一个有向无环图中选出尽量多的边，使任意两条边没有相同起点或终点。\n\n进一步将问题转化为二分图匹配，将每个点拆成左右两个，对于原图中任意一条有向边 `(u, v)`，在新图中将左边的 `u` 和右边的 `v` 连接，然后求出最大匹配，用总点数减去最大匹配就是答案。\n\n输出方案嘛，只要枚举起点然后沿着匹配边向下搜就好咯 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-728","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7j01afooxl6pdqftlp"},{"title":"「COGS 727」太空飞行计划 - 最大权闭合图","id":"49","updated":"2016-02-15T00:45:03.000Z","date":"2016-02-15T00:39:38.000Z","_content":"\nW 教授正在为国家航天中心计划一系列的太空飞行。可供选择的实验集合为 $ E = \\{ E1, E2, …, Em \\} $，这些实验需要使用的全部仪器的集合为 $ I = \\{ I1, I2, …, In \\} $。实验 $ E_j $ 需要用到的仪器是 $ R_j∈I $。仪器 $ I_k $ 的费用为 $ c_k $。实验 $ E_j $ 的赞助商为该实验结果支付 $ p_j $。设计方案使收益最大。 \n\n<!-- more -->\n\n### 链接\n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### 题解\n首先，这个问题抽象出来是一个『最大权闭合图』问题 —— 把每个实验作为点，权值为获利；把每个仪器作为点，权值为费用的**相反数**，求出一个点权和最大的子图，使这个子图中的每个点的所有出边指向的点都在这个子图中。特殊的，这个子图可以为空。\n\n根据胡伯涛的论文，最大权闭合图可以用最小割模型来求解：添加源点和汇点，对于原图中的每个**正权点**，连接一条从源点流向该点的边，容量为权值；对于原图中的每个**负权点**，连接一条从该点流向汇点的边，容量为权值的**绝对值**；对于原图中的每一条有向边，对应在网络中连接一条容量为正无穷的边。求出该网络的最小割，割边中所有边一定是从源点连接到一个正权点或从一个负权点连到汇点，这些与割边相连的正权点是**不选择**的点，与割边相连的负权点是**选择**的负权点。\n\n重点来说下怎么求最小割，用 Dinic 求出最大流之后，在**包含反向边**的残量网络中沿着**不满流**的边进行 BFS，将遍历到的点做上标记。BFS 结束后，所有有标记的点组成 `S` 集合，无标记的点组成 `T` 集合。枚举每条边，所有跨越了 `S` 和 `T` 集合的边组成了最小割。\n\n得到不选择的正权点之后，用 `std::set_difference` 求出与所有正权点的差集就是选择的正权点。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-727.md","raw":"title: 「COGS 727」太空飞行计划 - 最大权闭合图\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\n  - 最大权闭合图\npermalink: cogs-727\nid: 49\nupdated: '2016-02-15 08:45:03'\ndate: 2016-02-15 08:39:38\n---\n\nW 教授正在为国家航天中心计划一系列的太空飞行。可供选择的实验集合为 $ E = \\{ E1, E2, …, Em \\} $，这些实验需要使用的全部仪器的集合为 $ I = \\{ I1, I2, …, In \\} $。实验 $ E_j $ 需要用到的仪器是 $ R_j∈I $。仪器 $ I_k $ 的费用为 $ c_k $。实验 $ E_j $ 的赞助商为该实验结果支付 $ p_j $。设计方案使收益最大。 \n\n<!-- more -->\n\n### 链接\n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### 题解\n首先，这个问题抽象出来是一个『最大权闭合图』问题 —— 把每个实验作为点，权值为获利；把每个仪器作为点，权值为费用的**相反数**，求出一个点权和最大的子图，使这个子图中的每个点的所有出边指向的点都在这个子图中。特殊的，这个子图可以为空。\n\n根据胡伯涛的论文，最大权闭合图可以用最小割模型来求解：添加源点和汇点，对于原图中的每个**正权点**，连接一条从源点流向该点的边，容量为权值；对于原图中的每个**负权点**，连接一条从该点流向汇点的边，容量为权值的**绝对值**；对于原图中的每一条有向边，对应在网络中连接一条容量为正无穷的边。求出该网络的最小割，割边中所有边一定是从源点连接到一个正权点或从一个负权点连到汇点，这些与割边相连的正权点是**不选择**的点，与割边相连的负权点是**选择**的负权点。\n\n重点来说下怎么求最小割，用 Dinic 求出最大流之后，在**包含反向边**的残量网络中沿着**不满流**的边进行 BFS，将遍历到的点做上标记。BFS 结束后，所有有标记的点组成 `S` 集合，无标记的点组成 `T` 集合。枚举每条边，所有跨越了 `S` 和 `T` 集合的边组成了最小割。\n\n得到不选择的正权点之后，用 `std::set_difference` 求出与所有正权点的差集就是选择的正权点。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-727","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7q01anooxl1oz6bhqz"},{"title":"「COGS 439」软件补丁 - 记忆化搜索 + 位运算","id":"50","updated":"2016-02-15T02:17:27.000Z","date":"2016-02-15T02:13:28.000Z","_content":"\n现在有一个软件，共有 `n` 个 BUG，开发人员开发了 `m` 个补丁，每个补丁有一个应用条件，要求某些 BUG 比如存在，某些 BUG 可以不存在，某些 BUG 存在或不存在都可以；每个补丁有一个影响，会使某些 BUG 消失，会使某些 BUG 产生；每个 BUG 有一个应用时间。问修复所有 BUG 需要的最短时间为多少。\n\n<!-- more -->\n\n### 链接\n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### 题解\n记录状态：用一个 `unsigned int` 类型的数记录状态，从右边数第 `i` 个二进制位表示第 `i` 个 BUG 是否存在。用 `std::tr1::unordered_map`（哈希表）存储状态到所有时间的映射，即 `map[status]` 表示从初始状态到状态 `status` 所用的最短时间。\n\n状态转移：每个补丁存储两个值 `effectAddition`、`effectSubtract`，前者表示应用该补丁后新增加的 BUG，后者表示减少的 BUG，则状态转移为：\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n一个难点在于怎样判断补丁的应用条件，「某些 BUG 存在或不存在都可以」是难以用位运算来体现的（或者说我不会），所以我们可以把这种情况转化为「某些 BUG 必须存在」，然后在判断条件时先将当前状态加上那些「可有可无」的 BUG，然后继续判断。\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n话说其实这道题暴力表示状态，一位一位地判断、转移也可以过的，而且照样是 COGS 上提交记录第一 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 吐槽\n又是一道不是网络流但被放进「网络流 24 题」里的~~水~~题。","source":"_posts/cogs-439.md","raw":"title: 「COGS 439」软件补丁 - 记忆化搜索 + 位运算\ncategories: OI\ntags: \n  - 搜索\n  - 记忆化搜索\n  - 位运算\n  - COGS\n  - 网络流 24 题\n  - map\npermalink: cogs-439\nid: 50\nupdated: '2016-02-15 10:17:27'\ndate: 2016-02-15 10:13:28\n---\n\n现在有一个软件，共有 `n` 个 BUG，开发人员开发了 `m` 个补丁，每个补丁有一个应用条件，要求某些 BUG 比如存在，某些 BUG 可以不存在，某些 BUG 存在或不存在都可以；每个补丁有一个影响，会使某些 BUG 消失，会使某些 BUG 产生；每个 BUG 有一个应用时间。问修复所有 BUG 需要的最短时间为多少。\n\n<!-- more -->\n\n### 链接\n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### 题解\n记录状态：用一个 `unsigned int` 类型的数记录状态，从右边数第 `i` 个二进制位表示第 `i` 个 BUG 是否存在。用 `std::tr1::unordered_map`（哈希表）存储状态到所有时间的映射，即 `map[status]` 表示从初始状态到状态 `status` 所用的最短时间。\n\n状态转移：每个补丁存储两个值 `effectAddition`、`effectSubtract`，前者表示应用该补丁后新增加的 BUG，后者表示减少的 BUG，则状态转移为：\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n一个难点在于怎样判断补丁的应用条件，「某些 BUG 存在或不存在都可以」是难以用位运算来体现的（或者说我不会），所以我们可以把这种情况转化为「某些 BUG 必须存在」，然后在判断条件时先将当前状态加上那些「可有可无」的 BUG，然后继续判断。\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n话说其实这道题暴力表示状态，一位一位地判断、转移也可以过的，而且照样是 COGS 上提交记录第一 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 吐槽\n又是一道不是网络流但被放进「网络流 24 题」里的~~水~~题。","slug":"cogs-439","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7y01avooxl5ku8le04"},{"title":"「COGS 396」魔术球问题 - 贪心","id":"46","updated":"2016-02-06T15:04:22.000Z","date":"2016-02-06T15:02:55.000Z","_content":"\n假设有 `n` 根柱子，现要按下述规则在这n根柱子中依次放入编号为 1，2，3，4 ...... 的球。\n\n1. 每次只能在某根柱子的最上面放球；\n2. 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 `n` 根柱子上最多能放多少个球。\n\n<!-- more -->\n\n### 链接\n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### 题解\n放球的两个条件很显然，在上面放再多的球是不影响下面的。并且，某个球放在哪一根柱子上，只会影响其之上的球的编号，而不会影响全局的球总数。\n\n所以可以使用贪心解决：策略是，先从一个柱子开始，每次枚举所有柱子，只要某个柱子能放就放上去，然后继续放下一个；直到所有的柱子不能放当前的球，则添加一个柱子；最后不能在添加时，就是最优解。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-396.md","raw":"title: 「COGS 396」魔术球问题 - 贪心\ncategories: OI\ntags: \n  - COGS\n  - 贪心\n  - 网络流 24 题\npermalink: cogs-396\nid: 46\nupdated: '2016-02-06 23:04:22'\ndate: 2016-02-06 23:02:55\n---\n\n假设有 `n` 根柱子，现要按下述规则在这n根柱子中依次放入编号为 1，2，3，4 ...... 的球。\n\n1. 每次只能在某根柱子的最上面放球；\n2. 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 `n` 根柱子上最多能放多少个球。\n\n<!-- more -->\n\n### 链接\n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### 题解\n放球的两个条件很显然，在上面放再多的球是不影响下面的。并且，某个球放在哪一根柱子上，只会影响其之上的球的编号，而不会影响全局的球总数。\n\n所以可以使用贪心解决：策略是，先从一个柱子开始，每次枚举所有柱子，只要某个柱子能放就放上去，然后继续放下一个；直到所有的柱子不能放当前的球，则添加一个柱子；最后不能在添加时，就是最优解。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-396","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8601b4ooxl9xtoeca1"},{"title":"「COGS 14」搭配飞行员 - 二分图匹配","id":"44","updated":"2016-02-06T14:22:28.000Z","date":"2016-02-06T14:21:18.000Z","_content":"\n从一个二分图中选出尽量多的边，使得任意两条边没有公共点。\n\n<!-- more -->\n\n### 链接\n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### 题解\n二分图匹配，可以用匈牙利~~也可以用带花树~~，然而我不会写。\n\n所以要把二分图最大匹配转化成最大流 …… \n\n设二分图左右两列分别为 `X` 和 `Y`，建立超级源点 `S`，从 `S` 向 `X` 中的每个点连一条边，容量为 `1`，建立超级汇点 `T`，从 `Y` 中的每个点向 `T` 连一条边，容量为 `1`。最后对于原图的每一条边 `(u, v)`（假设 `u` 在左侧 `v` 在右侧），连接一条由 `u` 指向 `v` 的**有向**边，容量为 `1`。然后跑一遍最大流就是最大匹配啦！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-14.md","raw":"title: 「COGS 14」搭配飞行员 - 二分图匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 二分图匹配\n  - 网络流 24 题\npermalink: cogs-14\nid: 44\nupdated: '2016-02-06 22:22:28'\ndate: 2016-02-06 22:21:18\n---\n\n从一个二分图中选出尽量多的边，使得任意两条边没有公共点。\n\n<!-- more -->\n\n### 链接\n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### 题解\n二分图匹配，可以用匈牙利~~也可以用带花树~~，然而我不会写。\n\n所以要把二分图最大匹配转化成最大流 …… \n\n设二分图左右两列分别为 `X` 和 `Y`，建立超级源点 `S`，从 `S` 向 `X` 中的每个点连一条边，容量为 `1`，建立超级汇点 `T`，从 `Y` 中的每个点向 `T` 连一条边，容量为 `1`。最后对于原图的每一条边 `(u, v)`（假设 `u` 在左侧 `v` 在右侧），连接一条由 `u` 指向 `v` 的**有向**边，容量为 `1`。然后跑一遍最大流就是最大匹配啦！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-14","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8b01b9ooxlt9mufp9o"},{"title":"「CodeVS 3269」混合背包 - 背包 DP","id":"3","updated":"2016-01-19T13:08:13.000Z","date":"2015-11-22T21:00:15.000Z","_content":"\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> 1）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 题解\n混合三种背包问题，很经典的一个问题。  \n首先分开考虑这三种背包问题的解法。  \n使用动态规划，用 `f[v]` 表示把所有物品按要求装入一个体积为 `v` （`v` <= `V`）的背包时，装入背包内物品总价值的最大值。    \n首先，对于 01 背包，显而易见其方程为：\n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n实现代码（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n特别注意第二层循环枚举 `v` 时的顺序，`v` 必须从 `V` 到 `0` 循环，因为当前 `f[v]` 要根据一个当 `v` 更小时的 `f[v]` 推出（为了腾出大小为 `Vi` 的空间防第 `i` 件物品），保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**没有尝试过**放置第 `i` 件物品时的状态。  \n\n对于完全背包，我们可以将其每件拆分成 `V` / `Vi` 件 `01` 背包物品，对每件物品进行一次 01 背包处理。但显然这样做效率会很低。  \n考虑到完全背包与 01 背包的不同点，仅在于 01 背包每种物品**只能放置一次**，而完全背包可以放置**任意次**，将其体现在动态规划的状态转移上，即完全背包问题，需要保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**已经尝试过**放置第 `i` 件物品时的状态。而只需将第二层循环 `v` 的遍历顺序改为从 `0` 到 `V` 即可。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n这两段代码的差异比较难理解，这里举个例子：背包容量 `V = 10`，仅有一件物品体积 `Vi = 3`，价值 `Wi = 5`，现将这件物品尝试放入背包。  \n\n如果这件物品是 `01` 背包：  \n当 `v = 10` 时，**`f[v - Vi] = f[7] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 9` 时，`f[v - Vi] = f[6] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 8` 时，`f[v - Vi] = f[5] = 0`，`f[v]` 被更新为 `5`。  \n**当 `v = 7` 时，`f[v - Vi] = f[4] = 0`，`f[v]` 被更新为 `5`。**  \n……  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 3` 时，`f[v - Vi] = f[0] = 0`，`f[v]` 被更新为 `5`。  \n\n如果这件物品是完全背包：  \n当 `v = 3` 时，**`f[v - Vi] = f[0] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n……  \n**当 `v = 6` 时，`f[v - Vi] = f[3] = 5`，`f[v]` 被更新为 `10`。**  \n……  \n**当 `v = 9` 时，`f[v - Vi] = f[6] = 10`，`f[v]` 被更新为 `15`。**  \n当 `v = 10` 时，`f[v - Vi] = f[7] = 10`，`f[v]` 被更新为 `15`。  \n\n以上例子可以体现出 01 背包与完全背包解法上的区别与问题实质的联系。  \n\n回到原来的话题上来，我们已经解决了前两类问题——01 背包和完全背包，现在来看多重背包。  \n还是考虑拆分，把一件可以装 `Mi` 次的多重背包物品拆分成 `Mi` 件 01 背包物品，分别对其进行 01 背包处理。这种方法很好理解，但时间复杂度达到了$O(V*{\\Sigma}Mi)$，考虑将其优化。  \n我们采用类似二进制的思想，将每个多重背包物品拆分为 `t` 个不同的 01 背包物品，每一个拆分后的物品都有一个系数 `k`，该物品的体积和价值分别等于**原物品的体积和价值乘以这个系数**，并且使所有拆分后的物品的系数之和${\\Sigma}k = Mi$，即原物品最多被放置的次数。并且要使每个系数 `k` 分别为 $1$,$2$,$4$,…,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$。  \n举个例子，当 `Mi = 17` 时，将其拆成 `5` 件物品，系数 `k` 分别为 `1`,`2`,`4`,`8`,`2`。  \n使用二进制思想优化过的算法，复杂度降为了$O(V * {\\Sigma}{\\log}Wi)$。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j 将 1 按二进制位左移 j 位，快速计算 2 的 j 次方\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { // 如果不能 2 的幂作为系数将原物品完全拆分，则多拆分出一件物品 k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n三种背包问题的思路明确后，就可以考虑混合背包问题了，具体实现方法是对于每一种物品，判断物品类型，分别进行处理。  \n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### 吐槽\n这段时间在学习 dp，听 liujz 学长讲完后自己抱着书啃了好久 ……  \n算是有些理解了吧 >_<\n","source":"_posts/codevs-3269.md","raw":"title: 「CodeVS 3269」混合背包 - 背包 DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 背包 DP\npermalink: codevs-3269\nid: 3\nupdated: '2016-01-19 21:08:13'\ndate: 2015-11-23 05:00:15\n---\n\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> 1）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 题解\n混合三种背包问题，很经典的一个问题。  \n首先分开考虑这三种背包问题的解法。  \n使用动态规划，用 `f[v]` 表示把所有物品按要求装入一个体积为 `v` （`v` <= `V`）的背包时，装入背包内物品总价值的最大值。    \n首先，对于 01 背包，显而易见其方程为：\n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n实现代码（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n特别注意第二层循环枚举 `v` 时的顺序，`v` 必须从 `V` 到 `0` 循环，因为当前 `f[v]` 要根据一个当 `v` 更小时的 `f[v]` 推出（为了腾出大小为 `Vi` 的空间防第 `i` 件物品），保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**没有尝试过**放置第 `i` 件物品时的状态。  \n\n对于完全背包，我们可以将其每件拆分成 `V` / `Vi` 件 `01` 背包物品，对每件物品进行一次 01 背包处理。但显然这样做效率会很低。  \n考虑到完全背包与 01 背包的不同点，仅在于 01 背包每种物品**只能放置一次**，而完全背包可以放置**任意次**，将其体现在动态规划的状态转移上，即完全背包问题，需要保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**已经尝试过**放置第 `i` 件物品时的状态。而只需将第二层循环 `v` 的遍历顺序改为从 `0` 到 `V` 即可。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n这两段代码的差异比较难理解，这里举个例子：背包容量 `V = 10`，仅有一件物品体积 `Vi = 3`，价值 `Wi = 5`，现将这件物品尝试放入背包。  \n\n如果这件物品是 `01` 背包：  \n当 `v = 10` 时，**`f[v - Vi] = f[7] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 9` 时，`f[v - Vi] = f[6] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 8` 时，`f[v - Vi] = f[5] = 0`，`f[v]` 被更新为 `5`。  \n**当 `v = 7` 时，`f[v - Vi] = f[4] = 0`，`f[v]` 被更新为 `5`。**  \n……  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 3` 时，`f[v - Vi] = f[0] = 0`，`f[v]` 被更新为 `5`。  \n\n如果这件物品是完全背包：  \n当 `v = 3` 时，**`f[v - Vi] = f[0] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n……  \n**当 `v = 6` 时，`f[v - Vi] = f[3] = 5`，`f[v]` 被更新为 `10`。**  \n……  \n**当 `v = 9` 时，`f[v - Vi] = f[6] = 10`，`f[v]` 被更新为 `15`。**  \n当 `v = 10` 时，`f[v - Vi] = f[7] = 10`，`f[v]` 被更新为 `15`。  \n\n以上例子可以体现出 01 背包与完全背包解法上的区别与问题实质的联系。  \n\n回到原来的话题上来，我们已经解决了前两类问题——01 背包和完全背包，现在来看多重背包。  \n还是考虑拆分，把一件可以装 `Mi` 次的多重背包物品拆分成 `Mi` 件 01 背包物品，分别对其进行 01 背包处理。这种方法很好理解，但时间复杂度达到了$O(V*{\\Sigma}Mi)$，考虑将其优化。  \n我们采用类似二进制的思想，将每个多重背包物品拆分为 `t` 个不同的 01 背包物品，每一个拆分后的物品都有一个系数 `k`，该物品的体积和价值分别等于**原物品的体积和价值乘以这个系数**，并且使所有拆分后的物品的系数之和${\\Sigma}k = Mi$，即原物品最多被放置的次数。并且要使每个系数 `k` 分别为 $1$,$2$,$4$,…,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$。  \n举个例子，当 `Mi = 17` 时，将其拆成 `5` 件物品，系数 `k` 分别为 `1`,`2`,`4`,`8`,`2`。  \n使用二进制思想优化过的算法，复杂度降为了$O(V * {\\Sigma}{\\log}Wi)$。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j 将 1 按二进制位左移 j 位，快速计算 2 的 j 次方\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { // 如果不能 2 的幂作为系数将原物品完全拆分，则多拆分出一件物品 k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n三种背包问题的思路明确后，就可以考虑混合背包问题了，具体实现方法是对于每一种物品，判断物品类型，分别进行处理。  \n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### 吐槽\n这段时间在学习 dp，听 liujz 学长讲完后自己抱着书啃了好久 ……  \n算是有些理解了吧 >_<\n","slug":"codevs-3269","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8j01bhooxlw1ixjot5"},{"title":"「CodeVS 3269」混合背包 - 背包 DP + 单调队列","id":"23","updated":"2016-01-19T13:03:26.000Z","date":"2016-01-14T21:47:45.000Z","_content":"\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> `1`）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 题解\n01 和完全这两种之前写过，这里就重点说说怎么用单调队列来解多重。\n\n首先，对于多重背包的每件物品，`n` 表示这件物品的数量，`w` 表示这件物品的体积，`c` 表示这件物品的价值。\n\n朴素的多重背包状态转移方程为：\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n设 $r=i ~~ \\% ~~ c$，$m=i ~~ / ~~ c$。\n\n`m` 的意义为，如果当前状态的背包容量全部用来放当前物品，能放多少件。  \n`r` 的意义为，如果当前状态的背包容量全部用来放当前物品，则剩下的容量是多少。\n\n到此，我们可以修改一下方程，使原来的枚举 `i` 变为先枚举 `r`，然后在 $[0,m]$ 上枚举 `d`，以 $(m-d)*c+r$代替原来的 `i`。\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n令\n\n$$ k=m-d $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n进一步化为\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n令\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n由此得到一个可以用单调队列优化的方程，结合方程我们知道，$ f[k*c+r] $是由之前的 `n + 1` 项的最大值推出的，于是用一个长度为 `n + 1` 的单调队列维护 $g(k,r)$，就可以 $O(1)$ 地求出每个状态。\n\n需要注意的是，在使用单调队列实现这个算法时，方程中的 `m` 应该被替换为当前状态对应的 `k`，因为枚举的 `k` 总是当前状态的**背包容量全部用来放当前物品的最大件数**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3269-monotone-queue.md","raw":"title: 「CodeVS 3269」混合背包 - 背包 DP + 单调队列\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 单调队列\n  - 背包 DP\npermalink: codevs-3269-monotone-queue\nid: 23\nupdated: '2016-01-19 21:03:26'\ndate: 2016-01-15 05:47:45\n---\n\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> `1`）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 题解\n01 和完全这两种之前写过，这里就重点说说怎么用单调队列来解多重。\n\n首先，对于多重背包的每件物品，`n` 表示这件物品的数量，`w` 表示这件物品的体积，`c` 表示这件物品的价值。\n\n朴素的多重背包状态转移方程为：\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n设 $r=i ~~ \\% ~~ c$，$m=i ~~ / ~~ c$。\n\n`m` 的意义为，如果当前状态的背包容量全部用来放当前物品，能放多少件。  \n`r` 的意义为，如果当前状态的背包容量全部用来放当前物品，则剩下的容量是多少。\n\n到此，我们可以修改一下方程，使原来的枚举 `i` 变为先枚举 `r`，然后在 $[0,m]$ 上枚举 `d`，以 $(m-d)*c+r$代替原来的 `i`。\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n令\n\n$$ k=m-d $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n进一步化为\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n令\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n由此得到一个可以用单调队列优化的方程，结合方程我们知道，$ f[k*c+r] $是由之前的 `n + 1` 项的最大值推出的，于是用一个长度为 `n + 1` 的单调队列维护 $g(k,r)$，就可以 $O(1)$ 地求出每个状态。\n\n需要注意的是，在使用单调队列实现这个算法时，方程中的 `m` 应该被替换为当前状态对应的 `k`，因为枚举的 `k` 总是当前状态的**背包容量全部用来放当前物品的最大件数**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```\n","slug":"codevs-3269-monotone-queue","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8o01bmooxl9ynl5qen"},{"title":"「CodeVS 3168 / 3162」抄书问题 - 划分 DP / 二分答案","id":"14","updated":"2016-01-06T13:03:26.000Z","date":"2016-01-05T21:47:45.000Z","_content":"\n把 `M` 本有顺序的书分给 `K` 个人抄写，每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的（比如不能把第一、第三、第四本数给同一个人抄写）。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3162 - 抄书问题](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 - 抄书问题 3](http://codevs.cn/problem/3168/)\n\n### 划分 DP\n考虑用动态规划求出最短时间，以 $a[m]$ 表示第 `m` 本书的页数，$f[m][k]$ 表示前 `m` 本书给前 `k` 个人抄需要的最短时间。\n\n边界条件为：\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n转移方程为：\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n即，枚举第 `k` 个人抄的书数，从“前面 `k - 1` 个人每人只抄一本，剩下的全留给第 `k` 个人”到“前面 `k - 1` 个人一共抄 `m - 1` 本，给第 `k` 个人留一本”，并上第 `k` 个人抄的时间，取最小值。\n\n求书本页数的区间和可以用一个前缀和数组来优化时间复杂度，故该算法时间复杂度为 $O(km^2)$。\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### 二分答案\n加大后的数据量已不能使用 DP 的方法，考虑对最短时间在**最大页数**到**总页数**之间进行二分，检验过程**贪心**枚举每一本书，从最后一个人开始，如果当前的人还能抄就给他抄，否则给前一个人抄，如果最后能抄完则可行。\n\n时间复杂度为 $O(m{\\log}m)$。\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### 方案输出\n输出方案算是这题最难的地方。~~才不会告诉你们我 WA 了 8 次呢！~~\n\n和二分答案求最短时间的思路相似，贪心枚举每本书，从最后一个人开始（注意题目要求前面的人少抄），如果当前人还能抄，就给他抄，否则给下一个人抄，**如果剩余人的数量大于剩余书的数量，则无论如何都要给下一个人抄（后面的全给抄完了咱前面的吵啥啊）**。\n\n输出顺序可以用一个栈来调整。\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n### 代码（划分 DP，CodeVS 3162）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### 代码（二分答案，CodeVS 3162，CodeVS 3168）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3168-3162.md","raw":"title: 「CodeVS 3168 / 3162」抄书问题 - 划分 DP / 二分答案\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 二分答案\n  - 划分 DP\n  - 贪心\npermalink: codevs-3168-3162\nid: 14\nupdated: '2016-01-06 21:03:26'\ndate: 2016-01-06 05:47:45\n---\n\n把 `M` 本有顺序的书分给 `K` 个人抄写，每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的（比如不能把第一、第三、第四本数给同一个人抄写）。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3162 - 抄书问题](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 - 抄书问题 3](http://codevs.cn/problem/3168/)\n\n### 划分 DP\n考虑用动态规划求出最短时间，以 $a[m]$ 表示第 `m` 本书的页数，$f[m][k]$ 表示前 `m` 本书给前 `k` 个人抄需要的最短时间。\n\n边界条件为：\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n转移方程为：\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n即，枚举第 `k` 个人抄的书数，从“前面 `k - 1` 个人每人只抄一本，剩下的全留给第 `k` 个人”到“前面 `k - 1` 个人一共抄 `m - 1` 本，给第 `k` 个人留一本”，并上第 `k` 个人抄的时间，取最小值。\n\n求书本页数的区间和可以用一个前缀和数组来优化时间复杂度，故该算法时间复杂度为 $O(km^2)$。\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### 二分答案\n加大后的数据量已不能使用 DP 的方法，考虑对最短时间在**最大页数**到**总页数**之间进行二分，检验过程**贪心**枚举每一本书，从最后一个人开始，如果当前的人还能抄就给他抄，否则给前一个人抄，如果最后能抄完则可行。\n\n时间复杂度为 $O(m{\\log}m)$。\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### 方案输出\n输出方案算是这题最难的地方。~~才不会告诉你们我 WA 了 8 次呢！~~\n\n和二分答案求最短时间的思路相似，贪心枚举每本书，从最后一个人开始（注意题目要求前面的人少抄），如果当前人还能抄，就给他抄，否则给下一个人抄，**如果剩余人的数量大于剩余书的数量，则无论如何都要给下一个人抄（后面的全给抄完了咱前面的吵啥啊）**。\n\n输出顺序可以用一个栈来调整。\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n### 代码（划分 DP，CodeVS 3162）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### 代码（二分答案，CodeVS 3162，CodeVS 3168）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","slug":"codevs-3168-3162","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8u01bsooxl09eayfj8"},{"title":"「CodeVS 2822」爱在心中 - 强联通分量","date":"2016-03-04T02:47:42.000Z","_content":"\n在爱的国度里有 N 个人，在他们的心中都有着一个爱的名单，上面记载着他所爱的人（不会出现自爱的情况）。爱是具有传递性的，即如果 A 爱 B，B 爱 C，则 A 也爱 C。\n\n如果有这样一部分人，他们彼此都相爱，则他们就超越了一切的限制，用集体的爱化身成为一个爱心天使。现在，我们想知道在这个爱的国度里会出现多少爱心天使。而且，如果某个爱心天使被其他所有人或爱心天使所爱则请输出这个爱心天使是由哪些人构成的，否则输出 -1。\n\n<!-- more -->\n\n### 链接\n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### 题解\n第一问很明显的，求出图中有多少不是单点的强联通分量就是答案。\n\n第二问，把每个强联通分量缩成一个点，重新构图，如果新图中有出度为零的点，则该点对应的原图中的点集即为第二问答案。注意排除一个点情况。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/codevs-2822.md","raw":"title: 「CodeVS 2822」爱在心中 - 强联通分量\ncategories: OI\ntags: \n  - CodeVS\n  - 图论\n  - Tarjan\n  - 强联通分量\n  - 缩点\npermalink: codevs-2822\ndate: 2016-03-04 10:47:42\n---\n\n在爱的国度里有 N 个人，在他们的心中都有着一个爱的名单，上面记载着他所爱的人（不会出现自爱的情况）。爱是具有传递性的，即如果 A 爱 B，B 爱 C，则 A 也爱 C。\n\n如果有这样一部分人，他们彼此都相爱，则他们就超越了一切的限制，用集体的爱化身成为一个爱心天使。现在，我们想知道在这个爱的国度里会出现多少爱心天使。而且，如果某个爱心天使被其他所有人或爱心天使所爱则请输出这个爱心天使是由哪些人构成的，否则输出 -1。\n\n<!-- more -->\n\n### 链接\n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### 题解\n第一问很明显的，求出图中有多少不是单点的强联通分量就是答案。\n\n第二问，把每个强联通分量缩成一个点，重新构图，如果新图中有出度为零的点，则该点对应的原图中的点集即为第二问答案。注意排除一个点情况。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"codevs-2822","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9001bzooxlvzne69or"},{"title":"「CodeVS 2598」编辑距离问题 - 线性 DP","id":"17","updated":"2016-01-19T13:05:21.000Z","date":"2016-01-08T21:32:19.000Z","_content":"\n设 A 和 B 是 2 个字符串。要用最少的字符操作将字符串 A 转换为字符串 B。这里所说的字符操作包括：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n求将字符串 A 变换为字符串 B 所用的最少字符操作数，即 A 到 B 的编辑距离。\n\n字符串 A、B 的长度均不超过4000。\n\n<!-- more -->\n\n### 链接\n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### 题解\n字符串的题乍一看都很恶心，但这道题仔细想想还是很简单的。\n用 `f[i][j]` 表示字符串 A 的前 `i` 个字符到字符串 B 的前 `j` 个字符的编辑距离，则转移方程为：\n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i] ≠ B[j]} $$\n\n当 $ A[i]=B[j] $ 时，当前位置无需编辑，直接等于上一位的编辑距离。\n\n当 $ A[i]≠B[j] $ 时，有三种情况：\n\n1. 字符串 B 的前 `j` 位可由 $A[i]$ 编辑到 $B[j-1]$ 后插入 B 的第 `j` 个字符得到。\n2. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j]$ 后删除 A 的第 `i` 个字符得到。\n3. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j-1]$ 后修改 A 的第 `i` 个字符为 B 的第 `j` 个字符得到。\n\n### 代码\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```\n","source":"_posts/codevs-2598.md","raw":"title: 「CodeVS 2598」编辑距离问题 - 线性 DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 字符串\n  - 线性 DP\npermalink: codevs-2598\nid: 17\nupdated: '2016-01-19 21:05:21'\ndate: 2016-01-09 05:32:19\n---\n\n设 A 和 B 是 2 个字符串。要用最少的字符操作将字符串 A 转换为字符串 B。这里所说的字符操作包括：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n求将字符串 A 变换为字符串 B 所用的最少字符操作数，即 A 到 B 的编辑距离。\n\n字符串 A、B 的长度均不超过4000。\n\n<!-- more -->\n\n### 链接\n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### 题解\n字符串的题乍一看都很恶心，但这道题仔细想想还是很简单的。\n用 `f[i][j]` 表示字符串 A 的前 `i` 个字符到字符串 B 的前 `j` 个字符的编辑距离，则转移方程为：\n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i] ≠ B[j]} $$\n\n当 $ A[i]=B[j] $ 时，当前位置无需编辑，直接等于上一位的编辑距离。\n\n当 $ A[i]≠B[j] $ 时，有三种情况：\n\n1. 字符串 B 的前 `j` 位可由 $A[i]$ 编辑到 $B[j-1]$ 后插入 B 的第 `j` 个字符得到。\n2. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j]$ 后删除 A 的第 `i` 个字符得到。\n3. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j-1]$ 后修改 A 的第 `i` 个字符为 B 的第 `j` 个字符得到。\n\n### 代码\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```\n","slug":"codevs-2598","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9701c6ooxlp3f7afsi"},{"title":"「CodeVS 1563」奶牛的交通 - 网络流","id":"42","updated":"2016-02-06T14:23:12.000Z","date":"2016-02-05T13:06:41.000Z","_content":"\n给出一个无向图，问最少割掉多少个点使 `s` 点与 `t` 点不连通。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[洛谷 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### 题解\n首先，这题一看就是最小割，由最小割最大流定理得，求出最大流就是最小割。\n\n怎么流？\n\n一般的网络流，流量都在边上，求出的割也是割的边 …… 而我们这次需要割点，那就拆点呀！\n\n把每个点拆成 `i` 和 `i'` 两个点，`i` 表示进入这个点，`i'` 表示离开这个点。由 `i` 向 `i'` 连接一条有向边，容量为 1。对于原图中任意一条有向边 `(i, j)`，连接 `(i', j)`，容量为正无穷。\n\n于是就完成了喜闻乐见的建模，求出 `s'` 到 `t` （想一想为什么不是 `s` 到 `t'`？）的最大流就是答案啦！\n\n###代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1563.md","raw":"title: 「CodeVS 1563」奶牛的交通 - 网络流\ncategories: OI\ntags: \n  - CodeVS\n  - USACO\n  - 网络流\n  - Dinic\n  - 图论\npermalink: codevs-1563\nid: 42\nupdated: '2016-02-06 22:23:12'\ndate: 2016-02-05 21:06:41\n---\n\n给出一个无向图，问最少割掉多少个点使 `s` 点与 `t` 点不连通。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[洛谷 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### 题解\n首先，这题一看就是最小割，由最小割最大流定理得，求出最大流就是最小割。\n\n怎么流？\n\n一般的网络流，流量都在边上，求出的割也是割的边 …… 而我们这次需要割点，那就拆点呀！\n\n把每个点拆成 `i` 和 `i'` 两个点，`i` 表示进入这个点，`i'` 表示离开这个点。由 `i` 向 `i'` 连接一条有向边，容量为 1。对于原图中任意一条有向边 `(i, j)`，连接 `(i', j)`，容量为正无穷。\n\n于是就完成了喜闻乐见的建模，求出 `s'` 到 `t` （想一想为什么不是 `s` 到 `t'`？）的最大流就是答案啦！\n\n###代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","slug":"codevs-1563","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9d01ccooxl31kv6hwb"},{"title":"「CodeVS 1345」饥饿的奶牛 - 线性 DP","id":"21","updated":"2016-01-19T13:04:02.000Z","date":"2016-01-13T21:17:18.000Z","_content":"\n在 `n`（≤ 1000）条线段中选出若干条，保证任意两条线段没有公共点（端点也不能重合），使总长度最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### 题解\n刚开始确实晕了，又是想线段树又是想背包 ……\n\n保证线段不重合是个难点 …… 解决方法以线段的右端点排序，**去除后效性**。\n\n以 $ f[i] $ 表示前 `i` 条线段中选出若干条（必选第 `i` 条）的最大总长度，则转移方程为：\n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n简单地说，就是只要**保证最后一条线段不与当前线段重合**，就可以添加当前线段。\n\n注意最终答案是 $ max\\{f[i],i{\\in}[1,n]\\} $，而不一定是 $f[n]$，因为不选最后一条线段可能比选最后一条线段更优。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1345.md","raw":"title: 「CodeVS 1345」饥饿的奶牛 - 线性 DP\ncategories: OI\ntags: \n  - CodeVS\n  - USACO\n  - DP\n  - 线性 DP\npermalink: codevs-1345\nid: 21\nupdated: '2016-01-19 21:04:02'\ndate: 2016-01-14 05:17:18\n---\n\n在 `n`（≤ 1000）条线段中选出若干条，保证任意两条线段没有公共点（端点也不能重合），使总长度最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### 题解\n刚开始确实晕了，又是想线段树又是想背包 ……\n\n保证线段不重合是个难点 …… 解决方法以线段的右端点排序，**去除后效性**。\n\n以 $ f[i] $ 表示前 `i` 条线段中选出若干条（必选第 `i` 条）的最大总长度，则转移方程为：\n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n简单地说，就是只要**保证最后一条线段不与当前线段重合**，就可以添加当前线段。\n\n注意最终答案是 $ max\\{f[i],i{\\in}[1,n]\\} $，而不一定是 $f[n]$，因为不选最后一条线段可能比选最后一条线段更优。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"codevs-1345","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9l01ckooxlliudo3kh"},{"title":"「BZOJ 3881」Divljak - AC 自动机 + 树上路径并","date":"2016-09-17T23:27:00.000Z","_content":"\n给 $ n $ 个字符串 $ S_1, S_2, \\ldots, S_n $，另有一个集合 $ T $，初始为空。  \n有 $ q $ 次操作，每次向 $ T $ 中添加一个字符串 $ P $，或询问 $ T $ 中有多少串能匹配 $ S_i $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3881](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)\n\n### 题解\n对 $ S_i $ 建立 AC 自动机，每次加入一个串 $ P $ 时，将所有匹配 $ P $ 的单词节点计数器 $ +1 $，询问时直接输出答案。\n\n考虑到每一次能匹配一个串的单词节点数量是 $ O(n ^ 2) $ 级别的，需要优化。如果我们不考虑后缀链接，则匹配数量降为 $ O(n) $，而对于通过后缀链接转移到的点，都是这些点在 Fail 树上的祖先。\n\n每次记录所有匹配 $ P $ 的首个单词节点，在 Fail 树上对这些点到根的路径求**并**，对路径并的每个节点计数器 $ +1 $。\n\n关于求路径并，将所有节点按照 DFS 序排序，将每个点到根的路径加入到集合中，将相邻每一对点的最近公共祖先到根的路径从集合中去除即可。\n\n体现在本题中即为将每个点到根的路径上的每一个点计数器 $ +1 $，相邻每一对点的最近公共祖先到根的路径上的每一个点计数器 $ -1 $。转化为子树求和，用树状数组维护即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 2000000;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nint tot;\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tint id;\n\t\tbool isWord, visited;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, std::vector<int> &vec) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) vec.push_back(v->id);\n\t\t\telse if (v->next) vec.push_back(v->next->id);\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint l, r, depth, size;\n\tNode *p, *c, *top;\n\tbool visited;\n} N[MAXLEN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n#ifdef DBG\n\tprintf(\"addEdge: %d -> %d\\n\", s + 1, t + 1);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->fail != v) addEdge(v->id, v->fail->id);\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].depth = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) {\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->c || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->top = (!v->p || v != v->p->c) ? v : v->p->top;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) {\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) assert(N[i].l && N[i].r);\n\n#ifdef DBG\n\tfor (int i = 0; i < tot; i++) {\n\t\tprintf(\"N[%d] => [%d, %d]\\n\", i + 1, N[i].l, N[i].r);\n\t}\n#endif\n}\n\ninline Node *lca(Node *a, Node *b) {\n\twhile (a->top != b->top) {\n\t\tif (a->top->depth < b->top->depth) std::swap(a, b);\n\t\ta = a->top->p;\n\t}\n\tNode *res = a->depth < b->depth ? a : b;\n#ifdef DBG\n\tprintf(\"lca(%lu, %lu) = %lu\\n\", a - N + 1, b - N + 1, res - N + 1);\n#endif\n\treturn res;\n}\n\ninline bool compare(const int a, const int b) {\n\treturn N[a].l < N[b].l;\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN + 1 + 1 + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n#ifdef DBG\n\t\tprintf(\"BIT: %d add %d\\n\", pos, delta);\n#endif\n#ifdef FORCE\n\t\ta[pos] += delta;\n\t\treturn;\n#endif\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint sum(const int pos) {\n\t\tint res = 0;\n#ifdef FORCE\n\t\tfor (int i = 1; i <= pos; i++) res += a[i];\n\t\t// printf(\"sum(%d) = %d\\n\", pos, res);\n\t\treturn res;\n#endif\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef FORCE\n\t\tint res = 0;\n\t\tfor (int i = l; i <= r; i++) res += a[i];\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, res);\n\t\treturn res;\n#endif\n\t\treturn sum(r) - sum(l - 1);\n\t}\n} bit;\n\ninline void add(const char *begin, const char *end) {\n\tstd::vector<int> vec;\n\tt.exec(begin, end, vec);\n\tstd::sort(vec.begin(), vec.end(), compare);\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n#ifdef DBG\n\tprintf(\"%lu matched:\", vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++) printf(\" %d\", vec[i] + 1);\n\tputchar('\\n');\n#endif\n\n\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\tbit.update(N[vec[i]].l, 1);\n\t\tif (i != 0) {\n\t\t\tNode *p = lca(&N[vec[i]], &N[vec[i - 1]]);\n\t\t\tbit.update(p->l, -1);\n\t\t}\n\t}\n}\n\ninline int solve(const int x) {\n\treturn bit.query(N[x].l, N[x].r);\n}\n\nint main() {\n\tint n;\n\tstatic char s[MAXLEN + 1];\n\tscanf(\"%d\", &n);\n\tTrie::Node *a[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\ta[i] = t.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\tsplit();\n\tbit.init(tot);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tconst int len = strlen(s);\n#ifdef DBG\n\t\t\tprintf(\"add(\\\"%s\\\"): \", s);\n#endif\n\t\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\t\tadd(s, s + len);\n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%d\\n\", solve(a[x]->id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/coci2015-divljak.md","raw":"title: 「BZOJ 3881」Divljak - AC 自动机 + 树上路径并\ncategories: OI\ntags: \n  - BZOJ\n  - COCI\n  - 字符串\n  - AC 自动机\n  - 树链剖分\n  - 树上路径并\npermalink: bzoj-3881\ndate: 2016-09-18 07:27:00\n---\n\n给 $ n $ 个字符串 $ S_1, S_2, \\ldots, S_n $，另有一个集合 $ T $，初始为空。  \n有 $ q $ 次操作，每次向 $ T $ 中添加一个字符串 $ P $，或询问 $ T $ 中有多少串能匹配 $ S_i $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3881](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)\n\n### 题解\n对 $ S_i $ 建立 AC 自动机，每次加入一个串 $ P $ 时，将所有匹配 $ P $ 的单词节点计数器 $ +1 $，询问时直接输出答案。\n\n考虑到每一次能匹配一个串的单词节点数量是 $ O(n ^ 2) $ 级别的，需要优化。如果我们不考虑后缀链接，则匹配数量降为 $ O(n) $，而对于通过后缀链接转移到的点，都是这些点在 Fail 树上的祖先。\n\n每次记录所有匹配 $ P $ 的首个单词节点，在 Fail 树上对这些点到根的路径求**并**，对路径并的每个节点计数器 $ +1 $。\n\n关于求路径并，将所有节点按照 DFS 序排序，将每个点到根的路径加入到集合中，将相邻每一对点的最近公共祖先到根的路径从集合中去除即可。\n\n体现在本题中即为将每个点到根的路径上的每一个点计数器 $ +1 $，相邻每一对点的最近公共祖先到根的路径上的每一个点计数器 $ -1 $。转化为子树求和，用树状数组维护即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 2000000;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nint tot;\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tint id;\n\t\tbool isWord, visited;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, std::vector<int> &vec) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) vec.push_back(v->id);\n\t\t\telse if (v->next) vec.push_back(v->next->id);\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint l, r, depth, size;\n\tNode *p, *c, *top;\n\tbool visited;\n} N[MAXLEN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n#ifdef DBG\n\tprintf(\"addEdge: %d -> %d\\n\", s + 1, t + 1);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->fail != v) addEdge(v->id, v->fail->id);\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].depth = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) {\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->c || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->top = (!v->p || v != v->p->c) ? v : v->p->top;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) {\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) assert(N[i].l && N[i].r);\n\n#ifdef DBG\n\tfor (int i = 0; i < tot; i++) {\n\t\tprintf(\"N[%d] => [%d, %d]\\n\", i + 1, N[i].l, N[i].r);\n\t}\n#endif\n}\n\ninline Node *lca(Node *a, Node *b) {\n\twhile (a->top != b->top) {\n\t\tif (a->top->depth < b->top->depth) std::swap(a, b);\n\t\ta = a->top->p;\n\t}\n\tNode *res = a->depth < b->depth ? a : b;\n#ifdef DBG\n\tprintf(\"lca(%lu, %lu) = %lu\\n\", a - N + 1, b - N + 1, res - N + 1);\n#endif\n\treturn res;\n}\n\ninline bool compare(const int a, const int b) {\n\treturn N[a].l < N[b].l;\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN + 1 + 1 + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n#ifdef DBG\n\t\tprintf(\"BIT: %d add %d\\n\", pos, delta);\n#endif\n#ifdef FORCE\n\t\ta[pos] += delta;\n\t\treturn;\n#endif\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint sum(const int pos) {\n\t\tint res = 0;\n#ifdef FORCE\n\t\tfor (int i = 1; i <= pos; i++) res += a[i];\n\t\t// printf(\"sum(%d) = %d\\n\", pos, res);\n\t\treturn res;\n#endif\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef FORCE\n\t\tint res = 0;\n\t\tfor (int i = l; i <= r; i++) res += a[i];\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, res);\n\t\treturn res;\n#endif\n\t\treturn sum(r) - sum(l - 1);\n\t}\n} bit;\n\ninline void add(const char *begin, const char *end) {\n\tstd::vector<int> vec;\n\tt.exec(begin, end, vec);\n\tstd::sort(vec.begin(), vec.end(), compare);\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n#ifdef DBG\n\tprintf(\"%lu matched:\", vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++) printf(\" %d\", vec[i] + 1);\n\tputchar('\\n');\n#endif\n\n\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\tbit.update(N[vec[i]].l, 1);\n\t\tif (i != 0) {\n\t\t\tNode *p = lca(&N[vec[i]], &N[vec[i - 1]]);\n\t\t\tbit.update(p->l, -1);\n\t\t}\n\t}\n}\n\ninline int solve(const int x) {\n\treturn bit.query(N[x].l, N[x].r);\n}\n\nint main() {\n\tint n;\n\tstatic char s[MAXLEN + 1];\n\tscanf(\"%d\", &n);\n\tTrie::Node *a[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\ta[i] = t.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\tsplit();\n\tbit.init(tot);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tconst int len = strlen(s);\n#ifdef DBG\n\t\t\tprintf(\"add(\\\"%s\\\"): \", s);\n#endif\n\t\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\t\tadd(s, s + len);\n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%d\\n\", solve(a[x]->id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3881","published":1,"updated":"2016-09-18T23:01:08.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9r01cqooxlimg9hty7"},{"title":"主席树学习笔记","date":"2016-05-11T13:06:00.000Z","_content":"\n主席树是一种数据结构，其主要应用是区间第 $ k $ 大问题。\n\n<!-- more -->\n\n### 权值线段树\n传统的线段树用于维护一条线段上的区间，可以方便地查询区间信息。而如果将线段树转化为『权值线段树』，每个叶子节点存储某个元素出现次数，一条线段的总和表示区间内所有数出现次数的总和。\n\n利用权值线段树可以方便地求出整体第 $ k $ 大 —— 从根节点向下走，如果 $ k $ 小于等于左子树大小，说明第 $ k $ 大在左子树的区间中，在左子树中继续查找即可；否则，说明第 $ k $ 大在右子树的区间中，此时将 $ k $ 减去左子树大小，并在右子树中继续查找。\n\n查找过程类似平衡树，时间复杂度为 $ O(\\log n) $。\n\n### 前缀和\n上述算法可以用来处理整个序列上的第 $ k $ 大，而我们可以对于一个长度为 $ n $ 的序列 $ a $ 建立 $ n $ 棵上述的权值线段树，第 $ i $ 棵表示『$ a_1 $ ~ $ a_i $ 的所有数』组成的权值线段树。如果要查询 $ [l, r] $ 中的第 $ k $ 大，可以使用第 $ r $ 棵线段树减去第 $ l - 1 $ 棵线段树，得到整个区间组成的权值线段树，并进行上述算法得到区间中的第 $ k $ 大。\n\n这个算法存在两个问题：\n\n1. 每个线段树要占用 $ O(n \\log n) $ 的空间，算法的空间复杂度为 $ O(n ^ 2 \\log n) $，占用空间过多；\n2. 建立每棵线段树至少要用 $ O(n \\log n) $ 的时间，每次查询又要用 $ O(n \\log n) $ 的时间构建区间的权值线段树，总时间复杂度 $ O((n + m) n \\log n) $。\n\n看上去还不如**每次直接提取出区间，并使用后线性选择得到答案**的 $ O(n ^ 2) $ 的朴素算法优秀。\n\n### 主席树\n仔细思考，发现上述算法的 $ n $ 棵线段树中，相邻的两棵线段树仅有 $ O(\\log n) $ 个节点不同，因此本质不同的节点只有 $ O(n \\log n) $ 个。我们可以充分利用这一特点，每次只重新创建与上次所不同的节点，相同的节点直接使用前一棵的即可。\n\n为了节省空间，可以将第 $ 0 $ 棵线段树置为空，每次插入一个新叶子节点时接入一条长度为 $ O(\\log n) $ 的链。总空间、时间复杂度仍为 $ O(n \\log n) $\n\n查询时构造整棵线段树，需要构造 $ O(n \\log n) $ 个节点，但每次查询只会用到 $ O(\\log n) $ 个节点，直接动态构造这些节点即可。为了方便，可以不显式构造这些节点，而是直接用两棵线段树上的值相减。\n\n### 模板\n[POJ 2104](http://poj.org/problem?id=2104)  \n动态分配内存会超时，需要静态分配内存。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/chairman-tree-notes.md","raw":"title: 主席树学习笔记\ncategories: OI\ntags: \n  - 数据结构\n  - 主席树\n  - 学习笔记\n  - 算法模板\npermalink: chairman-tree-notes\ndate: 2016-05-11 21:06:00\n---\n\n主席树是一种数据结构，其主要应用是区间第 $ k $ 大问题。\n\n<!-- more -->\n\n### 权值线段树\n传统的线段树用于维护一条线段上的区间，可以方便地查询区间信息。而如果将线段树转化为『权值线段树』，每个叶子节点存储某个元素出现次数，一条线段的总和表示区间内所有数出现次数的总和。\n\n利用权值线段树可以方便地求出整体第 $ k $ 大 —— 从根节点向下走，如果 $ k $ 小于等于左子树大小，说明第 $ k $ 大在左子树的区间中，在左子树中继续查找即可；否则，说明第 $ k $ 大在右子树的区间中，此时将 $ k $ 减去左子树大小，并在右子树中继续查找。\n\n查找过程类似平衡树，时间复杂度为 $ O(\\log n) $。\n\n### 前缀和\n上述算法可以用来处理整个序列上的第 $ k $ 大，而我们可以对于一个长度为 $ n $ 的序列 $ a $ 建立 $ n $ 棵上述的权值线段树，第 $ i $ 棵表示『$ a_1 $ ~ $ a_i $ 的所有数』组成的权值线段树。如果要查询 $ [l, r] $ 中的第 $ k $ 大，可以使用第 $ r $ 棵线段树减去第 $ l - 1 $ 棵线段树，得到整个区间组成的权值线段树，并进行上述算法得到区间中的第 $ k $ 大。\n\n这个算法存在两个问题：\n\n1. 每个线段树要占用 $ O(n \\log n) $ 的空间，算法的空间复杂度为 $ O(n ^ 2 \\log n) $，占用空间过多；\n2. 建立每棵线段树至少要用 $ O(n \\log n) $ 的时间，每次查询又要用 $ O(n \\log n) $ 的时间构建区间的权值线段树，总时间复杂度 $ O((n + m) n \\log n) $。\n\n看上去还不如**每次直接提取出区间，并使用后线性选择得到答案**的 $ O(n ^ 2) $ 的朴素算法优秀。\n\n### 主席树\n仔细思考，发现上述算法的 $ n $ 棵线段树中，相邻的两棵线段树仅有 $ O(\\log n) $ 个节点不同，因此本质不同的节点只有 $ O(n \\log n) $ 个。我们可以充分利用这一特点，每次只重新创建与上次所不同的节点，相同的节点直接使用前一棵的即可。\n\n为了节省空间，可以将第 $ 0 $ 棵线段树置为空，每次插入一个新叶子节点时接入一条长度为 $ O(\\log n) $ 的链。总空间、时间复杂度仍为 $ O(n \\log n) $\n\n查询时构造整棵线段树，需要构造 $ O(n \\log n) $ 个节点，但每次查询只会用到 $ O(\\log n) $ 个节点，直接动态构造这些节点即可。为了方便，可以不显式构造这些节点，而是直接用两棵线段树上的值相减。\n\n### 模板\n[POJ 2104](http://poj.org/problem?id=2104)  \n动态分配内存会超时，需要静态分配内存。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"chairman-tree-notes","published":1,"updated":"2016-05-11T13:06:44.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sa201d0ooxlvy3jjpt2"},{"title":"「Codeforces 716E」Digit Tree - 点分治","date":"2016-09-21T02:30:00.000Z","_content":"\n给一棵树，每一条边上有一个 $ [1, 9] $ 内的数字，求有多少有序点对 $ (u, v) $ 满足，将 $ u $ 到 $ v $ 的最短路上所有边上的数字连接成一个数，这个数是 $ m $ 的倍数。其中 $ \\gcd(m, 10) = 1 $。\n\n<!-- more -->\n\n### 链接\n[Codeforces 716E](http://codeforces.com/contest/716/problem/E)\n\n### 题解\n点分治，考虑一棵子树内满足条件的点对。\n\n记录 $ a_i $ 为从根到 $ i $ 节点路径上所有边上的数字按倒序连接成的数；$ b_i $ 为对应按正序连接成的数；$ d_i $ 为节点 $ i $ 的深度，等于 $ a_i $ 和 $ b_i $ 十进制位数。如\n\n![例子](cf-716e/example.svg)\n\n$$\n\\begin{cases}\na_u = 321 & a_v = 54 \\\\\nb_u = 123 & b_v = 45 \\\\\nd_u = 3 & d_v = 2\n\\end{cases}\n$$\n\n从 $ u $ 到 $ v $ 的路径组成的数可以表示为\n\n$$ a_u \\times 10 ^ {d_v} + b_v $$\n\n题目要求的条件即为\n\n$$ a_u \\times 10 ^ {d_v} + b_v \\equiv 0 \\pmod m $$\n\n因为这是一个同余式，所以 $ a_i $ 和 $ b_i $ 可以是模意义下的。\n\n整理，得\n\n$$ a_u \\equiv -b_v \\times \\frac{1}{10 ^ {d_v}} \\pmod m $$\n\n将式子右边存入哈希表中，对于每个节点 $ u $，对答案的贡献即为哈希表中 $ a_u $ 出现的次数。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tint size, depth, max;\n\tbool visited, solved;\n\tlong long backward, forward;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, mod;\nlong long pow10[MAXN + 1], pow10Inv[MAXN + 1];\n\nvoid exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long x) {\n\tlong long tmp1, res, tmp2;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline long long calc(Node *root, const int pre = 0) {\n\tif (pre != 0) {\n\t\troot->forward = root->backward = pre;\n\t\troot->depth = 1;\n\t} else {\n\t\troot->forward = root->backward = 0;\n\t\troot->depth = 0;\n\t}\n\troot->parent = NULL;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\n\tstd::map<long long, int> map;\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tmap[(mod - v->forward) * pow10Inv[v->depth] % mod]++;\n\t\tassert((mod - v->forward) * pow10Inv[v->depth] % mod >= 0);\n\t\ta[cnt++] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->forward = (v->forward * 10 + e->w) % mod;\n\t\t\te->t->backward = (e->w * pow10[v->depth] + v->backward) % mod;\n#ifdef DBG\n\t\t\tprintf(\"%lld <--> %lld\\n\", e->t->forward, e->t->backward);\n#endif\n\t\t\te->t->parent = v;\n\t\t\te->t->depth = v->depth + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tlong long ans = 0; // pre ? 0 : -1 * 0;\n#ifdef FORCE\n\tfor (int i = 0; i < cnt; i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif ((a[i]->backward * pow10[a[j]->depth] + a[j]->forward) % 3 == 0 /*&& !(a[i]->backward == 0 && a[j]->forward == 0)*/) {\n\t\t\t\tans++;\n#ifdef DBG\n\t\t\t\tprintf(\"%lld\\n\", a[i]->backward * pow10[a[j]->depth] + a[j]->forward);\n#endif\n\t\t\t}\n\t\t\tif (a[i]->backward == 0 && a[j]->forward == 0) printf(\"%lu %lu in %lu, %d\\n\", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--;\n\t\t}\n\t}\n#else\n\tmap[0]--;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans += map[a[i]->backward];\n#ifdef DBG\n\t\tprintf(\"back = %lld, ans + %d\\n\", a[i]->backward, map[a[i]->backward]);\n#endif\n\t}\n#endif\n#ifdef DBG\n\tfor (std::map<long long, int>::const_iterator it = map.begin(); it != map.end(); it++) printf(\"[%lld => %d]\\n\", it->first, it->second);\n\tprintf(\"** ans = %lld\\n\", ans);\n#endif\n\n\treturn ans;\n}\n\ninline long long solve() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n#ifdef DBG\n\t\tputs(\"+++++++++++++++++++\");\n#endif\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n#ifdef DBG\n\t\t\tputs(\"-------------------\");\n#endif\n\t\t\tans -= calc(e->t, e->w);\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &mod);\n#ifdef FORCE\n\tmod = 1e9 + 7;\n#endif\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w % mod);\n\t}\n\n\tpow10[0] = pow10Inv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10 % mod;\n\t\tpow10Inv[i] = inv(pow10[i]);\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}\n```\n","source":"_posts/cf-716e.md","raw":"title: 「Codeforces 716E」Digit Tree - 点分治\ncategories: OI\ntags: \n  - Codeforces\n  - 数据结构\n  - 点分治\n  - 数学\n  - 数论\n  - 乘法逆元\npermalink: cf-716e\ndate: 2016-09-21 10:30:00\n---\n\n给一棵树，每一条边上有一个 $ [1, 9] $ 内的数字，求有多少有序点对 $ (u, v) $ 满足，将 $ u $ 到 $ v $ 的最短路上所有边上的数字连接成一个数，这个数是 $ m $ 的倍数。其中 $ \\gcd(m, 10) = 1 $。\n\n<!-- more -->\n\n### 链接\n[Codeforces 716E](http://codeforces.com/contest/716/problem/E)\n\n### 题解\n点分治，考虑一棵子树内满足条件的点对。\n\n记录 $ a_i $ 为从根到 $ i $ 节点路径上所有边上的数字按倒序连接成的数；$ b_i $ 为对应按正序连接成的数；$ d_i $ 为节点 $ i $ 的深度，等于 $ a_i $ 和 $ b_i $ 十进制位数。如\n\n![例子](cf-716e/example.svg)\n\n$$\n\\begin{cases}\na_u = 321 & a_v = 54 \\\\\nb_u = 123 & b_v = 45 \\\\\nd_u = 3 & d_v = 2\n\\end{cases}\n$$\n\n从 $ u $ 到 $ v $ 的路径组成的数可以表示为\n\n$$ a_u \\times 10 ^ {d_v} + b_v $$\n\n题目要求的条件即为\n\n$$ a_u \\times 10 ^ {d_v} + b_v \\equiv 0 \\pmod m $$\n\n因为这是一个同余式，所以 $ a_i $ 和 $ b_i $ 可以是模意义下的。\n\n整理，得\n\n$$ a_u \\equiv -b_v \\times \\frac{1}{10 ^ {d_v}} \\pmod m $$\n\n将式子右边存入哈希表中，对于每个节点 $ u $，对答案的贡献即为哈希表中 $ a_u $ 出现的次数。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tint size, depth, max;\n\tbool visited, solved;\n\tlong long backward, forward;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, mod;\nlong long pow10[MAXN + 1], pow10Inv[MAXN + 1];\n\nvoid exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long x) {\n\tlong long tmp1, res, tmp2;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline long long calc(Node *root, const int pre = 0) {\n\tif (pre != 0) {\n\t\troot->forward = root->backward = pre;\n\t\troot->depth = 1;\n\t} else {\n\t\troot->forward = root->backward = 0;\n\t\troot->depth = 0;\n\t}\n\troot->parent = NULL;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\n\tstd::map<long long, int> map;\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tmap[(mod - v->forward) * pow10Inv[v->depth] % mod]++;\n\t\tassert((mod - v->forward) * pow10Inv[v->depth] % mod >= 0);\n\t\ta[cnt++] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->forward = (v->forward * 10 + e->w) % mod;\n\t\t\te->t->backward = (e->w * pow10[v->depth] + v->backward) % mod;\n#ifdef DBG\n\t\t\tprintf(\"%lld <--> %lld\\n\", e->t->forward, e->t->backward);\n#endif\n\t\t\te->t->parent = v;\n\t\t\te->t->depth = v->depth + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tlong long ans = 0; // pre ? 0 : -1 * 0;\n#ifdef FORCE\n\tfor (int i = 0; i < cnt; i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif ((a[i]->backward * pow10[a[j]->depth] + a[j]->forward) % 3 == 0 /*&& !(a[i]->backward == 0 && a[j]->forward == 0)*/) {\n\t\t\t\tans++;\n#ifdef DBG\n\t\t\t\tprintf(\"%lld\\n\", a[i]->backward * pow10[a[j]->depth] + a[j]->forward);\n#endif\n\t\t\t}\n\t\t\tif (a[i]->backward == 0 && a[j]->forward == 0) printf(\"%lu %lu in %lu, %d\\n\", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--;\n\t\t}\n\t}\n#else\n\tmap[0]--;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans += map[a[i]->backward];\n#ifdef DBG\n\t\tprintf(\"back = %lld, ans + %d\\n\", a[i]->backward, map[a[i]->backward]);\n#endif\n\t}\n#endif\n#ifdef DBG\n\tfor (std::map<long long, int>::const_iterator it = map.begin(); it != map.end(); it++) printf(\"[%lld => %d]\\n\", it->first, it->second);\n\tprintf(\"** ans = %lld\\n\", ans);\n#endif\n\n\treturn ans;\n}\n\ninline long long solve() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n#ifdef DBG\n\t\tputs(\"+++++++++++++++++++\");\n#endif\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n#ifdef DBG\n\t\t\tputs(\"-------------------\");\n#endif\n\t\t\tans -= calc(e->t, e->w);\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &mod);\n#ifdef FORCE\n\tmod = 1e9 + 7;\n#endif\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w % mod);\n\t}\n\n\tpow10[0] = pow10Inv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10 % mod;\n\t\tpow10Inv[i] = inv(pow10[i]);\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}\n```\n","slug":"cf-716e","published":1,"updated":"2017-01-02T07:03:10.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sa801d6ooxltw9m0m0q"},{"title":"「Codeforces 628D」Magic Numbers - 数位 DP","date":"2016-05-12T07:47:00.000Z","_content":"\n我们认为一个数是 `d-magic` 的，当且仅当数字 $ d $ 出现在这个数字的十进制表示的所有偶数位上，而不会出现在其它位上。\n\n例如，$ 1727374,\\ 17,\\ 1 $ 是 `7-magic` 的，但 $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $ 不是 `7-magic` 的。\n\n找出能被 `m` 整除的 `d-magic` 的数字在区间 $ [a, b] $ 内的数量。\n\n<!-- more -->\n\n### 链接\n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### 题解\n数位 DP，设\n\n$$ f[n][limit][r] $$\n\n表示数字的最后 $ n $ 位，最高位最大为 $ limit $，模 $ m $ 的余数为 $ r $ 的数量。\n\n对于 $ [a, b] $ 的限制，我们通常定义函数 $ g(x) $ 表示 $ [0, x] $ 中的数量，求出 $ g(b) - g(a - 1) $，但这道题目中 $ a $ 是高精度数，不方便做减法，可以先求出 $ g(b) - g(a) $，然后特判 $ a $ 是否有效。\n\n### 代码\n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","source":"_posts/cf-628d.md","raw":"title: 「Codeforces 628D」Magic Numbers - 数位 DP\ncategories: OI\ntags: \n  - Codeforces\n  - 数位 DP\n  - DP\npermalink: cf-628d\ndate: 2016-05-12 15:47:00\n---\n\n我们认为一个数是 `d-magic` 的，当且仅当数字 $ d $ 出现在这个数字的十进制表示的所有偶数位上，而不会出现在其它位上。\n\n例如，$ 1727374,\\ 17,\\ 1 $ 是 `7-magic` 的，但 $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $ 不是 `7-magic` 的。\n\n找出能被 `m` 整除的 `d-magic` 的数字在区间 $ [a, b] $ 内的数量。\n\n<!-- more -->\n\n### 链接\n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### 题解\n数位 DP，设\n\n$$ f[n][limit][r] $$\n\n表示数字的最后 $ n $ 位，最高位最大为 $ limit $，模 $ m $ 的余数为 $ r $ 的数量。\n\n对于 $ [a, b] $ 的限制，我们通常定义函数 $ g(x) $ 表示 $ [0, x] $ 中的数量，求出 $ g(b) - g(a - 1) $，但这道题目中 $ a $ 是高精度数，不方便做减法，可以先求出 $ g(b) - g(a) $，然后特判 $ a $ 是否有效。\n\n### 代码\n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","slug":"cf-628d","published":1,"updated":"2016-10-24T23:38:39.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9saj01dfooxlkcflucvz"},{"title":"「CEOI2008」Order - 最小割","date":"2016-06-22T08:07:00.000Z","_content":"\n有 $ N $ 个工作，$ M $ 种机器，每种机器你可以租或者买过来。每个工作（可以不做）包括若干道工序，每道工序需要某种机器来完成，你可以通过购买或租用机器来完成。求最大利润。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1391](http://www.lydsy.com/JudgeOnline/problem.php?id=1391)\n\n### 题解\n为每个工作和机器建点，增加源和汇。\n\n从源点向每个工作连边，容量为利润；从每个工作向它需要的机器连边，容量为租用费用；从每个机器向汇点连边，容量为购买费用。\n\n割源点连向工作的边表示不做工作，割中间的边表示租用一台机器，割机器到汇点的边表示购买机器。\n\n所有工作利润的总和减去最小割即为答案。\n\n### 代码\n不知道哪里写错了，一直 MLE ……\n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #include <queue>\n// #include <vector>\n\nconst int MAXN = 1200;\nconst int MAXM = 1200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t// std::queue<Node *> q;\n\t\t// q.push(s);\n\t\tstatic Node *q[MAXN + MAXM + 2];\n\t\tNode **l = q, **r = q - 1;\n\t\t*++r = s;\n\n\t\ts->l = 1;\n\n\t\twhile (l <= r /* !q.empty() */) {\n\t\t\tNode *v = *l++ /* q.front() */;\n\t\t\t// q.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse *++r = e->t; // q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w, k;\n\t\tscanf(\"%d %d\", &w, &k);\n\t\tsum += w;\n\n\t\taddEdge(s, i, w);\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\taddEdge(i, n + x, c);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(n + i, t, x);\n\t}\n\n\t/*\n\tstatic int w[MAXN];\n\tstatic std::vector< std::pair<int, int> > used[MAXN];\n\tstatic std::vector<int> borrow[MAXM];\n\tstatic std::pair<int, int> buy[MAXM];\n\tint id = n + 1, sum = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k;\n\t\tscanf(\"%d %d\", &w[i - 1], &k);\n\t\tsum += w[i - 1];\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\tint t = id++;\n\t\t\tused[i - 1].push_back(std::make_pair(t, c));\n\t\t\tborrow[x - 1].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &buy[i].second);\n\t\tbuy[i].first = id++;\n\t}\n\n\tconst int s = 0, t = id++;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, w[i - 1]);\n\n\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) {\n\t\t\taddEdge(i, it->first, it->second);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (std::vector<int>::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) {\n\t\t\taddEdge(*it, buy[i].first, INT_MAX);\n\t\t}\n\t\taddEdge(buy[i].first, t, buy[i].second);\n\t}\n\t*/\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/ceoi2008-order.md","raw":"title: 「CEOI2008」Order - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: ceoi2008-order\ndate: 2016-06-22 16:07:00\n---\n\n有 $ N $ 个工作，$ M $ 种机器，每种机器你可以租或者买过来。每个工作（可以不做）包括若干道工序，每道工序需要某种机器来完成，你可以通过购买或租用机器来完成。求最大利润。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1391](http://www.lydsy.com/JudgeOnline/problem.php?id=1391)\n\n### 题解\n为每个工作和机器建点，增加源和汇。\n\n从源点向每个工作连边，容量为利润；从每个工作向它需要的机器连边，容量为租用费用；从每个机器向汇点连边，容量为购买费用。\n\n割源点连向工作的边表示不做工作，割中间的边表示租用一台机器，割机器到汇点的边表示购买机器。\n\n所有工作利润的总和减去最小割即为答案。\n\n### 代码\n不知道哪里写错了，一直 MLE ……\n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #include <queue>\n// #include <vector>\n\nconst int MAXN = 1200;\nconst int MAXM = 1200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t// std::queue<Node *> q;\n\t\t// q.push(s);\n\t\tstatic Node *q[MAXN + MAXM + 2];\n\t\tNode **l = q, **r = q - 1;\n\t\t*++r = s;\n\n\t\ts->l = 1;\n\n\t\twhile (l <= r /* !q.empty() */) {\n\t\t\tNode *v = *l++ /* q.front() */;\n\t\t\t// q.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse *++r = e->t; // q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w, k;\n\t\tscanf(\"%d %d\", &w, &k);\n\t\tsum += w;\n\n\t\taddEdge(s, i, w);\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\taddEdge(i, n + x, c);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(n + i, t, x);\n\t}\n\n\t/*\n\tstatic int w[MAXN];\n\tstatic std::vector< std::pair<int, int> > used[MAXN];\n\tstatic std::vector<int> borrow[MAXM];\n\tstatic std::pair<int, int> buy[MAXM];\n\tint id = n + 1, sum = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k;\n\t\tscanf(\"%d %d\", &w[i - 1], &k);\n\t\tsum += w[i - 1];\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\tint t = id++;\n\t\t\tused[i - 1].push_back(std::make_pair(t, c));\n\t\t\tborrow[x - 1].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &buy[i].second);\n\t\tbuy[i].first = id++;\n\t}\n\n\tconst int s = 0, t = id++;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, w[i - 1]);\n\n\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) {\n\t\t\taddEdge(i, it->first, it->second);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (std::vector<int>::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) {\n\t\t\taddEdge(*it, buy[i].first, INT_MAX);\n\t\t}\n\t\taddEdge(buy[i].first, t, buy[i].second);\n\t}\n\t*/\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"ceoi2008-order","published":1,"updated":"2016-06-22T08:07:58.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sao01dkooxl00fmrn5m"},{"title":"「CEOI2004」锯木厂选址 - 斜率优化 DP","date":"2016-05-18T10:03:00.000Z","_content":"\n从山顶上到山底下沿着一条直线种植了 $ n $ 棵老树。当地的政府决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。\n木材只能按照一个方向运输：朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建两个锯木厂，使得传输的费用总和最小。假定运输每公斤木材每米需要一分钱。\n\n<!-- more -->\n\n### 链接\n[COGS 362](http://cogs.top/cogs/problem/problem.php?pid=362)\n\n### 题解\n将整个序列反转，目标变为将所有树运到 $ 0 $ 号点。\n\n设 $ f[i][j] $ 表示前 $ i $ 棵树，修建 $ j $ 个锯木厂的最小花费。使用滚动数组去掉第二维，设 $ f(i) $ 为原有的 $ f[i][j] $，$ g(i) $ 为原有的 $ f[i][j - 1] $。$ S(i) $ 表示前 $ i $ 棵树全部运到 $ 0 $ 号点的花费，$ s(i) $ 表示前 $ i $ 棵树的总质量。\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i} \\{ g(j) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n斜率优化，考虑两个决策点 $ a $、$ b $，若 $ a $ 比 $ b $ 优，则有\n\n$$\n{(g(a) - S(a) + s(a) \\times d(a + 1)) - (g(b) - S(b) + s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1)} < s(i)\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 3;\n\nint n;\nlong long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1];\nlong long g[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n    std::reverse(w + 1, w + n + 1);\n    std::reverse(d + 1, d + n + 1);\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n        s[i] = s[i - 1] + w[i];\n        S[i] = S[i - 1] + w[i] * d[i];\n    }\n}\n\n/*\ninline void force() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int _j = -1;\n            for (int j = 0; j < i; j++) {\n                if (f[i] > g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                    f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                    _j = j;\n                }\n            }\n            printf(\"%d --> %d\\n\", i, _j);\n        }\n    }\n}\n*/\n\ninline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; }\n\ninline double slope(const int a, const int b) {\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n\ninline void dp() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n\n        static int q[MAXN];\n        int *l = q, *r = q;\n        *r = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n\n            int &j = *l;\n            f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n            // printf(\"%d --> %d\\n\", i, j);\n\n            if (i < n) {\n                while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n                *++r = i;\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"two.in\", \"r\", stdin);\n    freopen(\"two.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld\", &w[i], &d[i]);\n    }\n\n    prepare();\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/ceoi2004-two.md","raw":"title: 「CEOI2004」锯木厂选址 - 斜率优化 DP\ncategories: OI\ntags: \n  - COGS\n  - CEOI\n  - 斜率优化\n  - 单调队列\n  - DP\npermalink: ceoi2004-two\ndate: 2016-05-18 18:03:00\n---\n\n从山顶上到山底下沿着一条直线种植了 $ n $ 棵老树。当地的政府决定把他们砍下来。为了不浪费任何一棵木材，树被砍倒后要运送到锯木厂。\n木材只能按照一个方向运输：朝山下运。山脚下有一个锯木厂。另外两个锯木厂将新修建在山路上。你必须决定在哪里修建两个锯木厂，使得传输的费用总和最小。假定运输每公斤木材每米需要一分钱。\n\n<!-- more -->\n\n### 链接\n[COGS 362](http://cogs.top/cogs/problem/problem.php?pid=362)\n\n### 题解\n将整个序列反转，目标变为将所有树运到 $ 0 $ 号点。\n\n设 $ f[i][j] $ 表示前 $ i $ 棵树，修建 $ j $ 个锯木厂的最小花费。使用滚动数组去掉第二维，设 $ f(i) $ 为原有的 $ f[i][j] $，$ g(i) $ 为原有的 $ f[i][j - 1] $。$ S(i) $ 表示前 $ i $ 棵树全部运到 $ 0 $ 号点的花费，$ s(i) $ 表示前 $ i $ 棵树的总质量。\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i} \\{ g(j) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n斜率优化，考虑两个决策点 $ a $、$ b $，若 $ a $ 比 $ b $ 优，则有\n\n$$\n{(g(a) - S(a) + s(a) \\times d(a + 1)) - (g(b) - S(b) + s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1)} < s(i)\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 3;\n\nint n;\nlong long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1];\nlong long g[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n    std::reverse(w + 1, w + n + 1);\n    std::reverse(d + 1, d + n + 1);\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n        s[i] = s[i - 1] + w[i];\n        S[i] = S[i - 1] + w[i] * d[i];\n    }\n}\n\n/*\ninline void force() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int _j = -1;\n            for (int j = 0; j < i; j++) {\n                if (f[i] > g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                    f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                    _j = j;\n                }\n            }\n            printf(\"%d --> %d\\n\", i, _j);\n        }\n    }\n}\n*/\n\ninline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; }\n\ninline double slope(const int a, const int b) {\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n\ninline void dp() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n\n        static int q[MAXN];\n        int *l = q, *r = q;\n        *r = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n\n            int &j = *l;\n            f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n            // printf(\"%d --> %d\\n\", i, j);\n\n            if (i < n) {\n                while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n                *++r = i;\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"two.in\", \"r\", stdin);\n    freopen(\"two.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld\", &w[i], &d[i]);\n    }\n\n    prepare();\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"ceoi2004-two","published":1,"updated":"2016-10-24T23:34:14.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sau01dqooxlnxqow11w"},{"title":"「BZOJ 4403」序列统计 - 组合数","date":"2016-04-08T14:11:34.000Z","_content":"\n给定三个正整数 $ N $、$ L $ 和 $ R $，统计长度在 $ 1 $ 到 $ N $ 之间，元素大小都在 $ L $ 到 $ R $ 之间的单调不降序列的数量。输出答案对 $ 10 ^ 6 + 3 $ 取模的结果。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### 题解\n问题等价于，从 $ [1, R - L + 1] $ 中选择 $ N $ 个数（可重复）的方案数。\n\n设\n\n$$ M = R - L + 1 $$\n\n答案为\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n直接算组合数会超时，需要用 Lucas 定理\n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n当 $ n \\lt p, m \\lt p $ 时，直接**使用公式**计算即可。\n\n不要预处理逆元，用到的时候用费马小定理计算即可。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4403.md","raw":"title: 「BZOJ 4403」序列统计 - 组合数\ncategories: OI\ntags: \n  - BZOJ\n  - 数学\n  - 组合数学\n  - 组合数\n  - 数论\n  - Lucas 定理\n  - 乘法逆元\npermalink: bzoj-4403\ndate: 2016-04-08 22:11:34\n---\n\n给定三个正整数 $ N $、$ L $ 和 $ R $，统计长度在 $ 1 $ 到 $ N $ 之间，元素大小都在 $ L $ 到 $ R $ 之间的单调不降序列的数量。输出答案对 $ 10 ^ 6 + 3 $ 取模的结果。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### 题解\n问题等价于，从 $ [1, R - L + 1] $ 中选择 $ N $ 个数（可重复）的方案数。\n\n设\n\n$$ M = R - L + 1 $$\n\n答案为\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n直接算组合数会超时，需要用 Lucas 定理\n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n当 $ n \\lt p, m \\lt p $ 时，直接**使用公式**计算即可。\n\n不要预处理逆元，用到的时候用费马小定理计算即可。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4403","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sb201dyooxl6v5leuke"},{"title":"「BZOJ 4318」OSU! - 概率与期望","date":"2016-05-31T09:32:00.000Z","_content":"\n我们可以把 osu! 的规则简化与改编成以下的样子: \n\n一共有 $ n $ 次操作，每次操作只有成功与失败之分，成功对应 $ 1 $，失败对应 $ 0 $，$ n $ 次操作对应为 $ 1 $ 个长度为 $ n $ 的 01 串。在这个串中连续的 $ x $ 个 $ 1 $ 可以贡献 $ x ^ 3 $ 的分数，这 $ x $ 个 $ 1 $ 不能被其他连续的 $ 1 $ 所包含（也就是极长的一串 $ 1 $）。\n\n现在给出 $ n $，以及每个操作的成功率，请你输出期望分数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4318](http://www.lydsy.com/JudgeOnline/problem.php?id=4318)\n\n### 题解\n设 $ f(i) $ 表示前 $ i $ 次操作后的期望得分，$ p(i) $ 表示第 $ i $ 次操作成功的概率。\n\n考虑连续 $ 1 $ 的长度 $ x $ 的变化，如果第 $ i $ 次成功，则 $ x_i = x_{i - 1} + 1 $，考虑其对得分 $ x ^ 3 $ 的影响。\n\n$$ (x + 1) ^ 3 - x ^ 3 = 3x ^ 2 + 3x + 1 $$\n\n根据期望的线性性，我们只需要求出 $ E_{x ^ 2} $ 和 $ E_x $，即可得到\n\n$$ E_{(x + 1) ^ 3 - x ^ 3} = 3E_{x ^ 2} + 3E_x + 1 $$\n\n乘上成功的概率，即为该次操作的期望分数增量（相对于第 $ i - 1 $ 次）。\n\n$$ f(i) = f(i - 1) + (3E_{x ^ 2}(i) + 3E_x(i) + 1) \\times p(i) $$\n\n考虑如何维护 $ E_{x ^ 2}(i) $ 与 $ E_x(i) $，仍旧是考虑期望的线性性，将式子展开。\n\n首先，显然\n\n$$ E_{x + 1} = E_x + 1 $$\n\n有 $ p(i) $ 的概率比上一次操作多 $ 1 $ 次，有 $ 1 - p(i) $ 的概率直接成为 $ 0 $，即\n\n$$ E_x(i) = (E_x(i - 1) + 1) \\times p(i) $$\n\n类似的，有\n\n$$ E_{(x + 1) ^ 2} = E_{x ^ 2} + 2E_{x} + 1 $$\n\n即\n\n$$ E_{x ^ 2}(i) = E_{x ^ 2}(i - 1) + 2E_{x}(i - 1) + 1 $$\n\n至此，$ E_{x ^ 2}(i) $、$ E_{x}(i) $、$ f(i) $ 均可在线性时间内递推得到。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n\nconst int MAXN = 100000;\n\nint n;\ndouble p[MAXN + 1], f[MAXN + 1];\ndouble ex1[MAXN + 1], ex2[MAXN + 1];\n\ninline void dp() {\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tex1[i] = (ex1[i - 1] + 1) * p[i];\n\t\tex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i];\n\t\tdouble t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i];\n\t\tf[i] = f[i - 1] + t;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n\n\tdp();\n\n\tprintf(\"%.1lf\\n\", floor(f[n] * 10 + 0.5) / 10);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4318.md","raw":"title: 「BZOJ 4318」OSU! - 概率与期望\ncategories: OI\ntags: \n  - BZOJ\n  - 数学\n  - 概率与期望\n  - DP\npermalink: bzoj-4318\ndate: 2016-05-31 17:32:00\n---\n\n我们可以把 osu! 的规则简化与改编成以下的样子: \n\n一共有 $ n $ 次操作，每次操作只有成功与失败之分，成功对应 $ 1 $，失败对应 $ 0 $，$ n $ 次操作对应为 $ 1 $ 个长度为 $ n $ 的 01 串。在这个串中连续的 $ x $ 个 $ 1 $ 可以贡献 $ x ^ 3 $ 的分数，这 $ x $ 个 $ 1 $ 不能被其他连续的 $ 1 $ 所包含（也就是极长的一串 $ 1 $）。\n\n现在给出 $ n $，以及每个操作的成功率，请你输出期望分数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4318](http://www.lydsy.com/JudgeOnline/problem.php?id=4318)\n\n### 题解\n设 $ f(i) $ 表示前 $ i $ 次操作后的期望得分，$ p(i) $ 表示第 $ i $ 次操作成功的概率。\n\n考虑连续 $ 1 $ 的长度 $ x $ 的变化，如果第 $ i $ 次成功，则 $ x_i = x_{i - 1} + 1 $，考虑其对得分 $ x ^ 3 $ 的影响。\n\n$$ (x + 1) ^ 3 - x ^ 3 = 3x ^ 2 + 3x + 1 $$\n\n根据期望的线性性，我们只需要求出 $ E_{x ^ 2} $ 和 $ E_x $，即可得到\n\n$$ E_{(x + 1) ^ 3 - x ^ 3} = 3E_{x ^ 2} + 3E_x + 1 $$\n\n乘上成功的概率，即为该次操作的期望分数增量（相对于第 $ i - 1 $ 次）。\n\n$$ f(i) = f(i - 1) + (3E_{x ^ 2}(i) + 3E_x(i) + 1) \\times p(i) $$\n\n考虑如何维护 $ E_{x ^ 2}(i) $ 与 $ E_x(i) $，仍旧是考虑期望的线性性，将式子展开。\n\n首先，显然\n\n$$ E_{x + 1} = E_x + 1 $$\n\n有 $ p(i) $ 的概率比上一次操作多 $ 1 $ 次，有 $ 1 - p(i) $ 的概率直接成为 $ 0 $，即\n\n$$ E_x(i) = (E_x(i - 1) + 1) \\times p(i) $$\n\n类似的，有\n\n$$ E_{(x + 1) ^ 2} = E_{x ^ 2} + 2E_{x} + 1 $$\n\n即\n\n$$ E_{x ^ 2}(i) = E_{x ^ 2}(i - 1) + 2E_{x}(i - 1) + 1 $$\n\n至此，$ E_{x ^ 2}(i) $、$ E_{x}(i) $、$ f(i) $ 均可在线性时间内递推得到。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n\nconst int MAXN = 100000;\n\nint n;\ndouble p[MAXN + 1], f[MAXN + 1];\ndouble ex1[MAXN + 1], ex2[MAXN + 1];\n\ninline void dp() {\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tex1[i] = (ex1[i - 1] + 1) * p[i];\n\t\tex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i];\n\t\tdouble t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i];\n\t\tf[i] = f[i - 1] + t;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n\n\tdp();\n\n\tprintf(\"%.1lf\\n\", floor(f[n] * 10 + 0.5) / 10);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4318","published":1,"updated":"2016-05-31T12:06:27.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sbb01e8ooxlhjtta6av"},{"title":"「BZOJ 4247」挂饰 - 背包 DP","date":"2016-07-11T15:22:00.000Z","_content":"\nJOI 君有 $ N $ 个装在手机上的挂饰，编号为 $ 1 \\to N $。 JOI君可以将其中的一些装在手机上。\n\n一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有 $ 1 $ 个。此外，每个挂件有一个安装时会获得的喜悦值，用一个整数（可以为负）来表示。\n\nJOI 君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4247](http://www.lydsy.com/JudgeOnline/problem.php?id=4247)\n\n### 题解\n允许背包容量为负，做一次背包，答案取背包容量为 $ -n $ 到 $ 1 $ 时结果的最大值。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic struct Array {\n\t\tint a[MAXN * 2 + 1];\n\t\tint &operator[](const int i) { return a[i + MAXN]; }\n\t} f[MAXN + 1];\n\n\tfor (int i = -n; i < 0; i++) f[0][i] = INT_MIN;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, v;\n\t\tscanf(\"%d %d\", &x, &v);\n\n\t\tconst int w = 1 - x;\n\n\t\tfor (int j = -n; j <= n; j++) {\n\t\t\tif (j - w >= -n && j - w <= n && f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v);\n\t\t\telse if (j - w > n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v);\n\t\t\telse f[i][j] = f[i - 1][j];\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = -n; i <= 1; i++) ans = std::max(ans, f[n][i]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4247.md","raw":"title: 「BZOJ 4247」挂饰 - 背包 DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - 背包 DP\npermalink: bzoj-4247\ndate: 2016-07-11 23:22:00\n---\n\nJOI 君有 $ N $ 个装在手机上的挂饰，编号为 $ 1 \\to N $。 JOI君可以将其中的一些装在手机上。\n\n一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有 $ 1 $ 个。此外，每个挂件有一个安装时会获得的喜悦值，用一个整数（可以为负）来表示。\n\nJOI 君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4247](http://www.lydsy.com/JudgeOnline/problem.php?id=4247)\n\n### 题解\n允许背包容量为负，做一次背包，答案取背包容量为 $ -n $ 到 $ 1 $ 时结果的最大值。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic struct Array {\n\t\tint a[MAXN * 2 + 1];\n\t\tint &operator[](const int i) { return a[i + MAXN]; }\n\t} f[MAXN + 1];\n\n\tfor (int i = -n; i < 0; i++) f[0][i] = INT_MIN;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, v;\n\t\tscanf(\"%d %d\", &x, &v);\n\n\t\tconst int w = 1 - x;\n\n\t\tfor (int j = -n; j <= n; j++) {\n\t\t\tif (j - w >= -n && j - w <= n && f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v);\n\t\t\telse if (j - w > n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v);\n\t\t\telse f[i][j] = f[i - 1][j];\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = -n; i <= 1; i++) ans = std::max(ans, f[n][i]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4247","published":1,"updated":"2016-10-24T23:34:05.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sbh01eeooxla294l35s"},{"title":"「BZOJ 4145」The Prices - 状压 DP","date":"2016-07-11T15:29:00.000Z","_content":"\n你要购买 $ m $ 种物品各一件，一共有 $ n $ 家商店，你到第 $ i $ 家商店的路费为 $ d(i) $，在第 $ i $ 家商店购买第 $ j $ 种物品的费用为 $ c(i)(j) $，求最小总费用。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4145](http://www.lydsy.com/JudgeOnline/problem.php?id=4145)\n\n### 题解\n将所有的物品压进一个二进制集合中，用 $ f(i, j) $ 表示已经尝试了前 $ i $ 个商店，已购买物品集合为 $ j $ 的最小总费用。\n\n使用类似背包的方式枚举每个物品转移即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int maxn = 100;\nconst int maxm = 16;\nconst int maxstatus = 1 << 16;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int c[maxn][maxm], d[maxn];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d[i]);\n\t\tfor (int j = 0; j < m; j++) scanf(\"%d\", &c[i][j]);\n\t}\n\n\tstatic int f[maxn][maxstatus];\n\tfor (int j = 0; j < (1 << m); j++) {\n\t\tf[0][j] = d[0];\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (j & (1 << k)) f[0][j] += c[0][k];\n\t\t}\n\t}\n\tf[0][0] = 0;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = f[i - 1][j] + d[i];\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (j & (1 << k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 << k)] + c[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", f[n - 1][(1 << m) - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4145.md","raw":"title: 「BZOJ 4145」The Prices - 状压 DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - 状压 DP\npermalink: bzoj-4145\ndate: 2016-07-11 23:29:00\n---\n\n你要购买 $ m $ 种物品各一件，一共有 $ n $ 家商店，你到第 $ i $ 家商店的路费为 $ d(i) $，在第 $ i $ 家商店购买第 $ j $ 种物品的费用为 $ c(i)(j) $，求最小总费用。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4145](http://www.lydsy.com/JudgeOnline/problem.php?id=4145)\n\n### 题解\n将所有的物品压进一个二进制集合中，用 $ f(i, j) $ 表示已经尝试了前 $ i $ 个商店，已购买物品集合为 $ j $ 的最小总费用。\n\n使用类似背包的方式枚举每个物品转移即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int maxn = 100;\nconst int maxm = 16;\nconst int maxstatus = 1 << 16;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int c[maxn][maxm], d[maxn];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d[i]);\n\t\tfor (int j = 0; j < m; j++) scanf(\"%d\", &c[i][j]);\n\t}\n\n\tstatic int f[maxn][maxstatus];\n\tfor (int j = 0; j < (1 << m); j++) {\n\t\tf[0][j] = d[0];\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (j & (1 << k)) f[0][j] += c[0][k];\n\t\t}\n\t}\n\tf[0][0] = 0;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = f[i - 1][j] + d[i];\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (j & (1 << k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 << k)] + c[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", f[n - 1][(1 << m) - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4145","published":1,"updated":"2016-10-24T23:33:52.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sbn01ejooxlsdjn57bi"},{"title":"「BZOJ 3940」Censoring - AC 自动机","date":"2016-09-13T23:52:00.000Z","_content":"\n给定一个串 $ S $ 和一些单词串，每一次在 $ S $ 中寻找第一次出现的单词串，并将其删除，求最终串。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3940](http://www.lydsy.com/JudgeOnline/problem.php?id=3940)\n\n### 题解\n对单词串建立 AC 自动机，用链表维护原串，匹配到单词串时从链表中删除。\n\n删去一个单词时，原单词的左右两边可能会连接形成一个新的单词，为了不漏掉这些新单词，必须在删掉一个单词后以在这个单词之前的状态继续匹配 —— 使用栈维护历史状态即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <list>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint length;\n\n\t\tNode(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, end - begin);\n\t\telse (*v)->isWord = true, (*v)->length = end - begin;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(std::list<char> &list) {\n\t\tNode *v = root;\n\t\tstd::stack<Node *> history;\n\t\tfor (std::list<char>::iterator it = list.begin(); it != list.end(); ) {\n\t\t\thistory.push(v);\n\t\t\t// while (v != root && !v->c[*it]) v = v->fail, assert(false);\n\t\t\tif (v->c[*it]) v = v->c[*it];\n\t\t\tif (!v->isWord && v->next) v = v->next;\n\t\t\tif (v->isWord) {\n\t\t\t\tfor (int i = 1; i < v->length; i++) it--;\n\t\t\t\tfor (int i = 0; i < v->length; i++) it = list.erase(it);\n\t\t\t\tfor (int i = 1; i < v->length; i++) history.pop();\n\t\t\t\tv = history.top();\n\t\t\t\thistory.pop();\n\t\t\t} else it++;\n\t\t}\n\t}\n} t;\n\nint main() {\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tstd::list<char> list;\n\tfor (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tt.exec(list);\n\n\tfor (std::list<char>::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR);\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3940.md","raw":"title: 「BZOJ 3940」Censoring - AC 自动机\ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - 字符串\n  - AC 自动机\n  - 链表\n  - 栈\npermalink: bzoj-3940\ndate: 2016-09-14 07:52:00\n---\n\n给定一个串 $ S $ 和一些单词串，每一次在 $ S $ 中寻找第一次出现的单词串，并将其删除，求最终串。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3940](http://www.lydsy.com/JudgeOnline/problem.php?id=3940)\n\n### 题解\n对单词串建立 AC 自动机，用链表维护原串，匹配到单词串时从链表中删除。\n\n删去一个单词时，原单词的左右两边可能会连接形成一个新的单词，为了不漏掉这些新单词，必须在删掉一个单词后以在这个单词之前的状态继续匹配 —— 使用栈维护历史状态即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <list>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint length;\n\n\t\tNode(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, end - begin);\n\t\telse (*v)->isWord = true, (*v)->length = end - begin;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(std::list<char> &list) {\n\t\tNode *v = root;\n\t\tstd::stack<Node *> history;\n\t\tfor (std::list<char>::iterator it = list.begin(); it != list.end(); ) {\n\t\t\thistory.push(v);\n\t\t\t// while (v != root && !v->c[*it]) v = v->fail, assert(false);\n\t\t\tif (v->c[*it]) v = v->c[*it];\n\t\t\tif (!v->isWord && v->next) v = v->next;\n\t\t\tif (v->isWord) {\n\t\t\t\tfor (int i = 1; i < v->length; i++) it--;\n\t\t\t\tfor (int i = 0; i < v->length; i++) it = list.erase(it);\n\t\t\t\tfor (int i = 1; i < v->length; i++) history.pop();\n\t\t\t\tv = history.top();\n\t\t\t\thistory.pop();\n\t\t\t} else it++;\n\t\t}\n\t}\n} t;\n\nint main() {\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tstd::list<char> list;\n\tfor (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tt.exec(list);\n\n\tfor (std::list<char>::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR);\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","slug":"bzoj-3940","published":1,"updated":"2016-09-13T23:47:40.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sbs01eoooxlp93dnb2z"},{"title":"「BZOJ 3894」文理分科 - 最大权闭合图","date":"2016-06-21T09:51:00.000Z","_content":"\n小 P 所在的班级要进行文理分科。他的班级可以用一个 $ n \\times m $ 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到：\n\n1. 如果第 $ i $ 行第 $ j $ 列的同学选择了文科，则他将获得 $ a[i][j] $ 的满意值，如果选择理科，将获得 $ b[i][j] $ 的满意值。\n2. 如果第 $ i $ 行第 $ j $ 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 $ A[i][j] $ 的满意值。\n3. 如果第 $ i $ 行第 $ j $ 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加 $ B[i][j] $ 的满意值。\n\n小 P 想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### 题解\n先考虑每个人都选择文科，然后考虑一个人改选理科带来的影响。\n\n建立最大权闭合图模型：为每个人建 $ 3 $ 个点，分别表示 TA 自己改选理科（权值为 $ b[i][j] - a[i][j] $）、TA 和 TA 相邻的人有任意一个选择理科（失去文科的收益加成）、TA 和 TA 相邻的人全部选择理科（获得理科的收益加成）。  \n对于每一个人，从**TA 和 TA 相邻所有人**的第一个点向 TA 的第二个点连边，从 TA 的第三个点向 TA 和 TA 相邻所有人的第一个点连边。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 3 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3];\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &A[i][j]), sum += A[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &B[i][j]);\n\t\n\tint x = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < 3; k++) id[i][j][k] = x++;\n\n\tconst int s = 0, t = n * m * 3 + 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n\t\t\telse addEdge(id[i][j][0], t, -x);\n\t\t\taddEdge(id[i][j][1], t, A[i][j]);\n\t\t\taddEdge(s, id[i][j][2], B[i][j]), sum += B[i][j];\n\n\t\t\taddEdge(id[i][j][0], id[i][j][1], INT_MAX);\n\t\t\taddEdge(id[i][j][2], id[i][j][0], INT_MAX);\n\n\t\t\tif (i != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m * 3 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3894.md","raw":"title: 「BZOJ 3894」文理分科 - 最大权闭合图\ncategories: OI\ntags: \n  - BZOJ\n  - 最大权闭合图\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: bzoj-3894\ndate: 2016-06-21 17:51:00\n---\n\n小 P 所在的班级要进行文理分科。他的班级可以用一个 $ n \\times m $ 的矩阵进行描述，每个格子代表一个同学的座位。每位同学必须从文科和理科中选择一科。同学们在选择科目的时候会获得一个满意值。满意值按如下的方式得到：\n\n1. 如果第 $ i $ 行第 $ j $ 列的同学选择了文科，则他将获得 $ a[i][j] $ 的满意值，如果选择理科，将获得 $ b[i][j] $ 的满意值。\n2. 如果第 $ i $ 行第 $ j $ 列的同学选择了文科，并且他相邻（两个格子相邻当且仅当它们拥有一条相同的边）的同学全部选择了文科，则他会更开心，所以会增加 $ A[i][j] $ 的满意值。\n3. 如果第 $ i $ 行第 $ j $ 列的同学选择了理科，并且他相邻的同学全部选择了理科，则增加 $ B[i][j] $ 的满意值。\n\n小 P 想知道，大家应该如何选择，才能使所有人的满意值之和最大。请告诉他这个最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### 题解\n先考虑每个人都选择文科，然后考虑一个人改选理科带来的影响。\n\n建立最大权闭合图模型：为每个人建 $ 3 $ 个点，分别表示 TA 自己改选理科（权值为 $ b[i][j] - a[i][j] $）、TA 和 TA 相邻的人有任意一个选择理科（失去文科的收益加成）、TA 和 TA 相邻的人全部选择理科（获得理科的收益加成）。  \n对于每一个人，从**TA 和 TA 相邻所有人**的第一个点向 TA 的第二个点连边，从 TA 的第三个点向 TA 和 TA 相邻所有人的第一个点连边。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 3 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3];\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &A[i][j]), sum += A[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &B[i][j]);\n\t\n\tint x = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < 3; k++) id[i][j][k] = x++;\n\n\tconst int s = 0, t = n * m * 3 + 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n\t\t\telse addEdge(id[i][j][0], t, -x);\n\t\t\taddEdge(id[i][j][1], t, A[i][j]);\n\t\t\taddEdge(s, id[i][j][2], B[i][j]), sum += B[i][j];\n\n\t\t\taddEdge(id[i][j][0], id[i][j][1], INT_MAX);\n\t\t\taddEdge(id[i][j][2], id[i][j][0], INT_MAX);\n\n\t\t\tif (i != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m * 3 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3894","published":1,"updated":"2016-06-22T08:25:43.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sc201eyooxlr7xobk40"},{"title":"「BZOJ 3796」Mushroom - 后缀数组 + AC 自动机","date":"2016-09-29T23:41:00.000Z","_content":"\n给三个字符串 $ s_1, s_2, s_3 $，求一个长度最大的 $ w $，满足：\n\n1. $ w $ 是 $ s_1 $ 的子串；\n2. $ w $ 是 $ s_2 $ 的子串；\n3. $ s_3 $ 不是 $ w $ 的子串；\n\n<!-- more -->\n\n### 链接\n[BZOJ 3796](http://www.lydsy.com/JudgeOnline/problem.php?id=3796)\n\n### 题解\n对 $ s_1 $ 和 $ s_2 $ 建立后缀数组，枚举 $ s_1 $ 的每个后缀，该后缀与在后缀数组离它最近的 $ s_2 $ 的某个后缀的最长公共前缀长度为在满足前两个条件下的最大答案。\n\n对于条件 3，对 $ s_3 $ 建立 AC 自动机，求出 $ s_3 $ 在 $ s_1 $ 中的每个匹配位置，设每个 $ i $ 位置的右边第一个匹配 $ s_3 $ 的位置为 $ r(i) $，则在满足条件三的情况下，第 $ i $ 个后缀的最大答案为 $ r(i) - i + \\mathrm{len}(s_3) - 1 $。\n\n将两个答案取较小值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\nconst int CHARSET_SIZE = 12;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail;\n\t\tbool isWord;\n\t\tint depth;\n\n\t\tNode(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p - BASE_CHAR];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root;\n\t\troot->depth = 0;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc->depth = v->depth + 1;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, bool *match) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\tif (v->isWord) match[p - begin - v->depth + 1] = true;\n\t\t}\n\t}\n} t;\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\ttemplate <typename T>\n\tvoid build(const T *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"build: %s\\n\", s);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) < n) st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\telse st[i][j] = st[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tint rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\telse {\n\t\t\tconst int t = log[r - l];\n\t\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t\t}\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint main() {\n\tstatic char buf[MAXN];\n\tscanf(\"%s\", buf);\n\tconst int n1 = strlen(buf);\n\tbuf[n1] = '$';\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n2 = strlen(buf + n1 + 1);\n\tsa1.build(buf, n1 + 1 + n2);\n\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n3 = strlen(buf + n1 + 1);\n\t// sa2.build(buf, n1 + 1 + n3);\n\n\tt.insert(buf + n1 + 1, buf + n1 + 1 + n3);\n\tt.build();\n\n\tstatic bool match[MAXN];\n\tt.exec(buf, buf + n1, match);\n\n\tstatic int nextMatch[MAXN];\n\tfor (int i = n1 - 1, x = INT_MAX; i >= 0; i--) {\n\t\tif (match[i]) x = i;\n\t\tnextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1;\n\t}\n\n#ifdef DBG\n\tputs(\"KMP:\");\n\tbuf[n1] = '\\0';\n\tfor (int i = 0; i < n1; i++) printf(\"%d %s\\n\", nextMatch[i], &buf[i]);\n#endif\n\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 1, x = -1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) l[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\tfor (int i = n1 + n2 + 1 - 1, x = -1; i >= 1; i--) {\n\t\tif (sa1.sa[i] < n1) r[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\n#ifdef DBG\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) printf(\"l[%d] = %d\\n\", i, l[i]);\n\t\tif (sa1.sa[i] < n1) printf(\"r[%d] = %d\\n\", i, r[i]);\n\t}\n#endif\n\n\tint ans = 0;\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] > n1) continue;\n\t\tint x;\n\t\tif (l[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (r[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3796.md","raw":"title: 「BZOJ 3796」Mushroom - 后缀数组 + AC 自动机\ncategories: OI\ntags: \n  - BZOJ\n  - 字符串\n  - 后缀数组\n  - AC 自动机\npermalink: bzoj-3796\ndate: 2016-09-30 07:41:00\n---\n\n给三个字符串 $ s_1, s_2, s_3 $，求一个长度最大的 $ w $，满足：\n\n1. $ w $ 是 $ s_1 $ 的子串；\n2. $ w $ 是 $ s_2 $ 的子串；\n3. $ s_3 $ 不是 $ w $ 的子串；\n\n<!-- more -->\n\n### 链接\n[BZOJ 3796](http://www.lydsy.com/JudgeOnline/problem.php?id=3796)\n\n### 题解\n对 $ s_1 $ 和 $ s_2 $ 建立后缀数组，枚举 $ s_1 $ 的每个后缀，该后缀与在后缀数组离它最近的 $ s_2 $ 的某个后缀的最长公共前缀长度为在满足前两个条件下的最大答案。\n\n对于条件 3，对 $ s_3 $ 建立 AC 自动机，求出 $ s_3 $ 在 $ s_1 $ 中的每个匹配位置，设每个 $ i $ 位置的右边第一个匹配 $ s_3 $ 的位置为 $ r(i) $，则在满足条件三的情况下，第 $ i $ 个后缀的最大答案为 $ r(i) - i + \\mathrm{len}(s_3) - 1 $。\n\n将两个答案取较小值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\nconst int CHARSET_SIZE = 12;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail;\n\t\tbool isWord;\n\t\tint depth;\n\n\t\tNode(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p - BASE_CHAR];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root;\n\t\troot->depth = 0;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc->depth = v->depth + 1;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, bool *match) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\tif (v->isWord) match[p - begin - v->depth + 1] = true;\n\t\t}\n\t}\n} t;\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\ttemplate <typename T>\n\tvoid build(const T *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"build: %s\\n\", s);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) < n) st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\telse st[i][j] = st[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tint rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\telse {\n\t\t\tconst int t = log[r - l];\n\t\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t\t}\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint main() {\n\tstatic char buf[MAXN];\n\tscanf(\"%s\", buf);\n\tconst int n1 = strlen(buf);\n\tbuf[n1] = '$';\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n2 = strlen(buf + n1 + 1);\n\tsa1.build(buf, n1 + 1 + n2);\n\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n3 = strlen(buf + n1 + 1);\n\t// sa2.build(buf, n1 + 1 + n3);\n\n\tt.insert(buf + n1 + 1, buf + n1 + 1 + n3);\n\tt.build();\n\n\tstatic bool match[MAXN];\n\tt.exec(buf, buf + n1, match);\n\n\tstatic int nextMatch[MAXN];\n\tfor (int i = n1 - 1, x = INT_MAX; i >= 0; i--) {\n\t\tif (match[i]) x = i;\n\t\tnextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1;\n\t}\n\n#ifdef DBG\n\tputs(\"KMP:\");\n\tbuf[n1] = '\\0';\n\tfor (int i = 0; i < n1; i++) printf(\"%d %s\\n\", nextMatch[i], &buf[i]);\n#endif\n\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 1, x = -1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) l[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\tfor (int i = n1 + n2 + 1 - 1, x = -1; i >= 1; i--) {\n\t\tif (sa1.sa[i] < n1) r[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\n#ifdef DBG\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) printf(\"l[%d] = %d\\n\", i, l[i]);\n\t\tif (sa1.sa[i] < n1) printf(\"r[%d] = %d\\n\", i, r[i]);\n\t}\n#endif\n\n\tint ans = 0;\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] > n1) continue;\n\t\tint x;\n\t\tif (l[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (r[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"bzoj-3796","published":1,"updated":"2016-09-29T23:48:43.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sc901f5ooxlt4ls5piq"},{"title":"「BZOJ 3697」采药人的路径 - 点分治","date":"2016-06-15T02:26:00.000Z","_content":"\n采药人的药田是一个树状结构，每条路径上都种植着同种药材。\n\n采药人每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。\n\n采药人每天都要进行采药活动。他走的一定是两种药材数目相等的路径。他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是两种药材数目相等的。他想知道他一共可以选择多少种不同的路径。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3697](http://www.lydsy.com/JudgeOnline/problem.php?id=3697)\n\n### 题解\n点分治，考虑经过根的路径中合法的路径数量。\n\n将边权为 $ 0 $ 改为 $ -1 $，对树遍历时记录路径上的前缀和。\n\n对根的所有子树做 DFS 遍历，设 $ f(i,\\ 0) $ 表示当前子树前缀和为 $ i $ **且 $ i $ 在路径上仅出现过一次**的路径数，$ f(i,\\ 1) $ 表示当前子树前缀和为 $ i $ **且 $ i $ 在路径上出现过至少两次**的路径数。\n\n如果一个前缀和 $ i $ 在一棵子树内出现过两次，那么在根的另一棵子树选一条前缀和为 $ -i $ 的路径与其相接，即可组成一条合法的路径 —— 休息站可以被选择在前一条路径上另一个前缀和为 $ i $ 的点上。\n\n对树进行 DFS 遍历时，记录 $ c(i) $ 表示当前路径前缀和为 $ i $ 的节点数量，根据情况将当前节点累加在 $ f(i,\\ 0) $ 或 $ f(i,\\ 1 ) $ 中。\n\n记录 $ g(i,\\ 0) $、$ g(i,\\ 1) $ 为之前的所有子树中对应的路径数量，每次更新答案，统计不以根节点为休息站的路径数量\n\n$$ \\sum\\limits_i f(i,\\ 0) g(-i,\\ 1) + f(i,\\ 1) g(-i,\\ 0) + f(i,\\ 1) g(-i,\\ 1) $$\n\n令 $ g(0,\\ 0) $ 的初始值为 $ 1 $，表示根节点单独组成一条路径，统计以根节点为休息站的的路径数量\n\n$$ (g(0,\\ 0) - 1) \\times f(0,\\ 0) $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100003;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, max, dist;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ntemplate <typename T, int L, int R>\nstruct Array {\n\tT a[R - L + 1];\n\n\tT &operator[](const int pos) { return a[pos - L]; }\n\n\tconst T &operator[](const int pos) const { return a[pos - L]; }\n};\n\nArray<long long [2], -(MAXN - 1), MAXN - 1> f, g;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline void dfs(Node *start, const int dist, int &max) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->dist = dist;\n\tstart->visited = false;\n\n\tstatic int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tf[v->dist][!cnt[v->dist] ? 0 : 1]++;\n\t\t\tcnt[v->dist]++;\n\n\t\t\tmax = std::max(max, v->dist);\n\t\t\tmax = std::max(max, abs(v->dist));\n\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tcnt[v->dist]--;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\n/*\ninline void print(const int max) {\n\tfor (int i = -max; i <= max; i++) {\n\t\tprintf(\"f[%d][0] = %lld, f[%d][1] = %lld\\n\", i, f[i][0], i, f[i][1]);\n\t\tprintf(\"g[%d][0] = %lld, g[%d][1] = %lld\\n\", i, g[i][0], i, g[i][1]);\n\t}\n\tputchar('\\n');\n}\n*/\n\ninline long long calc(Node *root) {\n\tlong long res = 0;\n\tint max = 0;\n\tg[0][0] = 1;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tint curr = 0;\n\t\tdfs(e->t, e->w, curr);\n\t\t// print(max);\n\n\t\tres += (g[0][0] - 1) * f[0][0];\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\t// printf(\"res += %lld\\n\", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]));\n\t\t\tres += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]);\n\t\t}\n\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\tg[i][0] += f[i][0];\n\t\t\tg[i][1] += f[i][1];\n\t\t\tf[i][0] = f[i][1] = 0;\n\t\t}\n\n\t\tmax = std::max(max, curr);\n\t}\n\n\tfor (int i = -max; i <= max; i++) {\n\t\tg[i][0] = g[i][1] = 0;\n\t}\n\n\t// printf(\"calc(%ld) = %lld\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline long long solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\t\tans += calc(root);\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\tif (w == 0) w = -1;\n\t\taddEdge(u, v, w);\n\t}\n\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\t// printf(\"counter: %lld\\n\", counter);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3697.md","raw":"title: 「BZOJ 3697」采药人的路径 - 点分治\ncategories: OI\ntags: \n  - BZOJ\n  - 点分治\n  - 数据结构\npermalink: bzoj-3697\ndate: 2016-06-15 10:26:00\n---\n\n采药人的药田是一个树状结构，每条路径上都种植着同种药材。\n\n采药人每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。\n\n采药人每天都要进行采药活动。他走的一定是两种药材数目相等的路径。他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是两种药材数目相等的。他想知道他一共可以选择多少种不同的路径。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3697](http://www.lydsy.com/JudgeOnline/problem.php?id=3697)\n\n### 题解\n点分治，考虑经过根的路径中合法的路径数量。\n\n将边权为 $ 0 $ 改为 $ -1 $，对树遍历时记录路径上的前缀和。\n\n对根的所有子树做 DFS 遍历，设 $ f(i,\\ 0) $ 表示当前子树前缀和为 $ i $ **且 $ i $ 在路径上仅出现过一次**的路径数，$ f(i,\\ 1) $ 表示当前子树前缀和为 $ i $ **且 $ i $ 在路径上出现过至少两次**的路径数。\n\n如果一个前缀和 $ i $ 在一棵子树内出现过两次，那么在根的另一棵子树选一条前缀和为 $ -i $ 的路径与其相接，即可组成一条合法的路径 —— 休息站可以被选择在前一条路径上另一个前缀和为 $ i $ 的点上。\n\n对树进行 DFS 遍历时，记录 $ c(i) $ 表示当前路径前缀和为 $ i $ 的节点数量，根据情况将当前节点累加在 $ f(i,\\ 0) $ 或 $ f(i,\\ 1 ) $ 中。\n\n记录 $ g(i,\\ 0) $、$ g(i,\\ 1) $ 为之前的所有子树中对应的路径数量，每次更新答案，统计不以根节点为休息站的路径数量\n\n$$ \\sum\\limits_i f(i,\\ 0) g(-i,\\ 1) + f(i,\\ 1) g(-i,\\ 0) + f(i,\\ 1) g(-i,\\ 1) $$\n\n令 $ g(0,\\ 0) $ 的初始值为 $ 1 $，表示根节点单独组成一条路径，统计以根节点为休息站的的路径数量\n\n$$ (g(0,\\ 0) - 1) \\times f(0,\\ 0) $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100003;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, max, dist;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ntemplate <typename T, int L, int R>\nstruct Array {\n\tT a[R - L + 1];\n\n\tT &operator[](const int pos) { return a[pos - L]; }\n\n\tconst T &operator[](const int pos) const { return a[pos - L]; }\n};\n\nArray<long long [2], -(MAXN - 1), MAXN - 1> f, g;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline void dfs(Node *start, const int dist, int &max) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->dist = dist;\n\tstart->visited = false;\n\n\tstatic int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tf[v->dist][!cnt[v->dist] ? 0 : 1]++;\n\t\t\tcnt[v->dist]++;\n\n\t\t\tmax = std::max(max, v->dist);\n\t\t\tmax = std::max(max, abs(v->dist));\n\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tcnt[v->dist]--;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\n/*\ninline void print(const int max) {\n\tfor (int i = -max; i <= max; i++) {\n\t\tprintf(\"f[%d][0] = %lld, f[%d][1] = %lld\\n\", i, f[i][0], i, f[i][1]);\n\t\tprintf(\"g[%d][0] = %lld, g[%d][1] = %lld\\n\", i, g[i][0], i, g[i][1]);\n\t}\n\tputchar('\\n');\n}\n*/\n\ninline long long calc(Node *root) {\n\tlong long res = 0;\n\tint max = 0;\n\tg[0][0] = 1;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tint curr = 0;\n\t\tdfs(e->t, e->w, curr);\n\t\t// print(max);\n\n\t\tres += (g[0][0] - 1) * f[0][0];\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\t// printf(\"res += %lld\\n\", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]));\n\t\t\tres += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]);\n\t\t}\n\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\tg[i][0] += f[i][0];\n\t\t\tg[i][1] += f[i][1];\n\t\t\tf[i][0] = f[i][1] = 0;\n\t\t}\n\n\t\tmax = std::max(max, curr);\n\t}\n\n\tfor (int i = -max; i <= max; i++) {\n\t\tg[i][0] = g[i][1] = 0;\n\t}\n\n\t// printf(\"calc(%ld) = %lld\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline long long solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\t\tans += calc(root);\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\tif (w == 0) w = -1;\n\t\taddEdge(u, v, w);\n\t}\n\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\t// printf(\"counter: %lld\\n\", counter);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3697","published":1,"updated":"2016-09-25T13:05:40.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9scf01fbooxllohwmidy"},{"title":"「BZOJ 3511」土地划分 - 最小割","date":"2016-04-06T14:33:05.000Z","_content":"\n给定一张 $ n $ 个点 $ m $ 条边的无向连通图，初始时 $ 1 $ 号点属于集合 $ A $，$ n $ 号点属于集合 $ B $。现在要将其他点划分进两个集合，并使得评分最高，评分方式如下：\n\n1. 对于点 $ i $，划给 $ A $ 集合得 $ VA_i $ 分，划给 $ B $ 集合得 $ VB_i $ 分；\n2. 对于一条边 $ i $，若它连接两个 $ A $ 集合点，则得 $ EA_i $ 分，若它连接两个 $ B $ 集合点，则得 $ EB_i $ 分，否则将扣除 $ EC_i $ 分。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### 题解\n建立最小割模型，使 $ A $ 集合的点与 $ S $ 联通，$ B $ 集合的点与 $ T $ 联通。\n\n对于每个点 $ u $，连边 $ (S, u) = VA_i $，割掉这条边表示它不被放在 $ A $ 集合中；连边 $ (u, T) = VB_i $，割掉这条边表示它不被放在 $ B $ 集合中。\n\n对于已经确定的点 $ 1 $ 和点 $ n $，连两条容量为正无穷的边 $ (S, 1) $ 和 $ (n, T) $，这两条边都不会被割掉。\n\n对于原图中的每条边，将其转化为容量为 $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $ 的双向边，并对于两个端点，连接 $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $。\n\n如果两个端点都在 $ A $ 集合中，那么两条容量为 $ EB_i $ 的边会被割掉，如果两个端点都在 $ B $ 集合中，那么两条容量为 $ EA_i $ 的边会被割掉，否则会割掉一条容量为 $ EA_i $，一条容量为 $ EB_i $ 的边，并且中间的边也会被割掉。\n\n求出最小割即为损失，$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ 减去损失即为答案。\n\n输入的数字可能有奇数，可以把所有数字乘以二再进行处理。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3511.md","raw":"title: 「BZOJ 3511」土地划分 - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - 安徽集训\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: bzoj-3511\ndate: 2016-04-06 22:33:05\n---\n\n给定一张 $ n $ 个点 $ m $ 条边的无向连通图，初始时 $ 1 $ 号点属于集合 $ A $，$ n $ 号点属于集合 $ B $。现在要将其他点划分进两个集合，并使得评分最高，评分方式如下：\n\n1. 对于点 $ i $，划给 $ A $ 集合得 $ VA_i $ 分，划给 $ B $ 集合得 $ VB_i $ 分；\n2. 对于一条边 $ i $，若它连接两个 $ A $ 集合点，则得 $ EA_i $ 分，若它连接两个 $ B $ 集合点，则得 $ EB_i $ 分，否则将扣除 $ EC_i $ 分。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### 题解\n建立最小割模型，使 $ A $ 集合的点与 $ S $ 联通，$ B $ 集合的点与 $ T $ 联通。\n\n对于每个点 $ u $，连边 $ (S, u) = VA_i $，割掉这条边表示它不被放在 $ A $ 集合中；连边 $ (u, T) = VB_i $，割掉这条边表示它不被放在 $ B $ 集合中。\n\n对于已经确定的点 $ 1 $ 和点 $ n $，连两条容量为正无穷的边 $ (S, 1) $ 和 $ (n, T) $，这两条边都不会被割掉。\n\n对于原图中的每条边，将其转化为容量为 $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $ 的双向边，并对于两个端点，连接 $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $。\n\n如果两个端点都在 $ A $ 集合中，那么两条容量为 $ EB_i $ 的边会被割掉，如果两个端点都在 $ B $ 集合中，那么两条容量为 $ EA_i $ 的边会被割掉，否则会割掉一条容量为 $ EA_i $，一条容量为 $ EB_i $ 的边，并且中间的边也会被割掉。\n\n求出最小割即为损失，$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ 减去损失即为答案。\n\n输入的数字可能有奇数，可以把所有数字乘以二再进行处理。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3511","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9scl01fgooxltchcuriw"},{"title":"「BZOJ 3438」小 M 的作物 - 最大权闭合图","date":"2016-06-21T07:18:00.000Z","_content":"\n小 M 有耕地 $ A $ 和 $ B $，有 $ n $ 中作物的种子，第i种作物种植在 $ A $ 中种植可以获得 $ a_i $ 的收益，在 $ B $ 中种植可以获得 $ b_i $ 的收益。  \n共有 $ m $ 种作物组合，第 $ i $ 个组合中的作物共同种在 $ A $ 中可以获得 $ c_{1_i} $的额外收益，共同总在 $ B $ 中可以获得 $ c_{2_i} $ 的额外收益。  \n求最大收益。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3438](http://www.lydsy.com/JudgeOnline/problem.php?id=3438)\n\n### 题解\n首先考虑将所有作物种植在 $ A $ 中，收益为 $ \\sum\\limits_{i = 1} ^ n a_i + \\sum\\limits_{i = 1} ^ m c_{1_i} $。\n\n考虑选择一些作物改为种在 $ B $ 中，任意一个作物种在 $ B $ 中后，包含该作物的组合 $ i $ 的 $ c_{1_i} $ 将失去。如果一个组合中**所有**作物都种在 $ B $ 中，则该组合 $ i $ 的 $ c_{2_i} $ 将被获得。\n\n建立最大权闭合图模型。每个作物的点权为 $ B_i - A_i $，每个组合拆为两个点，一个点表示损失掉的 $ c_{1_i} $，另一个点表示得到的 $ c_{2_i} $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"[%d, %d] = %d\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\n\tconst int s = 0, t = n + m * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w = b[i - 1] - a[i - 1];\n\t\tif (w > 0) addEdge(s, i, w), sum += w;\n\t\telse addEdge(i, t, -w);\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint k, c1, c2;\n\t\tscanf(\"%d %d %d\", &k, &c1, &c2);\n\n\t\taddEdge(i, t, c1);\n\t\taddEdge(s, i + m, c2);\n\n\t\tsum += c1 + c2;\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(x, i, INT_MAX);\n\t\t\taddEdge(i + m, x, INT_MAX);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3438.md","raw":"title: 「BZOJ 3438」小 M 的作物 - 最大权闭合图\ncategories: OI\ntags: \n  - BZOJ\n  - 最大权闭合图\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: bzoj-3438\ndate: 2016-06-21 15:18:00\n---\n\n小 M 有耕地 $ A $ 和 $ B $，有 $ n $ 中作物的种子，第i种作物种植在 $ A $ 中种植可以获得 $ a_i $ 的收益，在 $ B $ 中种植可以获得 $ b_i $ 的收益。  \n共有 $ m $ 种作物组合，第 $ i $ 个组合中的作物共同种在 $ A $ 中可以获得 $ c_{1_i} $的额外收益，共同总在 $ B $ 中可以获得 $ c_{2_i} $ 的额外收益。  \n求最大收益。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3438](http://www.lydsy.com/JudgeOnline/problem.php?id=3438)\n\n### 题解\n首先考虑将所有作物种植在 $ A $ 中，收益为 $ \\sum\\limits_{i = 1} ^ n a_i + \\sum\\limits_{i = 1} ^ m c_{1_i} $。\n\n考虑选择一些作物改为种在 $ B $ 中，任意一个作物种在 $ B $ 中后，包含该作物的组合 $ i $ 的 $ c_{1_i} $ 将失去。如果一个组合中**所有**作物都种在 $ B $ 中，则该组合 $ i $ 的 $ c_{2_i} $ 将被获得。\n\n建立最大权闭合图模型。每个作物的点权为 $ B_i - A_i $，每个组合拆为两个点，一个点表示损失掉的 $ c_{1_i} $，另一个点表示得到的 $ c_{2_i} $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"[%d, %d] = %d\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\n\tconst int s = 0, t = n + m * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w = b[i - 1] - a[i - 1];\n\t\tif (w > 0) addEdge(s, i, w), sum += w;\n\t\telse addEdge(i, t, -w);\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint k, c1, c2;\n\t\tscanf(\"%d %d %d\", &k, &c1, &c2);\n\n\t\taddEdge(i, t, c1);\n\t\taddEdge(s, i + m, c2);\n\n\t\tsum += c1 + c2;\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(x, i, INT_MAX);\n\t\t\taddEdge(i + m, x, INT_MAX);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3438","published":1,"updated":"2016-06-21T07:18:27.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9scs01fnooxlnm5ke1v2"},{"title":"「BZOJ 3365」Distance Statistics - 点分治","date":"2016-06-16T10:09:00.000Z","_content":"\n约翰提供一个整数 $ K $（$ 1 \\leq K \\leq 10 ^ 9 $），希望你输出有多少对农场之间的距离是不超过 $ K $ 的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3365](http://www.lydsy.com/JudgeOnline/problem.php?id=3365)\n\n### 题解\n和 [BZOJ 1468](bzoj-1468) 一样。\n\n### 代码\n```c++\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// printf(\"start->size - cnt = %d\\n\", start->size - cnt);\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tchar s[2];\n\t\tscanf(\"%d %d %d %s\", &u, &v, &w, s), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3365.md","raw":"title: 「BZOJ 3365」Distance Statistics - 点分治\ncategories: OI\ntags: \n  - BZOJ\n  - 点分治\n  - 数据结构\npermalink: bzoj-3365\ndate: 2016-06-16 18:09:00\n---\n\n约翰提供一个整数 $ K $（$ 1 \\leq K \\leq 10 ^ 9 $），希望你输出有多少对农场之间的距离是不超过 $ K $ 的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3365](http://www.lydsy.com/JudgeOnline/problem.php?id=3365)\n\n### 题解\n和 [BZOJ 1468](bzoj-1468) 一样。\n\n### 代码\n```c++\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// printf(\"start->size - cnt = %d\\n\", start->size - cnt);\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tchar s[2];\n\t\tscanf(\"%d %d %d %s\", &u, &v, &w, s), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3365","published":1,"updated":"2016-06-16T10:09:41.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sd001fuooxld0xz6w8z"},{"title":"「BZOJ 3289」Mato 的文件管理 - 莫队","date":"2016-12-30T02:45:00.000Z","_content":"\n给一个长度为 $ n $ 的序列，每次求一个区间 $ [l, r] $ 的逆序对数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3289](http://www.lydsy.com/JudgeOnline/problem.php?id=3289)\n\n### 题解\n对序列离散化，应用莫队算法，用树状数组维护当前区间的数，每次左边或右边加入一个数时在树状数组中查询小于或大于该数的数量来统计答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\n\nint blockSize;\n\nstruct Query {\n\tint l, r, a, b;\n\tstd::pair<int, int> *ans;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) return r < other.r;\n\t\telse return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\nint n, m, a[MAXN + 1];\n\nstruct BIT {\n\tint a[MAXN + MAXM * 2 + 1], n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t}\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n} bit1, bit2;\n\ninline std::pair<int, int> calc(int a, int b) {\n\treturn std::make_pair(bit1.query(a, b), bit2.query(a, b));\n}\n\nint cnt[MAXN + MAXM + 2 + 1];\ninline void extend(int l, int r, bool left, int d) {\n\tint pos = left ? l : r;\n\tbit1.update(a[pos], d);\n\tif (d == 1) {\n\t\tif (++cnt[a[pos]] == 1) bit2.update(a[pos], 1);\n\t} else {\n\t\tif (--cnt[a[pos]] == 0) bit2.update(a[pos], -1);\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (r < Q[i].r) extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) extend(l++, r, true, -1);\n\n\t\t*Q[i].ans = calc(Q[i].a, Q[i].b);\n\t}\n}\n\ninline void prepare() {\n\tstatic int set[MAXN + MAXM * 2 + 1];\n\tstd::copy(a + 1, a + n + 1, set + 1);\n\tfor (int i = 1; i <= m; i++) set[n + i] = Q[i].a;\n\tfor (int i = 1; i <= m; i++) set[n + m + i] = Q[i].b;\n\n\tstd::sort(set + 1, set + n + m * 2 + 1);\n\tint *end = std::unique(set + 1, set + n + m * 2 + 1);\n\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set;\n\n\tint cnt = end - (set + 1);\n\tbit1.init(cnt);\n\tbit2.init(cnt);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic std::pair<int, int> ans[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d %d %d\", &Q[i].l, &Q[i].r, &Q[i].a, &Q[i].b);\n\t\tQ[i].ans = &ans[i];\n\t}\n\n\tprepare();\n\n\tblockSize = floor(sqrt(n) + 1);\n\tstd::sort(Q + 1, Q + m + 1);\n\tsolve();\n\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3289.md","raw":"title: 「BZOJ 3289」Mato 的文件管理 - 莫队\ncategories: OI\ntags: \n  - BZOJ\n  - 莫队\n  - 数据结构\npermalink: bzoj-3289\ndate: 2016-12-30 10:45:00\n---\n\n给一个长度为 $ n $ 的序列，每次求一个区间 $ [l, r] $ 的逆序对数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3289](http://www.lydsy.com/JudgeOnline/problem.php?id=3289)\n\n### 题解\n对序列离散化，应用莫队算法，用树状数组维护当前区间的数，每次左边或右边加入一个数时在树状数组中查询小于或大于该数的数量来统计答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\n\nint blockSize;\n\nstruct Query {\n\tint l, r, a, b;\n\tstd::pair<int, int> *ans;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) return r < other.r;\n\t\telse return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\nint n, m, a[MAXN + 1];\n\nstruct BIT {\n\tint a[MAXN + MAXM * 2 + 1], n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t}\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n} bit1, bit2;\n\ninline std::pair<int, int> calc(int a, int b) {\n\treturn std::make_pair(bit1.query(a, b), bit2.query(a, b));\n}\n\nint cnt[MAXN + MAXM + 2 + 1];\ninline void extend(int l, int r, bool left, int d) {\n\tint pos = left ? l : r;\n\tbit1.update(a[pos], d);\n\tif (d == 1) {\n\t\tif (++cnt[a[pos]] == 1) bit2.update(a[pos], 1);\n\t} else {\n\t\tif (--cnt[a[pos]] == 0) bit2.update(a[pos], -1);\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (r < Q[i].r) extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) extend(l++, r, true, -1);\n\n\t\t*Q[i].ans = calc(Q[i].a, Q[i].b);\n\t}\n}\n\ninline void prepare() {\n\tstatic int set[MAXN + MAXM * 2 + 1];\n\tstd::copy(a + 1, a + n + 1, set + 1);\n\tfor (int i = 1; i <= m; i++) set[n + i] = Q[i].a;\n\tfor (int i = 1; i <= m; i++) set[n + m + i] = Q[i].b;\n\n\tstd::sort(set + 1, set + n + m * 2 + 1);\n\tint *end = std::unique(set + 1, set + n + m * 2 + 1);\n\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set;\n\n\tint cnt = end - (set + 1);\n\tbit1.init(cnt);\n\tbit2.init(cnt);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic std::pair<int, int> ans[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d %d %d\", &Q[i].l, &Q[i].r, &Q[i].a, &Q[i].b);\n\t\tQ[i].ans = &ans[i];\n\t}\n\n\tprepare();\n\n\tblockSize = floor(sqrt(n) + 1);\n\tstd::sort(Q + 1, Q + m + 1);\n\tsolve();\n\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n```","slug":"bzoj-3289","published":1,"updated":"2016-12-30T02:45:35.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sd701fzooxlgv99imzv"},{"title":"「BZOJ 3280」小 R 的烦恼 - 费用流","date":"2016-09-03T23:21:00.000Z","_content":"\n程设老师最近要进行一项邪恶的实验，这个实验一共持续 $ n $ 天，第 $ i $ 天需要 $ a_i $ 个研究生来给他搬砖。研究生毕竟也是人，所以雇佣研究生是需要钱的，机智的程设老师已经联系好了 $ m $ 所大学，第 $ j $ 所大学共有 $ l_j $ 个研究生，同时雇佣这所大学的一个研究生需要 $ p_j $ 元钱。\n\n一天下来给他搬砖的所有研究生都会进入濒死状态。濒死状态的研究生，毫无疑问，就不能再进行工作了。但是机智的老师早早联系好了 $ k $ 家医院，第 $ i $ 家医院医治一个濒死的研究生需要 $ d_i $ 天，并且需要 $ q_i $ 元钱。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3280](http://www.lydsy.com/JudgeOnline/problem.php?id=3280)\n\n### 题解\n建立费用流模型。\n\n为每一天建两个点，一个表示这一天开始时可用的研究生，另一个表示这一天结束时濒死的研究生。两点之间连一条边，流量上下界均为这一天所需的研究生数量 $ a_i $，费用为零。\n\n显然，第一天雇佣所有的研究生，每一天未使用的研究生留到下一天，和在每一天分别雇佣研究生是等价的。从源点向第一天可用研究生的点连 $ m $ 条边，容量为 $ l_i $，费用为一个 $ p_i $。\n\n从第 $ i $ 天表示濒死的研究生的点向第 $ i + d_i $ 天表示可用研究生的点连一条边，表示医治一些研究生，容量为正无穷，费用为 $ q_i $。\n\n对上下界的处理：从源点到表示每天濒死研究生的点连一条边，容量为 $ a_i $，从表示每天可用研究生的点向汇点连一条边，容量为 $ a_i $，最终流量为 $ \\sum a_i $ 则有解。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXK = 50;\n\nstruct Node {\n\tstruct Edge *e, *in;\n\tbool q;\n\tint d, f;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].q = false;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].f = 0;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t}\n}\n\ninline void clear(const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t\tconst int s = 0, t = n * 2 + 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i, t, x, 0);\n\t\t\taddEdge(s, i + n, x, 0);\n\t\t\tsum += x;\n\n\t\t\tif (i != n) addEdge(i, i + 1, INT_MAX, 0);\n\t\t}\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\taddEdge(s, 1, a, b);\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b), a++;\n\t\t\tfor (int j = 1; j <= n - a; j++) addEdge(j + n, j + a, INT_MAX, b);\n\t\t}\n\n\t\tint flow, cost;\n\t\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\t\tprintf(\"Case %d: \", i);\n\t\tif (flow == sum) printf(\"%d\\n\", cost);\n\t\telse puts(\"impossible\");\n\n\t\tclear(n * 2 + 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3280.md","raw":"title: 「BZOJ 3280」小 R 的烦恼 - 费用流\ncategories: OI\ntags: \n  - BZOJ\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\npermalink: bzoj-3280\ndate: 2016-09-04 07:21:00\n---\n\n程设老师最近要进行一项邪恶的实验，这个实验一共持续 $ n $ 天，第 $ i $ 天需要 $ a_i $ 个研究生来给他搬砖。研究生毕竟也是人，所以雇佣研究生是需要钱的，机智的程设老师已经联系好了 $ m $ 所大学，第 $ j $ 所大学共有 $ l_j $ 个研究生，同时雇佣这所大学的一个研究生需要 $ p_j $ 元钱。\n\n一天下来给他搬砖的所有研究生都会进入濒死状态。濒死状态的研究生，毫无疑问，就不能再进行工作了。但是机智的老师早早联系好了 $ k $ 家医院，第 $ i $ 家医院医治一个濒死的研究生需要 $ d_i $ 天，并且需要 $ q_i $ 元钱。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3280](http://www.lydsy.com/JudgeOnline/problem.php?id=3280)\n\n### 题解\n建立费用流模型。\n\n为每一天建两个点，一个表示这一天开始时可用的研究生，另一个表示这一天结束时濒死的研究生。两点之间连一条边，流量上下界均为这一天所需的研究生数量 $ a_i $，费用为零。\n\n显然，第一天雇佣所有的研究生，每一天未使用的研究生留到下一天，和在每一天分别雇佣研究生是等价的。从源点向第一天可用研究生的点连 $ m $ 条边，容量为 $ l_i $，费用为一个 $ p_i $。\n\n从第 $ i $ 天表示濒死的研究生的点向第 $ i + d_i $ 天表示可用研究生的点连一条边，表示医治一些研究生，容量为正无穷，费用为 $ q_i $。\n\n对上下界的处理：从源点到表示每天濒死研究生的点连一条边，容量为 $ a_i $，从表示每天可用研究生的点向汇点连一条边，容量为 $ a_i $，最终流量为 $ \\sum a_i $ 则有解。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXK = 50;\n\nstruct Node {\n\tstruct Edge *e, *in;\n\tbool q;\n\tint d, f;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].q = false;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].f = 0;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t}\n}\n\ninline void clear(const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t\tconst int s = 0, t = n * 2 + 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i, t, x, 0);\n\t\t\taddEdge(s, i + n, x, 0);\n\t\t\tsum += x;\n\n\t\t\tif (i != n) addEdge(i, i + 1, INT_MAX, 0);\n\t\t}\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\taddEdge(s, 1, a, b);\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b), a++;\n\t\t\tfor (int j = 1; j <= n - a; j++) addEdge(j + n, j + a, INT_MAX, b);\n\t\t}\n\n\t\tint flow, cost;\n\t\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\t\tprintf(\"Case %d: \", i);\n\t\tif (flow == sum) printf(\"%d\\n\", cost);\n\t\telse puts(\"impossible\");\n\n\t\tclear(n * 2 + 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3280","published":1,"updated":"2016-09-10T11:54:33.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sdc01g4ooxl4pl7m6x7"},{"title":"「BZOJ 3277」串 - 后缀数组 + 并查集 + 启发式合并","date":"2016-09-29T23:24:00.000Z","_content":"\n给 $ n $ 个字符串，询问每个字符串有多少子串（不要求本质不同，不包括空串）是所有 $ n $ 个字符串中至少 $ k $ 个字符串的子串。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3277](http://www.lydsy.com/JudgeOnline/problem.php?id=3277)  \n[Codeforces 204E](http://codeforces.com/problemset/problem/204/E)\n\n### 题解\n将所有串用在字符集之外的不同字符连接，对所得串建立后缀数组，考虑一个极大的两两间最长公共前缀（下文中省略）$ \\geq x $ 的连通块。如果这个块内包含来自 $ \\geq k $ 个原串前缀，则这些后缀长度为 $ x $ 的前缀是满足题意的子串。\n\n从大到小枚举 $ x $，用并查集维护每个 $ \\geq x $ 的连通块，用 `set` 维护连通块内。每次合并相邻的连通块，统计长度为 $ x $ 的子串对答案的贡献。将 $ < x $ 的子串留到下一次继续合并的时候统计。\n\n但是会有一种情况，一个 $ x $ 的连通块附近没有 $ x - 1 $ 的连通块，则长度为 $ x - 1 $ 的子串不会被统计，并且长度为 $ x - 1 $ 的子串和长度为 $ x $ 的子串是相同的，一起统计即可。\n\n对于 $ k = 1 $ 的情况，需要特判，输出每个字符串的子串数量。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 100000 + MAXN;\n\nint s[MAXLEN];\nint n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN];\n\ninline void suffixArray() {\n\tstatic int set[MAXLEN], a[MAXLEN];\n\tstd::copy(s, s + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\t\t\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tbool unique = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\tif (unique) break;\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\nstruct UnionFindSet {\n\tint a[MAXLEN], l[MAXLEN], r[MAXLEN];\n\tstd::set<int> set[MAXLEN];\n\n\tvoid init(const int n, const int *belong) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = i;\n\t\t\trk[i] = 1;\n\t\t\tl[i] = r[i] = i;\n\t\t\tset[i].insert(belong[i]);\n\t\t}\n\t}\n\n\tint find(const int x) {\n\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t}\n\n\tint merge(const int x, const int y) {\n#ifdef DBG\n\t\tprintf(\"merge(%d, %d)\\n\", x, y);\n#endif\n\t\tint _x = find(x), _y = find(y);\n\t\tif (set[_x].size() < set[_y].size()) std::swap(_x, _y);\n\t\ta[_y] = _x;\n\t\tset[_x].insert(set[_y].begin(), set[_y].end());\n\t\tl[_x] = std::min(l[_x], l[_y]);\n\t\tr[_x] = std::max(r[_x], r[_y]);\n\t\treturn _x;\n\t}\n\n\tint uniqueCount(const int x) {\n\t\treturn set[x].size();\n\t}\n\n\tvoid getRange(const int x, int &l, int &r) {\n\t\tl = this->l[x];\n\t\tr = this->r[x];\n\t}\n} ufs;\n\nlong long gap[MAXLEN + 1];\ninline void apply(const int id, const int val = 1) {\n\tint l, r;\n\tufs.getRange(id, l, r);\n\tgap[l] += val, gap[r + 1] -= val;\n#ifdef DBG\n\tfor (int i = l; i <= r; i++) printf(\"ans[%d] += %d\\n\", belong[i], val);\n#endif\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d\", &m, &k);\n\n\tint *p = s;\n\tint spliter = 233;\n\tfor (int i = 0; i < m; i++) {\n#ifdef DBG\n\t\tprintf(\"%d\\n\", i);\n#endif\n\t\tpos[i] = p - s;\n\t\tstatic char buf[MAXLEN];\n\t\tscanf(\"%s\", buf);\n\t\tint len = strlen(buf);\n\t\tif (k == 1) {\n\t\t\tstd::cout << (static_cast<long long>(len) * (len + 1) / 2) << (i == m - 1 ? '\\n' : ' ');\n\t\t}\n\t\tfor (int i = 0; i < len; i++) *p++ = buf[i];\n\t\t*p++ = spliter++;\n\t}\n\t\n\tif (k == 1) return 0;\n\n\t*--p = '\\0';\n\tn = p - s;\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1;\n\tufs.init(n, belong);\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d %s\\n\", belong[i], ht[i], &s[sa[i]]);\n\t}\n#endif\n\n\tstd::vector<int> v[MAXLEN];\n\tint maxH = 0;\n\tfor (int i = 0; i < n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]);\n\tfor (int i = maxH; i > 0; i--) {\n#ifdef DBG\n\t\tprintf(\"Now processing h = %d\\n\", i);\n#endif\n\t\tstd::vector<int> vec;\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\tint id = ufs.merge(*it, *it - 1);\n\t\t\tif (ufs.uniqueCount(id) >= k) {\n\t\t\t\t// apply(id);\n\t\t\t\tvec.push_back(id);\n\t\t\t}\n\t\t}\n\t\tfor (std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it);\n\t\tstd::sort(vec.begin(), vec.end());\n\t\tstd::vector<int>::const_iterator end = std::unique(vec.begin(), vec.end());\n\t\tfor (std::vector<int>::const_iterator it = vec.begin(); it != end; it++) {\n\t\t\tint l, r;\n\t\t\tufs.getRange(*it, l, r);\n\t\t\tint x = ht[l];\n\t\t\tif (r != n - 1) x = std::max(x, ht[r + 1]);\n\t\t\tapply(*it, i - x);\n\t\t}\n\t}\n\n\tstatic long long ans[MAXN];\n\tfor (int i = 1; i < n; i++) gap[i] += gap[i - 1];\n\tfor (int i = 0; i < n; i++) ans[belong[i]] += gap[i];\n\n\t// for (int i = 0; i < m; i++) printf(\"%lld%c\", ans[i], i == m - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::cout << ans[i]; //  << (i == m - 1 ? '\\0' : ' ');\n\t\tif (i != m - 1) std::cout << ' ';\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3277.md","raw":"title: 「BZOJ 3277」串 - 后缀数组 + 并查集 + 启发式合并\ncategories: OI\ntags: \n  - BZOJ\n  - Codeforces\n  - 字符串\n  - 后缀数组\n  - 并查集\n  - 启发式合并\npermalink: bzoj-3277\ndate: 2016-09-30 07:24:00\n---\n\n给 $ n $ 个字符串，询问每个字符串有多少子串（不要求本质不同，不包括空串）是所有 $ n $ 个字符串中至少 $ k $ 个字符串的子串。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3277](http://www.lydsy.com/JudgeOnline/problem.php?id=3277)  \n[Codeforces 204E](http://codeforces.com/problemset/problem/204/E)\n\n### 题解\n将所有串用在字符集之外的不同字符连接，对所得串建立后缀数组，考虑一个极大的两两间最长公共前缀（下文中省略）$ \\geq x $ 的连通块。如果这个块内包含来自 $ \\geq k $ 个原串前缀，则这些后缀长度为 $ x $ 的前缀是满足题意的子串。\n\n从大到小枚举 $ x $，用并查集维护每个 $ \\geq x $ 的连通块，用 `set` 维护连通块内。每次合并相邻的连通块，统计长度为 $ x $ 的子串对答案的贡献。将 $ < x $ 的子串留到下一次继续合并的时候统计。\n\n但是会有一种情况，一个 $ x $ 的连通块附近没有 $ x - 1 $ 的连通块，则长度为 $ x - 1 $ 的子串不会被统计，并且长度为 $ x - 1 $ 的子串和长度为 $ x $ 的子串是相同的，一起统计即可。\n\n对于 $ k = 1 $ 的情况，需要特判，输出每个字符串的子串数量。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 100000 + MAXN;\n\nint s[MAXLEN];\nint n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN];\n\ninline void suffixArray() {\n\tstatic int set[MAXLEN], a[MAXLEN];\n\tstd::copy(s, s + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\t\t\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tbool unique = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\tif (unique) break;\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\nstruct UnionFindSet {\n\tint a[MAXLEN], l[MAXLEN], r[MAXLEN];\n\tstd::set<int> set[MAXLEN];\n\n\tvoid init(const int n, const int *belong) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = i;\n\t\t\trk[i] = 1;\n\t\t\tl[i] = r[i] = i;\n\t\t\tset[i].insert(belong[i]);\n\t\t}\n\t}\n\n\tint find(const int x) {\n\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t}\n\n\tint merge(const int x, const int y) {\n#ifdef DBG\n\t\tprintf(\"merge(%d, %d)\\n\", x, y);\n#endif\n\t\tint _x = find(x), _y = find(y);\n\t\tif (set[_x].size() < set[_y].size()) std::swap(_x, _y);\n\t\ta[_y] = _x;\n\t\tset[_x].insert(set[_y].begin(), set[_y].end());\n\t\tl[_x] = std::min(l[_x], l[_y]);\n\t\tr[_x] = std::max(r[_x], r[_y]);\n\t\treturn _x;\n\t}\n\n\tint uniqueCount(const int x) {\n\t\treturn set[x].size();\n\t}\n\n\tvoid getRange(const int x, int &l, int &r) {\n\t\tl = this->l[x];\n\t\tr = this->r[x];\n\t}\n} ufs;\n\nlong long gap[MAXLEN + 1];\ninline void apply(const int id, const int val = 1) {\n\tint l, r;\n\tufs.getRange(id, l, r);\n\tgap[l] += val, gap[r + 1] -= val;\n#ifdef DBG\n\tfor (int i = l; i <= r; i++) printf(\"ans[%d] += %d\\n\", belong[i], val);\n#endif\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d\", &m, &k);\n\n\tint *p = s;\n\tint spliter = 233;\n\tfor (int i = 0; i < m; i++) {\n#ifdef DBG\n\t\tprintf(\"%d\\n\", i);\n#endif\n\t\tpos[i] = p - s;\n\t\tstatic char buf[MAXLEN];\n\t\tscanf(\"%s\", buf);\n\t\tint len = strlen(buf);\n\t\tif (k == 1) {\n\t\t\tstd::cout << (static_cast<long long>(len) * (len + 1) / 2) << (i == m - 1 ? '\\n' : ' ');\n\t\t}\n\t\tfor (int i = 0; i < len; i++) *p++ = buf[i];\n\t\t*p++ = spliter++;\n\t}\n\t\n\tif (k == 1) return 0;\n\n\t*--p = '\\0';\n\tn = p - s;\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1;\n\tufs.init(n, belong);\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d %s\\n\", belong[i], ht[i], &s[sa[i]]);\n\t}\n#endif\n\n\tstd::vector<int> v[MAXLEN];\n\tint maxH = 0;\n\tfor (int i = 0; i < n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]);\n\tfor (int i = maxH; i > 0; i--) {\n#ifdef DBG\n\t\tprintf(\"Now processing h = %d\\n\", i);\n#endif\n\t\tstd::vector<int> vec;\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\tint id = ufs.merge(*it, *it - 1);\n\t\t\tif (ufs.uniqueCount(id) >= k) {\n\t\t\t\t// apply(id);\n\t\t\t\tvec.push_back(id);\n\t\t\t}\n\t\t}\n\t\tfor (std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it);\n\t\tstd::sort(vec.begin(), vec.end());\n\t\tstd::vector<int>::const_iterator end = std::unique(vec.begin(), vec.end());\n\t\tfor (std::vector<int>::const_iterator it = vec.begin(); it != end; it++) {\n\t\t\tint l, r;\n\t\t\tufs.getRange(*it, l, r);\n\t\t\tint x = ht[l];\n\t\t\tif (r != n - 1) x = std::max(x, ht[r + 1]);\n\t\t\tapply(*it, i - x);\n\t\t}\n\t}\n\n\tstatic long long ans[MAXN];\n\tfor (int i = 1; i < n; i++) gap[i] += gap[i - 1];\n\tfor (int i = 0; i < n; i++) ans[belong[i]] += gap[i];\n\n\t// for (int i = 0; i < m; i++) printf(\"%lld%c\", ans[i], i == m - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::cout << ans[i]; //  << (i == m - 1 ? '\\0' : ' ');\n\t\tif (i != m - 1) std::cout << ' ';\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3277","published":1,"updated":"2016-09-29T23:40:34.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sdj01gaooxlldwx269a"},{"title":"「BZOJ 3275」Number - 最小割","date":"2016-05-23T13:50:00.000Z","_content":"\n有 $ N $ 个正整数，需要从中选出一些数，使这些数的和最大。\n\n若两个数 $ a,\\ b $ 同时满足以下条件，则 $ a,\\ b $ 不能同时被选。\n\n1. 存在正整数 $ c $，使 $ a ^ 2 + b ^ 2 = c ^ 2 $；\n2. $ \\gcd(a,\\ b) = 1 $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3275](http://www.lydsy.com/JudgeOnline/problem.php?id=3275)  \n[COGS 1389](http://cogs.top/cogs/problem/problem.php?pid=1389)\n\n### 题解\n建图，把不能同时选择的数字连边，染色后发现是二分图，问题转化为二分图最大点权独立集。\n\n从源点到所有 $ X $ 点连边，容量为数字，从所有 $ Y $ 点向汇点连边，容量为数字，不能成对选择数字，从 $ X $ 点到 $ Y $ 点连边，容量为正无穷，求出最小割即为损失，总和减去损失即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n\tlong long x;\n\tbool color, v;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const long long c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], 0);\n\t(N[u].e->r = N[v].e)->r = N[u].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlong long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tlong long flow = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->f += flow;\n\t\t\t\t\te->r->f -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlong long operator()(const int s, const int t, const int n) {\n\t\tlong long res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tlong long flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\nint n;\nbool flag[MAXN][MAXN];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\n\ntemplate <typename T>\ninline bool isSquare(const T x) {\n\tT t = static_cast<T>(sqrt(static_cast<double>(x)));\n\treturn t * t == x;\n}\n\ntemplate <typename T>\ninline T gcd(const T a, const T b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].color = true;\n\t\tN[i].v = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->v) {\n\t\t\t\t\te->t->v = true;\n\t\t\t\t\te->t->color = !v->color;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else assert(e->t->color != v->color);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void clean() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &N[i].x);\n\t\tsum += N[i].x;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (isSquare(sqr(N[i].x) + sqr(N[j].x)) && gcd(N[i].x, N[j].x) == 1) {\n\t\t\t\tflag[i][j] = flag[j][i] = true;\n\t\t\t\taddEdge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcolor();\n\tclean();\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].color) addEdge(s, i, N[i].x);\n\t\telse addEdge(i, t, N[i].x);\n\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (flag[i][j]) {\n\t\t\t\tif (N[i].color) addEdge(i, j, LLONG_MAX);\n\t\t\t\telse addEdge(j, i, LLONG_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%lld\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3275.md","raw":"title: 「BZOJ 3275」Number - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - 网络流\n  - Dinic\n  - 最小割\n  - 二分图染色\npermalink: bzoj-3275\ndate: 2016-05-23 21:50:00\n---\n\n有 $ N $ 个正整数，需要从中选出一些数，使这些数的和最大。\n\n若两个数 $ a,\\ b $ 同时满足以下条件，则 $ a,\\ b $ 不能同时被选。\n\n1. 存在正整数 $ c $，使 $ a ^ 2 + b ^ 2 = c ^ 2 $；\n2. $ \\gcd(a,\\ b) = 1 $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3275](http://www.lydsy.com/JudgeOnline/problem.php?id=3275)  \n[COGS 1389](http://cogs.top/cogs/problem/problem.php?pid=1389)\n\n### 题解\n建图，把不能同时选择的数字连边，染色后发现是二分图，问题转化为二分图最大点权独立集。\n\n从源点到所有 $ X $ 点连边，容量为数字，从所有 $ Y $ 点向汇点连边，容量为数字，不能成对选择数字，从 $ X $ 点到 $ Y $ 点连边，容量为正无穷，求出最小割即为损失，总和减去损失即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n\tlong long x;\n\tbool color, v;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const long long c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], 0);\n\t(N[u].e->r = N[v].e)->r = N[u].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlong long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tlong long flow = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->f += flow;\n\t\t\t\t\te->r->f -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlong long operator()(const int s, const int t, const int n) {\n\t\tlong long res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tlong long flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\nint n;\nbool flag[MAXN][MAXN];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\n\ntemplate <typename T>\ninline bool isSquare(const T x) {\n\tT t = static_cast<T>(sqrt(static_cast<double>(x)));\n\treturn t * t == x;\n}\n\ntemplate <typename T>\ninline T gcd(const T a, const T b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].color = true;\n\t\tN[i].v = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->v) {\n\t\t\t\t\te->t->v = true;\n\t\t\t\t\te->t->color = !v->color;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else assert(e->t->color != v->color);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void clean() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &N[i].x);\n\t\tsum += N[i].x;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (isSquare(sqr(N[i].x) + sqr(N[j].x)) && gcd(N[i].x, N[j].x) == 1) {\n\t\t\t\tflag[i][j] = flag[j][i] = true;\n\t\t\t\taddEdge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcolor();\n\tclean();\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].color) addEdge(s, i, N[i].x);\n\t\telse addEdge(i, t, N[i].x);\n\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (flag[i][j]) {\n\t\t\t\tif (N[i].color) addEdge(i, j, LLONG_MAX);\n\t\t\t\telse addEdge(j, i, LLONG_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%lld\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3275","published":1,"updated":"2016-05-23T15:09:19.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sdr01giooxlxt70lzsf"},{"title":"「BZOJ 3262」陌上花开 - CDQ","date":"2016-06-19T12:56:00.000Z","_content":"\n定义一个序列，序列中每个元素都是一个三元组 $ A_i = (a,\\ b,\\ c) $。  \n若 $ a_i \\leq a_j,\\ b_i \\leq b_j,\\ c_i \\leq c_j $，则称 $ A_j $ 比 $ A_i $ 优。  \n定义 $ A_i $ 的等级为有多少 $ A_j $ 满足 $ A_i $ 比 $ A_j $ 更优。\n\n求每个等级的元素数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3262](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n### 题解\n经典的三维偏序问题，使用 CDQ 分治解决。\n\n首先，将第一维排序，进行 CDQ 分治。分治时保证前一半元素的 $ a $ 始终小于等于后一半，并且两半分别按照 $ b $ 升序。\n\n分治完两半之后，将两半按照 $ b $ 归并，并同时对 $ c $ 维护树状数组，动态查询有多少点的 $ c $ 小于等于当前点。树状数组保证了 $ c $ 的大小关系，归并保证了 $ b $ 的大小关系，排序保证了 $ a $ 的大小关系，CDQ 保证了对一个元素有贡献的所有元素都被考虑的到。\n\n每一次分治完成后需要清空树状数组。\n\n注意可能有多个重复的元素，此时只需记录一个元素出现的次数即可。一个元素会对它本身的答案有贡献，在分治到最后一层时对其赋值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXK = 200000;\n\nstruct Triple {\n\tint a, b, c, cnt, ans;\n} a[MAXN], A[MAXN];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.a < b.a || (a.a == b.a && a.b < b.b) || (a.a == b.a && a.b == b.b && a.c < b.c);\n}\n\nint n, k;\n\nstruct BinaryIndexedTree {\n\tint a[MAXK];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clean(const int x) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->b <= p2->b && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tbit.clean(p->c);\n\t\t*q = *p;\n\t}\n\n\t/*\n\tprintf(\"cdq(%ld, %ld): \", l - A + 1, r - A + 1);\n\tfor (Triple *p = l; p <= r; p++) {\n\t\tprintf(\"(%d, %d, %d)%s\", p->a, p->b, p->c, p == r ? \"\\n\" : \", \");\n\t}\n\t*/\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T &x) {\n\tstatic char s[20];\n\tint cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tread(n), read(k);\n\tfor (int i = 0; i < n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1;\n\t// scanf(\"%d %d\", &n, &k);\n\t// for (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\n\tstd::sort(a, a + n);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[cnt++] = a[i];\n\t\telse A[cnt - 1].cnt++;\n\t}\n\n\tcdq(A, A + cnt - 1);\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0; i < cnt; i++) ans[A[i].ans] += A[i].cnt;\n\t\n\tfor (int i = 0; i < n; i++) write(ans[i]);\n\t// for (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3262.md","raw":"title: 「BZOJ 3262」陌上花开 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - 树状数组\n  - 数据结构\n  - 分治\npermalink: bzoj-3262\ndate: 2016-06-19 20:56:00\n---\n\n定义一个序列，序列中每个元素都是一个三元组 $ A_i = (a,\\ b,\\ c) $。  \n若 $ a_i \\leq a_j,\\ b_i \\leq b_j,\\ c_i \\leq c_j $，则称 $ A_j $ 比 $ A_i $ 优。  \n定义 $ A_i $ 的等级为有多少 $ A_j $ 满足 $ A_i $ 比 $ A_j $ 更优。\n\n求每个等级的元素数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3262](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n### 题解\n经典的三维偏序问题，使用 CDQ 分治解决。\n\n首先，将第一维排序，进行 CDQ 分治。分治时保证前一半元素的 $ a $ 始终小于等于后一半，并且两半分别按照 $ b $ 升序。\n\n分治完两半之后，将两半按照 $ b $ 归并，并同时对 $ c $ 维护树状数组，动态查询有多少点的 $ c $ 小于等于当前点。树状数组保证了 $ c $ 的大小关系，归并保证了 $ b $ 的大小关系，排序保证了 $ a $ 的大小关系，CDQ 保证了对一个元素有贡献的所有元素都被考虑的到。\n\n每一次分治完成后需要清空树状数组。\n\n注意可能有多个重复的元素，此时只需记录一个元素出现的次数即可。一个元素会对它本身的答案有贡献，在分治到最后一层时对其赋值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXK = 200000;\n\nstruct Triple {\n\tint a, b, c, cnt, ans;\n} a[MAXN], A[MAXN];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.a < b.a || (a.a == b.a && a.b < b.b) || (a.a == b.a && a.b == b.b && a.c < b.c);\n}\n\nint n, k;\n\nstruct BinaryIndexedTree {\n\tint a[MAXK];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clean(const int x) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->b <= p2->b && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tbit.clean(p->c);\n\t\t*q = *p;\n\t}\n\n\t/*\n\tprintf(\"cdq(%ld, %ld): \", l - A + 1, r - A + 1);\n\tfor (Triple *p = l; p <= r; p++) {\n\t\tprintf(\"(%d, %d, %d)%s\", p->a, p->b, p->c, p == r ? \"\\n\" : \", \");\n\t}\n\t*/\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T &x) {\n\tstatic char s[20];\n\tint cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tread(n), read(k);\n\tfor (int i = 0; i < n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1;\n\t// scanf(\"%d %d\", &n, &k);\n\t// for (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\n\tstd::sort(a, a + n);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[cnt++] = a[i];\n\t\telse A[cnt - 1].cnt++;\n\t}\n\n\tcdq(A, A + cnt - 1);\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0; i < cnt; i++) ans[A[i].ans] += A[i].cnt;\n\t\n\tfor (int i = 0; i < n; i++) write(ans[i]);\n\t// for (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3262","published":1,"updated":"2016-06-19T12:56:40.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sdy01gpooxlb5n43bq4"},{"title":"「BZOJ 3230」相似子串 - 后缀数组","date":"2016-09-29T22:59:00.000Z","_content":"\n对于一个长度为 $ N $ 的字符串 $ S $，将其本质不同的所有子串按照字典序排序。我们定义两个子串的相似程度为 $ f = a ^ 2 + b ^ 2 $ 的最大值，其中 $ a $、$ b $ 满足：$ S[l \\ldots l + a - 1] = S[p \\ldots p + a - 1] $，$ S[r - b + 1 \\ldots r] = S[q - b + 1 \\ldots q] $，$ 0 \\leq a \\leq r - l + 1 $，$ 0 \\leq b \\leq q - p + 1 $。\n\n每次询问排序后的第 $ i $ 个和第 $ j $ 个子串的相似程度。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3230](http://www.lydsy.com/JudgeOnline/problem.php?id=3230)\n\n### 题解\n一个长度为 $ N $ 的串，它的本质不同的子串数量是 $ O(N ^ 2) $ 级别的，所以不能直接对子串排序。\n\n考虑到每个子串都是一个后缀的前缀，对所有后缀排序，相邻两个后缀的最长公共前缀即为重复的子串。设第 $ i $ 个与第 $ i - 1 $ 个后缀的最长公共前缀为 $ l $，则由第 $ i $ 个后缀的前缀构成的子串中与前 $ i - 1 $ 个后缀的前缀构成的子串的不同的有 $ \\mathrm{len}(i) - l $ 个，这其中长度最小的为 $ l + 1 $，长度最大的为该后缀本身，这些子串的字典序即为它们长度顺序。\n\n使用后缀数组求出相邻两个后缀的最长公共前缀，求出每个后缀对子串个数的贡献，通过二分即可定位产生第 $ i $ 个子串的后缀，进而求出这个子串在原串中的位置。$ a $ 和 $ b $ 使用后缀数组求最长公共前缀、后缀解决即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812;\n\nchar s[MAXN], sRev[MAXN];\nint n, log[MAXN + 1];\nlong long cnt[MAXN];\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1];\n\n\tvoid build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n\t\t// */\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef TEST\n\t\tassert(l <= r);\n#endif\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\tint res = std::min(st[l][t], st[r - (1 << t) + 1][t]);\n#ifdef TEST\n\t\tint ans = n;\n\t\tfor (int k = l; k <= r; k++) ans = std::min(ans, ht[k]);\n\t\tassert(res == ans);\n#endif\n\t\treturn res;\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn query(a + 1, b);\n\t}\n} sa, saRev;\n\ninline int lcp(const int i, const int j) {\n\tint res = sa.lcp(i, j);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i + ans < n && j + ans < n && s[i + ans] == s[j + ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline int lcs(const int i, const int j) {\n\tint res = saRev.lcp(n - i - 1, n - j - 1);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i - ans >= 0 && j - ans >= 0 && s[i - ans] == s[j - ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline void prepare() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t\t// printf(\"log(%d) = %d\\n\", i, log[i]);\n\t}\n\n\tsa.build(s, n);\n\n\tlong long x = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tx += n - sa.sa[i];\n\t\tif (i) x -= sa.ht[i];\n\t\tcnt[i] = x;\n\t\t// printf(\"%lld\\n\", x);\n\t}\n\n\tstd::copy(s, s + n, sRev);\n\tstd::reverse(sRev, sRev + n);\n\tsaRev.build(sRev, n);\n}\n\ninline bool locate(const long long k, int &l, int &r) {\n\tlong long *p = std::upper_bound(cnt, cnt + n, k - 1);\n\tif (p == cnt + n) return false;\n\tint t = *p - k;\n\tl = sa.sa[p - cnt];\n\tr = n - t - 1;\n\treturn true;\n}\n\ninline void all() {\n\tstd::vector<std::string> v;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) v.push_back(std::string(&s[i], &s[j]));\n\tstd::sort(v.begin(), v.end());\n\tv.erase(std::unique(v.begin(), v.end()), v.end());\n\tint i = 1;\n\tfor (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tint l, r;\n\t\tlocate(i++, l, r);\n\t\t// printf(\"%d %d\\n\", l, r);\n\t\tfor (int j = l; j <= r; j++) putchar(s[j]);\n\t\tputchar('\\n');\n\t\tprintf(\"%s\\n\", it->c_str());\n\t}\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\\n%s\", &n, &q, s);\n\tn = strlen(s);\n\tprepare();\n\t// all();\n\n\t/*\n\tputs(\"left query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"lq(%d, %d) = %d\\n\", i, j, query(stp, i, j));\n\n\tputs(\"right query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"rq(%d, %d) = %d\\n\", i, j, query(sts, i, j));\n\t*/\n\n\t/*\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcp(%d, %d) = %d\\n\", i, j, lcp(i, j));\n\tputchar('\\n');\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcs(%d, %d) = %d\\n\", i, j, lcs(i, j));\n\t*/\n\n\twhile (q--) {\n\t\tlong long i, j;\n\t\tscanf(\"%lld %lld\", &i, &j);\n\t\tint l1, r1, l2, r2;\n\t\tif (!locate(i, l1, r1) || !locate(j, l2, r2)) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint lim = std::min(r1 - l1 + 1, r2 - l2 + 1);\n\t\tlong long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2));\n\t\tprintf(\"%lld\\n\", a * a + b * b);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3230.md","raw":"title: 「BZOJ 3230」相似子串 - 后缀数组\ncategories: OI\ntags: \n  - BZOJ\n  - 字符串\n  - 后缀数组\npermalink: bzoj-3230\ndate: 2016-09-30 06:59:00\n---\n\n对于一个长度为 $ N $ 的字符串 $ S $，将其本质不同的所有子串按照字典序排序。我们定义两个子串的相似程度为 $ f = a ^ 2 + b ^ 2 $ 的最大值，其中 $ a $、$ b $ 满足：$ S[l \\ldots l + a - 1] = S[p \\ldots p + a - 1] $，$ S[r - b + 1 \\ldots r] = S[q - b + 1 \\ldots q] $，$ 0 \\leq a \\leq r - l + 1 $，$ 0 \\leq b \\leq q - p + 1 $。\n\n每次询问排序后的第 $ i $ 个和第 $ j $ 个子串的相似程度。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3230](http://www.lydsy.com/JudgeOnline/problem.php?id=3230)\n\n### 题解\n一个长度为 $ N $ 的串，它的本质不同的子串数量是 $ O(N ^ 2) $ 级别的，所以不能直接对子串排序。\n\n考虑到每个子串都是一个后缀的前缀，对所有后缀排序，相邻两个后缀的最长公共前缀即为重复的子串。设第 $ i $ 个与第 $ i - 1 $ 个后缀的最长公共前缀为 $ l $，则由第 $ i $ 个后缀的前缀构成的子串中与前 $ i - 1 $ 个后缀的前缀构成的子串的不同的有 $ \\mathrm{len}(i) - l $ 个，这其中长度最小的为 $ l + 1 $，长度最大的为该后缀本身，这些子串的字典序即为它们长度顺序。\n\n使用后缀数组求出相邻两个后缀的最长公共前缀，求出每个后缀对子串个数的贡献，通过二分即可定位产生第 $ i $ 个子串的后缀，进而求出这个子串在原串中的位置。$ a $ 和 $ b $ 使用后缀数组求最长公共前缀、后缀解决即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812;\n\nchar s[MAXN], sRev[MAXN];\nint n, log[MAXN + 1];\nlong long cnt[MAXN];\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1];\n\n\tvoid build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n\t\t// */\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef TEST\n\t\tassert(l <= r);\n#endif\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\tint res = std::min(st[l][t], st[r - (1 << t) + 1][t]);\n#ifdef TEST\n\t\tint ans = n;\n\t\tfor (int k = l; k <= r; k++) ans = std::min(ans, ht[k]);\n\t\tassert(res == ans);\n#endif\n\t\treturn res;\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn query(a + 1, b);\n\t}\n} sa, saRev;\n\ninline int lcp(const int i, const int j) {\n\tint res = sa.lcp(i, j);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i + ans < n && j + ans < n && s[i + ans] == s[j + ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline int lcs(const int i, const int j) {\n\tint res = saRev.lcp(n - i - 1, n - j - 1);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i - ans >= 0 && j - ans >= 0 && s[i - ans] == s[j - ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline void prepare() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t\t// printf(\"log(%d) = %d\\n\", i, log[i]);\n\t}\n\n\tsa.build(s, n);\n\n\tlong long x = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tx += n - sa.sa[i];\n\t\tif (i) x -= sa.ht[i];\n\t\tcnt[i] = x;\n\t\t// printf(\"%lld\\n\", x);\n\t}\n\n\tstd::copy(s, s + n, sRev);\n\tstd::reverse(sRev, sRev + n);\n\tsaRev.build(sRev, n);\n}\n\ninline bool locate(const long long k, int &l, int &r) {\n\tlong long *p = std::upper_bound(cnt, cnt + n, k - 1);\n\tif (p == cnt + n) return false;\n\tint t = *p - k;\n\tl = sa.sa[p - cnt];\n\tr = n - t - 1;\n\treturn true;\n}\n\ninline void all() {\n\tstd::vector<std::string> v;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) v.push_back(std::string(&s[i], &s[j]));\n\tstd::sort(v.begin(), v.end());\n\tv.erase(std::unique(v.begin(), v.end()), v.end());\n\tint i = 1;\n\tfor (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tint l, r;\n\t\tlocate(i++, l, r);\n\t\t// printf(\"%d %d\\n\", l, r);\n\t\tfor (int j = l; j <= r; j++) putchar(s[j]);\n\t\tputchar('\\n');\n\t\tprintf(\"%s\\n\", it->c_str());\n\t}\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\\n%s\", &n, &q, s);\n\tn = strlen(s);\n\tprepare();\n\t// all();\n\n\t/*\n\tputs(\"left query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"lq(%d, %d) = %d\\n\", i, j, query(stp, i, j));\n\n\tputs(\"right query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"rq(%d, %d) = %d\\n\", i, j, query(sts, i, j));\n\t*/\n\n\t/*\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcp(%d, %d) = %d\\n\", i, j, lcp(i, j));\n\tputchar('\\n');\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcs(%d, %d) = %d\\n\", i, j, lcs(i, j));\n\t*/\n\n\twhile (q--) {\n\t\tlong long i, j;\n\t\tscanf(\"%lld %lld\", &i, &j);\n\t\tint l1, r1, l2, r2;\n\t\tif (!locate(i, l1, r1) || !locate(j, l2, r2)) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint lim = std::min(r1 - l1 + 1, r2 - l2 + 1);\n\t\tlong long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2));\n\t\tprintf(\"%lld\\n\", a * a + b * b);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3230","published":1,"updated":"2016-09-29T23:26:11.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9se501gwooxl4he1heaz"},{"title":"「BZOJ 3196」二逼平衡树 - 树套树","date":"2016-06-19T01:37:00.000Z","_content":"\n您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：\n\n1. 查询 $ k $ 在区间内的排名；\n2. 查询区间内排名为 $ k $ 的值；\n3. 修改某一位值上的数值；\n4. 查询 $ k $ 在区间内的前驱（前驱定义为小于 $ x $，且最大的数）；\n5. 查询 $ k $ 在区间内的后继（后继定义为大于 $ x $，且最小的数）。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3196](http://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n### 题解\n对于没有区间限制的查询，我们可以使用平衡树维护，有了区间的限制，可以在外层套上一层线段树。\n\n对序列建立线段树，在每个线段树节点中建立平衡树。考虑到序列中的每个数最多会出现在线段树上的 $ O(\\log n) $ 个节点中，总空间复杂度为 $ O(n \\log n) $。可以在 $ O(n \\log ^ 2 n) $ 的时间内完成建树。\n\n#### 排名\n在该区间对应在线段树上的 $ O(\\log n) $ 个节点中的平衡树上查询该数的排名，累加得到区间内公有多少数比该数小即可；\n\n#### 根据排名选择\n枚举答案，并查询所枚举的答案的排名，显然这里的答案是单调的，可以使用二分。\n\n二分 $ x $，如果 $ x $ 的排名大于 $ k $，则它不可能成为答案，但这时我们可以将右边界置为 $ x $；反之它可以被置为左边界。最终二分区间内只剩下两个数时，判断较大的数是否合法即可。\n\n对数据进行离散化可以加速二分。\n\n#### 修改\n转化为一次删除一次插入即可。\n\n#### 前驱（后继）\n在该区间对应在线段树上的 $ O(\\log n) $ 个节点中的平衡树上查询该数前驱（后继），取最大（小）值即可。\n\n总时间复杂度为 $ O(n \\log ^ 3 n) $，但 Splay 常数巨大，在 BZOJ 可以卡着时限通过。\n\n另一种方法是将内层的平衡树换为带垃圾回收的动态开点的权值线段树，空间复杂度为 $ O(n \\log ^ 2 n) $，需要 512M 内存。\n\n![带垃圾回收的动态开点的权值线段树](bzoj-3196/lemon.png)\n\n正解分块，时间复杂度为 $ O(n \\sqrt n \\log n) $，我没写。\n\n### 代码\n线段树套 Splay，RP 不好的时候会 TLE。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\n\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size, cnt, val;\n\n\t\tNode(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) {\n\t\t\tc[L] = c[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = cnt;\n\t\t\tif (c[L]) size += c[L]->size;\n\t\t\tif (c[R]) size += c[R]->size;\n\t\t}\n\n\t\tRelation relatain() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relatain();\n\t\t\tNode *o = p;\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relatain()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (p->relatain() == relatain()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prec() {\n\t\t\tsplay();\n\t\t\tNode *v = c[L];\n\t\t\twhile (v->c[R]) v = v->c[R];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = c[R];\n\t\t\twhile (v->c[L]) v = v->c[L];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tint left() const { return c[L] ? c[L]->size : 0; }\n\n#ifdef DBG\n\t\tvoid validate() {\n\t\t\tint size = 0;\n\t\t\tif (c[L]) c[L]->validate(), assert(this->val > c[L]->val), size += c[L]->size;\n\t\t\tif (c[R]) c[R]->validate(), assert(this->val < c[R]->val), size += c[R]->size;\n\t\t\tassert(this->size == size + cnt);\n\t\t}\n\n\t\tvoid print(const int depth = 0);\n#endif\n\t} *r;\n#ifdef DBG\n\tint id;\n#endif\n\n\tSplay(const int *a, const int n) : r(NULL) {\n\t\tinsert(INT_MAX), insert(INT_MIN);\n#ifdef DBG\n\t\tstatic int time = 0;\n\t\ttime++;\n\t\tid = time;\n\t\tprintf(\"build(%d): \", id);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~Splay() { delete r; }\n\n\tNode *find(const int x) {\n\t\tNode *v = r;\n\t\twhile (v && x != v->val) {\n\t\t\tif (x < v->val) v = v->c[L];\n\t\t\telse v = v->c[R];\n\t\t}\n\t\treturn v ? v->splay() : NULL;\n\t}\n\n\tNode *insert(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) {\n\t\t\tv->cnt++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &r, *p = NULL;\n\t\twhile (*target) {\n\t\t\tp = *target;\n\t\t\tp->size++;\n\t\t\tif (x< p->val) target = &p->c[L];\n\t\t\telse target = &p->c[R];\n\t\t}\n\n\t\treturn (*target = new Node(p, x, &r))->splay();\n\t}\n\n\tint rank(const int x) {\n\t\tNode *v = find(x);\n\t\tint res;\n\t\tif (v) res = v->left();\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tres = v->left();\n\t\t\terase(v);\n\t\t}\n#ifdef DBG\n\t\tprintf(\"rank(%d) in (%d) = %d\\n\", x, id, res);\n#endif\n\t\treturn res;\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (!(x >= v->left() + 1 && x <= v->left() + v->cnt)) {\n\t\t\tif (x < v->left() + 1) v = v->c[L];\n\t\t\telse x -= v->left() + v->cnt, v = v->c[R];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->cnt != 1) {\n\t\t\tv->cnt--, v->size--;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode *prec = v->prec(), *succ = v->succ();\n\n\t\tprec->splay();\n\t\tsucc->splay(prec);\n\n\t\tdelete succ->c[L];\n\t\tsucc->c[L] = NULL;\n\n\t\tsucc->maintain(), prec->maintain();\n\t}\n\n\tvoid erase(const int x) {\n\t\tNode *v = find(x);\n\t\terase(v);\n\t}\n\n\tint prec(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->prec()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->prec()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint succ(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->succ()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tr->validate();\n\t}\n#endif\n};\n\n#ifdef DBG\nvoid Splay::Node::print(const int depth) {\n\tif (c[L]) c[L]->print(depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' '), putchar(' ');\n\tprintf(\"%d\\n\", val);\n\tif (c[R]) c[R]->print(depth + 1);\n}\n#endif\n\nint map[MAXM + MAXN], max;\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tSplay s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n\n线段树套带垃圾回收的动态开点的权值线段树，MLE。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\nint map[MAXM + MAXN], max;\n\nstruct WeightSegmentTree {\n\tint l, r, mid;\n\tWeightSegmentTree *lc, *rc;\n\tint min, max, cnt;\n\n\tWeightSegmentTree(const int l, const int r)\n\t\t: l(l), r(r), mid(l + (r - l) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{}\n\n\tWeightSegmentTree(const int *a, const int n)\n\t\t: l(0), r(::max - 1), mid((max - 1) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~WeightSegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tvoid maintain() {\n\t\tmin = INT_MAX;\n\t\tif (lc) min = std::min(min, lc->min);\n\t\tif (rc) min = std::min(min, rc->min);\n\n\t\tmax = INT_MIN;\n\t\tif (lc) max = std::max(max, lc->max);\n\t\tif (rc) max = std::max(max, rc->max);\n\n\t\tcnt = 0;\n\t\tif (lc) cnt += lc->cnt;\n\t\tif (rc) cnt += rc->cnt;\n\t}\n\n\tvoid insert(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!cnt++) min = max = x;\n\t\t} else {\n\t\t\tif (x <= mid) {\n\t\t\t\tif (!lc) lc = new WeightSegmentTree(l, mid);\n\t\t\t\tlc->insert(x);\n\t\t\t} else {\n\t\t\t\tif (!rc) rc = new WeightSegmentTree(mid + 1, r);\n\t\t\t\trc->insert(x);\n\t\t\t}\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tvoid erase(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!--cnt) min = INT_MAX, max = INT_MIN;\n\t\t} else {\n\t\t\tif (x <= mid) lc->erase(x);\n\t\t\telse rc->erase(x);\n\t\t\tmaintain();\n\t\t\tif (x <= mid && lc->cnt == 0) delete lc, lc = NULL;\n\t\t\telse if (x > mid && rc->cnt == 0) delete rc, rc = NULL;\n\t\t}\n\t}\n\n\tint prec(const int x) {\n\t\treturn queryMax(0, x - 1);\n\t}\n\n\tint succ(const int x) {\n\t\treturn queryMin(x + 1, ::max);\n\t}\n\n\tint rank(const int x) {\n\t\treturn queryCnt(0, x - 1) + 1;\n\t}\n\n\tint select(const int k) {\n\t\tint x = k;\n\t\tWeightSegmentTree *v = this;\n\t\twhile (v->l != v->r) {\n\t\t\tif (!v->lc) v = v->rc;\n\t\t\telse if (x <= v->lc->cnt) v = v->lc;\n\t\t\telse x -= v->lc->cnt, v = v->rc;\n\t\t}\n\t\treturn v->mid;\n\t}\n\n\tint queryMin(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return min;\n\t\telse {\n\t\t\tint res = INT_MAX;\n\t\t\tif (lc) res = lc->queryMin(l, r);\n\t\t\tif (res == INT_MAX && rc) return rc->queryMin(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse {\n\t\t\tint res = INT_MIN;\n\t\t\tif (rc) res = rc->queryMax(l, r);\n\t\t\tif (res == INT_MIN && lc) return lc->queryMax(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryCnt(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tif (lc) res += lc->queryCnt(l, r);\n\t\t\tif (rc) res += rc->queryCnt(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tWeightSegmentTree s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3196.md","raw":"title: 「BZOJ 3196」二逼平衡树 - 树套树\ncategories: OI\ntags: \n  - BZOJ\n  - 线段树\n  - 平衡树\n  - Splay\n  - 数据结构\npermalink: bzoj-3196\ndate: 2016-06-19 09:37:00\n---\n\n您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：\n\n1. 查询 $ k $ 在区间内的排名；\n2. 查询区间内排名为 $ k $ 的值；\n3. 修改某一位值上的数值；\n4. 查询 $ k $ 在区间内的前驱（前驱定义为小于 $ x $，且最大的数）；\n5. 查询 $ k $ 在区间内的后继（后继定义为大于 $ x $，且最小的数）。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3196](http://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n### 题解\n对于没有区间限制的查询，我们可以使用平衡树维护，有了区间的限制，可以在外层套上一层线段树。\n\n对序列建立线段树，在每个线段树节点中建立平衡树。考虑到序列中的每个数最多会出现在线段树上的 $ O(\\log n) $ 个节点中，总空间复杂度为 $ O(n \\log n) $。可以在 $ O(n \\log ^ 2 n) $ 的时间内完成建树。\n\n#### 排名\n在该区间对应在线段树上的 $ O(\\log n) $ 个节点中的平衡树上查询该数的排名，累加得到区间内公有多少数比该数小即可；\n\n#### 根据排名选择\n枚举答案，并查询所枚举的答案的排名，显然这里的答案是单调的，可以使用二分。\n\n二分 $ x $，如果 $ x $ 的排名大于 $ k $，则它不可能成为答案，但这时我们可以将右边界置为 $ x $；反之它可以被置为左边界。最终二分区间内只剩下两个数时，判断较大的数是否合法即可。\n\n对数据进行离散化可以加速二分。\n\n#### 修改\n转化为一次删除一次插入即可。\n\n#### 前驱（后继）\n在该区间对应在线段树上的 $ O(\\log n) $ 个节点中的平衡树上查询该数前驱（后继），取最大（小）值即可。\n\n总时间复杂度为 $ O(n \\log ^ 3 n) $，但 Splay 常数巨大，在 BZOJ 可以卡着时限通过。\n\n另一种方法是将内层的平衡树换为带垃圾回收的动态开点的权值线段树，空间复杂度为 $ O(n \\log ^ 2 n) $，需要 512M 内存。\n\n![带垃圾回收的动态开点的权值线段树](bzoj-3196/lemon.png)\n\n正解分块，时间复杂度为 $ O(n \\sqrt n \\log n) $，我没写。\n\n### 代码\n线段树套 Splay，RP 不好的时候会 TLE。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\n\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size, cnt, val;\n\n\t\tNode(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) {\n\t\t\tc[L] = c[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = cnt;\n\t\t\tif (c[L]) size += c[L]->size;\n\t\t\tif (c[R]) size += c[R]->size;\n\t\t}\n\n\t\tRelation relatain() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relatain();\n\t\t\tNode *o = p;\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relatain()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (p->relatain() == relatain()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prec() {\n\t\t\tsplay();\n\t\t\tNode *v = c[L];\n\t\t\twhile (v->c[R]) v = v->c[R];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = c[R];\n\t\t\twhile (v->c[L]) v = v->c[L];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tint left() const { return c[L] ? c[L]->size : 0; }\n\n#ifdef DBG\n\t\tvoid validate() {\n\t\t\tint size = 0;\n\t\t\tif (c[L]) c[L]->validate(), assert(this->val > c[L]->val), size += c[L]->size;\n\t\t\tif (c[R]) c[R]->validate(), assert(this->val < c[R]->val), size += c[R]->size;\n\t\t\tassert(this->size == size + cnt);\n\t\t}\n\n\t\tvoid print(const int depth = 0);\n#endif\n\t} *r;\n#ifdef DBG\n\tint id;\n#endif\n\n\tSplay(const int *a, const int n) : r(NULL) {\n\t\tinsert(INT_MAX), insert(INT_MIN);\n#ifdef DBG\n\t\tstatic int time = 0;\n\t\ttime++;\n\t\tid = time;\n\t\tprintf(\"build(%d): \", id);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~Splay() { delete r; }\n\n\tNode *find(const int x) {\n\t\tNode *v = r;\n\t\twhile (v && x != v->val) {\n\t\t\tif (x < v->val) v = v->c[L];\n\t\t\telse v = v->c[R];\n\t\t}\n\t\treturn v ? v->splay() : NULL;\n\t}\n\n\tNode *insert(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) {\n\t\t\tv->cnt++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &r, *p = NULL;\n\t\twhile (*target) {\n\t\t\tp = *target;\n\t\t\tp->size++;\n\t\t\tif (x< p->val) target = &p->c[L];\n\t\t\telse target = &p->c[R];\n\t\t}\n\n\t\treturn (*target = new Node(p, x, &r))->splay();\n\t}\n\n\tint rank(const int x) {\n\t\tNode *v = find(x);\n\t\tint res;\n\t\tif (v) res = v->left();\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tres = v->left();\n\t\t\terase(v);\n\t\t}\n#ifdef DBG\n\t\tprintf(\"rank(%d) in (%d) = %d\\n\", x, id, res);\n#endif\n\t\treturn res;\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (!(x >= v->left() + 1 && x <= v->left() + v->cnt)) {\n\t\t\tif (x < v->left() + 1) v = v->c[L];\n\t\t\telse x -= v->left() + v->cnt, v = v->c[R];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->cnt != 1) {\n\t\t\tv->cnt--, v->size--;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode *prec = v->prec(), *succ = v->succ();\n\n\t\tprec->splay();\n\t\tsucc->splay(prec);\n\n\t\tdelete succ->c[L];\n\t\tsucc->c[L] = NULL;\n\n\t\tsucc->maintain(), prec->maintain();\n\t}\n\n\tvoid erase(const int x) {\n\t\tNode *v = find(x);\n\t\terase(v);\n\t}\n\n\tint prec(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->prec()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->prec()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint succ(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->succ()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tr->validate();\n\t}\n#endif\n};\n\n#ifdef DBG\nvoid Splay::Node::print(const int depth) {\n\tif (c[L]) c[L]->print(depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' '), putchar(' ');\n\tprintf(\"%d\\n\", val);\n\tif (c[R]) c[R]->print(depth + 1);\n}\n#endif\n\nint map[MAXM + MAXN], max;\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tSplay s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n\n线段树套带垃圾回收的动态开点的权值线段树，MLE。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\nint map[MAXM + MAXN], max;\n\nstruct WeightSegmentTree {\n\tint l, r, mid;\n\tWeightSegmentTree *lc, *rc;\n\tint min, max, cnt;\n\n\tWeightSegmentTree(const int l, const int r)\n\t\t: l(l), r(r), mid(l + (r - l) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{}\n\n\tWeightSegmentTree(const int *a, const int n)\n\t\t: l(0), r(::max - 1), mid((max - 1) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~WeightSegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tvoid maintain() {\n\t\tmin = INT_MAX;\n\t\tif (lc) min = std::min(min, lc->min);\n\t\tif (rc) min = std::min(min, rc->min);\n\n\t\tmax = INT_MIN;\n\t\tif (lc) max = std::max(max, lc->max);\n\t\tif (rc) max = std::max(max, rc->max);\n\n\t\tcnt = 0;\n\t\tif (lc) cnt += lc->cnt;\n\t\tif (rc) cnt += rc->cnt;\n\t}\n\n\tvoid insert(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!cnt++) min = max = x;\n\t\t} else {\n\t\t\tif (x <= mid) {\n\t\t\t\tif (!lc) lc = new WeightSegmentTree(l, mid);\n\t\t\t\tlc->insert(x);\n\t\t\t} else {\n\t\t\t\tif (!rc) rc = new WeightSegmentTree(mid + 1, r);\n\t\t\t\trc->insert(x);\n\t\t\t}\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tvoid erase(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!--cnt) min = INT_MAX, max = INT_MIN;\n\t\t} else {\n\t\t\tif (x <= mid) lc->erase(x);\n\t\t\telse rc->erase(x);\n\t\t\tmaintain();\n\t\t\tif (x <= mid && lc->cnt == 0) delete lc, lc = NULL;\n\t\t\telse if (x > mid && rc->cnt == 0) delete rc, rc = NULL;\n\t\t}\n\t}\n\n\tint prec(const int x) {\n\t\treturn queryMax(0, x - 1);\n\t}\n\n\tint succ(const int x) {\n\t\treturn queryMin(x + 1, ::max);\n\t}\n\n\tint rank(const int x) {\n\t\treturn queryCnt(0, x - 1) + 1;\n\t}\n\n\tint select(const int k) {\n\t\tint x = k;\n\t\tWeightSegmentTree *v = this;\n\t\twhile (v->l != v->r) {\n\t\t\tif (!v->lc) v = v->rc;\n\t\t\telse if (x <= v->lc->cnt) v = v->lc;\n\t\t\telse x -= v->lc->cnt, v = v->rc;\n\t\t}\n\t\treturn v->mid;\n\t}\n\n\tint queryMin(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return min;\n\t\telse {\n\t\t\tint res = INT_MAX;\n\t\t\tif (lc) res = lc->queryMin(l, r);\n\t\t\tif (res == INT_MAX && rc) return rc->queryMin(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse {\n\t\t\tint res = INT_MIN;\n\t\t\tif (rc) res = rc->queryMax(l, r);\n\t\t\tif (res == INT_MIN && lc) return lc->queryMax(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryCnt(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tif (lc) res += lc->queryCnt(l, r);\n\t\t\tif (rc) res += rc->queryCnt(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tWeightSegmentTree s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-3196","published":1,"updated":"2017-01-02T07:05:01.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9seb01h1ooxlnh5z10y5"},{"title":"「BZOJ 3156」防御准备 - 斜率优化 DP","date":"2016-05-19T03:58:00.000Z","_content":"\n我们定义战线为一条长度为 $ n $ 的序列，在这条战线上共设有 $ n $ 个检查点，从左到右依次标号为 $ 1 $ 到 $ n $。一个战线为合法战线当且仅当任意一个检查点可以通过安全检查。对于第 $ i $ 个点，通过安全检查的方法有两种，第一种是放置一个守卫塔，这将花费 $ c(i) $ 的费用，第二种方式是放置一个木偶，放置木偶的花费等于这个检查点右侧的第一个守卫塔到它的距离。第 $ n $ 个点只能放置守卫塔。求最小的战线花费值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3156](http://www.lydsy.com/JudgeOnline/problem.php?id=3156)\n\n### 题解\n将整个序列反转，放置木偶的花费等于这个检查点**左侧**的第一个守卫塔到它的距离，一号检查点必须放置守卫塔。\n\n设 $ f(i) $ 表示前 $ i $ 个检查点通过检查的最小代价，枚举 $ j $，在 $ j + 1 $ 位置放置一个守卫塔，之后一直到 $ i $ 的位置全部放置木偶。\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + \\frac{(i - j - 1)(i - j)}{2} \\} $$\n\n斜率优化，考虑两个决策 $ a $、$ b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + \\frac{(i - a - 1)(i - a)}{2} &< f(b) + c(b + 1) + \\frac{(i - b - 1)(i - b)}{2} \\\\\nf(a) + c(a + 1) + \\frac{i ^ 2}{2} + \\frac{a ^ 2}{2} - ia - \\frac{i}{2} + \\frac{a}{2} &< f(b) + c(b + 1) + \\frac{i ^ 2}{2} + \\frac{b ^ 2}{2} - ib - \\frac{i}{2} + \\frac{b}{2} \\\\\n{ (f(a) + c(a + 1) + \\frac{a ^ 2}{2} + \\frac{a}{2}) - (f(b) + c(b + 1) + \\frac{b ^ 2}{2} + \\frac{b}{2}) \\over a - b } &< i \\\\\n\\end{align*}\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long c[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n\tstd::reverse(c + 1, c + n + 1);\n}\n\n/*\ninline void force() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _j = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (f[i] > f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) {\n\t\t\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t\t\t_j = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d --> %d\\n\", i, _j);\n\t}\n}\n*/\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast<long long>(i)) * 0.5 + i * 0.5; }\n\ninline double slope(const int a, const int b) {\n\treturn double(x(a) - x(b))\n\t\t / double(a - b);\n}\n\ninline void dp() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\n\tstatic int q[MAXN];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (l < r && slope(*(l + 1), *l) < i) l++;\n\n\t\tint &j = *l;\n\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t// printf(\"%d --> %d\\n\", i, j);\n\n\t\tif (i < n) {\n\t\t\twhile (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n\t\t\t*++r = i;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\n\tprepare();\n\n\t// force();\n\tdp();\n\tprintf(\"%lld\\n\", f[n]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3156.md","raw":"title: 「BZOJ 3156」防御准备 - 斜率优化 DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - 单调队列\n  - 斜率优化\npermalink: bzoj-3156\ndate: 2016-05-19 11:58:00\n---\n\n我们定义战线为一条长度为 $ n $ 的序列，在这条战线上共设有 $ n $ 个检查点，从左到右依次标号为 $ 1 $ 到 $ n $。一个战线为合法战线当且仅当任意一个检查点可以通过安全检查。对于第 $ i $ 个点，通过安全检查的方法有两种，第一种是放置一个守卫塔，这将花费 $ c(i) $ 的费用，第二种方式是放置一个木偶，放置木偶的花费等于这个检查点右侧的第一个守卫塔到它的距离。第 $ n $ 个点只能放置守卫塔。求最小的战线花费值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3156](http://www.lydsy.com/JudgeOnline/problem.php?id=3156)\n\n### 题解\n将整个序列反转，放置木偶的花费等于这个检查点**左侧**的第一个守卫塔到它的距离，一号检查点必须放置守卫塔。\n\n设 $ f(i) $ 表示前 $ i $ 个检查点通过检查的最小代价，枚举 $ j $，在 $ j + 1 $ 位置放置一个守卫塔，之后一直到 $ i $ 的位置全部放置木偶。\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + \\frac{(i - j - 1)(i - j)}{2} \\} $$\n\n斜率优化，考虑两个决策 $ a $、$ b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + \\frac{(i - a - 1)(i - a)}{2} &< f(b) + c(b + 1) + \\frac{(i - b - 1)(i - b)}{2} \\\\\nf(a) + c(a + 1) + \\frac{i ^ 2}{2} + \\frac{a ^ 2}{2} - ia - \\frac{i}{2} + \\frac{a}{2} &< f(b) + c(b + 1) + \\frac{i ^ 2}{2} + \\frac{b ^ 2}{2} - ib - \\frac{i}{2} + \\frac{b}{2} \\\\\n{ (f(a) + c(a + 1) + \\frac{a ^ 2}{2} + \\frac{a}{2}) - (f(b) + c(b + 1) + \\frac{b ^ 2}{2} + \\frac{b}{2}) \\over a - b } &< i \\\\\n\\end{align*}\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long c[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n\tstd::reverse(c + 1, c + n + 1);\n}\n\n/*\ninline void force() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _j = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (f[i] > f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) {\n\t\t\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t\t\t_j = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d --> %d\\n\", i, _j);\n\t}\n}\n*/\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast<long long>(i)) * 0.5 + i * 0.5; }\n\ninline double slope(const int a, const int b) {\n\treturn double(x(a) - x(b))\n\t\t / double(a - b);\n}\n\ninline void dp() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\n\tstatic int q[MAXN];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (l < r && slope(*(l + 1), *l) < i) l++;\n\n\t\tint &j = *l;\n\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t// printf(\"%d --> %d\\n\", i, j);\n\n\t\tif (i < n) {\n\t\t\twhile (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n\t\t\t*++r = i;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\n\tprepare();\n\n\t// force();\n\tdp();\n\tprintf(\"%lld\\n\", f[n]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3156","published":1,"updated":"2016-10-24T23:33:42.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sel01h9ooxlbob18bs1"},{"title":"「BZOJ 2820」YY的GCD - 莫比乌斯反演","date":"2016-04-07T14:24:12.000Z","_content":"\n求 $ 1 \\leq x \\leq N $，$ 1 \\leq y \\leq M $ 且 $ \\gcd(x, y) $ 为质数的 $ (x, y) $ 数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### 题解\n首先，我们只需要处理 $ N \\leq M $ 的情况，当 $ M \\lt N $ 的情况只需要交换 $ N $ 和 $ M $ 即可。\n\n设小于 $ N $ 质数为 $ p_1, p_2, …, p_n $，则答案为\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n根据莫比乌斯反演，我们有\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n令 $ T = p_k \\times d $\t，我们在外层枚举 $ T $ 然后对每个质因子计算 $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n设\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times … p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times … p_n ^ {x_n} $$\n\n考虑线性筛求 $ \\mu $ 的过程，当 $ T' \\ {\\rm mod} \\ p_1 = 0 $ 时\n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n当 $ x_1 \\gt 1 $ 时\n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n线性筛后分块处理即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2820.md","raw":"title: 「BZOJ 2820」YY的GCD - 莫比乌斯反演\ncategories: OI\ntags: \n  - BZOJ\n  - 莫比乌斯反演\n  - 数论\n  - 线性筛\n  - 数学\npermalink: bzoj-2820\ndate: 2016-04-07 22:24:12\n---\n\n求 $ 1 \\leq x \\leq N $，$ 1 \\leq y \\leq M $ 且 $ \\gcd(x, y) $ 为质数的 $ (x, y) $ 数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### 题解\n首先，我们只需要处理 $ N \\leq M $ 的情况，当 $ M \\lt N $ 的情况只需要交换 $ N $ 和 $ M $ 即可。\n\n设小于 $ N $ 质数为 $ p_1, p_2, …, p_n $，则答案为\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n根据莫比乌斯反演，我们有\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n令 $ T = p_k \\times d $\t，我们在外层枚举 $ T $ 然后对每个质因子计算 $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n设\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times … p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times … p_n ^ {x_n} $$\n\n考虑线性筛求 $ \\mu $ 的过程，当 $ T' \\ {\\rm mod} \\ p_1 = 0 $ 时\n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n当 $ x_1 \\gt 1 $ 时\n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n线性筛后分块处理即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2820","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ses01hfooxlfbrle23q"},{"title":"「BZOJ 2716」天使玩偶 - CDQ","date":"2016-06-25T03:08:00.000Z","_content":"\n维护一个平面，支持以下两种操作：\n\n1. 加入点 $ (x,\\ y) $；\n2. 查询**麦哈顿距离**与点 $ (x,\\ y) $ 最小的点。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2716](http://www.lydsy.com/JudgeOnline/problem.php?id=2716)\n\n### 题解\n任意两个点 $ (x_1,\\ y_1) $、$ (x_2,\\ y_2) $ 的麦哈顿距离为 $ | x_1 - x_2 | + | y_1 - y_2 | $。\n\n当 $ (x_1,\\ y_1) $ 在 $ (x_2,\\ y_2) $ 左下方时，其麦哈顿距离为：\n\n$$\n\\begin{aligned}\n & | x_1 - x_2 | + | y_1 - y_2 | \\\\\n=& ( x_1 - x_2 ) + ( y_1 - y_2 ) \\\\\n=& ( x_1 + y_1 ) - (x_2 + y_2)\n\\end{aligned}\n$$\n\n问题转化为数据结构维护 $ (x_2 + y_2) $ 的最大值，很明显这是一个三维偏序问题，可以使用 CDQ 分治解决，将传统的 CDQ 分治中的累加改为取较小值即可。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 1000000;\n\nstruct Triple {\n\tint id, x, y, *ans;\n\n\tTriple() {}\n\n\tTriple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) {\n\t\tstatic int i = 0;\n\t\tid = i++;\n\t}\n} a[MAXN + MAXM];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.id < b.id;\n}\n\nint maxX, maxY;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int v) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v);\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, q->x + q->y);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) {\n\t\t\t\tint res = bit.query(q->y);\n\t\t\t\tif (res) *q->ans = std::min(*q->ans, q->x + q->y - res);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; p++, q++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\\n\", &x, &y), x += 2, y += 2;\n\t\ta[cnt++] = Triple(x, y);\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint qCnt = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d %d %d\", &t, &x, &y), x += 2, y += 2;\n\t\tif (t == 1) {\n\t\t\ta[cnt++] = Triple(x, y);\n\t\t} else {\n\t\t\ta[cnt++] = Triple(x, y, &ans[qCnt++]);\n\t\t}\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tfor (int i = 0; i < qCnt; i++) ans[i] = INT_MAX;\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].y = maxY - a[i].y + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qCnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2716.md","raw":"title: 「BZOJ 2716」天使玩偶 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - 数据结构\n  - CDQ\n  - 树状数组\n  - 分治\npermalink: bzoj-2716\ndate: 2016-06-25 11:08:00\n---\n\n维护一个平面，支持以下两种操作：\n\n1. 加入点 $ (x,\\ y) $；\n2. 查询**麦哈顿距离**与点 $ (x,\\ y) $ 最小的点。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2716](http://www.lydsy.com/JudgeOnline/problem.php?id=2716)\n\n### 题解\n任意两个点 $ (x_1,\\ y_1) $、$ (x_2,\\ y_2) $ 的麦哈顿距离为 $ | x_1 - x_2 | + | y_1 - y_2 | $。\n\n当 $ (x_1,\\ y_1) $ 在 $ (x_2,\\ y_2) $ 左下方时，其麦哈顿距离为：\n\n$$\n\\begin{aligned}\n & | x_1 - x_2 | + | y_1 - y_2 | \\\\\n=& ( x_1 - x_2 ) + ( y_1 - y_2 ) \\\\\n=& ( x_1 + y_1 ) - (x_2 + y_2)\n\\end{aligned}\n$$\n\n问题转化为数据结构维护 $ (x_2 + y_2) $ 的最大值，很明显这是一个三维偏序问题，可以使用 CDQ 分治解决，将传统的 CDQ 分治中的累加改为取较小值即可。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 1000000;\n\nstruct Triple {\n\tint id, x, y, *ans;\n\n\tTriple() {}\n\n\tTriple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) {\n\t\tstatic int i = 0;\n\t\tid = i++;\n\t}\n} a[MAXN + MAXM];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.id < b.id;\n}\n\nint maxX, maxY;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int v) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v);\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, q->x + q->y);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) {\n\t\t\t\tint res = bit.query(q->y);\n\t\t\t\tif (res) *q->ans = std::min(*q->ans, q->x + q->y - res);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; p++, q++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\\n\", &x, &y), x += 2, y += 2;\n\t\ta[cnt++] = Triple(x, y);\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint qCnt = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d %d %d\", &t, &x, &y), x += 2, y += 2;\n\t\tif (t == 1) {\n\t\t\ta[cnt++] = Triple(x, y);\n\t\t} else {\n\t\t\ta[cnt++] = Triple(x, y, &ans[qCnt++]);\n\t\t}\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tfor (int i = 0; i < qCnt; i++) ans[i] = INT_MAX;\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].y = maxY - a[i].y + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qCnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2716","published":1,"updated":"2016-06-25T03:08:50.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sez01hmooxlc2dlr6n3"},{"title":"「BZOJ 2683」简单题 - CDQ","id":"43","updated":"2016-02-05T14:46:27.000Z","date":"2016-02-05T14:42:35.000Z","_content":"\n有一个$N*N$的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作：\n\n1. 将格子$(x,y)$里的数字加上$A$；\n2. 输出$(x1,y1)(x2,y2)$这个矩形内的数字和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### 题解\n题解见 [BZOJ 1176](bzoj-1176)。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2683.md","raw":"title: 「BZOJ 2683」简单题 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - 树状数组\n  - 数据结构\n  - 分治\npermalink: bzoj-2683\nid: 43\nupdated: '2016-02-05 22:46:27'\ndate: 2016-02-05 22:42:35\n---\n\n有一个$N*N$的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作：\n\n1. 将格子$(x,y)$里的数字加上$A$；\n2. 输出$(x1,y1)(x2,y2)$这个矩形内的数字和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### 题解\n题解见 [BZOJ 1176](bzoj-1176)。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2683","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sf701htooxlxaoc9nf8"},{"title":"「BZOJ 2580」Video Game - AC 自动机","date":"2016-09-17T23:16:00.000Z","_content":"\n给出 $ n $ 个串 $ s_i $，求一个长度为 $ k $ 的串 $ S $，使 $ S $ 匹配 $ s_i $（可重叠）的次数最多。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2580](http://www.lydsy.com/JudgeOnline/problem.php?id=2580)\n\n### 题解\n设 $ f(i, j) $ 表示已生成的 $ k - i $ 个字符组成的串在 AC 自动机上匹配的状态为第 $ j $ 个节点，之后再生成 $ i $ 个字符后的总最大匹配数量。\n\n枚举下一个字符，如果是单词节点则对应答案为当前匹配数量 $ + $ 目标节点单词数量（自身单词和由后缀链接能转移到的单词），否则为当前匹配数量。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 15;\nconst int MAXM = 20;\nconst int MAXK = 1000;\nconst int CHARSET_SIZE = 26;\nconst int BASE_CHAR = 'A';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint wordCnt, id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tv->id = vec.size();\n#ifdef DBG\n\t\t\tprintf(\"wordCnt(%d) = %d\\n\", v->id, v->wordCnt);\n#endif\n\t\t\tvec.push_back(v);\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tc->wordCnt = c->isWord + (c->next ? c->next->wordCnt : 0);\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\twhile (n--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tstd::vector<Trie::Node *> vec;\n\tt.build(vec);\n\n\tstatic int f[MAXN * MAXM + 1][MAXK + 1];\n#ifdef DBG\n\tstatic char g[MAXN * MAXM + 1][MAXK + 1];\n#endif\n\t// for (size_t i = 0; i < vec.size(); i++) f[i][0] = vec[i]->wordCnt;\n\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tint t = f[vec[j]->c[k]->id][i - 1] + vec[j]->c[k]->wordCnt;\n\t\t\t\tif (t >= f[j][i]) {\n\t\t\t\t\tf[j][i] = t;\n#ifdef DBG\n\t\t\t\t\tg[j][i] = k;\n#endif\n\t\t\t\t}\n\t\t\t}\n#ifdef DBG\n\t\t\tprintf(\"f(%lu, %d) = %d\\n\", j, i, f[j][i]);\n#endif\n\t\t}\n\t}\n\n#ifdef DBG\n\tint last = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tputchar(g[last][i] + 'A');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n\tputchar('\\n');\n\n\tlast = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tprintf(\"%d%c\", last, i == 1 ? '\\n' : ' ');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n#endif\n\n\tprintf(\"%d\\n\", f[0][k]);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2580.md","raw":"title: 「BZOJ 2580」Video Game - AC 自动机\ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - 字符串\n  - AC 自动机\n  - DP\npermalink: bzoj-2580\ndate: 2016-09-18 07:16:00\n---\n\n给出 $ n $ 个串 $ s_i $，求一个长度为 $ k $ 的串 $ S $，使 $ S $ 匹配 $ s_i $（可重叠）的次数最多。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2580](http://www.lydsy.com/JudgeOnline/problem.php?id=2580)\n\n### 题解\n设 $ f(i, j) $ 表示已生成的 $ k - i $ 个字符组成的串在 AC 自动机上匹配的状态为第 $ j $ 个节点，之后再生成 $ i $ 个字符后的总最大匹配数量。\n\n枚举下一个字符，如果是单词节点则对应答案为当前匹配数量 $ + $ 目标节点单词数量（自身单词和由后缀链接能转移到的单词），否则为当前匹配数量。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 15;\nconst int MAXM = 20;\nconst int MAXK = 1000;\nconst int CHARSET_SIZE = 26;\nconst int BASE_CHAR = 'A';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint wordCnt, id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tv->id = vec.size();\n#ifdef DBG\n\t\t\tprintf(\"wordCnt(%d) = %d\\n\", v->id, v->wordCnt);\n#endif\n\t\t\tvec.push_back(v);\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tc->wordCnt = c->isWord + (c->next ? c->next->wordCnt : 0);\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\twhile (n--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tstd::vector<Trie::Node *> vec;\n\tt.build(vec);\n\n\tstatic int f[MAXN * MAXM + 1][MAXK + 1];\n#ifdef DBG\n\tstatic char g[MAXN * MAXM + 1][MAXK + 1];\n#endif\n\t// for (size_t i = 0; i < vec.size(); i++) f[i][0] = vec[i]->wordCnt;\n\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tint t = f[vec[j]->c[k]->id][i - 1] + vec[j]->c[k]->wordCnt;\n\t\t\t\tif (t >= f[j][i]) {\n\t\t\t\t\tf[j][i] = t;\n#ifdef DBG\n\t\t\t\t\tg[j][i] = k;\n#endif\n\t\t\t\t}\n\t\t\t}\n#ifdef DBG\n\t\t\tprintf(\"f(%lu, %d) = %d\\n\", j, i, f[j][i]);\n#endif\n\t\t}\n\t}\n\n#ifdef DBG\n\tint last = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tputchar(g[last][i] + 'A');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n\tputchar('\\n');\n\n\tlast = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tprintf(\"%d%c\", last, i == 1 ? '\\n' : ' ');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n#endif\n\n\tprintf(\"%d\\n\", f[0][k]);\n\n\treturn 0;\n}\n```","slug":"bzoj-2580","published":1,"updated":"2016-09-17T23:25:45.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sfg01i0ooxlihy27wv6"},{"title":"「BZOJ 2565」最长双回文串 - Manacher","date":"2017-01-02T08:29:00.000Z","_content":"\n输入串 $ S $，求 $ S $ 的最长双回文子串 $ T $，即可将 $ T $ 分为两部分 $ X $、$ Y $（$ |X|, |Y| \\geq 1 $）且 $ X $ 和 $ Y $ 都是回文串。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2565](http://www.lydsy.com/JudgeOnline/problem.php?id=2565)\n\n### 题解\n首先用 Manacher 求出以每个位置为中心的最长回文半径 $ r(i) $。\n\n用 $ \\mathrm{right}(i) $ 表示以第 $ i $ 个位置为最右字符的最长回文串长度，$ \\mathrm{left}(i) $ 表示以第 $ i $ 个位置为最左字符的最长回文串长度。扫描 $ r(i) $，更新每个回文串的两端点。\n\n此时只有以每个位置为中心的最长回文子串的左右端点的 $ \\mathrm{right}(i) $ 和 $ \\mathrm{left}(i) $ 有效。注意到 $ \\mathrm{right}(i) $ 一定不小于 $ \\mathrm{right}(i + 1) - 1 $，对于 $ \\mathrm{left}(i) $ 也有相似的结论。正反分别扫一遍，更新 $ \\mathrm{right}(i) $ 和 $ \\mathrm{left}(i) $ 即可。\n\n最后枚举每一个分隔符 `#`，统计答案即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\n\nchar s1[MAXN + 2], s2[MAXN * 2 + 2];\nint n, len, r[MAXN * 2 + 2];\n\ninline void prepare() {\n\tn = strlen(s1 + 1);\n\n\ts2[++len] = '@';\n\ts2[++len] = '#';\n\tfor (int i = 1; i <= n; i++) {\n\t\ts2[++len] = s1[i];\n\t\ts2[++len] = '#';\n\t}\n\n\ts2[++len] = '\\0';\n}\n\ninline void manacher() {\n\tint right = 0, pos = -1;\n\tfor (int i = 1; i <= len; i++) {\n\t\tint x;\n\n\t\tif (right < i) x = 1;\n\t\telse x = std::min(r[2 * pos - i], right - i);\n\n\t\twhile (s2[i - x] == s2[i + x]) x++;\n\n\t\tif (x + i > right) {\n\t\t\tright = x + i;\n\t\t\tpos = i;\n\t\t}\n\n\t\tr[i] = x;\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s1 + 1);\n\n\tprepare();\n\tmanacher();\n\n\t// puts(s2 + 1);\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", r[i], i == len ? '\\n' : ' ');\n\t// for (int i = 1; i <= len; i++) printf(\"%c%c\", s2[i], i == len ? '\\n' : ' ');\n\n\tstatic int right[MAXN * 2 + 2], left[MAXN * 2 + 2];\n\tfor (int i = 1; i <= len; i++) {\n\t\tif (i + r[i] - 1 <= len) right[i + r[i] - 1] = std::max(right[i + r[i] - 1], r[i] - 1);\n\t\tif (i - r[i] + 1 >= 0) left[i - r[i] + 1] = std::max(left[i - r[i] + 1], r[i] - 1);\n\t}\n\n\tfor (int i = 2; i <= len; i++) {\n\t\tleft[i] = std::max(left[i], left[i - 1] - 1);\n\t\t// if (s2[i - 1 - right[i - 1]] == s2[i + 1]) right[i] = std::max(right[i], right[i - 1] + 1);\n\t}\n\n\tfor (int i = len - 1; i >= 1; i--) {\n\t\tright[i] = std::max(right[i], right[i + 1] - 1);\n\t\t// if (s2[i + 1 + left[i + 1]] == s2[i - 1]) left[i] = std::max(left[i], left[i + 1] + 1);\n\t}\n\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", right[i], i == len ? '\\n' : ' ');\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", left[i], i == len ? '\\n' : ' ');\n\n\tint ans = 0;\n\tfor (int i = 1; i <= len; i++) {\n\t\tif (s2[i] == '#') {\n\t\t\tans = std::max(ans, right[i] + left[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2565.md","raw":"title: 「BZOJ 2565」最长双回文串 - Manacher\ncategories: OI\ntags: \n  - BZOJ\n  - 字符串\n  - Manacher\npermalink: bzoj-2565\ndate: 2017-01-02 16:29:00\n---\n\n输入串 $ S $，求 $ S $ 的最长双回文子串 $ T $，即可将 $ T $ 分为两部分 $ X $、$ Y $（$ |X|, |Y| \\geq 1 $）且 $ X $ 和 $ Y $ 都是回文串。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2565](http://www.lydsy.com/JudgeOnline/problem.php?id=2565)\n\n### 题解\n首先用 Manacher 求出以每个位置为中心的最长回文半径 $ r(i) $。\n\n用 $ \\mathrm{right}(i) $ 表示以第 $ i $ 个位置为最右字符的最长回文串长度，$ \\mathrm{left}(i) $ 表示以第 $ i $ 个位置为最左字符的最长回文串长度。扫描 $ r(i) $，更新每个回文串的两端点。\n\n此时只有以每个位置为中心的最长回文子串的左右端点的 $ \\mathrm{right}(i) $ 和 $ \\mathrm{left}(i) $ 有效。注意到 $ \\mathrm{right}(i) $ 一定不小于 $ \\mathrm{right}(i + 1) - 1 $，对于 $ \\mathrm{left}(i) $ 也有相似的结论。正反分别扫一遍，更新 $ \\mathrm{right}(i) $ 和 $ \\mathrm{left}(i) $ 即可。\n\n最后枚举每一个分隔符 `#`，统计答案即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\n\nchar s1[MAXN + 2], s2[MAXN * 2 + 2];\nint n, len, r[MAXN * 2 + 2];\n\ninline void prepare() {\n\tn = strlen(s1 + 1);\n\n\ts2[++len] = '@';\n\ts2[++len] = '#';\n\tfor (int i = 1; i <= n; i++) {\n\t\ts2[++len] = s1[i];\n\t\ts2[++len] = '#';\n\t}\n\n\ts2[++len] = '\\0';\n}\n\ninline void manacher() {\n\tint right = 0, pos = -1;\n\tfor (int i = 1; i <= len; i++) {\n\t\tint x;\n\n\t\tif (right < i) x = 1;\n\t\telse x = std::min(r[2 * pos - i], right - i);\n\n\t\twhile (s2[i - x] == s2[i + x]) x++;\n\n\t\tif (x + i > right) {\n\t\t\tright = x + i;\n\t\t\tpos = i;\n\t\t}\n\n\t\tr[i] = x;\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s1 + 1);\n\n\tprepare();\n\tmanacher();\n\n\t// puts(s2 + 1);\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", r[i], i == len ? '\\n' : ' ');\n\t// for (int i = 1; i <= len; i++) printf(\"%c%c\", s2[i], i == len ? '\\n' : ' ');\n\n\tstatic int right[MAXN * 2 + 2], left[MAXN * 2 + 2];\n\tfor (int i = 1; i <= len; i++) {\n\t\tif (i + r[i] - 1 <= len) right[i + r[i] - 1] = std::max(right[i + r[i] - 1], r[i] - 1);\n\t\tif (i - r[i] + 1 >= 0) left[i - r[i] + 1] = std::max(left[i - r[i] + 1], r[i] - 1);\n\t}\n\n\tfor (int i = 2; i <= len; i++) {\n\t\tleft[i] = std::max(left[i], left[i - 1] - 1);\n\t\t// if (s2[i - 1 - right[i - 1]] == s2[i + 1]) right[i] = std::max(right[i], right[i - 1] + 1);\n\t}\n\n\tfor (int i = len - 1; i >= 1; i--) {\n\t\tright[i] = std::max(right[i], right[i + 1] - 1);\n\t\t// if (s2[i + 1 + left[i + 1]] == s2[i - 1]) left[i] = std::max(left[i], left[i + 1] + 1);\n\t}\n\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", right[i], i == len ? '\\n' : ' ');\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", left[i], i == len ? '\\n' : ' ');\n\n\tint ans = 0;\n\tfor (int i = 1; i <= len; i++) {\n\t\tif (s2[i] == '#') {\n\t\t\tans = std::max(ans, right[i] + left[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"bzoj-2565","published":1,"updated":"2017-01-02T08:30:04.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sfo01i7ooxlz6m9wk11"},{"title":"「BeiJing2011」矩阵模板 - AC 自动机","date":"2016-09-13T23:32:00.000Z","_content":"\n给定一个 $ M $ 行 $ N $ 列的 01 矩阵，以及 $ Q $ 个 $ A $ 行 $ B $ 列的 01 矩阵，你需要求出这 $ Q $ 个矩阵哪些在原矩阵中出现过。 \n\n<!-- more -->\n\n### 链接\n[BZOJ 2462](http://www.lydsy.com/JudgeOnline/problem.php?id=2462)\n\n### 题解\n对模式矩阵的每一行建立 AC 自动机，匹配目标矩阵的每一行。如果目标矩阵的第 $ i $ 行在第 $ j $ 个字符处完成了对模式矩阵的第 $ k $ 行的匹配，则对以 $ (i - k, j - b + 1) $ 为左上角的子矩阵有 $ 1 $ 的贡献（表示这个位置的矩阵有一行被匹配了）。\n\n统计答案时，如果某个位置的值 $ \\geq b $，则该模式矩阵可以匹配。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint id;\n\n\t\tNode(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply(std::vector< std::pair<int, int> > &vec, const int pos) {\n\t\t\tassert(isWord);\n\t\t\tvec.push_back(std::make_pair(pos, id));\n\t\t\tif (next) next->apply(vec, pos);\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\ttemplate <typename T>\n\tvoid insert(const T *begin, const T *end, const int id) {\n\t\tNode **v = &root;\n\t\tfor (const T *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, id);\n\t\telse (*v)->id = id, (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const bool *begin, const bool *end, std::vector< std::pair<int, int> > &vec) {\n\t\tNode *v = root;\n\t\tfor (const bool *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply(vec, p - begin);\n\t\t\telse if (v->next) v->next->apply(vec, p - begin);\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\troot = NULL;\n\t}\n} t;\n\nint main() {\n\tint n, m, a, b;\n\tscanf(\"%d %d %d %d\", &n, &m, &a, &b);\n\n\tstatic bool matrix[MAXN][MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < m; j++) matrix[i][j] = s[j] - BASE_CHAR;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tt.clear();\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tstatic char s[MAXN + 1];\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor (int j = 0; j < b; j++) s[j] -= BASE_CHAR;\n\t\t\tt.insert(s, s + b, i);\n\t\t}\n\n\t\tt.build();\n\n\t\tstatic int matchCnt[MAXN][MAXN];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::vector< std::pair<int, int> > vec;\n\t\t\tt.exec(matrix[i], matrix[i] + m, vec);\n\t\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n \t\t\t\t// printf(\"%d matched %d\\n\", i, *it);\n\t\t\t\tif (i - it->second >= 0) matchCnt[i - it->second][it->first - b + 1]++;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// printf(\"match(%d) = %d\\n\", i, matchCnt[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (matchCnt[i][j] >= b) flag = true;\n\t\t\t\tmatchCnt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(flag ? \"1\" : \"0\");\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2462.md","raw":"title: 「BeiJing2011」矩阵模板 - AC 自动机\ncategories: OI\ntags: \n  - BZOJ\n  - 字符串\n  - AC 自动机\npermalink: bzoj-2462\ndate: 2016-09-14 07:32:00\n---\n\n给定一个 $ M $ 行 $ N $ 列的 01 矩阵，以及 $ Q $ 个 $ A $ 行 $ B $ 列的 01 矩阵，你需要求出这 $ Q $ 个矩阵哪些在原矩阵中出现过。 \n\n<!-- more -->\n\n### 链接\n[BZOJ 2462](http://www.lydsy.com/JudgeOnline/problem.php?id=2462)\n\n### 题解\n对模式矩阵的每一行建立 AC 自动机，匹配目标矩阵的每一行。如果目标矩阵的第 $ i $ 行在第 $ j $ 个字符处完成了对模式矩阵的第 $ k $ 行的匹配，则对以 $ (i - k, j - b + 1) $ 为左上角的子矩阵有 $ 1 $ 的贡献（表示这个位置的矩阵有一行被匹配了）。\n\n统计答案时，如果某个位置的值 $ \\geq b $，则该模式矩阵可以匹配。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint id;\n\n\t\tNode(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply(std::vector< std::pair<int, int> > &vec, const int pos) {\n\t\t\tassert(isWord);\n\t\t\tvec.push_back(std::make_pair(pos, id));\n\t\t\tif (next) next->apply(vec, pos);\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\ttemplate <typename T>\n\tvoid insert(const T *begin, const T *end, const int id) {\n\t\tNode **v = &root;\n\t\tfor (const T *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, id);\n\t\telse (*v)->id = id, (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const bool *begin, const bool *end, std::vector< std::pair<int, int> > &vec) {\n\t\tNode *v = root;\n\t\tfor (const bool *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply(vec, p - begin);\n\t\t\telse if (v->next) v->next->apply(vec, p - begin);\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\troot = NULL;\n\t}\n} t;\n\nint main() {\n\tint n, m, a, b;\n\tscanf(\"%d %d %d %d\", &n, &m, &a, &b);\n\n\tstatic bool matrix[MAXN][MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < m; j++) matrix[i][j] = s[j] - BASE_CHAR;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tt.clear();\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tstatic char s[MAXN + 1];\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor (int j = 0; j < b; j++) s[j] -= BASE_CHAR;\n\t\t\tt.insert(s, s + b, i);\n\t\t}\n\n\t\tt.build();\n\n\t\tstatic int matchCnt[MAXN][MAXN];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::vector< std::pair<int, int> > vec;\n\t\t\tt.exec(matrix[i], matrix[i] + m, vec);\n\t\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n \t\t\t\t// printf(\"%d matched %d\\n\", i, *it);\n\t\t\t\tif (i - it->second >= 0) matchCnt[i - it->second][it->first - b + 1]++;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// printf(\"match(%d) = %d\\n\", i, matchCnt[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (matchCnt[i][j] >= b) flag = true;\n\t\t\t\tmatchCnt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(flag ? \"1\" : \"0\");\n\t}\n\n\treturn 0;\n}\n```","slug":"bzoj-2462","published":1,"updated":"2016-09-13T23:41:03.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sfu01icooxl6b4q2hml"},{"title":"「BZOJ 2456」mode - 乱搞","date":"2016-06-17T14:07:00.000Z","_content":"\n给你一个 $ n $ 个数的数列，其中某个数出现了超过 $ n \\over 2 $ 次即众数，请你找出那个数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2456](http://www.lydsy.com/JudgeOnline/problem.php?id=2456)\n\n### 题解\n$ 500,000 $ 的数据，$ \\text {1M} $ 内存是存不下的，考虑空间复杂度为 $ O(1) $ 的做法。\n\n如果众数出现了超过 $ n \\over 2 $ 次，那么任意删除序列中的两个不同的数，众数的出现次数仍然超过一半。不停地进行下去，最终剩下的一个数即为众数。\n\n实现时，记录一个「当前的数」和它的「出现次数」，删除一次则出现次数减一，出现次数为 $ 0 $ 时用读入的数更新当前的数。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 500000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = -1, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (cnt == 0) {\n\t\t\tans = x;\n\t\t\tcnt = 1;\n\t\t} else {\n\t\t\tif (ans == x) {\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2456.md","raw":"title: 「BZOJ 2456」mode - 乱搞\ncategories: OI\ntags: \n  - BZOJ\n  - 乱搞\npermalink: bzoj-2456\ndate: 2016-06-17 22:07:00\n---\n\n给你一个 $ n $ 个数的数列，其中某个数出现了超过 $ n \\over 2 $ 次即众数，请你找出那个数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2456](http://www.lydsy.com/JudgeOnline/problem.php?id=2456)\n\n### 题解\n$ 500,000 $ 的数据，$ \\text {1M} $ 内存是存不下的，考虑空间复杂度为 $ O(1) $ 的做法。\n\n如果众数出现了超过 $ n \\over 2 $ 次，那么任意删除序列中的两个不同的数，众数的出现次数仍然超过一半。不停地进行下去，最终剩下的一个数即为众数。\n\n实现时，记录一个「当前的数」和它的「出现次数」，删除一次则出现次数减一，出现次数为 $ 0 $ 时用读入的数更新当前的数。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 500000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = -1, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (cnt == 0) {\n\t\t\tans = x;\n\t\t\tcnt = 1;\n\t\t} else {\n\t\t\tif (ans == x) {\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2456","published":1,"updated":"2016-06-17T14:08:31.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sg201ihooxlf6fgnhkg"},{"title":"「BZOJ 2442」修剪草坪 - 线性 DP + 单调队列","id":"24","updated":"2016-01-19T13:03:11.000Z","date":"2016-01-16T14:32:47.000Z","_content":"\nFJ 有 `N`（$1 ≤ N ≤ 100,000$）只排成一排的奶牛，编号为 `1` 到 `N`。每只奶牛的效率是不同的，奶牛 `i` 的效率为$E_i$（$0 ≤ E_i ≤ 1,000,000,000$）。\n\n靠近的奶牛们很熟悉，因此，如果 FJ 安排超过 `K` 只连续的奶牛，那么，这些奶牛就会罢工去开派对。因此，现在 FJ 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 `K` 只奶牛。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### 题解\n一个 $O(n^2)$ 的解法是采用线性 DP，用 $a[i]$ 表示第 `i` 头奶牛的效率，$f[i]$ 表示选择前 `i` 只奶牛中部分或全部可获得的最大效率，对于每次状态转移，枚举 `j`（$i-k ≤ j < i$），计算不选择第 `j` 头奶牛时的最大效率。\n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n边界条件为：\n\n$$ f[1]=a[1] $$\n\n用前缀和数组来维护效率和，每次转移要耗费 $O(n)$ 的时间。\n\n实现代码：（注意边界判断和数组访问的 `-1`）\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n现在让我们来尝试优化这个 DP，首先，设\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n忽略 $f[i-1]$，把转移方程中的前缀和项展开\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n令\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n则转移方程的前半部分化为\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n用一个长度为 `k + 1` 的单调队列来维护 $g(j)$，然后就可以优化到 $O(1)$ 的计算出每个状态。\n\n最终，新的转移方程为\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n两个坑：\n\n1. $E_i$加起来妥妥的爆 `int`，快上 `long long` 保平安；\n2. 边界条件！边界条件！边界条件！\n\n~~（才不是坑呢是我太弱了啦）~~\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2442.md","raw":"title: 「BZOJ 2442」修剪草坪 - 线性 DP + 单调队列\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - USACO\n  - DP\n  - 单调队列\n  - 线性 DP\npermalink: bzoj-2442\nid: 24\nupdated: '2016-01-19 21:03:11'\ndate: 2016-01-16 22:32:47\n---\n\nFJ 有 `N`（$1 ≤ N ≤ 100,000$）只排成一排的奶牛，编号为 `1` 到 `N`。每只奶牛的效率是不同的，奶牛 `i` 的效率为$E_i$（$0 ≤ E_i ≤ 1,000,000,000$）。\n\n靠近的奶牛们很熟悉，因此，如果 FJ 安排超过 `K` 只连续的奶牛，那么，这些奶牛就会罢工去开派对。因此，现在 FJ 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 `K` 只奶牛。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### 题解\n一个 $O(n^2)$ 的解法是采用线性 DP，用 $a[i]$ 表示第 `i` 头奶牛的效率，$f[i]$ 表示选择前 `i` 只奶牛中部分或全部可获得的最大效率，对于每次状态转移，枚举 `j`（$i-k ≤ j < i$），计算不选择第 `j` 头奶牛时的最大效率。\n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n边界条件为：\n\n$$ f[1]=a[1] $$\n\n用前缀和数组来维护效率和，每次转移要耗费 $O(n)$ 的时间。\n\n实现代码：（注意边界判断和数组访问的 `-1`）\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n现在让我们来尝试优化这个 DP，首先，设\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n忽略 $f[i-1]$，把转移方程中的前缀和项展开\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n令\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n则转移方程的前半部分化为\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n用一个长度为 `k + 1` 的单调队列来维护 $g(j)$，然后就可以优化到 $O(1)$ 的计算出每个状态。\n\n最终，新的转移方程为\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n两个坑：\n\n1. $E_i$加起来妥妥的爆 `int`，快上 `long long` 保平安；\n2. 边界条件！边界条件！边界条件！\n\n~~（才不是坑呢是我太弱了啦）~~\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2442","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sg701ilooxlvxbywlgz"},{"title":"「BZOJ 2438」杀人游戏 - 强联通分量","date":"2016-06-25T08:31:00.000Z","_content":"\n一位杀手潜入假装成平民。警察希望能在 $ N $ 个人里面，查出谁是杀手。警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他认识的人，谁是杀手，谁是平民。假如查证的对象是杀手，杀手将会把警察干掉。\n\n现在警察掌握了每一个人认识谁。每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。\n\n根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多少？\n\n<!-- more -->\n\n### 链接\n[BZOJ 2438](http://www.lydsy.com/JudgeOnline/problem.php?id=2438)\n\n### 题解\n如果一些人在一个强联通分量中，那么这些人中只需要查证一个人。\n\n缩点后，统计有多少入度为零的点，查证这些点一定不会漏掉。\n\n考虑这样一种特殊情况：只有一个人，这个人一定是杀手，即不需要查证任何人。\n\n更普遍的，每一个入度为零一个人的单点（必须是一个人不能是一群人），对于其连接的所有点，这些点的入度如果都不为 $ 1 $，则这个人可以不需要查证。查证其它所有人后，他认识的人也都被查证过，只剩他一个人不需要查证即知道身份。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *e, *in, *c;\n\tbool visited, pushed, inStack;\n\tint dfn, low, inDegree;\n\tSCC *scc;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint s;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, m;\n\ninline int tarjan() {\n\tint time = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->dfn = v->low = time++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tif (v->c->t->inStack) v->low = std::min(v->low, v->c->t->dfn);\n\t\t\t\telse if (v->c->t->pushed == false) s.push(v->c->t), v->c->t->pushed = true, v->c->t->in = v->c;\n\t\t\t\tv->c = v->c->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = scc;\n\t\t\t\t\t\tu->scc->s++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->in) v->in->s->low = std::min(v->in->s->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tif (e->s->scc != e->t->scc) {\n\t\t\t\te->s->scc->v.e = new Edge(&e->s->scc->v, &e->t->scc->v);\n\t\t\t\te->t->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t), s--, t--;\n\t\taddEdge(s, t);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint k = 0;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0) k++;\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0 && S[i].s == 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (Edge *e = S[i].v.e; e; e = e->next) {\n\t\t\t\tif (e->t->inDegree <= 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tk--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", static_cast<double>(n - k) / n);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2438.md","raw":"title: 「BZOJ 2438」杀人游戏 - 强联通分量\ncategories: OI\ntags: \n  - BZOJ\n  - 强联通分量\n  - Tarjan\n  - 缩点\npermalink: bzoj-2438\ndate: 2016-06-25 16:31:00\n---\n\n一位杀手潜入假装成平民。警察希望能在 $ N $ 个人里面，查出谁是杀手。警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他认识的人，谁是杀手，谁是平民。假如查证的对象是杀手，杀手将会把警察干掉。\n\n现在警察掌握了每一个人认识谁。每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。\n\n根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多少？\n\n<!-- more -->\n\n### 链接\n[BZOJ 2438](http://www.lydsy.com/JudgeOnline/problem.php?id=2438)\n\n### 题解\n如果一些人在一个强联通分量中，那么这些人中只需要查证一个人。\n\n缩点后，统计有多少入度为零的点，查证这些点一定不会漏掉。\n\n考虑这样一种特殊情况：只有一个人，这个人一定是杀手，即不需要查证任何人。\n\n更普遍的，每一个入度为零一个人的单点（必须是一个人不能是一群人），对于其连接的所有点，这些点的入度如果都不为 $ 1 $，则这个人可以不需要查证。查证其它所有人后，他认识的人也都被查证过，只剩他一个人不需要查证即知道身份。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *e, *in, *c;\n\tbool visited, pushed, inStack;\n\tint dfn, low, inDegree;\n\tSCC *scc;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint s;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, m;\n\ninline int tarjan() {\n\tint time = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->dfn = v->low = time++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tif (v->c->t->inStack) v->low = std::min(v->low, v->c->t->dfn);\n\t\t\t\telse if (v->c->t->pushed == false) s.push(v->c->t), v->c->t->pushed = true, v->c->t->in = v->c;\n\t\t\t\tv->c = v->c->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = scc;\n\t\t\t\t\t\tu->scc->s++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->in) v->in->s->low = std::min(v->in->s->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tif (e->s->scc != e->t->scc) {\n\t\t\t\te->s->scc->v.e = new Edge(&e->s->scc->v, &e->t->scc->v);\n\t\t\t\te->t->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t), s--, t--;\n\t\taddEdge(s, t);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint k = 0;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0) k++;\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0 && S[i].s == 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (Edge *e = S[i].v.e; e; e = e->next) {\n\t\t\t\tif (e->t->inDegree <= 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tk--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", static_cast<double>(n - k) / n);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2438","published":1,"updated":"2016-06-25T08:31:49.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sgh01itooxl4uq404pe"},{"title":"「BZOJ 2296」随机种子 - 数论基础","date":"2016-04-01T14:59:45.000Z","_content":"\n给定一个数 $ x $（$ 0 \\leq x \\leq 10 ^ 6 $），求一个数 $ n $ 满足：\n\n1. $ n $ 的十进制表示中包含 0 ~ 9 的所有数；\n2. $ n ~ {\\rm mod} ~ x = 0 $；\n3. $ 0 \\leq n \\leq 10 ^ {16} $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### 题解\n做这题需要有点数论基础，构造方法并不难，首先为了满足性质 1，我们可以令 n 的十进制表示中的前 10 位为 $ 9876543210 $，这样我们只需要考虑后 6 位即可。\n\n设 $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $，想象我们通过若干次减法把 $ 9876543210 $ 减到了 $ d $，所以我们只要令 $ n = 9876543210 \\times 10 ^ 6 + x - d $ 即可。\n\n注意 0 的特判。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2296.md","raw":"title: 「BZOJ 2296」随机种子 - 数论基础\ncategories: OI\ntags: \n  - BZOJ\n  - 数论\n  - 安徽集训\npermalink: bzoj-2296\ndate: 2016-04-01 22:59:45\n---\n\n给定一个数 $ x $（$ 0 \\leq x \\leq 10 ^ 6 $），求一个数 $ n $ 满足：\n\n1. $ n $ 的十进制表示中包含 0 ~ 9 的所有数；\n2. $ n ~ {\\rm mod} ~ x = 0 $；\n3. $ 0 \\leq n \\leq 10 ^ {16} $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### 题解\n做这题需要有点数论基础，构造方法并不难，首先为了满足性质 1，我们可以令 n 的十进制表示中的前 10 位为 $ 9876543210 $，这样我们只需要考虑后 6 位即可。\n\n设 $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $，想象我们通过若干次减法把 $ 9876543210 $ 减到了 $ d $，所以我们只要令 $ n = 9876543210 \\times 10 ^ 6 + x - d $ 即可。\n\n注意 0 的特判。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2296","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sgo01izooxlvy5gpnck"},{"title":"「BZOJ 2194」快速傅立叶之二 - FFT","date":"2016-06-10T01:32:00.000Z","_content":"\n给定两个长度为 $ n $ 的序列 $ A $、$ B $，求长度为 $ n $ 的序列 $ C $，满足 $ C_k = \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2194](http://www.lydsy.com/JudgeOnline/problem.php?id=2194)\n\n### 题解\n将 $ A $ 反转得到 $ A' $，则有\n\n$$\n\\begin{align*}\nC_k &= \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} \\\\\n&= \\sum\\limits_{i = k} ^ {n - 1} A'_{n - i - 1} \\times B_{i - k}\n\\end{align*}\n$$\n\n调整求和指标，使 $ i $ 从 $ 0 $ 开始枚举\n\n$$\nC_k = \\sum\\limits_{i = 0} ^ {n - k - 1} A'_{n - k - 1 - i} \\times B_{i}\n$$\n\n现在表达式已经类似多项式乘法的形式了，考虑这样一个多项式乘法\n\n$$ c_t = \\sum\\limits_{i = 0} ^ {t} a_{t - i} b_{i} $$\n\n令 $ t = n - k - 1 $，则上式化为\n\n$$\nC_{n - t - 1} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n考虑将 $ C $ 翻转为 $ C' $\n\n$$\nC'_{t} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n至此，原式已被化为多项式乘法的形式，只需将 $ A' $ 和 $ B $ 作为多项式系数，求出 $ C' $（只需前 $ n $ 项），翻转后即为 $ C $。\n\n总时间复杂度为 FFT 的时间复杂度，$ O(n \\log n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n\nconst int MAXN = 131072 * 2;\nconst double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << (k - j - 1))) t |= (1 << j);\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid operator()(const int *a, const int n1, const int *b, const int n2, int *c) {\n\t\tfor (int k = 0; k < n1 + n2; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tc[k] += a[i] * b[k - i];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\n\t\tstatic std::complex<double> ca[MAXN], cb[MAXN];\n\n\t\tint n = 1;\n\t\twhile (n < (n1 + n2)) n *= 2;\n\n\t\tfor (int i = 0; i < n; i++) ca[i] = std::complex<double>(i < n1 ? a[i] : 0, 0);\n\t\tfor (int i = 0; i < n; i++) cb[i] = std::complex<double>(i < n2 ? b[i] : 0, 0);\n\n\t\tinit(n);\n\t\tdft(ca, n);\n\t\tdft(cb, n);\n\n\t\tfor (int i = 0; i < n; i++) ca[i] *= cb[i];\n\n\t\tidft(ca, n);\n\n\t\tfor (int i = 0; i < n; i++) c[i] = static_cast<int>(floor(ca[i].real() + 0.5));\n\t}\n} fft;\n\ninline void force(const int *a, const int *b, int *c, const int n) {\n\t/*\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tc[k] += a[n - i - 1] * b[i - k];\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n - k; i++) {\n\t\t\tc[k] += a[n - k - 1 - i] * b[i];\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN], c[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[n - i - 1], &b[i]);\n\n\t// force(a, b, c, n);\n\tfft(a, n, b, n, c);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", c[n - i - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2194.md","raw":"title: 「BZOJ 2194」快速傅立叶之二 - FFT\ncategories: OI\ntags: \n  - BZOJ\n  - 数学\n  - FFT\npermalink: bzoj-2194\ndate: 2016-06-10 09:32:00\n---\n\n给定两个长度为 $ n $ 的序列 $ A $、$ B $，求长度为 $ n $ 的序列 $ C $，满足 $ C_k = \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2194](http://www.lydsy.com/JudgeOnline/problem.php?id=2194)\n\n### 题解\n将 $ A $ 反转得到 $ A' $，则有\n\n$$\n\\begin{align*}\nC_k &= \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} \\\\\n&= \\sum\\limits_{i = k} ^ {n - 1} A'_{n - i - 1} \\times B_{i - k}\n\\end{align*}\n$$\n\n调整求和指标，使 $ i $ 从 $ 0 $ 开始枚举\n\n$$\nC_k = \\sum\\limits_{i = 0} ^ {n - k - 1} A'_{n - k - 1 - i} \\times B_{i}\n$$\n\n现在表达式已经类似多项式乘法的形式了，考虑这样一个多项式乘法\n\n$$ c_t = \\sum\\limits_{i = 0} ^ {t} a_{t - i} b_{i} $$\n\n令 $ t = n - k - 1 $，则上式化为\n\n$$\nC_{n - t - 1} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n考虑将 $ C $ 翻转为 $ C' $\n\n$$\nC'_{t} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n至此，原式已被化为多项式乘法的形式，只需将 $ A' $ 和 $ B $ 作为多项式系数，求出 $ C' $（只需前 $ n $ 项），翻转后即为 $ C $。\n\n总时间复杂度为 FFT 的时间复杂度，$ O(n \\log n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n\nconst int MAXN = 131072 * 2;\nconst double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << (k - j - 1))) t |= (1 << j);\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid operator()(const int *a, const int n1, const int *b, const int n2, int *c) {\n\t\tfor (int k = 0; k < n1 + n2; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tc[k] += a[i] * b[k - i];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\n\t\tstatic std::complex<double> ca[MAXN], cb[MAXN];\n\n\t\tint n = 1;\n\t\twhile (n < (n1 + n2)) n *= 2;\n\n\t\tfor (int i = 0; i < n; i++) ca[i] = std::complex<double>(i < n1 ? a[i] : 0, 0);\n\t\tfor (int i = 0; i < n; i++) cb[i] = std::complex<double>(i < n2 ? b[i] : 0, 0);\n\n\t\tinit(n);\n\t\tdft(ca, n);\n\t\tdft(cb, n);\n\n\t\tfor (int i = 0; i < n; i++) ca[i] *= cb[i];\n\n\t\tidft(ca, n);\n\n\t\tfor (int i = 0; i < n; i++) c[i] = static_cast<int>(floor(ca[i].real() + 0.5));\n\t}\n} fft;\n\ninline void force(const int *a, const int *b, int *c, const int n) {\n\t/*\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tc[k] += a[n - i - 1] * b[i - k];\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n - k; i++) {\n\t\t\tc[k] += a[n - k - 1 - i] * b[i];\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN], c[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[n - i - 1], &b[i]);\n\n\t// force(a, b, c, n);\n\tfft(a, n, b, n, c);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", c[n - i - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2194","published":1,"updated":"2016-06-11T13:32:41.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sgu01j4ooxlhpdlz7gb"},{"title":"「BZOJ 2152」聪聪可可 - 点分治","date":"2016-06-14T14:09:00.000Z","_content":"\n求在一棵 $ n $ 个点的带权树上随机选择两个有序点（可以相同），两点距离为 $ 3 $ 的倍数的概率。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2152](http://www.lydsy.com/JudgeOnline/problem.php?id=2152)\n\n### 题解\n点分治，每次分治计算从根出发的长度 $ \\bmod 3 $ 的值为 $ i $ 的路径数量为 $ f(i) $。\n\n点对有序，考虑两条路径可以连接，因此 $ f(1) \\times f(2) \\times 2 $ 是答案的一部分。  \n考虑 $ f(0) $ 对答案的贡献，每条路径可以单独算，也可以与另一条连接，注意到每条路径可以与其连接的路径条数是一个等差数列，因此该部分答案为 $ \\frac{ f(0) \\times (f(0) - 1) }{2} $，点对有序，再乘以 $ 2 $，加上单独算的答案，为 $ f ^ 2(0) $。\n\n因此，统计 $ f ^ 2(0) + f(1) \\times f(2) \\times 2 $ 即可。\n\n最终答案需要处以 $ n ^ 2 $（总方案数），之后约分即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, dist, max;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(start->size - a[i]->max, a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->parent = NULL;\n\troot->dist = dist;\n\t\n\tint a[3] = { 0, 0, 0 }, cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt++;\n\t\ta[v->dist %= 3]++;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn a[0] * a[0] + a[1] * a[2] * 2;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint res = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\tres += calc(root);\n\t\troot->solved = true;\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tres -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--, w %= 3;\n\t\taddEdge(u, v, w);\n\t}\n\n\tint cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum);\n\tprintf(\"%d/%d\\n\", cnt / g, sum / g);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2152.md","raw":"title: 「BZOJ 2152」聪聪可可 - 点分治\ncategories: OI\ntags: \n  - BZOJ\n  - 点分治\n  - 数据结构\npermalink: bzoj-2152\ndate: 2016-06-14 22:09:00\n---\n\n求在一棵 $ n $ 个点的带权树上随机选择两个有序点（可以相同），两点距离为 $ 3 $ 的倍数的概率。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2152](http://www.lydsy.com/JudgeOnline/problem.php?id=2152)\n\n### 题解\n点分治，每次分治计算从根出发的长度 $ \\bmod 3 $ 的值为 $ i $ 的路径数量为 $ f(i) $。\n\n点对有序，考虑两条路径可以连接，因此 $ f(1) \\times f(2) \\times 2 $ 是答案的一部分。  \n考虑 $ f(0) $ 对答案的贡献，每条路径可以单独算，也可以与另一条连接，注意到每条路径可以与其连接的路径条数是一个等差数列，因此该部分答案为 $ \\frac{ f(0) \\times (f(0) - 1) }{2} $，点对有序，再乘以 $ 2 $，加上单独算的答案，为 $ f ^ 2(0) $。\n\n因此，统计 $ f ^ 2(0) + f(1) \\times f(2) \\times 2 $ 即可。\n\n最终答案需要处以 $ n ^ 2 $（总方案数），之后约分即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, dist, max;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(start->size - a[i]->max, a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->parent = NULL;\n\troot->dist = dist;\n\t\n\tint a[3] = { 0, 0, 0 }, cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt++;\n\t\ta[v->dist %= 3]++;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn a[0] * a[0] + a[1] * a[2] * 2;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint res = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\tres += calc(root);\n\t\troot->solved = true;\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tres -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--, w %= 3;\n\t\taddEdge(u, v, w);\n\t}\n\n\tint cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum);\n\tprintf(\"%d/%d\\n\", cnt / g, sum / g);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2152","published":1,"updated":"2016-06-16T10:10:15.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sh001j9ooxlbo7maly2"},{"title":"「BZOJ 2143」飞飞侠 - 最短路","date":"2016-03-22T11:50:15.000Z","_content":"\n飞国是一个 $ N * M $ 的矩形方阵，每个格子代表一个街区。飞国是没有交通工具的。飞侠完全靠地面的弹射装置来移动。每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹力。设第 $ i $ 行第 $ j $ 列的弹射装置有 $ A_{ij} $ 的费用和 $ B_{ij} $ 的弹力。并规定有相邻边的格子间距离是 $ 1 $。那么，任何飞侠都只需要在 $ (i,j) $ 支付 $ A_{ij} $ 的费用就可以任 意选择弹到距离不超过 $ B_{ij} $ 的位置了。\n\n有三个飞侠，分别叫做 X、Y、Z。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $ 3 $ 个飞侠的坐标，求往哪里集合大家需要花的费用总和最低。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2143](http://www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### 题解\n直接裸最短路只能过 40%，考虑从每个位置能走到的位置的坐标最多为 $ B_{ij} $，为空中的每个位置建立节点，从地面到空中 $ B_{ij} $ 高度需要 $ A_{ij} $ 的花费，从空中每个位置到其前后左右位置，高度下降一个单位，花费为 0。这样做有效的减少了边的数量，虽然点变多了，但 Dijkstra 的堆优化效果会更加明显。\n\n然而这样还是过不了的 …… 考虑到 Dijkstra 贪心选择最近点的特点，如果从堆中取出的点的到起点距离比三个飞侠的到起点的距离还要大，就可以直接剪枝。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2143.md","raw":"title: 「BZOJ 2143」飞飞侠 - 最短路\ncategories: OI\ntags: \n  - BZOJ\n  - 最短路\n  - Dijkstra\n  - 安徽集训\npermalink: bzoj-2143\ndate: 2016-03-22 19:50:15\n---\n\n飞国是一个 $ N * M $ 的矩形方阵，每个格子代表一个街区。飞国是没有交通工具的。飞侠完全靠地面的弹射装置来移动。每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹力。设第 $ i $ 行第 $ j $ 列的弹射装置有 $ A_{ij} $ 的费用和 $ B_{ij} $ 的弹力。并规定有相邻边的格子间距离是 $ 1 $。那么，任何飞侠都只需要在 $ (i,j) $ 支付 $ A_{ij} $ 的费用就可以任 意选择弹到距离不超过 $ B_{ij} $ 的位置了。\n\n有三个飞侠，分别叫做 X、Y、Z。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $ 3 $ 个飞侠的坐标，求往哪里集合大家需要花的费用总和最低。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2143](http://www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### 题解\n直接裸最短路只能过 40%，考虑从每个位置能走到的位置的坐标最多为 $ B_{ij} $，为空中的每个位置建立节点，从地面到空中 $ B_{ij} $ 高度需要 $ A_{ij} $ 的花费，从空中每个位置到其前后左右位置，高度下降一个单位，花费为 0。这样做有效的减少了边的数量，虽然点变多了，但 Dijkstra 的堆优化效果会更加明显。\n\n然而这样还是过不了的 …… 考虑到 Dijkstra 贪心选择最近点的特点，如果从堆中取出的点的到起点距离比三个飞侠的到起点的距离还要大，就可以直接剪枝。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2143","published":1,"updated":"2016-06-14T07:16:00.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sh601jeooxl6gdfag18"},{"title":"「BZOJ 2132」圈地计划 - 最小割","date":"2016-06-23T08:56:00.000Z","_content":"\n对于第 $ i $ 行第 $ j $ 列的区域，建造商业区将得到 $ A_{i,\\ j} $ 收益，建造工业区将得到 $ B_{i,\\ j} $ 收益。另外不同的区域连在一起可以得到额外的收益，即如果区域 $ (i,\\ j) $ 相邻（相邻是指两个格子有公共边）有 $ K $ 块（显然 $ K $ 不超过 $ 4 $）类型不同于 $ (i,\\ j) $ 的区域，则这块区域能增加 $ K \\times C_{i,\\ j} $ 收益。求最大收益。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2132](http://www.lydsy.com/JudgeOnline/problem.php?id=2132)\n\n### 题解\n黑白染色，从源点到所有 $ X $ 点连边，容量为 $ A_{i,\\ j} $，从源点到所有 $ Y $ 点连边，容量为 $ B_{i,\\ j} $；从所有 $ X $ 点到汇点连边，容量为 $ B_{i,\\ j} $，从所有 $ Y $ 点向汇点连边，容量为 $ A_{i,\\ j} $。\n\n对于相邻的点，之间连一条容量为 $ C_{i_1,\\ j_1} + C_{i_2,\\ j_2} $ 的无向边。\n\n考虑相邻的两个点，如果都割源点方向的边或都割汇点方向的边，则不需要割中间的边；如果一个割源点方向的边，另一个割汇点方向的边，则需要同时割掉中间的边，此时两个点对应区域建造相同。\n\n所有可能获得的收益减去最小割即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\tconst int s = 0, t = n * m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\t\t\t\n\t\t\tif ((i + j) % 2 == 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\n\t\t\tif ((i + j) % 2 != 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x;\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x;\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2132.md","raw":"title: 「BZOJ 2132」圈地计划 - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: bzoj-2132\ndate: 2016-06-23 16:56:00\n---\n\n对于第 $ i $ 行第 $ j $ 列的区域，建造商业区将得到 $ A_{i,\\ j} $ 收益，建造工业区将得到 $ B_{i,\\ j} $ 收益。另外不同的区域连在一起可以得到额外的收益，即如果区域 $ (i,\\ j) $ 相邻（相邻是指两个格子有公共边）有 $ K $ 块（显然 $ K $ 不超过 $ 4 $）类型不同于 $ (i,\\ j) $ 的区域，则这块区域能增加 $ K \\times C_{i,\\ j} $ 收益。求最大收益。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2132](http://www.lydsy.com/JudgeOnline/problem.php?id=2132)\n\n### 题解\n黑白染色，从源点到所有 $ X $ 点连边，容量为 $ A_{i,\\ j} $，从源点到所有 $ Y $ 点连边，容量为 $ B_{i,\\ j} $；从所有 $ X $ 点到汇点连边，容量为 $ B_{i,\\ j} $，从所有 $ Y $ 点向汇点连边，容量为 $ A_{i,\\ j} $。\n\n对于相邻的点，之间连一条容量为 $ C_{i_1,\\ j_1} + C_{i_2,\\ j_2} $ 的无向边。\n\n考虑相邻的两个点，如果都割源点方向的边或都割汇点方向的边，则不需要割中间的边；如果一个割源点方向的边，另一个割汇点方向的边，则需要同时割掉中间的边，此时两个点对应区域建造相同。\n\n所有可能获得的收益减去最小割即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\tconst int s = 0, t = n * m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\t\t\t\n\t\t\tif ((i + j) % 2 == 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\n\t\t\tif ((i + j) % 2 != 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x;\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x;\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2132","published":1,"updated":"2016-06-23T08:56:59.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9she01jlooxl1qtik5ks"},{"title":"「BZOJ 2127」happiness - 最大权闭合图","date":"2016-06-21T09:41:00.000Z","_content":"\n高一一班的座位表是个 $ n \\times m $ 的矩阵，经过一个学期的相处，每个同学和**前后左右相邻**的同学互相成为了好朋友。这学期要分文理科了，每个同学对于选择文科与理科有着自己的喜悦值，而**一对**好朋友如果能同时选文科或者理科，那么他们又将收获一些喜悦值。如何分配可以使得全班的喜悦值总和最大？\n\n<!-- more -->\n\n### 链接\n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### 题解\n先考虑每个人都选择文科，然后考虑一个人改选理科带来的影响。\n\n建立最大权闭合图模型：为每个人建点，权值为理科收益减去文科收益。为每一对之间建两个点，一个点表示两个人中任意一个人选理，则文科收益加成取消，另一个点表示两个人都选理，则获得理科收益加成。从每一对的第一个点向两个人连边，每个人向每一对的第二个点连边。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2];\n\tconst int DOWN = 0, RIGHT = 1;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &aDown[i][j]), sum += aDown[i][j];\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &bDown[i][j]);\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &aRight[i][j]), sum += aRight[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &bRight[i][j]);\n\n\tint id = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) vID[i][j] = id++;\n\n\t// printf(\"eID starts from %d\\n\", id);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++;\n\t\t\tif (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++;\n\t\t}\n\t}\n\n\tconst int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1;\n\n\t// printf(\"%d %d\\n\", id, t);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, vID[i][j], x), sum += x;\n\t\t\telse addEdge(vID[i][j], t, -x);\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(eID[i][j][DOWN][0], t, aDown[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX);\n\t\t\t\taddEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(eID[i][j][RIGHT][0], t, aRight[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX);\n\t\t\t\taddEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2127.md","raw":"title: 「BZOJ 2127」happiness - 最大权闭合图\ncategories: OI\ntags: \n  - BZOJ\n  - 最大权闭合图\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: bzoj-2127\ndate: 2016-06-21 17:41:00\n---\n\n高一一班的座位表是个 $ n \\times m $ 的矩阵，经过一个学期的相处，每个同学和**前后左右相邻**的同学互相成为了好朋友。这学期要分文理科了，每个同学对于选择文科与理科有着自己的喜悦值，而**一对**好朋友如果能同时选文科或者理科，那么他们又将收获一些喜悦值。如何分配可以使得全班的喜悦值总和最大？\n\n<!-- more -->\n\n### 链接\n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### 题解\n先考虑每个人都选择文科，然后考虑一个人改选理科带来的影响。\n\n建立最大权闭合图模型：为每个人建点，权值为理科收益减去文科收益。为每一对之间建两个点，一个点表示两个人中任意一个人选理，则文科收益加成取消，另一个点表示两个人都选理，则获得理科收益加成。从每一对的第一个点向两个人连边，每个人向每一对的第二个点连边。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2];\n\tconst int DOWN = 0, RIGHT = 1;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &aDown[i][j]), sum += aDown[i][j];\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &bDown[i][j]);\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &aRight[i][j]), sum += aRight[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &bRight[i][j]);\n\n\tint id = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) vID[i][j] = id++;\n\n\t// printf(\"eID starts from %d\\n\", id);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++;\n\t\t\tif (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++;\n\t\t}\n\t}\n\n\tconst int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1;\n\n\t// printf(\"%d %d\\n\", id, t);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, vID[i][j], x), sum += x;\n\t\t\telse addEdge(vID[i][j], t, -x);\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(eID[i][j][DOWN][0], t, aDown[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX);\n\t\t\t\taddEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(eID[i][j][RIGHT][0], t, aRight[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX);\n\t\t\t\taddEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2127","published":1,"updated":"2016-06-22T08:25:36.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9shl01jrooxl0bhviy1k"},{"title":"「BZOJ 2120」数颜色 - 带修改莫队","date":"2016-12-30T01:40:00.000Z","_content":"\n墨墨购买了一套 $ N $ 支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。  \n墨墨会像你发布如下指令：\n1. `Q L R` 代表询问你从第 $ L $ 支画笔到第 $ R $ 支画笔中共有几种不同颜色的画笔。\n2. `R P Col` 把第 $ P $ 支画笔替换为颜色 $ \\text{Col}$。\n\n为了满足墨墨的要求，你知道你需要干什么了吗？\n\n<!-- more -->\n\n### 链接\n[BZOJ 2120](http://www.lydsy.com/JudgeOnline/problem.php?id=2120)\n\n### 题解\n为每个修改操作分配一个时刻，为每个查询记录其时刻，即受到了前多少次修改的影响。\n\n将序列分块，每块 $ n ^ {\\frac{2}{3}} $，将询问排序，左端点所在块为第一关键字，右端点所在块为第二关键字，查询时刻为第三关键字，莫队转移即可。\n\n注意需要记录每次修改的旧值，以便撤销。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\nconst int MAXX = 1e6;\n\nint n, a[MAXN + 1], blockSize;\n\nstruct Update {\n\tint pos, oldVal, newVal;\n} b[MAXM + 1];\n\nint q, ans[MAXM + 1], cnt[MAXX + 1];\n\nstruct Query {\n\tint id, l, r, time, block;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) {\n\t\t\tif (r / blockSize == other.r / blockSize) {\n\t\t\t\treturn time < other.time;\n\t\t\t} else return r / blockSize < other.r / blockSize;\n\t\t} else return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\ninline int extend(int l, int r, bool left, int d) {\n\tif (left) {\n\t\tif (d == 1) {\n\t\t\tif (++cnt[a[l]] == 1) return 1;\n\t\t\telse return 0;\n\t\t} else {\n\t\t\tif (--cnt[a[l]] == 0) return -1;\n\t\t\telse return 0;\n\t\t}\n\t} else {\n\t\tif (d == 1) {\n\t\t\tif (++cnt[a[r]] == 1) return 1;\n\t\t\telse return 0;\n\t\t} else {\n\t\t\tif (--cnt[a[r]] == 0) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n}\n\ninline int update(int l, int r, int time, int d) {\n\tUpdate x = b[time];\n\tint res = 0;\n\tif (d == 1) {\n\t\ta[x.pos] = x.newVal;\n\t\tif (x.pos >= l && x.pos <= r) {\n\t\t\tif (--cnt[x.oldVal] == 0) res--;\n\t\t\tif (++cnt[x.newVal] == 1) res++;\n\t\t}\n\t} else {\n\t\tif (x.pos >= l && x.pos <= r) {\n\t\t\tif (--cnt[x.newVal] == 0) res--;\n\t\t\tif (++cnt[x.oldVal] == 1) res++;\n\t\t}\n\t\ta[x.pos] = x.oldVal;\n\t}\n\treturn res;\n}\n\ninline void prepare(int t) {\n\tstatic int newA[MAXN + 1];\n\tstd::copy(a + 1, a + n + 1, newA + 1);\n\tfor (int i = 1; i <= t; i++) {\n\t\tb[i].oldVal = newA[b[i].pos];\n\t\tnewA[b[i].pos] = b[i].newVal;\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0, time = 0, ans = 0;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (r < Q[i].r) ans += extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) ans += extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) ans += extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) ans += extend(l++, r, true, -1);\n\n\t\twhile (time < Q[i].time) ans += update(l, r, ++time, 1);\n\t\twhile (time > Q[i].time) ans += update(l, r, time--, -1);\n\n\t\t::ans[Q[i].id] = ans;\n\t}\n}\n\nint main() {\n\tint m, t = 0;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tq++;\n\t\t\tQ[q].id = q;\n\t\t\tscanf(\"%d %d\", &Q[q].l, &Q[q].r);\n\t\t\tQ[q].time = t;\n\t\t} else {\n\t\t\tt++;\n\t\t\tscanf(\"%d %d\", &b[t].pos, &b[t].newVal);\n\t\t}\n\t}\n\n\tprepare(t);\n\n\tblockSize = floor(pow(n, 2.0 / 3) + 1);\n\tstd::sort(Q + 1, Q + q + 1);\n\n\tsolve();\n\n\tfor (int i = 1; i <= q; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2120.md","raw":"title: 「BZOJ 2120」数颜色 - 带修改莫队\ncategories: OI\ntags: \n  - BZOJ\n  - 莫队\n  - 数据结构\npermalink: bzoj-2120\ndate: 2016-12-30 09:40:00\n---\n\n墨墨购买了一套 $ N $ 支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。  \n墨墨会像你发布如下指令：\n1. `Q L R` 代表询问你从第 $ L $ 支画笔到第 $ R $ 支画笔中共有几种不同颜色的画笔。\n2. `R P Col` 把第 $ P $ 支画笔替换为颜色 $ \\text{Col}$。\n\n为了满足墨墨的要求，你知道你需要干什么了吗？\n\n<!-- more -->\n\n### 链接\n[BZOJ 2120](http://www.lydsy.com/JudgeOnline/problem.php?id=2120)\n\n### 题解\n为每个修改操作分配一个时刻，为每个查询记录其时刻，即受到了前多少次修改的影响。\n\n将序列分块，每块 $ n ^ {\\frac{2}{3}} $，将询问排序，左端点所在块为第一关键字，右端点所在块为第二关键字，查询时刻为第三关键字，莫队转移即可。\n\n注意需要记录每次修改的旧值，以便撤销。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\nconst int MAXX = 1e6;\n\nint n, a[MAXN + 1], blockSize;\n\nstruct Update {\n\tint pos, oldVal, newVal;\n} b[MAXM + 1];\n\nint q, ans[MAXM + 1], cnt[MAXX + 1];\n\nstruct Query {\n\tint id, l, r, time, block;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) {\n\t\t\tif (r / blockSize == other.r / blockSize) {\n\t\t\t\treturn time < other.time;\n\t\t\t} else return r / blockSize < other.r / blockSize;\n\t\t} else return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\ninline int extend(int l, int r, bool left, int d) {\n\tif (left) {\n\t\tif (d == 1) {\n\t\t\tif (++cnt[a[l]] == 1) return 1;\n\t\t\telse return 0;\n\t\t} else {\n\t\t\tif (--cnt[a[l]] == 0) return -1;\n\t\t\telse return 0;\n\t\t}\n\t} else {\n\t\tif (d == 1) {\n\t\t\tif (++cnt[a[r]] == 1) return 1;\n\t\t\telse return 0;\n\t\t} else {\n\t\t\tif (--cnt[a[r]] == 0) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n}\n\ninline int update(int l, int r, int time, int d) {\n\tUpdate x = b[time];\n\tint res = 0;\n\tif (d == 1) {\n\t\ta[x.pos] = x.newVal;\n\t\tif (x.pos >= l && x.pos <= r) {\n\t\t\tif (--cnt[x.oldVal] == 0) res--;\n\t\t\tif (++cnt[x.newVal] == 1) res++;\n\t\t}\n\t} else {\n\t\tif (x.pos >= l && x.pos <= r) {\n\t\t\tif (--cnt[x.newVal] == 0) res--;\n\t\t\tif (++cnt[x.oldVal] == 1) res++;\n\t\t}\n\t\ta[x.pos] = x.oldVal;\n\t}\n\treturn res;\n}\n\ninline void prepare(int t) {\n\tstatic int newA[MAXN + 1];\n\tstd::copy(a + 1, a + n + 1, newA + 1);\n\tfor (int i = 1; i <= t; i++) {\n\t\tb[i].oldVal = newA[b[i].pos];\n\t\tnewA[b[i].pos] = b[i].newVal;\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0, time = 0, ans = 0;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (r < Q[i].r) ans += extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) ans += extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) ans += extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) ans += extend(l++, r, true, -1);\n\n\t\twhile (time < Q[i].time) ans += update(l, r, ++time, 1);\n\t\twhile (time > Q[i].time) ans += update(l, r, time--, -1);\n\n\t\t::ans[Q[i].id] = ans;\n\t}\n}\n\nint main() {\n\tint m, t = 0;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tq++;\n\t\t\tQ[q].id = q;\n\t\t\tscanf(\"%d %d\", &Q[q].l, &Q[q].r);\n\t\t\tQ[q].time = t;\n\t\t} else {\n\t\t\tt++;\n\t\t\tscanf(\"%d %d\", &b[t].pos, &b[t].newVal);\n\t\t}\n\t}\n\n\tprepare(t);\n\n\tblockSize = floor(pow(n, 2.0 / 3) + 1);\n\tstd::sort(Q + 1, Q + q + 1);\n\n\tsolve();\n\n\tfor (int i = 1; i <= q; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","slug":"bzoj-2120","published":1,"updated":"2016-12-30T01:46:39.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9shs01jyooxle7mhon4u"},{"title":"「BZOJ 2038」小Z的袜子 - 莫队","date":"2016-04-01T14:15:45.000Z","_content":"\n给一个数列 $ x_1 $ ~ $ x_n $，给出 $ m $ 个询问，每次询问 $ x_i $ ~ $ x_j $ 中，任选两个数相同的概率。\n\n<!-- more -->\n\n### 题解\n先按照 $ \\sqrt n $ 分块，以区间左端点所在块为第一关键字，区间右端点为第二关键字排序，使用莫队算法。\n\n问题可转化为：求 $ x_i $ ~ $ x_j $ 中相等的数字对数。\n\n记某个时刻每个数字 $ x $ 的出现次数为 $ c_i $ 考虑每个数字对答案的贡献，答案为：\n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n每加进来或删去一个数字时，可以重新计算单个数字对答案的贡献来得到新的答案。\n\n计算出相等的对数后，除以总对数即为最终答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2038.md","raw":"title: 「BZOJ 2038」小Z的袜子 - 莫队\ncategories: OI\ntags: \n  - BZOJ\n  - 莫队\n  - 分块\n  - 安徽集训\npermalink: bzoj-2038\ndate: 2016-04-01 22:15:45\n---\n\n给一个数列 $ x_1 $ ~ $ x_n $，给出 $ m $ 个询问，每次询问 $ x_i $ ~ $ x_j $ 中，任选两个数相同的概率。\n\n<!-- more -->\n\n### 题解\n先按照 $ \\sqrt n $ 分块，以区间左端点所在块为第一关键字，区间右端点为第二关键字排序，使用莫队算法。\n\n问题可转化为：求 $ x_i $ ~ $ x_j $ 中相等的数字对数。\n\n记某个时刻每个数字 $ x $ 的出现次数为 $ c_i $ 考虑每个数字对答案的贡献，答案为：\n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n每加进来或删去一个数字时，可以重新计算单个数字对答案的贡献来得到新的答案。\n\n计算出相等的对数后，除以总对数即为最终答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2038","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9shy01k3ooxld3fb801r"},{"title":"「BZOJ 1756」小白逛公园 - 线段树","id":"38","updated":"2016-01-24T15:24:35.000Z","date":"2016-01-24T15:19:48.000Z","_content":"\n路的一边从南到北依次排着 `n` 个公园，一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 `a` 个和第 `b` 个公园之间（包括 `a`、`b` 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。那么，就请你来帮小白选择公园吧。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### 题解\n区间内最大连续和，还带修改，当然是线段树咯！\n\n每个节点维护以下几项信息：\n\n1. 区间总和；\n2. 区间最大连续和；\n3. **强制包含左端点**的最大连续和；\n4. **强制包含右端点**的最大连续和。\n\n然后使用动态规划的方式求出每个节点的四个值即可。\n\n查询麻烦一点，如果跨左右子树查询的话，需要维护**要查询的区间**的以上四项值，然后用相似的方式向上传递。\n\n合并两个区间时，需要注意细节。\n\n还有就是读入 `a`、`b` 时，有可能 `a` 比 `b` 大！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1756.md","raw":"title: 「BZOJ 1756」小白逛公园 - 线段树\ncategories: OI\ntags: \n  - BZOJ\n  - 线段树\n  - 高级数据结构\n  - 数据结构\n  - DP\npermalink: bzoj-1756\nid: 38\nupdated: '2016-01-24 23:24:35'\ndate: 2016-01-24 23:19:48\n---\n\n路的一边从南到北依次排着 `n` 个公园，一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 `a` 个和第 `b` 个公园之间（包括 `a`、`b` 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。那么，就请你来帮小白选择公园吧。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### 题解\n区间内最大连续和，还带修改，当然是线段树咯！\n\n每个节点维护以下几项信息：\n\n1. 区间总和；\n2. 区间最大连续和；\n3. **强制包含左端点**的最大连续和；\n4. **强制包含右端点**的最大连续和。\n\n然后使用动态规划的方式求出每个节点的四个值即可。\n\n查询麻烦一点，如果跨左右子树查询的话，需要维护**要查询的区间**的以上四项值，然后用相似的方式向上传递。\n\n合并两个区间时，需要注意细节。\n\n还有就是读入 `a`、`b` 时，有可能 `a` 比 `b` 大！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1756","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9si501k9ooxlkdf2kt40"},{"title":"「BZOJ 1718」Redundant Paths - 割边","date":"2017-01-01T01:22:00.000Z","_content":"\n给一个无向连通图，求至少加多少条边使得每两个点之间都存在至少两条路径，即使图没有割边。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1718](http://www.lydsy.com/JudgeOnline/problem.php?id=1718)  \n[POJ 3177](https://vjudge.net/problem/POJ-3177)\n\n### 题解\n坑。\n\n### 代码\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 5000;\nconst int MAXM = 10000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge, *inEdge;\n\tint dfn, low, deg;\n\tbool vis;\n\tNode *fa;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tbool isCut;\n\tEdge *next, *revEdge;\n\t                                  /* 不要忘记初始化 */\n\tEdge(Node *from, Node *to) : from(from), to(to), isCut(false), next(from->firstEdge) {}\n} *E[MAXM + 1]; // 数组里存边的指针\n\ninline Edge *addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n\n\tN[from].firstEdge->revEdge = N[to].firstEdge;\n\tN[to].firstEdge->revEdge = N[from].firstEdge;\n\n\treturn N[from].firstEdge; // 返回一条边\n}\n\nint n, cnt;\n\ninline void tarjan(Node *v)\n{\n\tstatic int ts;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->revEdge == v->inEdge) continue; // 判掉通过同一条边（互为反向边的两条有向边）走回去的情况\n\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->inEdge = e;\n\t\t\ttarjan(e->to);\n\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (e->to->low > v->dfn) // 注意没有等于，如果 e->to 通过其子节点的返祖边走到 v，e 就不是割边\n\t\t\t{\t                     // 或者当 v 和 e->to 之间有多条重边时，都不会是割边\n\t\t\t\te->isCut = e->revEdge->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n}\n\n\n// 并查集\nstruct UFS\n{\n\tint fa[MAXN + 1];\n\n\tvoid init(int n)\n\t{\n\t\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\t}\n\n\tint find(int x)\n\t{\n\t\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n\t}\n\n\tvoid merge(int x, int y)\n\t{\n\t\tfa[find(x)] = find(y);\n\t}\n} ufs;\n\nint main()\n{\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\t// 存储每一条 u 到 v 的边\n\t\tE[i] = addEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis)\n\t\t{\n\t\t\ttarjan(&N[i]);\n\t\t}\n\t}\n\n\tufs.init(n); // 并查集不要忘记初始化\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\t// 并查集实现缩点，把非割边的两端点合并\n\t\tif (!E[i]->isCut) ufs.merge(E[i]->from - N, E[i]->to - N);\n\t}\n\n\tfor (int i = 1; i <= m; i++) // 数组中只存了一个方向的边，不需处理正向反向边的问题\n\t{\n\t\t// 将割边加入到新图中，统计每个节点的度\n\t\tif (E[i]->isCut)\n\t\t{\n\t\t\t// printf(\"cutEdge: (%lu, %lu)\\n\", E[i]->from - N, E[i]->to - N);\n\t\t\tN[ufs.find(E[i]->from - N)].deg++;\n\t\t\tN[ufs.find(E[i]->to - N)].deg++;\n\t\t}\n\t}\n\n\tint leaves = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (ufs.find(i) == i) // 枚举每个连通块（用并查集中的每个根节点代表每个连通块，即每个边双连通分量）\n\t\t{\n\t\t\tif (N[i].deg == 1) // 统计叶子节点的数量\n\t\t\t{\n\t\t\t\tleaves++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"leaves = %d\\n\", leaves);\n\tprintf(\"%d\\n\", (leaves + 1) / 2);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1718.md","raw":"title: 「BZOJ 1718」Redundant Paths - 割边\ndate: 2017-01-01 09:22:00\ncategories: OI\ntags:\n  - BZOJ\n  - USACO\n  - 割边\n  - 图论\npermalink: bzoj-1718\n---\n\n给一个无向连通图，求至少加多少条边使得每两个点之间都存在至少两条路径，即使图没有割边。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1718](http://www.lydsy.com/JudgeOnline/problem.php?id=1718)  \n[POJ 3177](https://vjudge.net/problem/POJ-3177)\n\n### 题解\n坑。\n\n### 代码\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 5000;\nconst int MAXM = 10000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge, *inEdge;\n\tint dfn, low, deg;\n\tbool vis;\n\tNode *fa;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tbool isCut;\n\tEdge *next, *revEdge;\n\t                                  /* 不要忘记初始化 */\n\tEdge(Node *from, Node *to) : from(from), to(to), isCut(false), next(from->firstEdge) {}\n} *E[MAXM + 1]; // 数组里存边的指针\n\ninline Edge *addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n\n\tN[from].firstEdge->revEdge = N[to].firstEdge;\n\tN[to].firstEdge->revEdge = N[from].firstEdge;\n\n\treturn N[from].firstEdge; // 返回一条边\n}\n\nint n, cnt;\n\ninline void tarjan(Node *v)\n{\n\tstatic int ts;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->revEdge == v->inEdge) continue; // 判掉通过同一条边（互为反向边的两条有向边）走回去的情况\n\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->inEdge = e;\n\t\t\ttarjan(e->to);\n\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (e->to->low > v->dfn) // 注意没有等于，如果 e->to 通过其子节点的返祖边走到 v，e 就不是割边\n\t\t\t{\t                     // 或者当 v 和 e->to 之间有多条重边时，都不会是割边\n\t\t\t\te->isCut = e->revEdge->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n}\n\n\n// 并查集\nstruct UFS\n{\n\tint fa[MAXN + 1];\n\n\tvoid init(int n)\n\t{\n\t\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\t}\n\n\tint find(int x)\n\t{\n\t\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n\t}\n\n\tvoid merge(int x, int y)\n\t{\n\t\tfa[find(x)] = find(y);\n\t}\n} ufs;\n\nint main()\n{\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\t// 存储每一条 u 到 v 的边\n\t\tE[i] = addEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis)\n\t\t{\n\t\t\ttarjan(&N[i]);\n\t\t}\n\t}\n\n\tufs.init(n); // 并查集不要忘记初始化\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\t// 并查集实现缩点，把非割边的两端点合并\n\t\tif (!E[i]->isCut) ufs.merge(E[i]->from - N, E[i]->to - N);\n\t}\n\n\tfor (int i = 1; i <= m; i++) // 数组中只存了一个方向的边，不需处理正向反向边的问题\n\t{\n\t\t// 将割边加入到新图中，统计每个节点的度\n\t\tif (E[i]->isCut)\n\t\t{\n\t\t\t// printf(\"cutEdge: (%lu, %lu)\\n\", E[i]->from - N, E[i]->to - N);\n\t\t\tN[ufs.find(E[i]->from - N)].deg++;\n\t\t\tN[ufs.find(E[i]->to - N)].deg++;\n\t\t}\n\t}\n\n\tint leaves = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (ufs.find(i) == i) // 枚举每个连通块（用并查集中的每个根节点代表每个连通块，即每个边双连通分量）\n\t\t{\n\t\t\tif (N[i].deg == 1) // 统计叶子节点的数量\n\t\t\t{\n\t\t\t\tleaves++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"leaves = %d\\n\", leaves);\n\tprintf(\"%d\\n\", (leaves + 1) / 2);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1718","published":1,"updated":"2017-01-01T01:30:39.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sic01kgooxlh6482eho"},{"title":"「BZOJ 1711」Dining - 网络流","date":"2016-06-21T14:17:00.000Z","_content":"\n每一头牛只喜欢吃一些食品和饮料而别的一概不吃。农夫做了 $ F $（$ 1 \\leq F \\leq 100 $）种食品并准备了 $ D $（$ 1 \\leq D \\leq 100 $）种饮料。$ N $（$ 1 \\leq N \\leq 100 $）头牛都以决定了是否愿意吃某种食物和喝某种饮料。\n\n农夫想给每一头牛一种食品和一种饮料，使得尽可能多的牛得到喜欢的食物和饮料。\n\n每一件食物和饮料只能由一头牛来用。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1711](http://www.lydsy.com/JudgeOnline/problem.php?id=1711)\n\n### 题解\n将一头牛拆成两个点 $ A $ 和 $ A' $，从每个食品向能吃它的牛的 $ A $ 点连一条边，从每头牛的 $ A' $ 点向它能喝的饮料连一条边。\n\n源点向每个食品连边，每个饮料向汇点连边。\n\n边权均为 $ 1 $，最大流即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m1, m2;\n\tscanf(\"%d %d %d\", &n, &m1, &m2);\n\n\tconst int s = 0, t = n * 2 + m1 + m2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\tfor (int i = n + n + 1; i <= n + n + m1; i++) addEdge(s, i, 1);\n\tfor (int i = n + n + m1 + 1; i <= n + n + m1 + m2; i++) addEdge(i, t, 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k1, k2;\n\t\tscanf(\"%d %d\", &k1, &k2);\n\n\t\tfor (int j = 0; j < k1; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(n + n + x, i, 1);\n\t\t}\n\n\t\tfor (int j = 0; j < k2; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i + n, n + n + m1 + x, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1711.md","raw":"title: 「BZOJ 1711」Dining - 网络流\ndate: 2016-06-21 22:17:00\ncategories: OI\ntags:\n  - BZOJ\n  - USACO\n  - 网络流\n  - Dinic\npermalink: bzoj-1711\n---\n\n每一头牛只喜欢吃一些食品和饮料而别的一概不吃。农夫做了 $ F $（$ 1 \\leq F \\leq 100 $）种食品并准备了 $ D $（$ 1 \\leq D \\leq 100 $）种饮料。$ N $（$ 1 \\leq N \\leq 100 $）头牛都以决定了是否愿意吃某种食物和喝某种饮料。\n\n农夫想给每一头牛一种食品和一种饮料，使得尽可能多的牛得到喜欢的食物和饮料。\n\n每一件食物和饮料只能由一头牛来用。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1711](http://www.lydsy.com/JudgeOnline/problem.php?id=1711)\n\n### 题解\n将一头牛拆成两个点 $ A $ 和 $ A' $，从每个食品向能吃它的牛的 $ A $ 点连一条边，从每头牛的 $ A' $ 点向它能喝的饮料连一条边。\n\n源点向每个食品连边，每个饮料向汇点连边。\n\n边权均为 $ 1 $，最大流即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m1, m2;\n\tscanf(\"%d %d %d\", &n, &m1, &m2);\n\n\tconst int s = 0, t = n * 2 + m1 + m2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\tfor (int i = n + n + 1; i <= n + n + m1; i++) addEdge(s, i, 1);\n\tfor (int i = n + n + m1 + 1; i <= n + n + m1 + m2; i++) addEdge(i, t, 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k1, k2;\n\t\tscanf(\"%d %d\", &k1, &k2);\n\n\t\tfor (int j = 0; j < k1; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(n + n + x, i, 1);\n\t\t}\n\n\t\tfor (int j = 0; j < k2; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i + n, n + n + m1 + x, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1711","published":1,"updated":"2016-10-08T09:04:46.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sil01knooxlo1st7o09"},{"title":"「BZOJ 1706」乳牛接力跑 - 矩阵乘法","date":"2016-10-07T23:11:00.000Z","_content":"\n给一个图，求从 $ s $ 点到 $ t $ 点恰好经过 $ k $ 步的最短路。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1586](www.lydsy.com/JudgeOnline/problem.php?id=1586)  \n[COGS 1470](http://cogs.pro/cogs/problem/problem.php?pid=1470)\n\n### 题解\n矩阵乘法可以求出恰好经过 $ k $ 步的路径数，将矩阵乘法中的求和改为取较小值，相乘改为相加即可求出恰好经过 $ k $ 步的最短路。\n\n注意这时的单位矩阵，对角线上为 $ 0 $，其它全部为正无穷。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 100;\nconst int MAXN_SMALL = 200;\nconst int MAXK = 1000000;\n\nstruct Matrix {\n\tint a[MAXN_SMALL][MAXN_SMALL];\n\n\tMatrix(const bool unit = false) {\n\t\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) a[i][j] = INT_MAX;\n\t\tif (unit) for (int i = 0; i < MAXN_SMALL; i++) a[i][i] = 0;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) for (int k = 0; k < MAXN_SMALL; k++) if (a(i, k) != INT_MAX && b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j));\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"relays.in\", \"r\", stdin);\n\tfreopen(\"relays.out\", \"w\", stdout);\n\n\tint n, m, s, t, cnt;\n\tstatic int set[MAXM * 2];\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n\tstatic struct {\n\t\tint u, v, w;\n\t} E[MAXM];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].w, &E[i].u, &E[i].v);\n\t\tset[i] = E[i].u;\n\t\tset[i + m] = E[i].v;\n\t}\n\n\tstd::sort(set, set + m * 2);\n\tint *end = std::unique(set, set + m * 2);\n\tcnt = end - set;\n\n\tMatrix g(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tE[i].u = std::lower_bound(set, end, E[i].u) - set;\n\t\tE[i].v = std::lower_bound(set, end, E[i].v) - set;\n\t\tg(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w;\n\t}\n\ts = std::lower_bound(set, end, s) - set;\n\tt = std::lower_bound(set, end, t) - set;\n\n\tMatrix res = pow(g, n);\n\t/*\n\tMatrix res(true);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = res * g;\n\t\tfor (int i = 0; i < cnt; i++) for (int j = 0; j < cnt; j++) printf(\"%d%c\", res(i, j), j == cnt - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------------\");\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", res(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1706.md","raw":"title: 「BZOJ 1706」乳牛接力跑 - 矩阵乘法\ndate: 2016-10-08 07:11:00\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - USACO\n  - 矩阵乘法\npermalink: bzoj-1706\n---\n\n给一个图，求从 $ s $ 点到 $ t $ 点恰好经过 $ k $ 步的最短路。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1586](www.lydsy.com/JudgeOnline/problem.php?id=1586)  \n[COGS 1470](http://cogs.pro/cogs/problem/problem.php?pid=1470)\n\n### 题解\n矩阵乘法可以求出恰好经过 $ k $ 步的路径数，将矩阵乘法中的求和改为取较小值，相乘改为相加即可求出恰好经过 $ k $ 步的最短路。\n\n注意这时的单位矩阵，对角线上为 $ 0 $，其它全部为正无穷。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 100;\nconst int MAXN_SMALL = 200;\nconst int MAXK = 1000000;\n\nstruct Matrix {\n\tint a[MAXN_SMALL][MAXN_SMALL];\n\n\tMatrix(const bool unit = false) {\n\t\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) a[i][j] = INT_MAX;\n\t\tif (unit) for (int i = 0; i < MAXN_SMALL; i++) a[i][i] = 0;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) for (int k = 0; k < MAXN_SMALL; k++) if (a(i, k) != INT_MAX && b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j));\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"relays.in\", \"r\", stdin);\n\tfreopen(\"relays.out\", \"w\", stdout);\n\n\tint n, m, s, t, cnt;\n\tstatic int set[MAXM * 2];\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n\tstatic struct {\n\t\tint u, v, w;\n\t} E[MAXM];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].w, &E[i].u, &E[i].v);\n\t\tset[i] = E[i].u;\n\t\tset[i + m] = E[i].v;\n\t}\n\n\tstd::sort(set, set + m * 2);\n\tint *end = std::unique(set, set + m * 2);\n\tcnt = end - set;\n\n\tMatrix g(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tE[i].u = std::lower_bound(set, end, E[i].u) - set;\n\t\tE[i].v = std::lower_bound(set, end, E[i].v) - set;\n\t\tg(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w;\n\t}\n\ts = std::lower_bound(set, end, s) - set;\n\tt = std::lower_bound(set, end, t) - set;\n\n\tMatrix res = pow(g, n);\n\t/*\n\tMatrix res(true);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = res * g;\n\t\tfor (int i = 0; i < cnt; i++) for (int j = 0; j < cnt; j++) printf(\"%d%c\", res(i, j), j == cnt - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------------\");\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", res(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"bzoj-1706","published":1,"updated":"2016-10-07T23:18:48.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sit01ktooxl5amhekiy"},{"title":"「BZOJ 1692」队列变换 - 后缀数组 + 贪心","date":"2016-09-29T13:33:00.000Z","_content":"\n对于一个字符串 $ S $，每次从它的首部或尾部弹出一个字符，加入到 $ T $ 的尾部，求可以构造出的字典序最小的 $ T $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1692](http://www.lydsy.com/JudgeOnline/problem.php?id=1692)\n\n### 题解\n贪心，如果没有重复字符，则每次从两边选一个字典序较小的字符即可。\n\n因为有重复字符，所以可以继续比较，直到找到某一边一个字典序较小的字符即可，这个过程使用后缀数组优化。\n\n注意输出 80 个字符后换行。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1692.md","raw":"title: 「BZOJ 1692」队列变换 - 后缀数组 + 贪心\ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - 字符串\n  - 后缀数组\n  - 贪心\npermalink: bzoj-1692\ndate: 2016-09-29 21:33:00\n---\n\n对于一个字符串 $ S $，每次从它的首部或尾部弹出一个字符，加入到 $ T $ 的尾部，求可以构造出的字典序最小的 $ T $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1692](http://www.lydsy.com/JudgeOnline/problem.php?id=1692)\n\n### 题解\n贪心，如果没有重复字符，则每次从两边选一个字典序较小的字符即可。\n\n因为有重复字符，所以可以继续比较，直到找到某一边一个字典序较小的字符即可，这个过程使用后缀数组优化。\n\n注意输出 80 个字符后换行。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","slug":"bzoj-1692","published":1,"updated":"2016-09-29T13:45:54.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sj301kzooxlp726ykia"},{"title":"「BZOJ 1597」土地购买 - 斜率优化 DP","date":"2016-05-18T09:04:00.000Z","_content":"\n农夫 John 准备扩大他的农场，他正在考虑 $ N $（$ 1 \\leq N \\leq 50000 $）块长方形的土地。每块土地的长宽满足（$ 1 \\leq $ 长、宽 $ \\leq 1000000 $）。每块土地的价格是它的面积，但 FJ 可以同时购买多快土地。这些土地的价格是它们最大的长乘以它们最大的宽，但是土地的长宽不能交换。如果 FJ 买一块 $ 3 \\times 5 $ 的地和一块 $ 5 \\times 3 $ 的地，则他需要付 $ 5 \\times 5 = 25 $。FJ 希望买下所有的土地，但是他发现分组来买这些土地可以节省经费，他需要你帮助他找到最小的经费。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1597](http://www.lydsy.com/JudgeOnline/problem.php?id=1597)\n\n### 题解\n考虑两块土地，若其中一块可将另一块完全包含，则可以将较小的一块忽略，因为它总是可以被和另一块同时购买，而不增加花费。\n\n排序将上述情况筛除后，整个序列以一个关键字升序，另一个关键字降序。假设宽度 $ w(i) $ 降序，高度 $ h(i) $ 升序。设 $ f(i) $ 表示购买前 $ i $ 块土地的最小花费，考虑哪些不和 $ i $ 在一起购买。\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + w(j + 1) \\times h(i) \\} $$\n\n斜率优化，考虑两个决策 $ a $、$ b $，若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\nf(a) + w(a + 1) \\times h(i) & < f(b) + w(b + 1) \\times h(i) \\\\\nf(a) + f(b) & < (w(b + 1) - w(a + 1)) \\times h(i) \\\\\nf(a) + f(b) \\over w(b + 1) - w(a + 1) & < h(i) \\\\\n\\end{align*}\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50000;\n\nstd::pair<int, int> A[MAXN];\nstd::vector< std::pair<int, int>* > vec;\n\nint n;\nlong long f[MAXN + 1];\n\ninline void prepare() {\n    std::sort(A, A + n, std::greater< std::pair<int, int> >());\n\n    std::pair<int, int> *last = NULL;\n    for (int i = 0; i < n; i++) {\n        if (!last || A[i].second > last->second) {\n            vec.push_back(&A[i]);\n            last = &A[i];\n        }\n    }\n\n    n = vec.size();\n}\n\ninline long long w(const int i) { return static_cast<long long>(vec[i - 1]->first); }\ninline long long h(const int i) { return static_cast<long long>(vec[i - 1]->second); }\n\ninline void force() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + w(j + 1) * h(i)) {\n                f[i] = f[j] + w(j + 1) * h(i);\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n\ninline double slope(const int a, const int b) {\n    return double(f[a] - f[b])\n         / double(w(b + 1) - w(a + 1));\n}\n\ninline void dp() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n\n    static int q[MAXN + 1];\n    int *l = &q[0], *r = &q[0];\n    *r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < h(i)) l++;\n\n        int tmp = *l;\n        f[i] = f[tmp] + w(tmp + 1) * h(i);\n        // printf(\"%d --> %d\\n\", i, tmp);\n\n        if (i != n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &A[i].first, &A[i].second);\n\n    prepare();\n    // for (int i = 0; i < n; i++) printf(\"%d %d\\n\", vec[i]->first, vec[i]->second);\n\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/bzoj-1597.md","raw":"title: 「BZOJ 1597」土地购买 - 斜率优化 DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - 单调队列\n  - 斜率优化\npermalink: bzoj-1597\ndate: 2016-05-18 17:04:00\n---\n\n农夫 John 准备扩大他的农场，他正在考虑 $ N $（$ 1 \\leq N \\leq 50000 $）块长方形的土地。每块土地的长宽满足（$ 1 \\leq $ 长、宽 $ \\leq 1000000 $）。每块土地的价格是它的面积，但 FJ 可以同时购买多快土地。这些土地的价格是它们最大的长乘以它们最大的宽，但是土地的长宽不能交换。如果 FJ 买一块 $ 3 \\times 5 $ 的地和一块 $ 5 \\times 3 $ 的地，则他需要付 $ 5 \\times 5 = 25 $。FJ 希望买下所有的土地，但是他发现分组来买这些土地可以节省经费，他需要你帮助他找到最小的经费。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1597](http://www.lydsy.com/JudgeOnline/problem.php?id=1597)\n\n### 题解\n考虑两块土地，若其中一块可将另一块完全包含，则可以将较小的一块忽略，因为它总是可以被和另一块同时购买，而不增加花费。\n\n排序将上述情况筛除后，整个序列以一个关键字升序，另一个关键字降序。假设宽度 $ w(i) $ 降序，高度 $ h(i) $ 升序。设 $ f(i) $ 表示购买前 $ i $ 块土地的最小花费，考虑哪些不和 $ i $ 在一起购买。\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + w(j + 1) \\times h(i) \\} $$\n\n斜率优化，考虑两个决策 $ a $、$ b $，若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\nf(a) + w(a + 1) \\times h(i) & < f(b) + w(b + 1) \\times h(i) \\\\\nf(a) + f(b) & < (w(b + 1) - w(a + 1)) \\times h(i) \\\\\nf(a) + f(b) \\over w(b + 1) - w(a + 1) & < h(i) \\\\\n\\end{align*}\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50000;\n\nstd::pair<int, int> A[MAXN];\nstd::vector< std::pair<int, int>* > vec;\n\nint n;\nlong long f[MAXN + 1];\n\ninline void prepare() {\n    std::sort(A, A + n, std::greater< std::pair<int, int> >());\n\n    std::pair<int, int> *last = NULL;\n    for (int i = 0; i < n; i++) {\n        if (!last || A[i].second > last->second) {\n            vec.push_back(&A[i]);\n            last = &A[i];\n        }\n    }\n\n    n = vec.size();\n}\n\ninline long long w(const int i) { return static_cast<long long>(vec[i - 1]->first); }\ninline long long h(const int i) { return static_cast<long long>(vec[i - 1]->second); }\n\ninline void force() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + w(j + 1) * h(i)) {\n                f[i] = f[j] + w(j + 1) * h(i);\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n\ninline double slope(const int a, const int b) {\n    return double(f[a] - f[b])\n         / double(w(b + 1) - w(a + 1));\n}\n\ninline void dp() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n\n    static int q[MAXN + 1];\n    int *l = &q[0], *r = &q[0];\n    *r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < h(i)) l++;\n\n        int tmp = *l;\n        f[i] = f[tmp] + w(tmp + 1) * h(i);\n        // printf(\"%d --> %d\\n\", i, tmp);\n\n        if (i != n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &A[i].first, &A[i].second);\n\n    prepare();\n    // for (int i = 0; i < n; i++) printf(\"%d %d\\n\", vec[i]->first, vec[i]->second);\n\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"bzoj-1597","published":1,"updated":"2016-10-24T23:38:54.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sjd01l6ooxlwpwa5oi0"},{"title":"「BZOJ 1585」Earthquake Damage 2 - 最小割","date":"2016-06-22T08:14:00.000Z","_content":"\n农场里有 $ P $ 个牧场，有 $ C $ 条无向道路连接着他们，第 $ i $ 条道路连接着两个牧场 $ A_i $ 和 $ B_i $，注意可能有很多条道路连接着相同的 $ A_i $和 $ B_i $，并且 $ A_i $ 有可能和 $ B_i $ 相等。Farmer John 在 $ 1 $ 号牧场里。某些牧场被损坏，$ C $ 条道路没有一条损坏。有 $ N $ 头奶牛，第 $ i $ 头奶牛报告一个整数 $ R_i $，代表第 $ R_i $ 个牧场没有损毁，但不能够从第 $ R_i $ 个牧场经过一些没有损坏的牧场到达 $ 1 $ 号牧场。现在 Farmer John 想知道，最少有多少损坏的牧场。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1585](http://www.lydsy.com/JudgeOnline/problem.php?id=1585)\n\n### 题解\n将点拆成两个，之间容量为 $ 1 $。从源点连向每个 $ R_i $，从 $ 1 $ 点连向汇点，求出最小割即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u + n, v, INT_MAX);\n\t\taddEdge(v + n, u, INT_MAX);\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\n\t\taddEdge(s, u + n, INT_MAX);\n\t}\n\n\taddEdge(1, t, INT_MAX);\n\n\tint maxFlow = dinic(s, t, n + n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1585.md","raw":"title: 「BZOJ 1585」Earthquake Damage 2 - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - 网络流\n  - Dinic\n  - 最小割\n  - USACO\npermalink: bzoj-1585\ndate: 2016-06-22 16:14:00\n---\n\n农场里有 $ P $ 个牧场，有 $ C $ 条无向道路连接着他们，第 $ i $ 条道路连接着两个牧场 $ A_i $ 和 $ B_i $，注意可能有很多条道路连接着相同的 $ A_i $和 $ B_i $，并且 $ A_i $ 有可能和 $ B_i $ 相等。Farmer John 在 $ 1 $ 号牧场里。某些牧场被损坏，$ C $ 条道路没有一条损坏。有 $ N $ 头奶牛，第 $ i $ 头奶牛报告一个整数 $ R_i $，代表第 $ R_i $ 个牧场没有损毁，但不能够从第 $ R_i $ 个牧场经过一些没有损坏的牧场到达 $ 1 $ 号牧场。现在 Farmer John 想知道，最少有多少损坏的牧场。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1585](http://www.lydsy.com/JudgeOnline/problem.php?id=1585)\n\n### 题解\n将点拆成两个，之间容量为 $ 1 $。从源点连向每个 $ R_i $，从 $ 1 $ 点连向汇点，求出最小割即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u + n, v, INT_MAX);\n\t\taddEdge(v + n, u, INT_MAX);\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\n\t\taddEdge(s, u + n, INT_MAX);\n\t}\n\n\taddEdge(1, t, INT_MAX);\n\n\tint maxFlow = dinic(s, t, n + n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1585","published":1,"updated":"2016-06-22T08:14:52.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sjo01lcooxl36c3xbdc"},{"title":"「BZOJ 1477」青蛙的约会 - 扩展欧几里得","date":"2016-01-23T15:20:01.000Z","_content":"\n我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### 题解\n设两只青蛙跳了 $t$ 次后碰面，则有：\n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n令 $k=k_{1}-k_{2}$，得\n\n$$ (x+tm)-(y+tn)=kL $$\n\n移项，得\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n题目转化为求一个二元一次不定方程的**最小正整数**解。\n\n扩展欧几里得直接上即可，注意细节，注意细节，注意细节！\n\n### 代码\n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1477.md","raw":"title: 「BZOJ 1477」青蛙的约会 - 扩展欧几里得\ncategories: OI\ntags: \n  - BZOJ\n  - Tyvj\n  - EXGCD\n  - 数论\npermalink: bzoj-1477\ndate: 2016-01-23 23:20:01\n---\n\n我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### 题解\n设两只青蛙跳了 $t$ 次后碰面，则有：\n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n令 $k=k_{1}-k_{2}$，得\n\n$$ (x+tm)-(y+tn)=kL $$\n\n移项，得\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n题目转化为求一个二元一次不定方程的**最小正整数**解。\n\n扩展欧几里得直接上即可，注意细节，注意细节，注意细节！\n\n### 代码\n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1477","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sjw01ljooxlc2d2aocm"},{"title":"「BZOJ 1468」Tree - 点分治","date":"2016-06-14T13:59:00.000Z","_content":"\n给你一棵 Tree，以及这棵 Tree 上边的距离。问有多少对点它们两者间的距离小于等于 $ K $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1468](http://www.lydsy.com/JudgeOnline/problem.php?id=1468)\n\n### 题解\n点分治，考虑「经过根**且两端在不同子树**的路径」中满足条件的路径数目（如果两端在同一子树内，则距离不是最短）。\n\n遍历整棵树，得到所有点到根的距离，排序后得到一个递增序列。问题转化为序列中找两个元素加起来小于等于 $ K $ 的方案数。\n\n显然，对于给定的数 $ a_i $，满足 $ a_i + a_j \\leq K $ 的数 $ a_j $ 是连续的一段。我们只要从小到大枚举 $ i $，并维护 $ j $ 指向的位置，每次 $ i $ 增加时减小 $ j $，直到 $ a_i + a_j \\leq K $，此时 $ [i + 1,\\ j] $ 的数都满足条件，对答案的贡献即为 $ j - i $。\n\n这样求出来的路径会包含**两端在同一子树**的路径，我们需要再减去每棵子树的「经过根的路径」的答案数。实现时相当于对每棵子树做一遍上述过程，但计算距离时计算的还是相对于当前根的距离。\n\n时间复杂度为 $ O(n \\log ^ 2 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tprintf(\"%d\\n\", solve());\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1468.md","raw":"title: 「BZOJ 1468」Tree - 点分治\ncategories: OI\ntags: \n  - BZOJ\n  - 点分治\n  - 数据结构\npermalink: bzoj-1468\ndate: 2016-06-14 21:59:00\n---\n\n给你一棵 Tree，以及这棵 Tree 上边的距离。问有多少对点它们两者间的距离小于等于 $ K $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1468](http://www.lydsy.com/JudgeOnline/problem.php?id=1468)\n\n### 题解\n点分治，考虑「经过根**且两端在不同子树**的路径」中满足条件的路径数目（如果两端在同一子树内，则距离不是最短）。\n\n遍历整棵树，得到所有点到根的距离，排序后得到一个递增序列。问题转化为序列中找两个元素加起来小于等于 $ K $ 的方案数。\n\n显然，对于给定的数 $ a_i $，满足 $ a_i + a_j \\leq K $ 的数 $ a_j $ 是连续的一段。我们只要从小到大枚举 $ i $，并维护 $ j $ 指向的位置，每次 $ i $ 增加时减小 $ j $，直到 $ a_i + a_j \\leq K $，此时 $ [i + 1,\\ j] $ 的数都满足条件，对答案的贡献即为 $ j - i $。\n\n这样求出来的路径会包含**两端在同一子树**的路径，我们需要再减去每棵子树的「经过根的路径」的答案数。实现时相当于对每棵子树做一遍上述过程，但计算距离时计算的还是相对于当前根的距离。\n\n时间复杂度为 $ O(n \\log ^ 2 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tprintf(\"%d\\n\", solve());\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1468","published":1,"updated":"2016-06-16T10:09:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sk501lpooxllld15m00"},{"title":"「BZOJ 1334」Elect - 背包 DP","date":"2016-07-11T14:50:00.000Z","_content":"\n$ N $ 个政党要组成一个联合内阁，每个党都有自己的席位数。现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好。对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1334](http://www.lydsy.com/JudgeOnline/problem.php?id=1334)\n\n### 题解\n一个显然的结论是，只要当席位最少的党是多余的，这个方案就一定不合法。\n\n使用类似背包的方法，设 $ f(i) $ 表示联合内阁席位数为 $ i $ 时，席位最少的党的席位数的最大值。\n\n完成 DP 后扫描整个数组，满足 $ i - f(i) \\leq \\frac{m}{2} $ 的最大的 $ i $ 即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tint m = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), m += a[i];\n\n\tstatic int f[MAXM + 1];\n\tf[0] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= a[i]; j--) {\n\t\t\tf[j] = std::max(f[j], std::min(f[j - a[i]], a[i]));\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (i - f[i] <= m / 2) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1334.md","raw":"title: 「BZOJ 1334」Elect - 背包 DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - 背包 DP\npermalink: bzoj-1334\ndate: 2016-07-11 22:50:00\n---\n\n$ N $ 个政党要组成一个联合内阁，每个党都有自己的席位数。现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好。对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1334](http://www.lydsy.com/JudgeOnline/problem.php?id=1334)\n\n### 题解\n一个显然的结论是，只要当席位最少的党是多余的，这个方案就一定不合法。\n\n使用类似背包的方法，设 $ f(i) $ 表示联合内阁席位数为 $ i $ 时，席位最少的党的席位数的最大值。\n\n完成 DP 后扫描整个数组，满足 $ i - f(i) \\leq \\frac{m}{2} $ 的最大的 $ i $ 即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tint m = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), m += a[i];\n\n\tstatic int f[MAXM + 1];\n\tf[0] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= a[i]; j--) {\n\t\t\tf[j] = std::max(f[j], std::min(f[j - a[i]], a[i]));\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (i - f[i] <= m / 2) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1334","published":1,"updated":"2016-10-24T23:33:15.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9skb01luooxlybp32p0j"},{"title":"「BZOJ 1251」序列终结者 - Splay","id":"27","updated":"2016-01-19T13:02:18.000Z","date":"2016-01-18T13:44:15.000Z","_content":"\n给定一个长度为 `N` 的序列，每个序列的元素是一个整数。要支持以下三种操作：\n\n1. 将 `[L,R]` 这个区间内的所有数加上 `V`。\n2. 将 `[L,R]` 这个区间翻转，比如 `1 2 3 4` 变成 `4 3 2 1`。\n3. 求 `[L,R]` 这个区间中的最大值。 最开始所有元素都是 `0`。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### 题解\nSplay 裸题，比文艺平衡树强一点，那个没有区间修改和查询。\n\n区间修改：和翻转一样，维护一个 `lazy-tag`，然后 `pushDown()` 的时候下放即可。\n\n区间查询：维护一个子树值的和，查询的时候直接选择区间然后返回这个和。需要在 `maintain()` 中维护。\n\n细节需要注意，各种下放 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1251.md","raw":"title: 「BZOJ 1251」序列终结者 - Splay\ncategories: OI\ntags: \n  - Splay\n  - BZOJ\n  - CodeVS\n  - 高级数据结构\npermalink: bzoj-1251\nid: 27\nupdated: '2016-01-19 21:02:18'\ndate: 2016-01-18 21:44:15\n---\n\n给定一个长度为 `N` 的序列，每个序列的元素是一个整数。要支持以下三种操作：\n\n1. 将 `[L,R]` 这个区间内的所有数加上 `V`。\n2. 将 `[L,R]` 这个区间翻转，比如 `1 2 3 4` 变成 `4 3 2 1`。\n3. 求 `[L,R]` 这个区间中的最大值。 最开始所有元素都是 `0`。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### 题解\nSplay 裸题，比文艺平衡树强一点，那个没有区间修改和查询。\n\n区间修改：和翻转一样，维护一个 `lazy-tag`，然后 `pushDown()` 的时候下放即可。\n\n区间查询：维护一个子树值的和，查询的时候直接选择区间然后返回这个和。需要在 `maintain()` 中维护。\n\n细节需要注意，各种下放 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","slug":"bzoj-1251","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9skn01lzooxl1c1iro6x"},{"title":"「BZOJ 1176」Mokia - CDQ","date":"2016-06-20T11:48:00.000Z","_content":"\n维护一个 $ N \\times N $（$ N \\leq 2000000 $）的矩阵，初始值均为 $ S $。每次操作可以增加某格子的权值，或询问某子矩阵的总权值。\n\n修改操作数 $ \\leq 160000 $，询问数 $ \\leq 10000 $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1176](http://www.lydsy.com/JudgeOnline/problem.php?id=1176)\n\n### 题解\n设 $ Q(x1,\\ y1,\\ x2,\\ y2) $ 表示左上角 $ [x1,\\ y1] $ 右下角 $ [x2,\\ y2] $ 的矩形数字总和，则\n\n$$\n\\begin{aligned}\nQ(x1,\\ y1,\\ x2,\\ y2) = &  Q(0,\\ 0,\\ x2,\\ y2) \\\\\n& - Q(0,\\ 0,\\ x1 - 1,\\ y2) - Q(0,\\ 0,\\ x2,\\ y1 - 1) \\\\\n& + Q(0,\\ 0,\\ x1,\\ y1)\n\\end{aligned}\n$$\n\n问题转化为三维（时间、$ x $、$ y $）偏序问题，时间是有序的，对 $ x $ 进行分治，用树状数组维护 $ y $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 2000000 + 1;\nconst int MAXQ = 10000;\nconst int MAXM = 160000 + MAXQ * 4;\n\nstruct Triple {\n\tint id, x, y, d, delta, *ans;\n\n\tTriple() {}\n\tTriple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); }\n\tTriple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); }\n\n\tvoid setID() {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tbool isQuery() const { return d != 0; }\n} a[MAXM];\n\nint s, n, m, cnt, ans[MAXQ];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXM];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->x <= p2->x && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tif (!p->isQuery()) bit.update(p->y, p->delta);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tif (p->isQuery()) *p->ans += bit.query(p->y) * p->d;\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tif (q <= mid && !q->isQuery()) bit.clear(q->y);\n\t\t*q = *p;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &s, &n), n++;\n\t\n\tint qcnt = 0;\n\twhile (true) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 3) break;\n\t\telse if (t == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1++, y1++, x2++, y2++;\n\n\t\t\tint *p = &ans[qcnt++];\n\t\t\t*p = (y2 - y1 + 1) * (x2 - x1 + 1) * s;\n\t\t\ta[cnt++] = Triple(x2, y2, 1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y2, -1, p);\n\t\t\ta[cnt++] = Triple(x2, y1 - 1, -1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, 1, p);\n\t\t} else if (t == 1) {\n\t\t\tint x, y, delta;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &delta), x++, y++;\n\t\t\ta[cnt++] = Triple(x, y, delta);\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < cnt; i++) {\n\t\tprintf(\"Triple(x = %d, y = %d, d = %d, delta = %d)\\n\", a[i].x, a[i].y, a[i].d, a[i].delta);\n\t}\n\t*/\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qcnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1176.md","raw":"title: 「BZOJ 1176」Mokia - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - 数据结构\n  - 树状数组\n  - 分治\npermalink: bzoj-1176\ndate: 2016-06-20 19:48:00\n---\n\n维护一个 $ N \\times N $（$ N \\leq 2000000 $）的矩阵，初始值均为 $ S $。每次操作可以增加某格子的权值，或询问某子矩阵的总权值。\n\n修改操作数 $ \\leq 160000 $，询问数 $ \\leq 10000 $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1176](http://www.lydsy.com/JudgeOnline/problem.php?id=1176)\n\n### 题解\n设 $ Q(x1,\\ y1,\\ x2,\\ y2) $ 表示左上角 $ [x1,\\ y1] $ 右下角 $ [x2,\\ y2] $ 的矩形数字总和，则\n\n$$\n\\begin{aligned}\nQ(x1,\\ y1,\\ x2,\\ y2) = &  Q(0,\\ 0,\\ x2,\\ y2) \\\\\n& - Q(0,\\ 0,\\ x1 - 1,\\ y2) - Q(0,\\ 0,\\ x2,\\ y1 - 1) \\\\\n& + Q(0,\\ 0,\\ x1,\\ y1)\n\\end{aligned}\n$$\n\n问题转化为三维（时间、$ x $、$ y $）偏序问题，时间是有序的，对 $ x $ 进行分治，用树状数组维护 $ y $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 2000000 + 1;\nconst int MAXQ = 10000;\nconst int MAXM = 160000 + MAXQ * 4;\n\nstruct Triple {\n\tint id, x, y, d, delta, *ans;\n\n\tTriple() {}\n\tTriple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); }\n\tTriple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); }\n\n\tvoid setID() {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tbool isQuery() const { return d != 0; }\n} a[MAXM];\n\nint s, n, m, cnt, ans[MAXQ];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXM];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->x <= p2->x && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tif (!p->isQuery()) bit.update(p->y, p->delta);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tif (p->isQuery()) *p->ans += bit.query(p->y) * p->d;\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tif (q <= mid && !q->isQuery()) bit.clear(q->y);\n\t\t*q = *p;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &s, &n), n++;\n\t\n\tint qcnt = 0;\n\twhile (true) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 3) break;\n\t\telse if (t == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1++, y1++, x2++, y2++;\n\n\t\t\tint *p = &ans[qcnt++];\n\t\t\t*p = (y2 - y1 + 1) * (x2 - x1 + 1) * s;\n\t\t\ta[cnt++] = Triple(x2, y2, 1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y2, -1, p);\n\t\t\ta[cnt++] = Triple(x2, y1 - 1, -1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, 1, p);\n\t\t} else if (t == 1) {\n\t\t\tint x, y, delta;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &delta), x++, y++;\n\t\t\ta[cnt++] = Triple(x, y, delta);\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < cnt; i++) {\n\t\tprintf(\"Triple(x = %d, y = %d, d = %d, delta = %d)\\n\", a[i].x, a[i].y, a[i].d, a[i].delta);\n\t}\n\t*/\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qcnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1176","published":1,"updated":"2016-06-20T14:11:06.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sku01m5ooxlitgi4rbt"},{"title":"「HNOI2008」越狱 - 计数原理","date":"2016-04-06T13:04:45.000Z","_content":"\n监狱有连续编号为 $ 1 … N $ 的 $ N $ 个房间，每个房间关押一个犯人，有M种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### 题解\n考虑计算「不会越狱的方案数」，用「方案总数」减去「不会越狱的方案数」即可。\n\n方案总数：一共 $ N $ 个位置，每个位置有 $ M $ 种选择，总方案数为 $ M ^ N $。\n\n不会越狱的方案数：第一个位置有 $ M $ 种选择，之后每个位置都不能与上一个位置相同，即有 $ M - 1 $ 种选择，方案数为 $ M * (M - 1) ^ {N - 1} $。\n\n所以答案为 $ M ^ N - M * (M - 1) ^ {N - 1} $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1008.md","raw":"title: 「HNOI2008」越狱 - 计数原理\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - 计数原理\n  - 快速幂\npermalink: bzoj-1008\ndate: 2016-04-06 21:04:45\n---\n\n监狱有连续编号为 $ 1 … N $ 的 $ N $ 个房间，每个房间关押一个犯人，有M种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### 题解\n考虑计算「不会越狱的方案数」，用「方案总数」减去「不会越狱的方案数」即可。\n\n方案总数：一共 $ N $ 个位置，每个位置有 $ M $ 种选择，总方案数为 $ M ^ N $。\n\n不会越狱的方案数：第一个位置有 $ M $ 种选择，之后每个位置都不能与上一个位置相同，即有 $ M - 1 $ 种选择，方案数为 $ M * (M - 1) ^ {N - 1} $。\n\n所以答案为 $ M ^ N - M * (M - 1) ^ {N - 1} $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1008","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sl201mcooxlv07ksmff"},{"title":"「BeiJing2006」狼抓兔子 - 最小割","date":"2016-04-03T14:46:25.000Z","_content":"\n左上角点为 $ (1, 1) $，右下角点为 $ (N, M) $，有以下三种类型的道路：\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $ (1, 1) $ 的窝里，现在它们要跑到右下解 $ (N, M) $ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $ K $，狼王需要安排同样数量的 $ K $ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦.\n\n<!-- more -->\n\n### 链接\n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### 题解\nDinic 模板题，注意注意内存就好 ……\n\n边直接加双向边，反向边的容量和原边相等即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1001.md","raw":"title: 「BeiJing2006」狼抓兔子 - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - Dinic\n  - 网络流\n  - 最小割\npermalink: bzoj-1001\ndate: 2016-04-03 22:46:25\n---\n\n左上角点为 $ (1, 1) $，右下角点为 $ (N, M) $，有以下三种类型的道路：\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $ (1, 1) $ 的窝里，现在它们要跑到右下解 $ (N, M) $ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $ K $，狼王需要安排同样数量的 $ K $ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦.\n\n<!-- more -->\n\n### 链接\n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### 题解\nDinic 模板题，注意注意内存就好 ……\n\n边直接加双向边，反向边的容量和原边相等即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-1001","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sl901miooxljfxbb22y"},{"title":"离散对数与 BSGS","date":"2016-06-13T03:52:00.000Z","_content":"\n![zyz 大佬的评价](images/zyz.png)\n\n对于给定的 $ a $、$ b $、$ p $ 存在一个 $ x $，使得\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n则称 $ x $ 为 $ b $ 在模 $ p $ 意义下以 $ a $ 为底的**离散对数**。\n\n<!-- more -->\n\n### 性质\n离散对数有类似于一般的对数的性质\n\n$$\n\\begin{aligned}\n\\log_g x + \\log_g y &\\equiv \\log_g xy \\pmod p \\\\\n\\log_g x ^ y &\\equiv y \\log_g x \\pmod p\n\\end{aligned}\n$$\n\n### BSGS\n求解离散对数问题常用的算法是 BSGS（Baby-Step Giant-Step）。\n\n我们需要求解的方程为（$ p $ 为质数）\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n令 $ m = \\lceil \\sqrt p \\rceil $。  \n根据费马小定理，有 $ a ^ {p - 1} \\equiv 1 \\pmod p $，故若方程有解，则必然存在一个 $ 0 \\leq x < p - 1 $。\n\n设 $ x = im + j $，其中 $ 0 \\leq i,\\ j \\leq m $。\n\n方程可化为\n\n$$\n\\begin{align*}\na ^ {x} &\\equiv b \\pmod p \\\\\na ^ {im + j} &\\equiv b \\pmod p \\\\\na ^ {j} &\\equiv b \\times a ^ {-im} \\pmod p \\\\\na ^ {j} &\\equiv b \\times (a ^ {-m}) ^ i \\pmod p\n\\end{align*}\n$$\n\n我们只需要找到一组 $ i $、$ j $ 使得最后一个式子成立即可。\n\n枚举 $ j $，递推出左边 $ a ^ j \\bmod p $ 的所有取值，并将其按照 $ (a ^ j \\bmod p) \\mapsto j $ 的映射关系插入到哈希表中。\n\n之后，求出 $ a ^ m \\bmod p $ 的乘法逆元，即 $ a ^ {-m} \\bmod p $。枚举 $ i $，递推出所有的 $ b \\times (a ^ {-m}) ^ i $，每得到一个值后，从哈希表中查找该值，如果存在，取出其对应的 $ j $，$ x = im + j $ 即为一个解。\n\n时间复杂度为 $ O(\\sqrt p) $。\n\n#### 模板\n```c++\ninline void exgcd(long long a, long long b, long long &g, long long &x, long long &y)\n{\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(long long x, long long p)\n{\n\tlong long g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ninline long long bsgs(long long a, long long b, long long p)\n{\n\tif (a == 0) return b == 0 ? 1 : -1;\n\n\tstd::map<long long, long long> map;\n\n\tlong long m = ceil(sqrt(p)), t = 1;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tlong long k = inv(t, p), w = b;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (map.count(w)) return i * m + map[w];\n\t\tw = w * k % p;\n\t}\n\n\treturn -1;\n}\n```\n\n### EXBSGS\n用 BSGS 求解离散对数需要 $ p $ 为质数，因为算法中用到了 $ a $ 的乘法逆元。实际上，只要 $ \\gcd(a,\\ p) = 1 $ 成立即可。\n\n考虑方程\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n将它写成二元不定方程的形式\n\n$$ a ^ x = b + kp $$\n\n令 $ d = \\gcd(a,\\ p) $，若 $ d \\mid b $，则有\n\n$$ a ^ {x - 1} \\frac{a}{d} = \\frac{b}{d} + k \\frac{p}{d} $$\n\n即\n\n$$ a ^ {x - 1} \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod { \\frac{p}{d} } $$\n\n此时 $ \\gcd(\\frac{a}{d},\\ \\frac{p}{d}) = 1 $，可以求出 $ \\frac{a}{d} $ 的乘法逆元，乘到右边去\n\n$$ a ^ {x - 1} \\equiv \\frac{b}{d} \\times (\\frac{a}{d}) ^ {-1} \\pmod { \\frac{p}{d} } $$\n\n至此，问题转化为规模更小的子问题，继续如上过程直到 $ d = 1 $ 时调用 BSGS 求解即可。若过程中出现 $ d \\not \\mid b $ 则无解，若 $ b = 1 $ 则答案为 $ 0 $（加上之前所有减去的 $ 1 $）。\n\n#### 模板\n```c++\ninline long long exbsgs(long long a, long long b, long long p)\n{\n\tlong long t, c = 0;\n\twhile ((t = std::__gcd(a, p)) != 1)\n\t{\n\t\tif (b == 1) return c;\n\t\tif (b % t != 0) return -1;\n\t\tp /= t;\n\t\tb = b / t * inv(a / t, p) % p;\n\t\tc++;\n\t}\n\n\tlong long r = bsgs(a, b, p);\n\tif (r == -1) return -1;\n\telse return r + c;\n}\n```\n","source":"_posts/bsgs-notes.md","raw":"title: 离散对数与 BSGS\ncategories: OI\ntags: \n  - 数学\n  - 学习笔记\n  - 算法模板\n  - 离散对数\n  - BSGS\npermalink: bsgs-notes\ndate: 2016-06-13 11:52:00\n---\n\n![zyz 大佬的评价](images/zyz.png)\n\n对于给定的 $ a $、$ b $、$ p $ 存在一个 $ x $，使得\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n则称 $ x $ 为 $ b $ 在模 $ p $ 意义下以 $ a $ 为底的**离散对数**。\n\n<!-- more -->\n\n### 性质\n离散对数有类似于一般的对数的性质\n\n$$\n\\begin{aligned}\n\\log_g x + \\log_g y &\\equiv \\log_g xy \\pmod p \\\\\n\\log_g x ^ y &\\equiv y \\log_g x \\pmod p\n\\end{aligned}\n$$\n\n### BSGS\n求解离散对数问题常用的算法是 BSGS（Baby-Step Giant-Step）。\n\n我们需要求解的方程为（$ p $ 为质数）\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n令 $ m = \\lceil \\sqrt p \\rceil $。  \n根据费马小定理，有 $ a ^ {p - 1} \\equiv 1 \\pmod p $，故若方程有解，则必然存在一个 $ 0 \\leq x < p - 1 $。\n\n设 $ x = im + j $，其中 $ 0 \\leq i,\\ j \\leq m $。\n\n方程可化为\n\n$$\n\\begin{align*}\na ^ {x} &\\equiv b \\pmod p \\\\\na ^ {im + j} &\\equiv b \\pmod p \\\\\na ^ {j} &\\equiv b \\times a ^ {-im} \\pmod p \\\\\na ^ {j} &\\equiv b \\times (a ^ {-m}) ^ i \\pmod p\n\\end{align*}\n$$\n\n我们只需要找到一组 $ i $、$ j $ 使得最后一个式子成立即可。\n\n枚举 $ j $，递推出左边 $ a ^ j \\bmod p $ 的所有取值，并将其按照 $ (a ^ j \\bmod p) \\mapsto j $ 的映射关系插入到哈希表中。\n\n之后，求出 $ a ^ m \\bmod p $ 的乘法逆元，即 $ a ^ {-m} \\bmod p $。枚举 $ i $，递推出所有的 $ b \\times (a ^ {-m}) ^ i $，每得到一个值后，从哈希表中查找该值，如果存在，取出其对应的 $ j $，$ x = im + j $ 即为一个解。\n\n时间复杂度为 $ O(\\sqrt p) $。\n\n#### 模板\n```c++\ninline void exgcd(long long a, long long b, long long &g, long long &x, long long &y)\n{\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(long long x, long long p)\n{\n\tlong long g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ninline long long bsgs(long long a, long long b, long long p)\n{\n\tif (a == 0) return b == 0 ? 1 : -1;\n\n\tstd::map<long long, long long> map;\n\n\tlong long m = ceil(sqrt(p)), t = 1;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tlong long k = inv(t, p), w = b;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (map.count(w)) return i * m + map[w];\n\t\tw = w * k % p;\n\t}\n\n\treturn -1;\n}\n```\n\n### EXBSGS\n用 BSGS 求解离散对数需要 $ p $ 为质数，因为算法中用到了 $ a $ 的乘法逆元。实际上，只要 $ \\gcd(a,\\ p) = 1 $ 成立即可。\n\n考虑方程\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n将它写成二元不定方程的形式\n\n$$ a ^ x = b + kp $$\n\n令 $ d = \\gcd(a,\\ p) $，若 $ d \\mid b $，则有\n\n$$ a ^ {x - 1} \\frac{a}{d} = \\frac{b}{d} + k \\frac{p}{d} $$\n\n即\n\n$$ a ^ {x - 1} \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod { \\frac{p}{d} } $$\n\n此时 $ \\gcd(\\frac{a}{d},\\ \\frac{p}{d}) = 1 $，可以求出 $ \\frac{a}{d} $ 的乘法逆元，乘到右边去\n\n$$ a ^ {x - 1} \\equiv \\frac{b}{d} \\times (\\frac{a}{d}) ^ {-1} \\pmod { \\frac{p}{d} } $$\n\n至此，问题转化为规模更小的子问题，继续如上过程直到 $ d = 1 $ 时调用 BSGS 求解即可。若过程中出现 $ d \\not \\mid b $ 则无解，若 $ b = 1 $ 则答案为 $ 0 $（加上之前所有减去的 $ 1 $）。\n\n#### 模板\n```c++\ninline long long exbsgs(long long a, long long b, long long p)\n{\n\tlong long t, c = 0;\n\twhile ((t = std::__gcd(a, p)) != 1)\n\t{\n\t\tif (b == 1) return c;\n\t\tif (b % t != 0) return -1;\n\t\tp /= t;\n\t\tb = b / t * inv(a / t, p) % p;\n\t\tc++;\n\t}\n\n\tlong long r = bsgs(a, b, p);\n\tif (r == -1) return -1;\n\telse return r + c;\n}\n```\n","slug":"bsgs-notes","published":1,"updated":"2017-01-02T12:47:43.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9slg01moooxltxsdu2p9"},{"title":"高精度加、减、乘模板","date":"2016-03-14T13:34:42.000Z","_content":"\n今天早上写了一道高精度的题，一口气敲完了高精度加、减、乘。现在把模板放在这备用着 \n…… 需要者自取。\n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","source":"_posts/bigint-template.md","raw":"title: 高精度加、减、乘模板\ncategories: OI\ntags: \n  - 高精度\n  - 算法模板\npermalink: bigint-template\ndate: 2016-03-14 21:34:42\n---\n\n今天早上写了一道高精度的题，一口气敲完了高精度加、减、乘。现在把模板放在这备用着 \n…… 需要者自取。\n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","slug":"bigint-template","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9slq01mwooxlefrrc6zm"},{"title":"在时光的交叉路口 —— 写在 NOI2016 之后","date":"2016-08-30T18:42:00.000Z","_content":"\n<div style=\"width: 100%; text-align: center; \"><div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div></div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '夢追人',\n        author: 'KOKIA',\n        url: 'https://dn-menci.qbox.me/music/mzr/mzr.ogg',\n        pic: 'https://dn-menci.qbox.me/music/mzr/mzr.jpg',\n        lrc: '/at-the-cross-of-time/mzr.lrc'\n    }\n});\n</script>\n\n高一结束了，作为 OIer 的生活过去一半了，NOI 也是一个多月之前的事了，在这期间一直想着，想要写些什么。一拖再拖，终于拖到了开学前的最后一夜。\n\n<!-- more -->\n\nNOI 的成绩不怎么好，但相比几位比我优秀，但没有发挥好的伙伴来说，我或许已经足够幸运了。自己作为一个弱者，在不考虑随机条件的影响下，取得这等名次，也是理所当然的吧。  \n最后的两天，和一位考砸的朋友聊了两个晚上，心里也颇有些感触，当然，这都不能说明什么。比赛都会有竞争，而竞争，就一定会分出强弱。强者是理所应当的胜者，而弱者呢？\n\n或者说，弱者存在的意义是什么？\n想想 OIer 们 —— 从入学时的全省几千人，到初赛几百人通过，到联赛几十人拿到省一。百余人参加省选，一轮、二轮，然后十几个人组成省队。最后，全国的这些人中，五十多人拿到金牌 —— 也有上百人空手而归。\n\n如果这样想，竞赛就像一只筛子，每一次选拔，都会筛下一部分人，留下那些更强的，运气更好的，去等待下一次过筛。  \n事实上就是这样 —— 竞赛确是残酷的，就像极限运动，你很难想象，每一次正式比赛都有可能是你的最后一场，你必须时刻做好告别的心里准备 —— 一场重要比赛的失误足够让你永远失去资格。有时候，你必须承认，那些更强的人，更有理由获得最终的胜利。\n\n一次一次的，最终留下的便是最强的 —— 不至于万里挑一，但这种悬殊已经足够让真正的强者去展现自己。\n而弱者存在的意义，只是一个陪衬罢了。\n\n这并不是说弱者是完全失败的，更没有否定弱者的价值 —— 奥林匹克精神中便有「重在参与」，虽然每个人心中都有一个金牌梦，但能梦想成真的，每年只有那五十多个 —— 相对于「我一定要拿金牌」这种励志向的话语，你必须有另外的事支撑着你去努力，哪怕最终只能成为一个「陪衬者」。\n\n就像那位第二个到达南极的探险家，一个伟大的悲剧。\n\n当然，这也不是在否定自己成为「强者」、「胜者」的希望，尽管「金牌」看上去很遥远（实际上确实是的），但在你在成绩单上看见一个整天和你谈笑风生的伙伴卡线拿了金牌，你是不是也会感觉到，有些事，似乎从来没有离自己这么近？\n\n**或者说，我们还不够强。**\n\n很多 OIer 都常说自己弱，排除谦虚的成分，这就是我们和那些强者的差距。我们知道，只有明白自己弱，才可以尝试去变强，并且，我们在努力。我们不能保证自己最终能走到哪里，但也不会说自己永远无法到达他们的层次。\n\n想到这里，对接下来那段路，还有什么可害怕的呢？\n\n最后，祝贺各位拿到金牌的同学；祝高三退役的同学们高考顺利；同时，希望我们，我们几个人，能成为下一届省队中的佼佼者。\n\n眼下便是高二的新学期，文化课不可放弃，而 OI 更加重要，在这样一个交叉路口处，希望自己能找到一个平衡罢。晚安。\n","source":"_posts/at-the-cross-of-time.md","raw":"title: 在时光的交叉路口 —— 写在 NOI2016 之后\ncategories: \n  - Diary\npermalink: at-the-cross-of-time\ndate: 2016-08-31 02:42:00\n---\n\n<div style=\"width: 100%; text-align: center; \"><div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div></div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '夢追人',\n        author: 'KOKIA',\n        url: 'https://dn-menci.qbox.me/music/mzr/mzr.ogg',\n        pic: 'https://dn-menci.qbox.me/music/mzr/mzr.jpg',\n        lrc: '/at-the-cross-of-time/mzr.lrc'\n    }\n});\n</script>\n\n高一结束了，作为 OIer 的生活过去一半了，NOI 也是一个多月之前的事了，在这期间一直想着，想要写些什么。一拖再拖，终于拖到了开学前的最后一夜。\n\n<!-- more -->\n\nNOI 的成绩不怎么好，但相比几位比我优秀，但没有发挥好的伙伴来说，我或许已经足够幸运了。自己作为一个弱者，在不考虑随机条件的影响下，取得这等名次，也是理所当然的吧。  \n最后的两天，和一位考砸的朋友聊了两个晚上，心里也颇有些感触，当然，这都不能说明什么。比赛都会有竞争，而竞争，就一定会分出强弱。强者是理所应当的胜者，而弱者呢？\n\n或者说，弱者存在的意义是什么？\n想想 OIer 们 —— 从入学时的全省几千人，到初赛几百人通过，到联赛几十人拿到省一。百余人参加省选，一轮、二轮，然后十几个人组成省队。最后，全国的这些人中，五十多人拿到金牌 —— 也有上百人空手而归。\n\n如果这样想，竞赛就像一只筛子，每一次选拔，都会筛下一部分人，留下那些更强的，运气更好的，去等待下一次过筛。  \n事实上就是这样 —— 竞赛确是残酷的，就像极限运动，你很难想象，每一次正式比赛都有可能是你的最后一场，你必须时刻做好告别的心里准备 —— 一场重要比赛的失误足够让你永远失去资格。有时候，你必须承认，那些更强的人，更有理由获得最终的胜利。\n\n一次一次的，最终留下的便是最强的 —— 不至于万里挑一，但这种悬殊已经足够让真正的强者去展现自己。\n而弱者存在的意义，只是一个陪衬罢了。\n\n这并不是说弱者是完全失败的，更没有否定弱者的价值 —— 奥林匹克精神中便有「重在参与」，虽然每个人心中都有一个金牌梦，但能梦想成真的，每年只有那五十多个 —— 相对于「我一定要拿金牌」这种励志向的话语，你必须有另外的事支撑着你去努力，哪怕最终只能成为一个「陪衬者」。\n\n就像那位第二个到达南极的探险家，一个伟大的悲剧。\n\n当然，这也不是在否定自己成为「强者」、「胜者」的希望，尽管「金牌」看上去很遥远（实际上确实是的），但在你在成绩单上看见一个整天和你谈笑风生的伙伴卡线拿了金牌，你是不是也会感觉到，有些事，似乎从来没有离自己这么近？\n\n**或者说，我们还不够强。**\n\n很多 OIer 都常说自己弱，排除谦虚的成分，这就是我们和那些强者的差距。我们知道，只有明白自己弱，才可以尝试去变强，并且，我们在努力。我们不能保证自己最终能走到哪里，但也不会说自己永远无法到达他们的层次。\n\n想到这里，对接下来那段路，还有什么可害怕的呢？\n\n最后，祝贺各位拿到金牌的同学；祝高三退役的同学们高考顺利；同时，希望我们，我们几个人，能成为下一届省队中的佼佼者。\n\n眼下便是高二的新学期，文化课不可放弃，而 OI 更加重要，在这样一个交叉路口处，希望自己能找到一个平衡罢。晚安。\n","slug":"at-the-cross-of-time","published":1,"updated":"2016-12-31T05:04:52.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9slv01n0ooxlauq8af31"},{"title":"「APIO2012」Dispatching - 左偏树","date":"2017-01-04T03:33:00.000Z","_content":"\n给定一棵 $ n $ 个点的有根树，每个点有两个属性 $ C_i $ 与 $ L_i $，现在你要指定一个点 $ R $，并在 $ R $ 的子树内选取若干点（可以选取 $ R $ 自己），使得这些点的 $ C_i $ 的和不超过 $ M $，而一个选取方案的价值为选取人数 $ \\times L_R $，求选取方案的最大价值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2809](http://www.lydsy.com/JudgeOnline/problem.php?id=2809)\n\n### 题解\n坑。\n\n### 代码\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct LeftTree\n{\n\tLeftTree *lc, *rc;\n\tlong long dist, sum, x, size;\n\n\tLeftTree(long long x) : lc(NULL), rc(NULL), dist(0), sum(x), x(x), size(1) {}\n\n\t// 维护 size 和 sum\n\tvoid maintain()\n\t{\n\t\tsize = (lc ? lc->size : 0) + (rc ? rc->size : 0) + 1;\n\t\tsum = (lc ? lc->sum : 0) + (rc ? rc->sum : 0) + x;\n\t}\n\n\t// 合并 a、b 两棵左偏树，将 a 作为根返回\n\tstatic LeftTree *merge(LeftTree *a, LeftTree *b)\n\t{\n\t\tif (!a) return b;\n\t\tif (!b) return a;\n\t\tif (a->x < b->x) std::swap(a, b); // 保证根 >= 儿子\n\t\n\t\t// 递归合并右子树\n\t\ta->rc = merge(a->rc, b);\n\n\t\t// 如果右儿子距离更大了，需要交换左右儿子\n\t\tif (!a->lc || a->lc->dist < a->rc->dist) std::swap(a->lc, a->rc);\n\n\t\t// 计算新根的距离\n\t\ta->dist = a->rc ? a->rc->dist + 1 : 0;\n\t\ta->maintain();\n\n\t\treturn a;\n\t}\n};\n\nstruct Node\n{\n\tstruct Edge *e;\n\tlong long c, l;\n\tLeftTree *lt;\n} N[MAXN + 1], *seq[MAXN + 1]; // 记录 BFS 序\n\nstruct Edge\n{\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\ninline void bfs()\n{\n\tstd::queue<Node *> q;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\t// 记录 BFS 序\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next)\n\t\t{\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tlong long m;\n\tscanf(\"%d %lld\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint fa;\n\t\tscanf(\"%d\", &fa);\n\t\tif (fa) addEdge(fa, i);\n\n\t\tscanf(\"%lld %lld\", &N[i].c, &N[i].l);\n\n\t\t// 创建左偏树\n\t\tN[i].lt = new LeftTree(N[i].c);\n\t}\n\n\tbfs();\n\n\tlong long ans = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tNode *v = seq[i];\n\n\t\t// 将所有子节点加入\n\t\tfor (Edge *e = v->e; e; e = e->next)\n\t\t{\n\t\t\tv->lt = LeftTree::merge(v->lt, e->t->lt);\n\t\t}\n\n\t\t// 删除最大的节点，直到总和 <= M\n\t\twhile (v->lt->sum > m) v->lt = LeftTree::merge(v->lt->lc, v->lt->rc);\n\n\t\tans = std::max(ans, v->lt->size * v->l);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/apio2012-dispatching.md","raw":"title: 「APIO2012」Dispatching - 左偏树\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - 数据结构\n  - 左偏树\npermalink: apio2012-dispatching\ndate: 2017-01-04 11:33:00\n---\n\n给定一棵 $ n $ 个点的有根树，每个点有两个属性 $ C_i $ 与 $ L_i $，现在你要指定一个点 $ R $，并在 $ R $ 的子树内选取若干点（可以选取 $ R $ 自己），使得这些点的 $ C_i $ 的和不超过 $ M $，而一个选取方案的价值为选取人数 $ \\times L_R $，求选取方案的最大价值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2809](http://www.lydsy.com/JudgeOnline/problem.php?id=2809)\n\n### 题解\n坑。\n\n### 代码\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct LeftTree\n{\n\tLeftTree *lc, *rc;\n\tlong long dist, sum, x, size;\n\n\tLeftTree(long long x) : lc(NULL), rc(NULL), dist(0), sum(x), x(x), size(1) {}\n\n\t// 维护 size 和 sum\n\tvoid maintain()\n\t{\n\t\tsize = (lc ? lc->size : 0) + (rc ? rc->size : 0) + 1;\n\t\tsum = (lc ? lc->sum : 0) + (rc ? rc->sum : 0) + x;\n\t}\n\n\t// 合并 a、b 两棵左偏树，将 a 作为根返回\n\tstatic LeftTree *merge(LeftTree *a, LeftTree *b)\n\t{\n\t\tif (!a) return b;\n\t\tif (!b) return a;\n\t\tif (a->x < b->x) std::swap(a, b); // 保证根 >= 儿子\n\t\n\t\t// 递归合并右子树\n\t\ta->rc = merge(a->rc, b);\n\n\t\t// 如果右儿子距离更大了，需要交换左右儿子\n\t\tif (!a->lc || a->lc->dist < a->rc->dist) std::swap(a->lc, a->rc);\n\n\t\t// 计算新根的距离\n\t\ta->dist = a->rc ? a->rc->dist + 1 : 0;\n\t\ta->maintain();\n\n\t\treturn a;\n\t}\n};\n\nstruct Node\n{\n\tstruct Edge *e;\n\tlong long c, l;\n\tLeftTree *lt;\n} N[MAXN + 1], *seq[MAXN + 1]; // 记录 BFS 序\n\nstruct Edge\n{\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\ninline void bfs()\n{\n\tstd::queue<Node *> q;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\t// 记录 BFS 序\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next)\n\t\t{\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tlong long m;\n\tscanf(\"%d %lld\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint fa;\n\t\tscanf(\"%d\", &fa);\n\t\tif (fa) addEdge(fa, i);\n\n\t\tscanf(\"%lld %lld\", &N[i].c, &N[i].l);\n\n\t\t// 创建左偏树\n\t\tN[i].lt = new LeftTree(N[i].c);\n\t}\n\n\tbfs();\n\n\tlong long ans = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tNode *v = seq[i];\n\n\t\t// 将所有子节点加入\n\t\tfor (Edge *e = v->e; e; e = e->next)\n\t\t{\n\t\t\tv->lt = LeftTree::merge(v->lt, e->t->lt);\n\t\t}\n\n\t\t// 删除最大的节点，直到总和 <= M\n\t\twhile (v->lt->sum > m) v->lt = LeftTree::merge(v->lt->lc, v->lt->rc);\n\n\t\tans = std::max(ans, v->lt->size * v->l);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"apio2012-dispatching","published":1,"updated":"2017-01-04T08:26:53.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sm301n2ooxlq7v6oo1l"},{"title":"「APIO2010」特别行动队 - 斜率优化 DP","date":"2016-05-13T12:16:00.000Z","_content":"\n一支部队由 $ n $ 名预备役士兵组成，士兵从 $ 1 $ 到 $ n $ 编号，要将他们拆分成若干特别行动队，同一队中队员的编号应该连续。\n\n士兵 $ i $ 的初始战斗力为 $ x_i $ 一支特别行动队的初始战斗力 $ x $ 为各士兵初始战斗力之和。一支特别行动队的战斗力会被修正为 $ x' = Ax ^ 2 + Bx + C $，其中 $ A $、$ B $、$ C $ 已知，$ A < 0 $。\n\n求出将所有士兵组成若干特别行动队的最大总战斗力。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### 题解\n设 $ f[i] $ 表示前 $ i $ 名士兵分成若干特别行动队的最大战斗力，$ s_i $ 表示前缀和。\n\n枚举 $ j $，将第 $ j + 1 $ 到 $ i $ 个分在同一队里，状态转移方程为\n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n时间复杂度为 $ O(n ^ 2) $，超时，需要优化。\n\n考虑两个决策点 $ j = a $、$ j = b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n不等式右边单调递减，左边分母上的前缀和单调递增。\n\n用单调队列存储所有决策点，维护一个上凸壳，从左到后两两之间的斜率递减，且均小于当前的 $ 2 A s_i $，每次最优决策从最左边取得。\n\n时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","source":"_posts/apio2010-commando.md","raw":"title: 「APIO2010」特别行动队 - 斜率优化 DP\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - DP\n  - 单调队列\n  - 斜率优化\npermalink: apio2010-commando\ndate: 2016-05-13 20:16:00\n---\n\n一支部队由 $ n $ 名预备役士兵组成，士兵从 $ 1 $ 到 $ n $ 编号，要将他们拆分成若干特别行动队，同一队中队员的编号应该连续。\n\n士兵 $ i $ 的初始战斗力为 $ x_i $ 一支特别行动队的初始战斗力 $ x $ 为各士兵初始战斗力之和。一支特别行动队的战斗力会被修正为 $ x' = Ax ^ 2 + Bx + C $，其中 $ A $、$ B $、$ C $ 已知，$ A < 0 $。\n\n求出将所有士兵组成若干特别行动队的最大总战斗力。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### 题解\n设 $ f[i] $ 表示前 $ i $ 名士兵分成若干特别行动队的最大战斗力，$ s_i $ 表示前缀和。\n\n枚举 $ j $，将第 $ j + 1 $ 到 $ i $ 个分在同一队里，状态转移方程为\n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n时间复杂度为 $ O(n ^ 2) $，超时，需要优化。\n\n考虑两个决策点 $ j = a $、$ j = b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n不等式右边单调递减，左边分母上的前缀和单调递增。\n\n用单调队列存储所有决策点，维护一个上凸壳，从左到后两两之间的斜率递减，且均小于当前的 $ 2 A s_i $，每次最优决策从最左边取得。\n\n时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","slug":"apio2010-commando","published":1,"updated":"2016-10-24T23:33:06.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9smd01naooxliy5evulj"},{"title":"「APIO2009」抢掠计划 - 强联通分量","date":"2016-03-10T11:57:45.000Z","_content":"\n城中的道路都是单向的。不同的道路由路口连接。在每个路口都设立了一个 ATM 取款机。酒吧也都设在路口，虽然并不是每个路口都设有酒吧。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。\n\n他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### 题解\nTarjan 求强联通分量，一个强联通分量中的点肯定可以同时被抢走。缩点后图转化为 DAG，求出 DAG 上的最长路即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n一开始想到最长路，然后写了个 Dijkstra …… 写了个 Dijkstra ……\n\n(╯‵□′)╯︵┻━┻ 为什么我要写 Dijkstra！\n\n┬—┬ノ('-'ノ) 改成 Bellman-Ford 之后 WA 的更离谱了 ……\n\n最后发现是读进来的起点下标忘了减一 ……\n\n以后不能再出这种沙茶错误了啊啊啊啊啊啊 OvO ……\n\n### 还是吐槽\n从测试点命名中我们可以看出出题人的恶意 →_→\n\n|       测试点      | 结果| 内存使用量 | 时间使用量|\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","source":"_posts/apio2009-atm.md","raw":"title: 「APIO2009」抢掠计划 - 强联通分量\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - 强联通分量\n  - Tarjan\n  - 缩点\n  - DAG\n  - 最长路\n  - Bellman-Ford\npermalink: apio2009-atm\ndate: 2016-03-10 19:57:45\n---\n\n城中的道路都是单向的。不同的道路由路口连接。在每个路口都设立了一个 ATM 取款机。酒吧也都设在路口，虽然并不是每个路口都设有酒吧。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。\n\n他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### 题解\nTarjan 求强联通分量，一个强联通分量中的点肯定可以同时被抢走。缩点后图转化为 DAG，求出 DAG 上的最长路即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n一开始想到最长路，然后写了个 Dijkstra …… 写了个 Dijkstra ……\n\n(╯‵□′)╯︵┻━┻ 为什么我要写 Dijkstra！\n\n┬—┬ノ('-'ノ) 改成 Bellman-Ford 之后 WA 的更离谱了 ……\n\n最后发现是读进来的起点下标忘了减一 ……\n\n以后不能再出这种沙茶错误了啊啊啊啊啊啊 OvO ……\n\n### 还是吐槽\n从测试点命名中我们可以看出出题人的恶意 →_→\n\n|       测试点      | 结果| 内存使用量 | 时间使用量|\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","slug":"apio2009-atm","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9smm01nhooxlgmz9268i"},{"title":"「AHOI2014」支线剧情 - 费用流","date":"2016-04-08T09:57:21.000Z","_content":"\n游戏中有 $ N $ 个剧情点，由 $ 1 $ 到 $ N $ 编号，第 $ i $ 个剧情点可以经过不同的支线剧情，前往 $ K_i $ 种不同的新的剧情点。当然如果为 $ 0 $，则说明 $ i $ 号剧情点是游戏的一个结局了。\n\n开始处在 $ 1 $ 号剧情点。任何一个剧情点都是从 $ 1 $ 号剧情点可达的。从任意剧情点出发，都不能再回到这个剧情点。要想回到之前的剧情点，唯一的方法就是开始新的游戏，回到 $ 1 $ 号剧情点。可以在任何时刻退出游戏并重新开始。求花费最少的时间，看完所有不同的支线剧情。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3876](http://www.lydsy.com/JudgeOnline/problem.php?id=3876)\n\n### 题解\n题目是一个这样的模型：给出一个带权 DAG，从每个点均可回到 1 号点且不需要花费，求从 1 号点出发遍历整个 DAG 的最小花费。\n\n建立有上下界的费用流模型。\n\n对于原图中的每条边 $ (u, v, w) $，转化为 $ (u, v, [1, \\infty], w) $ 表示可以经过一次或多次这条边。对于不是 $ 1 $ 号点的任意一点 $ u $，连接 $ (u, 1, \\infty, 0) $ 表示在任意一点可无限次回到 $ 1 $ 号点。\n\n考虑去掉容量下界，对于原图中的每条边 $ (u, v, w) $，连接 $ (S, v, 1, w) $，表示这条边至少被走一次，连接 $ (u, T, 1, 0) $ 表示把从源点强行流给 $ v $ 的流量补给汇点。\n\n实际上，$ (u, T, 1, 0) $ 类型的边是可以合并的，实现时只需要连边 $ (u, T, k_i, 0) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2014-story.md","raw":"title: 「AHOI2014」支线剧情 - 费用流\ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - 网络流\n  - 费用流\n  - 上下界网络流\n  - Edmonds-Karp\npermalink: ahoi2014-story\ndate: 2016-04-08 17:57:21\n---\n\n游戏中有 $ N $ 个剧情点，由 $ 1 $ 到 $ N $ 编号，第 $ i $ 个剧情点可以经过不同的支线剧情，前往 $ K_i $ 种不同的新的剧情点。当然如果为 $ 0 $，则说明 $ i $ 号剧情点是游戏的一个结局了。\n\n开始处在 $ 1 $ 号剧情点。任何一个剧情点都是从 $ 1 $ 号剧情点可达的。从任意剧情点出发，都不能再回到这个剧情点。要想回到之前的剧情点，唯一的方法就是开始新的游戏，回到 $ 1 $ 号剧情点。可以在任何时刻退出游戏并重新开始。求花费最少的时间，看完所有不同的支线剧情。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3876](http://www.lydsy.com/JudgeOnline/problem.php?id=3876)\n\n### 题解\n题目是一个这样的模型：给出一个带权 DAG，从每个点均可回到 1 号点且不需要花费，求从 1 号点出发遍历整个 DAG 的最小花费。\n\n建立有上下界的费用流模型。\n\n对于原图中的每条边 $ (u, v, w) $，转化为 $ (u, v, [1, \\infty], w) $ 表示可以经过一次或多次这条边。对于不是 $ 1 $ 号点的任意一点 $ u $，连接 $ (u, 1, \\infty, 0) $ 表示在任意一点可无限次回到 $ 1 $ 号点。\n\n考虑去掉容量下界，对于原图中的每条边 $ (u, v, w) $，连接 $ (S, v, 1, w) $，表示这条边至少被走一次，连接 $ (u, T, 1, 0) $ 表示把从源点强行流给 $ v $ 的流量补给汇点。\n\n实际上，$ (u, T, 1, 0) $ 类型的边是可以合并的，实现时只需要连边 $ (u, T, k_i, 0) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"ahoi2014-story","published":1,"updated":"2016-12-25T01:57:05.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sn001nuooxlg7lxrwrf"},{"title":"「AHOI2013」作业 - 莫队","date":"2016-12-30T02:58:00.000Z","_content":"\n给一个长度为 $ n $ 的序列，每次查询一个区间 $ x \\in [l, r] $ 内满足 $ a_i \\leq x \\leq b_i $ 的 $ x $ 的数量和不重复的 $ x $ 的数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3236](http://www.lydsy.com/JudgeOnline/problem.php?id=3236)\n\n### 题解\n莫队处理询问，用一个树状数组维护当前区间的所有数。用一个数组维护当前区间每个数的出现次数，用另一个树状数组维护当前区间不重复的数，仅在每个数第一次出现或最后一次删除的时候对树状数组操作。\n\n需要离散化。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\n\nint blockSize;\n\nstruct Query {\n\tint l, r, a, b;\n\tstd::pair<int, int> *ans;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) return r < other.r;\n\t\telse return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\nint n, m, a[MAXN + 1];\n\nstruct BIT {\n\tint a[MAXN + MAXM * 2 + 1], n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t}\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n} bit1, bit2;\n\ninline std::pair<int, int> calc(int a, int b) {\n\treturn std::make_pair(bit1.query(a, b), bit2.query(a, b));\n}\n\nint cnt[MAXN + MAXM + 2 + 1];\ninline void extend(int l, int r, bool left, int d) {\n\tint pos = left ? l : r;\n\tbit1.update(a[pos], d);\n\tif (d == 1) {\n\t\tif (++cnt[a[pos]] == 1) bit2.update(a[pos], 1);\n\t} else {\n\t\tif (--cnt[a[pos]] == 0) bit2.update(a[pos], -1);\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (r < Q[i].r) extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) extend(l++, r, true, -1);\n\n\t\t*Q[i].ans = calc(Q[i].a, Q[i].b);\n\t}\n}\n\ninline void prepare() {\n\tstatic int set[MAXN + MAXM * 2 + 1];\n\tstd::copy(a + 1, a + n + 1, set + 1);\n\tfor (int i = 1; i <= m; i++) set[n + i] = Q[i].a;\n\tfor (int i = 1; i <= m; i++) set[n + m + i] = Q[i].b;\n\n\tstd::sort(set + 1, set + n + m * 2 + 1);\n\tint *end = std::unique(set + 1, set + n + m * 2 + 1);\n\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set;\n\n\tint cnt = end - (set + 1);\n\tbit1.init(cnt);\n\tbit2.init(cnt);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic std::pair<int, int> ans[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d %d %d\", &Q[i].l, &Q[i].r, &Q[i].a, &Q[i].b);\n\t\tQ[i].ans = &ans[i];\n\t}\n\n\tprepare();\n\n\tblockSize = floor(sqrt(n) + 1);\n\tstd::sort(Q + 1, Q + m + 1);\n\tsolve();\n\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2013-homework.md","raw":"title: 「AHOI2013」作业 - 莫队\ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - 莫队\n  - 数据结构\npermalink: ahoi2013-homework\ndate: 2016-12-30 10:58:00\n---\n\n给一个长度为 $ n $ 的序列，每次查询一个区间 $ x \\in [l, r] $ 内满足 $ a_i \\leq x \\leq b_i $ 的 $ x $ 的数量和不重复的 $ x $ 的数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3236](http://www.lydsy.com/JudgeOnline/problem.php?id=3236)\n\n### 题解\n莫队处理询问，用一个树状数组维护当前区间的所有数。用一个数组维护当前区间每个数的出现次数，用另一个树状数组维护当前区间不重复的数，仅在每个数第一次出现或最后一次删除的时候对树状数组操作。\n\n需要离散化。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\n\nint blockSize;\n\nstruct Query {\n\tint l, r, a, b;\n\tstd::pair<int, int> *ans;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) return r < other.r;\n\t\telse return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\nint n, m, a[MAXN + 1];\n\nstruct BIT {\n\tint a[MAXN + MAXM * 2 + 1], n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t}\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n} bit1, bit2;\n\ninline std::pair<int, int> calc(int a, int b) {\n\treturn std::make_pair(bit1.query(a, b), bit2.query(a, b));\n}\n\nint cnt[MAXN + MAXM + 2 + 1];\ninline void extend(int l, int r, bool left, int d) {\n\tint pos = left ? l : r;\n\tbit1.update(a[pos], d);\n\tif (d == 1) {\n\t\tif (++cnt[a[pos]] == 1) bit2.update(a[pos], 1);\n\t} else {\n\t\tif (--cnt[a[pos]] == 0) bit2.update(a[pos], -1);\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (r < Q[i].r) extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) extend(l++, r, true, -1);\n\n\t\t*Q[i].ans = calc(Q[i].a, Q[i].b);\n\t}\n}\n\ninline void prepare() {\n\tstatic int set[MAXN + MAXM * 2 + 1];\n\tstd::copy(a + 1, a + n + 1, set + 1);\n\tfor (int i = 1; i <= m; i++) set[n + i] = Q[i].a;\n\tfor (int i = 1; i <= m; i++) set[n + m + i] = Q[i].b;\n\n\tstd::sort(set + 1, set + n + m * 2 + 1);\n\tint *end = std::unique(set + 1, set + n + m * 2 + 1);\n\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set;\n\n\tint cnt = end - (set + 1);\n\tbit1.init(cnt);\n\tbit2.init(cnt);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic std::pair<int, int> ans[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d %d %d\", &Q[i].l, &Q[i].r, &Q[i].a, &Q[i].b);\n\t\tQ[i].ans = &ans[i];\n\t}\n\n\tprepare();\n\n\tblockSize = floor(sqrt(n) + 1);\n\tstd::sort(Q + 1, Q + m + 1);\n\tsolve();\n\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n```\n","slug":"ahoi2013-homework","published":1,"updated":"2016-12-30T03:08:09.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9snb01o3ooxl45snx359"},{"title":"「AHOI2013」差异 - 后缀数组","date":"2016-09-29T13:07:00.000Z","_content":"\n一个长度为 $ n $ 的字符串，令 $ T_i $ 表示它从第 $ i $ 个字符开始的后缀，求\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) - 2 \\times \\mathrm{lcp}(T_i, T_j) $$\n\n<!-- more -->\n\n### 链接\n[BZOJ 3238](http://www.lydsy.com/JudgeOnline/problem.php?id=3238)\n\n### 题解\n通过打表找规律可得\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) = \\sum\\limits_{i = 2} ^ n \\frac{i(i - 1)}{2} + i(i - 1) $$\n\n剩下的一部分为\n\n$$ -2 \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{lcp}(T_i, T_j) $$\n\n每两两间的 LCP 都被计算了一次。\n\n它相当于 $ \\mathrm{height}[] $ 数组中每个区间的最小值。我们考虑一个数 $ a_i $ 在哪些区间里会成为最小值。\n\n使用单调栈求出每个数 $ a_i $ 左边第一个**大于等于**（方便处理相等的数）它的数的位置，右边第一个**大于**它的数的位置，中间的所有区间内，$ a_i $ 均为最小值。\n\n设 $ a_i $ 左边到第一个大于等于它的数之前共有 $ l_i $ 个数（不含 $ a_i $ 和大于等于它的数），右边到第一个大于它的数之前共有 $ r_i $ 个数，则 $ a_i $ 对答案的贡献为\n\n$$ (l_i + 1) \\times (r_i + 1) \\times a_i $$\n\n求和即可\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 500000;\n\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\nunsigned long long l[MAXN], r[MAXN];\nchar s[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", &s[sa[i]]);\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n}\n\n/*\ninline int lcp(const int i, const int j) {\n\t/ *\n\tint a = rk[i], b = rk[j], ans = n;\n\tif (a > b) std::swap(a, b);\n\tfor (int i = a + 1; i <= b; i++) ans = std::min(ans, ht[i]);\n\t// printf(\"- %d %d => %d\\n\", a + 1, b, ans);\n\treturn ans;\n\t* /\n\n\tint ans = 0;\n\twhile (s[i + ans] == s[j + ans] && i + ans < n && j + ans < n) ans++;\n\treturn ans;\n}\n*/\n\ninline void prepare() {\n\tstd::stack<int> s;\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (!s.empty() && ht[s.top()] > ht[i]) s.pop();\n\t\tl[i] = s.empty() ? i - 1 : i - s.top() - 1;\n\t\ts.push(i);\n\t}\n\twhile (!s.empty()) s.pop();\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\twhile (!s.empty() && ht[s.top()] >= ht[i]) s.pop();\n\t\tr[i] = s.empty() ? n - i - 1 : s.top() - i - 1;\n\t\ts.push(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsuffixArray();\n\n\tunsigned long long sumLcp = 0;\n\t/*\n\tfor (int i = 1; i < n; i++) for (int j = i; j < n; j++) {\n\t\tint min = n;\n\t\tfor (int k = i; k <= j; k++) min = std::min(min, ht[k]);\n\t\tsumLcp += min;\n\t}\n\t*/\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tsumLcp += lcp(i, j);\n\t\t}\n\t}\n\t*/\n\n\tprepare();\n\t// /*\n\tfor (int i = 1; i < n; i++) {\n\t\t// printf(\"%d: %d %d\\n\", i, l[i], r[i]);\n\t\tsumLcp += static_cast<unsigned long long>(l[i] + 2) * (r[i] + 1) * ht[i];\n\t}\n\t// */\n\n\tunsigned long long sum = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tunsigned long long t = static_cast<unsigned long long>(1 + (i - 1)) * (i - 1) / 2 + static_cast<unsigned long long>(i) * (i - 1);\n\t\t// printf(\"- %lld\\n\", t);\n\t\tsum += t;\n\t\t// printf(\"sum = %llu\\n\", sum);\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t// printf(\"- %d %d\\n\", n - i, n - j);\n\t\t\tsum += n - i + n - j;\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%llu\\n\", sum - 2 * sumLcp);\n\n\treturn 0;\n}\n```","source":"_posts/ahoi2013-diff.md","raw":"title: 「AHOI2013」差异 - 后缀数组\ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - 字符串\n  - 后缀数组\n  - 单调栈\npermalink: ahoi2013-diff\ndate: 2016-09-29 21:07:00\n---\n\n一个长度为 $ n $ 的字符串，令 $ T_i $ 表示它从第 $ i $ 个字符开始的后缀，求\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) - 2 \\times \\mathrm{lcp}(T_i, T_j) $$\n\n<!-- more -->\n\n### 链接\n[BZOJ 3238](http://www.lydsy.com/JudgeOnline/problem.php?id=3238)\n\n### 题解\n通过打表找规律可得\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) = \\sum\\limits_{i = 2} ^ n \\frac{i(i - 1)}{2} + i(i - 1) $$\n\n剩下的一部分为\n\n$$ -2 \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{lcp}(T_i, T_j) $$\n\n每两两间的 LCP 都被计算了一次。\n\n它相当于 $ \\mathrm{height}[] $ 数组中每个区间的最小值。我们考虑一个数 $ a_i $ 在哪些区间里会成为最小值。\n\n使用单调栈求出每个数 $ a_i $ 左边第一个**大于等于**（方便处理相等的数）它的数的位置，右边第一个**大于**它的数的位置，中间的所有区间内，$ a_i $ 均为最小值。\n\n设 $ a_i $ 左边到第一个大于等于它的数之前共有 $ l_i $ 个数（不含 $ a_i $ 和大于等于它的数），右边到第一个大于它的数之前共有 $ r_i $ 个数，则 $ a_i $ 对答案的贡献为\n\n$$ (l_i + 1) \\times (r_i + 1) \\times a_i $$\n\n求和即可\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 500000;\n\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\nunsigned long long l[MAXN], r[MAXN];\nchar s[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", &s[sa[i]]);\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n}\n\n/*\ninline int lcp(const int i, const int j) {\n\t/ *\n\tint a = rk[i], b = rk[j], ans = n;\n\tif (a > b) std::swap(a, b);\n\tfor (int i = a + 1; i <= b; i++) ans = std::min(ans, ht[i]);\n\t// printf(\"- %d %d => %d\\n\", a + 1, b, ans);\n\treturn ans;\n\t* /\n\n\tint ans = 0;\n\twhile (s[i + ans] == s[j + ans] && i + ans < n && j + ans < n) ans++;\n\treturn ans;\n}\n*/\n\ninline void prepare() {\n\tstd::stack<int> s;\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (!s.empty() && ht[s.top()] > ht[i]) s.pop();\n\t\tl[i] = s.empty() ? i - 1 : i - s.top() - 1;\n\t\ts.push(i);\n\t}\n\twhile (!s.empty()) s.pop();\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\twhile (!s.empty() && ht[s.top()] >= ht[i]) s.pop();\n\t\tr[i] = s.empty() ? n - i - 1 : s.top() - i - 1;\n\t\ts.push(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsuffixArray();\n\n\tunsigned long long sumLcp = 0;\n\t/*\n\tfor (int i = 1; i < n; i++) for (int j = i; j < n; j++) {\n\t\tint min = n;\n\t\tfor (int k = i; k <= j; k++) min = std::min(min, ht[k]);\n\t\tsumLcp += min;\n\t}\n\t*/\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tsumLcp += lcp(i, j);\n\t\t}\n\t}\n\t*/\n\n\tprepare();\n\t// /*\n\tfor (int i = 1; i < n; i++) {\n\t\t// printf(\"%d: %d %d\\n\", i, l[i], r[i]);\n\t\tsumLcp += static_cast<unsigned long long>(l[i] + 2) * (r[i] + 1) * ht[i];\n\t}\n\t// */\n\n\tunsigned long long sum = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tunsigned long long t = static_cast<unsigned long long>(1 + (i - 1)) * (i - 1) / 2 + static_cast<unsigned long long>(i) * (i - 1);\n\t\t// printf(\"- %lld\\n\", t);\n\t\tsum += t;\n\t\t// printf(\"sum = %llu\\n\", sum);\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t// printf(\"- %d %d\\n\", n - i, n - j);\n\t\t\tsum += n - i + n - j;\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%llu\\n\", sum - 2 * sumLcp);\n\n\treturn 0;\n}\n```","slug":"ahoi2013-diff","published":1,"updated":"2016-09-29T13:25:07.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sno01o9ooxlgt1j214s"},{"title":"「AHOI2008」紧急集合 - 最近公共祖先","date":"2016-03-07T12:36:46.000Z","_content":"\n在树上寻找一个点，使其到给定三点的距离之和最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### 题解\n从样例中找出规律，三个点两两之间的 LCA 必有一对相等，写了个数据生成器用大数据验证了一下，确实是成立的。\n\n进一步得到规律，要找的点就是除了相等的一对 LCA 以外的另一个 LCA …… 别问我怎么证明，我不会 qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2008-meet.md","raw":"title: 「AHOI2008」紧急集合 - 最近公共祖先\ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - 最近公共祖先\n  - 乱搞\n  - 倍增\npermalink: ahoi2008-meet\ndate: 2016-03-07 20:36:46\n---\n\n在树上寻找一个点，使其到给定三点的距离之和最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### 题解\n从样例中找出规律，三个点两两之间的 LCA 必有一对相等，写了个数据生成器用大数据验证了一下，确实是成立的。\n\n进一步得到规律，要找的点就是除了相等的一对 LCA 以外的另一个 LCA …… 别问我怎么证明，我不会 qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"ahoi2008-meet","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sny01ohooxlry34pi7o"},{"title":"AC 自动机学习笔记","date":"2016-09-18T23:04:00.000Z","_content":"\nAC 自动机是一种多模式串匹配算法，可以用来在文本串中匹配一系列模式串，其时间复杂度与串的总长度成正比。\n\n<!-- more -->\n\n### 引入\n> 给一个 Trie 和一个文本串，求 Trie 上所有单词在文本串中的出现次数。\n\n如果使用朴素的匹配算法，时间复杂度非常高。如果对 Trie 上每个单词使用 KMP 预处理后匹配，还是需要做 $ O(n) $ 次的匹配。\n\n### 失配函数\n我们知道，在 KMP 算法中，如果在模式串的一个位置失配，则需要回到模式串的前面一个位置继续匹配。从位置 $ i $ 处失配后回到位置 $ j $，记作 $ \\mathrm{fail}(i) = j $。\n\n考虑 $ \\mathrm{fail}(i) = j $ 的条件 —— 串的前 $ j $ 个字符组成的前缀，是前 $ i $ 个字符组成前缀的**后缀**。理论依据是，这样可以保证每一时刻已匹配的字符尽量多，避免遗漏。\n\n现在将问题转化为，在一棵 Trie 上，求一个节点 $ j $，使得从根到 $ j $ 的路径组成的串是从根到 $ i $ 的路径组成串的**后缀**。\n\n### 构造\n![AC 自动机](acam-notes/acam.svg)\n\n设 $ i $ 父节点为 $ i' $，$ i $ 的入边上的字母为 $ c $。\n\n一个显然的结论是，如果 $ \\mathrm{fail}(i') $ 有字母 $ c $ 的出边，则该出边指向的点即为 $ \\mathrm{fail}(i) $。  \n例如，上图中 $ \\mathrm{fail}(7) = 1, \\mathrm{fail}(8) = 2 $。\n\n如果 $ \\mathrm{fail}(i') $ 没有字母 $ c $ 的出边，则沿着失配函数继续向上找，找到 $ \\mathrm{fail}(\\mathrm{fail}(i')) $ …… 直到找到根为止，如果找不到一个符合条件的节点，则 $ \\mathrm{fail}(i) $ 为根。  \n例如，上图中 $ \\mathrm{fail}(3) = 0 $。\n\n### 匹配\n用于匹配字符串时，设置一个当前状态 $ i $，它的初始值为根。每一次新加入一个字符 $ c $，首先检查状态 $ i $ 有没有出边 $ c $，如果有，则转移到出边指向的点上，否则继续检查 $ \\mathrm{fail}(i) $ 有无字符 $ c $ 的出边。如果找不到满足条件的节点，则转移到根节点上。\n\n如果状态转移到一个单词节点上，则代表这个单词被匹配到。但有时会出现，一个节点 $ i $ 不是单词，$ \\mathrm{fail}(i) $ 是单词。\n\n如下图，`a` 和 `bac` 组成的 AC 自动机（一些失配边已略去）。\n![AC 自动机](acam-notes/acam2.svg)\n\n节点 3 可以通过失配边连向 1，如果输入 `ba` 则会到达节点 3，节点 1 处的单词则被忽略。为了解决这一问题，我们引入另一个指针 —— 后缀链接，$ \\mathrm{next}(i) $ 表示从节点 $ i $ 沿着失配边转移，能到达的第一个单词节点，如上图 $ \\mathrm{next}(3) = 1 $。\n\n有了后缀链接，便可以在匹配时检查每个节点的后缀链接，记录匹配单词时要遍历被匹配节点后缀链接。\n\n后缀链接可以在失配指针之后求出 —— 如果 $ \\mathrm{fail}(i) $ 为单词节点，则 $ \\mathrm{next}(i) = \\mathrm{fail}(i) $，否则 $ \\mathrm{next}(i) = \\mathrm{next}(\\mathrm{fail}(i)) $。\n\n### 优化\n由于每次失配时需要使用失配指针，每次输入一个字符时经过的节点数不确定，时间复杂度可能会退化。\n\n一个显然的结论是，对于一个状态，对它添加一个字符之后，转移到的状态是确定的。**也就是说，我们可以预处理每一个状态可能转移到的所有状态**。\n\n对于节点 $ i $，如果它有字符 $ c $ 的出边，则在加入字符 $ c $ 时，它可以直接转移到该出边指向的节点上。否则，应该转移到 $ \\mathrm{fail}(i) $ 加入对应字符时转移到的点上。我们可以用递推的方式求出这些转移方式，并且在 Trie 树上加上这些边，得到**Trie 图**。\n\n### 模板\n统计每个模式串的出现次数。\n\n更新于 2016 年 12 月 27 日。\n\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\nconst int CHARSET_SIZE = 'z' - 'a' + 1; // 字符集大小\nconst char BASE_CHAR = 'a'; // 最小的字符\n\nstruct Trie\n{\n\tstruct Node\n\t{\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n\t\tint ans;\n\n\t\tNode(bool isWord = false) : next(NULL), fail(NULL), isWord(isWord)\n\t\t{\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply()\n\t\t{\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end)\n\t{\n\t\t// 插入过程类似 Splay\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// 向下找到对应节点的位置\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build()\n\t{\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root; // 边界\n\t\troot->next = NULL;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++)\n\t\t\t{\n\t\t\t\t// 使用引用减少代码量\n\t\t\t\tNode *&c = v->c[i];\n\n\t\t\t\t// 补全为 Trie 图\n\t\t\t\tif (!c)\n\t\t\t\t{\n\t\t\t\t\t// 如果 v == root，则 v->fail == root，c 和 v->fail->c[i] 是同一个变量\n                    c = v == root ? root : v->fail->c[i];\n                    continue;\n                }\n\t\t\t\tNode *u = v->fail;\n\n\t\t\t\t// 类似 KMP 的方法，求失配指针\n\t\t\t\t// while (u != root && !u->c[i]) u = u->fail; // 补全为 Trie 图，此行可省略\n\n\t\t\t\t// 如果 v == root，则失配后一定回到根节点\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\n\t\t\t\t// 沿着 fail 指针能走到的第一个单词节点\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end)\n\t{\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// 状态转移\n\t\t\tv = v->c[*p];\n\n\t\t\t// 统计答案\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply(); // 注意是 else if\n\t\t}\n\t}\n};\n```\n","source":"_posts/acam-notes.md","raw":"title: AC 自动机学习笔记\ncategories: OI\ntags: \n  - AC 自动机\n  - 字符串\n  - 学习笔记\n  - 算法模板\npermalink: acam-notes\ndate: 2016-09-19 07:04:00\n---\n\nAC 自动机是一种多模式串匹配算法，可以用来在文本串中匹配一系列模式串，其时间复杂度与串的总长度成正比。\n\n<!-- more -->\n\n### 引入\n> 给一个 Trie 和一个文本串，求 Trie 上所有单词在文本串中的出现次数。\n\n如果使用朴素的匹配算法，时间复杂度非常高。如果对 Trie 上每个单词使用 KMP 预处理后匹配，还是需要做 $ O(n) $ 次的匹配。\n\n### 失配函数\n我们知道，在 KMP 算法中，如果在模式串的一个位置失配，则需要回到模式串的前面一个位置继续匹配。从位置 $ i $ 处失配后回到位置 $ j $，记作 $ \\mathrm{fail}(i) = j $。\n\n考虑 $ \\mathrm{fail}(i) = j $ 的条件 —— 串的前 $ j $ 个字符组成的前缀，是前 $ i $ 个字符组成前缀的**后缀**。理论依据是，这样可以保证每一时刻已匹配的字符尽量多，避免遗漏。\n\n现在将问题转化为，在一棵 Trie 上，求一个节点 $ j $，使得从根到 $ j $ 的路径组成的串是从根到 $ i $ 的路径组成串的**后缀**。\n\n### 构造\n![AC 自动机](acam-notes/acam.svg)\n\n设 $ i $ 父节点为 $ i' $，$ i $ 的入边上的字母为 $ c $。\n\n一个显然的结论是，如果 $ \\mathrm{fail}(i') $ 有字母 $ c $ 的出边，则该出边指向的点即为 $ \\mathrm{fail}(i) $。  \n例如，上图中 $ \\mathrm{fail}(7) = 1, \\mathrm{fail}(8) = 2 $。\n\n如果 $ \\mathrm{fail}(i') $ 没有字母 $ c $ 的出边，则沿着失配函数继续向上找，找到 $ \\mathrm{fail}(\\mathrm{fail}(i')) $ …… 直到找到根为止，如果找不到一个符合条件的节点，则 $ \\mathrm{fail}(i) $ 为根。  \n例如，上图中 $ \\mathrm{fail}(3) = 0 $。\n\n### 匹配\n用于匹配字符串时，设置一个当前状态 $ i $，它的初始值为根。每一次新加入一个字符 $ c $，首先检查状态 $ i $ 有没有出边 $ c $，如果有，则转移到出边指向的点上，否则继续检查 $ \\mathrm{fail}(i) $ 有无字符 $ c $ 的出边。如果找不到满足条件的节点，则转移到根节点上。\n\n如果状态转移到一个单词节点上，则代表这个单词被匹配到。但有时会出现，一个节点 $ i $ 不是单词，$ \\mathrm{fail}(i) $ 是单词。\n\n如下图，`a` 和 `bac` 组成的 AC 自动机（一些失配边已略去）。\n![AC 自动机](acam-notes/acam2.svg)\n\n节点 3 可以通过失配边连向 1，如果输入 `ba` 则会到达节点 3，节点 1 处的单词则被忽略。为了解决这一问题，我们引入另一个指针 —— 后缀链接，$ \\mathrm{next}(i) $ 表示从节点 $ i $ 沿着失配边转移，能到达的第一个单词节点，如上图 $ \\mathrm{next}(3) = 1 $。\n\n有了后缀链接，便可以在匹配时检查每个节点的后缀链接，记录匹配单词时要遍历被匹配节点后缀链接。\n\n后缀链接可以在失配指针之后求出 —— 如果 $ \\mathrm{fail}(i) $ 为单词节点，则 $ \\mathrm{next}(i) = \\mathrm{fail}(i) $，否则 $ \\mathrm{next}(i) = \\mathrm{next}(\\mathrm{fail}(i)) $。\n\n### 优化\n由于每次失配时需要使用失配指针，每次输入一个字符时经过的节点数不确定，时间复杂度可能会退化。\n\n一个显然的结论是，对于一个状态，对它添加一个字符之后，转移到的状态是确定的。**也就是说，我们可以预处理每一个状态可能转移到的所有状态**。\n\n对于节点 $ i $，如果它有字符 $ c $ 的出边，则在加入字符 $ c $ 时，它可以直接转移到该出边指向的节点上。否则，应该转移到 $ \\mathrm{fail}(i) $ 加入对应字符时转移到的点上。我们可以用递推的方式求出这些转移方式，并且在 Trie 树上加上这些边，得到**Trie 图**。\n\n### 模板\n统计每个模式串的出现次数。\n\n更新于 2016 年 12 月 27 日。\n\n![zyz 大佬的评价](images/zyz.png)\n\n```c++\nconst int CHARSET_SIZE = 'z' - 'a' + 1; // 字符集大小\nconst char BASE_CHAR = 'a'; // 最小的字符\n\nstruct Trie\n{\n\tstruct Node\n\t{\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n\t\tint ans;\n\n\t\tNode(bool isWord = false) : next(NULL), fail(NULL), isWord(isWord)\n\t\t{\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply()\n\t\t{\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end)\n\t{\n\t\t// 插入过程类似 Splay\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// 向下找到对应节点的位置\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build()\n\t{\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root; // 边界\n\t\troot->next = NULL;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++)\n\t\t\t{\n\t\t\t\t// 使用引用减少代码量\n\t\t\t\tNode *&c = v->c[i];\n\n\t\t\t\t// 补全为 Trie 图\n\t\t\t\tif (!c)\n\t\t\t\t{\n\t\t\t\t\t// 如果 v == root，则 v->fail == root，c 和 v->fail->c[i] 是同一个变量\n                    c = v == root ? root : v->fail->c[i];\n                    continue;\n                }\n\t\t\t\tNode *u = v->fail;\n\n\t\t\t\t// 类似 KMP 的方法，求失配指针\n\t\t\t\t// while (u != root && !u->c[i]) u = u->fail; // 补全为 Trie 图，此行可省略\n\n\t\t\t\t// 如果 v == root，则失配后一定回到根节点\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\n\t\t\t\t// 沿着 fail 指针能走到的第一个单词节点\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end)\n\t{\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// 状态转移\n\t\t\tv = v->c[*p];\n\n\t\t\t// 统计答案\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply(); // 注意是 else if\n\t\t}\n\t}\n};\n```\n","slug":"acam-notes","published":1,"updated":"2017-01-02T07:03:44.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9so601ooooxluh670jtd"},{"title":"「省队集训 2016」Play with array - 块状链表","date":"2016-05-27T15:55:00.000Z","_content":"\n有一个长度为 $ n $ 的数列，支持以下两种操作：\n\n1. 将 $ a_r $ 移动到 $ a_l $ 的前面；\n2. 查询 $ [l,\\ r] $ 中 $ k $ 的出现次数。\n\n<!-- more -->\n\n### 题解\n将序列按照 $ O(\\sqrt n) $ 分块，维护块状链表，将每次修改转化为一次插入一次删除，每个块记录每个数出现次数。\n\n每次查询时，将 $ [l,\\ r] $ 的答案转化为 $ [1,\\ r] $ 的答案减去 $ [1,\\ l - 1] $ 的答案。对于块内部分直接查询，块外部分暴力。\n\n时间复杂度、空间复杂度均为 $ O(n \\sqrt n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\n#define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__)\n\nconst int MAXN = 100000;\nconst int MAXN_SQRT = 316 + 1;\nconst int MAXM = 100000;\n\nint n, m, a[MAXN];\n\nstruct BlockList {\n\tstruct Block {\n\t\tstd::list<int> l;\n\t\tstd::vector<int> sum;\n\n\t\tBlock() : sum(n) {}\n\n\t\tinline int left(const int k, const int pos) {\n\t\t\tint res = 0;\n\t\t\tstd::list<int>::const_iterator it = l.begin();\n\t\t\tfor (int i = 0; i <= pos; i++) if (*it++ == k) res++;\n\t\t\treturn res;\n\t\t}\n\t};\n\tstd::list<Block> blocks;\n\tint blockCount, blockSize;\n\n\tinline void build(const int *a, const int n) {\n\t\tblockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast<double>(n) / blockCount);\n\t\t// dprintf(\"BlockList::build(): blockCount = %d, blockSize = %d\\n\", blockCount, blockSize);\n\t\tblocks.resize(blockCount);\n\t\tstd::list<Block>::iterator b = blocks.begin();\n\t\tfor (int i = 0, j = 0; i < blockCount; i++, b++) {\n\t\t\tfor (int k = 0; k <= blockSize && j < n; k++, j++) {\n\t\t\t\tb->sum[a[j]]++;\n\t\t\t\tb->l.push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int erase(int pos) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tconst int x = *it;\n\t\t\t\tb->sum[*it]--;\n\t\t\t\tb->l.erase(it);\n\t\t\t\treturn x;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline void insert(int pos, const int x) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tb->sum[x]++;\n\t\t\t\tb->l.insert(it, x);\n\t\t\t\treturn;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline int query(int pos, const int k) {\n\t\tint ans = 0;\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tans += b->left(k, pos);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpos -= b->l.size();\n\t\t\t\tans += b->sum[k];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline void mergeNext(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator next = b;\n\t\tnext++;\n\t\tif (next == blocks.end()) return;\n\t\tfor (std::list<int>::const_iterator it = next->l.begin(); it != next->l.end(); it++) {\n\t\t\tb->l.push_back(*it);\n\t\t\tb->sum[*it]++;\n\t\t}\n\t\tblocks.erase(next);\n\t}\n\n\tinline void split(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator newBlock = blocks.insert(b, Block());\n\t\tfor (int i = 0; i < b->l.size() / 2; i++) {\n\t\t\tconst int &x = b->l.front();\n\t\t\tnewBlock->l.push_back(x);\n\t\t\tnewBlock->sum[x]++;\n\t\t\tb->sum[x]--;\n\t\t\tb->l.pop_front();\n\t\t}\n\t}\n\n\tinline void maintain() {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (b->l.size() <= blockSize / 2) mergeNext(b);\n\t\t\telse if (b->l.size() >= blockSize * 2) split(b);\n\t\t}\n\t}\n\n\tinline void print() {\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tdprintf(\"blockSize = %d\\n\", b->l.size());\n\t\t}\n\n\t\treturn;\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tfor (std::list<int>::const_iterator it = b->l.begin(); it != b->l.end(); it++) {\n\t\t\t\tdprintf(\"%d \", *it + 1);\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%c\", '\\n');\n\t}\n} list;\n\nint main() {\n\t// freopen(\"array.in\", \"r\", stdin);\n\t// freopen(\"array.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]), a[i]--;\n\t}\n\n\tlist.build(a, n);\n\n\t// list.print();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r), l--, r--;\n\t\tif (t == 1) {\n\t\t\tint x = list.erase(r);\n\t\t\tlist.insert(l, x);\n\t\t\t// list.print();\n\t\t\tlist.maintain();\n\t\t\t// list.print();\n\t\t\t// dprintf(\"%c\", '\\n');\n\t\t} else {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k), k--;\n\t\t\tint R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k);\n\t\t\tprintf(\"%d\\n\", R - L);\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\t// list.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/20160527-array.md","raw":"title: 「省队集训 2016」Play with array - 块状链表\ncategories: OI\ntags: \n  - 省队集训\n  - 分块\n  - 块状链表\n  - 数据结构\npermalink: 20160527-array\ndate: 2016-05-27 23:55:00\n---\n\n有一个长度为 $ n $ 的数列，支持以下两种操作：\n\n1. 将 $ a_r $ 移动到 $ a_l $ 的前面；\n2. 查询 $ [l,\\ r] $ 中 $ k $ 的出现次数。\n\n<!-- more -->\n\n### 题解\n将序列按照 $ O(\\sqrt n) $ 分块，维护块状链表，将每次修改转化为一次插入一次删除，每个块记录每个数出现次数。\n\n每次查询时，将 $ [l,\\ r] $ 的答案转化为 $ [1,\\ r] $ 的答案减去 $ [1,\\ l - 1] $ 的答案。对于块内部分直接查询，块外部分暴力。\n\n时间复杂度、空间复杂度均为 $ O(n \\sqrt n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\n#define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__)\n\nconst int MAXN = 100000;\nconst int MAXN_SQRT = 316 + 1;\nconst int MAXM = 100000;\n\nint n, m, a[MAXN];\n\nstruct BlockList {\n\tstruct Block {\n\t\tstd::list<int> l;\n\t\tstd::vector<int> sum;\n\n\t\tBlock() : sum(n) {}\n\n\t\tinline int left(const int k, const int pos) {\n\t\t\tint res = 0;\n\t\t\tstd::list<int>::const_iterator it = l.begin();\n\t\t\tfor (int i = 0; i <= pos; i++) if (*it++ == k) res++;\n\t\t\treturn res;\n\t\t}\n\t};\n\tstd::list<Block> blocks;\n\tint blockCount, blockSize;\n\n\tinline void build(const int *a, const int n) {\n\t\tblockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast<double>(n) / blockCount);\n\t\t// dprintf(\"BlockList::build(): blockCount = %d, blockSize = %d\\n\", blockCount, blockSize);\n\t\tblocks.resize(blockCount);\n\t\tstd::list<Block>::iterator b = blocks.begin();\n\t\tfor (int i = 0, j = 0; i < blockCount; i++, b++) {\n\t\t\tfor (int k = 0; k <= blockSize && j < n; k++, j++) {\n\t\t\t\tb->sum[a[j]]++;\n\t\t\t\tb->l.push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int erase(int pos) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tconst int x = *it;\n\t\t\t\tb->sum[*it]--;\n\t\t\t\tb->l.erase(it);\n\t\t\t\treturn x;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline void insert(int pos, const int x) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tb->sum[x]++;\n\t\t\t\tb->l.insert(it, x);\n\t\t\t\treturn;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline int query(int pos, const int k) {\n\t\tint ans = 0;\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tans += b->left(k, pos);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpos -= b->l.size();\n\t\t\t\tans += b->sum[k];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline void mergeNext(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator next = b;\n\t\tnext++;\n\t\tif (next == blocks.end()) return;\n\t\tfor (std::list<int>::const_iterator it = next->l.begin(); it != next->l.end(); it++) {\n\t\t\tb->l.push_back(*it);\n\t\t\tb->sum[*it]++;\n\t\t}\n\t\tblocks.erase(next);\n\t}\n\n\tinline void split(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator newBlock = blocks.insert(b, Block());\n\t\tfor (int i = 0; i < b->l.size() / 2; i++) {\n\t\t\tconst int &x = b->l.front();\n\t\t\tnewBlock->l.push_back(x);\n\t\t\tnewBlock->sum[x]++;\n\t\t\tb->sum[x]--;\n\t\t\tb->l.pop_front();\n\t\t}\n\t}\n\n\tinline void maintain() {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (b->l.size() <= blockSize / 2) mergeNext(b);\n\t\t\telse if (b->l.size() >= blockSize * 2) split(b);\n\t\t}\n\t}\n\n\tinline void print() {\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tdprintf(\"blockSize = %d\\n\", b->l.size());\n\t\t}\n\n\t\treturn;\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tfor (std::list<int>::const_iterator it = b->l.begin(); it != b->l.end(); it++) {\n\t\t\t\tdprintf(\"%d \", *it + 1);\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%c\", '\\n');\n\t}\n} list;\n\nint main() {\n\t// freopen(\"array.in\", \"r\", stdin);\n\t// freopen(\"array.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]), a[i]--;\n\t}\n\n\tlist.build(a, n);\n\n\t// list.print();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r), l--, r--;\n\t\tif (t == 1) {\n\t\t\tint x = list.erase(r);\n\t\t\tlist.insert(l, x);\n\t\t\t// list.print();\n\t\t\tlist.maintain();\n\t\t\t// list.print();\n\t\t\t// dprintf(\"%c\", '\\n');\n\t\t} else {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k), k--;\n\t\t\tint R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k);\n\t\t\tprintf(\"%d\\n\", R - L);\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\t// list.print();\n\n\treturn 0;\n}\n```\n","slug":"20160527-array","published":1,"updated":"2016-05-27T16:14:44.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9soh01ouooxl31ydifdg"},{"title":"「省选模拟赛」完美理论 - 最大权闭合图","date":"2016-04-04T02:35:52.000Z","_content":"\n有两棵点集相同的树，顶点编号为 $ 1 \\to n $，每个点都有一个权值，你需要选择一个点集的子集，使得这个子集在两棵树上都是一个联通块。你要选出权值和最大的子集，你只需要输出最大的权值和。\n\n<!-- more -->\n\n### 题解\n首先，我们可以枚举一个点，使得这个点在选择的连通块中，限制转化为：选择了某个点，就必须选择它的父节点。\n\n于是这就是经典的最大权闭合图问题，用最小割模型解决即可。\n\n### 40分代码（暴搜 + 树形DP）\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160404-theory.md","raw":"title: 「省选模拟赛」完美理论 - 最大权闭合图\ncategories: OI\ntags: \n  - 安徽集训\n  - 树形 DP\n  - 暴力\n  - 网络流\n  - Dinic\n  - 最大权闭合图\npermalink: 20160404-theory\ndate: 2016-04-04 10:35:52\n---\n\n有两棵点集相同的树，顶点编号为 $ 1 \\to n $，每个点都有一个权值，你需要选择一个点集的子集，使得这个子集在两棵树上都是一个联通块。你要选出权值和最大的子集，你只需要输出最大的权值和。\n\n<!-- more -->\n\n### 题解\n首先，我们可以枚举一个点，使得这个点在选择的连通块中，限制转化为：选择了某个点，就必须选择它的父节点。\n\n于是这就是经典的最大权闭合图问题，用最小割模型解决即可。\n\n### 40分代码（暴搜 + 树形DP）\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160404-theory","published":1,"updated":"2016-10-24T23:32:53.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sor01p2ooxlmqnul7js"},{"title":"「省选模拟赛」扔鸡蛋 - DP","date":"2016-04-01T13:24:45.000Z","_content":"\n有 $ N $ 层楼，第 $ M $ 层以下扔鸡蛋会碎，你有 $ K $ 个鸡蛋，找出这个 $ M $ 需要多少次实验。\n\n<!-- more -->\n\n### 题解\n用 $ f_{i, j} $ 表示用 i 个鸡蛋做 j 次实验最多能测试出多少层的楼，考虑第一个鸡蛋是否摔碎，即：\n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n第二维大小取 $ 10 ^ 5 $ 即可，当询问 $ (N, K) $ 时，在 $ f_K $ 中二分查找 $ N $ 即可。\n\n注意当 $ K = 1, 2, 3 $ 时答案非常大，需要特判。\n\n当 $ K = 1 $ 时，答案为 $ N $。  \n当 $ K = 2 $ 时，设答案为 $ x $，有：\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n当 $ K = 3 $ 时，难以推出公式，我们可以再为 1 ~ 3 开一个 $ f $ 数组，第二维开到 $ 2 \\times 10 ^ 6 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/20160331-naive.md","raw":"title: 「省选模拟赛」扔鸡蛋 - DP\ncategories: OI\ntags: \n  - 安徽集训\n  - DP\n  - 二分查找\npermalink: 20160331-naive\ndate: 2016-04-01 21:24:45\n---\n\n有 $ N $ 层楼，第 $ M $ 层以下扔鸡蛋会碎，你有 $ K $ 个鸡蛋，找出这个 $ M $ 需要多少次实验。\n\n<!-- more -->\n\n### 题解\n用 $ f_{i, j} $ 表示用 i 个鸡蛋做 j 次实验最多能测试出多少层的楼，考虑第一个鸡蛋是否摔碎，即：\n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n第二维大小取 $ 10 ^ 5 $ 即可，当询问 $ (N, K) $ 时，在 $ f_K $ 中二分查找 $ N $ 即可。\n\n注意当 $ K = 1, 2, 3 $ 时答案非常大，需要特判。\n\n当 $ K = 1 $ 时，答案为 $ N $。  \n当 $ K = 2 $ 时，设答案为 $ x $，有：\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n当 $ K = 3 $ 时，难以推出公式，我们可以再为 1 ~ 3 开一个 $ f $ 数组，第二维开到 $ 2 \\times 10 ^ 6 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"20160331-naive","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sp101pbooxlgpu4kmkq"},{"title":"「省选模拟赛」小奇的集合 - 矩阵乘法","date":"2016-03-20T14:50:45.000Z","_content":"\n有一个大小为 $ n $ 的可重集 $ S $，小奇每次操作可以加入一个数 $ a + b $（$ a $，$ b $ 均属于 $ S $），求 $ k $ 次操作后它可获得的 $ S $ 的和的最大值（数据保证这个值为非负数）。\n\n<!-- more -->\n\n### 题解\n每次要取的都是最大的和次大的，考虑最大的和次大的都是非负数正数的情况，使用矩阵乘法（$ m1 $ 为最大值，$ m2 $ 为次大值，$ s $ 为当前总和）：\n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n对于次大值为负的情况，先模拟，直到为正再用矩阵乘法。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-set.md","raw":"title: 「省选模拟赛」小奇的集合 - 矩阵乘法\ncategories: OI\ntags: \n  - 安徽集训\n  - 矩阵乘法\n  - 快速幂\n  - 数学\npermalink: 20160319-set\ndate: 2016-03-20 22:50:45\n---\n\n有一个大小为 $ n $ 的可重集 $ S $，小奇每次操作可以加入一个数 $ a + b $（$ a $，$ b $ 均属于 $ S $），求 $ k $ 次操作后它可获得的 $ S $ 的和的最大值（数据保证这个值为非负数）。\n\n<!-- more -->\n\n### 题解\n每次要取的都是最大的和次大的，考虑最大的和次大的都是非负数正数的情况，使用矩阵乘法（$ m1 $ 为最大值，$ m2 $ 为次大值，$ s $ 为当前总和）：\n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n对于次大值为负的情况，先模拟，直到为正再用矩阵乘法。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-set","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sp901phooxlc2uv4z47"},{"title":"「省选模拟赛」小奇的糖果 - 扫描线 + 链表","date":"2016-03-20T14:58:12.000Z","_content":"\n有 $ N $ 个彩色糖果在平面上。小奇想在平面上取一条水平的线段，并拾起它上方或下方的所有糖果。求出最多能够拾起多少糖果，使得获得的糖果并不包含所有的颜色。\n\n<!-- more -->\n\n### 题解\n对纵坐标离散化。\n\n用树状数组维护「当前」横坐标在某个区间内的糖果数量。\n\n用链表维护「当前」某个糖果左边右边与它横坐标最近的两个糖果。\n\n扫描线从上往下扫，初始时树状数组为满，扫到某个新纵坐标把一条直线上所有糖果从树状数组中删掉。对于每个扫描到的糖果，先把它从链表中删掉，考虑这种颜色不选，统计它左边和它右边两个与它颜色相同的糖果之间的糖果数量，更新答案。\n\n跑扫描线之前还要先算出每两个相邻的糖果之间的答案。\n\n题目中允许取上边或下边，只需要将纵坐标取反即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-candy.md","raw":"title: 「省选模拟赛」小奇的糖果 - 扫描线 + 链表\ncategories: OI\ntags: \n  - 安徽集训\n  - 扫描线\n  - 链表\n  - 树状数组\n  - 离散化\npermalink: 20160319-candy\ndate: 2016-03-20 22:58:12\n---\n\n有 $ N $ 个彩色糖果在平面上。小奇想在平面上取一条水平的线段，并拾起它上方或下方的所有糖果。求出最多能够拾起多少糖果，使得获得的糖果并不包含所有的颜色。\n\n<!-- more -->\n\n### 题解\n对纵坐标离散化。\n\n用树状数组维护「当前」横坐标在某个区间内的糖果数量。\n\n用链表维护「当前」某个糖果左边右边与它横坐标最近的两个糖果。\n\n扫描线从上往下扫，初始时树状数组为满，扫到某个新纵坐标把一条直线上所有糖果从树状数组中删掉。对于每个扫描到的糖果，先把它从链表中删掉，考虑这种颜色不选，统计它左边和它右边两个与它颜色相同的糖果之间的糖果数量，更新答案。\n\n跑扫描线之前还要先算出每两个相邻的糖果之间的答案。\n\n题目中允许取上边或下边，只需要将纵坐标取反即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-candy","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9spg01pnooxlq77ex1mq"}],"PostAsset":[{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"hotkey.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/network.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"network.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/port.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"port.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"screenfetch.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/share.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"share.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"terminal.png","modified":1},{"_id":"source/_posts/uva-11538/cells.png","post":"cixlg9rac0041ooxl472q7ojl","slug":"cells.png","modified":1},{"_id":"source/_posts/tree-chain-split-notes/1.svg","post":"cixlg9rbn0060ooxlf67buek0","slug":"1.svg","modified":1},{"_id":"source/_posts/splay-notes-1/splay.png","post":"cixlg9rds0094ooxlo8t6v8ua","slug":"splay.png","modified":1},{"_id":"source/_posts/sdoi2016-game/line.png","post":"cixlg9rf800c7ooxlwt64odd7","slug":"line.png","modified":1},{"_id":"source/_posts/sdoi2016-game/tree.png","post":"cixlg9rf800c7ooxlwt64odd7","slug":"tree.png","modified":1},{"_id":"source/_posts/noip2016-running/linear-backward1.svg","post":"cixlg9rkc00l0ooxl3gg8o7tc","slug":"linear-backward1.svg","modified":1},{"_id":"source/_posts/noip2016-running/linear-forward1.svg","post":"cixlg9rkc00l0ooxl3gg8o7tc","slug":"linear-forward1.svg","modified":1},{"_id":"source/_posts/noip2016-running/linear-forward2.svg","post":"cixlg9rkc00l0ooxl3gg8o7tc","slug":"linear-forward2.svg","modified":1},{"_id":"source/_posts/noi2008-candy/1.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"1.svg","modified":1},{"_id":"source/_posts/noi2008-candy/2.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"2.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/2.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"2.svg","modified":1},{"_id":"source/_posts/noi2008-candy/3.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"3.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/3.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"3.svg","modified":1},{"_id":"source/_posts/noi2008-candy/4.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"4.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/4.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"4.svg","modified":1},{"_id":"source/_posts/noi2008-candy/5.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"5.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/5.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"5.svg","modified":1},{"_id":"source/_posts/noi2008-candy/6.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"6.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/6.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"6.svg","modified":1},{"_id":"source/_posts/noi2008-candy/7.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"7.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/7.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"7.svg","modified":1},{"_id":"source/_posts/node-devide-notes/tree1.svg","post":"cixlg9rrt00tjooxl26si2srg","slug":"tree1.svg","modified":1},{"_id":"source/_posts/node-devide-notes/tree2.svg","post":"cixlg9rrt00tjooxl26si2srg","slug":"tree2.svg","modified":1},{"_id":"source/_posts/manacher-notes/1.svg","post":"cixlg9rso00unooxlniigyuwv","slug":"1.svg","modified":1},{"_id":"source/_posts/manacher-notes/2.svg","post":"cixlg9rso00unooxlniigyuwv","slug":"2.svg","modified":1},{"_id":"source/_posts/manacher-notes/3.svg","post":"cixlg9rso00unooxlniigyuwv","slug":"3.svg","modified":1},{"_id":"source/_posts/here-the-best-sight/1.jpg","post":"cixlg9rxo010xooxlim11g2sa","slug":"1.jpg","modified":1},{"_id":"source/_posts/here-the-best-sight/2.jpg","post":"cixlg9rxo010xooxlim11g2sa","slug":"2.jpg","modified":1},{"_id":"source/_posts/here-the-best-sight/3.jpg","post":"cixlg9rxo010xooxlim11g2sa","slug":"3.jpg","modified":1},{"_id":"source/_posts/haoi2006-sequence/1.svg","post":"cixlg9s11014oooxlk15ca9gr","slug":"1.svg","modified":1},{"_id":"source/_posts/haoi2006-sequence/2.svg","post":"cixlg9s11014oooxlk15ca9gr","slug":"2.svg","modified":1},{"_id":"source/_posts/geometry-notes/1.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"1.ggb","modified":1},{"_id":"source/_posts/geometry-notes/1.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"1.svg","modified":1},{"_id":"source/_posts/geometry-notes/2.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"2.ggb","modified":1},{"_id":"source/_posts/geometry-notes/2.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"2.svg","modified":1},{"_id":"source/_posts/geometry-notes/3.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"3.ggb","modified":1},{"_id":"source/_posts/geometry-notes/3.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"3.svg","modified":1},{"_id":"source/_posts/geometry-notes/4.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"4.ggb","modified":1},{"_id":"source/_posts/geometry-notes/4.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"4.svg","modified":1},{"_id":"source/_posts/geometry-notes/5.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"5.ggb","modified":1},{"_id":"source/_posts/geometry-notes/5.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"5.svg","modified":1},{"_id":"source/_posts/geometry-notes/6.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"6.ggb","modified":1},{"_id":"source/_posts/geometry-notes/6.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"6.svg","modified":1},{"_id":"source/_posts/docker-sandbox-judger/image.svg","post":"cixlg9s3i016mooxlfujpjwv5","slug":"image.svg","modified":1},{"_id":"source/_posts/cf-716e/example.svg","post":"cixlg9sa801d6ooxltw9m0m0q","slug":"example.svg","modified":1},{"_id":"source/_posts/bzoj-3196/lemon.png","post":"cixlg9seb01h1ooxlnh5z10y5","slug":"lemon.png","modified":1},{"_id":"source/_posts/bzoj-2683/cdq.png","post":"cixlg9sf701htooxlxaoc9nf8","slug":"cdq.png","modified":1},{"_id":"source/_posts/at-the-cross-of-time/mzr.lrc","post":"cixlg9slv01n0ooxlauq8af31","slug":"mzr.lrc","modified":1},{"_id":"source/_posts/acam-notes/acam.svg","post":"cixlg9so601ooooxluh670jtd","slug":"acam.svg","modified":1},{"_id":"source/_posts/acam-notes/acam2.svg","post":"cixlg9so601ooooxluh670jtd","slug":"acam2.svg","modified":1},{"_id":"source/_posts/geometry-notes/7.ggb","slug":"7.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","modified":1},{"_id":"source/_posts/geometry-notes/7.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"7.svg","modified":1}],"PostCategory":[{"post_id":"cixlg9r760000ooxlll2vxp8k","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r7h0007ooxlh0ippyz3"},{"post_id":"cixlg9r7v000gooxlu86flrpb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r7w000hooxlxqgbme59"},{"post_id":"cixlg9r80000qooxls99odt0h","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r81000rooxl2wf5fw80"},{"post_id":"cixlg9r880012ooxly9xlvj0j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r890013ooxlp6ujfri2"},{"post_id":"cixlg9r8b001aooxlsxcj7zkb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8d001booxl75wyt7hl"},{"post_id":"cixlg9r8j001gooxl5xhuodpp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8l001hooxlep3n3d6h"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8q001nooxl773gq2bw"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8u001yooxluc8ow30n"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8z0028ooxl6b1jl5jp"},{"post_id":"cixlg9r92002iooxlczrdlyzt","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r93002jooxlrgb41mo8"},{"post_id":"cixlg9r95002oooxls8l15ust","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r96002pooxlone2270z"},{"post_id":"cixlg9r99002wooxlw9wlizgc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r9e002xooxlmoycnemw"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","category_id":"cixlg9r9h0035ooxlomt7421m","_id":"cixlg9r9j003cooxl5vely9y6"},{"post_id":"cixlg9ra4003jooxlk639w24c","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ra5003kooxlsbuhkspi"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9raa003uooxlnokbieza"},{"post_id":"cixlg9rac0041ooxl472q7ojl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rae0042ooxliq8nmfx3"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rao0048ooxlhqxol1xa"},{"post_id":"cixlg9raq004fooxlyk872vzc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rar004gooxlp7ybxms7"},{"post_id":"cixlg9rat004nooxl0udxuz2r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rau004oooxljweexac3"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ray0050ooxlhav9xg7y"},{"post_id":"cixlg9rb10057ooxl45cl24ny","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rb30058ooxla5ymmk3d"},{"post_id":"cixlg9rb5005fooxl4xju7de7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rb7005gooxlk10duyg9"},{"post_id":"cixlg9rbg005rooxlwmmodxef","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rbi005sooxlz3qvzh7a"},{"post_id":"cixlg9rbn0060ooxlf67buek0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rbp0061ooxlcwwiaqrz"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rbz006aooxlqx8ms5oe"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rc3006iooxlrg219bkj"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rc7006qooxlpubrcom4"},{"post_id":"cixlg9rcc006zooxl7j0zh7n1","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9rcf0071ooxlcwnj9fpj"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rcl0073ooxlyv6av57i"},{"post_id":"cixlg9rcq007cooxll7931685","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rcs007dooxlipr9egv0"},{"post_id":"cixlg9rcu007kooxl669tzoxp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rcv007looxliu2vnp0h"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rcy007tooxl9h8a27as"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rd40081ooxlwfhjqwty"},{"post_id":"cixlg9rd70089ooxleh439i2r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rd9008aooxldtcgdg52"},{"post_id":"cixlg9rdb008fooxlmuqr73ki","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdh008gooxlnjtah2mr"},{"post_id":"cixlg9rdj008looxlpanbg3cl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdl008mooxlgg4hh4sh"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdo008sooxl7ty9optf"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdr008yooxl1a8ypolq"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdu0095ooxllz9r1htn"},{"post_id":"cixlg9rdx009booxlch8h998g","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdy009cooxlm55jye3f"},{"post_id":"cixlg9re0009hooxl4o7msif9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9re1009iooxlln3w83o7"},{"post_id":"cixlg9re3009oooxl9oqc1j4j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9re4009pooxlzuqq35kg"},{"post_id":"cixlg9re6009tooxlxwkgks62","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9re8009uooxlnv5bsiwz"},{"post_id":"cixlg9re9009yooxl765qsyac","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9reb009zooxlz75znryj"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ref00a7ooxljq82dmof"},{"post_id":"cixlg9reh00adooxl81or26s2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rei00aeooxlx9cmct7d"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ren00aoooxljtf1w8l6"},{"post_id":"cixlg9req00azooxln3o0605f","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9rer00b0ooxl1wx594pf"},{"post_id":"cixlg9res00b1ooxl1tynortw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ret00b2ooxlycbufpa4"},{"post_id":"cixlg9rev00bbooxlauiqllaa","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rew00bcooxlb5z4supy"},{"post_id":"cixlg9rf000bqooxlxoy869wq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rf100brooxlwsfto2ot"},{"post_id":"cixlg9rf400byooxl5qvktlmq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rf600bzooxl2fml66ay"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rf900c8ooxliyl6ua7f"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rfk00cjooxlvkh0r1g4"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rfp00ctooxlssyrsxq3"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rfu00d7ooxll0h67hz4"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rfx00ddooxlb7b3mq78"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rg200doooxlvpwqmnlk"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rg600dyooxlt73oh5cb"},{"post_id":"cixlg9rg800e5ooxlwalebfg2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rga00e6ooxlo8z4ktfi"},{"post_id":"cixlg9rgb00eaooxla477j5s2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgc00ebooxlolhlk4y2"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgg00eiooxl5v4hqtgz"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgj00eoooxlhv8g5y4v"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgp00ezooxlwylhcfiw"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgv00f9ooxlyobgj5ex"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgz00fiooxlqsgrhnlt"},{"post_id":"cixlg9rh300frooxlgpbhevex","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rh500fsooxlsfxjdjb4"},{"post_id":"cixlg9rh800fzooxlezmphpdp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rh900g0ooxlj5o08pd9"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rhc00g8ooxllazgl2ap"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rhg00geooxlemilw23b"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rho00goooxlatr0rx2x"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rhu00gyooxl5s82knew"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rhx00h4ooxlz8p8c2j3"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ri100haooxltvxzlmdh"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ri500hjooxl2f6g1tou"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ria00hrooxl6z5bgmat"},{"post_id":"cixlg9ric00hzooxlglirxi4t","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rid00i0ooxldjp5mnne"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rih00i6ooxlj0z2sebi"},{"post_id":"cixlg9rik00ieooxlposk45jc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rim00ifooxl50z4t33u"},{"post_id":"cixlg9rio00ikooxllp2j80bd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rip00ilooxlnfiumjbc"},{"post_id":"cixlg9rir00ipooxlk35f67ay","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rit00iqooxleos1kun3"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rix00ixooxl4upuv7xu"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rj200j4ooxlrcwt3kbe"},{"post_id":"cixlg9rj600jeooxll009vlfm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rj700jfooxlm00baiev"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rjb00jnooxlt528jqor"},{"post_id":"cixlg9rjd00juooxlptjla394","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rjf00jvooxlyjn98az4"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rji00k2ooxlb3bfi5zu"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rjm00k9ooxl7n703z40"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rjq00kgooxl8s0qqwnc"},{"post_id":"cixlg9rk300klooxl9kn22g9j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rk400kmooxlsny9m3r8"},{"post_id":"cixlg9rk700ktooxl6g2yf5hl","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9rk800kuooxloryhs3k4"},{"post_id":"cixlg9rk900kvooxl5hjzokqa","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rka00kwooxlfkt6dwth"},{"post_id":"cixlg9rkc00l0ooxl3gg8o7tc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rke00l1ooxl9rc8iq5z"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rkt00l7ooxlttpl2m69"},{"post_id":"cixlg9rkv00lcooxls72wclbx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rkx00ldooxlk815vkzv"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rl100liooxl7mwvmvcp"},{"post_id":"cixlg9rl400loooxl33swj2te","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rl500lpooxl2in96041"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlf00lxooxlybrbueyt"},{"post_id":"cixlg9rlj00m2ooxlr531mhw2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlk00m3ooxlexofujop"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rln00m8ooxlwmogi13f"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlq00meooxlhlcktyfj"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlv00mmooxle9prkfvr"},{"post_id":"cixlg9rly00msooxlf3pyicvr","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlz00mtooxl8kgvisqm"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rm600n2ooxlvqxuxy8f"},{"post_id":"cixlg9rm900n8ooxltf4y1ddn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rma00n9ooxlz5fovyni"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmd00neooxl6k5thk6x"},{"post_id":"cixlg9rmh00nlooxl1idgmfrv","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmj00nmooxlv7n7hbu5"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmn00nrooxl37gkffcw"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmu00o1ooxl6nhvewnc"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmz00o8ooxly6b3qpf8"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rn800okooxlhakqehll"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rnd00osooxlj8rqy4ij"},{"post_id":"cixlg9rng00oyooxl1q61w30r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rni00ozooxlvp7f5jb8"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rnn00p8ooxlp7xoqm0m"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rns00pgooxljy1fem59"},{"post_id":"cixlg9rnu00plooxlun40oh7g","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rnw00pmooxlgxcofur3"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ro000psooxlwjlqd5ek"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ro400pzooxl3wz1kuux"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ro800q5ooxlqhddu9qt"},{"post_id":"cixlg9rob00qbooxle38fb1mx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rod00qcooxlm5mwo808"},{"post_id":"cixlg9roi00qnooxl0d6iws72","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9roj00qoooxlc69hoopx"},{"post_id":"cixlg9ron00qvooxltvmba5m0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9roo00qwooxld9w9quht"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9row00r5ooxlnq7wex4f"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rp500reooxl0zkmzbjy"},{"post_id":"cixlg9rp900rkooxl4329aiu2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpb00rlooxl92kjkcez"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpf00rrooxlg9mgd3d1"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpk00rxooxlsly8exjg"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpp00s4ooxlkblvkmej"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpv00saooxlhm5a4gvz"},{"post_id":"cixlg9rq200sfooxly4o781l4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rq500sgooxlw0h5tf61"},{"post_id":"cixlg9rqx00soooxllb590yw9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rqy00spooxlnyzoxvjg"},{"post_id":"cixlg9rr500szooxl5spvxvdd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rrd00t0ooxlvfw4wz7f"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rrm00t8ooxleuasqdna"},{"post_id":"cixlg9rrp00teooxlvdm3u5f0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rrr00tfooxley7agmpc"},{"post_id":"cixlg9rrt00tjooxl26si2srg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rrv00tkooxlstfurpt9"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rs300trooxl0smwla3g"},{"post_id":"cixlg9rs700txooxlxitu2z26","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rs900tyooxlgy61sek0"},{"post_id":"cixlg9rsc00u4ooxlj8ab512z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rse00u5ooxl7nocpsek"},{"post_id":"cixlg9rsg00uaooxljndn1qui","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rsi00ubooxlncr7lejy"},{"post_id":"cixlg9rso00unooxlniigyuwv","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rsq00uoooxlh3y0ppnd"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rsz00uvooxl5zv2y032"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rt700v3ooxljb6ctsne"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rtb00vaooxl46ee6chn"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rth00vhooxl1jwdsybd"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rtl00voooxlpjsnzwnn"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rts00vyooxlru30dj08"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rty00w7ooxl3dihh8gs"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ru400wdooxl7w4cacdm"},{"post_id":"cixlg9ru700wjooxldpiytopo","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ru900wkooxl06x112wo"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rue00wrooxl5snl7i7i"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ruj00wxooxlqietpgzs"},{"post_id":"cixlg9rum00x2ooxlk70b6ezl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ruo00x3ooxlr7tdneyi"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rus00x8ooxlnwdbcn7h"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ruy00xfooxlk7nq25in"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rv400xmooxl35x0cex8"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rv900xsooxl3dqgusbl"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rve00xzooxlrczp9w9v"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rvk00y7ooxlesp2yuzd"},{"post_id":"cixlg9rvp00yfooxldumqyx55","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rvq00ygooxltxcng8vr"},{"post_id":"cixlg9rvt00ylooxlsots6p61","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rvv00ymooxlc72xxdqd"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rw100yuooxlgdkkbze2"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rw700z2ooxl2oxjfva6"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rwe00z9ooxlhzhses12"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rwj00zfooxlenvjtcw6"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rwp00znooxl0smw211a"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rww00zwooxl6myhc3vp"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rx20104ooxlq6ozcl45"},{"post_id":"cixlg9rx6010cooxlj2093ofg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rx8010dooxlvu4w99l8"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rxf010looxlpugqt1dv"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rxl010sooxl0yl159jx"},{"post_id":"cixlg9rxo010xooxlim11g2sa","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9rxq010yooxli6mkc7ck"},{"post_id":"cixlg9rxv010zooxl992znn8t","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rxw0110ooxlztoeobjy"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ry20117ooxlhprc3rgz"},{"post_id":"cixlg9ry8011hooxlyt6940cs","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rya011iooxlm4dtupuk"},{"post_id":"cixlg9rye011oooxljwdrbzgj","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ryg011pooxljgduwv3w"},{"post_id":"cixlg9ryj011tooxlqxng4x0m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ryl011uooxl9egdxcc3"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ryp011zooxlyj1yckhn"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ryv0127ooxlqlhap5xk"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rz1012eooxlgd5w2zgu"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rz9012oooxl575tvbix"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rze012uooxld1rgz3vk"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rzm0131ooxlei4dst3d"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rzr0137ooxlopwdsopf"},{"post_id":"cixlg9rzu013cooxlvok6je2x","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rzw013dooxlgf6zdmft"},{"post_id":"cixlg9s01013kooxlpt7nhhab","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s03013looxlxz10vjnp"},{"post_id":"cixlg9s06013pooxll1sqek1m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s08013qooxl9cujxdsb"},{"post_id":"cixlg9s0a013uooxlg37nsti1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0c013vooxlril84ij8"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0h0140ooxl7spa2wa2"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0n0147ooxl54v4xl0r"},{"post_id":"cixlg9s0q014cooxluoph4st4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0s014dooxliv4ixu0p"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0x014jooxltq0zp9qz"},{"post_id":"cixlg9s11014oooxlk15ca9gr","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s13014pooxl58tmz2hs"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s1c014uooxl5y0uj3rm"},{"post_id":"cixlg9s1g0150ooxltpgq3ka0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s1i0151ooxlj5oq4fzd"},{"post_id":"cixlg9s2d015eooxloob8hphs","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s2g015fooxl8ckj1wtw"},{"post_id":"cixlg9s2j015kooxlno9phes2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s2l015looxlr3ifmfyu"},{"post_id":"cixlg9s2r015tooxlois4c85n","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s2t015uooxl5qphqhk0"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s310161ooxl8jh7va9y"},{"post_id":"cixlg9s360167ooxl1fok2ucx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s380168ooxlu17rm5qz"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s3e016fooxlmcrk3cns"},{"post_id":"cixlg9s3i016mooxlfujpjwv5","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s3l016nooxlaeca22bu"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s3s016tooxlixkh67lj"},{"post_id":"cixlg9s3w016zooxl934kfe33","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s3y0170ooxlriersdqg"},{"post_id":"cixlg9s410174ooxl2pkymw5v","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s440175ooxl4haj6l37"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s4d017gooxlnhst5dt5"},{"post_id":"cixlg9s4g017looxld0m4k1w0","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9s4j017mooxlc05d6byg"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s4m017oooxl1anjml1p"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s4s017vooxl0bwu5mb6"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s4z0182ooxl0luhu5nr"},{"post_id":"cixlg9s560189ooxl8r20eqsp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s59018aooxlbb2kjls2"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s5f018gooxlsh5bjewb"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s5t018pooxlg5zq9xzj"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s60018xooxlykam5ody"},{"post_id":"cixlg9s640194ooxl2r9h3e11","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s670195ooxlx6vuhtio"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s6f019eooxlfy0rumiw"},{"post_id":"cixlg9s6n019looxlzh13wmyd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s6s019mooxl6pxfuusd"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s6z019uooxloqn0s5l7"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s7801a2ooxllakxbmyu"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s7e01a9ooxlighc88nf"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s7l01agooxlfmw9yymq"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s7t01aoooxl7d9y20mg"},{"post_id":"cixlg9s7y01avooxl5ku8le04","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8001awooxla4v7f9yq"},{"post_id":"cixlg9s8601b4ooxl9xtoeca1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8801b5ooxlb7notgvg"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8e01baooxlq9qsc49o"},{"post_id":"cixlg9s8j01bhooxlw1ixjot5","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8l01biooxl6isz8y2r"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8q01bnooxlvruqktr1"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8w01btooxlxrj30919"},{"post_id":"cixlg9s9001bzooxlvzne69or","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9201c0ooxlzts0x5da"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9901c7ooxlcqyoqiep"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9f01cdooxlcn7q96hm"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9n01clooxl0ejqg3yq"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9v01crooxl6ubkgimz"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sa401d1ooxl1rhog74z"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sab01d7ooxln5tgqcfg"},{"post_id":"cixlg9saj01dfooxlkcflucvz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sal01dgooxlfjoxggkc"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sar01dlooxlwsxl8l37"},{"post_id":"cixlg9sau01dqooxlnxqow11w","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9saw01drooxlqf52sygt"},{"post_id":"cixlg9sb201dyooxl6v5leuke","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sb401dzooxl0b50dfl1"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sbd01e9ooxlhgragry2"},{"post_id":"cixlg9sbh01eeooxla294l35s","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sbk01efooxl0t2u67yj"},{"post_id":"cixlg9sbn01ejooxlsdjn57bi","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sbp01ekooxlm8j8garv"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sbv01epooxlhpj5tinw"},{"post_id":"cixlg9sc201eyooxlr7xobk40","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sc401ezooxloh80yig0"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9scb01f6ooxlpk6zsu8d"},{"post_id":"cixlg9scf01fbooxllohwmidy","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sch01fcooxlfut9v91v"},{"post_id":"cixlg9scl01fgooxltchcuriw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sco01fhooxle7zdzi5e"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9scv01foooxlu5zumzgx"},{"post_id":"cixlg9sd001fuooxld0xz6w8z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sd401fvooxlvwnb3cxg"},{"post_id":"cixlg9sd701fzooxlgv99imzv","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sd901g0ooxl4o6mm73c"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sdf01g5ooxlt3imji8f"},{"post_id":"cixlg9sdj01gaooxlldwx269a","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sdl01gbooxlba4gz2xi"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sdt01gjooxlobxi2v6q"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9se001gqooxl3at70pxp"},{"post_id":"cixlg9se501gwooxl4he1heaz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9se801gxooxlcncucsn7"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sed01h2ooxlrev3u5io"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9seo01haooxlw4f5tcc9"},{"post_id":"cixlg9ses01hfooxlfbrle23q","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sev01hgooxlj53v8d4c"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sf201hnooxl5iwhwqqn"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sf901huooxlygt24vtj"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sfj01i1ooxlk3o1qhpt"},{"post_id":"cixlg9sfo01i7ooxlz6m9wk11","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sfr01i8ooxlto2akck4"},{"post_id":"cixlg9sfu01icooxl6b4q2hml","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sfy01idooxlbp3lf23s"},{"post_id":"cixlg9sg201ihooxlf6fgnhkg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sg501iiooxljw36679p"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sga01imooxll3j1p9zo"},{"post_id":"cixlg9sgh01itooxl4uq404pe","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sgk01iuooxljmedct1a"},{"post_id":"cixlg9sgo01izooxlvy5gpnck","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sgr01j0ooxln4ida5xv"},{"post_id":"cixlg9sgu01j4ooxlhpdlz7gb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sgw01j5ooxl4pk7b5wl"},{"post_id":"cixlg9sh001j9ooxlbo7maly2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sh201jaooxlr6robvzo"},{"post_id":"cixlg9sh601jeooxl6gdfag18","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sh801jfooxls69n6g7n"},{"post_id":"cixlg9she01jlooxl1qtik5ks","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9shg01jmooxlne6bo2x4"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9shn01jsooxl7dgj2mfn"},{"post_id":"cixlg9shs01jyooxle7mhon4u","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9shv01jzooxl12fm9lcb"},{"post_id":"cixlg9shy01k3ooxld3fb801r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9si101k4ooxlfydhrqbz"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9si801kaooxlhpaqk3tq"},{"post_id":"cixlg9sic01kgooxlh6482eho","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sif01khooxl64uou7fg"},{"post_id":"cixlg9sil01knooxlo1st7o09","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sio01koooxlq5lj97o8"},{"post_id":"cixlg9sit01ktooxl5amhekiy","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9siw01kuooxll14xchm9"},{"post_id":"cixlg9sj301kzooxlp726ykia","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sj701l0ooxlsot184ud"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sji01l7ooxlm2klshhk"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sjr01ldooxls5yaf96r"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sk001lkooxl1e34yh3t"},{"post_id":"cixlg9sk501lpooxllld15m00","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sk701lqooxlxtxrlef1"},{"post_id":"cixlg9skb01luooxlybp32p0j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ski01lvooxlirpy0e1y"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9skq01m0ooxl9pi0w7tc"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9skx01m6ooxlzkdl0xkt"},{"post_id":"cixlg9sl201mcooxlv07ksmff","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sl501mdooxlcdcv3p18"},{"post_id":"cixlg9sl901miooxljfxbb22y","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9slc01mjooxl6xojdmge"},{"post_id":"cixlg9slg01moooxltxsdu2p9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9slj01mpooxl5h3d9k3c"},{"post_id":"cixlg9slq01mwooxlefrrc6zm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9slt01mxooxl0twqanpa"},{"post_id":"cixlg9slv01n0ooxlauq8af31","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9slz01n1ooxls1v6m9r8"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sm701n3ooxls1ha6gfs"},{"post_id":"cixlg9smd01naooxliy5evulj","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9smg01nbooxlyayy0a60"},{"post_id":"cixlg9smm01nhooxlgmz9268i","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9smo01niooxl4whx8pr2"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sn301nvooxlal7g56zk"},{"post_id":"cixlg9snb01o3ooxl45snx359","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sni01o4ooxlmx999dkh"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9snr01oaooxlleqpsx6b"},{"post_id":"cixlg9sny01ohooxlry34pi7o","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9so101oiooxlckgsc0r9"},{"post_id":"cixlg9so601ooooxluh670jtd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9so901opooxlvdghxwsc"},{"post_id":"cixlg9soh01ouooxl31ydifdg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sok01ovooxlq4az7hoi"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sou01p3ooxlr0c5jju8"},{"post_id":"cixlg9sp101pbooxlgpu4kmkq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sp401pcooxlzfr9im69"},{"post_id":"cixlg9sp901phooxlc2uv4z47","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9spc01piooxl0xw4eps8"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9spj01poooxl408h1qae"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlk169l0000s5xl3ho7q84r"}],"PostTag":[{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9r7i0008ooxl9h0i8hwn"},{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9r7i0009ooxlscg67id6"},{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9r7i000aooxlzdfa29uw"},{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9r7i000booxlsxzxjhtm"},{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9r7j000cooxlniknq3qn"},{"post_id":"cixlg9r7v000gooxlu86flrpb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r7x000mooxlmaz5n4v8"},{"post_id":"cixlg9r7v000gooxlu86flrpb","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r7y000nooxlimgegxap"},{"post_id":"cixlg9r7v000gooxlu86flrpb","tag_id":"cixlg9r7x000kooxl1wzq6q2w","_id":"cixlg9r7y000oooxlkcq57g0q"},{"post_id":"cixlg9r7v000gooxlu86flrpb","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9r7y000pooxl5b7i36x3"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r84000wooxlkwuaxbxr"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r84000xooxl2emj08ap"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9r84000yooxlexqz3mrt"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9r85000zooxlrw311gx2"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9r850010ooxld72xou99"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9r850011ooxl88revdus"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r890015ooxlwxhwbbgs"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8a0016ooxlog9p7l3b"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9r8a0017ooxl6ux6v3vp"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9r8a0018ooxlrqopps5z"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9r8a0019ooxlrmz9ebkn"},{"post_id":"cixlg9r8b001aooxlsxcj7zkb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r8e001dooxlcy1oxzz0"},{"post_id":"cixlg9r8b001aooxlsxcj7zkb","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8e001eooxl9h2jlifn"},{"post_id":"cixlg9r8b001aooxlsxcj7zkb","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r8f001fooxldtxlvusb"},{"post_id":"cixlg9r8j001gooxl5xhuodpp","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r8m001jooxl5ccqc6rx"},{"post_id":"cixlg9r8j001gooxl5xhuodpp","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8m001kooxlvseow096"},{"post_id":"cixlg9r8j001gooxl5xhuodpp","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9r8n001looxla4ko84yt"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r8s001rooxlnebw1vl9"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9r8s001sooxlv7w4j079"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8s001tooxl4ftoiws7"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r8r001pooxlyc0q1m6c","_id":"cixlg9r8s001uooxldjnndurz"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r8r001qooxlwlkctz05","_id":"cixlg9r8s001vooxlfjhlb163"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9r8s001wooxljk9fjfm7"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r8w0021ooxl11f8f62u"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9r8w0022ooxlexcpm74b"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8w0023ooxlx4w2kluy"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9r8w0024ooxl9ga7u0ju"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9r8w0025ooxlsdei0fd3"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r8w0026ooxl8u8zyot6"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r90002cooxldl8zdnf4"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r90002dooxl152m6596"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r8z0029ooxlyqa6zz0l","_id":"cixlg9r90002eooxllpn06fs3"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9r90002fooxlsdjmj0vs"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9r91002gooxl5o33ap97"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r91002hooxlku857mkl"},{"post_id":"cixlg9r92002iooxlczrdlyzt","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r94002looxlfm5g2u9b"},{"post_id":"cixlg9r92002iooxlczrdlyzt","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r94002mooxlrriclheb"},{"post_id":"cixlg9r92002iooxlczrdlyzt","tag_id":"cixlg9r93002kooxlh54bru8k","_id":"cixlg9r94002nooxlfw3gtgxm"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r96002rooxlc0uvftlj"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9r97002sooxl3b91njdq"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r97002tooxlfhogw1l7"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9r97002uooxllcpm533u"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r97002vooxl3s9i5tgi"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r9f002zooxldtuen99r"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9r9f0030ooxlri8yf6vn"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r9f0031ooxly5e11zuv"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9r9f0032ooxllcmslabm"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r9f0033ooxlzhedb37u"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9h0036ooxlqisj2rda","_id":"cixlg9r9j003dooxlu2nv3j47"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i0037ooxlsbc7nni3","_id":"cixlg9r9j003eooxlrxscntva"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i0038ooxlkm3my37w","_id":"cixlg9r9j003fooxl6z9bcga7"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i0039ooxlvgirf8rg","_id":"cixlg9r9j003gooxlm0wnoh07"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i003aooxlewo42a2j","_id":"cixlg9r9j003hooxlqdfemr0w"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i003booxlqglqwn0h","_id":"cixlg9r9j003iooxl2m55kvaz"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9ra8003oooxlm11sy55y"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9ra8003pooxlz91tamku"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ra9003qooxl2eqkinqi"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9ra9003rooxlvl584u2p"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9ra9003sooxlif0kezda"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rab003xooxlg7y6o5jb"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rab003yooxlsdbkqg4b"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9rab003zooxlf2glsyv7"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","tag_id":"cixlg9rab003wooxl37uc1xiy","_id":"cixlg9rab0040ooxlr528ikv2"},{"post_id":"cixlg9rac0041ooxl472q7ojl","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rae0043ooxl5yqgbyke"},{"post_id":"cixlg9rac0041ooxl472q7ojl","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9raf0044ooxl9zlw3u5g"},{"post_id":"cixlg9rac0041ooxl472q7ojl","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9raf0045ooxluw6iarj1"},{"post_id":"cixlg9rac0041ooxl472q7ojl","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9raf0046ooxl6g4wzhkv"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rap004booxlk5obr9j1"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rap004cooxly2n17rlm"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9rap004dooxlw0wysxt1"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9rap004eooxl6efv4qop"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9ras004iooxl0820wc0k"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9ras004jooxlke15q0v3"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9ras004kooxl0coii2xy"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ras004looxl4c4pi368"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9ras004mooxlkbkr15tu"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rav004sooxl7tr0tz0s"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9raw004tooxlj2j9lawz"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9raw004uooxlfh4bor8j"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9raw004vooxlyqgnkrhd"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9raw004wooxlwkaafzk2"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9raw004xooxloxudlij7"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9rav004rooxl64zczyza","_id":"cixlg9raw004yooxls4vhqmp0"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rb00052ooxlqqqxwe5l"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rb00053ooxlchd1zzlw"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9rb00054ooxl57imefoq"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rb00055ooxlrm9qbq8x"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rb00056ooxlo36ntqf3"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rb4005aooxldve8jtpn"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rb5005booxlfiho5442"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rb5005cooxlvz57a8bi"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rb5005dooxl1nlhy1ln"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9rb30059ooxlcu3albgd","_id":"cixlg9rb5005eooxlp8imxcd3"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rba005kooxldi48hckh"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rba005looxlbc7lz22o"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9rba005mooxlq5vu447c"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9rba005nooxls2nyci8e"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9rba005oooxlc9iyj90t"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9rb8005iooxl4nklbagp","_id":"cixlg9rba005pooxlilm0tt24"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9rb9005jooxljsf2wusx","_id":"cixlg9rba005qooxlueqn8olo"},{"post_id":"cixlg9rbg005rooxlwmmodxef","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rbm005wooxl5n2xe6s3"},{"post_id":"cixlg9rbg005rooxlwmmodxef","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rbm005xooxl5dg7tgnl"},{"post_id":"cixlg9rbg005rooxlwmmodxef","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rbm005yooxllowg9fnb"},{"post_id":"cixlg9rbg005rooxlwmmodxef","tag_id":"cixlg9rbl005vooxl8g5rzkci","_id":"cixlg9rbm005zooxl5n58r33k"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rbq0063ooxlppwaqcny"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rbq0064ooxlh3cn7ld4"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rbq0065ooxlzy277ira"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rbq0066ooxlksi8kz8m"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rbq0067ooxln8hm49q0"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rbq0068ooxlgqqvha5t"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rc0006dooxl8zknacxs"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","tag_id":"cixlg9rbz006booxlc2aoef6x","_id":"cixlg9rc0006eooxltzw6ky7n"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","tag_id":"cixlg9rbz006cooxlo6c2fj1p","_id":"cixlg9rc0006fooxl10n38pz0"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9rc0006gooxl2tt45nxe"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rc5006looxlnlo4fp40"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","tag_id":"cixlg9rbz006booxlc2aoef6x","_id":"cixlg9rc5006mooxl4wa5fti3"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rc5006nooxldqww97o7"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rc5006oooxl0waut8sm"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rc9006uooxlx64swgdf"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9rbz006booxlc2aoef6x","_id":"cixlg9rcb006vooxlj1u883a5"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9rc7006rooxl1vs8rdyg","_id":"cixlg9rcb006wooxlv3llqcfo"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rcb006xooxlx7vp7cha"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9rcb006yooxliizfwgah"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rcn0077ooxlegqd8qyw"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rco0078ooxloisf3gjw"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9rco0079ooxlqm8e44qa"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rco007aooxl4lg7iez0"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rco007booxljacn2e2d"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rct007fooxlhzhr9872"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rct007gooxl0wr4lv1v"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9rcs007eooxljl4cr6fp","_id":"cixlg9rct007hooxl2bc1hm8j"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rct007iooxlra5hyudu"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rct007jooxl3ixnzcjn"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rcv007nooxl0x3z29z4"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rcw007oooxlcufsz2ew"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9rcv007mooxl2rcb6kfa","_id":"cixlg9rcw007pooxlonrh5xfd"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rcw007qooxlou21gs82"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rcw007rooxlelsqe2vb"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rcz007vooxl4f04gjvj"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rcz007wooxlngxa9g72"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9rcy007uooxlgxy1ji5a","_id":"cixlg9rcz007xooxlhkzx4qts"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9rcz007yooxl89c3ueth"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rcz007zooxlwfssqrm2"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rd60084ooxl37r52uqt"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rd60085ooxl0brizigm"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rd60086ooxl7zvksmdy"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rd60087ooxlmzg2vi1b"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rd50083ooxlpmj401g3","_id":"cixlg9rd60088ooxlfe68igbr"},{"post_id":"cixlg9rd70089ooxleh439i2r","tag_id":"cixlg9rd9008booxlvhckog1m","_id":"cixlg9rda008dooxlagddyqtf"},{"post_id":"cixlg9rd70089ooxleh439i2r","tag_id":"cixlg9rd9008cooxlorh78wc9","_id":"cixlg9rda008eooxl23bfekkl"},{"post_id":"cixlg9rdb008fooxlmuqr73ki","tag_id":"cixlg9rdi008hooxly39dpt5q","_id":"cixlg9rdi008iooxlwbrlw2a2"},{"post_id":"cixlg9rdb008fooxlmuqr73ki","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rdj008jooxlh9adjqvg"},{"post_id":"cixlg9rdb008fooxlmuqr73ki","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rdj008kooxlav7fq6vp"},{"post_id":"cixlg9rdj008looxlpanbg3cl","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rdl008nooxlffybi31a"},{"post_id":"cixlg9rdj008looxlpanbg3cl","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rdm008oooxl8fqj7wmp"},{"post_id":"cixlg9rdj008looxlpanbg3cl","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rdm008pooxldbsgd0k1"},{"post_id":"cixlg9rdj008looxlpanbg3cl","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rdm008qooxlwuari606"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rdo008tooxl5e8erkhp"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rdp008uooxl82tvsmsm"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rdp008vooxl147iqfav"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rdp008wooxlokd7ej5v"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rdr008zooxlgqvdp6ij"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rdr0090ooxl8005qk5p"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rdr0091ooxlzin5g4pz"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rdr0092ooxlvvquiskm"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rdr0093ooxloqjlawa1"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rdu0096ooxl5lfi9ao0"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rdu0097ooxls3dcbtun"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rdv0098ooxl8y12rom6"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rdv0099ooxlke4ecdi4"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rdv009aooxlgw4pt27a"},{"post_id":"cixlg9rdx009booxlch8h998g","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rdz009eooxllxdrtng9"},{"post_id":"cixlg9rdx009booxlch8h998g","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9rdz009fooxlyit3cdty"},{"post_id":"cixlg9rdx009booxlch8h998g","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rdz009gooxlxdi9tafl"},{"post_id":"cixlg9re0009hooxl4o7msif9","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9re1009kooxlvse8sjg9"},{"post_id":"cixlg9re0009hooxl4o7msif9","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9re2009looxlc76duuer"},{"post_id":"cixlg9re0009hooxl4o7msif9","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9re2009mooxlw1bxezc9"},{"post_id":"cixlg9re0009hooxl4o7msif9","tag_id":"cixlg9re1009jooxl17lu709s","_id":"cixlg9re2009nooxlx4gli8v0"},{"post_id":"cixlg9re3009oooxl9oqc1j4j","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9re4009qooxlw8y6bit3"},{"post_id":"cixlg9re3009oooxl9oqc1j4j","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9re5009rooxlcgb8ncxd"},{"post_id":"cixlg9re3009oooxl9oqc1j4j","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9re5009sooxl6uaj7f6x"},{"post_id":"cixlg9re6009tooxlxwkgks62","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9re8009vooxli48s6tnc"},{"post_id":"cixlg9re6009tooxlxwkgks62","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9re8009wooxl9nwcn9ez"},{"post_id":"cixlg9re6009tooxlxwkgks62","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9re8009xooxlr1kmo277"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rec00a1ooxlu9pobxj1"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9rec00a2ooxl9dfr8ecj"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rec00a3ooxl4tylkzux"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9reb00a0ooxlhez8iqr8","_id":"cixlg9rec00a4ooxla37tzc9n"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rec00a5ooxl08ft4ega"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ref00a8ooxlz3a59prm"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9reg00a9ooxlns18adfm"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9reg00aaooxlcwv0u3dv"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9reg00abooxlicxfhccl"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9reg00acooxl0jhoauzz"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rek00ahooxlaocqv2b1"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9rel00aiooxlr8mns5la"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rel00ajooxl3yca3vat"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9rel00akooxliw07b2py"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9rel00alooxl5akcep82"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9rel00amooxlea2tw7ai"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9reo00atooxlly69jvxd"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rep00auooxlscektk0p"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rep00avooxlunfnsgk5"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9ren00aqooxlfsj277q8","_id":"cixlg9rep00awooxlu8em6pms"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9reo00arooxleknn6uqx","_id":"cixlg9rep00axooxlxuhxl7ob"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9reo00asooxlwj0nsdlc","_id":"cixlg9rep00ayooxlid0lvh4m"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9reu00b4ooxlcrvptdfv"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rev00b5ooxl6c2aizdx"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rev00b6ooxl9vo0hdtu"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9rev00b7ooxlyp5yffah"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rev00b8ooxlo7pza2pu"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9ret00b3ooxllpne01jw","_id":"cixlg9rev00b9ooxl81i84ncd"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9rev00baooxl8fc217hx"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rey00bgooxlc4twgiqw"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rez00bhooxl8cxugafm"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rez00biooxlxdrxhite"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9rez00bjooxlvjvcs438"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rez00bkooxlc2bb3050"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9rex00bdooxlx8kdkklz","_id":"cixlg9rez00blooxll32t1vk0"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9rex00beooxlwxao8570","_id":"cixlg9rez00bmooxlnovq3peq"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rez00bnooxl4wbkfbsp"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9rez00boooxlaw0u9c2k"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rez00bpooxl1raq0xyb"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rf200bsooxlm9oiuxf7"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rf200btooxlu0smwddb"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rf200buooxljc3ixrer"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rf300bvooxlyl7pnboz"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9rf300bwooxl1z5wszmw"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9rf300bxooxly9wvxemo"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rf700c1ooxlrq5go698"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rf700c2ooxl28vr16zi"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rf700c3ooxlfgpqqtuc"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rf700c4ooxlt0tt397k"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rf700c5ooxlte7pmd7w"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9rf600c0ooxlh79pc7t9","_id":"cixlg9rf700c6ooxlyh80fscx"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rfb00caooxlseqt10mo"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rfd00cbooxlcdgn5yhg"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfd00ccooxl4nyfije6"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rfd00cdooxl9txvguc8"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rfd00ceooxlxo5o41j5"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rfd00cfooxlzwxvx18y"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rfd00cgooxlyi8z2f79"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9rfd00chooxldprc53z8"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfm00clooxl3e3zedh8"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rfn00cmooxlro48mlre"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rfn00cnooxleu9t0wdc"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rfn00coooxlkwvnjvi1"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rfn00cpooxl3322zbxv"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rfn00cqooxlqem2sc4z"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9rfl00ckooxl1t1ryhzn","_id":"cixlg9rfn00crooxlhtdofvx5"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfr00cyooxl72nwscul"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rfs00czooxlfd9mna5p"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9r7x000kooxl1wzq6q2w","_id":"cixlg9rfs00d0ooxl33rhc16p"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9rfp00cuooxlb418ewkl","_id":"cixlg9rft00d1ooxlscu6c7dk"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rft00d2ooxlq3bqnbc7"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9rfq00cvooxlscwpkhkd","_id":"cixlg9rft00d3ooxlifs5lnxr"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9rft00d4ooxlej7xi49a"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9rfr00cxooxldhdyuxmz","_id":"cixlg9rft00d5ooxlnr8mwy6z"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfv00d8ooxl9vta6e86"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rfv00d9ooxl25doryca"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rfv00daooxl5fp9s0ts"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rfv00dbooxllhu8q44m"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfz00dhooxlfu13nv4c"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rg000diooxlyhnsatn3"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rg000djooxlkslrj385"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9rfy00dfooxl3d9e7det","_id":"cixlg9rg000dkooxlgd41grkj"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9rfz00dgooxl7dflz7zw","_id":"cixlg9rg000dlooxl49tb2w20"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9rg000dmooxlfxnvgefv"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rg300drooxlc03acpfi"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rg400dsooxlj1b2ssz9"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rg400dtooxlqr0lvrgf"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9rg200dpooxlpxgfrm7a","_id":"cixlg9rg400duooxl7uoe3usv"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9rg400dvooxlgcxuj5di"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9rg300dqooxljoaconen","_id":"cixlg9rg400dwooxlczfv9vuu"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rg600dzooxllpsabm4e"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rg700e0ooxl8in7sh23"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9rg700e1ooxl7g2vsgiw"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rg700e2ooxl83sfn3vz"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rg700e3ooxlvwrg6l8n"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9rg700e4ooxl0fvez3ge"},{"post_id":"cixlg9rg800e5ooxlwalebfg2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rga00e7ooxllhlzw3ji"},{"post_id":"cixlg9rg800e5ooxlwalebfg2","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rga00e8ooxlf9991wmb"},{"post_id":"cixlg9rg800e5ooxlwalebfg2","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rgb00e9ooxlnphrs10p"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgd00ecooxlv0xyk9cv"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rgd00edooxlzj1tpvem"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rgd00eeooxlcz97uagz"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9rgd00efooxl83tpfuk0"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9rgd00egooxld12lotpp"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgg00ejooxlsvi34zp8"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rgh00ekooxl5d4sg6qw"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rgh00elooxl6ftp5kw3"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rgh00emooxlbosn9yf1"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgl00erooxls2es12iw"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rgm00esooxlthdef1xy"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rgm00etooxl0fxldh0n"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rgm00euooxlcbu3abut"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rgm00evooxlhk55eq5d"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9rgk00epooxlz9d136ps","_id":"cixlg9rgm00ewooxlozkhntvy"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9rgl00eqooxl6rx31ll9","_id":"cixlg9rgm00exooxl0iq11fg1"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgs00f3ooxljktftaph"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rgt00f4ooxlqa3nteq0"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rgt00f5ooxl5edaqomj"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9rgq00f1ooxljoqfe3j6","_id":"cixlg9rgt00f6ooxlsscjrnpx"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9rgr00f2ooxl5h77j5xb","_id":"cixlg9rgt00f7ooxldq0r7qag"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgv00faooxlhbr3g3ug"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rgx00fbooxly8jxwh1n"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rgx00fcooxlg4pabi81"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9rc7006rooxl1vs8rdyg","_id":"cixlg9rgx00fdooxl89yeyqyr"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9rgl00eqooxl6rx31ll9","_id":"cixlg9rgx00feooxl88gnnvbr"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rgx00ffooxl68iaibmg"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rgx00fgooxlh8zxdqw1"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rh100fkooxlkejgrlpj"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rh200flooxl9kba03nu"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rh200fmooxlsygl27yl"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rh200fnooxln24wivwh"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9rh200foooxlr6k2kuvo"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rh200fpooxlv9uneavt"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rh200fqooxlhq74ipvv"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rh600fuooxludo7ey99"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rh700fvooxlf34v5u1x"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rh700fwooxlmkguifu9"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rh700fxooxlkapek3wj"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9rh500ftooxliog0rt8q","_id":"cixlg9rh700fyooxlor4gm0eu"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rha00g2ooxl1f85yc0m"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rha00g3ooxl1vflo205"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rha00g4ooxljqyzcrl3"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9rha00g5ooxla7hqx769"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9rhb00g6ooxlr9yfhwo8"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhd00g9ooxl52wlz7a1"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhe00gaooxlic6vw2in"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rhe00gbooxleracgrjw"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rhe00gcooxlhfi1dky8"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhl00ggooxlb6yuouvr"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhm00ghooxlbwzsngsw"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9rhm00giooxlnph9tdad"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rhm00gjooxl040hxk9h"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9rhm00gkooxlwpz85si2"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9rhg00gfooxl7ajpt78z","_id":"cixlg9rhm00glooxlucbyuq0u"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9rcy007uooxlgxy1ji5a","_id":"cixlg9rhm00gmooxliozrylsi"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhq00grooxlrvie7b8d"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhq00gsooxlstsit1af"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rhr00gtooxlap98lp92"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9rhr00guooxl18xe5fc3"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rho00gpooxldpn403og","_id":"cixlg9rhr00gvooxlzrut2qzw"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rhp00gqooxlwhqlb558","_id":"cixlg9rhr00gwooxltsqlw10m"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhu00gzooxlr3il7zwe"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhv00h0ooxlb3iygvd5"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9rhv00h1ooxlr3c5duhn"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rhv00h2ooxlral1dzbi"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhy00h5ooxl3k1p8klu"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhz00h6ooxl4gi42r58"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rhz00h7ooxlk7t0oq0v"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rhz00h8ooxl7ml1wlru"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ri200hcooxlhz1sg13f"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9ri300hdooxlntw4kcww"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9ri300heooxli38xezwu"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9ri100hbooxlkoeo17fm","_id":"cixlg9ri300hfooxl0o7acv5p"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9ri300hgooxlh6k0pbli"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ri300hhooxl16ye1s0b"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ri700hmooxlq8abu4um"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9ri700hnooxlwsofdke8"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9ri700hoooxl57sll0xw"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","tag_id":"cixlg9ri600hlooxlg6n4blh1","_id":"cixlg9ri700hpooxls56jrppj"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ria00hsooxlka6m9wmj"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rib00htooxlabzfwut2"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9ric00huooxlsx14q2ad"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9ric00hvooxl5tyomopb"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9ric00hwooxlrdbei60f"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9ric00hxooxlh9chyr1c"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9ric00hyooxlqtxekeou"},{"post_id":"cixlg9ric00hzooxlglirxi4t","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rie00i1ooxl7nwynp4d"},{"post_id":"cixlg9ric00hzooxlglirxi4t","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rif00i2ooxl4ahz51p1"},{"post_id":"cixlg9ric00hzooxlglirxi4t","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rif00i3ooxlcoxw5n2c"},{"post_id":"cixlg9ric00hzooxlglirxi4t","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rif00i4ooxlx91sj943"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rii00i9ooxlmalwvj82"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rij00iaooxle7t2jdtq"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9rih00i7ooxl65jx3w5z","_id":"cixlg9rij00ibooxl4u6888is"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9rij00icooxlgg1x68ja"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rij00idooxltd75pzkq"},{"post_id":"cixlg9rik00ieooxlposk45jc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rim00igooxlkm2u1co8"},{"post_id":"cixlg9rik00ieooxlposk45jc","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rin00ihooxlmrw2ruwn"},{"post_id":"cixlg9rik00ieooxlposk45jc","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rin00iiooxlzc4vvozx"},{"post_id":"cixlg9rik00ieooxlposk45jc","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9rin00ijooxlnbbwiqge"},{"post_id":"cixlg9rio00ikooxllp2j80bd","tag_id":"cixlg9rf600c0ooxlh79pc7t9","_id":"cixlg9riq00imooxllodk10tu"},{"post_id":"cixlg9rio00ikooxllp2j80bd","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rir00inooxlu151dxb1"},{"post_id":"cixlg9rio00ikooxllp2j80bd","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rir00ioooxlmp3p13oz"},{"post_id":"cixlg9rir00ipooxlk35f67ay","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9riu00itooxlvd7rlp3a"},{"post_id":"cixlg9rir00ipooxlk35f67ay","tag_id":"cixlg9riu00isooxlcigd4msu","_id":"cixlg9riv00iuooxl3i88oh00"},{"post_id":"cixlg9rir00ipooxlk35f67ay","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9riv00ivooxl0ntwopuv"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9riz00izooxlfldzp9z8"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","tag_id":"cixlg9riy00iyooxlqp6j5wny","_id":"cixlg9rj000j0ooxlp40lihfj"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rj000j1ooxlr1vv7gau"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rj000j2ooxlvim1d9un"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9rj400j8ooxl63g33q0e"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rj200j5ooxl5hfu647a","_id":"cixlg9rj500j9ooxlux7evyl6"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rj300j6ooxlxbxwjitw","_id":"cixlg9rj500jaooxlpqsbsp4j"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rj500jbooxl2q5s9mw9"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rfl00ckooxl1t1ryhzn","_id":"cixlg9rj500jcooxlgmf4caeg"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rj300j7ooxly5xcactb","_id":"cixlg9rj500jdooxlfma2sm72"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9rj800jgooxlan3brwi5"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9rj900jhooxll0rc42d0"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9rj900jiooxlieougfkm"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9rj900jjooxlinuqpm1s"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9rj900jkooxluaurnt86"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rj900jlooxl47m5zzc0"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rjc00jpooxl5dmykwnl"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9rjb00joooxl7dpm24bd","_id":"cixlg9rjd00jqooxla2i860ti"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rjd00jrooxllzkb0rdt"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rjd00jsooxl0r55w0f1"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9rcs007eooxljl4cr6fp","_id":"cixlg9rjd00jtooxlyfhieb8x"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rjf00jwooxlklvl0xfv"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9rjb00joooxl7dpm24bd","_id":"cixlg9rjg00jxooxlxnyljg4t"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rjg00jyooxl7g2w4sv7"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9rjg00jzooxlfugtqkww"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9rjg00k0ooxl8n5lkj3t"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rjj00k3ooxlekc72mzn"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9rjb00joooxl7dpm24bd","_id":"cixlg9rjk00k4ooxliojpvfwc"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rjk00k5ooxlcpjqxpk9"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rjk00k6ooxlobbtch90"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rjk00k7ooxlrczj1b8i"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rjm00kaooxl3b63jer0"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9rjb00joooxl7dpm24bd","_id":"cixlg9rjn00kbooxl6x55c5bo"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rjo00kcooxlq83z9zhm"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rjo00kdooxlcsu4rt61"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9rhg00gfooxl7ajpt78z","_id":"cixlg9rjo00keooxld6aao35q"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rjq00khooxlzzd6ipba"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rjr00kiooxlrjz4c77i"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rjr00kjooxl9mf58h3p"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rjr00kkooxltklb5e4b"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9rd9008cooxlorh78wc9","_id":"cixlg9rk500knooxlwiclfmcy"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9ri600hlooxlg6n4blh1","_id":"cixlg9rk600koooxl15lh4bj7"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rk600kpooxllsix46ed"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rk600kqooxlk0t4ukik"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9rk600krooxlcjlvlfiz"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rk600ksooxlhybanpj9"},{"post_id":"cixlg9rk900kvooxl5hjzokqa","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rkb00kyooxlzkm2qfqe"},{"post_id":"cixlg9rk900kvooxl5hjzokqa","tag_id":"cixlg9r8r001pooxlyc0q1m6c","_id":"cixlg9rkc00kzooxlwkipf9fe"},{"post_id":"cixlg9rkc00l0ooxl3gg8o7tc","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rkf00l3ooxlf7ivgt91"},{"post_id":"cixlg9rkc00l0ooxl3gg8o7tc","tag_id":"cixlg9rke00l2ooxl1uern1gg","_id":"cixlg9rkf00l4ooxl73sy6ync"},{"post_id":"cixlg9rkc00l0ooxl3gg8o7tc","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rkf00l5ooxlueeui6s5"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rku00l8ooxlkcqm7399"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","tag_id":"cixlg9rke00l2ooxl1uern1gg","_id":"cixlg9rkv00l9ooxlpied9tqn"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rkv00laooxlc838o3k0"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9rkv00lbooxl8d9tk18j"},{"post_id":"cixlg9rkv00lcooxls72wclbx","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rky00lfooxl7wzauzb9"},{"post_id":"cixlg9rkv00lcooxls72wclbx","tag_id":"cixlg9rkx00leooxlh03treh7","_id":"cixlg9rky00lgooxl6t8ep8ui"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rl200lkooxlw16vtl2r"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rl300llooxlzvza4bfl"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","tag_id":"cixlg9rl200ljooxlseakivmj","_id":"cixlg9rl300lmooxln9tuezvr"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","tag_id":"cixlg9rb30059ooxlcu3albgd","_id":"cixlg9rl300lnooxlf4mda5k5"},{"post_id":"cixlg9rl400loooxl33swj2te","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rl700lsooxlgc49rl3w"},{"post_id":"cixlg9rl400loooxl33swj2te","tag_id":"cixlg9rl600lqooxly4jhus6y","_id":"cixlg9rlc00ltooxlkvlu40lj"},{"post_id":"cixlg9rl400loooxl33swj2te","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9rlc00luooxlbhpovvzv"},{"post_id":"cixlg9rl400loooxl33swj2te","tag_id":"cixlg9rl600lrooxlwthjx2u0","_id":"cixlg9rlc00lvooxlcbuldfjt"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rlg00lyooxlff5le8p2"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rlh00lzooxlf02si488"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rlh00m0ooxlc27dtzuk"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9rlh00m1ooxl0lof6ylw"},{"post_id":"cixlg9rlj00m2ooxlr531mhw2","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rlk00m4ooxljxt6kg6x"},{"post_id":"cixlg9rlj00m2ooxlr531mhw2","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rll00m5ooxl6etp3c7a"},{"post_id":"cixlg9rlj00m2ooxlr531mhw2","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rll00m6ooxlqwk5av6x"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rln00m9ooxluns5wfc2"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rlo00maooxlkax8im2c"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rlo00mbooxlnbqvdlk5"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9rlo00mcooxlw2kmstul"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rls00mgooxlo5wuf5zy"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rlt00mhooxly7bve2oq"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rlt00miooxlvzm0xst1"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9rlr00mfooxlmgoshp8r","_id":"cixlg9rlt00mjooxl73v5xw9s"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rlt00mkooxl8ezz79au"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rlw00mnooxlj6w2pmvw"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rlx00moooxl837u3vjv"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rlx00mpooxlnl265bwl"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rlx00mqooxlmnx9ysbl"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rlx00mrooxll91o5pc1"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rm200mvooxllao4yx8b"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rm400mwooxl9hvadz3s"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9rm400mxooxlsuz2mqyr"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9rm400myooxlhzhix4ga"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9rm000muooxlvx6kdpsq","_id":"cixlg9rm400mzooxlx4j0dvln"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9rl600lrooxlwthjx2u0","_id":"cixlg9rm400n0ooxl29rg7jny"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rm700n4ooxljn3pykx6"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rm800n5ooxltl3n6926"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","tag_id":"cixlg9rm700n3ooxlba6ej9bv","_id":"cixlg9rm800n6ooxlh98go0oa"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9rm800n7ooxlzatcm2fa"},{"post_id":"cixlg9rm900n8ooxltf4y1ddn","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rmb00naooxl453ur1mo"},{"post_id":"cixlg9rm900n8ooxltf4y1ddn","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rmb00nbooxlve85ttvx"},{"post_id":"cixlg9rm900n8ooxltf4y1ddn","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9rmb00ncooxl618ju7bw"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rme00nfooxlraefbrjw"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rmg00ngooxlyue2bsz8"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rmg00nhooxlrvcg2pk7"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rmg00niooxlb45n8cg4"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rg200dpooxlpxgfrm7a","_id":"cixlg9rmg00njooxl4ukv5cb3"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9rmg00nkooxlf6kqngex"},{"post_id":"cixlg9rmh00nlooxl1idgmfrv","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rmk00nnooxlx4qbue20"},{"post_id":"cixlg9rmh00nlooxl1idgmfrv","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rmk00noooxl09k3wbd0"},{"post_id":"cixlg9rmh00nlooxl1idgmfrv","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9rml00npooxlio3riv1n"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rmr00nuooxlqqcyms1y"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rms00nvooxl5by6mqei"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rms00nwooxl83oqx8ht"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9rmn00nsooxl0pr2me3j","_id":"cixlg9rms00nxooxlgvhc3c89"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rms00nyooxlik5gprlt"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9rmq00ntooxl3yfmg7cc","_id":"cixlg9rms00nzooxl18grhf8v"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rmv00o2ooxltltkanqk"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rmw00o3ooxlr5g0bkf7"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9rmn00nsooxl0pr2me3j","_id":"cixlg9rmx00o4ooxlrzn8tpnv"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9rmx00o5ooxl05hm5pi3"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9rmx00o6ooxlekluefxs"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rn300ocooxlqgadrkyi"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rn500odooxlv4mu3itq"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rmz00o9ooxl61y81v7x","_id":"cixlg9rn500oeooxl9td0n0zk"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rn000oaooxlafm6tkz7","_id":"cixlg9rn500ofooxlojzo4wcw"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rn500ogooxlq49kr8e7"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rn500ohooxlvwxbeisq"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rn200obooxl8e4bkjz3","_id":"cixlg9rn500oiooxlgr4d4cri"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rn900omooxlhz02zm7g"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rnb00onooxlq0uheo9v"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9rl600lrooxlwthjx2u0","_id":"cixlg9rnb00ooooxlsmzveo89"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnb00opooxleezvhnon"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9rn800olooxln9dpmyn1","_id":"cixlg9rnb00oqooxlelunnsp5"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rne00otooxl071vkp0r"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnf00ouooxl92o3rcok"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rnf00ovooxlofa77gt6"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rnf00owooxlogb8mvcu"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9rnf00oxooxlmvloyydf"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rnj00p0ooxl53bxnl02"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnl00p1ooxl8yigjjhk"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rnl00p2ooxlram2b0ou"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rmz00o9ooxl61y81v7x","_id":"cixlg9rnl00p3ooxli4sklm45"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rh500ftooxliog0rt8q","_id":"cixlg9rnl00p4ooxl0o465yzx"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rn000oaooxlafm6tkz7","_id":"cixlg9rnl00p5ooxlk7dmbeqe"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rnl00p6ooxlc24ylnz8"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rno00p9ooxl1pkaz32b"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnp00paooxl8yv2h3tx"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rnp00pbooxlwtoek6lo"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rbl005vooxl8g5rzkci","_id":"cixlg9rnp00pcooxlc99x5j95"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rn000oaooxlafm6tkz7","_id":"cixlg9rnq00pdooxlq4tugqhq"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rnq00peooxln6pkvcb3"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rns00phooxld4g5gwbg"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnu00piooxlq7ew1hbh"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rnu00pjooxlc8clpvk8"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","tag_id":"cixlg9rbl005vooxl8g5rzkci","_id":"cixlg9rnu00pkooxl5295ws5b"},{"post_id":"cixlg9rnu00plooxlun40oh7g","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rnx00poooxlwv0fj47s"},{"post_id":"cixlg9rnu00plooxlun40oh7g","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rny00ppooxlxfcj5k8e"},{"post_id":"cixlg9rnu00plooxlun40oh7g","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rny00pqooxlro5iy9tl"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ro100ptooxl9bp0f99f"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9ro200puooxlpzaxvuai"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9ro200pvooxlyzi3e8wk"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9ro200pwooxl12pgsjyg"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9rcs007eooxljl4cr6fp","_id":"cixlg9ro200pxooxlen2mns99"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9ro500q0ooxlemvfney4"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ro600q1ooxl1wis1vqv"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9ro600q2ooxl141lztgc"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","tag_id":"cixlg9rlr00mfooxlmgoshp8r","_id":"cixlg9ro600q3ooxltnsi2sr5"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9ro900q6ooxlpqbqcu8i"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rob00q7ooxlrmcfyb7x"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rob00q8ooxlrlchidv0"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rob00q9ooxlzdtgf9in"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rob00qaooxl2j838nhd"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rof00qgooxlnvqt3uhm"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9roh00qhooxlms1d9vjg"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9roh00qiooxlbpd9dtby"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rod00qdooxlha53ivln","_id":"cixlg9roh00qjooxl9ki2vbfo"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9roh00qkooxlbnl6rxed"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9roe00qeooxl9sfddbb5","_id":"cixlg9roh00qlooxl2n6hn004"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rof00qfooxlq93jumjl","_id":"cixlg9roh00qmooxljyay57wx"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rok00qpooxl1kg2apvq"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rom00qqooxlref3jnq4"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rom00qrooxluscfelzk"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rom00qsooxlg76smrp1"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rom00qtooxl7rkfc5rq"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rom00quooxl0a3bxo8w"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9roq00qyooxl1mmk6wtu"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ror00qzooxlfdu25lx8"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ror00r0ooxln8te60hw"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rot00r1ooxlzock308z"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9roo00qxooxl28ecubjc","_id":"cixlg9rot00r2ooxlgtr1nfnz"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rot00r3ooxljsmq03p7"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rp100r8ooxlle0p5i0e"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rp200r9ooxlge32ydtz"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9roz00r6ooxlo5iwgtep","_id":"cixlg9rp200raooxl2mmtpdaq"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rp200rbooxlhoyk6nv0"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9rp000r7ooxlymu9fyh8","_id":"cixlg9rp200rcooxljngkala2"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rp600rfooxlnbabk7v8"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rp800rgooxlfkbsp1qp"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rp800rhooxl9y1ws707"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9rbz006cooxlo6c2fj1p","_id":"cixlg9rp800riooxlaexwfkpz"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rp800rjooxlo9f3gh9b"},{"post_id":"cixlg9rp900rkooxl4329aiu2","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpb00rmooxlhaai2tay"},{"post_id":"cixlg9rp900rkooxl4329aiu2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rpc00rnooxlon8kt4rc"},{"post_id":"cixlg9rp900rkooxl4329aiu2","tag_id":"cixlg9riy00iyooxlqp6j5wny","_id":"cixlg9rpc00roooxl18uo4xyc"},{"post_id":"cixlg9rp900rkooxl4329aiu2","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rpc00rpooxlhc6e4xvq"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpg00rsooxlxsfbsecy"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rph00rtooxl5wmlbqve"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","tag_id":"cixlg9reo00asooxlwj0nsdlc","_id":"cixlg9rph00ruooxlnfwlv5ih"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9rph00rvooxl2mjiqsww"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpl00rzooxlyleg3hpl"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rpm00s0ooxl67y7v9ru"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","tag_id":"cixlg9rpk00ryooxl36numal7","_id":"cixlg9rpm00s1ooxl0t1t6d12"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rpm00s2ooxl1bukwuzg"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpq00s5ooxld1cyl5gj"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rpr00s6ooxli3vosvys"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rpr00s7ooxlvw90v5oi"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9rpr00s8ooxl1159z7u5"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpw00sbooxl0vmnu0tl"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rq000scooxlwpzaz95l"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rq000sdooxldihv9x21"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rq000seooxlpthob8pq"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rq800sjooxllt7cj20m"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rqc00skooxlikprojpe"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9rq500shooxlt5reslko","_id":"cixlg9rqc00slooxlppo1wi40"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9rqc00smooxloigup3qb"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9rq700siooxlrvcwf8av","_id":"cixlg9rqc00snooxll4ctuk7q"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rr000srooxl5uranmsr"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rr200ssooxlsmiq0ynd"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rr200stooxllyik02tj"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rr200suooxlivizf98v"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rr200svooxlahylnc21"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9rr200swooxlhdnehvak"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9rr200sxooxlkgo8x2yl"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rr200syooxlr0zhkz0e"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rre00t1ooxlesu7rafp"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rrj00t2ooxlgzg9ebug"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rrj00t3ooxl0vc5lain"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rrj00t4ooxlyvpjv94q"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rrj00t5ooxlr3y0jm9d"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rrj00t6ooxlp6lhutoa"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rrm00t9ooxl072mlk8y"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rro00taooxlbmkd192w"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rro00tbooxlf0clm0vm"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rro00tcooxlwy7xvajb"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rro00tdooxlyiurj24w"},{"post_id":"cixlg9rrp00teooxlvdm3u5f0","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rrr00tgooxl7gkw7z6q"},{"post_id":"cixlg9rrp00teooxlvdm3u5f0","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rrs00thooxlzxq1mfgf"},{"post_id":"cixlg9rrp00teooxlvdm3u5f0","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rrs00tiooxl958c3lzo"},{"post_id":"cixlg9rrt00tjooxl26si2srg","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9rrw00tmooxlqvqya066"},{"post_id":"cixlg9rrt00tjooxl26si2srg","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rrx00tnooxlkib5hq9f"},{"post_id":"cixlg9rrt00tjooxl26si2srg","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rrx00toooxluf7nmioe"},{"post_id":"cixlg9rrt00tjooxl26si2srg","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rrx00tpooxl77t437lo"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rs300tsooxl4h0wl21v"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rs600ttooxlsbhlh3lw"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rs700tuooxlffpptvq3"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rs700tvooxl1jniwdg8"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9rs700twooxlyg7lzdc8"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9rsa00tzooxlz4mhvv9j"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rsb00u0ooxlz43k7i2t"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rsb00u1ooxle0nwomhu"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rsb00u2ooxl5pfk6gvj"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rsb00u3ooxlmk3yfrym"},{"post_id":"cixlg9rsc00u4ooxlj8ab512z","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9rsf00u7ooxlkvytlbej"},{"post_id":"cixlg9rsc00u4ooxlj8ab512z","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rsg00u8ooxlawsk17l5"},{"post_id":"cixlg9rsc00u4ooxlj8ab512z","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rsg00u9ooxlrfyz6w67"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rsi00ucooxlwjr6ng4m","_id":"cixlg9rsk00ueooxlyhh5k19v"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9rsn00ufooxle3xooeo5"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rj200j5ooxl5hfu647a","_id":"cixlg9rsn00ugooxlma0makap"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9rsn00uhooxl1swk0nx0"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rsn00uiooxly0ty0wej"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rsn00ujooxl5hn83h0p"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rsn00ukooxl12i9xa5i"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rsj00udooxl4sgwnk5b","_id":"cixlg9rsn00ulooxl8gejbzua"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rsn00umooxl3iftuxgv"},{"post_id":"cixlg9rso00unooxlniigyuwv","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rsr00uqooxl0ys0ivfk"},{"post_id":"cixlg9rso00unooxlniigyuwv","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rss00urooxl0p0rdiqu"},{"post_id":"cixlg9rso00unooxlniigyuwv","tag_id":"cixlg9rsq00upooxl3x7f7dd6","_id":"cixlg9rss00usooxl57d42bj5"},{"post_id":"cixlg9rso00unooxlniigyuwv","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rss00utooxl3sothraw"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9rgl00eqooxl6rx31ll9","_id":"cixlg9rt000uwooxlk81ydpdh"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9rgk00epooxlz9d136ps","_id":"cixlg9rt400uxooxl2dktmxwr"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rt400uyooxldxe9p28h"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rt400uzooxlzku6rj22"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rt400v0ooxlcn3v6mn7"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rt400v1ooxlgcxe3jnc"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rt700v4ooxl5ehy6vpi"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9riy00iyooxlqp6j5wny","_id":"cixlg9rt900v5ooxl7gfpqpyr"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rt900v6ooxlgoehqr5e"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rt900v7ooxl21c3jx2r"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rt900v8ooxljayqj9e8"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rtd00vcooxluz7459gr"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9rte00vdooxlpekaav81"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","tag_id":"cixlg9rgr00f2ooxl5h77j5xb","_id":"cixlg9rte00veooxl5u7h0pze"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","tag_id":"cixlg9rf600c0ooxlh79pc7t9","_id":"cixlg9rte00vfooxlonf5svgl"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rth00viooxlre14q66t"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rtj00vjooxlbf5wnxhe"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rtj00vkooxl8m1rouua"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9rtj00vlooxl6up4ymde"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9rl200ljooxlseakivmj","_id":"cixlg9rtj00vmooxllpufqczh"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rtn00vqooxl4ti7pl9e"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rtp00vrooxl20zxds8a"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rtp00vsooxlrhw0ppgb"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rtp00vtooxlw9fluv96"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rb30059ooxlcu3albgd","_id":"cixlg9rtq00vuooxlb9pk1jlk"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rtq00vvooxl25hnfizw"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rtm00vpooxl0x4ha848","_id":"cixlg9rtq00vwooxlry5s1p06"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rtt00w0ooxlcdbigclw"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rtv00w1ooxli3by6r0d"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9rts00vzooxl6iva4crz","_id":"cixlg9rtw00w2ooxlqwspo771"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9rtw00w3ooxlcie94t60"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rtw00w4ooxllb4b4ciq"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rtw00w5ooxl8wbl9z6n"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rtz00w8ooxlgeem2nn0"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ru000w9ooxlskzhvlm5"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9ru000waooxlkln1ue02"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","tag_id":"cixlg9rc7006rooxl1vs8rdyg","_id":"cixlg9ru000wbooxlcvn5xmpp"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ru500weooxlkerxwmzo"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ru700wfooxlmmoflcw5"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9ru700wgooxlpgc8ha4w"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9rlr00mfooxlmgoshp8r","_id":"cixlg9ru700whooxlq3sprs6w"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9ru700wiooxlkujl4si9"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rua00wlooxljs3szmij"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ruc00wmooxlh9ljff5j"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9ruc00wnooxllz9crb3j"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9ruc00woooxlbhtufdqh"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9ruc00wpooxll2yxu6es"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ruf00wsooxlxin2kez4"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rug00wtooxlehfox906"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rug00wuooxlwhuam3ty"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rug00wvooxl578bwecl"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ruk00wyooxlfa3bl9m6"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rul00wzooxldf3kwyba"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","tag_id":"cixlg9rsj00udooxl4sgwnk5b","_id":"cixlg9rul00x0ooxlcp67oy5y"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9rul00x1ooxly61vh7ao"},{"post_id":"cixlg9rum00x2ooxlk70b6ezl","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rup00x4ooxl18y5a5wo"},{"post_id":"cixlg9rum00x2ooxlk70b6ezl","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ruq00x5ooxl2wpwejrn"},{"post_id":"cixlg9rum00x2ooxlk70b6ezl","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9ruq00x6ooxlsvf07xqo"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ruu00xaooxltrz8m7e7"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ruv00xbooxlbuq1u9qt"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","tag_id":"cixlg9rut00x9ooxlcdp781e3","_id":"cixlg9ruv00xcooxls9mpg5y2"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9ruv00xdooxl65o5nggj"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ruy00xgooxlcvc16u98"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rv000xhooxlqaj6peh5"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rv000xiooxl3ma5mtah"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rv000xjooxl2t3evd6w"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rv000xkooxlpcg766ks"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rv400xnooxlcedj2idj"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rv600xoooxluyyh7zna"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rv600xpooxlfb0t5abv"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rv600xqooxlcjb8moei"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","tag_id":"cixlg9rv900xtooxla3ya2diu","_id":"cixlg9rvb00xuooxle8diskq0"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvc00xvooxl34vgy1mu"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9rvc00xwooxlmoluc6k5"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rvc00xxooxlnf0rob9r"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvg00y1ooxldpway2at"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9rvi00y2ooxluitqygvg"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rvi00y3ooxl7kur5s6u"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9rvf00y0ooxlaikb14ap","_id":"cixlg9rvi00y4ooxlhupvrjmj"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rvi00y5ooxle1amy8u4"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvm00y9ooxl0q0b5v41"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rvo00yaooxl074ro6sw"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rvo00ybooxlaisdafkt"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rvo00ycooxlmnq158rt"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9rfy00dfooxl3d9e7det","_id":"cixlg9rvo00ydooxl97dyll7i"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9rvo00yeooxl03yqdwsb"},{"post_id":"cixlg9rvp00yfooxldumqyx55","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvr00yhooxllasee5v8"},{"post_id":"cixlg9rvp00yfooxldumqyx55","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rvt00yiooxl8ch3k8sh"},{"post_id":"cixlg9rvp00yfooxldumqyx55","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9rvt00yjooxln7j9l22g"},{"post_id":"cixlg9rvp00yfooxldumqyx55","tag_id":"cixlg9rf600c0ooxlh79pc7t9","_id":"cixlg9rvt00ykooxlydzs3acy"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvx00yoooxl0wke87o7"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rvy00ypooxleaxkfgoz"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rvy00yqooxlnruk842y"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rvz00yrooxllwnmtiwp"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9rvw00ynooxlewljezon","_id":"cixlg9rvz00ysooxle3kgw6fe"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rw200yvooxleqcgmmf9"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rw400ywooxltuz467o7"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rw400yxooxlzl0b4mru"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rw400yyooxlbq0n1xex"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9rw400yzooxlkb1ff4ob"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rw400z0ooxlu34jthee"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rw800z3ooxlpfjg4f2q"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rw900z4ooxlvw40x2bf"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rw900z5ooxlhct4nfym"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rw900z6ooxl6k3mdny1"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9rcs007eooxljl4cr6fp","_id":"cixlg9rw900z7ooxlrozs57cc"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rwf00zaooxlua0el9kd"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rwg00zbooxl7g4uubwd"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rwh00zcooxlagcq3zrh"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9rwh00zdooxl9cnazoxs"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rwl00zhooxlm7ckdzgh"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rwn00ziooxlu61mpj6m"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9rwk00zgooxl7mcitqah","_id":"cixlg9rwn00zjooxl8lzpu11c"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rwn00zkooxlq2pzyht4"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9rwn00zlooxluk18jo67"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rwq00zoooxly661lkyf"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rwt00zpooxlw60apqi4"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rwt00zqooxlkqbq9cp3"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rwt00zrooxln4bb2pte"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9rwt00zsooxlaug9y36y"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9rwt00ztooxljjz0dqrd"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rwt00zuooxl4eci228y"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rwy00zzooxlzg3utqcq"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rwz0100ooxlfo33i109"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","tag_id":"cixlg9rww00zxooxlxr3mjpwx","_id":"cixlg9rwz0101ooxlrwhv33ur"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","tag_id":"cixlg9rwx00zyooxl7u22v0ag","_id":"cixlg9rwz0102ooxlwkj5wj8k"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rx30105ooxle0n7ezd9"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rx60106ooxla1i9ghit"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rx60107ooxlslhcdi26"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9riy00iyooxlqp6j5wny","_id":"cixlg9rx60108ooxl6m3z08ys"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rx60109ooxl5gjhuzu0"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9rx6010aooxl5gne9c5k"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9rx6010booxlsp2s4ywv"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rxb010fooxl0uk3frm2"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rxd010gooxlc7y7n80e"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9rx9010eooxlyuii46yp","_id":"cixlg9rxd010hooxlcs308d33"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9ri100hbooxlkoeo17fm","_id":"cixlg9rxd010iooxlqmbawoxv"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rxd010jooxl78awwc7x"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rxg010mooxlnxttty17"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rxi010nooxlrsfhrg1e"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rxi010oooxlntewb9vy"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9rgq00f1ooxljoqfe3j6","_id":"cixlg9rxi010pooxl24y4xzcv"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9rd9008cooxlorh78wc9","_id":"cixlg9rxi010qooxl73m3olir"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rxm010tooxl2grurj8f"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rxn010uooxlm0ju7v6c"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rxn010vooxlk2yv4ng5"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","tag_id":"cixlg9riu00isooxlcigd4msu","_id":"cixlg9rxn010wooxlf0q318hi"},{"post_id":"cixlg9rxv010zooxl992znn8t","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rxy0112ooxlce3iz14q"},{"post_id":"cixlg9rxv010zooxl992znn8t","tag_id":"cixlg9rxx0111ooxl9cql4m0g","_id":"cixlg9ry00113ooxl7s89tj02"},{"post_id":"cixlg9rxv010zooxl992znn8t","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ry00114ooxlnfyv3h4q"},{"post_id":"cixlg9rxv010zooxl992znn8t","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9ry00115ooxl5o6sjr7i"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9ry20118ooxlv5uflbnw","_id":"cixlg9ry5011aooxlj89uiycb"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9ry40119ooxlwynjo53g","_id":"cixlg9ry8011booxlmte6pv7f"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9ry8011cooxlww3r4crw"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9ry8011dooxlwq6arqrm"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9ry8011eooxlk9fy9lq7"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rc7006rooxl1vs8rdyg","_id":"cixlg9ry8011fooxlepcwhqwm"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9ry8011gooxl204rly4v"},{"post_id":"cixlg9ry8011hooxlyt6940cs","tag_id":"cixlg9ry20118ooxlv5uflbnw","_id":"cixlg9ryc011kooxlzyh2212j"},{"post_id":"cixlg9ry8011hooxlyt6940cs","tag_id":"cixlg9ryb011jooxlj980a8it","_id":"cixlg9ryd011looxliuoka1ad"},{"post_id":"cixlg9ry8011hooxlyt6940cs","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9ryd011mooxllb2y6mh4"},{"post_id":"cixlg9ry8011hooxlyt6940cs","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rye011nooxliscybrvf"},{"post_id":"cixlg9rye011oooxljwdrbzgj","tag_id":"cixlg9ry20118ooxlv5uflbnw","_id":"cixlg9ryh011qooxl8hf0evct"},{"post_id":"cixlg9rye011oooxljwdrbzgj","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9ryi011rooxlwmji9ogh"},{"post_id":"cixlg9rye011oooxljwdrbzgj","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ryi011sooxl71n9wwe7"},{"post_id":"cixlg9ryj011tooxlqxng4x0m","tag_id":"cixlg9ry20118ooxlv5uflbnw","_id":"cixlg9ryl011vooxl6q72nvr4"},{"post_id":"cixlg9ryj011tooxlqxng4x0m","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9ryn011wooxl6scgyhn6"},{"post_id":"cixlg9ryj011tooxlqxng4x0m","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ryn011xooxl2pl9ub3j"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ryr0121ooxlwjvcauor"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9ryt0122ooxlyzta2spf"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9ryt0123ooxlalrfyzbx"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9rhg00gfooxl7ajpt78z","_id":"cixlg9ryt0124ooxlxjjkypum"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ryt0125ooxl1nagbg2o"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ryw0128ooxloqxn7nbz"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9ryy0129ooxl22ci6dtw"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9ryz012aooxl5x5cz1zm"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9ryz012booxlxvlvbchf"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9rvw00ynooxlewljezon","_id":"cixlg9ryz012cooxl0dz1xc31"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rz3012gooxl1k539181"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rz6012hooxl2q6dfyci"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rz6012iooxljn4gqdzi"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9rz2012fooxlv35g1ywr","_id":"cixlg9rz6012jooxlm90s9sy3"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rz6012kooxlao9ash87"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rz6012looxlr66r3bpn"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9rex00beooxlwxao8570","_id":"cixlg9rz6012mooxlq5men0qf"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rza012pooxlup50tp69"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rzb012qooxlmmfe6aae"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","tag_id":"cixlg9rmn00nsooxl0pr2me3j","_id":"cixlg9rzb012rooxlb5ob0b5n"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rzb012sooxlikypclz6"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rzf012vooxlkbkfkcsx"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rzh012wooxlphl10na3"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9rof00qfooxlq93jumjl","_id":"cixlg9rzh012xooxlnropz9oz"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rzh012yooxlsaywpwtf"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rzh012zooxlunsbbbjo"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rzn0132ooxl49j0tfpw"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rzo0133ooxlge1yxwlz"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rzo0134ooxllvjofz4x"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9rzo0135ooxl9ag9cjpg"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rzs0138ooxl3332b1ci"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rzu0139ooxl3ngivg4j"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","tag_id":"cixlg9rl600lqooxly4jhus6y","_id":"cixlg9rzu013aooxloho6s54c"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","tag_id":"cixlg9rl600lrooxlwthjx2u0","_id":"cixlg9rzu013booxl09vgcuth"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rzx013eooxlkrxk8cn6"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s00013fooxlzsxub61j"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s00013gooxl2f07o1vm"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s00013hooxl5kx7aj28"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9s00013iooxlbuqnlqmo"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9rab003wooxl37uc1xiy","_id":"cixlg9s00013jooxljrk2yp4d"},{"post_id":"cixlg9s01013kooxlpt7nhhab","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s04013mooxlgqvzaba0"},{"post_id":"cixlg9s01013kooxlpt7nhhab","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s05013nooxllgbrdqnd"},{"post_id":"cixlg9s01013kooxlpt7nhhab","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s05013oooxlw9wwewkh"},{"post_id":"cixlg9s06013pooxll1sqek1m","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s08013rooxlood5h1j4"},{"post_id":"cixlg9s06013pooxll1sqek1m","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s09013sooxlj49xr6j3"},{"post_id":"cixlg9s06013pooxll1sqek1m","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s09013tooxlzck8ftmj"},{"post_id":"cixlg9s0a013uooxlg37nsti1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0d013wooxl66q1ofo8"},{"post_id":"cixlg9s0a013uooxlg37nsti1","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s0e013xooxlkhpxsk5m"},{"post_id":"cixlg9s0a013uooxlg37nsti1","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9s0e013yooxlnoz9nkjh"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0i0141ooxliw2njapb"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s0k0142ooxlegbar7xj"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s0k0143ooxl24xpo6ji"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9s0k0144ooxl4x6fzav5"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9ri600hlooxlg6n4blh1","_id":"cixlg9s0k0145ooxlfxbch53b"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0o0148ooxl0jtx07w0"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s0p0149ooxlrykyzwak"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s0p014aooxlmehem2hl"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9s0p014booxl24vffhg4"},{"post_id":"cixlg9s0q014cooxluoph4st4","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0t014eooxl1cda0int"},{"post_id":"cixlg9s0q014cooxluoph4st4","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s0v014fooxlusjiedtg"},{"post_id":"cixlg9s0q014cooxluoph4st4","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9s0v014gooxl78n2vwof"},{"post_id":"cixlg9s0q014cooxluoph4st4","tag_id":"cixlg9rut00x9ooxlcdp781e3","_id":"cixlg9s0v014hooxlz7l6c36q"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0y014kooxluy1c38qn"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s10014looxl4bwx17cg"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9s10014mooxlft7gutkb"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s10014nooxlagx9dml6"},{"post_id":"cixlg9s11014oooxlk15ca9gr","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s14014qooxlzfwmkj2v"},{"post_id":"cixlg9s11014oooxlk15ca9gr","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s15014rooxlh35mtd9x"},{"post_id":"cixlg9s11014oooxlk15ca9gr","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s15014sooxlsjgmu0j7"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s1d014vooxl4umg9hzk"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s1f014wooxlku0jwk58"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9s1f014xooxlt51kqh0t"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9s1f014yooxlyzlg612f"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9s1f014zooxl7ehephj3"},{"post_id":"cixlg9s1g0150ooxltpgq3ka0","tag_id":"cixlg9s1i0152ooxla05m35n3","_id":"cixlg9s1k0154ooxl9b32t6ot"},{"post_id":"cixlg9s1g0150ooxltpgq3ka0","tag_id":"cixlg9s1j0153ooxlrv98ovk8","_id":"cixlg9s1l0155ooxltvrcng1p"},{"post_id":"cixlg9s1g0150ooxltpgq3ka0","tag_id":"cixlg9rd9008booxlvhckog1m","_id":"cixlg9s1l0156ooxls8df3bme"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s1q015aooxlg6itppam"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","tag_id":"cixlg9s1o0159ooxl6hkwjn6q","_id":"cixlg9s1s015booxlv8yvgnj8"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s1s015cooxl1cw2j8f3"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s1s015dooxlool4m8g3"},{"post_id":"cixlg9s2d015eooxloob8hphs","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s2h015hooxl3fmwmsj0"},{"post_id":"cixlg9s2d015eooxloob8hphs","tag_id":"cixlg9s2g015gooxl90p0wbn7","_id":"cixlg9s2i015iooxl3n210q05"},{"post_id":"cixlg9s2d015eooxloob8hphs","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9s2i015jooxl0iwjjm9f"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s2n015nooxl18podupt"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s2q015oooxlxithyeh7"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s2q015pooxlr10qy1l6"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9s2l015mooxlkeheh0t2","_id":"cixlg9s2q015qooxl24qco4pe"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9s2q015rooxlux5jn8rj"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9rfr00cxooxldhdyuxmz","_id":"cixlg9s2q015sooxlwnd39iy5"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9r7x000kooxl1wzq6q2w","_id":"cixlg9s2u015vooxl4ggvjxis"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s2w015wooxldh7yf4x8"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s2w015xooxlluuawlcs"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s2w015yooxlq1hd7588"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9s2l015mooxlkeheh0t2","_id":"cixlg9s2w015zooxl1pzh6c89"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s320162ooxly0vmfntb"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9s350163ooxlgl3am309"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s350164ooxlkk8p3gta"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s350165ooxl3pr3qq8p"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9rex00beooxlwxao8570","_id":"cixlg9s350166ooxlkyy1ed1m"},{"post_id":"cixlg9s360167ooxl1fok2ucx","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s39016aooxltx2h4tl1"},{"post_id":"cixlg9s360167ooxl1fok2ucx","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s3b016booxl9e6zuv4n"},{"post_id":"cixlg9s360167ooxl1fok2ucx","tag_id":"cixlg9s380169ooxl6lbbs2mr","_id":"cixlg9s3b016cooxlkpjrvi44"},{"post_id":"cixlg9s360167ooxl1fok2ucx","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s3b016dooxl42phfy03"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s3f016gooxlgz2lr3qn"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s3i016hooxlb2br3eo5"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s3i016iooxlbniz24j1"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s3i016jooxlc3ztac5t"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s3i016kooxllkhw03t2"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s3i016looxlhhw7hc06"},{"post_id":"cixlg9s3i016mooxlfujpjwv5","tag_id":"cixlg9s3l016oooxlwjlyby5o","_id":"cixlg9s3n016qooxlafwpbdq6"},{"post_id":"cixlg9s3i016mooxlfujpjwv5","tag_id":"cixlg9s3m016pooxlwg1c0auh","_id":"cixlg9s3o016rooxl1y1lbv4x"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s3t016uooxlyqkh34ji"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s3v016vooxlbseqvxla"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s3v016wooxlloi5rqum"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s3w016xooxl95kj3h6u"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s3w016yooxlpc7o0vz2"},{"post_id":"cixlg9s3w016zooxl934kfe33","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s3z0171ooxlvyy8by71"},{"post_id":"cixlg9s3w016zooxl934kfe33","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s410172ooxlqnhxl5dq"},{"post_id":"cixlg9s3w016zooxl934kfe33","tag_id":"cixlg9ret00b3ooxllpne01jw","_id":"cixlg9s410173ooxl970ujpzp"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s460178ooxlggdkvza6"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9s440176ooxlcjm0iksp","_id":"cixlg9s4a0179ooxl1t6cpwgc"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s4a017aooxl85r18pyt"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s4a017booxlx6qn1731"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s4a017cooxlcdbk318v"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s4a017dooxlk4w72hdl"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9rhp00gqooxlwhqlb558","_id":"cixlg9s4a017eooxlry3opppp"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s4e017hooxlwwq34bpu"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","tag_id":"cixlg9s440176ooxlcjm0iksp","_id":"cixlg9s4f017iooxle8jyzyu1"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s4f017jooxler5sy21h"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","tag_id":"cixlg9rh500ftooxliog0rt8q","_id":"cixlg9s4f017kooxlx73u0i2r"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","tag_id":"cixlg9s4m017pooxlba720hsh","_id":"cixlg9s4n017qooxlbwoxibpv"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s4p017rooxl73k5jdxg"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9s4p017sooxlc0d83hkp"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s4p017tooxl5osdqbuf"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9s4m017pooxlba720hsh","_id":"cixlg9s4t017wooxl7dmz841d"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s4v017xooxlg5e7xgh0"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s4v017yooxlueq6x274"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s4v017zooxlmcxvp1jl"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9s4v0180ooxlca33kfxm"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9s4m017pooxlba720hsh","_id":"cixlg9s500183ooxlascyzw86"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s550184ooxlurjyhl74"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9s550185ooxlgibv0xvg"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9s550186ooxlox7th305"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9s550187ooxl6zmhm9pd"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9s550188ooxlook85s0d"},{"post_id":"cixlg9s560189ooxl8r20eqsp","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s5a018booxlbe4wwuov"},{"post_id":"cixlg9s560189ooxl8r20eqsp","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9s5c018cooxlwc8v8mzq"},{"post_id":"cixlg9s560189ooxl8r20eqsp","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s5c018dooxlorp1i60m"},{"post_id":"cixlg9s560189ooxl8r20eqsp","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s5c018eooxl8v8r5gzq"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s5h018iooxlr2mnssb5"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s5n018jooxlrdyni1qv"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s5o018kooxleny2f2vw"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s5o018looxlgn6ucqrn"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s5o018mooxlc0xsj4eg"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9s5g018hooxlgrq3o7qc","_id":"cixlg9s5o018nooxlwm5rfx8l"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s5u018qooxl6gcms8f8"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s5x018rooxlq81e973l"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s5x018sooxl5slftrln"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s5x018tooxlqw10gttx"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s5x018uooxl2lfhkynd"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s5x018vooxlbujwqpvh"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s61018yooxlpekde3ps"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s64018zooxllw5ao4zt"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s640190ooxliuvi61eo"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s640191ooxl1ewx7l4i"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s640192ooxlalf40gse"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s640193ooxl4dbmac9k"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s680196ooxlt8ggyd61"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s6b0197ooxl9s16kbce"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s6b0198ooxlkpmh5l46"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s6b0199ooxl6rjw8xp9"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s6b019aooxl3izi5uld"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s6b019booxlh0agbtw4"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9s6b019cooxlbqd4m6mt"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s6h019fooxl9qsq3kr8"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s6l019gooxlq7f1k7lv"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s6l019hooxlanxc83s3"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s6l019iooxldaa3a3u8"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s6l019jooxlmjzqlbj5"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s6l019kooxlqogdzhls"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s6t019nooxl83ab51op"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s6w019oooxltn9lzoo0"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s6w019pooxl45mwt657"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s6w019qooxljggog67c"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s6w019rooxlva5a6a88"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s6w019sooxl89bksf2y"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s70019vooxl5ixpp3hw"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s74019wooxl73vsmufz"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s74019xooxltiofe1rb"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s74019yooxldv9lg2x8"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s74019zooxl7tkhytsn"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9s5g018hooxlgrq3o7qc","_id":"cixlg9s7401a0ooxl04t2rt29"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s7901a3ooxl9s38gl4s"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s7b01a4ooxlx93wnzpw"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s7b01a5ooxlj5jag5ua"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s7b01a6ooxlgyk173pv"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s7b01a7ooxlaflx8zq7"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s7f01aaooxl99d1h095"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s7i01abooxlrzdp8uld"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s7i01acooxld1svdu67"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s7i01adooxlh7meshhj"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s7i01aeooxlpgae3uop"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s7m01ahooxl3q2z48un"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s7p01aiooxlp65zh2bq"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s7p01ajooxlkh13w2ub"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s7p01akooxl1wqn14fe"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9s7p01alooxljh1ajg81"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s7q01amooxl6jzeh8op"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s7u01apooxlpalirjkj"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s7x01aqooxlun6r5o4d"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s7x01arooxl2h0yhz7q"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s7x01asooxlfziup17p"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s7x01atooxlxgdtpj51"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9s7x01auooxlsc4o5hy0"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9s8201ayooxlbzit41i1"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9s8001axooxlyobic1zh","_id":"cixlg9s8501azooxly32fzx2z"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9reo00asooxlwj0nsdlc","_id":"cixlg9s8501b0ooxl205hh8nk"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s8501b1ooxl2k29w1qp"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s8501b2ooxl8a1zmn7x"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9rof00qfooxlq93jumjl","_id":"cixlg9s8501b3ooxllfvfblv8"},{"post_id":"cixlg9s8601b4ooxl9xtoeca1","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s8901b6ooxllcsnww4q"},{"post_id":"cixlg9s8601b4ooxl9xtoeca1","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9s8a01b7ooxlz2jr3ks1"},{"post_id":"cixlg9s8601b4ooxl9xtoeca1","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s8b01b8ooxlt19v2oi9"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s8f01bbooxlcmjhx677"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s8i01bcooxl3lhcxa67"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s8i01bdooxlfghhbicc"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s8i01beooxl2xk5lv2f"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9s8i01bfooxl4z9f9hg3"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s8i01bgooxl722prcjx"},{"post_id":"cixlg9s8j01bhooxlw1ixjot5","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s8m01bjooxl58is72ie"},{"post_id":"cixlg9s8j01bhooxlw1ixjot5","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s8n01bkooxlbvvg2z5w"},{"post_id":"cixlg9s8j01bhooxlw1ixjot5","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9s8n01blooxl2f910c1i"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s8r01boooxlgmzdjf3e"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s8t01bpooxlcoa7t8sw"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9s8t01bqooxl9djo5ts0"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9s8t01brooxly69mpn95"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s8x01buooxlihe6f15j"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s8z01bvooxlnuvdnefb"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9s8z01bwooxlg4uchppy"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9rbl005vooxl8g5rzkci","_id":"cixlg9s8z01bxooxlwq59k1v1"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9s8z01byooxli67hrgbr"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s9301c1ooxlhlbwd6uy"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s9601c2ooxl5ppt7bad"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9s9601c3ooxlpfpfmcik"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9s9601c4ooxl8fd7tcl1"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9s9601c5ooxl7dgmd1iu"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s9a01c8ooxln2eee8eq"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s9c01c9ooxl689kll4q"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9s9c01caooxlwalb5bg3"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","tag_id":"cixlg9rn800olooxln9dpmyn1","_id":"cixlg9s9c01cbooxllvdbk4c5"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s9h01cfooxllypqden0"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9s9k01cgooxl3zt8urbv"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s9k01chooxl2qi4ghrb"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s9k01ciooxl1xtgo6sc"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s9k01cjooxlrgfnl6ph"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s9o01cmooxlxp8aosdd"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9s9q01cnooxl6qaqiqv9"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s9q01coooxlnm8wms6a"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","tag_id":"cixlg9rn800olooxln9dpmyn1","_id":"cixlg9s9q01cpooxljkat3o5u"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s9y01cuooxl0liikocq"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9s9v01csooxlmermlh5i","_id":"cixlg9sa101cvooxl1v3jmibr"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sa101cwooxlavbtdk8u"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sa101cxooxlffnnjyga"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9sa101cyooxll81af90i"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9s9x01ctooxleb6zfw7h","_id":"cixlg9sa101czooxlb15hz2uv"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sa501d2ooxli9ynvywr"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","tag_id":"cixlg9rfy00dfooxl3d9e7det","_id":"cixlg9sa701d3ooxlafqk99k7"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9sa701d4ooxl66l6v9l6"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9sa701d5ooxl2s5sdt3p"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9sab01d8ooxlzeyhdtns","_id":"cixlg9sad01d9ooxlwazs3o5s"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sag01daooxldhshhhpu"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9sag01dbooxl8c0ik6kg"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sag01dcooxl0nl8nbyl"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sag01ddooxlqnwt6770"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9sag01deooxli655cihj"},{"post_id":"cixlg9saj01dfooxlkcflucvz","tag_id":"cixlg9sab01d8ooxlzeyhdtns","_id":"cixlg9sam01dhooxli5g0u2cl"},{"post_id":"cixlg9saj01dfooxlkcflucvz","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9sao01diooxl6o66ftkv"},{"post_id":"cixlg9saj01dfooxlkcflucvz","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sao01djooxl2im0mgbq"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sar01dmooxl94z08hsh"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sat01dnooxl6e3ubc9d"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sat01doooxlgpauywbt"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9sat01dpooxl4fjxnqf9"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9saz01dtooxlksnfzk1e"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9sax01dsooxlao4x3j2t","_id":"cixlg9sb101duooxl7b8420jc"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9sb101dvooxl52cd45oe"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9sb101dwooxll00pfzwk"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sb101dxooxl5pzhmv8l"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sb601e1ooxl57hcd5cr"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sba01e2ooxlhjk7rsac"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9sba01e3ooxlhpgoo1uc"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9sba01e4ooxl6k1wuf3r"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sba01e5ooxl8jsbmux8"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9sb501e0ooxlvk8hqk17","_id":"cixlg9sba01e6ooxls1tug3cj"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9sba01e7ooxl1fdattwa"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sbe01eaooxl0csr839h"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sbh01ebooxlx1qtp8a2"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","tag_id":"cixlg9rb30059ooxlcu3albgd","_id":"cixlg9sbh01ecooxla5ts68li"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sbh01edooxlil8dpp5u"},{"post_id":"cixlg9sbh01eeooxla294l35s","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sbl01egooxlkka80qv1"},{"post_id":"cixlg9sbh01eeooxla294l35s","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sbm01ehooxlhtb2b0kv"},{"post_id":"cixlg9sbh01eeooxla294l35s","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9sbm01eiooxlujibyoje"},{"post_id":"cixlg9sbn01ejooxlsdjn57bi","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sbq01elooxlvoce974w"},{"post_id":"cixlg9sbn01ejooxlsdjn57bi","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sbr01emooxl8ldj94hy"},{"post_id":"cixlg9sbn01ejooxlsdjn57bi","tag_id":"cixlg9rbz006cooxlo6c2fj1p","_id":"cixlg9sbr01enooxl9irqw02a"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sby01esooxlkkh0pj8n"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sc101etooxl50rh7swi"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sc101euooxllqa4e7tk"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sc101evooxllekebwu4"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9sbv01eqooxlwg5rkdwl","_id":"cixlg9sc101ewooxlmb82ru67"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9sbw01erooxl4wqdz5la","_id":"cixlg9sc101exooxl5e4y96y7"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sc501f0ooxlgslufy7c"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9sc801f1ooxlfa2jd70x"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sc801f2ooxl07h7ihxq"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sc801f3ooxlozermc1t"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9sc801f4ooxls6r8k1n7"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9scc01f7ooxli86a6ku4"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sce01f8ooxlwn5sfuza"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9sce01f9ooxltwpvpfye"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sce01faooxlo6yvynvu"},{"post_id":"cixlg9scf01fbooxllohwmidy","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sci01fdooxlt1xs402j"},{"post_id":"cixlg9scf01fbooxllohwmidy","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9sck01feooxlg60v3d15"},{"post_id":"cixlg9scf01fbooxllohwmidy","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sck01ffooxlyzmeo41g"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9scp01fiooxlf1vyjq5j"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9scr01fjooxl8h1ehux5"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9scr01fkooxl22sh77m3"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9scr01flooxlczsv3gmo"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9scr01fmooxly11cwm49"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9scw01fpooxlzgtwp2ec"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9scz01fqooxllwcs9pgf"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9scz01frooxlfsc2ilw4"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9scz01fsooxl641ehnoz"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9scz01ftooxl5hc80y2i"},{"post_id":"cixlg9sd001fuooxld0xz6w8z","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sd501fwooxl3co7fuqn"},{"post_id":"cixlg9sd001fuooxld0xz6w8z","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9sd601fxooxlrs59ijik"},{"post_id":"cixlg9sd001fuooxld0xz6w8z","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sd601fyooxl2yythiwc"},{"post_id":"cixlg9sd701fzooxlgv99imzv","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sda01g1ooxlbp6jyc80"},{"post_id":"cixlg9sd701fzooxlgv99imzv","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9sdc01g2ooxly2fudsjm"},{"post_id":"cixlg9sd701fzooxlgv99imzv","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sdc01g3ooxldeduyalu"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sdg01g6ooxl10necm2g"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sdi01g7ooxlrj096lj5"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9sdi01g8ooxlmt5sxsgl"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9sdi01g9ooxligu6crxy"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sdn01gcooxlzhqffetw"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9sab01d8ooxlzeyhdtns","_id":"cixlg9sdq01gdooxlii9upjz6"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sdq01geooxlv6rggect"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9sdq01gfooxly5ofdde4"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9sdq01ggooxle0nuypfy"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9rfz00dgooxl7dflz7zw","_id":"cixlg9sdq01ghooxliqmv9g93"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sdu01gkooxlz6beifaf"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sdx01glooxl4ipy8l5x"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sdx01gmooxle2q1a6ec"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9sdx01gnooxl9nvf8m8u"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9rn200obooxl8e4bkjz3","_id":"cixlg9sdx01goooxli97014yl"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9se101grooxl0z22e5lq"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9se401gsooxla9pg7it2"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9se401gtooxltg4ev1gw"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9se401guooxl4evr19ke"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9se401gvooxlbhplze7m"},{"post_id":"cixlg9se501gwooxl4he1heaz","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9se901gyooxl5hz7ph5s"},{"post_id":"cixlg9se501gwooxl4he1heaz","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sea01gzooxld02fiuog"},{"post_id":"cixlg9se501gwooxl4he1heaz","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9sea01h0ooxl0emoslsv"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9seg01h4ooxlxm4fxvny"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9sej01h5ooxl1dv34rp6"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9see01h3ooxlcc3v1zyy","_id":"cixlg9sej01h6ooxlocg89h2f"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9sej01h7ooxladwrrxog"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sej01h8ooxla3nat7oq"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sep01hbooxlxzo0gxhx"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ser01hcooxltmdjl58w"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9ser01hdooxln6c19lz5"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9ser01heooxlw9ifljbs"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sew01hhooxlxiqfls76"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9rz2012fooxlv35g1ywr","_id":"cixlg9sey01hiooxlcwt6qqw2"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sez01hjooxlfhgnjr2t"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9rex00beooxlwxao8570","_id":"cixlg9sez01hkooxldszm82ar"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sez01hlooxlnunbj4tx"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sf301hoooxlicy41ue0"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sf601hpooxlyl2ob9bt"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9sf601hqooxlezf9bznq"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9sf601hrooxl9y4c5ty8"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9sf601hsooxln318g8xp"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sfa01hvooxlr1u7sjp3"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9sfd01hwooxlf34jausc"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9sfd01hxooxlscrm265b"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sfd01hyooxlt6u91gt6"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9sfd01hzooxlg8uclgtb"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sfk01i2ooxlxsikpt84"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sfn01i3ooxlvqm9jlue"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sfn01i4ooxlmotyywdq"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sfn01i5ooxlqfo9t7jf"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sfn01i6ooxl3arj4qtz"},{"post_id":"cixlg9sfo01i7ooxlz6m9wk11","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sfs01i9ooxlua29uttn"},{"post_id":"cixlg9sfo01i7ooxlz6m9wk11","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sft01iaooxljtl8oln5"},{"post_id":"cixlg9sfo01i7ooxlz6m9wk11","tag_id":"cixlg9rsq00upooxl3x7f7dd6","_id":"cixlg9sft01ibooxl66ayx9y0"},{"post_id":"cixlg9sfu01icooxl6b4q2hml","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sfz01ieooxl802v2i5l"},{"post_id":"cixlg9sfu01icooxl6b4q2hml","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sg101ifooxle0ybnkrg"},{"post_id":"cixlg9sfu01icooxl6b4q2hml","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sg101igooxl16wki9bh"},{"post_id":"cixlg9sg201ihooxlf6fgnhkg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sg601ijooxltq2y2jzm"},{"post_id":"cixlg9sg201ihooxlf6fgnhkg","tag_id":"cixlg9rgr00f2ooxl5h77j5xb","_id":"cixlg9sg701ikooxlxr3hxoaa"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sgb01inooxlnf9z559i"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9sgg01ioooxlnkywsj5a"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sgg01ipooxlmstrrmwn"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sgg01iqooxljyqjxvly"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9sgg01irooxlykyant8k"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9rn800olooxln9dpmyn1","_id":"cixlg9sgh01isooxl1qkwqrjo"},{"post_id":"cixlg9sgh01itooxl4uq404pe","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sgl01ivooxll3j5i550"},{"post_id":"cixlg9sgh01itooxl4uq404pe","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9sgn01iwooxlom8e8rz6"},{"post_id":"cixlg9sgh01itooxl4uq404pe","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9sgn01ixooxlcd0vrwf4"},{"post_id":"cixlg9sgh01itooxl4uq404pe","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9sgn01iyooxlg9wa56sm"},{"post_id":"cixlg9sgo01izooxlvy5gpnck","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sgr01j1ooxl0rrbb1pv"},{"post_id":"cixlg9sgo01izooxlvy5gpnck","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sgt01j2ooxlkz6qowk8"},{"post_id":"cixlg9sgo01izooxlvy5gpnck","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9sgt01j3ooxlha2pa25x"},{"post_id":"cixlg9sgu01j4ooxlhpdlz7gb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sgx01j6ooxl5so88b2s"},{"post_id":"cixlg9sgu01j4ooxlhpdlz7gb","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sgz01j7ooxl3s0ntc5t"},{"post_id":"cixlg9sgu01j4ooxlhpdlz7gb","tag_id":"cixlg9r7x000kooxl1wzq6q2w","_id":"cixlg9sgz01j8ooxlokos0atz"},{"post_id":"cixlg9sh001j9ooxlbo7maly2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sh301jbooxl64g6jhuq"},{"post_id":"cixlg9sh001j9ooxlbo7maly2","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9sh501jcooxlwydgc34g"},{"post_id":"cixlg9sh001j9ooxlbo7maly2","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sh501jdooxlo9qkzkgl"},{"post_id":"cixlg9sh601jeooxl6gdfag18","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9shb01jhooxll2iigb28"},{"post_id":"cixlg9sh601jeooxl6gdfag18","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9shd01jiooxlsnanvdba"},{"post_id":"cixlg9sh601jeooxl6gdfag18","tag_id":"cixlg9sh901jgooxlcbu0n7lg","_id":"cixlg9shd01jjooxly0w7stx9"},{"post_id":"cixlg9sh601jeooxl6gdfag18","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9shd01jkooxlzzddc8ep"},{"post_id":"cixlg9she01jlooxl1qtik5ks","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9shh01jnooxl2mbmm8bf"},{"post_id":"cixlg9she01jlooxl1qtik5ks","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9shk01joooxle2rj7wbd"},{"post_id":"cixlg9she01jlooxl1qtik5ks","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9shk01jpooxlo3g18fq8"},{"post_id":"cixlg9she01jlooxl1qtik5ks","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9shk01jqooxlr5vsxelk"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sho01jtooxlw5kzl0rf"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9shr01juooxl58mpxr6y"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9shr01jvooxlrjws1tpk"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9shr01jwooxlq674j8f8"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9shr01jxooxlsfqyg4ko"},{"post_id":"cixlg9shs01jyooxle7mhon4u","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9shw01k0ooxlbf5pmsi5"},{"post_id":"cixlg9shs01jyooxle7mhon4u","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9shx01k1ooxlret9mlcs"},{"post_id":"cixlg9shs01jyooxle7mhon4u","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9shx01k2ooxlq0ys70uh"},{"post_id":"cixlg9shy01k3ooxld3fb801r","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9si201k5ooxle5lh7hoe"},{"post_id":"cixlg9shy01k3ooxld3fb801r","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9si401k6ooxl2gah9f3v"},{"post_id":"cixlg9shy01k3ooxld3fb801r","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9si401k7ooxlewyis2rj"},{"post_id":"cixlg9shy01k3ooxld3fb801r","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9si401k8ooxl4k8s8bx2"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9si801kbooxlk0bguwl6"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9sib01kcooxllpnmk968"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9sib01kdooxl0w1282ub"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sib01keooxl2fbf1dam"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sib01kfooxldfe80j08"},{"post_id":"cixlg9sic01kgooxlh6482eho","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sii01kjooxlas7dfv1j"},{"post_id":"cixlg9sic01kgooxlh6482eho","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sik01kkooxl4blq9bxf"},{"post_id":"cixlg9sic01kgooxlh6482eho","tag_id":"cixlg9sig01kiooxl0qora2h0","_id":"cixlg9sik01klooxlvfxsvw4m"},{"post_id":"cixlg9sic01kgooxlh6482eho","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9sik01kmooxl4lpw1u6v"},{"post_id":"cixlg9sil01knooxlo1st7o09","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sip01kpooxlchnr9fkl"},{"post_id":"cixlg9sil01knooxlo1st7o09","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sis01kqooxlp3ue0coy"},{"post_id":"cixlg9sil01knooxlo1st7o09","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sis01krooxl25g5wrux"},{"post_id":"cixlg9sil01knooxlo1st7o09","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sis01ksooxlewrc5l0r"},{"post_id":"cixlg9sit01ktooxl5amhekiy","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9six01kvooxlqm402a0o"},{"post_id":"cixlg9sit01ktooxl5amhekiy","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9siz01kwooxlvat6j569"},{"post_id":"cixlg9sit01ktooxl5amhekiy","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9siz01kxooxlbm4ol1dq"},{"post_id":"cixlg9sit01ktooxl5amhekiy","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9siz01kyooxlr0tlvc8o"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sj801l1ooxl3c4yzzgm"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sjc01l2ooxl03dzrl5r"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sjc01l3ooxlos6yqlka"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9sjc01l4ooxl80cz18k3"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9sjc01l5ooxlslvclwws"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sjk01l8ooxlo6mnawfa"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sjn01l9ooxl72rpva01"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9sjn01laooxlzpy9a3m7"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9sjn01lbooxlme1ddjcx"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sjs01leooxl23bo1zna"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sjv01lfooxlfq9ay3dm"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sjv01lgooxleaigsk2v"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9sjv01lhooxlfzar84lw"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sjv01liooxl6ll23ybw"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sk101llooxl5pb6r7ku"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9sk401lmooxlvcebuml7"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","tag_id":"cixlg9rg200dpooxlpxgfrm7a","_id":"cixlg9sk401lnooxlxm0hikh5"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sk401loooxl6yxb1112"},{"post_id":"cixlg9sk501lpooxllld15m00","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sk801lrooxliutqsc9e"},{"post_id":"cixlg9sk501lpooxllld15m00","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9ska01lsooxl1nd6bkbu"},{"post_id":"cixlg9sk501lpooxllld15m00","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9ska01ltooxln5mj78mg"},{"post_id":"cixlg9skb01luooxlybp32p0j","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9skk01lwooxlq2ngx388"},{"post_id":"cixlg9skb01luooxlybp32p0j","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9skm01lxooxl2vyjzx31"},{"post_id":"cixlg9skb01luooxlybp32p0j","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9skm01lyooxlytxowiv0"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9skr01m1ooxl70m4v21p"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9skt01m2ooxl49d1nbfu"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9skt01m3ooxlszzjntvd"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9skt01m4ooxld8i28lz1"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sky01m7ooxl0u9tshwu"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9sl101m8ooxlogoiffkz"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sl101m9ooxl12ajrc3t"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9sl101maooxlia3z5nqt"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9sl101mbooxl2sx9bsxt"},{"post_id":"cixlg9sl201mcooxlv07ksmff","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sl601meooxlqy4twtb9"},{"post_id":"cixlg9sl201mcooxlv07ksmff","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9sl801mfooxlhzgjcs6r"},{"post_id":"cixlg9sl201mcooxlv07ksmff","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9sl801mgooxlw0marjvb"},{"post_id":"cixlg9sl201mcooxlv07ksmff","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9sl801mhooxlozh3mki0"},{"post_id":"cixlg9sl901miooxljfxbb22y","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sld01mkooxlshferh9k"},{"post_id":"cixlg9sl901miooxljfxbb22y","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9slg01mlooxlh90e6jiw"},{"post_id":"cixlg9sl901miooxljfxbb22y","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9slg01mmooxlme9ibyqw"},{"post_id":"cixlg9sl901miooxljfxbb22y","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9slg01mnooxl0l81134x"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9slm01mrooxleowwkf4z"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9slp01msooxlk174v6m3"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9slp01mtooxlhteynnnw"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9slj01mqooxldc9qajm0","_id":"cixlg9slp01muooxl72bp4mut"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9rg300dqooxljoaconen","_id":"cixlg9slp01mvooxlcw6zkp2r"},{"post_id":"cixlg9slq01mwooxlefrrc6zm","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9slt01myooxl86bhxz1g"},{"post_id":"cixlg9slq01mwooxlefrrc6zm","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9slu01mzooxlsicc5rer"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sma01n6ooxlyxuevsdk"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","tag_id":"cixlg9sm701n4ooxl7zlbu8l9","_id":"cixlg9smd01n7ooxlwjxwd5yu"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9smd01n8ooxlljvbd0ai"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","tag_id":"cixlg9sm801n5ooxl8g1hv5ne","_id":"cixlg9smd01n9ooxlf44wxeur"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9smi01ncooxlzn6a5357"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9sm701n4ooxl7zlbu8l9","_id":"cixlg9sml01ndooxl6zsn7vnv"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sml01neooxltnz5e7gk"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9sml01nfooxl0d1bq3f3"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9sml01ngooxlawjv01op"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9smt01nmooxl49ezcnm8"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9sm701n4ooxl7zlbu8l9","_id":"cixlg9smz01nnooxl27vy02yo"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9smz01noooxlge58qars"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9smz01npooxle5v8y5oq"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9smz01nqooxlwxyiyia6"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9smp01njooxlytyl9kii","_id":"cixlg9smz01nrooxldzdfsxmj"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9smq01nkooxlrcpmhl1t","_id":"cixlg9smz01nsooxlw0v6kj5u"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9smr01nlooxlcaizbhnv","_id":"cixlg9smz01ntooxl24x74l0m"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sn501nxooxlmnysmjte"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9sn301nwooxlx3m2uyjt","_id":"cixlg9sn901nyooxlxrc39gu2"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sn901nzooxlo62ru2dl"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9sn901o0ooxln3kk6ic7"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9roo00qxooxl28ecubjc","_id":"cixlg9sn901o1ooxlrnvh4qmq"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9sn901o2ooxllizvbkq8"},{"post_id":"cixlg9snb01o3ooxl45snx359","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9snj01o5ooxlrfub6oz4"},{"post_id":"cixlg9snb01o3ooxl45snx359","tag_id":"cixlg9sn301nwooxlx3m2uyjt","_id":"cixlg9snn01o6ooxlgqnt3aor"},{"post_id":"cixlg9snb01o3ooxl45snx359","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9snn01o7ooxlzc1t57y0"},{"post_id":"cixlg9snb01o3ooxl45snx359","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9snn01o8ooxlsxgjl2i3"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9snu01ocooxlweyqkm1i"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9sn301nwooxlx3m2uyjt","_id":"cixlg9snx01odooxlmlyv95e3"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9snx01oeooxl5gdfr9ng"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9snx01ofooxllkskd08o"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9sns01obooxlkc2bvkb3","_id":"cixlg9snx01ogooxlx2tevstb"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9so201ojooxlzq49z6w7"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9sn301nwooxlx3m2uyjt","_id":"cixlg9so501okooxlybavgv84"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9so601olooxlt2kof8r5"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9rgr00f2ooxl5h77j5xb","_id":"cixlg9so601omooxlivvk0cg0"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9so601onooxlog2rd875"},{"post_id":"cixlg9so601ooooxluh670jtd","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9soa01oqooxlst08pqha"},{"post_id":"cixlg9so601ooooxluh670jtd","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sod01orooxlkresep8i"},{"post_id":"cixlg9so601ooooxluh670jtd","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9sod01osooxl1xpobwcg"},{"post_id":"cixlg9so601ooooxluh670jtd","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9sod01otooxl1sviftrm"},{"post_id":"cixlg9soh01ouooxl31ydifdg","tag_id":"cixlg9sol01owooxlnsy6tr1f","_id":"cixlg9soo01oyooxlubt3x8li"},{"post_id":"cixlg9soh01ouooxl31ydifdg","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9soq01ozooxlu0b7d1fv"},{"post_id":"cixlg9soh01ouooxl31ydifdg","tag_id":"cixlg9som01oxooxlbyevypln","_id":"cixlg9soq01p0ooxl4ncekq1k"},{"post_id":"cixlg9soh01ouooxl31ydifdg","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9soq01p1ooxla7jh44z4"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9sox01p5ooxlxecql5y6"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9rh500ftooxliog0rt8q","_id":"cixlg9sp001p6ooxlxv92b0mp"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9sou01p4ooxlnhjn2tly","_id":"cixlg9sp101p7ooxlxdyn2n1j"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sp101p8ooxlq9vvtu2p"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sp101p9ooxlujbgj9j3"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9sp101paooxln0fqloeo"},{"post_id":"cixlg9sp101pbooxlgpu4kmkq","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9sp601peooxlfgdaznol"},{"post_id":"cixlg9sp101pbooxlgpu4kmkq","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sp801pfooxlh6q02d1h"},{"post_id":"cixlg9sp101pbooxlgpu4kmkq","tag_id":"cixlg9sp401pdooxl8crfl9d2","_id":"cixlg9sp801pgooxlhle5jx3m"},{"post_id":"cixlg9sp901phooxlc2uv4z47","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9spd01pjooxlmcosaapl"},{"post_id":"cixlg9sp901phooxlc2uv4z47","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9spf01pkooxl6pipe5qv"},{"post_id":"cixlg9sp901phooxlc2uv4z47","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9spf01plooxlmng7n4lc"},{"post_id":"cixlg9sp901phooxlc2uv4z47","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9spf01pmooxli3ottx9c"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9spm01pqooxlijsey068"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9spj01ppooxlwdbmdw83","_id":"cixlg9spp01prooxlsheedey8"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9sbv01eqooxlwg5rkdwl","_id":"cixlg9spp01psooxlm9g2r5yz"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9spp01ptooxlmkm1lnty"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9rod00qdooxlha53ivln","_id":"cixlg9spp01puooxl25dgl9st"}],"Tag":[{"name":"安徽集训","_id":"cixlg9r7c0002ooxlgw1ab7ay"},{"name":"树链剖分","_id":"cixlg9r7g0003ooxlouh2e40f"},{"name":"线段树","_id":"cixlg9r7g0004ooxlpu66horl"},{"name":"数据结构","_id":"cixlg9r7h0005ooxl7xizzqno"},{"name":"高级数据结构","_id":"cixlg9r7h0006ooxlkks9dhtl"},{"name":"BZOJ","_id":"cixlg9r7w000iooxlt8ncwmsh"},{"name":"ZJOI","_id":"cixlg9r7x000jooxl3ou6o1z6"},{"name":"FFT","_id":"cixlg9r7x000kooxl1wzq6q2w"},{"name":"数学","_id":"cixlg9r7x000looxlfgkh3sst"},{"name":"网络流","_id":"cixlg9r81000sooxl5gjr8ndd"},{"name":"Dinic","_id":"cixlg9r81000tooxlvy3lm704"},{"name":"费用流","_id":"cixlg9r82000uooxl4p625n8c"},{"name":"Edmonds-Karp","_id":"cixlg9r82000vooxly90aizya"},{"name":"最小割","_id":"cixlg9r890014ooxlijrzvrc1"},{"name":"DP","_id":"cixlg9r8e001cooxl3z233dg9"},{"name":"贪心","_id":"cixlg9r8l001iooxldlw1thtn"},{"name":"COGS","_id":"cixlg9r8q001oooxltzzq2ggv"},{"name":"模拟","_id":"cixlg9r8r001pooxlyc0q1m6c"},{"name":"几何","_id":"cixlg9r8r001qooxlwlkctz05"},{"name":"斜率优化","_id":"cixlg9r8v001zooxlcpw9gdef"},{"name":"单调队列","_id":"cixlg9r8v0020ooxlw36qxixv"},{"name":"强连通分量","_id":"cixlg9r8z0029ooxlyqa6zz0l"},{"name":"Tarjan","_id":"cixlg9r90002aooxlgrd2fgg3"},{"name":"缩点","_id":"cixlg9r90002booxli7z03vs8"},{"name":"悬线法","_id":"cixlg9r93002kooxlh54bru8k"},{"name":"最短路","_id":"cixlg9r96002qooxl5r2zlzp3"},{"name":"矩阵乘法","_id":"cixlg9r9e002yooxlon1e05fs"},{"name":"OS X","_id":"cixlg9r9h0036ooxlqisj2rda"},{"name":"Linux","_id":"cixlg9r9i0037ooxlsbc7nni3"},{"name":"Archlinux","_id":"cixlg9r9i0038ooxlkm3my37w"},{"name":"VirtualBox","_id":"cixlg9r9i0039ooxlvgirf8rg"},{"name":"虚拟机","_id":"cixlg9r9i003aooxlewo42a2j"},{"name":"SSH","_id":"cixlg9r9i003booxlqglqwn0h"},{"name":"UVa","_id":"cixlg9ra5003looxlqj25k0xd"},{"name":"区间 DP","_id":"cixlg9ra6003mooxl1fo09kse"},{"name":"计数原理","_id":"cixlg9ra7003nooxlw398qyzu"},{"name":"组合数学","_id":"cixlg9rab003vooxlzfo01j5s"},{"name":"容斥原理","_id":"cixlg9rab003wooxl37uc1xiy"},{"name":"递推","_id":"cixlg9rao0049ooxlbzlf0rr3"},{"name":"高精度","_id":"cixlg9rao004aooxlk0p6c313"},{"name":"数位 DP","_id":"cixlg9rar004hooxlh2cneg9p"},{"name":"数论","_id":"cixlg9rau004pooxlsan64mz1"},{"name":"乘法逆元","_id":"cixlg9rav004qooxldtjdx275"},{"name":"全排列","_id":"cixlg9rav004rooxl64zczyza"},{"name":"背包 DP","_id":"cixlg9raz0051ooxl916ggp6y"},{"name":"概率与期望","_id":"cixlg9rb30059ooxlcu3albgd"},{"name":"组合数","_id":"cixlg9rb8005hooxlvkuj3iik"},{"name":"整数划分","_id":"cixlg9rb8005iooxl4nklbagp"},{"name":"回溯","_id":"cixlg9rb9005jooxljsf2wusx"},{"name":"CodeVS","_id":"cixlg9rbi005tooxledxvr0pf"},{"name":"Tyvj","_id":"cixlg9rbk005uooxlb05mbcgh"},{"name":"划分 DP","_id":"cixlg9rbl005vooxl8g5rzkci"},{"name":"算法模板","_id":"cixlg9rbp0062ooxlfaygxjdl"},{"name":"TJOI","_id":"cixlg9rbz006booxlc2aoef6x"},{"name":"状压 DP","_id":"cixlg9rbz006cooxlo6c2fj1p"},{"name":"字符串","_id":"cixlg9rc3006jooxljttx1uit"},{"name":"AC 自动机","_id":"cixlg9rc4006kooxl1xded5ep"},{"name":"离线","_id":"cixlg9rc7006rooxl1vs8rdyg"},{"name":"Splay","_id":"cixlg9rc8006sooxl8iyr5nub"},{"name":"树状数组","_id":"cixlg9rc9006tooxlt4hpqc8m"},{"name":"学习笔记","_id":"cixlg9rcl0074ooxl5pv0t1yh"},{"name":"图论","_id":"cixlg9rcm0075ooxlzl3dcu1u"},{"name":"强联通分量","_id":"cixlg9rcn0076ooxl3h88991m"},{"name":"割点","_id":"cixlg9rcs007eooxljl4cr6fp"},{"name":"双联通分量","_id":"cixlg9rcv007mooxl2rcb6kfa"},{"name":"差分约束系统","_id":"cixlg9rcy007uooxlgxy1ji5a"},{"name":"后缀数组","_id":"cixlg9rd40082ooxlb1eovlp3"},{"name":"稀疏表","_id":"cixlg9rd50083ooxlpmj401g3"},{"name":"C++","_id":"cixlg9rd9008booxlvhckog1m"},{"name":"STL","_id":"cixlg9rd9008cooxlorh78wc9"},{"name":"SPOJ","_id":"cixlg9rdi008hooxly39dpt5q"},{"name":"SHOI","_id":"cixlg9rdz009dooxl0667i3py"},{"name":"博弈论","_id":"cixlg9re1009jooxl17lu709s"},{"name":"仙人掌","_id":"cixlg9reb00a0ooxlhez8iqr8"},{"name":"CDQ","_id":"cixlg9rej00afooxlb4lvl9wu"},{"name":"分治","_id":"cixlg9rej00agooxlg957oy88"},{"name":"SDOI","_id":"cixlg9ren00apooxlc77jnqlj"},{"name":"二进制","_id":"cixlg9ren00aqooxlfsj277q8"},{"name":"异或","_id":"cixlg9reo00arooxleknn6uqx"},{"name":"位运算","_id":"cixlg9reo00asooxlwj0nsdlc"},{"name":"错位排列","_id":"cixlg9ret00b3ooxllpne01jw"},{"name":"素数判定","_id":"cixlg9rex00bdooxlx8kdkklz"},{"name":"线性筛","_id":"cixlg9rex00beooxlwxao8570"},{"name":"二分答案","_id":"cixlg9rex00bfooxld9yilwth"},{"name":"RMQ","_id":"cixlg9rf600c0ooxlh79pc7t9"},{"name":"最近公共祖先","_id":"cixlg9rfa00c9ooxl4findci1"},{"name":"实数二分","_id":"cixlg9rfl00ckooxl1t1ryhzn"},{"name":"NTT","_id":"cixlg9rfp00cuooxlb418ewkl"},{"name":"生成函数","_id":"cixlg9rfq00cvooxlscwpkhkd"},{"name":"快速幂","_id":"cixlg9rfr00cwooxl2taux3yw"},{"name":"原根","_id":"cixlg9rfr00cxooxldhdyuxmz"},{"name":"并查集","_id":"cixlg9rfy00deooxl4rys2yhu"},{"name":"主席树","_id":"cixlg9rfy00dfooxl3d9e7det"},{"name":"启发式合并","_id":"cixlg9rfz00dgooxl7dflz7zw"},{"name":"EXGCD","_id":"cixlg9rg200dpooxlpxgfrm7a"},{"name":"BSGS","_id":"cixlg9rg300dqooxljoaconen"},{"name":"动态树","_id":"cixlg9rgk00epooxlz9d136ps"},{"name":"Link-Cut Tree","_id":"cixlg9rgl00eqooxl6rx31ll9"},{"name":"SCOI","_id":"cixlg9rgq00f0ooxla2z4aqjo"},{"name":"set","_id":"cixlg9rgq00f1ooxljoqfe3j6"},{"name":"乱搞","_id":"cixlg9rgr00f2ooxl5h77j5xb"},{"name":"二分图匹配","_id":"cixlg9rh000fjooxlob9h9hrs"},{"name":"树形 DP","_id":"cixlg9rh500ftooxliog0rt8q"},{"name":"倍增","_id":"cixlg9rh900g1ooxlncu1qjx3"},{"name":"拓扑排序","_id":"cixlg9rhg00gfooxl7ajpt78z"},{"name":"匈牙利算法","_id":"cixlg9rho00gpooxldpn403og"},{"name":"枚举答案","_id":"cixlg9rhp00gqooxlwhqlb558"},{"name":"群论","_id":"cixlg9ri100hbooxlkoeo17fm"},{"name":"搜索","_id":"cixlg9ri600hkooxlzzsveto4"},{"name":"DFS","_id":"cixlg9ri600hlooxlg6n4blh1"},{"name":"树分块","_id":"cixlg9rih00i7ooxl65jx3w5z"},{"name":"分块","_id":"cixlg9rii00i8ooxlfaebte34"},{"name":"POJ","_id":"cixlg9rit00irooxlr95e0h0y"},{"name":"Trie","_id":"cixlg9riu00isooxlcigd4msu"},{"name":"KMP","_id":"cixlg9riy00iyooxlqp6j5wny"},{"name":"Prim","_id":"cixlg9rj200j5ooxl5hfu647a"},{"name":"生成树","_id":"cixlg9rj300j6ooxlxbxwjitw"},{"name":"分数规划","_id":"cixlg9rj300j7ooxly5xcactb"},{"name":"POI","_id":"cixlg9rjb00joooxl7dpm24bd"},{"name":"NOIP","_id":"cixlg9rkb00kxooxledeoav11"},{"name":"前缀和","_id":"cixlg9rke00l2ooxl1uern1gg"},{"name":"队列","_id":"cixlg9rkx00leooxlh03treh7"},{"name":"Floyd","_id":"cixlg9rl200ljooxlseakivmj"},{"name":"状态压缩","_id":"cixlg9rl600lqooxly4jhus6y"},{"name":"BFS","_id":"cixlg9rl600lrooxlwthjx2u0"},{"name":"Hash","_id":"cixlg9rlr00mfooxlmgoshp8r"},{"name":"SPFA","_id":"cixlg9rm000muooxlvx6kdpsq"},{"name":"逆序对","_id":"cixlg9rm700n3ooxlba6ej9bv"},{"name":"二分","_id":"cixlg9rmn00nsooxl0pr2me3j"},{"name":"差分","_id":"cixlg9rmq00ntooxl3yfmg7cc"},{"name":"Vijos","_id":"cixlg9rmz00o9ooxl61y81v7x"},{"name":"洛谷","_id":"cixlg9rn000oaooxlafm6tkz7"},{"name":"二分图染色","_id":"cixlg9rn200obooxl8e4bkjz3"},{"name":"线性 DP","_id":"cixlg9rn800olooxln9dpmyn1"},{"name":"NOI","_id":"cixlg9rnw00pnooxlb0nmeehc"},{"name":"离散化","_id":"cixlg9rod00qdooxlha53ivln"},{"name":"哈希","_id":"cixlg9roe00qeooxl9sfddbb5"},{"name":"map","_id":"cixlg9rof00qfooxlq93jumjl"},{"name":"上下界网络流","_id":"cixlg9roo00qxooxl28ecubjc"},{"name":"哈夫曼树","_id":"cixlg9roz00r6ooxlo5iwgtep"},{"name":"堆","_id":"cixlg9rp000r7ooxlymu9fyh8"},{"name":"LCT","_id":"cixlg9rpk00ryooxl36numal7"},{"name":"坐标变换","_id":"cixlg9rq500shooxlt5reslko"},{"name":"二维树状数组","_id":"cixlg9rq700siooxlrvcwf8av"},{"name":"最大权闭合图","_id":"cixlg9rqz00sqooxl63n06e12"},{"name":"点分治","_id":"cixlg9rrv00tlooxl6yjfntb3"},{"name":"莫队","_id":"cixlg9rse00u6ooxlnjgn3lg4"},{"name":"Kruskal","_id":"cixlg9rsi00ucooxlwjr6ng4m"},{"name":"最小生成树","_id":"cixlg9rsj00udooxl4sgwnk5b"},{"name":"Manacher","_id":"cixlg9rsq00upooxl3x7f7dd6"},{"name":"JSOI","_id":"cixlg9rtb00vbooxljymxu8cu"},{"name":"高斯消元","_id":"cixlg9rtm00vpooxl0x4ha848"},{"name":"博弈","_id":"cixlg9rts00vzooxl6iva4crz"},{"name":"枚举","_id":"cixlg9rut00x9ooxlcdp781e3"},{"name":"IOI","_id":"cixlg9rv900xtooxla3ya2diu"},{"name":"基环树","_id":"cixlg9rvf00y0ooxlaikb14ap"},{"name":"HNOI","_id":"cixlg9rvk00y8ooxljxtmuyiu"},{"name":"DFS 序","_id":"cixlg9rvw00ynooxlewljezon"},{"name":"Prüfer 序列","_id":"cixlg9rwk00zgooxl7mcitqah"},{"name":"弦图","_id":"cixlg9rww00zxooxlxr3mjpwx"},{"name":"最大势","_id":"cixlg9rwx00zyooxl7u22v0ag"},{"name":"Burnside 引理","_id":"cixlg9rx9010eooxlyuii46yp"},{"name":"HEOI","_id":"cixlg9rxx0111ooxl9cql4m0g"},{"name":"HDU","_id":"cixlg9ry20118ooxlv5uflbnw"},{"name":"Bestcoder","_id":"cixlg9ry40119ooxlwynjo53g"},{"name":"BestCoder","_id":"cixlg9ryb011jooxlj980a8it"},{"name":"HAOI","_id":"cixlg9ryp0120ooxlouxejw54"},{"name":"莫比乌斯反演","_id":"cixlg9rz2012fooxlv35g1ywr"},{"name":"GDB","_id":"cixlg9s1i0152ooxla05m35n3"},{"name":"调试","_id":"cixlg9s1j0153ooxlrv98ovk8"},{"name":"计算几何","_id":"cixlg9s1o0159ooxl6hkwjn6q"},{"name":"FJOI","_id":"cixlg9s2g015gooxl90p0wbn7"},{"name":"多项式","_id":"cixlg9s2l015mooxlkeheh0t2"},{"name":"欧拉回路","_id":"cixlg9s380169ooxl6lbbs2mr"},{"name":"Docker","_id":"cixlg9s3l016oooxlwjlyby5o"},{"name":"评测系统","_id":"cixlg9s3m016pooxlwg1c0auh"},{"name":"CTSC","_id":"cixlg9s440176ooxlcjm0iksp"},{"name":"网络流 24 题","_id":"cixlg9s450177ooxl6o0v9ah2"},{"name":"CQOI","_id":"cixlg9s4m017pooxlba720hsh"},{"name":"最大独立集","_id":"cixlg9s5g018hooxlgrq3o7qc"},{"name":"记忆化搜索","_id":"cixlg9s8001axooxlyobic1zh"},{"name":"USACO","_id":"cixlg9s9f01ceooxl27qmc1ld"},{"name":"COCI","_id":"cixlg9s9v01csooxlmermlh5i"},{"name":"树上路径并","_id":"cixlg9s9x01ctooxleb6zfw7h"},{"name":"Codeforces","_id":"cixlg9sab01d8ooxlzeyhdtns"},{"name":"CEOI","_id":"cixlg9sax01dsooxlao4x3j2t"},{"name":"Lucas 定理","_id":"cixlg9sb501e0ooxlvk8hqk17"},{"name":"链表","_id":"cixlg9sbv01eqooxlwg5rkdwl"},{"name":"栈","_id":"cixlg9sbw01erooxl4wqdz5la"},{"name":"平衡树","_id":"cixlg9see01h3ooxlcc3v1zyy"},{"name":"Dijkstra","_id":"cixlg9sh901jgooxlcbu0n7lg"},{"name":"割边","_id":"cixlg9sig01kiooxl0qora2h0"},{"name":"离散对数","_id":"cixlg9slj01mqooxldc9qajm0"},{"name":"APIO","_id":"cixlg9sm701n4ooxl7zlbu8l9"},{"name":"左偏树","_id":"cixlg9sm801n5ooxl8g1hv5ne"},{"name":"DAG","_id":"cixlg9smp01njooxlytyl9kii"},{"name":"最长路","_id":"cixlg9smq01nkooxlrcpmhl1t"},{"name":"Bellman-Ford","_id":"cixlg9smr01nlooxlcaizbhnv"},{"name":"AHOI","_id":"cixlg9sn301nwooxlx3m2uyjt"},{"name":"单调栈","_id":"cixlg9sns01obooxlkc2bvkb3"},{"name":"省队集训","_id":"cixlg9sol01owooxlnsy6tr1f"},{"name":"块状链表","_id":"cixlg9som01oxooxlbyevypln"},{"name":"暴力","_id":"cixlg9sou01p4ooxlnhjn2tly"},{"name":"二分查找","_id":"cixlg9sp401pdooxl8crfl9d2"},{"name":"扫描线","_id":"cixlg9spj01ppooxlwdbmdw83"}]}}