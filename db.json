{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/icarus/source/vendor/source-code-pro/styles.css","path":"vendor/source-code-pro/styles.css","modified":1},{"_id":"themes/icarus/source/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","path":"vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":1},{"_id":"themes/icarus/source/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","path":"vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/styles.css","path":"vendor/open-sans/styles.css","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","path":"vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","path":"vendor/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","path":"vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":1},{"_id":"themes/icarus/source/vendor/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","path":"vendor/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lightgallery.min.js","path":"vendor/lightgallery/js/lightgallery.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lightgallery.js","path":"vendor/lightgallery/js/lightgallery.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-zoom.min.js","path":"vendor/lightgallery/js/lg-zoom.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-zoom.js","path":"vendor/lightgallery/js/lg-zoom.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-video.min.js","path":"vendor/lightgallery/js/lg-video.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-video.js","path":"vendor/lightgallery/js/lg-video.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-thumbnail.min.js","path":"vendor/lightgallery/js/lg-thumbnail.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-thumbnail.js","path":"vendor/lightgallery/js/lg-thumbnail.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-share.min.js","path":"vendor/lightgallery/js/lg-share.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-share.js","path":"vendor/lightgallery/js/lg-share.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-pager.min.js","path":"vendor/lightgallery/js/lg-pager.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-pager.js","path":"vendor/lightgallery/js/lg-pager.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-hash.min.js","path":"vendor/lightgallery/js/lg-hash.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-hash.js","path":"vendor/lightgallery/js/lg-hash.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-fullscreen.min.js","path":"vendor/lightgallery/js/lg-fullscreen.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-fullscreen.js","path":"vendor/lightgallery/js/lg-fullscreen.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-autoplay.min.js","path":"vendor/lightgallery/js/lg-autoplay.min.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-autoplay.js","path":"vendor/lightgallery/js/lg-autoplay.js","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/img/youtube-play.png","path":"vendor/lightgallery/img/youtube-play.png","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/img/vimeo-play.png","path":"vendor/lightgallery/img/vimeo-play.png","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/img/video-play.png","path":"vendor/lightgallery/img/video-play.png","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/img/loading.gif","path":"vendor/lightgallery/img/loading.gif","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.woff","path":"vendor/lightgallery/fonts/lg.woff","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.ttf","path":"vendor/lightgallery/fonts/lg.ttf","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.svg","path":"vendor/lightgallery/fonts/lg.svg","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.eot","path":"vendor/lightgallery/fonts/lg.eot","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.min.css","path":"vendor/lightgallery/css/lightgallery.min.css","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.css.map","path":"vendor/lightgallery/css/lightgallery.css.map","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.css","path":"vendor/lightgallery/css/lightgallery.css","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.min.css","path":"vendor/lightgallery/css/lg-transitions.min.css","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.css.map","path":"vendor/lightgallery/css/lg-transitions.css.map","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.css","path":"vendor/lightgallery/css/lg-transitions.css","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.min.css","path":"vendor/lightgallery/css/lg-fb-comment-box.min.css","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.css.map","path":"vendor/lightgallery/css/lg-fb-comment-box.css.map","modified":1},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.css","path":"vendor/lightgallery/css/lg-fb-comment-box.css","modified":1},{"_id":"themes/icarus/source/vendor/justified-gallery/justifiedGallery.min.css","path":"vendor/justified-gallery/justifiedGallery.min.css","modified":1},{"_id":"themes/icarus/source/vendor/justified-gallery/jquery.justifiedGallery.min.js","path":"vendor/justified-gallery/jquery.justifiedGallery.min.js","modified":1},{"_id":"themes/icarus/source/vendor/jquery/2.1.3/jquery.min.js","path":"vendor/jquery/2.1.3/jquery.min.js","modified":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendor/font-awesome/fonts/fontawesome-webfont.woff2","modified":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.woff","path":"vendor/font-awesome/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendor/font-awesome/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.svg","path":"vendor/font-awesome/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.eot","path":"vendor/font-awesome/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/FontAwesome.otf","path":"vendor/font-awesome/fonts/FontAwesome.otf","modified":1},{"_id":"themes/icarus/source/vendor/font-awesome/css/font-awesome.min.css","path":"vendor/font-awesome/css/font-awesome.min.css","modified":1},{"_id":"themes/icarus/source/vendor/font-awesome/css/font-awesome.css","path":"vendor/font-awesome/css/font-awesome.css","modified":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":1},{"_id":"themes/icarus/source/js/APlayer.min.js","path":"js/APlayer.min.js","modified":1},{"_id":"themes/icarus/source/css/tomorrow.css","path":"css/tomorrow.css","modified":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","path":"css/images/thumb-default-small.png","modified":1},{"_id":"themes/icarus/source/css/images/logo.png","path":"css/images/logo.png","modified":1},{"_id":"themes/icarus/source/css/images/avatar.png","path":"css/images/avatar.png","modified":1}],"Cache":[{"_id":"source/_posts/20160318-color.md","shasum":"4ba75ba58df47c2827d754b7cd1403c2e5a4fe5f","modified":1462959204410},{"_id":"source/_posts/20160319-candy.md","shasum":"f13122a5162f37bd168bbe581916353a80bf96ce","modified":1462959204410},{"_id":"source/_posts/20160319-set.md","shasum":"e7eb9c83dfd79c39fa6ab6288487d7451fd8be9f","modified":1462959204410},{"_id":"source/_posts/20160331-naive.md","shasum":"3ff152e74585ff685591863055fd944851352fd7","modified":1462959204420},{"_id":"source/_posts/20160404-theory.md","shasum":"e65366ddf744b97ea3c4e04212ea7f53221f1abe","modified":1477351973565},{"_id":"source/_posts/20160527-array.md","shasum":"a76262669f5104a91a95a469b2389802a606aaf0","modified":1464365684525},{"_id":"source/_posts/acam-notes/acam.svg","shasum":"2c11a423a255ec9f480dc9fa6e24d8f003b492c9","modified":1474250162206},{"_id":"source/_posts/acam-notes/acam2.svg","shasum":"8cd2e6903dc1aaf1b8011680c03929d538a56328","modified":1474268593745},{"_id":"source/_posts/acam-notes.md","shasum":"bae665206398030d2db67bf7cde7d0c9ed5c63a7","modified":1474269640384},{"_id":"source/_posts/ahoi2008-meet.md","shasum":"e0b091db3a703654300269a5e26b61cc9b345c43","modified":1462959204420},{"_id":"source/_posts/ahoi2013-diff.md","shasum":"7bc65d01071dd6e1b407a23fe06febf89aae7bf0","modified":1475155507464},{"_id":"source/_posts/ahoi2014-story.md","shasum":"30fcca23d94ffd5808db8a76c0670a12de0b1332","modified":1462959204420},{"_id":"source/_posts/apio2009-atm.md","shasum":"4c8b22e60777afe7205ce9a900eb1a02256c28e8","modified":1462959204420},{"_id":"source/_posts/apio2010-commando.md","shasum":"8fa94fab900ebf9c22c4f8323b5ae51a80ba6041","modified":1477351986840},{"_id":"source/_posts/at-the-cross-of-time/mzr.lrc","shasum":"25283ad79892beb5c83c43d981fdd32fbee30466","modified":1472609600778},{"_id":"source/_posts/at-the-cross-of-time.md","shasum":"45ffba5970ed4c74e713773e1024167d15177171","modified":1479656938381},{"_id":"source/_posts/bigint-template.md","shasum":"934fda5bea22b36e0606b10d33bc5df2f37d2487","modified":1462959204420},{"_id":"source/_posts/bsgs-notes.md","shasum":"99537ac64e91e7aeedff9431d60a61d28249a78b","modified":1473486906471},{"_id":"source/_posts/bzoj-1001.md","shasum":"72d9592ee87d155d313e7f628a8cebfae4aea2da","modified":1462959204420},{"_id":"source/_posts/bzoj-1008.md","shasum":"9e33d15285f7e920f9c945333df08bcb7bcc2c21","modified":1462959204420},{"_id":"source/_posts/bzoj-1176.md","shasum":"15b02ad8dd8e0ee24c61c6b0a165b2207065e63c","modified":1466431866375},{"_id":"source/_posts/bzoj-1251.md","shasum":"c08cd8320d570bccf0d3bc1be414e62b28b8a4da","modified":1462959204420},{"_id":"source/_posts/bzoj-1334.md","shasum":"abdb171b4bac613dca99191ef1801a96a998caec","modified":1477351995812},{"_id":"source/_posts/bzoj-1468.md","shasum":"0b82120a77b6175dff7f5aa518b23484188ffa05","modified":1466071797460},{"_id":"source/_posts/bzoj-1477.md","shasum":"c595afe04efabe234f97173104721f64efdbd233","modified":1462959204420},{"_id":"source/_posts/bzoj-1585.md","shasum":"8fbfb910f2698f366ee666295c4d8d6749d22046","modified":1466583292252},{"_id":"source/_posts/bzoj-1597.md","shasum":"90b890eb6f1937eeca51175e70935f65f36ff154","modified":1477352334716},{"_id":"source/_posts/bzoj-1692.md","shasum":"7d031362d6e4cdaaa6bba2b6eb13706db8dc7efb","modified":1475156754344},{"_id":"source/_posts/bzoj-1706.md","shasum":"ab608ab18d6e990d5f08f0969c5102b3c699b970","modified":1475882328043},{"_id":"source/_posts/bzoj-1711.md","shasum":"625edc5f73eabf5673add401b9f8242356034202","modified":1475917486235},{"_id":"source/_posts/bzoj-1756.md","shasum":"60bf2403886143b533d0a969f90c410a8550b425","modified":1462959204420},{"_id":"source/_posts/bzoj-2038.md","shasum":"f2168817f10ce4efdc4e11ddb87533de4e0ba411","modified":1462959204420},{"_id":"source/_posts/bzoj-2127.md","shasum":"5f423860c93ca99cf0134ec7057af3a5caa1cf77","modified":1466583936327},{"_id":"source/_posts/bzoj-2132.md","shasum":"f09e494406452a281f11baad78e64b72692cced6","modified":1466672219417},{"_id":"source/_posts/bzoj-2143.md","shasum":"3fb8100c81c0111db2d10080b9786aa065ae6b10","modified":1465888560611},{"_id":"source/_posts/bzoj-2152.md","shasum":"d123e9e36bf39b483ec5daf21b61b81649bb5640","modified":1466071815564},{"_id":"source/_posts/bzoj-2194.md","shasum":"28422db536e022d9d404eb6714a6ead40b23f7d2","modified":1465651961781},{"_id":"source/_posts/bzoj-2296.md","shasum":"23212b789066f8b9bd854f2cb7b3ddea6585ec9e","modified":1462959204420},{"_id":"source/_posts/bzoj-2438.md","shasum":"a91564720a619f94894f8572d4551a53c46faebd","modified":1466843509077},{"_id":"source/_posts/bzoj-2442.md","shasum":"09e6f50360804dfd5882d273bbb6300f2da95aa0","modified":1477352012360},{"_id":"source/_posts/bzoj-2456.md","shasum":"021110d045d68e07f7e18e35ac8d3940b7836493","modified":1466172511587},{"_id":"source/_posts/bzoj-2462.md","shasum":"1732c3114d698e1c3d622c6b1a3d172100e0812c","modified":1473810063694},{"_id":"source/_posts/bzoj-2580.md","shasum":"a73e63accb968c9992ae4c7e289994fcdbd507d5","modified":1474154745766},{"_id":"source/_posts/bzoj-2683/cdq.png","shasum":"a95d0b02b915f092df6656298add0f0fc9662341","modified":1462955792540},{"_id":"source/_posts/bzoj-2683.md","shasum":"926ec2d1b7000c24c1edd22d197180164cac76a8","modified":1466431930441},{"_id":"source/_posts/bzoj-2716.md","shasum":"fe2aec385e2971d42f1097e916fe964445aa424d","modified":1466824130905},{"_id":"source/_posts/bzoj-2820.md","shasum":"b893e9bbcea214b41bef4c502d833a930d123fdb","modified":1462959204420},{"_id":"source/_posts/bzoj-3156.md","shasum":"476a683d45bb01c6c6cca9af75e5f0c6f6c74734","modified":1477352022972},{"_id":"source/_posts/bzoj-3196.md","shasum":"2b72c0385e2a3174173ca2e75ca6d606c6696bf8","modified":1466300243903},{"_id":"source/_posts/bzoj-3230.md","shasum":"5882c46621fd0d914caa25ee49de7f163964c7b9","modified":1475191571909},{"_id":"source/_posts/bzoj-3262.md","shasum":"ad61bcd01d1a0afdc44e0e038123ff32c86a2e76","modified":1466341000696},{"_id":"source/_posts/bzoj-3275.md","shasum":"a14dc375463cfb3df8cc97d3adf5b78c7ca85456","modified":1464016159116},{"_id":"source/_posts/bzoj-3277.md","shasum":"07b57370422ef563976726932df98adac3478691","modified":1475192434037},{"_id":"source/_posts/bzoj-3280.md","shasum":"f379b4a1212f7781164d71625d49ad3124d1b523","modified":1473508473657},{"_id":"source/_posts/bzoj-3365.md","shasum":"3bfab6ccaa5e2dfd1fa3a6a4d65d68fb96a5b22a","modified":1466071781441},{"_id":"source/_posts/bzoj-3438.md","shasum":"7fa24e4ae32a471e08cf89604521923861bd42e8","modified":1466493507214},{"_id":"source/_posts/bzoj-3511.md","shasum":"a69c5a7b074d933e3eb29d1b2c8a24645520728d","modified":1462959204420},{"_id":"source/_posts/bzoj-3697.md","shasum":"3560e2748c810aec86cc770aab1371f8f33698a6","modified":1474808740919},{"_id":"source/_posts/bzoj-3796.md","shasum":"d964d550ff1177bfbb1d19991f600624ab25824c","modified":1475192923083},{"_id":"source/_posts/bzoj-3894.md","shasum":"9cf338b78641a5cc1eb027d84506a587d7c9267d","modified":1466583943359},{"_id":"source/_posts/bzoj-3940.md","shasum":"34e3c58a8bed87be2046f4b4da66f095f3353edd","modified":1473810460840},{"_id":"source/_posts/bzoj-4145.md","shasum":"1383833b1739216df566d16f25ab76e377e728a8","modified":1477352032208},{"_id":"source/_posts/bzoj-4247.md","shasum":"ecb5c5706b743d62fd19c3bcc03f4638b94e2be3","modified":1477352045720},{"_id":"source/_posts/bzoj-4318.md","shasum":"0004fbf6e758b707f24a98c3929912894626bdd0","modified":1464696387692},{"_id":"source/_posts/bzoj-4403.md","shasum":"0e503e9c28ace534c15b2b47576add9bd4027af5","modified":1462959204420},{"_id":"source/_posts/ceoi2004-two.md","shasum":"99ab98de7fb06f9fdfca038c023d4ff8f74f8755","modified":1477352054116},{"_id":"source/_posts/ceoi2008-order.md","shasum":"96b1a7c05854b6da645d341d870b6c958cac73a5","modified":1466582878396},{"_id":"source/_posts/cf-628d.md","shasum":"5bd19c9ec8ea646e78edcf23d15218c6060e1b47","modified":1477352319769},{"_id":"source/_posts/cf-716e/example.svg","shasum":"a1d6731f2ef7e43ae48e27345954c6cb24a216b0","modified":1474439170788},{"_id":"source/_posts/cf-716e.md","shasum":"34ad51b65867dd4a0c99349b191738070148aeb2","modified":1474440272852},{"_id":"source/_posts/chairman-tree-notes.md","shasum":"8be4f4b6d283778a78c6dc87d141029f34f57d51","modified":1462972004900},{"_id":"source/_posts/coci2015-divljak.md","shasum":"75aee7f3216c123eb41de62a2a657cf6fb2a9601","modified":1474239668919},{"_id":"source/_posts/codevs-1345.md","shasum":"58546572e0bb94b562f55fdbf6649287a3107656","modified":1477352064784},{"_id":"source/_posts/codevs-1563.md","shasum":"90f4dda98f3aed528734d91eaa918ea58ad5d67d","modified":1466518742060},{"_id":"source/_posts/codevs-2598.md","shasum":"9f5c7bea72bdd82e3f05c5e6284e8dd8e0aed8e8","modified":1477352072459},{"_id":"source/_posts/codevs-2822.md","shasum":"a5f2981e80882ae575f7c28d9552bddbe717915a","modified":1462959204420},{"_id":"source/_posts/codevs-3168-3162.md","shasum":"aafdf6bc35f4dcda18d9f89de0ae2ecb8c75c2c4","modified":1477352102283},{"_id":"source/_posts/codevs-3269-monotone-queue.md","shasum":"b445e3b6240f19aae1b165e94fb3e2fa17162499","modified":1477352123283},{"_id":"source/_posts/codevs-3269.md","shasum":"b276f70ecd368aa72d5c1a48b680f475818b0d47","modified":1477352115991},{"_id":"source/_posts/cogs-14.md","shasum":"df074c69b9f8cacedba8ccea146ac644e8201397","modified":1462959204420},{"_id":"source/_posts/cogs-396.md","shasum":"fbfd2fc22b9c83aa16792fa61d51d702b53461f7","modified":1462959204430},{"_id":"source/_posts/cogs-439.md","shasum":"2426244914406bd35b753d445bb5fcd3e01a5c30","modified":1462959204430},{"_id":"source/_posts/cogs-727.md","shasum":"d3f3d51ba288685a52479e3847f4e84885fcdb3e","modified":1462959204430},{"_id":"source/_posts/cogs-728.md","shasum":"c7fa068adf3bf1f5f5b4add16374b265ef21ca11","modified":1462959204430},{"_id":"source/_posts/cogs-729.md","shasum":"bb45c57f781ff5c8eb0e87b3edadf7b206b81c01","modified":1462959204430},{"_id":"source/_posts/cogs-731.md","shasum":"f16c01e7c3da8aa233df4daee546f3024726d239","modified":1477352304985},{"_id":"source/_posts/cogs-740.md","shasum":"e90060c6feb6273cd400258627f141214574dd8f","modified":1462959204430},{"_id":"source/_posts/cogs-734.md","shasum":"4a748f8ae51d4d1990b89ac8081e53d74fbc183c","modified":1462959204430},{"_id":"source/_posts/cogs-741.md","shasum":"91a8b62bd42e7be33d94ae1a9624d5a0d7c2c9a3","modified":1462959204430},{"_id":"source/_posts/cogs-742.md","shasum":"dc5b03c9e8b857ea345e0f906692847cc7c2508b","modified":1462959204430},{"_id":"source/_posts/cogs-746.md","shasum":"aa46c716f60453fdbbfa4ff4ccdca515e90e25ae","modified":1462959204430},{"_id":"source/_posts/combinatorics-notes.md","shasum":"f3e5e1bf1d06c126032426103df6f1990368ad07","modified":1462959204430},{"_id":"source/_posts/cqoi2011-inverse.md","shasum":"5e6e7e3d0c82e5814f994d8468de30766070c55b","modified":1466431853556},{"_id":"source/_posts/cqoi2016-cuts.md","shasum":"96b727a740bc374fefd4b8ca7d1c09b5f20648c4","modified":1462959204430},{"_id":"source/_posts/cqoi2016-number.md","shasum":"bae7a7e7008769b1bd14b496961ce95efd9f76c7","modified":1477352136359},{"_id":"source/_posts/ctsc1997-course.md","shasum":"48f7051612c8843ce79049b59c0fb88b0fbf557c","modified":1477352275933},{"_id":"source/_posts/ctsc-apio-2016.md","shasum":"b8a08df409b774cf281797e8a8dc95e01de5624a","modified":1479656971201},{"_id":"source/_posts/ctsc1999-home.md","shasum":"978baaae9dd654467febabfa562eea00beb02859","modified":1462959204430},{"_id":"source/_posts/cut-tree-notes.md","shasum":"e16fa699ed487724d2d7aa58d90088af35c1770a","modified":1462959204430},{"_id":"source/_posts/derangement-number.md","shasum":"1d85fe52fcf017157eeffc96e660b029b83cb31f","modified":1462959204430},{"_id":"source/_posts/cut-tree-notes/cutTree.png","shasum":"12de28c1f402f876a3826dcd7bfc8525d555ce1e","modified":1462955792540},{"_id":"source/_posts/dinic-notes.md","shasum":"0378294542c3e68fff50acce4071552b870f0468","modified":1462959204430},{"_id":"source/_posts/edmonds-karp-notes.md","shasum":"6c145828e387d262d0b9fd5cb1c529201815e265","modified":1462959204440},{"_id":"source/_posts/euler-sieve.md","shasum":"bdd661e2b3f1d99f802c6179a97c7c31dd4f883d","modified":1462959204440},{"_id":"source/_posts/fft-to-ntt.md","shasum":"1876bb4ba0acf94f95333a06dfdaa8eae3f51cd8","modified":1466170692116},{"_id":"source/_posts/fjoi2007-wheel.md","shasum":"62ed81583cf9b21d3798a0f89b3e4d4fe56ac776","modified":1476696387229},{"_id":"source/_posts/fft-notes.md","shasum":"c7bda397ed473f1427f762d4cbef0da1fa82fca8","modified":1466170775965},{"_id":"source/_posts/haoi2006-cow.md","shasum":"de4e6dcca3e29acdc131063a61ca1f8fd1ee3be1","modified":1462959204440},{"_id":"source/_posts/gnu-debugger.md","shasum":"a39a3556d1965b8fc4ce3404e23c4aa5587ceca1","modified":1462959204440},{"_id":"source/_posts/haoi2008-candy.md","shasum":"e408ba8c0c27c36c3fa2606474560055131c2412","modified":1479021877454},{"_id":"source/_posts/haoi2008-cir.md","shasum":"268b031e4e51141293fed8dc35b778c0e9d6c01f","modified":1479005811312},{"_id":"source/_posts/haoi2008-coins.md","shasum":"b2a5b3bebb8b9bd49ac5e76691ae32acd10e19bd","modified":1479006702698},{"_id":"source/_posts/haoi2008-name.md","shasum":"55056d53974b62ac7ba9c4daa55fb46bf2d7b125","modified":1477352144055},{"_id":"source/_posts/haoi2008-stick.md","shasum":"76f7a22c09f8394f2aff8a2f54bd36ce570a048c","modified":1479007911164},{"_id":"source/_posts/haoi2007-lis.md","shasum":"d559fad8378784179e8605eec1b0c70c6f75e34c","modified":1480580725224},{"_id":"source/_posts/haoi2011-problemb.md","shasum":"80f9d8191d53d49067ee4e5c654cdc60a8a53384","modified":1462959204440},{"_id":"source/_posts/haoi2015-t2.md","shasum":"b46b9260d7c4fd96c6f56b7faf8eb10a7507fc55","modified":1473500685141},{"_id":"source/_posts/haoi2016-chain.md","shasum":"b722f46a179a7fd0fd2293235b225a75c3343ef2","modified":1462959204440},{"_id":"source/_posts/hdu-2089.md","shasum":"52c4b8de67b50c5f4addd2d422c958164ed2e5fd","modified":1477352153582},{"_id":"source/_posts/hdu-5642.md","shasum":"65de14e383af7e37e49ab3a7c18f8acacab2f00e","modified":1477352172278},{"_id":"source/_posts/hdu-5632.md","shasum":"e8b90a7fda59235e4c0a7de7416e0f6bd2c2eaa9","modified":1477352162698},{"_id":"source/_posts/heoi2013-bag.md","shasum":"3d3544eca469964d0c67c98cc605e76bd654a445","modified":1477352200514},{"_id":"source/_posts/hnoi2004-language.md","shasum":"7c4a81764969730a17d818d80444428dc84d8179","modified":1473723911171},{"_id":"source/_posts/hdu-5906.md","shasum":"de080c085c1e5d051fc64319167bb951836391dc","modified":1475229652455},{"_id":"source/_posts/hnoi2004-pet.md","shasum":"b2bda3d66ff145436b7eab827120e72edbae6c57","modified":1462959204440},{"_id":"source/_posts/hnoi2008-cards.md","shasum":"a99c6c4f9bbf046575f4cf52eae0fdb272c1cc59","modified":1476673417128},{"_id":"source/_posts/hnoi2008-gt.md","shasum":"51d30d56860cf265cf1a21586d14ed5b7371d2e1","modified":1475880765853},{"_id":"source/_posts/hnoi2008-toy.md","shasum":"26405e1e114faeb135c6a647611853b9a3e34811","modified":1477352187662},{"_id":"source/_posts/hnoi2008-kingdom.md","shasum":"630ff7a9fe9730a54e7fb2af393bb3975bc30b87","modified":1476696323487},{"_id":"source/_posts/hnoi2010-chorus.md","shasum":"ef16ed9ed60a26fb7296c92f5456aff90b98849d","modified":1477352209310},{"_id":"source/_posts/hnoi2008-tree.md","shasum":"ba8997bd556bb160cc33b8978d55000e45c34b6e","modified":1476673607260},{"_id":"source/_posts/hnoi2012-mine.md","shasum":"cce8a25d8ba4f48806c8b10b6ea947912bb72964","modified":1473292401367},{"_id":"source/_posts/hnoi2016-multiple.md","shasum":"5f8819ca3130cd4e04f7c49a5ff3c52b50fe67a9","modified":1462959204440},{"_id":"source/_posts/hnoi2016-network.md","shasum":"701e1dfb9e177e0b4857e359cc2b2e32392fd4cd","modified":1462959589490},{"_id":"source/_posts/hnoi2016-sequence.md","shasum":"584e140ef6c2aefe78304fcedce69218d3c90d55","modified":1462959204440},{"_id":"source/_posts/hnoi2016-tree.md","shasum":"d8e0634d20447cf11e6a3dc092629df943442b65","modified":1473486695350},{"_id":"source/_posts/ioi2008-island.md","shasum":"c556010ee83873a588f35bf672275d3f03fd55de","modified":1477402349876},{"_id":"source/_posts/ioi2011-race.md","shasum":"e656c8dc53b1d87d99f3d3e9ef8425949a54dde0","modified":1466078515927},{"_id":"source/_posts/jsoi2007-cipher.md","shasum":"72d59d69cd1774e5ff8550950b7787d1c5245fae","modified":1475154361131},{"_id":"source/_posts/jsoi2007-mahjong.md","shasum":"7168f1c1c3915f6bdfbe63ab8fb1ad6eacd8e872","modified":1478997155260},{"_id":"source/_posts/jsoi2007-generator.md","shasum":"389a27109369808043d691bfce41bc3fa3b5b754","modified":1473636489303},{"_id":"source/_posts/jsoi2008-award.md","shasum":"8ac08f0cbca053ae3a9af3c3f8c7a333149e1ef9","modified":1476798062436},{"_id":"source/_posts/jsoi2007-repair.md","shasum":"b471ddac6cf3614bf4c70f7422bdc0c88a77fb79","modified":1479000357614},{"_id":"source/_posts/jsoi2008-dotr.md","shasum":"b0d21a9fcaf6e34cd3a1d55b6f4db4914e7165f7","modified":1477352221646},{"_id":"source/_posts/jsoi2008-maxnumber.md","shasum":"973b88d1287688eef3d8f99363a1db35399213db","modified":1462959204440},{"_id":"source/_posts/jsoi2008-starwar.md","shasum":"44f26d7aea8467915a733921932eb627c32c8657","modified":1476796800814},{"_id":"source/_posts/jsoi2008-prefix.md","shasum":"9d1e1e5bfc935b12dd2477dc09b31eeeda7651b8","modified":1476796235311},{"_id":"source/_posts/jsoi2009-game.md","shasum":"7e3bcdfbc619bd881e671216285cd1649f62b87a","modified":1462959204440},{"_id":"source/_posts/jsoi2009-game2.md","shasum":"982f4ff3511ef0b4262c197d007eafe92667d97e","modified":1474191031290},{"_id":"source/_posts/jsoi2016-light.md","shasum":"58533f261da20e6409234f6aee1ea40049a1f35f","modified":1462959204440},{"_id":"source/_posts/jsoi2016-flight.md","shasum":"9f52be4f9cddedb2ab7e6737ce2f387faa9147e6","modified":1462959238400},{"_id":"source/_posts/kmp-notes.md","shasum":"716f23d1fb6ac763134dfd9a570a9ce7cc88f3f5","modified":1462959204440},{"_id":"source/_posts/lyoi-pingfan/pfzl.lrc","shasum":"cd9495fcc11a3797b90d5b6e34676f412fa64709","modified":1479632878240},{"_id":"source/_posts/link-cut-tree-notes.md","shasum":"d0dd589310e783f3cc72f2d4a558396dde355f78","modified":1462959204440},{"_id":"source/_posts/lyoi-pingfan.md","shasum":"93016cc4298799f4e355b1b3e19ce77d94dc86d4","modified":1479656921098},{"_id":"source/_posts/markdown-latex-helper.md","shasum":"9646c40f411c104088af99b554ea34af8fb61e3d","modified":1462959204440},{"_id":"source/_posts/mo-algorithm-notes.md","shasum":"04963d986f2cbd596dfc9d92c1efdbb209e3afb7","modified":1462959204440},{"_id":"source/_posts/monotone-queue-notes.md","shasum":"fc7a11f33c6b9f425dde2c3b3c901e7018aca151","modified":1462959204440},{"_id":"source/_posts/minimum-spanning-tree-notes.md","shasum":"5e376a19420ba0d04fbfc86ffb85254f8f33b464","modified":1462959204440},{"_id":"source/_posts/mul-inverse.md","shasum":"88b06571986b29765bc702445e03c7db387ed3b1","modified":1462959204450},{"_id":"source/_posts/node-devide-notes/tree1.svg","shasum":"95a6f3d6aecac664917f8dad2ff4c4c655011efe","modified":1466132686090},{"_id":"source/_posts/node-devide-notes/tree2.svg","shasum":"d61370507100e7cdfab1181f3955a0b7b1183e5e","modified":1466152112424},{"_id":"source/_posts/noi2002-galaxy.md","shasum":"0b62ae091bdecd684968bd8eb0707890d71eeac1","modified":1462959204450},{"_id":"source/_posts/node-devide-notes.md","shasum":"125c398ee1be3445dbbc96b8e724e9ac97c3b9d9","modified":1466152641034},{"_id":"source/_posts/noi2003-editor.md","shasum":"6d6ccf7f089180de540cb75879f4589b5c1e8ee4","modified":1462959204450},{"_id":"source/_posts/noi2006-profit.md","shasum":"cdf389673d9a8babd630e8c5bc247670b695bff4","modified":1462959204450},{"_id":"source/_posts/noi2004-cashier.md","shasum":"0504fdf9c3754c9f1fa1b1be8befc3dcf0852794","modified":1462959204450},{"_id":"source/_posts/noi2012-random.md","shasum":"b0e78167c2a4168496fe6b70a1dc8d3b45962352","modified":1475883407010},{"_id":"source/_posts/noi2011-type.md","shasum":"f84650491029914e9de402d6433b478d1caa32f0","modified":1473638033794},{"_id":"source/_posts/noi2014-sleep.md","shasum":"32c222899af7ba614509f0b5cb66bc0867154960","modified":1462959204450},{"_id":"source/_posts/noi2014-forest.md","shasum":"692c2d383b68f8c65f1a2b45c37cb788e7f76f47","modified":1468252483005},{"_id":"source/_posts/noi2014-zoo.md","shasum":"48d488c5c348640989a59b2c84c2a60d8273ce10","modified":1468251707623},{"_id":"source/_posts/noi2015-epic.md","shasum":"d9f2c20735718a4f922f1b7f0bf394fcbeb992a8","modified":1467336511308},{"_id":"source/_posts/noi2015-dinner.md","shasum":"afbaf06fc29fcc73760e96692f67d386e51f7ffe","modified":1477352235002},{"_id":"source/_posts/noi2015-manager.md","shasum":"b718da5118bf865669f6505c4ac9acdba8339316","modified":1462959204450},{"_id":"source/_posts/noi2015-prog.md","shasum":"1f738de912a1b38d8bfc2d497e1b9c54236a13a4","modified":1478606807659},{"_id":"source/_posts/noi2015-farm.md","shasum":"419b248d8bb0e510213977f23d5ef46b98526c8c","modified":1478001561067},{"_id":"source/_posts/noi2016-excellent.md","shasum":"8d8033bffd7cc40a8a474d5914ff17c626524fc7","modified":1473118923830},{"_id":"source/_posts/noi2015-savour.md","shasum":"05ae6befa30e37183474e5a856a8fd2b95741b93","modified":1467336519440},{"_id":"source/_posts/noi2016-interval.md","shasum":"5e22b8b0f979a24af64e88dcc5ebbf8a75bddf16","modified":1473118751830},{"_id":"source/_posts/noip2000-cheng-ji-zui-da.md","shasum":"f98039cfa065e1662575945a0b1a582ec2ad2689","modified":1477351910525},{"_id":"source/_posts/noi2016-grid.md","shasum":"f86421c87bea57c995b00231fffadfd4fd54cecb","modified":1473638069201},{"_id":"source/_posts/noip2003-game.md","shasum":"6f382752e06de918287ed053ba5cc20db51b633a","modified":1477351904205},{"_id":"source/_posts/noip2006-budget.md","shasum":"b350f36da264bb5fd90a5fee23019284efa9918c","modified":1477351822210},{"_id":"source/_posts/noip2006-energy.md","shasum":"2a1c5d16824f3e06c23b5f7cd692b187863a66bd","modified":1477351922329},{"_id":"source/_posts/noip2010-flow.md","shasum":"7133e4ca1632ebbafbebee02cc749908e81af1f6","modified":1479029018684},{"_id":"source/_posts/noip2010-prison.md","shasum":"1c89f4fba3f01bec85a06ce8e5309a7e6d50f733","modified":1462959204450},{"_id":"source/_posts/noip2012-blockade.md","shasum":"dcbb2b7c28da18c0a662a6fd251f8d893461d8a4","modified":1479030258333},{"_id":"source/_posts/noip2012-classrooms.md","shasum":"3ec63cd7cf2caa054464e41e0e8428d52c234021","modified":1475917451595},{"_id":"source/_posts/noip2012-mod.md","shasum":"0fb6c0ef73a261e10a1b23b235c0492a247c1362","modified":1462959204450},{"_id":"source/_posts/noip2012-drive.md","shasum":"e7df25f732858eea47e4ebbb206e9cc30ab5d277","modified":1479028462387},{"_id":"source/_posts/noip2013-flower.md","shasum":"eac451fe25287a373570518cfab3666459c602ac","modified":1479026565336},{"_id":"source/_posts/noip2013-match.md","shasum":"a3b515c40a4d08f8abef8c1b26e0923df31b8d56","modified":1479024938455},{"_id":"source/_posts/noip2013-puzzle.md","shasum":"15b7b800cabdda94234aff34e9591e22974a4383","modified":1479033358177},{"_id":"source/_posts/noip2014-bird.md","shasum":"76874bf8cf59797f6fd23a6c0dcfa3fc25d228c3","modified":1478606832691},{"_id":"source/_posts/noip2014-equation.md","shasum":"32741b3c9a8437f91b273e1ea4979fe4e6937319","modified":1476865586067},{"_id":"source/_posts/noip2015-substring.md","shasum":"8132adb345d5966190126eb464240285ca345188","modified":1478069428453},{"_id":"source/_posts/noip2015-landlords.md","shasum":"383d0be32afdf22cbb8c522fea4ae2fcde6b7676","modified":1476865979622},{"_id":"source/_posts/noip2015-transport.md","shasum":"65287e79098fc97ed2f63ad521889c0e5cb853a5","modified":1476882449463},{"_id":"source/_posts/noip2016-angrybirds.md","shasum":"d4b424e95af568e449f201378bcccca21ffc3973","modified":1480425733905},{"_id":"source/_posts/noip2016-classroom.md","shasum":"a4730715dec75b04f15ebf35c7fc3e7c803c1a81","modified":1480404993407},{"_id":"source/_posts/noip2016-problem.md","shasum":"3f2bfceef09b7568444107ae65ed6222db1f5f29","modified":1480425142493},{"_id":"source/_posts/noip2016-earthworm.md","shasum":"1b2fcb76d67ccbceab9b7a4fccbdd8d36e25f77c","modified":1480425082980},{"_id":"source/_posts/noip2016-running/linear-forward1.svg","shasum":"21d1e9f4c290ba36e95ca3d1a3f03108f7e7d08c","modified":1480401570576},{"_id":"source/_posts/noip2016-running/linear-backward1.svg","shasum":"f11ad00d6b6d9c4a9dbcdd756a54ac9f98aae87c","modified":1480402071309},{"_id":"source/_posts/noip2016-running.md","shasum":"4314316adc4ca81526daf243a8365e04f7224136","modified":1480404979183},{"_id":"source/_posts/noip2016-toy.md","shasum":"5b73c18d444e50a23f5352203f26632af2830c2c","modified":1480404968883},{"_id":"source/_posts/noip2016.md","shasum":"a9273f495144f13620fd53d5e847c9f596becd2d","modified":1479656914658},{"_id":"source/_posts/non-recursion-dfs-with-stack.md","shasum":"77777eea132ddbbc8f0201f6438267a80a414656","modified":1462959204450},{"_id":"source/_posts/noip2016-running/linear-forward2.svg","shasum":"d828849ead2a7f7a3ac34250ec3e468dd053fe4c","modified":1480401597915},{"_id":"source/_posts/npm-debug.log","shasum":"881c868bf599dd4f4753f8b868bec0bb7a2a6f51","modified":1466824292761},{"_id":"source/_posts/poi2000-wir.md","shasum":"c7d42107d0fdf656828fda727b7c0207494f9dd3","modified":1473724314323},{"_id":"source/_posts/number-theory-notes-1.md","shasum":"06a1c30f28a21e76f65bc5afc0d9766231d8af32","modified":1462959204450},{"_id":"source/_posts/poi2005-kos.md","shasum":"7d2d41ca023967051b7c5e8262484cff78a75009","modified":1466591154146},{"_id":"source/_posts/poi2006-szk.md","shasum":"6eb519b750b4996e46308708f4676ef24bf623d3","modified":1466590859112},{"_id":"source/_posts/poi2008-blo.md","shasum":"60d3bdf871aedf1869912848eea175276493eff6","modified":1473332288939},{"_id":"source/_posts/poj-1737.md","shasum":"09c4fec6b5a83f1b9b7b8161b0aab0ac1b24cbc3","modified":1462959204450},{"_id":"source/_posts/poj-2728.md","shasum":"732694ea57c6eef6f36cb28708d0072913ef8f1e","modified":1462959204450},{"_id":"source/_posts/poj-3461.md","shasum":"226bd4eac18f3439dc754c946c995894cb74d640","modified":1462959204450},{"_id":"source/_posts/scoi2003-fold.md","shasum":"3aa6ac1189749d23245e8d9aa80da44c17eecd51","modified":1477351878502},{"_id":"source/_posts/scoi2007-lizard.md","shasum":"bbe131ab41e3ad9d89f12e81969a7c251c3d358e","modified":1472910683260},{"_id":"source/_posts/scoi2007-repair.md","shasum":"e5cd2d95c22fd64d8f4362732d747292a4e17240","modified":1462959204450},{"_id":"source/_posts/scoi2009-cake.md","shasum":"8573193bdcfc4f2a85224fd1791b00d1b91af94e","modified":1478956661779},{"_id":"source/_posts/scoi2009-game.md","shasum":"dd4f8b3206e56636eb53b7507b3b7c8ba0994438","modified":1478998078148},{"_id":"source/_posts/scoi2009-paint.md","shasum":"6650628febe53de448522a2028b19752256ee9bb","modified":1477351841406},{"_id":"source/_posts/scoi2009-windy.md","shasum":"227dc0a7195a3a327f2e3f5788dee664da2a3d83","modified":1477351833902},{"_id":"source/_posts/scoi2010-game.md","shasum":"81be4ae0bb7c1120e220a5177bea4877d19780f3","modified":1462959204450},{"_id":"source/_posts/scoi2012-name.md","shasum":"56ed15710897916cb0855611a326acf53bc7bb96","modified":1475155718840},{"_id":"source/_posts/scoi2011-candy.md","shasum":"3037949e9f52b0faac3b2ca5b4d7f40e64147dad","modified":1462959204450},{"_id":"source/_posts/scoi2015-flag.md","shasum":"d2273c0aa7434ce104123d934eed5ebc76ce7874","modified":1462959204450},{"_id":"source/_posts/scoi2015-light.md","shasum":"6f50e8af86425d00844a560e71538656754f9f6f","modified":1477351887454},{"_id":"source/_posts/scoi2015-matrix.md","shasum":"81f28e7cad4caf2a53201684e2eebc1961e7e42e","modified":1462959204450},{"_id":"source/_posts/scoi2015-message.md","shasum":"eaba94296389b994b29a45744ad81674723c1e31","modified":1462959204450},{"_id":"source/_posts/sdoi2008-cave.md","shasum":"0665e52de3f255cafac2bdc5b5c8f9ee23deee5c","modified":1462959204450},{"_id":"source/_posts/scoi2015-password.md","shasum":"ba24fd5191837df620e52e49246f6481006b0610","modified":1462959204450},{"_id":"source/_posts/sdoi2009-run.md","shasum":"239f7f7943172b90055db3a73dc898ba4a248a13","modified":1466511891867},{"_id":"source/_posts/sdoi2008-interval.md","shasum":"6d7c73c685e299bcefb7bb93dd4efa340d1ac0c6","modified":1472823498227},{"_id":"source/_posts/sdoi2010-goblin.md","shasum":"88700569b1ba9e8abf8a695bd17b762252927cb3","modified":1466409035404},{"_id":"source/_posts/sdoi2010-starrace.md","shasum":"7cdfa2fbc6b5703175d491f81869e84382baf68c","modified":1462959204450},{"_id":"source/_posts/sdoi2011-calc.md","shasum":"8bc38c373e311a2ca92f3f7ce36654a436d31f21","modified":1465790863358},{"_id":"source/_posts/sdoi2013-rforest.md","shasum":"a16ac45bc3f7d66afd0d348d8c30f9c4776906e5","modified":1476869061064},{"_id":"source/_posts/sdoi2014-journey.md","shasum":"2e11f80c5309333604309cd252acb87bcb39b70e","modified":1472823755641},{"_id":"source/_posts/sdoi2015-sequence.md","shasum":"2fe794b7d355bc493c80053ec8841812042c7acf","modified":1466170749686},{"_id":"source/_posts/sdoi2016-game.md","shasum":"f4688c431daa3a3b77b8ac3ec53c43f27ffb63de","modified":1462959204460},{"_id":"source/_posts/sdoi2016-game/line.png","shasum":"30c24e553938d2c27b55779527825b2577088a7c","modified":1462955792590},{"_id":"source/_posts/sdoi2016-incantation.md","shasum":"1152f86db800b686d790898d6b9193c7d8712bbe","modified":1462959204460},{"_id":"source/_posts/sdoi2016-journey.md","shasum":"9a67291ff2e3d19a6acb34043bd649423974380f","modified":1477351780335},{"_id":"source/_posts/sdoi2016-pair.md","shasum":"9a707c8f327534044dac4b013a285184edd7d349","modified":1462959204460},{"_id":"source/_posts/sdoi2016-permutation.md","shasum":"ac94de60fa9ed03ece26c466ef20698e935d6752","modified":1462959204460},{"_id":"source/_posts/sdoi2016-round1.md","shasum":"7e92ad517aff81a72afd6c6b393a7248ca7243d0","modified":1479656964533},{"_id":"source/_posts/shoi2007-tree.md","shasum":"408976b299bfef93fe74cfd816dc427929e313c2","modified":1466824073211},{"_id":"source/_posts/shoi2007-vote.md","shasum":"600f0630bbe939bdf9bbc2c5c7809382a204b070","modified":1466492665384},{"_id":"source/_posts/sdoi2016-table.md","shasum":"4069652db069ab71e8a3b733a02022472201dad6","modified":1473486856729},{"_id":"source/_posts/shoi2008-cactus.md","shasum":"865ec5c6af46e9aa3d97d2a0cf1871b06e2e5c85","modified":1477440165110},{"_id":"source/_posts/shoi2008-debt.md","shasum":"a270d590220f6e71746789e95b9d3acd767c82fe","modified":1476862555225},{"_id":"source/_posts/sdoi2015-war.md","shasum":"4a6a234666ff45ea7c5069e6630519b646dac882","modified":1462959204460},{"_id":"source/_posts/shoi2008-john.md","shasum":"49c7e0d140440d5228ceb897df0f2069fd83c12d","modified":1476863627059},{"_id":"source/_posts/shoi2008-traffic.md","shasum":"93cb98cb139e4fb449aa59256b5f6fee89ac2783","modified":1476858627266},{"_id":"source/_posts/splay-notes-2.md","shasum":"b7c1615a96dfff66ea8c6337d06c966a9223f69e","modified":1462959204460},{"_id":"source/_posts/splay-notes-3.md","shasum":"77f025b32786a71ce628095d27642fbe230e764a","modified":1462959204460},{"_id":"source/_posts/spoj-694.md","shasum":"4c02dff2a042a9c83e811f5f8536a361d53d798e","modified":1462959204460},{"_id":"source/_posts/stl-in-oi.md","shasum":"34b0cdda3523f9d31ebf2e404ddd59f27d146eaf","modified":1468498796795},{"_id":"source/_posts/suffix-array-notes.md","shasum":"a14a772250ef5d85308f76c1d08deb2199a705a1","modified":1462959204460},{"_id":"source/_posts/cogs-738.md","shasum":"01a88085f9e1823b8fc63e04a617b85fc1551ade","modified":1462959204430},{"_id":"source/_posts/cogs-739.md","shasum":"4eb4f215432d85cc7bd93a357ee70d326f314504","modified":1462959204430},{"_id":"source/_posts/system-of-difference-constraints-notes.md","shasum":"cda796649d3175c93146609b99ba4e753d04c995","modified":1462959204460},{"_id":"source/_posts/tarjan-cut-notes.md","shasum":"e29b5e3ff43629bd523c35001f4b004b19d6d5cb","modified":1473337034223},{"_id":"source/_posts/tarjan-scc-notes.md","shasum":"78f4744865c553f80815c07f1de3e94270e45733","modified":1462959204460},{"_id":"source/_posts/tjoi2013-lis.md","shasum":"85be6ae0b508baeb46540ffdd5ca250a522254ef","modified":1475883934938},{"_id":"source/_posts/tjoi2013-word.md","shasum":"03f1e85afbb5ba3e61596010715915b24de43fc8","modified":1475883942222},{"_id":"source/_posts/tjoi2015-chessboard.md","shasum":"4755bd1f5c721d893b8e31e3c8ce619ae45ea26f","modified":1477351756791},{"_id":"source/_posts/tyvj-3317.md","shasum":"229a79bbeb50f8efbcf84fea34aec24e3b27dccc","modified":1477351673532},{"_id":"source/_posts/uva-10253.md","shasum":"af4062ce79c9b4f080fe3c35d3be71ef13d0b36d","modified":1462959204460},{"_id":"source/_posts/uva-11021.md","shasum":"5c1c140b3d2a9dc0fa068195ae0ff3a51aaf3e4d","modified":1477351734763},{"_id":"source/_posts/uva-11137.md","shasum":"ab64769680e30fc5456f896dcd7413b5ec7474a2","modified":1477351709280},{"_id":"source/_posts/uva-11174.md","shasum":"343cb90133d9be62c263c27db889c0bf2945b918","modified":1462959204460},{"_id":"source/_posts/uva-11361.md","shasum":"4c2e014fa4d70f2eb75c75e8139fad18fe3c63d5","modified":1477351724619},{"_id":"source/_posts/uva-11375.md","shasum":"3ca8e6535aab2844777ae95ec8b8e10b2864f8f4","modified":1462959204460},{"_id":"source/_posts/uva-11538/cells.png","shasum":"3a162829c312a17639950c3620cd70799ed94a49","modified":1462955792600},{"_id":"source/_posts/uva-11538.md","shasum":"030938457fbe7ab2d5aec2148b7c03acfdf9513b","modified":1462959204460},{"_id":"source/_posts/uva-11806.md","shasum":"e7fe9a9f6f7bb8d32286243d4238f189b9d70734","modified":1462959204470},{"_id":"source/_posts/uva-1362.md","shasum":"6ed0875d87e133e428f77a35f3f4f075b29d3e37","modified":1477351694088},{"_id":"source/_posts/splay-notes-1.md","shasum":"74b118e9cca1b32c32298fcabf90192aa194e1a8","modified":1462959204460},{"_id":"source/_posts/virtualbox-archlinux.md","shasum":"920b51fe7f50d524a368c55db06a84cba0f3df1e","modified":1462959204470},{"_id":"source/_posts/zjoi2004-swamp.md","shasum":"6a255e50f4f5448b3a92fe288954862926e5aa99","modified":1475881729487},{"_id":"source/_posts/zjoi2006-trans.md","shasum":"725146000e1f996a32a1e672e19cb60fc8d7c05f","modified":1464010935316},{"_id":"source/_posts/zjoi2007-semi.md","shasum":"34804692730f5a3da0032440deb294157e8f37e9","modified":1472946674898},{"_id":"source/_posts/zjoi2007-storage.md","shasum":"67989e9cadbec2172cf844d64d62fd421a57370e","modified":1477351684936},{"_id":"source/_posts/zjoi2008-antbuster.md","shasum":"31c4b1b566f5c4319586c929f4af12c72ea89a3d","modified":1464010030156},{"_id":"source/_posts/zjoi2008-bnb.md","shasum":"ac858ed7f59d732e10122e77ade78baa597169a1","modified":1479002028968},{"_id":"source/_posts/zjoi2008-party.md","shasum":"65c92b713af1a524097ff448a1df0ad004ebcc0b","modified":1479003183231},{"_id":"source/_posts/zjoi2009-ws.md","shasum":"a8570e70c6c8cbe1db3c9fcd61a57d73338e3305","modified":1466677416289},{"_id":"source/_posts/zjoi2014-force.md","shasum":"fc88dcd64579695a98932f026cacac9d956141d8","modified":1465695038354},{"_id":"source/about-me.md","shasum":"64fcf2735c0c1b62e25355489c4cf4fa6994a922","modified":1463747969758},{"_id":"source/friends.md","shasum":"1d4316c140821c23d82933c2cc4352c57ab61bcb","modified":1476539032349},{"_id":"source/tags/index.md","shasum":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1473486143025},{"_id":"source/_posts/zjoi2010-network.md","shasum":"48bcc635e268cf66d01d9c129388be804bcc8413","modified":1466470152142},{"_id":"source/_posts/sdoi2016-game/tree.png","shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86","modified":1462955792590},{"_id":"source/_posts/shoi2008-hannoi.md","shasum":"087cf760e04d33e7a17df8e17d40f105d28f287c","modified":1476861861733},{"_id":"source/_posts/virtualbox-archlinux/port.png","shasum":"bb684dd8b616413e3e0e27c5efce118249a54113","modified":1462955792600},{"_id":"themes/icarus/LICENSE","shasum":"df00918fa95de563927fd92b26f14c7affdc3052","modified":1473479288813},{"_id":"themes/icarus/README.md","shasum":"25c75503f044b817297995a96621c92ce037a098","modified":1473479288813},{"_id":"themes/icarus/_config.yml","shasum":"d045666c37e85ffc0322b30290c7f353868b4c77","modified":1477987073201},{"_id":"themes/icarus/_config.yml.example","shasum":"2bfcb6fa9078f7c5ffe2fc6c482248783711387f","modified":1473479288813},{"_id":"themes/icarus/_source/about/index.md","shasum":"2847759c65295fdc47685cc32e10ae30b2f022ae","modified":1473479288813},{"_id":"themes/icarus/_source/categories/index.md","shasum":"55bee2cb88da438a2e8b1f29b1d7e954c07a9e60","modified":1473479288813},{"_id":"themes/icarus/_source/tags/index.md","shasum":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1473479288813},{"_id":"themes/icarus/languages/en.yml","shasum":"ade241498b85503a8953a1deca963222f47067a7","modified":1473479288813},{"_id":"themes/icarus/languages/es.yml","shasum":"d7432219be5bee4cb569331378ade61b749688e0","modified":1473479288813},{"_id":"themes/icarus/languages/fr.yml","shasum":"cb3e597cbec7e8f458858c457bafd1f3a225083d","modified":1473479288813},{"_id":"themes/icarus/languages/id.yml","shasum":"70ec9ab2ac04cf882e81377ca5ad15bf8adceca8","modified":1473479288813},{"_id":"themes/icarus/languages/ja.yml","shasum":"ff972961e5f468a695d80d21b62c3e9032cdf561","modified":1473479288813},{"_id":"themes/icarus/languages/ko.yml","shasum":"7c4ad4577dc0577ad2ca1c0410507f5e5fadf530","modified":1473479288813},{"_id":"themes/icarus/languages/pt-BR.yml","shasum":"3c5d5293575593705b9a2dfa9d97b017eb4bc8c3","modified":1473479288813},{"_id":"themes/icarus/languages/ru.yml","shasum":"d1aab2b0c939d0c6020f881d664b660a01ee7327","modified":1473479288813},{"_id":"themes/icarus/languages/tr.yml","shasum":"8b7eb6aec264db50dbabea89f680acca256f4cd1","modified":1473479288817},{"_id":"themes/icarus/languages/zh-CN.yml","shasum":"3dc8ec524805afd090438be717908750da439204","modified":1473479288817},{"_id":"themes/icarus/languages/zh-TW.yml","shasum":"d8d96a0a17c20af11919ce036e87379a6b163db9","modified":1473479288817},{"_id":"themes/icarus/layout/archive.ejs","shasum":"c1ecf667f40f34d61ab33eed46bab143eb1af36d","modified":1473479288817},{"_id":"themes/icarus/layout/categories.ejs","shasum":"aa95629b770cff8cca9d663aeb6b17928f070de5","modified":1473479288817},{"_id":"themes/icarus/layout/category.ejs","shasum":"1d407f9176db84e83062c52ad4755aaea9e74401","modified":1473479288817},{"_id":"themes/icarus/layout/comment/counter.ejs","shasum":"e109d3256b004b027d029bd5bd67feeb72dc5388","modified":1473479288817},{"_id":"themes/icarus/layout/comment/disqus.ejs","shasum":"8ce59d7e6d41fcdbfe84f35a61c37e3a53882465","modified":1473505978208},{"_id":"themes/icarus/layout/comment/duoshuo.ejs","shasum":"ce46d7410a99b57704da32e9d09071cef6c9fa93","modified":1473479288817},{"_id":"themes/icarus/layout/comment/index.ejs","shasum":"d45635e78a3fc40e424a401e983f2c8eef6ebcfd","modified":1473479288817},{"_id":"themes/icarus/layout/comment/scripts.ejs","shasum":"8a9a20f72ba0923afa776396fb67d8c5d446a666","modified":1473479288817},{"_id":"themes/icarus/layout/comment/youyan.ejs","shasum":"6fe807992832939caf6c3e7651d052df9520d88e","modified":1473479288817},{"_id":"themes/icarus/layout/common/article.ejs","shasum":"1c9db0c9305e56caddf8d894671bc38c4b08173a","modified":1473506250129},{"_id":"themes/icarus/layout/common/footer.ejs","shasum":"cbfe560fcab445d42ceeb5d1beba5957d5be5eaa","modified":1473479288817},{"_id":"themes/icarus/layout/common/head.ejs","shasum":"352fa61fd5176d4fa0f30ac553b127f2a79e7913","modified":1480504108316},{"_id":"themes/icarus/layout/common/header.ejs","shasum":"738c6a923b2a6de6a81c4892c8a47e03d8b34f88","modified":1473479288817},{"_id":"themes/icarus/layout/common/post/banner.ejs","shasum":"47ced3f03525698c79c6b1c07b48383fb6c496b2","modified":1473479288817},{"_id":"themes/icarus/layout/common/post/category.ejs","shasum":"75c9dda2e7ec041943855ca163a6b1c4c8b4f260","modified":1473479288817},{"_id":"themes/icarus/layout/common/post/date.ejs","shasum":"45cb0bcad461036cdd1fe2e3fbb5f2f19940025c","modified":1473479288817},{"_id":"themes/icarus/layout/common/post/gallery.ejs","shasum":"659f019761116313169148ec61773e7b84abb739","modified":1473479288817},{"_id":"themes/icarus/layout/common/post/nav.ejs","shasum":"d7cd611e642327f33dff3963ef869c2b46824a11","modified":1473479288817},{"_id":"themes/icarus/layout/common/post/tag.ejs","shasum":"2e966216256321aa0c76fe1b9be689601c76ef31","modified":1473479288817},{"_id":"themes/icarus/layout/common/post/title.ejs","shasum":"669ddb46fefa100856588351a7a2d30ad996b755","modified":1473479288817},{"_id":"themes/icarus/layout/common/profile.ejs","shasum":"0d5a9622d490652599e3ba3e4077a7d6bb2eb38e","modified":1473479288817},{"_id":"themes/icarus/layout/common/scripts.ejs","shasum":"c0a1a9e53f89440c42c325d5bd8c7234652c8937","modified":1473479288817},{"_id":"themes/icarus/layout/common/sidebar.ejs","shasum":"6e80fa52d23c9c39bfa357a1e00c26fc8b851b82","modified":1473479288817},{"_id":"themes/icarus/layout/common/thumbnail.ejs","shasum":"1b70f8a98cd8650b159bda858dbee38dbdb7f0c5","modified":1473479288817},{"_id":"themes/icarus/layout/common/timeline.ejs","shasum":"6420e34e0332c9b6670011519f341340db989343","modified":1473479288817},{"_id":"themes/icarus/layout/index.ejs","shasum":"43e971ebc35657b18e08a049559790348a16666f","modified":1473479288817},{"_id":"themes/icarus/layout/layout.ejs","shasum":"6f01b3d46d184a820297f9542497808b152bb09e","modified":1473479288817},{"_id":"themes/icarus/layout/page.ejs","shasum":"50170783bac99946ae8af483920568de9b2d9801","modified":1473479288817},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","shasum":"6a7bee18e666e627e62541a5e30906f87ba1bfe8","modified":1473479288817},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","shasum":"349f08b6521a16e79046b1f94f04317ac74f556e","modified":1473479288817},{"_id":"themes/icarus/layout/plugin/scripts.ejs","shasum":"a3c92f1f299e7ba11f2660457d8dcd41acf74640","modified":1473488523947},{"_id":"themes/icarus/layout/post.ejs","shasum":"50170783bac99946ae8af483920568de9b2d9801","modified":1473479288817},{"_id":"themes/icarus/layout/search/baidu.ejs","shasum":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1473479288817},{"_id":"themes/icarus/layout/search/index-mobile.ejs","shasum":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1473479288817},{"_id":"themes/icarus/layout/search/index.ejs","shasum":"24935e32e61d4706454b174ea3bed0726ae7fb34","modified":1473479288817},{"_id":"themes/icarus/layout/search/insight.ejs","shasum":"130fe3d33ac71da0b50f7fee6a87979f30938a1b","modified":1473479288817},{"_id":"themes/icarus/layout/search/swiftype.ejs","shasum":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1473479288817},{"_id":"themes/icarus/layout/share/addtoany.ejs","shasum":"ac180c4c84b73a04d61b17e7dc18c257e20bf59f","modified":1473479288817},{"_id":"themes/icarus/layout/share/bdshare.ejs","shasum":"a1e772c5a6f174d585b0c1e574058f75dc8e2898","modified":1473479288817},{"_id":"themes/icarus/layout/share/default.ejs","shasum":"ebfb919dc525b3ed61a6a5ee05ee71410eedc541","modified":1473479288817},{"_id":"themes/icarus/layout/share/index.ejs","shasum":"2a2c0095b95b11e5692bd8ad6a2337aa644189a2","modified":1473479288817},{"_id":"themes/icarus/layout/share/jiathis.ejs","shasum":"21ebaa51e828cba2cefbeeaccb01514643565755","modified":1473479288817},{"_id":"themes/icarus/layout/tag.ejs","shasum":"f6c220d4e5c231028bc71ddc11aec97d7b5a9943","modified":1473479288817},{"_id":"themes/icarus/layout/tags.ejs","shasum":"b0fcea68d7c11e5899bf0375d80997685111653f","modified":1473479288817},{"_id":"themes/icarus/layout/widget/archive.ejs","shasum":"d9ebbb7f6ce2f25df5ae25e4a1fef3c08f7054b9","modified":1473479288817},{"_id":"themes/icarus/layout/widget/category.ejs","shasum":"583bda80cf15b3ef11fefbd1b502897dfff40100","modified":1473479288817},{"_id":"themes/icarus/layout/widget/links.ejs","shasum":"aad118699718b62c0d3f3cfd6f17a181139a76af","modified":1473479288817},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","shasum":"2ca923465275fb38a7ac7d67211d6e94a977e957","modified":1473479288817},{"_id":"themes/icarus/layout/widget/tag.ejs","shasum":"3b8ae5953990436893da9d68f910ebe592005659","modified":1473479288817},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","shasum":"ca8c7bf555fb6ce4904f2c59160548405c2c8a82","modified":1473479288817},{"_id":"themes/icarus/package.json","shasum":"1bc52ef10a33df23e56bd73c927f605019c87d41","modified":1473479288817},{"_id":"themes/icarus/scripts/meta.js","shasum":"1993754a2f3dffa283fa0538eb8f056385b69ad4","modified":1473479288817},{"_id":"themes/icarus/scripts/thumbnail.js","shasum":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1473479288817},{"_id":"themes/icarus/source/css/_extend.styl","shasum":"9a5c72663c0da1b32ecb6a75773a5ccfb8c467ca","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/agate.styl","shasum":"601eb70448a16b918df132f6fc41e891ae053653","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/androidstudio.styl","shasum":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/arduino-light.styl","shasum":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/arta.styl","shasum":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/ascetic.styl","shasum":"32cff3bef6fac3760fe78f203096477052a90552","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-dark.styl","shasum":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-cave-light.styl","shasum":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-dark.styl","shasum":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-dune-light.styl","shasum":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-dark.styl","shasum":"d84382bc8298f96730757391d3e761b7e640f406","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-estuary-light.styl","shasum":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-dark.styl","shasum":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-forest-light.styl","shasum":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-dark.styl","shasum":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-heath-light.styl","shasum":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-dark.styl","shasum":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-lakeside-light.styl","shasum":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-dark.styl","shasum":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-plateau-light.styl","shasum":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-dark.styl","shasum":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-savanna-light.styl","shasum":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-dark.styl","shasum":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-seaside-light.styl","shasum":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-dark.styl","shasum":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/atelier-sulphurpool-light.styl","shasum":"efa52713efc468abeeb2b9299704371583b857de","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/brown-paper.styl","shasum":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/brown-papersq.png","shasum":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/codepen-embed.styl","shasum":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/color-brewer.styl","shasum":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/dark.styl","shasum":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/darkula.styl","shasum":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/docco.styl","shasum":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/far.styl","shasum":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/foundation.styl","shasum":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/github-gist.styl","shasum":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/github.styl","shasum":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/googlecode.styl","shasum":"bda816beee7b439814b514e6869dc678822be1bc","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/grayscale.styl","shasum":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/highlightjs.styl","shasum":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/hopscotch.styl","shasum":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/hybrid.styl","shasum":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/idea.styl","shasum":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/index.styl","shasum":"22282a7856b25837a143c2113742690c141dcaea","modified":1473488477845},{"_id":"themes/icarus/source/css/_highlight/ir-black.styl","shasum":"693078bbd72a2091ed30f506cc55949600b717af","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/kimbie.dark.styl","shasum":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/kimbie.light.styl","shasum":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/magula.styl","shasum":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/mono-blue.styl","shasum":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/monokai-sublime.styl","shasum":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/monokai.styl","shasum":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1473479288821},{"_id":"themes/icarus/source/css/_highlight/obsidian.styl","shasum":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/paraiso-dark.styl","shasum":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/paraiso-light.styl","shasum":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/pojoaque.jpg","shasum":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/pojoaque.styl","shasum":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/railscasts.styl","shasum":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/rainbow.styl","shasum":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/school-book.png","shasum":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/school-book.styl","shasum":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/solarized-dark.styl","shasum":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/solarized-light.styl","shasum":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/sunburst.styl","shasum":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-blue.styl","shasum":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-bright.styl","shasum":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night-eighties.styl","shasum":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/tomorrow-night.styl","shasum":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/tomorrow.styl","shasum":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/vs.styl","shasum":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/xcode.styl","shasum":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1473479288825},{"_id":"themes/icarus/source/css/_highlight/zenburn.styl","shasum":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1473479288825},{"_id":"themes/icarus/source/css/_partial/archive.styl","shasum":"dd8329d75a8312785611b5ec422bd49afc628c1c","modified":1473479288825},{"_id":"themes/icarus/source/css/_partial/article.styl","shasum":"1508fadf345f7c63fbe6c21e23b59a6ec9a5ae3f","modified":1473506145956},{"_id":"themes/icarus/source/css/_partial/comment.styl","shasum":"784646796184d4f27918c22395288a2fafbf9554","modified":1473479288825},{"_id":"themes/icarus/source/css/_partial/footer.styl","shasum":"484776654e4c1691dc844e6e93786a08855c1c99","modified":1473479288825},{"_id":"themes/icarus/source/css/_partial/header.styl","shasum":"1e351f741144135871a3373fe7e969dc961b65e7","modified":1473479288825},{"_id":"themes/icarus/source/css/_partial/insight.styl","shasum":"19833cd127f26ad90b06c115f8a96a30e0c0e53b","modified":1473479288825},{"_id":"themes/icarus/source/css/_partial/profile.styl","shasum":"fb0170075dc2a41e01dd11bbfdbccbed544c479a","modified":1473479288825},{"_id":"themes/icarus/source/css/_partial/sidebar.styl","shasum":"f528ca7064d9fcecd737b9b71c9c54601365d7d3","modified":1473479288825},{"_id":"themes/icarus/source/css/_partial/timeline.styl","shasum":"c813b98f4fc45b64d2e07e5d944745a654c8c943","modified":1473479288825},{"_id":"themes/icarus/source/css/_util/grid.styl","shasum":"93fb6f1e2f40cd7d88ad0d56dd73d3f9a7bc853e","modified":1473479288825},{"_id":"themes/icarus/source/css/_util/mixin.styl","shasum":"c8e1ddfc0fe9108bab592c7a73b73ce9344991fd","modified":1473479288825},{"_id":"themes/icarus/source/css/_variables.styl","shasum":"d62af931be6612ec8c3a917836379a8cd92fbce1","modified":1473479288825},{"_id":"themes/icarus/source/css/images/logo.png","shasum":"e606a0584f98268b2fe92303f3254520862ef659","modified":1473479288825},{"_id":"themes/icarus/source/css/images/thumb-default-small.png","shasum":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1473479288825},{"_id":"themes/icarus/source/css/style.styl","shasum":"865de42ad496af928252d5bcfa0e0bbb534b0df5","modified":1473479288825},{"_id":"themes/icarus/source/css/tomorrow.css","shasum":"5d7e34a8cf77a0e2ec66ce04139da68026fca564","modified":1480504063132},{"_id":"themes/icarus/source/js/APlayer.min.js","shasum":"5d040dc50af42fec45538a10a7f826e739935278","modified":1479633091605},{"_id":"themes/icarus/source/js/insight.js","shasum":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3","modified":1473479288825},{"_id":"themes/icarus/source/js/main.js","shasum":"a70daacbd0c0099aae0763b29a7fec20ce222d7a","modified":1473479288825},{"_id":"themes/icarus/source/vendor/font-awesome/css/font-awesome.css","shasum":"b5020c3860669185ba3f316fa7332cdf5c06f393","modified":1473479288825},{"_id":"themes/icarus/source/vendor/font-awesome/css/font-awesome.min.css","shasum":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1473479288825},{"_id":"themes/icarus/source/vendor/justified-gallery/jquery.justifiedGallery.min.js","shasum":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1473479288841},{"_id":"themes/icarus/source/vendor/justified-gallery/justifiedGallery.min.css","shasum":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.css","shasum":"844ce27b8488968bccb3e50bb49184ba2aae0625","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.css.map","shasum":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-fb-comment-box.min.css","shasum":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.css.map","shasum":"50c3348638b4d82fa08a449c690e8d2bb593005d","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.css","shasum":"7871c28498d74451d6aa438c8d3a1817810a1e19","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lg-transitions.min.css","shasum":"5c22e2073a4c96d6212c72135391b599e8d1359f","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.css","shasum":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.css.map","shasum":"3175b4107078674d25798979f7666f4daf31e624","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/css/lightgallery.min.css","shasum":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.eot","shasum":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.svg","shasum":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.ttf","shasum":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/fonts/lg.woff","shasum":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/img/loading.gif","shasum":"607810444094b8619fa4efa6273bc2a7e38dd4b4","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/img/video-play.png","shasum":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef","modified":1473479288841},{"_id":"themes/icarus/source/vendor/lightgallery/img/vimeo-play.png","shasum":"6190254f2804904a4a1fa1eb390dfd334e416992","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/img/youtube-play.png","shasum":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-autoplay.js","shasum":"426bb78b93acfc39d533ea2bab1cec8dc289cf24","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-autoplay.min.js","shasum":"d845741bcaf961579622880eb2a445257efad1ac","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-fullscreen.js","shasum":"65c47ac65362854ba44b00a010bb01e3630209d8","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-fullscreen.min.js","shasum":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-hash.js","shasum":"15d16516c5642d3de1566ff8fc9160136ccaa405","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-hash.min.js","shasum":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-pager.js","shasum":"8092c692b244bb26343eb03b91bd97deb9dafc9c","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-pager.min.js","shasum":"25caa6ff65b1c6dee09941e795ae2633bdbab211","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-share.js","shasum":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-share.min.js","shasum":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-thumbnail.js","shasum":"3a6476b6df1d2bef4a21861a78776282a7a11ef1","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-thumbnail.min.js","shasum":"18dd7d2909d1bfd6852f031d03e774b4428c512b","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-video.js","shasum":"4f99b598f6bb18de9eca8c45c5b4373a03962367","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-video.min.js","shasum":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-zoom.js","shasum":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lg-zoom.min.js","shasum":"15b49f9728439819ece15e4295cce254c87a4f45","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lightgallery.min.js","shasum":"956ef9b706755318da69ad0b5d7786339d831251","modified":1473479288845},{"_id":"themes/icarus/source/vendor/lightgallery/js/lightgallery.js","shasum":"3cd19b33ba99efd5ba1d167da91720566d274b2c","modified":1473479288845},{"_id":"themes/icarus/source/vendor/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","shasum":"c4248ea800bd5608344ce163f5658b57e7ef9410","modified":1473479288845},{"_id":"themes/icarus/source/vendor/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","shasum":"e0350190d720a8fec0557ab47b318ec4e4486448","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","shasum":"2c5b039b57f62625e88226a938679ec937431ad1","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","shasum":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","shasum":"63eb74ef040aade256f2274a7f31a914edddb0ea","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","shasum":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","shasum":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","shasum":"415eee05976ab8b2471602a5ddb78a6c58fc21aa","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","shasum":"a0b0c389cf46d63c850e61fed572485ff0b68183","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","shasum":"c5f29fed6632efe0aa83318369f0d8c4061b775b","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","shasum":"be201d32a9aa5d186723ebb3c538be691aa8c53a","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","shasum":"afc44700053c9a28f9ab26f6aec4862ac1d0795d","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","shasum":"113978181dcac77baecef6115a9121d8f6e4fc3a","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","shasum":"5067c81462c15422853c94d21a1726865a61634f","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","shasum":"b366f2fda2e524eb5ef50058eefff249a3b96e6c","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","shasum":"d22904914469be735490e3c8cb093c7862896dd5","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","shasum":"ae80fb3cd16339aa7b5da280ab53975523dcaac2","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","shasum":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","shasum":"e75607ba1417181397c700775b84303d5a2957b9","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","shasum":"d0b40a7848703556c6631f24e961a98ca5829255","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","shasum":"be365eca44760ce3fc9b377c43d4634958479c69","modified":1473479288849},{"_id":"themes/icarus/source/vendor/open-sans/styles.css","shasum":"5ca6e111046232bde112d33201a60532aee7d3c4","modified":1473479288849},{"_id":"themes/icarus/source/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","shasum":"942addaec4d3a60af33947a84a3d85f926015947","modified":1473479288849},{"_id":"themes/icarus/source/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","shasum":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310","modified":1473479288849},{"_id":"themes/icarus/source/vendor/source-code-pro/styles.css","shasum":"93c308012738728f906cd4c5cfdb34189e0c712b","modified":1473479288849},{"_id":"source/_posts/virtualbox-archlinux/share.png","shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8","modified":1462955792610},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/FontAwesome.otf","shasum":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1473479288829},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.eot","shasum":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1473479288829},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.woff","shasum":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1473479288837},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1473479288837},{"_id":"themes/icarus/source/vendor/jquery/2.1.3/jquery.min.js","shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1473479288841},{"_id":"source/_posts/splay-notes-1/splay.png","shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13","modified":1462955792590},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1473479288837},{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426","modified":1462955792600},{"_id":"source/_posts/virtualbox-archlinux/network.png","shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2","modified":1462955792600},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426","modified":1462955792610},{"_id":"themes/icarus/source/vendor/font-awesome/fonts/fontawesome-webfont.svg","shasum":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1473479288833},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d","modified":1462955792610},{"_id":"themes/icarus/source/css/images/avatar.png","shasum":"c85cb21d1859376a4178d0e5124a441345dd2ebd","modified":1473480242439},{"_id":"public/vendor/source-code-pro/styles.css","modified":1480580753710,"shasum":"93c308012738728f906cd4c5cfdb34189e0c712b"},{"_id":"public/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasDy2Q8seG17bfDXYR_jUsrzg.woff2","modified":1480580753730,"shasum":"b0e0bb5ef78db8b15d430d0b9be9d4329289a310"},{"_id":"public/vendor/source-code-pro/fonts/mrl8jkM18OlOQN8JLgasD9V_2ngZ8dMf8fLgjYEouxg.woff2","modified":1480580753738,"shasum":"942addaec4d3a60af33947a84a3d85f926015947"},{"_id":"public/vendor/open-sans/styles.css","modified":1480580753739,"shasum":"5ca6e111046232bde112d33201a60532aee7d3c4"},{"_id":"public/vendor/open-sans/fonts/xozscpT2726on7jbcb_pAhJtnKITppOI_IvcXXDNrsc.woff2","modified":1480580753740,"shasum":"be365eca44760ce3fc9b377c43d4634958479c69"},{"_id":"public/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBr6up8jxqWt8HVA3mDhkV_0.woff2","modified":1480580753741,"shasum":"d0b40a7848703556c6631f24e961a98ca5829255"},{"_id":"public/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBo4P5ICox8Kq3LLUNMylGO4.woff2","modified":1480580753743,"shasum":"e75607ba1417181397c700775b84303d5a2957b9"},{"_id":"public/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBmo_sUJ8uO4YLWRInS22T3Y.woff2","modified":1480580753744,"shasum":"b85efde42fa3a03c32b1d31c6cd74c622fc7916c"},{"_id":"public/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBkbcKLIaa1LC45dFaAfauRA.woff2","modified":1480580753746,"shasum":"ae80fb3cd16339aa7b5da280ab53975523dcaac2"},{"_id":"public/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjUj_cnvWIuuBMVgbX098Mw.woff2","modified":1480580753751,"shasum":"d22904914469be735490e3c8cb093c7862896dd5"},{"_id":"public/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBjTOQ_MqJVwkKsUn0wKzc2I.woff2","modified":1480580753759,"shasum":"b366f2fda2e524eb5ef50058eefff249a3b96e6c"},{"_id":"public/vendor/open-sans/fonts/xjAJXh38I15wypJXxuGMBiYE0-AqJ3nfInTTiDXDjU4.woff2","modified":1480580753763,"shasum":"5067c81462c15422853c94d21a1726865a61634f"},{"_id":"public/vendor/open-sans/fonts/u-WUoqrET9fUeobQW7jkRRJtnKITppOI_IvcXXDNrsc.woff2","modified":1480580753767,"shasum":"113978181dcac77baecef6115a9121d8f6e4fc3a"},{"_id":"public/vendor/open-sans/fonts/cJZKeOuBrn4kERxqtaUH3VtXRa8TVwTICgirnJhmVJw.woff2","modified":1480580753770,"shasum":"afc44700053c9a28f9ab26f6aec4862ac1d0795d"},{"_id":"public/vendor/open-sans/fonts/RjgO7rYTmqiVp7vzi-Q5URJtnKITppOI_IvcXXDNrsc.woff2","modified":1480580753771,"shasum":"be201d32a9aa5d186723ebb3c538be691aa8c53a"},{"_id":"public/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSv8zf_FOSsgRmwsS7Aa9k2w.woff2","modified":1480580753772,"shasum":"c5f29fed6632efe0aa83318369f0d8c4061b775b"},{"_id":"public/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSugdm0LZdjqr5-oayXSOefg.woff2","modified":1480580753773,"shasum":"a0b0c389cf46d63c850e61fed572485ff0b68183"},{"_id":"public/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSqaRobkAwv3vxw3jMhVENGA.woff2","modified":1480580753774,"shasum":"415eee05976ab8b2471602a5ddb78a6c58fc21aa"},{"_id":"public/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSq-j2U0lmluP9RWlSytm3ho.woff2","modified":1480580753780,"shasum":"4dc6d7174ea6d89f4c45e43e1bfc3e03d8ffebaf"},{"_id":"public/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSpX5f-9o1vgP2EXwfjgl7AY.woff2","modified":1480580753787,"shasum":"328a22fe3eec71ad9e5ece4d67dd62e79dab6b7f"},{"_id":"public/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNSj0LW-43aMEzIO6XUTLjad8.woff2","modified":1480580753791,"shasum":"63eb74ef040aade256f2274a7f31a914edddb0ea"},{"_id":"public/vendor/open-sans/fonts/MTP_ySUJH_bn48VBG8sNShWV49_lSm1NYrwo-zkhivY.woff2","modified":1480580753793,"shasum":"22413bb8bfb78608c1e25aa1ed5c1f38557df79f"},{"_id":"public/vendor/open-sans/fonts/LWCjsQkB6EMdfHrEVqA1KRJtnKITppOI_IvcXXDNrsc.woff2","modified":1480580753796,"shasum":"2c5b039b57f62625e88226a938679ec937431ad1"},{"_id":"public/vendor/open-sans/fonts/K88pR3goAWT7BTt32Z01mxJtnKITppOI_IvcXXDNrsc.woff2","modified":1480580753800,"shasum":"e0350190d720a8fec0557ab47b318ec4e4486448"},{"_id":"public/vendor/open-sans/fonts/59ZRklaO5bWGqF5A9baEERJtnKITppOI_IvcXXDNrsc.woff2","modified":1480580753804,"shasum":"c4248ea800bd5608344ce163f5658b57e7ef9410"},{"_id":"public/vendor/lightgallery/js/lightgallery.min.js","modified":1480580753806,"shasum":"956ef9b706755318da69ad0b5d7786339d831251"},{"_id":"public/vendor/lightgallery/js/lightgallery.js","modified":1480580753807,"shasum":"3cd19b33ba99efd5ba1d167da91720566d274b2c"},{"_id":"public/vendor/lightgallery/js/lg-zoom.min.js","modified":1480580753808,"shasum":"15b49f9728439819ece15e4295cce254c87a4f45"},{"_id":"public/vendor/lightgallery/js/lg-zoom.js","modified":1480580753812,"shasum":"a758e2c8fcf710f9ff761da0eea0ab9321f3484d"},{"_id":"public/vendor/lightgallery/js/lg-video.min.js","modified":1480580753820,"shasum":"032c001ab045a69856f9c3ed4a2a3bf12a8e310f"},{"_id":"public/vendor/lightgallery/js/lg-video.js","modified":1480580753826,"shasum":"4f99b598f6bb18de9eca8c45c5b4373a03962367"},{"_id":"public/vendor/lightgallery/js/lg-thumbnail.min.js","modified":1480580753831,"shasum":"18dd7d2909d1bfd6852f031d03e774b4428c512b"},{"_id":"public/vendor/lightgallery/js/lg-thumbnail.js","modified":1480580753836,"shasum":"3a6476b6df1d2bef4a21861a78776282a7a11ef1"},{"_id":"public/vendor/lightgallery/js/lg-share.min.js","modified":1480580753840,"shasum":"39c615f07c5d3aaa65a2c3068a30fdd6dd5c372d"},{"_id":"public/vendor/lightgallery/js/lg-share.js","modified":1480580753841,"shasum":"b7fb5f6474911060a351b0a6fe9dbb9ac3fb22aa"},{"_id":"public/vendor/lightgallery/js/lg-pager.min.js","modified":1480580753842,"shasum":"25caa6ff65b1c6dee09941e795ae2633bdbab211"},{"_id":"public/vendor/lightgallery/js/lg-pager.js","modified":1480580753842,"shasum":"8092c692b244bb26343eb03b91bd97deb9dafc9c"},{"_id":"public/vendor/lightgallery/js/lg-hash.min.js","modified":1480580753843,"shasum":"43f1e1e720ab0e241c19b83aa26bd6848eab8edc"},{"_id":"public/vendor/lightgallery/js/lg-hash.js","modified":1480580753846,"shasum":"15d16516c5642d3de1566ff8fc9160136ccaa405"},{"_id":"public/vendor/lightgallery/js/lg-fullscreen.min.js","modified":1480580753848,"shasum":"b6b9e4022700b7faf2a5a175ba44a3bd938fdd20"},{"_id":"public/vendor/lightgallery/js/lg-fullscreen.js","modified":1480580753853,"shasum":"65c47ac65362854ba44b00a010bb01e3630209d8"},{"_id":"public/vendor/lightgallery/js/lg-autoplay.min.js","modified":1480580753854,"shasum":"d845741bcaf961579622880eb2a445257efad1ac"},{"_id":"public/vendor/lightgallery/js/lg-autoplay.js","modified":1480580753857,"shasum":"426bb78b93acfc39d533ea2bab1cec8dc289cf24"},{"_id":"public/vendor/lightgallery/img/youtube-play.png","modified":1480580753862,"shasum":"fea6df9d9d43151f9c9d15f000adb30eb3e26fc4"},{"_id":"public/vendor/lightgallery/img/vimeo-play.png","modified":1480580753871,"shasum":"6190254f2804904a4a1fa1eb390dfd334e416992"},{"_id":"public/vendor/lightgallery/img/video-play.png","modified":1480580753874,"shasum":"3ea484cdc04d2e4547f80cbf80001dcf248c94ef"},{"_id":"public/vendor/lightgallery/img/loading.gif","modified":1480580753875,"shasum":"607810444094b8619fa4efa6273bc2a7e38dd4b4"},{"_id":"public/vendor/lightgallery/fonts/lg.woff","modified":1480580753876,"shasum":"3048de344dd5cad4624e0127e58eaae4b576f574"},{"_id":"public/vendor/lightgallery/fonts/lg.ttf","modified":1480580753877,"shasum":"f6421c0c397311ae09f9257aa58bcd5e9720f493"},{"_id":"public/vendor/lightgallery/fonts/lg.svg","modified":1480580753880,"shasum":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a"},{"_id":"public/vendor/lightgallery/fonts/lg.eot","modified":1480580753881,"shasum":"54caf05a81e33d7bf04f2e420736ce6f1de5f936"},{"_id":"public/vendor/lightgallery/css/lightgallery.min.css","modified":1480580753886,"shasum":"c9a2e19c932b56f4a2ce30c98910d10b74edb38a"},{"_id":"public/vendor/lightgallery/css/lightgallery.css.map","modified":1480580753887,"shasum":"3175b4107078674d25798979f7666f4daf31e624"},{"_id":"public/vendor/lightgallery/css/lightgallery.css","modified":1480580753888,"shasum":"bef55316a32e512d5a8940e5d0bfe8bf7a9c5c61"},{"_id":"public/vendor/lightgallery/css/lg-transitions.min.css","modified":1480580753890,"shasum":"5c22e2073a4c96d6212c72135391b599e8d1359f"},{"_id":"public/vendor/lightgallery/css/lg-transitions.css.map","modified":1480580753891,"shasum":"50c3348638b4d82fa08a449c690e8d2bb593005d"},{"_id":"public/vendor/lightgallery/css/lg-transitions.css","modified":1480580753893,"shasum":"7871c28498d74451d6aa438c8d3a1817810a1e19"},{"_id":"public/vendor/lightgallery/css/lg-fb-comment-box.min.css","modified":1480580753896,"shasum":"05830fadb8454f39dcc98c8686eb4d5c24b71fc0"},{"_id":"public/vendor/lightgallery/css/lg-fb-comment-box.css.map","modified":1480580753901,"shasum":"51e9df39edf0faa3f38c1bab0c1fa6c922b9edcb"},{"_id":"public/vendor/lightgallery/css/lg-fb-comment-box.css","modified":1480580753905,"shasum":"844ce27b8488968bccb3e50bb49184ba2aae0625"},{"_id":"public/vendor/justified-gallery/justifiedGallery.min.css","modified":1480580753908,"shasum":"13fbcba5e97aa88b748d94d3efc4718475279907"},{"_id":"public/vendor/justified-gallery/jquery.justifiedGallery.min.js","modified":1480580753908,"shasum":"b2683e7a872bc109b1756a65188a37cef7d0bd5c"},{"_id":"public/vendor/jquery/2.1.3/jquery.min.js","modified":1480580753909,"shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276"},{"_id":"public/vendor/font-awesome/fonts/fontawesome-webfont.woff2","modified":1480580753913,"shasum":"97e438cc545714309882fbceadbf344fcaddcec5"},{"_id":"public/vendor/font-awesome/fonts/fontawesome-webfont.woff","modified":1480580753921,"shasum":"6d7e6a5fc802b13694d8820fc0138037c0977d2e"},{"_id":"public/vendor/font-awesome/fonts/fontawesome-webfont.ttf","modified":1480580753922,"shasum":"61d8d967807ef12598d81582fa95b9f600c3ee01"},{"_id":"public/vendor/font-awesome/fonts/fontawesome-webfont.svg","modified":1480580753931,"shasum":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0"},{"_id":"public/vendor/font-awesome/fonts/fontawesome-webfont.eot","modified":1480580753936,"shasum":"965ce8f688fedbeed504efd498bc9c1622d12362"},{"_id":"public/vendor/font-awesome/fonts/FontAwesome.otf","modified":1480580753941,"shasum":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819"},{"_id":"public/vendor/font-awesome/css/font-awesome.min.css","modified":1480580753946,"shasum":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761"},{"_id":"public/vendor/font-awesome/css/font-awesome.css","modified":1480580753947,"shasum":"b5020c3860669185ba3f316fa7332cdf5c06f393"},{"_id":"public/js/main.js","modified":1480580753952,"shasum":"a70daacbd0c0099aae0763b29a7fec20ce222d7a"},{"_id":"public/js/insight.js","modified":1480580753953,"shasum":"6ee84c42c2b230ff9e9bf605a444bd671d44f9e3"},{"_id":"public/js/APlayer.min.js","modified":1480580753954,"shasum":"5d040dc50af42fec45538a10a7f826e739935278"},{"_id":"public/css/tomorrow.css","modified":1480580753955,"shasum":"5d7e34a8cf77a0e2ec66ce04139da68026fca564"},{"_id":"public/css/style.css","modified":1480580755151,"shasum":"d22ee5e083a9e8d3a0d0ba36c72b7e78a0c4cb9e"},{"_id":"public/css/images/thumb-default-small.png","modified":1480580755422,"shasum":"e8403b97ed9251f9f5207765b0ce796c5000b4ba"},{"_id":"public/css/images/logo.png","modified":1480580755424,"shasum":"e606a0584f98268b2fe92303f3254520862ef659"},{"_id":"public/css/images/avatar.png","modified":1480580755427,"shasum":"c85cb21d1859376a4178d0e5124a441345dd2ebd"},{"_id":"public/virtualbox-archlinux/hotkey.png","modified":1480580755438,"shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426"},{"_id":"public/virtualbox-archlinux/network.png","modified":1480580755440,"shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2"},{"_id":"public/virtualbox-archlinux/port.png","modified":1480580755442,"shasum":"bb684dd8b616413e3e0e27c5efce118249a54113"},{"_id":"public/virtualbox-archlinux/screenfetch.png","modified":1480580755447,"shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d"},{"_id":"public/virtualbox-archlinux/share.png","modified":1480580755461,"shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8"},{"_id":"public/virtualbox-archlinux/terminal.png","modified":1480580755474,"shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426"},{"_id":"public/uva-11538/cells.png","modified":1480580755478,"shasum":"3a162829c312a17639950c3620cd70799ed94a49"},{"_id":"public/splay-notes-1/splay.png","modified":1480580755483,"shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13"},{"_id":"public/sdoi2016-game/line.png","modified":1480580755484,"shasum":"30c24e553938d2c27b55779527825b2577088a7c"},{"_id":"public/sdoi2016-game/tree.png","modified":1480580755485,"shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86"},{"_id":"public/noip2016-running/linear-backward1.svg","modified":1480580755486,"shasum":"f11ad00d6b6d9c4a9dbcdd756a54ac9f98aae87c"},{"_id":"public/noip2016-running/linear-forward1.svg","modified":1480580755487,"shasum":"21d1e9f4c290ba36e95ca3d1a3f03108f7e7d08c"},{"_id":"public/noip2016-running/linear-forward2.svg","modified":1480580755488,"shasum":"d828849ead2a7f7a3ac34250ec3e468dd053fe4c"},{"_id":"public/node-devide-notes/tree1.svg","modified":1480580755492,"shasum":"95a6f3d6aecac664917f8dad2ff4c4c655011efe"},{"_id":"public/node-devide-notes/tree2.svg","modified":1480580755495,"shasum":"d61370507100e7cdfab1181f3955a0b7b1183e5e"},{"_id":"public/lyoi-pingfan/pfzl.lrc","modified":1480580755500,"shasum":"cd9495fcc11a3797b90d5b6e34676f412fa64709"},{"_id":"public/cut-tree-notes/cutTree.png","modified":1480580755503,"shasum":"12de28c1f402f876a3826dcd7bfc8525d555ce1e"},{"_id":"public/cf-716e/example.svg","modified":1480580755505,"shasum":"a1d6731f2ef7e43ae48e27345954c6cb24a216b0"},{"_id":"public/bzoj-2683/cdq.png","modified":1480580755506,"shasum":"a95d0b02b915f092df6656298add0f0fc9662341"},{"_id":"public/at-the-cross-of-time/mzr.lrc","modified":1480580755506,"shasum":"25283ad79892beb5c83c43d981fdd32fbee30466"},{"_id":"public/acam-notes/acam.svg","modified":1480580755507,"shasum":"2c11a423a255ec9f480dc9fa6e24d8f003b492c9"},{"_id":"public/acam-notes/acam2.svg","modified":1480580755508,"shasum":"8cd2e6903dc1aaf1b8011680c03929d538a56328"},{"_id":"public/tags/index.html","modified":1480580756489,"shasum":"f7a7cc7c4f44e188b6c551cef1badcbce5e069ec"},{"_id":"public/friends/index.html","modified":1480580756606,"shasum":"6bd8ee30af59c5da9a753e1c1767527917d2be4b"},{"_id":"public/about-me/index.html","modified":1480580756665,"shasum":"d521756343a7410f1c91d3c107ade43afd19ebb8"},{"_id":"public/haoi2007-lis/index.html","modified":1480580756788,"shasum":"3726b8b1104343463febde038bd0f010e62fa863"},{"_id":"public/noip2016-angrybirds/index.html","modified":1480580756902,"shasum":"6c78e6b816d407ccd96237b31f7b83017f0ddca7"},{"_id":"public/noip2016-earthworm/index.html","modified":1480580757017,"shasum":"9561423f4eceaf9d69e7921180168f03fac03d96"},{"_id":"public/noip2016-problem/index.html","modified":1480580757142,"shasum":"5cd53f8828300f4955db4f93e30e74c671baeeb8"},{"_id":"public/noip2016-classroom/index.html","modified":1480580757288,"shasum":"7e1f4b1fbbeab3a8114d3b3cd12a77f33d3ebebf"},{"_id":"public/noip2016-running/index.html","modified":1480580757477,"shasum":"90f976986068e2122c545cd6b448939156e06b43"},{"_id":"public/noip2016-toy/index.html","modified":1480580757544,"shasum":"d0549385107b34889ae19d0db0b9b673871601d2"},{"_id":"public/noip2016/index.html","modified":1480580757598,"shasum":"bfdb96d15d102b7fb0195f94a70928854b242761"},{"_id":"public/lyoi-pingfan/index.html","modified":1480580757646,"shasum":"a66f1b1919d1413bb2f3cf045f4b39e9fea84b72"},{"_id":"public/noip2012-blockade/index.html","modified":1480580757751,"shasum":"84b0503e2447463821959cfb1cae044c8aab8c84"},{"_id":"public/noip2010-flow/index.html","modified":1480580757832,"shasum":"2a068f3a7f78e30a2a2a9db3bbfc545bcc15e6f3"},{"_id":"public/noip2012-drive/index.html","modified":1480580757957,"shasum":"a2aba35474fda8512e0a4667655a31f4065439b1"},{"_id":"public/noip2013-puzzle/index.html","modified":1480580758087,"shasum":"db2509fd7fe2dc5b282ee3a2aff8085c6794b990"},{"_id":"public/haoi2008-candy/index.html","modified":1480580758193,"shasum":"db4de352aa77eb4d12b2ba916214d9aabbb80824"},{"_id":"public/haoi2008-stick/index.html","modified":1480580758269,"shasum":"b75dcb25ccaa0685446a596c395e6a0d1ff51e8e"},{"_id":"public/haoi2008-coins/index.html","modified":1480580758359,"shasum":"eb81473b8b22453eba428953d9512eb7d6ba1a69"},{"_id":"public/haoi2008-cir/index.html","modified":1480580758444,"shasum":"de4d931ada6b869e8a06515d1b41e41ca41f95e2"},{"_id":"public/zjoi2008-party/index.html","modified":1480580758517,"shasum":"daa1b8345347d7537abb1ed0d0e64b342c90e3a5"},{"_id":"public/zjoi2008-bnb/index.html","modified":1480580758569,"shasum":"c0c222bb9b14ee13a63520b81d47be1da5f066f1"},{"_id":"public/jsoi2007-repair/index.html","modified":1480580758648,"shasum":"3207833845776e0c476870d67a7913bc34efe7d2"},{"_id":"public/jsoi2007-mahjong/index.html","modified":1480580758721,"shasum":"4e9621fa3e79b0361ec35d9ec469c3da6c193eff"},{"_id":"public/scoi2009-game/index.html","modified":1480580758893,"shasum":"2d4a0c73309d1970f212c84a2ab9510f6bb75bbc"},{"_id":"public/scoi2009-cake/index.html","modified":1480580758966,"shasum":"16231f17c37d730b6b174b33a8309c03355d94a0"},{"_id":"public/shoi2008-cactus/index.html","modified":1480580759118,"shasum":"23416d797096790b81a03ce4235b26790df75980"},{"_id":"public/ioi2008-island/index.html","modified":1480580759322,"shasum":"b6d550d71571ecc53bc3ad0df00b45c23564d958"},{"_id":"public/noip2015-transport/index.html","modified":1480580759477,"shasum":"eca2af80322d493424ad00d423caaac68a44ae08"},{"_id":"public/noip2015-substring/index.html","modified":1480580759616,"shasum":"41ce2a9bd8ca96aac085b4e46781d3108956f5c1"},{"_id":"public/noip2015-landlords/index.html","modified":1480580759952,"shasum":"a615f63d743b6ea376d84bc941804a1ccb5fdb6d"},{"_id":"public/noip2014-equation/index.html","modified":1480580760256,"shasum":"4147b51f3bdfa1f2256de287d42d0a0f2b78c680"},{"_id":"public/shoi2008-john/index.html","modified":1480580760400,"shasum":"9aca78197885cb2d62898a708d7ddf79de3c2f6c"},{"_id":"public/shoi2008-debt/index.html","modified":1480580760545,"shasum":"6880e6b80123500f5aead509ef0bab3e5404f3f6"},{"_id":"public/shoi2008-hannoi/index.html","modified":1480580760650,"shasum":"b731b37283f788bf0448183778a8b669f6b796f7"},{"_id":"public/shoi2008-traffic/index.html","modified":1480580760781,"shasum":"bab35b0d3f0208b6f8e9b0b0ee9fb417e6a869ec"},{"_id":"public/jsoi2008-award/index.html","modified":1480580760954,"shasum":"cbbb8c649c3e80eddf1a06885e27c5d7aae8bcd8"},{"_id":"public/jsoi2008-starwar/index.html","modified":1480580761111,"shasum":"3e000c988a5810866332f5f9305db01af7724b60"},{"_id":"public/jsoi2008-prefix/index.html","modified":1480580761337,"shasum":"ae11fca574ee9ddf2a7485ea2b67e63bcb0245c5"},{"_id":"public/hnoi2008-kingdom/index.html","modified":1480580761442,"shasum":"aaaac452ecbc37b3e7c7e1c0da60a8c1a4422bbc"},{"_id":"public/hnoi2008-cards/index.html","modified":1480580761549,"shasum":"1252e68745d32280f6ca8f544c4151fcfbd9f7c0"},{"_id":"public/fjoi2007-wheel/index.html","modified":1480580761686,"shasum":"9f28ab3a3d05a040763a113270f05860598fae4e"},{"_id":"public/noip2013-flower/index.html","modified":1480580761931,"shasum":"a5d708637a294ee341469cd286e0efc611692473"},{"_id":"public/noip2013-match/index.html","modified":1480580762100,"shasum":"8cd5fffc607ae499658ce2a241b6c687bcb97556"},{"_id":"public/hnoi2008-tree/index.html","modified":1480580762482,"shasum":"9fd22b216b57d21bd71da3978b5da5a9a3452600"},{"_id":"public/noip2014-bird/index.html","modified":1480580762651,"shasum":"2ff0c1205393897f085ed4056707729e9c1ea9d2"},{"_id":"public/noip2012-classrooms/index.html","modified":1480580762787,"shasum":"750ef950a3d81afa60c4550ad3cfcadbf1ab7ad0"},{"_id":"public/tjoi2015-chessboard/index.html","modified":1480580762897,"shasum":"0dbb23e5aa924d3aaafab74cf315a7bb6fdb04f8"},{"_id":"public/noi2012-random/index.html","modified":1480580763025,"shasum":"43fabd2f93831b151a5ffe8f0c940c77ca171d93"},{"_id":"public/bzoj-1706/index.html","modified":1480580763134,"shasum":"cbd9cc9abc22099728f93b8b750762546bc69ac5"},{"_id":"public/zjoi2004-swamp/index.html","modified":1480580763233,"shasum":"e9f258588bd915d802c78bc7f899957e60e58dc7"},{"_id":"public/hnoi2008-gt/index.html","modified":1480580763346,"shasum":"c2570e266a34074b7a84ba68659266b3e5317abe"},{"_id":"public/hdu-5906/index.html","modified":1480580763556,"shasum":"0211e444a8a9ba1ae1d9ea9b5656b8c6af0be3d8"},{"_id":"public/bzoj-3796/index.html","modified":1480580763703,"shasum":"fe3d83781f8bce71ff105bde726536c843eb596d"},{"_id":"public/bzoj-3277/index.html","modified":1480580763847,"shasum":"790c8132aa15b22525b87e7534d8f14b95d12f25"},{"_id":"public/bzoj-3230/index.html","modified":1480580763994,"shasum":"68c5f2bdde3812d2c43ee62da96400e08e5028bb"},{"_id":"public/bzoj-1692/index.html","modified":1480580764099,"shasum":"9e66aee9dc55df1cf4f0378d988190bc73c5e3a2"},{"_id":"public/scoi2012-name/index.html","modified":1480580764247,"shasum":"1707267c409674af239c692fd2e21a52e1e7e56c"},{"_id":"public/ahoi2013-diff/index.html","modified":1480580764415,"shasum":"d0c3f36d9f1027cdb5a1d9085e35c7737d3f6ed4"},{"_id":"public/jsoi2007-cipher/index.html","modified":1480580764575,"shasum":"6eb340536903d31e2cc40ff524b472c804fdc3de"},{"_id":"public/cf-716e/index.html","modified":1480580764816,"shasum":"af38d2485dcfbf8332a0d3434a81242a25bd60b1"},{"_id":"public/acam-notes/index.html","modified":1480580764938,"shasum":"527750a45de920f1628239be2e44f7ba6c88cbc7"},{"_id":"public/jsoi2009-game2/index.html","modified":1480580765092,"shasum":"0a1461b5f6d0f51e3cfe6f25fa545d730a1f392f"},{"_id":"public/bzoj-3881/index.html","modified":1480580765275,"shasum":"e31bf14c8faf348ea1dd3cbb94294a70516e1304"},{"_id":"public/bzoj-2580/index.html","modified":1480580765438,"shasum":"7b28c333ba6ef60709c0bf22bc97ed7c733c4a89"},{"_id":"public/bzoj-3940/index.html","modified":1480580765586,"shasum":"530ff35074cfb41ebcdbe9a6e448b656df558730"},{"_id":"public/bzoj-2462/index.html","modified":1480580765729,"shasum":"3d3a8f71dd3134bdef268975a2436c24e41047f4"},{"_id":"public/poi2000-wir/index.html","modified":1480580765864,"shasum":"63d0252fddbeea03465f3f3adbff1e7c5f65e1f9"},{"_id":"public/hnoi2004-language/index.html","modified":1480580765964,"shasum":"4f5f4994a6dd6b101d9825539bb6ed334f438392"},{"_id":"public/noi2011-type/index.html","modified":1480580766152,"shasum":"c32c5713c59e7c38be0722d301bb5ad37848e6a8"},{"_id":"public/jsoi2007-generator/index.html","modified":1480580766338,"shasum":"8fce711459b86e4e86dbdb01bebacff326f22324"},{"_id":"public/tjoi2013-word/index.html","modified":1480580766469,"shasum":"782c29e6dedb0db82ce372c52e7d5a760d94143e"},{"_id":"public/tarjan-cut-notes/index.html","modified":1480580766627,"shasum":"cc0900ab44d6c3cea01cdf9bab6572a9c82c6902"},{"_id":"public/noi2016-grid/index.html","modified":1480580766832,"shasum":"871fedf7ecdf916c0d0f1e8e543883bfde5efd4f"},{"_id":"public/poi2008-blo/index.html","modified":1480580766952,"shasum":"c5786874e03964c5e564b2aed168e0ad91d1768c"},{"_id":"public/hnoi2012-mine/index.html","modified":1480580767053,"shasum":"5a8b2eec0388c3dd326d527f416166c9779f2815"},{"_id":"public/noi2016-excellent/index.html","modified":1480580767151,"shasum":"81570fcabe167f5eb3d99c0fa232e64266735d45"},{"_id":"public/noi2016-interval/index.html","modified":1480580767248,"shasum":"cb7dbe42b22995579e98c7fa1dc04d2355a90af8"},{"_id":"public/sdoi2013-rforest/index.html","modified":1480580767394,"shasum":"e220ccdc46147be1707517ef1f9aa68e52df0746"},{"_id":"public/zjoi2007-semi/index.html","modified":1480580767518,"shasum":"85c1a559ecdc179b61f7480bfca960a5dd29e35a"},{"_id":"public/bzoj-3280/index.html","modified":1480580767626,"shasum":"a6f72af086ff88186ccb7047eeba07a1bd9bb4e3"},{"_id":"public/scoi2007-lizard/index.html","modified":1480580767719,"shasum":"578fff1f458e497d56d091370fef116b58c9b794"},{"_id":"public/sdoi2014-journey/index.html","modified":1480580767829,"shasum":"265a3d5821ef97f7e9956427f5145bd560c6076a"},{"_id":"public/sdoi2008-interval/index.html","modified":1480580767941,"shasum":"f4bcb3e80cb95b5ac59d3ad09effd6dac3de5878"},{"_id":"public/at-the-cross-of-time/index.html","modified":1480580767995,"shasum":"18c4a9697524a48a195af116cd7a266862727219"},{"_id":"public/noi2014-forest/index.html","modified":1480580768097,"shasum":"f64a03e9e333e9b12ebe6e0047f10904d86db86e"},{"_id":"public/noi2014-zoo/index.html","modified":1480580768171,"shasum":"501f021a3c3fa460cf702466913dfd20605f5212"},{"_id":"public/bzoj-4145/index.html","modified":1480580768226,"shasum":"b182241dc216ef31f434a602dba759fe71c66c5a"},{"_id":"public/bzoj-4247/index.html","modified":1480580768283,"shasum":"46b310c55830c8cd94c2a492d7340fa14c1ae93f"},{"_id":"public/jsoi2008-dotr/index.html","modified":1480580768364,"shasum":"95dea48863a977a93c7a72cc2cb775c0ff56628c"},{"_id":"public/heoi2013-bag/index.html","modified":1480580768427,"shasum":"e0efe0e97d61226ca74dd4f6d13ba0594befba1d"},{"_id":"public/scoi2009-paint/index.html","modified":1480580768500,"shasum":"c647177a9e8baa638a2125b2c495d79a961791f2"},{"_id":"public/bzoj-1334/index.html","modified":1480580768564,"shasum":"96caba55ee4883308aa624fcf3ee8e2b5dc8e2e4"},{"_id":"public/hnoi2010-chorus/index.html","modified":1480580768623,"shasum":"07243355019d5905008349af1a55145abfd62c5a"},{"_id":"public/scoi2003-fold/index.html","modified":1480580768692,"shasum":"3017dcabb782d41454dc1e87ed9121258f124124"},{"_id":"public/haoi2008-name/index.html","modified":1480580768759,"shasum":"42be52582c4ab221020b9e90ecb7db223c3c7669"},{"_id":"public/noi2015-dinner/index.html","modified":1480580768874,"shasum":"2b835c89247e47ab0438262260fc24e303ee4858"},{"_id":"public/noi2015-epic/index.html","modified":1480580768946,"shasum":"a15324fb10d0f076f1d392b6c094265e70d62bba"},{"_id":"public/noi2015-farm/index.html","modified":1480580769202,"shasum":"118ab21534b814778dfd62c392b524ebeccef3f6"},{"_id":"public/noi2015-savour/index.html","modified":1480580769352,"shasum":"9e5bf6ad98bfbf9942c0d6b5378dffcb52260c43"},{"_id":"public/bzoj-2438/index.html","modified":1480580769430,"shasum":"5ab45ab1a2397f549e29f5ba40d77d99f1b1f6fa"},{"_id":"public/bzoj-2716/index.html","modified":1480580769535,"shasum":"18e268e42b7c7f9d049340897003cd4a95cc61aa"},{"_id":"public/shoi2007-tree/index.html","modified":1480580769610,"shasum":"c28fb1bd3dbb7e7c5635543d654f7cee37850e60"},{"_id":"public/zjoi2009-ws/index.html","modified":1480580769687,"shasum":"93332aafe8cac851d8d50bbf6a02c97e78701397"},{"_id":"public/bzoj-2132/index.html","modified":1480580769780,"shasum":"29452af588439cc02d2e4820351971031625fb6d"},{"_id":"public/poi2005-kos/index.html","modified":1480580769860,"shasum":"a0086afe4d209dbf3272f43c0cc708b6892e1849"},{"_id":"public/poi2006-szk/index.html","modified":1480580769941,"shasum":"62059ccdbe42eda143ccda0aa6024ef732b7e409"},{"_id":"public/bzoj-1585/index.html","modified":1480580770017,"shasum":"830162f943b95f16004d79a0dd2712ee36540175"},{"_id":"public/ceoi2008-order/index.html","modified":1480580770091,"shasum":"a51651bac59891f78581b23b191ada7a16efaed0"},{"_id":"public/bzoj-1711/index.html","modified":1480580770174,"shasum":"444dcea7bad9b46d95ab9c3b66dbd3172a52c7a3"},{"_id":"public/sdoi2009-run/index.html","modified":1480580770251,"shasum":"19f2f48aa8a139a5943f3eb95a8f470b7fedc4fd"},{"_id":"public/bzoj-3894/index.html","modified":1480580770353,"shasum":"8bd6f355e351a02effdd814d89ef90245208a788"},{"_id":"public/bzoj-2127/index.html","modified":1480580770457,"shasum":"2a5c0c46ecf1ed729dd51b9a2129b16ce274d549"},{"_id":"public/bzoj-3438/index.html","modified":1480580770557,"shasum":"9200abf59b09d67d2a9c2bf06477fc1e13b1e3c6"},{"_id":"public/shoi2007-vote/index.html","modified":1480580770682,"shasum":"112f1963589877e04716942b433d0b0d99a0e1ef"},{"_id":"public/zjoi2010-network/index.html","modified":1480580770807,"shasum":"36fba32ca0143af0b12d8b3b3f792817f812d913"},{"_id":"public/cqoi2011-inverse/index.html","modified":1480580770925,"shasum":"d1f68fc83763fa4c8fe786d315690d5cfa314f22"},{"_id":"public/bzoj-1176/index.html","modified":1480580771050,"shasum":"fd25a698c18bd26cdd69bd58ab0e5edf1a637d49"},{"_id":"public/sdoi2010-goblin/index.html","modified":1480580771135,"shasum":"7454c5899c1172ae8dc20f1d8321ef7038700c1a"},{"_id":"public/bzoj-3262/index.html","modified":1480580771231,"shasum":"d54381646770ef55a50c0c16feac09e041345748"},{"_id":"public/bzoj-3196/index.html","modified":1480580771493,"shasum":"e167e2da6b98d5a02328786ce6bcbac57b7a6938"},{"_id":"public/bzoj-2456/index.html","modified":1480580771565,"shasum":"a1f30914a72f712d5b5b1986e8061b19e9a20098"},{"_id":"public/fft-to-ntt/index.html","modified":1480580771733,"shasum":"991d664438b7e819f82e3aa0884479e2ffd446a9"},{"_id":"public/node-devide-notes/index.html","modified":1480580771815,"shasum":"e2d92c7970c21437a8887b30ebd865620ee2526c"},{"_id":"public/ioi2011-race/index.html","modified":1480580771921,"shasum":"98245f7b848d3631cf2a15f5140e983ddd89e297"},{"_id":"public/bzoj-3365/index.html","modified":1480580772066,"shasum":"c7446b43ae8dbe83e9ad27e2d6fe0cda684ca32a"},{"_id":"public/bzoj-3697/index.html","modified":1480580772251,"shasum":"4cb182e7a86678b9b816e18e0c591c0e4b1844d3"},{"_id":"public/bzoj-2152/index.html","modified":1480580772341,"shasum":"5b0be8d8b541e4af24f78f708522509c50ce8009"},{"_id":"public/bzoj-1468/index.html","modified":1480580772721,"shasum":"580c3be6a800fb2a62117bf05cf788815b4b8afb"},{"_id":"public/sdoi2011-calc/index.html","modified":1480580772976,"shasum":"2f00f90e4aa7448656df85fe4508bff206a7cdc6"},{"_id":"public/bsgs-notes/index.html","modified":1480580773156,"shasum":"74e3debf9482377c17022b344c4ec2fc0035711f"},{"_id":"public/sdoi2015-sequence/index.html","modified":1480580773338,"shasum":"2dd41f7148a391584674759c8a7085eb92938a99"},{"_id":"public/zjoi2014-force/index.html","modified":1480580773483,"shasum":"ac356525d17ce556f8a990af289dfad1a04892e1"},{"_id":"public/bzoj-2194/index.html","modified":1480580773636,"shasum":"7111017f6a141d64403cfec0f82f6685c765a99e"},{"_id":"public/fft-notes/index.html","modified":1480580774123,"shasum":"7c63ebbce0ecbbc71e197e6d98eb8bed6604f20b"},{"_id":"public/uva-11021/index.html","modified":1480580774226,"shasum":"730913c992d8449dc28601a11335ad2e0c05e6f3"},{"_id":"public/bzoj-4318/index.html","modified":1480580774367,"shasum":"0c461ccd59381cf3756c48a831d4dde78cef7570"},{"_id":"public/20160527-array/index.html","modified":1480580774457,"shasum":"c060acfaad028d47fc5c77b3bc0dd93789597435"},{"_id":"public/bzoj-3275/index.html","modified":1480580774553,"shasum":"18566ceec1f960de61ff577ac4adafc8c7d3e8b0"},{"_id":"public/zjoi2006-trans/index.html","modified":1480580774645,"shasum":"4bb57256cb02eadc45afb3c7788b59275fd0da11"},{"_id":"public/zjoi2008-antbuster/index.html","modified":1480580774984,"shasum":"5d63ab7c3efcedce39edde22a38da5168dd4a6ee"},{"_id":"public/bzoj-3156/index.html","modified":1480580775139,"shasum":"144fc8a61446c09bf35024fb85aa772ced386dc8"},{"_id":"public/ceoi2004-two/index.html","modified":1480580775251,"shasum":"015d782f6466f1c68db68c27553188c9e2581c55"},{"_id":"public/bzoj-1597/index.html","modified":1480580775436,"shasum":"8499acc835fdce477736c538cd51ccffcddd599d"},{"_id":"public/zjoi2007-storage/index.html","modified":1480580775605,"shasum":"42f80b50685e08b0ceefb4ea0d7f86908882c6cf"},{"_id":"public/apio2010-commando/index.html","modified":1480580775755,"shasum":"331aa9f3025e0f60c2c5ae414ad21e8d80fe5b0d"},{"_id":"public/hdu-5632/index.html","modified":1480580775887,"shasum":"bd547d4883ea2cf5f5f21d46244dd9e820387b18"},{"_id":"public/scoi2009-windy/index.html","modified":1480580775992,"shasum":"7264545cab1319c5172e5a07ebc5a66df751f9eb"},{"_id":"public/cf-628d/index.html","modified":1480580776129,"shasum":"c26161587e21c0a3558515c80d339992a507a599"},{"_id":"public/hdu-2089/index.html","modified":1480580776221,"shasum":"e5299498bdea604cd10924017da6372849845295"},{"_id":"public/hdu-5642/index.html","modified":1480580776298,"shasum":"d5d01f4aa9fbfa5f1454e51f7da5fcbafd240577"},{"_id":"public/chairman-tree-notes/index.html","modified":1480580776408,"shasum":"e4abd08ee176b66d28ca8b2b689fce38863422ac"},{"_id":"public/hnoi2016-tree/index.html","modified":1480580776572,"shasum":"32f551a86dc30cd3dbf7c70a86e02e0fc2edb4a8"},{"_id":"public/hnoi2016-network/index.html","modified":1480580776686,"shasum":"77b7923f2cfd42de3cf30d0f70fbe081578c7060"},{"_id":"public/hnoi2016-multiple/index.html","modified":1480580776834,"shasum":"5b0b7ae638cf1c456b78c82aef3b2d51a5e027d6"},{"_id":"public/ctsc-apio-2016/index.html","modified":1480580776897,"shasum":"e6ed153ad78e507d93bf907173b2c7c8c4a664d8"},{"_id":"public/mo-algorithm-notes/index.html","modified":1480580776980,"shasum":"ea062b99f017a0b4ddc97417bcf273cb1c11690f"},{"_id":"public/hnoi2016-sequence/index.html","modified":1480580777160,"shasum":"3ee3a969dd424aefa64fc096878849d96b089646"},{"_id":"public/haoi2016-chain/index.html","modified":1480580777249,"shasum":"1e8518e83faf7df0c7311e8bd1455287956821b3"},{"_id":"public/jsoi2009-game/index.html","modified":1480580777359,"shasum":"e8938bee57c4632ddd540db3ccc2adaa7cfff40f"},{"_id":"public/hnoi2008-toy/index.html","modified":1480580777467,"shasum":"efa4af9d404c7c925a025f00f1e824041e4c1ff5"},{"_id":"public/jsoi2016-flight/index.html","modified":1480580777577,"shasum":"1bcc635784ce1e7f41f04552b96fbff8abe7d2c6"},{"_id":"public/cqoi2016-number/index.html","modified":1480580777671,"shasum":"c5772bd9ed8183f6e646709e5887188877f5df22"},{"_id":"public/cqoi2016-cuts/index.html","modified":1480580777779,"shasum":"8d89b43f418b137cf447e9a5936feab9afeb1599"},{"_id":"public/jsoi2016-light/index.html","modified":1480580777879,"shasum":"463eed30ec765b49ceae73042f8b08f457e4a33b"},{"_id":"public/sdoi2016-table/index.html","modified":1480580778059,"shasum":"8b942317e7f5b14fa1e3bad5961bbc7d606700f8"},{"_id":"public/sdoi2016-journey/index.html","modified":1480580778195,"shasum":"8bcbc87107812516191a08625c81d435431195a6"},{"_id":"public/sdoi2016-game/index.html","modified":1480580778363,"shasum":"0261533e63dad2a9f4109f279b2f440df4a2a6c1"},{"_id":"public/derangement-number/index.html","modified":1480580778415,"shasum":"e745ef4129deb30bf6bca8515d15091659b5ac9d"},{"_id":"public/mul-inverse/index.html","modified":1480580778507,"shasum":"e052fda287058f04ef235e3ac4aa7718dc3ef561"},{"_id":"public/sdoi2016-permutation/index.html","modified":1480580778588,"shasum":"61f14be6a2cd28b96c6d58a01ca3a5145d8a3dda"},{"_id":"public/sdoi2016-incantation/index.html","modified":1480580778705,"shasum":"576b5ee7026ad796932d563ddfa062fe4b055f3f"},{"_id":"public/spoj-694/index.html","modified":1480580778791,"shasum":"6d3bb071e0f69a26fce44f70be3dfa481e4f7326"},{"_id":"public/suffix-array-notes/index.html","modified":1480580779019,"shasum":"58b2f23573754415e886a088179e5cf71ffbac9c"},{"_id":"public/sdoi2016-round1/index.html","modified":1480580779094,"shasum":"b7d10e346023e738d904af5633dbf49c7039fb96"},{"_id":"public/poj-3461/index.html","modified":1480580779159,"shasum":"a712750c8ad9acf51401179b97b457eff2104b1d"},{"_id":"public/sdoi2016-pair/index.html","modified":1480580779290,"shasum":"9fb151f8778ad816d43488533df9bf88c59e6acc"},{"_id":"public/bzoj-4403/index.html","modified":1480580779380,"shasum":"8ace8be4d44f3a96e2123c93233a70101b7678a5"},{"_id":"public/ahoi2014-story/index.html","modified":1480580779474,"shasum":"e2ad19660b42e67bf3f0835859824e921a2e691f"},{"_id":"public/non-recursion-dfs-with-stack/index.html","modified":1480580779567,"shasum":"907fc31e9ec8b23c8893d10e1907fe6ec8ad13bf"},{"_id":"public/euler-sieve/index.html","modified":1480580779692,"shasum":"28182dcfe22fa6d522e61b15a986539eacdddc63"},{"_id":"public/haoi2011-problemb/index.html","modified":1480580779888,"shasum":"d001a0102463765b040c65e0fc5088e5c859d838"},{"_id":"public/bzoj-2820/index.html","modified":1480580780228,"shasum":"429a71e9e248a78e301f283382b10382032c3648"},{"_id":"public/bzoj-3511/index.html","modified":1480580780418,"shasum":"12dfa2096e453ac7598e86b5011c7b444c750049"},{"_id":"public/bzoj-1008/index.html","modified":1480580780518,"shasum":"609ac4c39f4acec243950d18af50e4271307d615"},{"_id":"public/20160404-theory/index.html","modified":1480580780720,"shasum":"5448b2db2eabe65fc04567ce4c9fffbfa49b7096"},{"_id":"public/tjoi2013-lis/index.html","modified":1480580780819,"shasum":"25a84e59257695b59b89efd42495b5eedce58fc1"},{"_id":"public/bzoj-1001/index.html","modified":1480580780913,"shasum":"b34fcecb5dffd37eb31f0e720d1846b229ce36b2"},{"_id":"public/noi2014-sleep/index.html","modified":1480580781009,"shasum":"5107261b4d777205f6a527efd4a51ccc4970f051"},{"_id":"public/haoi2015-t2/index.html","modified":1480580781119,"shasum":"79feabdd58e8b2d82419ce3e21ee2eb1af2618a0"},{"_id":"public/bzoj-2296/index.html","modified":1480580781198,"shasum":"f7af1edd448e0c1b8dd7f1017d94d065b7260e5e"},{"_id":"public/bzoj-2038/index.html","modified":1480580781296,"shasum":"9d9edd57dbbeb2e59ff60f67926db6da621bc98e"},{"_id":"public/20160331-naive/index.html","modified":1480580781386,"shasum":"026c7313e583933c27bf4eecd76d6e31acc550f5"},{"_id":"public/scoi2015-password/index.html","modified":1480580781512,"shasum":"b9ed8d217edc6a7568d9a52bddb0a692000be153"},{"_id":"public/scoi2015-light/index.html","modified":1480580781618,"shasum":"1528fc05475e2689af84ea442a80fb4884ccf037"},{"_id":"public/bzoj-2143/index.html","modified":1480580781718,"shasum":"6c7eea577cf57f95d6fff0fb559a2113dd10cc93"},{"_id":"public/scoi2015-flag/index.html","modified":1480580781803,"shasum":"f4965b6ae34bd516397b8c0218d7f5df34692f97"},{"_id":"public/scoi2015-message/index.html","modified":1480580781901,"shasum":"a24791a46ab4274e75dd9c80ecf41390b15a767e"},{"_id":"public/scoi2015-matrix/index.html","modified":1480580782016,"shasum":"fb367c0e763cb2b708b532d330ea8490bf5376a0"},{"_id":"public/20160318-color/index.html","modified":1480580782214,"shasum":"ebe7353663d3dd4df9eb61deedbb428ee730b2c0"},{"_id":"public/20160319-candy/index.html","modified":1480580782319,"shasum":"2399700fd9c615f769d74e08e6eda8753e25af93"},{"_id":"public/20160319-set/index.html","modified":1480580782433,"shasum":"76c6f54088f661da11f0e4be33668228ce404555"},{"_id":"public/sdoi2008-cave/index.html","modified":1480580782539,"shasum":"dc0e58c797695515cc279b7fabc2c6dc2da39fb5"},{"_id":"public/combinatorics-notes/index.html","modified":1480580782703,"shasum":"6961c6502f9005efa2b03019a68a25af3c324e56"},{"_id":"public/uva-10253/index.html","modified":1480580782814,"shasum":"17444ce63ccb145e9a5129d5d719aba397662764"},{"_id":"public/uva-11361/index.html","modified":1480580782920,"shasum":"c8b1b254292d0ac62e8046f81c20764d86445371"},{"_id":"public/bigint-template/index.html","modified":1480580783005,"shasum":"a1e687a176255d000bcc55c257aec6fb63020570"},{"_id":"public/uva-1362/index.html","modified":1480580783071,"shasum":"d9b2b3be20d28f375aa14da451608a0b60d12fa4"},{"_id":"public/poj-1737/index.html","modified":1480580783179,"shasum":"8659569282785fb5aa9f9668fe553832afb1ad44"},{"_id":"public/uva-11174/index.html","modified":1480580783269,"shasum":"8af8060ece21cdf45fd88d51679fc1f6b0bee4f6"},{"_id":"public/uva-11137/index.html","modified":1480580783333,"shasum":"73c61eef8050df7fe4f4f153d3b6a0da71a662c8"},{"_id":"public/uva-11375/index.html","modified":1480580783404,"shasum":"aff67f56c5f3986eb45803bbd194b9d4316b4c03"},{"_id":"public/uva-11538/index.html","modified":1480580783476,"shasum":"f426b6acdd4dc2c8bbb114d7ff95bd15f3187330"},{"_id":"public/uva-11806/index.html","modified":1480580783550,"shasum":"a032ee563a300745896eeb03ef2fe279c3688797"},{"_id":"public/poj-2728/index.html","modified":1480580783617,"shasum":"eac84e5b3cf0f3b59da12ace553851e8edab115f"},{"_id":"public/apio2009-atm/index.html","modified":1480580783703,"shasum":"de98fa8ad4e892350fe5234986f8eed692c07527"},{"_id":"public/noi2006-profit/index.html","modified":1480580783789,"shasum":"06b91cb8173809b7ed9f164604ea180ea1ba2931"},{"_id":"public/scoi2007-repair/index.html","modified":1480580783880,"shasum":"7a321632eefc57c7aa7098fc4a968b7439ce3315"},{"_id":"public/ahoi2008-meet/index.html","modified":1480580783980,"shasum":"75460b61ca5a2f955cc4db69d4d2696f0fae95f2"},{"_id":"public/scoi2010-game/index.html","modified":1480580784040,"shasum":"57a57e0c070af76bcf8fda8a3d89bb54b775c133"},{"_id":"public/virtualbox-archlinux/index.html","modified":1480580784096,"shasum":"d5eed7215dfc3453123ff603a7533544c3535877"},{"_id":"public/noi2003-editor/index.html","modified":1480580784226,"shasum":"2194fb8e87fd51100e0660263ea6581aa1615a96"},{"_id":"public/scoi2011-candy/index.html","modified":1480580784338,"shasum":"7e61cdce60922db24d6e58fb475264a12b1a81b2"},{"_id":"public/haoi2006-cow/index.html","modified":1480580784431,"shasum":"c87bb06af7d2f7cd46ddbca8b7d009f73817b417"},{"_id":"public/codevs-2822/index.html","modified":1480580784523,"shasum":"4855e2dcd07ec2709282368f932c55708d4182e0"},{"_id":"public/tarjan-scc-notes/index.html","modified":1480580784632,"shasum":"48c5ad465fd9be88e330176f1af88d80a879a331"},{"_id":"public/sdoi2010-starrace/index.html","modified":1480580784771,"shasum":"83b37e2f00efc414472e08256cc99d3fedd03762"},{"_id":"public/sdoi2015-war/index.html","modified":1480580784962,"shasum":"0a1adb10528d2db8895ab778865250a24c4e7d04"},{"_id":"public/cogs-741/index.html","modified":1480580785126,"shasum":"b80e3793319cd36df06bd46acf30e0b2469d4471"},{"_id":"public/cogs-740/index.html","modified":1480580785266,"shasum":"6cab232dc3c35ce139ab9f37ec3f628b6d610406"},{"_id":"public/ctsc1999-home/index.html","modified":1480580785398,"shasum":"ccefcf33825ea9fb8343c5db30873302f7bec0d0"},{"_id":"public/cogs-742/index.html","modified":1480580785557,"shasum":"929bee8cb42e29d29e33342f23aafae6798ea2c7"},{"_id":"public/cogs-739/index.html","modified":1480580785692,"shasum":"fe39e3d5dc3ef2a48f36686ab0b0b6c565a1607c"},{"_id":"public/jsoi2008-maxnumber/index.html","modified":1480580785842,"shasum":"02c529ab419b436a53977049d8e3bf7ad811cfb4"},{"_id":"public/edmonds-karp-notes/index.html","modified":1480580785927,"shasum":"7e6b5c86e2fc14d894c7ae1602d3cc985a075c9d"},{"_id":"public/noip2010-prison/index.html","modified":1480580786009,"shasum":"495ecc4f077230c21baf663d1d2fb84ee9c6c4fd"},{"_id":"public/cogs-746/index.html","modified":1480580786105,"shasum":"631ffeb481805b2b5e01d09655721a6c955733ff"},{"_id":"public/cogs-738/index.html","modified":1480580786216,"shasum":"a508eb04e05aada0ffebd0c54c25a37b141163e5"},{"_id":"public/cogs-734/index.html","modified":1480580786304,"shasum":"687967f4fb582b9b047e0d683af67c3d3ce943f7"},{"_id":"public/cogs-439/index.html","modified":1480580786385,"shasum":"b1e84489161d504cfced565a470fa70d2ed23de3"},{"_id":"public/cogs-727/index.html","modified":1480580786494,"shasum":"f499be5c65387a37786fc6a6f25ea02362b42aaa"},{"_id":"public/cogs-731/index.html","modified":1480580786607,"shasum":"d7178d9ae4e89053e0eb714468ba50f7b63d8a3b"},{"_id":"public/cogs-729/index.html","modified":1480580786692,"shasum":"f21eea9f9569355cebbb97546fadbf98e1f0c7f0"},{"_id":"public/cogs-396/index.html","modified":1480580786743,"shasum":"b33d8e32cb70e336ababdb03c8203757ffd432ff"},{"_id":"public/cogs-728/index.html","modified":1480580786836,"shasum":"092235aa0c330938de8222068fd872a04478cf14"},{"_id":"public/cogs-14/index.html","modified":1480580786920,"shasum":"97ce95e5895756fc67d5edcb75316c032aecbbe0"},{"_id":"public/bzoj-2683/index.html","modified":1480580787012,"shasum":"f28c9dc0d9c8b5a2997f8046264f5dbc11d93308"},{"_id":"public/codevs-1563/index.html","modified":1480580787082,"shasum":"e933306dbb42c5d62693c316882b64b921bcf9f8"},{"_id":"public/gnu-debugger/index.html","modified":1480580787169,"shasum":"b5fae393709730c3a2d8c8a8431cc3af258334ce"},{"_id":"public/dinic-notes/index.html","modified":1480580787255,"shasum":"8e97792e8b8b42baa21f6e6dfbb24dc48da70566"},{"_id":"public/markdown-latex-helper/index.html","modified":1480580787302,"shasum":"cfdec09902884d2f6858204d591619db7d0b4155"},{"_id":"public/bzoj-1756/index.html","modified":1480580787393,"shasum":"c4be9c776bee67541d0a774442ef44d8da33350c"},{"_id":"public/noi2004-cashier/index.html","modified":1480580787510,"shasum":"9670a3b5ededf8c980230012e62b751fba00f542"},{"_id":"public/bzoj-1477/index.html","modified":1480580787593,"shasum":"e9c1c39c5d3e114f5ad1cb1e8a6147bd9132711c"},{"_id":"public/noi2015-manager/index.html","modified":1480580787732,"shasum":"5c8d6aba6e9008522beb445d956ee59905b0e726"},{"_id":"public/noi2015-prog/index.html","modified":1480580787877,"shasum":"1fdcb1911c69320c1878989127d610b419ec3081"},{"_id":"public/number-theory-notes-1/index.html","modified":1480580788061,"shasum":"4750794b0648d634b9276b25348d3aa77ec29d34"},{"_id":"public/noip2012-mod/index.html","modified":1480580788135,"shasum":"2f109d0ae466ea89d5df37fcd90e2e16170ff20f"},{"_id":"public/link-cut-tree-notes/index.html","modified":1480580788347,"shasum":"41c709a9dcc17a4e624cd8e8461066bfc405e903"},{"_id":"public/splay-notes-3/index.html","modified":1480580788513,"shasum":"f60beddac2010bfff4d8dfb8a4dda0b76b385de1"},{"_id":"public/bzoj-1251/index.html","modified":1480580788672,"shasum":"10fd3e124d9114d37b96270dc157396f33fca408"},{"_id":"public/noip2006-budget/index.html","modified":1480580788750,"shasum":"3ca36708d1c8bf34b482bdd58118c1016921e4ec"},{"_id":"public/bzoj-2442/index.html","modified":1480580788857,"shasum":"f3776719dd0d07b1196c823954fc89ccc70f416b"},{"_id":"public/codevs-3269-monotone-queue/index.html","modified":1480580788954,"shasum":"b113fb41fe02b70bcc5ec7f7d5349d8919b79522"},{"_id":"public/monotone-queue-notes/index.html","modified":1480580789013,"shasum":"2720c0e5923e1e73052bb02d47fa2b27e5179aa3"},{"_id":"public/codevs-1345/index.html","modified":1480580789080,"shasum":"96673fef5dc3f7d331f87fa4650b27be438b4d9c"},{"_id":"public/noip2003-game/index.html","modified":1480580789165,"shasum":"4e9ecb48d7ccd2081fdbaf8998dbe419aedb6a6a"},{"_id":"public/noip2006-energy/index.html","modified":1480580789238,"shasum":"4ab10ac73ed74ab0275321bd3c93db8476ed05b2"},{"_id":"public/tyvj-3317/index.html","modified":1480580789311,"shasum":"e9d2e9e752ac8a174f0aa62158c8689934512b3f"},{"_id":"public/codevs-2598/index.html","modified":1480580789393,"shasum":"184c0419b4e45e1ebb6b4b08828109e5c76b32b3"},{"_id":"public/noip2000-cheng-ji-zui-da/index.html","modified":1480580789461,"shasum":"a7b0ba749942e0ee802b81c6c7c97f1d30e2215a"},{"_id":"public/ctsc1997-course/index.html","modified":1480580789541,"shasum":"7bc3d17997d9ebcffc00aa486656a555bc86641d"},{"_id":"public/codevs-3168-3162/index.html","modified":1480580789660,"shasum":"c5979f34bad52283fa2e5b0d517742f291ccfe37"},{"_id":"public/minimum-spanning-tree-notes/index.html","modified":1480580789797,"shasum":"4dd76e9ffac8a38570b55503c416339bb5546add"},{"_id":"public/system-of-difference-constraints-notes/index.html","modified":1480580789883,"shasum":"712ced0a7ae9284d2b793315c941d0a2e59474bc"},{"_id":"public/kmp-notes/index.html","modified":1480580789958,"shasum":"7a24e80b9a9305e83a621a51afe4935614d2f53d"},{"_id":"public/cut-tree-notes/index.html","modified":1480580790135,"shasum":"dad16761205ded57a36e0da6383187a26559efb9"},{"_id":"public/stl-in-oi/index.html","modified":1480580790251,"shasum":"fab3bc0c4759670e117e12994da025da8a2eb54e"},{"_id":"public/splay-notes-2/index.html","modified":1480580790388,"shasum":"7c6660896a5c2226ea2cc2c923b090d2dd8b3c57"},{"_id":"public/splay-notes-1/index.html","modified":1480580790547,"shasum":"60eff246364a7bc72c2d4b45cf69b0c1228700e8"},{"_id":"public/hnoi2004-pet/index.html","modified":1480580790614,"shasum":"790c996d43986b2100ce0ed6d25eb8ec3bacdb32"},{"_id":"public/codevs-3269/index.html","modified":1480580790722,"shasum":"14ca637e98a5764096332953c332ba4628db2e7d"},{"_id":"public/noi2002-galaxy/index.html","modified":1480580790810,"shasum":"f92cc43b2162a14726519f3f9ddac2b1e808e42e"},{"_id":"public/archives/index.html","modified":1480580790884,"shasum":"10218fc8cf843c679863f3ddeb8f9719f6a317d5"},{"_id":"public/archives/page/2/index.html","modified":1480580790947,"shasum":"a134c4b88e5323cbc60228dc569af9d0945ad5eb"},{"_id":"public/archives/page/3/index.html","modified":1480580791018,"shasum":"4a200a7b5255f859514e4295e650881c886fa36b"},{"_id":"public/archives/page/4/index.html","modified":1480580791080,"shasum":"76f2886cb3a6d7b7d6cad8e881cf95265074be72"},{"_id":"public/archives/page/5/index.html","modified":1480580791152,"shasum":"df7781fdc45d0ad8319e7ea5f9594a0272ce54e4"},{"_id":"public/archives/page/6/index.html","modified":1480580791218,"shasum":"d5fc1114a2f169766c1b64029d1cf57b8ea43a66"},{"_id":"public/archives/page/7/index.html","modified":1480580791290,"shasum":"344fb0ce5648403e49838c325aa4f535bde78de5"},{"_id":"public/archives/page/8/index.html","modified":1480580791362,"shasum":"bf18e297825d0243ec8053740127f0238a4e9925"},{"_id":"public/archives/page/9/index.html","modified":1480580791435,"shasum":"8ff4bf8112aafd4dceddbc8bbf7889ea7ab61ad6"},{"_id":"public/archives/page/10/index.html","modified":1480580791503,"shasum":"00427e361f9322dc13fa70419c0b21275dab20f9"},{"_id":"public/archives/page/11/index.html","modified":1480580791574,"shasum":"1fd35632cd4232f93580cbf3710099b4ecc9696c"},{"_id":"public/archives/page/12/index.html","modified":1480580791646,"shasum":"52d41007d3eef38c16700235f1bb56feacf4c1a6"},{"_id":"public/archives/page/13/index.html","modified":1480580791719,"shasum":"28029305f13503bff073be004aee524391a81609"},{"_id":"public/archives/page/14/index.html","modified":1480580791784,"shasum":"cfde388c8d35d3f6a139cfe923de109042ccfdbd"},{"_id":"public/archives/page/15/index.html","modified":1480580791855,"shasum":"90aea38f37166add67165690bcc72817523f054a"},{"_id":"public/archives/page/16/index.html","modified":1480580791925,"shasum":"43a77d7de799492c7df2e02615b13ab7b4085509"},{"_id":"public/archives/page/17/index.html","modified":1480580791998,"shasum":"1c421b491e815ad3217724a25051c94bf6af2340"},{"_id":"public/archives/page/18/index.html","modified":1480580792070,"shasum":"fa7b3c3a1dc5d4a37056ad718c5210f960ef3f2a"},{"_id":"public/archives/page/19/index.html","modified":1480580792128,"shasum":"99a7850b90399609b3e6a4be3f338a1796141b3d"},{"_id":"public/archives/page/20/index.html","modified":1480580792202,"shasum":"947778b53342f5026dc6088ef0c93a5a700704fd"},{"_id":"public/archives/page/21/index.html","modified":1480580792260,"shasum":"b9bcc13c2918394c1bd3400d52adff382e635c26"},{"_id":"public/archives/page/22/index.html","modified":1480580792326,"shasum":"ffe6f0b00f9edcb36ae4c0bf142e7ae9dd563035"},{"_id":"public/archives/page/23/index.html","modified":1480580792393,"shasum":"74c072024f131e8cb25b4b32c088c04348bdb1f4"},{"_id":"public/archives/page/24/index.html","modified":1480580792465,"shasum":"52d86705da389d976e4f030674d01bfbb502bdb8"},{"_id":"public/archives/page/25/index.html","modified":1480580792538,"shasum":"2427ee20806f5b55374c4bb6a791a7ee2f70fc63"},{"_id":"public/archives/page/26/index.html","modified":1480580792613,"shasum":"3d9f1e0f80d2eff5f444e8e117dae3610a45dc27"},{"_id":"public/archives/page/27/index.html","modified":1480580792677,"shasum":"3aca512dc1be6af987b175317681ebe3bb2c52cf"},{"_id":"public/archives/page/28/index.html","modified":1480580792748,"shasum":"4e1b6f4ab757c8f861e188c686a8f92a9351fe5c"},{"_id":"public/archives/2015/index.html","modified":1480580792805,"shasum":"bdaf47ea1400a01a9cc758e7fd337bc24082fdd7"},{"_id":"public/archives/2015/11/index.html","modified":1480580792836,"shasum":"b6de50657c401e9207e5c0bf067d34e932505ea3"},{"_id":"public/archives/2015/12/index.html","modified":1480580792888,"shasum":"1a33848bdb6998df39d0a19332f649644ecac8a1"},{"_id":"public/archives/2016/index.html","modified":1480580792943,"shasum":"ed01fec8e12ff91ce0756d11ae9957dfc529d5a6"},{"_id":"public/archives/2016/page/2/index.html","modified":1480580793017,"shasum":"9bd3d85bbd0fe14e009e929e96e217ff010b20df"},{"_id":"public/archives/2016/page/3/index.html","modified":1480580793081,"shasum":"ccd9d85984240016a5d2211fd450aa82ce779eaa"},{"_id":"public/archives/2016/page/4/index.html","modified":1480580793155,"shasum":"3e0c27a6cc01f4e16f19e8f5563a95594df01e9d"},{"_id":"public/archives/2016/page/5/index.html","modified":1480580793217,"shasum":"198376cda61c6f84edafad5958026b5c7e4bb3d1"},{"_id":"public/archives/2016/page/6/index.html","modified":1480580793290,"shasum":"f4817b90be63ca3c126eaf1d047371f7449c9876"},{"_id":"public/archives/2016/page/7/index.html","modified":1480580793353,"shasum":"0cd44feec09631adb05cc1cd3d82a94bb1e4f1ec"},{"_id":"public/archives/2016/page/8/index.html","modified":1480580793419,"shasum":"8f64fc8abb6befe3610de5bf1aa6a5ff1778f732"},{"_id":"public/archives/2016/page/9/index.html","modified":1480580793476,"shasum":"5e96cd2488b74ec225e51cd99a82d089fabbc06e"},{"_id":"public/archives/2016/page/10/index.html","modified":1480580793552,"shasum":"bdec791f3db4f3da63d4034f3763d97f105285f5"},{"_id":"public/archives/2016/page/11/index.html","modified":1480580793611,"shasum":"4899198d4b9838ad244d06b0e13e02ffec7461d4"},{"_id":"public/archives/2016/page/12/index.html","modified":1480580793691,"shasum":"76586e6e229bdd6a5f1189ffb10748770d6a5b97"},{"_id":"public/archives/2016/page/13/index.html","modified":1480580793755,"shasum":"046d1bf072446e9337d5faf9d6bf9f44f7573597"},{"_id":"public/archives/2016/page/14/index.html","modified":1480580793828,"shasum":"0c0647cb7874424a979dfbd47438f0bb13ee800e"},{"_id":"public/archives/2016/page/15/index.html","modified":1480580793891,"shasum":"2f7fffbc139b6182bd75f25fc89941c8958c1999"},{"_id":"public/archives/2016/page/16/index.html","modified":1480580793963,"shasum":"5b5fc8d7dfac5ffa33aba8c936e6268230dbfc86"},{"_id":"public/archives/2016/page/17/index.html","modified":1480580794029,"shasum":"8903cfb8c1f1312acac01d4c7c5c15795895482a"},{"_id":"public/archives/2016/page/18/index.html","modified":1480580794104,"shasum":"da9c3389479ab81146708e3da1e6674e25a8c625"},{"_id":"public/archives/2016/page/19/index.html","modified":1480580794169,"shasum":"a621d485473aaf54f1f3acea1e5080d348704b30"},{"_id":"public/archives/2016/page/20/index.html","modified":1480580794239,"shasum":"504f9ca002097bad311bf7abab0c1d75c6badd3c"},{"_id":"public/archives/2016/page/21/index.html","modified":1480580794303,"shasum":"c8759a97e0bd2c8b7fd5b2cbe62dd67086ba2ca3"},{"_id":"public/archives/2016/page/22/index.html","modified":1480580794382,"shasum":"6e3d91361dd3c31c73377cb005e9e5932704a1ba"},{"_id":"public/archives/2016/page/23/index.html","modified":1480580794450,"shasum":"9d2a04db43d1e315b887f27753d4c4a953b74e5f"},{"_id":"public/archives/2016/page/24/index.html","modified":1480580794523,"shasum":"d6c60f7778232cf7a19ca255d161cde3a18a82a3"},{"_id":"public/archives/2016/page/25/index.html","modified":1480580794593,"shasum":"edf61b53b4e0f5f21b16c9985bf62eb5de5d403a"},{"_id":"public/archives/2016/page/26/index.html","modified":1480580794666,"shasum":"d8b23de9ef42235d4a30bab60667d2e49b6d9b07"},{"_id":"public/archives/2016/page/27/index.html","modified":1480580794731,"shasum":"8c3c8002c6fa6d4cd87ab7b8a4ee5badcccd0d38"},{"_id":"public/archives/2016/page/28/index.html","modified":1480580794778,"shasum":"06f9ed62cbc9afbb3a1cc8a565feb89c8ffc7c45"},{"_id":"public/archives/2016/01/index.html","modified":1480580794838,"shasum":"642a939a521f136ccb79de60a3f102f6b17d1ecd"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1480580794911,"shasum":"8d20c355e0a5b58f7bbd76be9b142bb7963b5f6e"},{"_id":"public/archives/2016/01/page/3/index.html","modified":1480580794958,"shasum":"f2ab2166ef5ca14dc53ee0bd94c26da0b68a35e2"},{"_id":"public/archives/2016/02/index.html","modified":1480580795021,"shasum":"dcf5881e74900ed7ca5f163c1e6970dff8977ac6"},{"_id":"public/archives/2016/02/page/2/index.html","modified":1480580795098,"shasum":"eaccd86c203e2776d8be2bddba17a4b1f377ace5"},{"_id":"public/archives/2016/02/page/3/index.html","modified":1480580795138,"shasum":"9cbae056d12b580d331be07f6c4ed78894ef4729"},{"_id":"public/archives/2016/03/index.html","modified":1480580795216,"shasum":"603f5639016a1db70596be59b407102606717f89"},{"_id":"public/archives/2016/03/page/2/index.html","modified":1480580795279,"shasum":"cc69ffb4cb7cf8630ac689fd0adc3ad89ab58b0f"},{"_id":"public/archives/2016/03/page/3/index.html","modified":1480580795352,"shasum":"8dd390ac656b3a6c77a0b9af17df0f963633740d"},{"_id":"public/archives/2016/03/page/4/index.html","modified":1480580795376,"shasum":"6351aa0174897dc45e7ddedc5b6e12187480a239"},{"_id":"public/archives/2016/04/index.html","modified":1480580795449,"shasum":"8dec3c66cf24981ca7a568a7bb4615dd59d27dd3"},{"_id":"public/archives/2016/04/page/2/index.html","modified":1480580795514,"shasum":"45372b87c28d22313cb8e69a719f02b4a3272b84"},{"_id":"public/archives/2016/04/page/3/index.html","modified":1480580795585,"shasum":"5d4d408d194c6f701a01155ca2d7ec5072ec3e4f"},{"_id":"public/archives/2016/04/page/4/index.html","modified":1480580795629,"shasum":"420d4d95cf151219cdc3ef71bedfff6e4ffb4def"},{"_id":"public/archives/2016/05/index.html","modified":1480580795694,"shasum":"14534f0171621fec88ad8c9a270ad693f74e3621"},{"_id":"public/archives/2016/05/page/2/index.html","modified":1480580795754,"shasum":"df1758a9a2dbc1c0b3764b4fd66beb54d0eb01f3"},{"_id":"public/archives/2016/05/page/3/index.html","modified":1480580795785,"shasum":"47d6b1de0d060abddeb7c13c81edaea2b0861466"},{"_id":"public/archives/2016/06/index.html","modified":1480580795856,"shasum":"3cfa28586600f17babdd2cbb76b47b7897e2af76"},{"_id":"public/archives/2016/06/page/2/index.html","modified":1480580795944,"shasum":"31d31578b2954232404fde8811e09a66c8381cd5"},{"_id":"public/archives/2016/06/page/3/index.html","modified":1480580796153,"shasum":"a8f46350f5caab4fe71607b37de76d3252d74bfa"},{"_id":"public/archives/2016/06/page/4/index.html","modified":1480580796254,"shasum":"b661b0f165f521c3f2c530444f8898470b941a0f"},{"_id":"public/archives/2016/07/index.html","modified":1480580796353,"shasum":"f3d5e6a438d4974619476d7bf7a7ad3f47939205"},{"_id":"public/archives/2016/07/page/2/index.html","modified":1480580796406,"shasum":"9d6fba2a789dfb819bda411c2b167d6ac3a6691e"},{"_id":"public/archives/2016/08/index.html","modified":1480580796444,"shasum":"0dc34c38d7680c8c72a40a374a9244fcbfcacb92"},{"_id":"public/archives/2016/09/index.html","modified":1480580796521,"shasum":"dc0a101da603d1928426c557e00744d63c93d155"},{"_id":"public/archives/2016/09/page/2/index.html","modified":1480580796590,"shasum":"e89f0ffa0da620584399d9a3e7a768f13abd8fcb"},{"_id":"public/archives/2016/09/page/3/index.html","modified":1480580796657,"shasum":"895bde77a2d564559f2b81f2e6395d25b61aa3dd"},{"_id":"public/archives/2016/09/page/4/index.html","modified":1480580796680,"shasum":"fdfb12cc64a08002d3784fe0a3e961ab95fc8843"},{"_id":"public/archives/2016/10/index.html","modified":1480580796743,"shasum":"4fb05f175818e676b261b39edef4eb154ecf12e8"},{"_id":"public/archives/2016/10/page/2/index.html","modified":1480580796815,"shasum":"8f4a4c0417fe2101af058a2bc71ac4dae8da67b3"},{"_id":"public/archives/2016/10/page/3/index.html","modified":1480580796860,"shasum":"6411c1b3e659114ecb4f4d5771754947d244d401"},{"_id":"public/archives/2016/11/index.html","modified":1480580796925,"shasum":"f2df0fdc2eb011b150d53b4d59b7538283bbae3a"},{"_id":"public/archives/2016/11/page/2/index.html","modified":1480580796987,"shasum":"db8e078a30cd5badd90bb33ddd3838539a6ac361"},{"_id":"public/archives/2016/11/page/3/index.html","modified":1480580797009,"shasum":"9964bf79cad72e85d179b42e8227218794a51a39"},{"_id":"public/archives/2016/12/index.html","modified":1480580797052,"shasum":"a86d0e557b5e076fdc799d87999e636011c4794f"},{"_id":"public/categories/oi/index.html","modified":1480580797119,"shasum":"18a9227b5a26b5c0d10fb1c8a8ed775895eb1c0c"},{"_id":"public/categories/oi/page/2/index.html","modified":1480580797193,"shasum":"305e99132cb1c34834274b66388a10ce9ba1225d"},{"_id":"public/categories/oi/page/3/index.html","modified":1480580797254,"shasum":"d1ffc8872faa29390b2374ea809fab69e17a116d"},{"_id":"public/categories/oi/page/4/index.html","modified":1480580797329,"shasum":"cf33953386e8c86a515b15458088007c57eb42df"},{"_id":"public/categories/oi/page/5/index.html","modified":1480580797397,"shasum":"5bd5529c20fb0e3c4da92e28e64f64bbb231b7f1"},{"_id":"public/categories/oi/page/6/index.html","modified":1480580797466,"shasum":"75e3feb4049640bf202604291d960f81dabe6a30"},{"_id":"public/categories/oi/page/7/index.html","modified":1480580797532,"shasum":"d130c72571654845bebcb4cba986b73267336be5"},{"_id":"public/categories/oi/page/8/index.html","modified":1480580797604,"shasum":"8fbd71eeb01aae888c7b61ff952a19c2412b8945"},{"_id":"public/categories/oi/page/9/index.html","modified":1480580797676,"shasum":"6f24983ec555d2b712731ec513b19a4d8b7d2097"},{"_id":"public/categories/oi/page/10/index.html","modified":1480580797743,"shasum":"0571968b172e1f3d0304e6243625508ce65c9b4d"},{"_id":"public/categories/oi/page/11/index.html","modified":1480580797818,"shasum":"0f7422d3ee3c1fb334dd5607f00ea1c79c9b9b9c"},{"_id":"public/categories/oi/page/12/index.html","modified":1480580797884,"shasum":"eac50999dfc0de55721d86bdf292629b0937be0f"},{"_id":"public/categories/oi/page/13/index.html","modified":1480580797958,"shasum":"09f0c573a9d94a088c4ec62767c4badc4788b39c"},{"_id":"public/categories/oi/page/14/index.html","modified":1480580798025,"shasum":"36184f50d3932015f695b1776c4c630ef19c6ccc"},{"_id":"public/categories/oi/page/15/index.html","modified":1480580798101,"shasum":"d056c28d447ae665b26d1e4c52489e150a9aa640"},{"_id":"public/categories/oi/page/16/index.html","modified":1480580798167,"shasum":"5ab8e790d82082f3d4abfbbceaf2ab0ba1e2b2f6"},{"_id":"public/categories/oi/page/17/index.html","modified":1480580798251,"shasum":"de673b92792c425d608802e4e91085f64d3af8f8"},{"_id":"public/categories/oi/page/18/index.html","modified":1480580798325,"shasum":"344bcff6eaa15846c9255d61538bde218b50cd43"},{"_id":"public/categories/oi/page/19/index.html","modified":1480580798392,"shasum":"4d7185a20a7f5e16acd0a8b8071beffa9055c024"},{"_id":"public/categories/oi/page/20/index.html","modified":1480580798461,"shasum":"d572131f4f6f5de436aedc2b65219019252fd434"},{"_id":"public/categories/oi/page/21/index.html","modified":1480580798529,"shasum":"ce29aaca6047776f913b889cce438c49fff3dd25"},{"_id":"public/categories/oi/page/22/index.html","modified":1480580798604,"shasum":"63ee675af1bcd3e16e3f52098757f4a40bef995a"},{"_id":"public/categories/oi/page/23/index.html","modified":1480580798671,"shasum":"40b999f11b266237a57e7c2d4a88e5349f586647"},{"_id":"public/categories/oi/page/24/index.html","modified":1480580798747,"shasum":"48994e53d63ea4f9ac7a89021907276ea61eacf9"},{"_id":"public/categories/oi/page/25/index.html","modified":1480580798825,"shasum":"c3f426a43943e54a384bfa5ceb2cf26e7653a129"},{"_id":"public/categories/oi/page/26/index.html","modified":1480580799106,"shasum":"ef0bda0be0bf028ebf7c7b2224636e70b8c5b9ac"},{"_id":"public/categories/oi/page/27/index.html","modified":1480580799178,"shasum":"d72498ad5c6c0410dfbba91b570d2cf3cb2b87ac"},{"_id":"public/categories/oi/page/28/index.html","modified":1480580799209,"shasum":"b4e0d27a595ae7c04bf9586f70f841760e68ec91"},{"_id":"public/categories/geek/index.html","modified":1480580799237,"shasum":"cdf85cb0508585c7349ebbb888e209f1e4cf7a56"},{"_id":"public/categories/diary/index.html","modified":1480580799284,"shasum":"f4b14875148feb085567d8ddbef380c465993803"},{"_id":"public/atom.xml","modified":1480580799299,"shasum":"6946cc5b76ca1790e5a71a132f6df7c2fde8e43b"},{"_id":"public/index.html","modified":1480580799506,"shasum":"50029320f70171ff5a0ff01e0620f530112dea95"},{"_id":"public/page/2/index.html","modified":1480580799648,"shasum":"82652209068d69fa1ab2c73408a19a5c1148bf61"},{"_id":"public/page/3/index.html","modified":1480580799778,"shasum":"3b296205f859e9708ee3aad53a0cde4750e4cee7"},{"_id":"public/page/4/index.html","modified":1480580799905,"shasum":"1fdfb58ab0cf02314d0c9b709c29348b1f924552"},{"_id":"public/page/5/index.html","modified":1480580800081,"shasum":"da803d882b7275c71ae719b6e69591f1e990882b"},{"_id":"public/page/6/index.html","modified":1480580800372,"shasum":"427e6fe1f7bd8e57cee91f4545b7e5772ce8df96"},{"_id":"public/page/7/index.html","modified":1480580800527,"shasum":"6ccee969a5ba71d30d510671ac45e11db326f14b"},{"_id":"public/page/8/index.html","modified":1480580800730,"shasum":"e70c1fb683fbaed147e5d6cada0285539d6d1f54"},{"_id":"public/page/9/index.html","modified":1480580800926,"shasum":"b2d3f8ba144637d8aaee285a14c7a8e1cddbd6d3"},{"_id":"public/page/10/index.html","modified":1480580801120,"shasum":"ea688e1c26e49ac5cf9a5439569088bdd4782387"},{"_id":"public/page/11/index.html","modified":1480580801313,"shasum":"110d7916cfd290f2897d4e287121e1268a1cf4b2"},{"_id":"public/page/12/index.html","modified":1480580801531,"shasum":"54c1b7cdeaf3bd6881fd71622ee3790d815b0392"},{"_id":"public/page/13/index.html","modified":1480580801764,"shasum":"e5487d6a3be449b31da3de9d4983d4bc37d86029"},{"_id":"public/page/14/index.html","modified":1480580801894,"shasum":"33454633878f8a8ed609988021082298551608b5"},{"_id":"public/page/15/index.html","modified":1480580802051,"shasum":"0392db88aa5224565c30a44d84fdb2a6a3e836cb"},{"_id":"public/page/16/index.html","modified":1480580802276,"shasum":"6cb9c3c16a133409625c626e005fba1c17d6a61d"},{"_id":"public/page/17/index.html","modified":1480580802440,"shasum":"4cad6a183343abcc581ebeb766f1519e21f27679"},{"_id":"public/page/18/index.html","modified":1480580802577,"shasum":"bea7a7878228e2f9b12f88c61266d6b6aa450405"},{"_id":"public/page/19/index.html","modified":1480580802733,"shasum":"7343093d4c227fabeb8ac6226dc3d40937f621eb"},{"_id":"public/page/20/index.html","modified":1480580803000,"shasum":"9b499ce192049ac609814c684c30206fdb977212"},{"_id":"public/page/21/index.html","modified":1480580803149,"shasum":"ad0c6dd71a8e45cd59b0ec2c762475798121da27"},{"_id":"public/page/22/index.html","modified":1480580803309,"shasum":"5627cc8c28cfaa7926173d8896dc9a162499cc38"},{"_id":"public/page/23/index.html","modified":1480580803429,"shasum":"d3796ab4ec63ffeec16668fdbbe5b2e052681931"},{"_id":"public/page/24/index.html","modified":1480580803551,"shasum":"c217ec96fc3f826f48c6d12ccf2f68bce8e09e4b"},{"_id":"public/page/25/index.html","modified":1480580803663,"shasum":"53bbdf776aff9a5141000b001225fbe4c9cf404a"},{"_id":"public/page/26/index.html","modified":1480580803788,"shasum":"e7790864b95e75ddba3b23af9b2e58828d329ef1"},{"_id":"public/page/27/index.html","modified":1480580803906,"shasum":"224b64890fb9643b831fea7efaa40e4219714b55"},{"_id":"public/page/28/index.html","modified":1480580804017,"shasum":"5654604d716444ecace1e1113a73a7410ac42c83"},{"_id":"public/sitemap.xml","modified":1480580804019,"shasum":"cd2285d8024afb15d0f9876ca4a0e203aae0e376"},{"_id":"public/content.json","modified":1480580804034,"shasum":"fb668e1d0a6e855a47f2f878c76b1c934dcb5d1e"},{"_id":"public/tag//index.html","modified":1480580804155,"shasum":"bea5d2f291e1196faca0468dc34b198a0ec12e3c"},{"_id":"public/tag//page/2/index.html","modified":1480580804199,"shasum":"8569359fff064b9f8367ebc70e9b85b973450828"},{"_id":"public/tag//index.html","modified":1480580804267,"shasum":"c58fb1a60e6e142b4cdd43297ca7c1c1adf147b2"},{"_id":"public/tag//page/2/index.html","modified":1480580804285,"shasum":"d1d074075ba4c7b982b578dbb53a9d3864c6935c"},{"_id":"public/tag//index.html","modified":1480580804350,"shasum":"d3c4845dc7bed7d3d1bcc2eb34d3e904feece127"},{"_id":"public/tag//index.html","modified":1480580804409,"shasum":"c727eb8e619d5c2636562cc52324fbd9bf77b513"},{"_id":"public/tag//page/2/index.html","modified":1480580804477,"shasum":"68d5f3d25846e1359470197ea1f602bbb7ff8567"},{"_id":"public/tag//page/3/index.html","modified":1480580804537,"shasum":"1e0ad245819ce1e7124bb990f7c12d104a16a387"},{"_id":"public/tag//page/4/index.html","modified":1480580804592,"shasum":"fafe3a17653991b642513b896d8304efa9b50dbf"},{"_id":"public/tag//index.html","modified":1480580804651,"shasum":"bcb23c945dd75683d40ebf00bb680111e029aeb4"},{"_id":"public/tag//page/2/index.html","modified":1480580804705,"shasum":"0b75a6516833612c394a4984529f51a7b31e5d8b"},{"_id":"public/tag/bzoj/index.html","modified":1480580804761,"shasum":"309e5d332e0498c8be793b4c34018454eb707439"},{"_id":"public/tag/bzoj/page/2/index.html","modified":1480580804833,"shasum":"2b36ec6dd4030633564683af0d7635e65492a854"},{"_id":"public/tag/bzoj/page/3/index.html","modified":1480580804897,"shasum":"c7d2da8c5f9be1a92a102219f5d20eda8c167ab0"},{"_id":"public/tag/bzoj/page/4/index.html","modified":1480580804965,"shasum":"5dfb0ed0cb4373a537c6b4bdde97ce5db005a7c4"},{"_id":"public/tag/bzoj/page/5/index.html","modified":1480580805025,"shasum":"80fa9125e1a715e011ef9636e608b753fe8e421f"},{"_id":"public/tag/bzoj/page/6/index.html","modified":1480580805088,"shasum":"e3fc6eaa76e5c7a55e0ab75e05245d07b6da81ec"},{"_id":"public/tag/bzoj/page/7/index.html","modified":1480580805147,"shasum":"f067ca86e0bf83dd9843c84a7c0584c9cd3f40bb"},{"_id":"public/tag/bzoj/page/8/index.html","modified":1480580805216,"shasum":"672f5fa4d953785121a8ce0ee88ec9042e543f8d"},{"_id":"public/tag/bzoj/page/9/index.html","modified":1480580805276,"shasum":"2e83c674216569928e4c2278e3c181d6f4e2070b"},{"_id":"public/tag/bzoj/page/10/index.html","modified":1480580805346,"shasum":"75e9ec9b602709e4a95644847e9846f853952b3d"},{"_id":"public/tag/bzoj/page/11/index.html","modified":1480580805427,"shasum":"1673910f02b6f29f13910991ff859c5933c3dc65"},{"_id":"public/tag/bzoj/page/12/index.html","modified":1480580805487,"shasum":"f9bed557901c9c91136a14418b8915c3da0dcf3e"},{"_id":"public/tag/bzoj/page/13/index.html","modified":1480580805571,"shasum":"0a7043cc7fe16abe3aa518d381d162c7a86c36dc"},{"_id":"public/tag/bzoj/page/14/index.html","modified":1480580805639,"shasum":"a17e400e8b2700018c025a753576ad7b9baa3ad9"},{"_id":"public/tag/bzoj/page/15/index.html","modified":1480580805728,"shasum":"92b642a5a5bc7a88a1d45da8c0ca173344fa2658"},{"_id":"public/tag/bzoj/page/16/index.html","modified":1480580805789,"shasum":"d501486c4f0540e0a72db42af49f251dedf3890a"},{"_id":"public/tag/bzoj/page/17/index.html","modified":1480580805859,"shasum":"0bedf936411efc8a1037c906c0a8a98a8d0f364f"},{"_id":"public/tag/bzoj/page/18/index.html","modified":1480580805880,"shasum":"c3c8eb9b77ac18ca796b9090fed34b5ff018aebb"},{"_id":"public/tag/zjoi/index.html","modified":1480580805948,"shasum":"edb0ffb67166f2877505a5292fefa320e80c9f88"},{"_id":"public/tag/fft/index.html","modified":1480580805983,"shasum":"100dd8cff5aae3443352227b6828210f614d01b1"},{"_id":"public/tag//index.html","modified":1480580806055,"shasum":"03207c1e3da8a0332c5b2e2fefce56a34a50329b"},{"_id":"public/tag//page/2/index.html","modified":1480580806117,"shasum":"b206be3a1abf7acbcd25f3b078fa22fe1c0ae5d7"},{"_id":"public/tag//page/3/index.html","modified":1480580806187,"shasum":"1646864c31005f4739c2f71560c29b3a5b4789f6"},{"_id":"public/tag//page/4/index.html","modified":1480580806282,"shasum":"07f3117a54c0594e0900881c4592657e2cfb23b1"},{"_id":"public/tag//page/5/index.html","modified":1480580806348,"shasum":"86c9aa6b0b8219c1562855339f499c63385231cc"},{"_id":"public/tag//index.html","modified":1480580806470,"shasum":"825139202fbbfe56ada6d3311f39bd381e538a04"},{"_id":"public/tag//page/2/index.html","modified":1480580806560,"shasum":"615a608ee814e4ede8e4bf9700643eee00ab88ac"},{"_id":"public/tag//page/3/index.html","modified":1480580806623,"shasum":"fb368051feeeadb9da911bc0943ed22b000955c1"},{"_id":"public/tag//page/4/index.html","modified":1480580806690,"shasum":"83823257888ff0df9c11c5b446af1df41d6215fb"},{"_id":"public/tag//page/5/index.html","modified":1480580806750,"shasum":"93e6357ddce4908d35cbd8142d2f40fdce29d078"},{"_id":"public/tag/dinic/index.html","modified":1480580806861,"shasum":"efb9841c457722b256a76e3d4ab34b3e56e9db51"},{"_id":"public/tag/dinic/page/2/index.html","modified":1480580806978,"shasum":"fe35a0a7d5a3deaf8db7abbbe22feca3b52c039e"},{"_id":"public/tag/dinic/page/3/index.html","modified":1480580807119,"shasum":"9c4be005531b886bc2ec16f7a4e6e61443cbf4d3"},{"_id":"public/tag/dinic/page/4/index.html","modified":1480580807176,"shasum":"c24c9343c3df2a5e534eca640f2de0bbb38e4e5f"},{"_id":"public/tag//index.html","modified":1480580807330,"shasum":"fec5e1c6240481f606c79909cc8a8c3ef7c2cbc0"},{"_id":"public/tag//page/2/index.html","modified":1480580807406,"shasum":"1660da16a451bf3718b33c5b2790a0f271905082"},{"_id":"public/tag/edmonds-karp/index.html","modified":1480580807539,"shasum":"570ac5c5de2ab3f7dc955a5e6d155295a200e06c"},{"_id":"public/tag/edmonds-karp/page/2/index.html","modified":1480580807598,"shasum":"8005261c142a61a5df9a93181fddf0d999e00d3e"},{"_id":"public/tag//index.html","modified":1480580807713,"shasum":"88a00e654b25864b8ec3dfc36a9b25a91857ec48"},{"_id":"public/tag//page/2/index.html","modified":1480580807784,"shasum":"3ab1ef8fd11ae75d7a69dae7f0f2e235f4ec27ae"},{"_id":"public/tag/dp/index.html","modified":1480580807877,"shasum":"c855cd12ab1936a94bbab6079c27acb4f20b8ad2"},{"_id":"public/tag/dp/page/2/index.html","modified":1480580808025,"shasum":"a12d297f5a0920a329fc531b53029c0fb1b5accd"},{"_id":"public/tag/dp/page/3/index.html","modified":1480580808168,"shasum":"5e5eb728993e3dc8ba7e2899eade5aa6be6730a6"},{"_id":"public/tag/dp/page/4/index.html","modified":1480580808310,"shasum":"756cd8add17509e905082223c5506bcd48883000"},{"_id":"public/tag/dp/page/5/index.html","modified":1480580808425,"shasum":"7a9cddeb404ee1eb5eff10e0627f55b7493c4843"},{"_id":"public/tag/dp/page/6/index.html","modified":1480580808551,"shasum":"afda4d596bf75a3877a7252a3f9db677038a2d3d"},{"_id":"public/tag/dp/page/7/index.html","modified":1480580808603,"shasum":"6f20e75371486778cbd57a593d784a0c2597e4da"},{"_id":"public/tag//index.html","modified":1480580808692,"shasum":"c6478e5f666c32438f5eb31fea3f6ff698bd56a2"},{"_id":"public/tag//page/2/index.html","modified":1480580808731,"shasum":"1885f88ede236677386c33404db455c6fc080cdb"},{"_id":"public/tag/cogs/index.html","modified":1480580808842,"shasum":"789bd566f71a9fdac885ac90de20aa2e4a551d21"},{"_id":"public/tag/cogs/page/2/index.html","modified":1480580808939,"shasum":"2f7ff3f63709e2bddea925a1d76be72950479c12"},{"_id":"public/tag/cogs/page/3/index.html","modified":1480580809046,"shasum":"f3f3a4c5f2d1e6cd6dcb79faefd107cac37f5d2b"},{"_id":"public/tag/cogs/page/4/index.html","modified":1480580809114,"shasum":"8f72c88588832d364f12b9c1de5794fe601f6b9d"},{"_id":"public/tag//index.html","modified":1480580809160,"shasum":"8d2d30bd64530cf6e0f56ab97944bec2ec2838db"},{"_id":"public/tag//index.html","modified":1480580809209,"shasum":"16431d3d97b383c23d81c698db96a2a1f6b9f032"},{"_id":"public/tag//index.html","modified":1480580809286,"shasum":"31cdc98db467945c3adc358fe63516dd34c43ed3"},{"_id":"public/tag//index.html","modified":1480580809392,"shasum":"7e3c5d95b975a7b0bf23f73c7c79ea5c238d97a4"},{"_id":"public/tag//index.html","modified":1480580809428,"shasum":"8d14b54d9c6faf4cf8f31a3697a92d9c8b417879"},{"_id":"public/tag/tarjan/index.html","modified":1480580809562,"shasum":"16b83b2d6131b44a61b6118ae773f5dd55d47f21"},{"_id":"public/tag/tarjan/page/2/index.html","modified":1480580809651,"shasum":"99b9975a88f82405fe5bddeb48940b2cd3772a71"},{"_id":"public/tag//index.html","modified":1480580809760,"shasum":"34d7c6ec50167b826c47674060894b33d3308a95"},{"_id":"public/tag//index.html","modified":1480580809816,"shasum":"6aacbe23502d82c95cc894c8848fbdc206770f4d"},{"_id":"public/tag//index.html","modified":1480580809859,"shasum":"b09494c7ab251081da0c7cdba455d5e2727c9e5b"},{"_id":"public/tag/os-x/index.html","modified":1480580809876,"shasum":"79f66f513fb5b64695ce46f26d74d84344fa0df7"},{"_id":"public/tag/linux/index.html","modified":1480580809911,"shasum":"3a1c4816af921f3585b65fb51337141d3512005f"},{"_id":"public/tag/archlinux/index.html","modified":1480580809951,"shasum":"e30572fa0e7559a89307716fffa7cde1540f0839"},{"_id":"public/tag/virtualbox/index.html","modified":1480580809982,"shasum":"974eb2e34ab9bf821ffb53d7b038ab1292d8406a"},{"_id":"public/tag//index.html","modified":1480580810013,"shasum":"e35a5430ecbaa1f8f6e8916f2ec4f313cff33bbb"},{"_id":"public/tag/ssh/index.html","modified":1480580810045,"shasum":"6ad8f6ffdec6a931122f82bb7dd36a01c39167b4"},{"_id":"public/tag/uva/index.html","modified":1480580810131,"shasum":"fb0b499bd87e404de3f0cfc1de4990e6ea82c9dc"},{"_id":"public/tag/-dp/index.html","modified":1480580810189,"shasum":"204f763ab2d4ccb331dbe22a8e2a942fa76a7976"},{"_id":"public/tag//index.html","modified":1480580810240,"shasum":"95a2a278fce084a54db2b3033a3b5cf2b5c5a79a"},{"_id":"public/tag//index.html","modified":1480580810300,"shasum":"516302257e4bb4c3e152bd437425b96b198576ee"},{"_id":"public/tag//index.html","modified":1480580810332,"shasum":"178b7d55329cc930587b8a7a7366310eb5fc9477"},{"_id":"public/tag//index.html","modified":1480580810424,"shasum":"85944bfb7d13bbb7df25aba18501fdfe6cf4bc8f"},{"_id":"public/tag//index.html","modified":1480580810561,"shasum":"b5e3ba18a79f6cf12366a4fe6e52e6c65f46f2ad"},{"_id":"public/tag/-dp/index.html","modified":1480580810679,"shasum":"72c068e3f2682d2820b24b7c1a41d396c53f6b1a"},{"_id":"public/tag//index.html","modified":1480580810844,"shasum":"a6384bf5103806354c4f29ff9c3b5c91fab75e6b"},{"_id":"public/tag//page/2/index.html","modified":1480580810879,"shasum":"c4668c9d9bef222447919b15c12e533e570fcd23"},{"_id":"public/tag//index.html","modified":1480580810927,"shasum":"0bcd9135b9c88ad8e26f9baa8b8ff73d3728bf1f"},{"_id":"public/tag//index.html","modified":1480580810966,"shasum":"2c6e31c91e8096d33d1b4c35138deed3db8836c5"},{"_id":"public/tag/-dp/index.html","modified":1480580811029,"shasum":"3dbe305059b6b49a2e1cb8313b1cd12bd890eb99"},{"_id":"public/tag/-dp/page/2/index.html","modified":1480580811093,"shasum":"7e19600792451241c1b0aaa1a952cb83d82d7699"},{"_id":"public/tag//index.html","modified":1480580811162,"shasum":"7d62ec61c470ece0498eb2ae763fd7ba65186d59"},{"_id":"public/tag//index.html","modified":1480580811285,"shasum":"78c16d4bc7c80c6b30287b44ae86a1fc2a85ea86"},{"_id":"public/tag//index.html","modified":1480580811347,"shasum":"16f7287bac6d7dbf537ef59fa5f7aabe405c3619"},{"_id":"public/tag//index.html","modified":1480580811443,"shasum":"1734971f74aefb5c2a9bbec5585d7a28896a56a7"},{"_id":"public/tag/codevs/index.html","modified":1480580811605,"shasum":"410788bcd26a56c0316808197a03614630a72e47"},{"_id":"public/tag/codevs/page/2/index.html","modified":1480580811725,"shasum":"1e9e9064b32b862f0902bee76baa3dddd0c169c4"},{"_id":"public/tag/codevs/page/3/index.html","modified":1480580811835,"shasum":"99f34d243095e7042e21eac5f530cdfbb78873cf"},{"_id":"public/tag/codevs/page/4/index.html","modified":1480580811966,"shasum":"581e9f0067338f302513f6183df35846a6e1c393"},{"_id":"public/tag/codevs/page/5/index.html","modified":1480580812020,"shasum":"81e52ab8143529772a39cf51ebd6c2b7f7af7a37"},{"_id":"public/tag/tyvj/index.html","modified":1480580812132,"shasum":"e48be74e2c7256bc1f641ca1d0f5b4e6a5e49f4c"},{"_id":"public/tag/-dp/index.html","modified":1480580812233,"shasum":"c25dae9950dfb6e80d1d857b7804557fa39153a6"},{"_id":"public/tag/tjoi/index.html","modified":1480580812293,"shasum":"235eb6d05713e7adaf2910fa3edd01d5c7978e74"},{"_id":"public/tag/-dp/index.html","modified":1480580812373,"shasum":"b20428d8382e5cee88e3abc3968009fe90c73115"},{"_id":"public/tag//index.html","modified":1480580812558,"shasum":"b20776d5d25e6b6e60de43a1079f6f00ea143cf7"},{"_id":"public/tag//page/2/index.html","modified":1480580812696,"shasum":"fc77cdf3542076063344c42b0e6edbf130ae2175"},{"_id":"public/tag//page/3/index.html","modified":1480580812791,"shasum":"adc4112170574f1aa83d28e13ad10ec126aa1d00"},{"_id":"public/tag/ac-/index.html","modified":1480580812861,"shasum":"9922f52c15442f415cb93c4b22ce8921d84200a1"},{"_id":"public/tag/ac-/page/2/index.html","modified":1480580812886,"shasum":"d86739067c74c822b74263859b19a49c31c3d123"},{"_id":"public/tag//index.html","modified":1480580812935,"shasum":"83d94049f5605d79fa159132490ab711084701d5"},{"_id":"public/tag/splay/index.html","modified":1480580813080,"shasum":"b80c9653173f297dcc6afdba368df0ccde911320"},{"_id":"public/tag/splay/page/2/index.html","modified":1480580813134,"shasum":"403654c99f6057a6a5b4e0f86de4546582a9d1d5"},{"_id":"public/tag//index.html","modified":1480580813205,"shasum":"1fb872f4324222d4d85db5e9d5d06e735e83e89b"},{"_id":"public/tag//index.html","modified":1480580813275,"shasum":"3a440f537581957a144b5eb2434f5fda8545c8b7"},{"_id":"public/tag//page/2/index.html","modified":1480580813356,"shasum":"090451ad73b09ae0cbcbfd88e20938f18835f231"},{"_id":"public/tag//page/3/index.html","modified":1480580813404,"shasum":"9ff97fcef19347aa1159a3a96cb9b62ee248b941"},{"_id":"public/tag//index.html","modified":1480580813473,"shasum":"1316790addd43cc456f562fe55ca2314b34a7871"},{"_id":"public/tag//page/2/index.html","modified":1480580813550,"shasum":"64ec3bb84abe02864a486d0e2776f2fb82051e59"},{"_id":"public/tag//page/3/index.html","modified":1480580813623,"shasum":"60a8b802ecd915aac08c3a318a505663558e25c9"},{"_id":"public/tag//index.html","modified":1480580813685,"shasum":"f97d0b2150dafabc3ab52d20474ceaa0cf19231c"},{"_id":"public/tag//index.html","modified":1480580813763,"shasum":"2dd5c79ae542eb406724a04ad3c8e6ed0e1d3a41"},{"_id":"public/tag//page/2/index.html","modified":1480580813829,"shasum":"d8f914d1287b54bffeffa0fe32d565554ee12b99"},{"_id":"public/tag//page/3/index.html","modified":1480580813875,"shasum":"edc4cb3dd2b48345bbeecb8ab92056c6a3a385c1"},{"_id":"public/tag//index.html","modified":1480580813952,"shasum":"011bd3f31e14bf434e7fcc4f163ef625706a7bbd"},{"_id":"public/tag//index.html","modified":1480580813990,"shasum":"ebb9ec4857a70c16e08b85347aca6bb4d66c5560"},{"_id":"public/tag//index.html","modified":1480580814070,"shasum":"3d46b4c44c204fccd162e8f7f2febc3d390b3650"},{"_id":"public/tag//page/2/index.html","modified":1480580814089,"shasum":"ec82717dcdc5394ee71724f519681a355074a959"},{"_id":"public/tag//index.html","modified":1480580814122,"shasum":"a31f8ca0f831fc79206ff814911a25077fc513a5"},{"_id":"public/tag/c/index.html","modified":1480580814157,"shasum":"e242e5364f3fac7f560b911fa25429b25dfef90e"},{"_id":"public/tag/stl/index.html","modified":1480580814205,"shasum":"5fb4668ddb1c3347dfc6d905e1308aee62f52adb"},{"_id":"public/tag/spoj/index.html","modified":1480580814226,"shasum":"37293d15f7e3ae8029ed524e9da5855c86f63a4e"},{"_id":"public/tag/shoi/index.html","modified":1480580814285,"shasum":"589dbd9988fdeb218345be1cfa0ce97ca73d3992"},{"_id":"public/tag//index.html","modified":1480580814303,"shasum":"758eab4f280a0464b5179aa1d7fbeb463e32f37c"},{"_id":"public/tag//index.html","modified":1480580814342,"shasum":"03e9263085c44e94669d0b3df88dad206ecbdbcf"},{"_id":"public/tag/cdq/index.html","modified":1480580814390,"shasum":"98a96f978c0ffd5ce2d315d65209fb10a73cb424"},{"_id":"public/tag//index.html","modified":1480580814450,"shasum":"8c3e63cc15d5adfff576ce0a90fc3b4a47768579"},{"_id":"public/tag/sdoi/index.html","modified":1480580814521,"shasum":"297986c7300f2f277fc75cf5bce2e3e3cd038659"},{"_id":"public/tag/sdoi/page/2/index.html","modified":1480580814580,"shasum":"c67635c8cefa834052b676c8ec0f342cd1205c86"},{"_id":"public/tag//index.html","modified":1480580814627,"shasum":"ebcc15ce24a4149a88d0ce89cacdfd543e07d9ff"},{"_id":"public/tag//index.html","modified":1480580814653,"shasum":"534fa73b43c6a85128c8c7fa657668ad0a38bdbc"},{"_id":"public/tag//index.html","modified":1480580814687,"shasum":"7ea2fadd7436a6565818202b79ee69d831558690"},{"_id":"public/tag//index.html","modified":1480580814716,"shasum":"f743df89f8f5aff70f7c7825545b27bf84af5bf9"},{"_id":"public/tag//index.html","modified":1480580814748,"shasum":"6b22fff6c9cd1980b8a9cd8ba5ead82c5cc51967"},{"_id":"public/tag//index.html","modified":1480580814783,"shasum":"0b3f5652cf0bf9c5f485f97f5da3a76c610eec7c"},{"_id":"public/tag//index.html","modified":1480580814829,"shasum":"193554eaa0061178acb9e139981a0bb656e6042d"},{"_id":"public/tag/rmq/index.html","modified":1480580814867,"shasum":"074c3febc1670ed914bc290705affcc819b7e9bc"},{"_id":"public/tag//index.html","modified":1480580814907,"shasum":"4cff99c2cc06f7463d9a02fcd381d42d1ceec22b"},{"_id":"public/tag//index.html","modified":1480580814938,"shasum":"2519b949e44d15926fc0af6cb1f04d3b82034189"},{"_id":"public/tag/ntt/index.html","modified":1480580814975,"shasum":"a3d5e2b09ac8675f08be81729a0e53411e390aa4"},{"_id":"public/tag//index.html","modified":1480580815001,"shasum":"637f330f7f7b387e6384cb0b3137cf65e6fbc695"},{"_id":"public/tag//index.html","modified":1480580815047,"shasum":"d385559f052e70c7df14b6ff48a336d9850e639c"},{"_id":"public/tag//index.html","modified":1480580815083,"shasum":"7768db36adf9bc1049ee0a35c1fa9d306ab5b5ab"},{"_id":"public/tag//index.html","modified":1480580815151,"shasum":"628bf756660fc1dd33d230ff7f6019a550a821fb"},{"_id":"public/tag//index.html","modified":1480580815178,"shasum":"f15b35296c948a5dd42d914331e3ba0ef7f416b6"},{"_id":"public/tag//index.html","modified":1480580815209,"shasum":"3bdc626901f16f2bc93c7944940868cddca5f7eb"},{"_id":"public/tag/exgcd/index.html","modified":1480580815249,"shasum":"d8a59459511683bcef91c8a0c4cf6e59ed8f7220"},{"_id":"public/tag/bsgs/index.html","modified":1480580815277,"shasum":"d086840b7dc200c250c3a568e3ec685d5886ba5c"},{"_id":"public/tag//index.html","modified":1480580815307,"shasum":"caaac3b8174737776ebf0fc22244c0292974e2d9"},{"_id":"public/tag/link-cut-tree/index.html","modified":1480580815346,"shasum":"f4988d1192d9fb5374b330f03cfc33ecf158b4c4"},{"_id":"public/tag/scoi/index.html","modified":1480580815416,"shasum":"1a890db4a739ff569e6bcabb63f230b62740f772"},{"_id":"public/tag/scoi/page/2/index.html","modified":1480580815454,"shasum":"3d184277b14a83f596b522a00a9fcbfe478495b9"},{"_id":"public/tag/set/index.html","modified":1480580815489,"shasum":"964f41f834ac467661771d5ccd1dc8359b79c0cf"},{"_id":"public/tag//index.html","modified":1480580815521,"shasum":"71a6f7adfed0632cd14a297013db1a3a7dac87fd"},{"_id":"public/tag//index.html","modified":1480580815565,"shasum":"08cb50a09e74a2b620690e93d49cc9b117aa874d"},{"_id":"public/tag/-dp/index.html","modified":1480580815606,"shasum":"827ccc58f64cf58074b9aae220da90ba45e22bf9"},{"_id":"public/tag//index.html","modified":1480580815644,"shasum":"151b71e538d3819228538900a32f865f8b3eaf4c"},{"_id":"public/tag//index.html","modified":1480580815669,"shasum":"d06a913cbef633d8bdbef781ee74cabbe79ba0ca"},{"_id":"public/tag//index.html","modified":1480580815699,"shasum":"3d38a91b7e17db0e036d19995bbcbce423ab788f"},{"_id":"public/tag//index.html","modified":1480580815727,"shasum":"dda98fc4a186fe349a7a7ff4f69d408f84a52eb3"},{"_id":"public/tag//index.html","modified":1480580815754,"shasum":"58402779d66942c37a5396d0a5065e541c1146bf"},{"_id":"public/tag//index.html","modified":1480580815797,"shasum":"7f2a0ebad47df3b09cf88097a66a20bd3440c510"},{"_id":"public/tag/dfs/index.html","modified":1480580815831,"shasum":"b76c02aa2ce635a5a82ea80a580a9dbfe9a15462"},{"_id":"public/tag/poj/index.html","modified":1480580815864,"shasum":"7edea1df7e88ab6d5fac210a1671e83c4d8e9dab"},{"_id":"public/tag/kmp/index.html","modified":1480580815897,"shasum":"85e73b771da2c5177e134d650822cd8f9025d129"},{"_id":"public/tag/prim/index.html","modified":1480580815932,"shasum":"75f865152b9ac180283f9e1335e4b6df62e668de"},{"_id":"public/tag//index.html","modified":1480580815955,"shasum":"54b54338e3e280a553ed0bfb765f4c31e1979a04"},{"_id":"public/tag//index.html","modified":1480580815973,"shasum":"cde7335650978d56a988deb195c16f1c01e094ed"},{"_id":"public/tag/poi/index.html","modified":1480580816010,"shasum":"e3c91a63726242a79479a5d759ae9f6ce63ed09e"},{"_id":"public/tag/noip/index.html","modified":1480580816074,"shasum":"199565c2d95bfed0216846eef253a8fe73e6a48d"},{"_id":"public/tag/noip/page/2/index.html","modified":1480580816129,"shasum":"fcedda573f57515f7274b531883f764c442d418b"},{"_id":"public/tag/noip/page/3/index.html","modified":1480580816167,"shasum":"d326b7282caf2f447c1158a76b32eb1394a636c6"},{"_id":"public/tag//index.html","modified":1480580816189,"shasum":"2471929a338d3acd0a54b5f09665916e85127d40"},{"_id":"public/tag//index.html","modified":1480580816212,"shasum":"8888361bbd7dd5d66b41427dd50657f4b10911f8"},{"_id":"public/tag/floyd/index.html","modified":1480580816237,"shasum":"cae486972210e75d04f7ed0f1cebb6fe37a58595"},{"_id":"public/tag//index.html","modified":1480580816266,"shasum":"f2de189c1c1c033c4a79fc1fe376aa59f77b3555"},{"_id":"public/tag/bfs/index.html","modified":1480580816293,"shasum":"565b229d1575ddf6373c1b9e25f4d76ba0149dac"},{"_id":"public/tag/hash/index.html","modified":1480580816325,"shasum":"a8927e10cb4326d102764ba94526f45e56acc014"},{"_id":"public/tag/spfa/index.html","modified":1480580816349,"shasum":"6033a26056dd566eade462076d095424b0c3d6be"},{"_id":"public/tag//index.html","modified":1480580816379,"shasum":"260287b8f60b9e6bce0e9e4b064ead6fc4af3fd6"},{"_id":"public/tag//index.html","modified":1480580816409,"shasum":"b74170c132ff6d9d74df4004d9f64094b8f85ef1"},{"_id":"public/tag//index.html","modified":1480580816428,"shasum":"0c7a89007f8c5ae028d5f3af9ac7954cf589ee84"},{"_id":"public/tag/vijos/index.html","modified":1480580816453,"shasum":"50c6b946ceb1e537243b9f0aad2dbc7e9957c8f9"},{"_id":"public/tag//index.html","modified":1480580816491,"shasum":"09f0a667634711a08fc86ae62095491464f2e3b7"},{"_id":"public/tag//index.html","modified":1480580816519,"shasum":"ef698d1dc8f1d1a0c7c3d00f61f3c94938211355"},{"_id":"public/tag/-dp/index.html","modified":1480580816553,"shasum":"55bebe26ee57e0fc4fe01fb87ba7bf3a5d73a6a8"},{"_id":"public/tag/noi/index.html","modified":1480580816613,"shasum":"ec250c5322ac12b1ed5395a80e2cdff9e2ed2fed"},{"_id":"public/tag/noi/page/2/index.html","modified":1480580816681,"shasum":"84068a291124dd283fec1f6720cf11834f7c5526"},{"_id":"public/tag//index.html","modified":1480580816740,"shasum":"9c39d67a953ac2038c288ce22a9b86d56ba4fb5f"},{"_id":"public/tag//index.html","modified":1480580816829,"shasum":"164a1272d6de980444cc01578c740ffddf403c69"},{"_id":"public/tag/map/index.html","modified":1480580816894,"shasum":"afad96bd6a0d74d363fa2783afd6100f77d02de6"},{"_id":"public/tag//index.html","modified":1480580816955,"shasum":"d491c194aeb284ab6e2c1abee83640b54ee133a8"},{"_id":"public/tag//index.html","modified":1480580816989,"shasum":"732b0e81ed418b26a936d276cfba70c552fe574b"},{"_id":"public/tag//index.html","modified":1480580817061,"shasum":"60e3abe7a1270f71f8928b39ca24bb7050fb921f"},{"_id":"public/tag/lct/index.html","modified":1480580817111,"shasum":"b475cd7d6fd7d425ba8183400ef36cbc0099d4c0"},{"_id":"public/tag//index.html","modified":1480580817178,"shasum":"462c73bc53a23940e721d714f68ad6209b18ff50"},{"_id":"public/tag//index.html","modified":1480580817251,"shasum":"86c886f7b05e124f63004fd4684c909606e6dd2e"},{"_id":"public/tag//index.html","modified":1480580817317,"shasum":"898c8176e1a9b198d36791102cdb841b7d61e98f"},{"_id":"public/tag/kruskal/index.html","modified":1480580817340,"shasum":"d1a2ac798d788cb226823418d1e0bdf067598a01"},{"_id":"public/tag//index.html","modified":1480580817381,"shasum":"b6b91003ef2055cdcdd3e0c07ce31eed47f5ecd8"},{"_id":"public/tag/markdown/index.html","modified":1480580817409,"shasum":"4bd311a82b36aab221947b8a085f1cb1b62d7576"},{"_id":"public/tag/latex/index.html","modified":1480580817489,"shasum":"44b498765a3059aafed2a02688c2739851aa43d3"},{"_id":"public/tag/github/index.html","modified":1480580817549,"shasum":"bfff39df7d36d1c0a92c8c242941b8159d335252"},{"_id":"public/tag/jsoi/index.html","modified":1480580817661,"shasum":"16f59617476487cc643ac92f87d2f10661edc674"},{"_id":"public/tag/jsoi/page/2/index.html","modified":1480580817708,"shasum":"064da93e03b1f0c848931e7f9b32c33a9319a7f4"},{"_id":"public/tag//index.html","modified":1480580817757,"shasum":"87a2f420d5939c0ad90f4c100f9bd3d868ba3171"},{"_id":"public/tag//index.html","modified":1480580817780,"shasum":"f373d9ddbbae98cceeccfa6ca3ca271deea275a1"},{"_id":"public/tag//index.html","modified":1480580817813,"shasum":"828199e8b80b1bbd313d96b26d842d38038a62c0"},{"_id":"public/tag//index.html","modified":1480580817851,"shasum":"8c0065b95da9c753272bc848c93edcbe1b14ce61"},{"_id":"public/tag/ioi/index.html","modified":1480580817871,"shasum":"84a0a318c02fcb870d7bc75cbee0e1835c8c2d13"},{"_id":"public/tag//index.html","modified":1480580817905,"shasum":"b9ae594eb20f53fabc10cca351599d5bb0529e2f"},{"_id":"public/tag/hnoi/index.html","modified":1480580817980,"shasum":"99173f5616d7b8d23d9073e2e0e1076af15cee52"},{"_id":"public/tag/hnoi/page/2/index.html","modified":1480580818018,"shasum":"8281ba71bd44f5365113ff23e7a5ceb5f5751b75"},{"_id":"public/tag/dfs-/index.html","modified":1480580818047,"shasum":"cb4cbdce334ab8220e1a23bd5093331f4e51c15b"},{"_id":"public/tag/prufer-/index.html","modified":1480580818070,"shasum":"7f3aed32aae006aab8b4316f1113797e2428688b"},{"_id":"public/tag//index.html","modified":1480580818108,"shasum":"493d1076bc3c97d24e50d5f41cbe0915341291c9"},{"_id":"public/tag//index.html","modified":1480580818132,"shasum":"1f9c111bb9f243ea86bdc6a098685d20175590e6"},{"_id":"public/tag/burnside-/index.html","modified":1480580818163,"shasum":"624d9e33ce0f8f96e999139a3d3766bbc124b6b7"},{"_id":"public/tag/trie/index.html","modified":1480580818195,"shasum":"4faa19574520167786fe003d2411cf51fc34db2e"},{"_id":"public/tag/heoi/index.html","modified":1480580818232,"shasum":"53e59332b8cfb57926ac9db08038b466b7283872"},{"_id":"public/tag/hdu/index.html","modified":1480580818322,"shasum":"c3676a91e47102350060f4c35c33e96514720491"},{"_id":"public/tag/bestcoder/index.html","modified":1480580818385,"shasum":"5bec3254c0211805494d1bbbeb1b80a10929f17e"},{"_id":"public/tag/haoi/index.html","modified":1480580818525,"shasum":"0bcaa2143e6837bf5fcd780e56c9db5fe4edfd4e"},{"_id":"public/tag//index.html","modified":1480580818570,"shasum":"9bfc8a22246b47a390eda66432b46c2f6f987db1"},{"_id":"public/tag/gdb/index.html","modified":1480580818621,"shasum":"e92000ebc78cb6569e6680552d021968aaa255a1"},{"_id":"public/tag//index.html","modified":1480580818654,"shasum":"873c7cd9dd030c88f7cdafdb3e3b614931f28165"},{"_id":"public/tag/fjoi/index.html","modified":1480580818699,"shasum":"3dadef17c972a9c615a0d064f1bd58f147888162"},{"_id":"public/tag//index.html","modified":1480580818772,"shasum":"90ab399c13f14547fd217095b1a87d4a43aa81ec"},{"_id":"public/tag/ctsc/index.html","modified":1480580818859,"shasum":"d4bd5e164799ac696806a8b4db0b087e82e4a56b"},{"_id":"public/tag/-24-/index.html","modified":1480580819049,"shasum":"d8d8ea367631e0dbd4593cd8fa37a47c079165e0"},{"_id":"public/tag/-24-/page/2/index.html","modified":1480580819159,"shasum":"42281a89c4c32dc14b55414ab9200519a88c1f1b"},{"_id":"public/tag/cqoi/index.html","modified":1480580819203,"shasum":"742e17bb2bfa25156a5076daa0f54b38e93783fd"},{"_id":"public/tag//index.html","modified":1480580819235,"shasum":"c4bf5c3a4eac2f41e00532e9f80edeaca7e6ff40"},{"_id":"public/tag//index.html","modified":1480580819272,"shasum":"e35a84b2694bbcb4eac35d1a444babb22e5036a2"},{"_id":"public/tag/usaco/index.html","modified":1480580819327,"shasum":"b056e7abba79648cbb273b937f6951e6bdf71ab4"},{"_id":"public/tag/coci/index.html","modified":1480580819351,"shasum":"5c6cb674ca8ce97805680eabf84e6dfb0bf5f974"},{"_id":"public/tag//index.html","modified":1480580819380,"shasum":"4899b116572a7d7a7cb7e0d30aadb576e06e3ed3"},{"_id":"public/tag/codeforces/index.html","modified":1480580819421,"shasum":"019ce593edcf0a51c6be43073a37b25c662a4570"},{"_id":"public/tag/ceoi/index.html","modified":1480580819448,"shasum":"047d34610e36a734c3c4e90411329e9984bb8bff"},{"_id":"public/tag/lucas-/index.html","modified":1480580819472,"shasum":"c67079fd15333a4bdaa04ae60cedb7802dc079df"},{"_id":"public/tag//index.html","modified":1480580819504,"shasum":"059c07ffb559105f8efa6331ab28828ed4ebf2b0"},{"_id":"public/tag//index.html","modified":1480580819539,"shasum":"f11b1b3af74b60831b0e9de38aaa705388fdd9d4"},{"_id":"public/tag//index.html","modified":1480580819566,"shasum":"cff2b7602ff2d4ad8469878955d23ede3b4d65a9"},{"_id":"public/tag/dijkstra/index.html","modified":1480580819588,"shasum":"d4eaaff5bcf71fba8616a4e3040e30f933f96ff1"},{"_id":"public/tag//index.html","modified":1480580819615,"shasum":"b3190b4ef3883b0dfcad194eb4c05c7f865b290a"},{"_id":"public/tag/apio/index.html","modified":1480580819646,"shasum":"ec94b81386daa37d50d7eebecddc5da8a01b30c9"},{"_id":"public/tag/dag/index.html","modified":1480580819693,"shasum":"571ac47ece18cbe2e39defb2a5325df1e14dca83"},{"_id":"public/tag//index.html","modified":1480580819752,"shasum":"1726bbfd4d5a7f556c96c2821a4e1dfba5ea8742"},{"_id":"public/tag/bellman-ford/index.html","modified":1480580819813,"shasum":"fb28b8e2bd2fbf5a77fcc779ec868fa321307c45"},{"_id":"public/tag/ahoi/index.html","modified":1480580819864,"shasum":"1cc30e31968295293854d2f62806b4a205a0e8e6"},{"_id":"public/tag//index.html","modified":1480580819900,"shasum":"fa9077cd8d1143592dc4a930732f350bc50e252e"},{"_id":"public/tag//index.html","modified":1480580819926,"shasum":"b1c80f63791eed96fc6e48f968c47d46d6b6a800"},{"_id":"public/tag//index.html","modified":1480580819952,"shasum":"a41b471372e23b3f4cbdf8686cf8184c6a603d89"},{"_id":"public/tag//index.html","modified":1480580819976,"shasum":"b85de2d59e91563bf93bab82ba0aa2a9cadbbd08"},{"_id":"public/tag//index.html","modified":1480580820003,"shasum":"dfc7553a381f5deddee3e638bda837dfdab72a43"},{"_id":"public/tag//index.html","modified":1480580820040,"shasum":"3a73b3ab2b2d490332ae234e0454e2ca91b5df07"}],"Category":[{"name":"OI","_id":"ciw63jhoe00010jxlqznpe3ld"},{"name":"Geek","_id":"ciw63jhqv002z0jxl3lcibvtr"},{"name":"Diary","_id":"ciw63jhw300a60jxlabv54v9b"}],"Data":[],"Page":[{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2016-09-10T05:42:23.025Z","updated":"2016-09-10T05:42:23.025Z","path":"tags/index.html","comments":1,"_id":"ciw63jhot000d0jxlrlzjizl8"},{"title":"Friends","date":"2016-01-18T13:08:05.000Z","_content":"\n<table width=\"100%\" id=\"oier\" style=\"text-align: center; \">\n<thead>\n<tr class=\"header\">\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td>[sxb_201](http://blog.csdn.net/sxb_201)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Rapiz](https://www.zybuluo.com/rapiz/note/367932)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Platypus](http://platypuspro.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Franky](http://www.cnblogs.com/Franky-ln/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ShallWe](http://shallwe2000.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[frank_c1](http://www.acyume.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Krydom](http://krydom.com/)</td>\n<td><span></span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# LYOI 2016\n[Edge](http://blog.u-pt.pw) [ilern](http://ilern.coding.me/428/) [yqy](https://yqy.moe) [Sulfur6](http://sulfur6.top/) [Roller](http://roller.coding.me/heyheyhey/) [x_shuai](http://x_shuai.leanote.com/) [Gavin](http://gavin_blog.leanote.com/) [Grape](http://bbs.u-pt.pw)\n\n# \n\n[](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n\n[Dimpurr](http://im.dimpurr.com/)\n","source":"friends.md","raw":"title: Friends\npermalink: friends/\ndate: 2016-01-18 21:08:05\n---\n\n<table width=\"100%\" id=\"oier\" style=\"text-align: center; \">\n<thead>\n<tr class=\"header\">\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td>[sxb_201](http://blog.csdn.net/sxb_201)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Rapiz](https://www.zybuluo.com/rapiz/note/367932)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Platypus](http://platypuspro.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Franky](http://www.cnblogs.com/Franky-ln/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ShallWe](http://shallwe2000.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[frank_c1](http://www.acyume.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Krydom](http://krydom.com/)</td>\n<td><span></span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# LYOI 2016\n[Edge](http://blog.u-pt.pw) [ilern](http://ilern.coding.me/428/) [yqy](https://yqy.moe) [Sulfur6](http://sulfur6.top/) [Roller](http://roller.coding.me/heyheyhey/) [x_shuai](http://x_shuai.leanote.com/) [Gavin](http://gavin_blog.leanote.com/) [Grape](http://bbs.u-pt.pw)\n\n# \n\n[](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n\n[Dimpurr](http://im.dimpurr.com/)\n","updated":"2016-10-15T13:43:52.349Z","path":"friends/index.html","comments":1,"layout":"page","_id":"ciw63jhow000e0jxlzpgzjf5a"},{"title":"About Me","date":"2015-11-22T21:36:32.000Z","_content":"\n OI ~~~~~~~~\n\n 2015  8  OI\n\n\n\n<!--  NOI  -->\n\n> \n","source":"about-me.md","raw":"title: About Me\npermalink: about-me/\ndate: 2015-11-23 05:36:32\n---\n\n OI ~~~~~~~~\n\n 2015  8  OI\n\n\n\n<!--  NOI  -->\n\n> \n","updated":"2016-05-20T12:39:29.758Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"ciw63jhoy000f0jxl1rzdqbyd"}],"Post":[{"title":" - ","date":"2016-03-20T15:07:32.000Z","_content":"\n $ n $  $ 0 $ \n\n1.  $ x $ \n2.  $ x $ \n\n<!-- more -->\n\n### \n $ sum $  $ count $\n\n u \n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n $ count(u) * d_i $  $ O(log ^ 2 n) $ \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","source":"_posts/20160318-color.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: 20160318-color\ndate: 2016-03-20 23:07:32\n---\n\n $ n $  $ 0 $ \n\n1.  $ x $ \n2.  $ x $ \n\n<!-- more -->\n\n### \n $ sum $  $ count $\n\n u \n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n $ count(u) * d_i $  $ O(log ^ 2 n) $ \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","slug":"20160318-color","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jho800000jxl7vo5ctl0"},{"title":"ZJOI2014 - FFT","date":"2016-06-11T13:27:00.000Z","_content":"\n\n\n$$ E_i = \\frac{F_i}{q_i} $$\n\n$$ F_j = \\sum\\limits_{i < j} \\frac{q_i q_j}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i q_j}{(i - j) ^ 2}  $$\n\n $ E $\n\n<!-- more -->\n\n### \n[BZOJ 3527](http://www.lydsy.com/JudgeOnline/problem.php?id=3527)\n\n### \n\n\n$$ E_j = \\sum\\limits_{i < j} \\frac{q_i}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i}{(i - j) ^ 2} $$\n\n $ E_j = A_j - B_j $ \n\n$$ A_j = \\sum\\limits_{i = 1} ^ {j - 1} \\frac{q_j}{(i - j) ^ 2} $$\n\n\n\n$$\ng(i) = \\begin{cases} \\frac{1}{i ^ 2} & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n$$\nf(i) = \\begin{cases} q_i & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n\n\n$$ A_j = \\sum\\limits_{i = 0} ^ {j} f(i) g(j - i) $$\n\n~~~~ FFT \n\n\n\n$$ A_j = \\sum\\limits_{i = j + 1} ^ {n} \\frac{q_j}{(i - j) ^ 2} $$\n\n [BZOJ 2194](bzoj-2194)  $ A $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_EXTENDED = 262144;\nconst long double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<long double> omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<long double>(cosl(2 * PI / n * i), sinl(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<long double> *a, const int n, const std::complex<long double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[t], a[i]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<long double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<long double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid multiply(std::complex<long double> *a, std::complex<long double> *b, const int n) {\n\t\tint size = 1;\n\t\twhile (size < n * 2) size *= 2;\n\n\t\t/*\n\t\tstatic std::complex<long double> c[MAXN_EXTENDED];\n\t\tfor (int i = 0; i < n; i++) c[i] = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i <= j; i++) {\n\t\t\t\tc[j] += a[i] * b[j - i];\n\t\t\t}\n\t\t}\n\n\t\tstd::copy(c, c + n, a);\n\t\treturn;\n\t\t*/\n\n\t\tinit(size);\n\n\t\tdft(a, size);\n\t\tdft(b, size);\n\n\t\tfor (int i = 0; i < size; i++) a[i] *= b[i];\n\n\t\tidft(a, size);\n\t}\n} fft;\n\nint n;\nlong double q[MAXN + 1];\n\ninline void calc(const long double *q, long double *E) {\n\tstatic std::complex<long double> f[MAXN_EXTENDED], g[MAXN_EXTENDED];\n\tstd::fill(f, f + MAXN_EXTENDED, 0);\n\tstd::fill(g, g + MAXN_EXTENDED, 0);\n\tstd::copy(q, q + n + 1, f);\n\tf[0] = g[0] = std::complex<long double>(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[i] = std::complex<long double>(1.0 / pow(i, 2), 0);\n\t}\n\n\tfft.multiply(f, g, n + 1);\n\tfor (int i = 1; i <= n; i++) E[i] = f[i].real();\n\n\t/*\n\tfor (int i = 0; i < (n + 1) * 2; i++) printf(\"* %lf\\n\", static_cast<double>(f[i].real()));\n\tputchar('\\n');\n\n\treturn;\n\n\tstatic std::complex<long double> r[MAXN_EXTENDED];\n\tfor (int j = 0; j <= n; j++) {\n\t\tr[j] = 0;\n\t\tfor (int i = 0; i <= j; i++) {\n\t\t\tr[j] += f[i] * g[j - i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) printf(\"* %lf\\n\", static_cast<double>(r[i].real()));\n\tputchar('\\n');\n\n\tfor (int i = 1; i <= n; i++) E[i] = r[i].real();\n\t*/\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdouble x;\n\t\tscanf(\"%lf\", &x);\n\t\tq[i] = x;\n\t}\n\n\tstatic long double E1[MAXN + 1], E2[MAXN + 1];\n\tcalc(q, E1);\n\tstd::reverse(q + 1, q + n + 1);\n\tcalc(q, E2);\n\n\tfor (int i = 1; i <= n; i++) printf(\"%.3lf\\n\", static_cast<double>(E1[i] - E2[n - i + 1]));\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2014-force.md","raw":"title: ZJOI2014 - FFT\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - FFT\n  - \npermalink: zjoi2014-force\ndate: 2016-06-11 21:27:00\n---\n\n\n\n$$ E_i = \\frac{F_i}{q_i} $$\n\n$$ F_j = \\sum\\limits_{i < j} \\frac{q_i q_j}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i q_j}{(i - j) ^ 2}  $$\n\n $ E $\n\n<!-- more -->\n\n### \n[BZOJ 3527](http://www.lydsy.com/JudgeOnline/problem.php?id=3527)\n\n### \n\n\n$$ E_j = \\sum\\limits_{i < j} \\frac{q_i}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i}{(i - j) ^ 2} $$\n\n $ E_j = A_j - B_j $ \n\n$$ A_j = \\sum\\limits_{i = 1} ^ {j - 1} \\frac{q_j}{(i - j) ^ 2} $$\n\n\n\n$$\ng(i) = \\begin{cases} \\frac{1}{i ^ 2} & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n$$\nf(i) = \\begin{cases} q_i & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n\n\n$$ A_j = \\sum\\limits_{i = 0} ^ {j} f(i) g(j - i) $$\n\n~~~~ FFT \n\n\n\n$$ A_j = \\sum\\limits_{i = j + 1} ^ {n} \\frac{q_j}{(i - j) ^ 2} $$\n\n [BZOJ 2194](bzoj-2194)  $ A $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_EXTENDED = 262144;\nconst long double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<long double> omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<long double>(cosl(2 * PI / n * i), sinl(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<long double> *a, const int n, const std::complex<long double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[t], a[i]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<long double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<long double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid multiply(std::complex<long double> *a, std::complex<long double> *b, const int n) {\n\t\tint size = 1;\n\t\twhile (size < n * 2) size *= 2;\n\n\t\t/*\n\t\tstatic std::complex<long double> c[MAXN_EXTENDED];\n\t\tfor (int i = 0; i < n; i++) c[i] = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i <= j; i++) {\n\t\t\t\tc[j] += a[i] * b[j - i];\n\t\t\t}\n\t\t}\n\n\t\tstd::copy(c, c + n, a);\n\t\treturn;\n\t\t*/\n\n\t\tinit(size);\n\n\t\tdft(a, size);\n\t\tdft(b, size);\n\n\t\tfor (int i = 0; i < size; i++) a[i] *= b[i];\n\n\t\tidft(a, size);\n\t}\n} fft;\n\nint n;\nlong double q[MAXN + 1];\n\ninline void calc(const long double *q, long double *E) {\n\tstatic std::complex<long double> f[MAXN_EXTENDED], g[MAXN_EXTENDED];\n\tstd::fill(f, f + MAXN_EXTENDED, 0);\n\tstd::fill(g, g + MAXN_EXTENDED, 0);\n\tstd::copy(q, q + n + 1, f);\n\tf[0] = g[0] = std::complex<long double>(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[i] = std::complex<long double>(1.0 / pow(i, 2), 0);\n\t}\n\n\tfft.multiply(f, g, n + 1);\n\tfor (int i = 1; i <= n; i++) E[i] = f[i].real();\n\n\t/*\n\tfor (int i = 0; i < (n + 1) * 2; i++) printf(\"* %lf\\n\", static_cast<double>(f[i].real()));\n\tputchar('\\n');\n\n\treturn;\n\n\tstatic std::complex<long double> r[MAXN_EXTENDED];\n\tfor (int j = 0; j <= n; j++) {\n\t\tr[j] = 0;\n\t\tfor (int i = 0; i <= j; i++) {\n\t\t\tr[j] += f[i] * g[j - i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) printf(\"* %lf\\n\", static_cast<double>(r[i].real()));\n\tputchar('\\n');\n\n\tfor (int i = 1; i <= n; i++) E[i] = r[i].real();\n\t*/\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdouble x;\n\t\tscanf(\"%lf\", &x);\n\t\tq[i] = x;\n\t}\n\n\tstatic long double E1[MAXN + 1], E2[MAXN + 1];\n\tcalc(q, E1);\n\tstd::reverse(q + 1, q + n + 1);\n\tcalc(q, E2);\n\n\tfor (int i = 1; i <= n; i++) printf(\"%.3lf\\n\", static_cast<double>(E1[i] - E2[n - i + 1]));\n\n\treturn 0;\n}\n```\n","slug":"zjoi2014-force","published":1,"updated":"2016-06-12T01:30:38.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhp1000g0jxl4ak61ggc"},{"title":"ZJOI2010 -  + ","date":"2016-06-21T00:48:00.000Z","_content":"\n $ C $  $ W $ $ 1 $ \n\n1. $ 1 $  $ N $ \n2.  $ 1 $  $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 1834](http://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n### \n\n\n**** $ W $  \n $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 5000;\nconst int MAXK = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c, *in;\n\tint l, d, f;\n\tbool q;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\n\t\tq.push(&N[s]);\n\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->in = e;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tstatic struct Edge {\n\t\tint s, t, c, w;\n\t} E[MAXM];\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tscanf(\"%d %d %d %d\", &e.s, &e.t, &e.c, &e.w);\n\t\taddEdge(e.s, e.t, e.c, 0);\n\t}\n\n\tint maxFlow = dinic(1, n, n + 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\taddEdge(e.s, e.t, INT_MAX, e.w);\n\t}\n\n\taddEdge(0, 1, k, 0);\n\n\tint flow, cost;\n\tedmondskarp(0, n, n + 1, flow, cost);\n\tprintf(\"%d %d\\n\", maxFlow, cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2010-network.md","raw":"title: ZJOI2010 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Dinic\n  - \n  - Edmonds-Karp\npermalink: zjoi2010-network\ndate: 2016-06-21 08:48:00\n---\n\n $ C $  $ W $ $ 1 $ \n\n1. $ 1 $  $ N $ \n2.  $ 1 $  $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 1834](http://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n### \n\n\n**** $ W $  \n $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 5000;\nconst int MAXK = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c, *in;\n\tint l, d, f;\n\tbool q;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\n\t\tq.push(&N[s]);\n\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->in = e;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tstatic struct Edge {\n\t\tint s, t, c, w;\n\t} E[MAXM];\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tscanf(\"%d %d %d %d\", &e.s, &e.t, &e.c, &e.w);\n\t\taddEdge(e.s, e.t, e.c, 0);\n\t}\n\n\tint maxFlow = dinic(1, n, n + 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\taddEdge(e.s, e.t, INT_MAX, e.w);\n\t}\n\n\taddEdge(0, 1, k, 0);\n\n\tint flow, cost;\n\tedmondskarp(0, n, n + 1, flow, cost);\n\tprintf(\"%d %d\\n\", maxFlow, cost);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2010-network","published":1,"updated":"2016-06-21T00:49:12.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhp8000q0jxlpyetogzg"},{"title":"ZJOI2009 - ","date":"2016-06-23T10:23:00.000Z","_content":"\nOrez  $ n \\times m $  Orez Orez \n\n<!-- more -->\n\n### \n[BZOJ 1412](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (x == 1) addEdge(s, id(i, j), INT_MAX);\n\t\t\telse if (x == 2) addEdge(id(i, j), t, INT_MAX);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), 1);\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), 1);\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), 1);\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), 1);\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2009-ws.md","raw":"title: ZJOI2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Dinic\n  - \npermalink: zjoi2009-ws\ndate: 2016-06-23 18:23:00\n---\n\nOrez  $ n \\times m $  Orez Orez \n\n<!-- more -->\n\n### \n[BZOJ 1412](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (x == 1) addEdge(s, id(i, j), INT_MAX);\n\t\t\telse if (x == 2) addEdge(id(i, j), t, INT_MAX);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), 1);\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), 1);\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), 1);\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), 1);\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2009-ws","published":1,"updated":"2016-06-23T10:23:36.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhph00120jxlf8v4vtf6"},{"title":"ZJOI2008 - DP","date":"2016-11-13T02:00:00.000Z","_content":"\n $ k $ party  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1037](http://www.lydsy.com/JudgeOnline/problem.php?id=1037)\n\n### \n $ f(i, j, p, q) $  $ i $  $ j $  $ i $  $ p $  $ q $ \n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j + 1, p + 1, \\max(q - 1, 0)) $$\n\n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j, \\max(p - 1, 0), q + 1) $$\n\n $ \\sum\\limits_{p = 0} ^ k \\sum\\limits_{q = 0} ^ k f(n + m, n, p, q) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 150;\nconst int MAXK = 20;\nconst int MOD = 12345678;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t// f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q\n\tstatic int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2];\n\tf[0][0][0][0] = 1;\n\tfor (int i = 0; i < n + m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tfor (int q = 0; q <= k; q++) {\n\t\t\t\t\t// Add a boy\n\t\t\t\t\t(f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD;\n\t\t\t\t\t// Add a girl\n\t\t\t\t\t(f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int p = 0; p <= k; p++) for (int q = 0; q <= k; q++) (ans += f[n + m][n][p][q]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2008-party.md","raw":"title: ZJOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - DP\npermalink: zjoi2008-party\ndate: 2016-11-13 10:00:00\n---\n\n $ k $ party  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1037](http://www.lydsy.com/JudgeOnline/problem.php?id=1037)\n\n### \n $ f(i, j, p, q) $  $ i $  $ j $  $ i $  $ p $  $ q $ \n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j + 1, p + 1, \\max(q - 1, 0)) $$\n\n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j, \\max(p - 1, 0), q + 1) $$\n\n $ \\sum\\limits_{p = 0} ^ k \\sum\\limits_{q = 0} ^ k f(n + m, n, p, q) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 150;\nconst int MAXK = 20;\nconst int MOD = 12345678;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t// f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q\n\tstatic int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2];\n\tf[0][0][0][0] = 1;\n\tfor (int i = 0; i < n + m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tfor (int q = 0; q <= k; q++) {\n\t\t\t\t\t// Add a boy\n\t\t\t\t\t(f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD;\n\t\t\t\t\t// Add a girl\n\t\t\t\t\t(f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int p = 0; p <= k; p++) for (int q = 0; q <= k; q++) (ans += f[n + m][n][p][q]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"zjoi2008-party","published":1,"updated":"2016-11-13T02:13:03.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhpo001a0jxlivjq2nyn"},{"title":"ZJOI2008 - ","date":"2016-11-13T01:53:00.000Z","_content":"\n $ n $  $ 2, 1, 0 $\n\n<!-- more -->\n\n### \n[BZOJ 1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034)\n\n### \n A  B  B  A  B \n\n\n\n### \n```c++\n#include <cstdio>\n#include <set>\n\nconst int MAXN = 100000;\n\nint n;\n\ninline int solve(const int *a, const int *b) {\n\tstd::multiset<int> sa, sb;\n\tfor (int i = 0; i < n; i++) sa.insert(a[i]), sb.insert(b[i]);\n\n\tint ans = 0;\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); ) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (target == sb.begin()) {\n\t\t\tit++;\n\t\t} else {\n\t\t\ttarget--;\n\t\t\tsb.erase(target);\n\t\t\tsa.erase(it++);\n\t\t\tans += 2;\n\t\t}\n\t}\n\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); it++) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (*target == *it) sb.erase(target), ans++;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\t/*\n\tstd::sort(a, a + n);\n\tstd::sort(b, b + n);\n\t*/\n\n\tprintf(\"%d %d\\n\", solve(a, b), n * 2 - solve(b, a));\n\t\n\treturn 0;\n}\n```","source":"_posts/zjoi2008-bnb.md","raw":"title: ZJOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \npermalink: zjoi2008-bnb\ndate: 2016-11-13 09:53:00\n---\n\n $ n $  $ 2, 1, 0 $\n\n<!-- more -->\n\n### \n[BZOJ 1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034)\n\n### \n A  B  B  A  B \n\n\n\n### \n```c++\n#include <cstdio>\n#include <set>\n\nconst int MAXN = 100000;\n\nint n;\n\ninline int solve(const int *a, const int *b) {\n\tstd::multiset<int> sa, sb;\n\tfor (int i = 0; i < n; i++) sa.insert(a[i]), sb.insert(b[i]);\n\n\tint ans = 0;\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); ) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (target == sb.begin()) {\n\t\t\tit++;\n\t\t} else {\n\t\t\ttarget--;\n\t\t\tsb.erase(target);\n\t\t\tsa.erase(it++);\n\t\t\tans += 2;\n\t\t}\n\t}\n\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); it++) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (*target == *it) sb.erase(target), ans++;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\t/*\n\tstd::sort(a, a + n);\n\tstd::sort(b, b + n);\n\t*/\n\n\tprintf(\"%d %d\\n\", solve(a, b), n * 2 - solve(b, a));\n\t\n\treturn 0;\n}\n```","slug":"zjoi2008-bnb","published":1,"updated":"2016-11-13T01:53:48.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhpv001g0jxlsw5fh7eh"},{"title":"ZJOI2008 -  + ","date":"2016-05-23T13:26:00.000Z","_content":"\n[](https://www.zybuluo.com/Jerusalem/note/221811)\n\n<!-- more -->\n\n### \n[BZOJ 1033](http://www.lydsy.com/JudgeOnline/problem.php?id=1033)  \n[COGS 2048](http://cogs.top/cogs/problem/problem.php?pid=2048)\n\n### \n \n\n $ a $ $ b $ $ a $ $ b $\n\n\n\n$$\n\\begin{cases}\na \\leq r \\\\\nb \\gt r\n\\end{cases}\n$$\n\n\n\n\n\n**** \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <list>\n#include <algorithm>\n\ntypedef long double real;\n\nconst int MAXN = 8;\nconst int MAXM = 8;\nconst int MAXS = 20;\nconst int MAXT = 200000;\nconst real EPS = 1e-6;\n\nint n, m, s, d, r, t, time;\n\nstruct Map {\n\tint message;\n\tbool reachable;\n\n\tMap() : message(0), reachable(true) {}\n} map[MAXN + 1][MAXM + 1];\n\ntemplate <typename T>\nstruct Point {\n\tT x, y;\n\n\tPoint(const T x = 0, const T y = 0) : x(x), y(y) {}\n\n\tMap *operator->() const { return &map[static_cast<int>(x)][static_cast<int>(y)]; }\n\n\tPoint offset(const int id) const {\n\t\tswitch (id) {\n\t\t\tcase 0: return Point(x, y + 1);\n\t\t\tcase 1: return Point(x + 1, y);\n\t\t\tcase 2: return Point(x, y - 1);\n\t\t\tcase 3: return Point(x - 1, y);\n\t\t\tdefault: return *this;\n\t\t}\n\t}\n\n\tbool valid() const { return x >= 0 && x <= n && y >= 0 && y <= m; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\n\ninline bool dcmp(const real a) { return fabs(a) <= EPS; }\ninline bool dcmp(const real a, const real b) { return dcmp(a - b); }\n\ninline bool isnan(const real x) { return x != x; }\ninline bool isinf(const real x) { return !isnan(x) && isnan(x - x); }\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ntemplate <typename Ta, typename Tb>\ninline real distance(const Point<Ta> a, const Point<Tb> b) {\n\treturn sqrt(static_cast<real>(sqr(a.x - b.x) + sqr(a.y - b.y)));\n}\n\nstruct Ant {\n\tPoint<int> position, lastPosition;\n\tint level;\n\tint hpLimit, hp;\n\tbool hasCake;\n\tint spawnTime;\n\n\tAnt(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) {\n\t\t// printf(\"spawn Ant(%d)\\n\", level);\n\t\tposition->reachable = false;\n\t}\n\n\tinline void moveTo(const Point<int> &nextPosition) {\n\t\tlastPosition = position;\n\t\tposition = nextPosition;\n\t\tif (lastPosition == position) return;\n\t\t// printf(\"moveTo(): from [%d, %d] to [%d, %d]\\n\", lastPosition.x, lastPosition.y, position.x, position.y);\n\t\tlastPosition->reachable = true;\n\t\tposition->reachable = false;\n\t}\n\n\tinline int age() const {\n\t\treturn time - spawnTime;\n\t}\n\n\tinline bool attackable(const Point<int> &p) {\n\t\tconst real dist = distance(position, p);\n\t\treturn dist < r || dcmp(dist, r);\n\t}\n};\n\nstruct Line {\n\treal k, b;\n\n\t/*\n\t * k != nan: y = kx + b\n\t * k == nan: x = b\n\t */\n\n\tLine(const Point<int> &p1, const Point<int> &p2) {\n\t\tconst real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\t\tif (x1 == x2) {\n\t\t\tk = NAN;\n\t\t\tb = x1;\n\t\t} else {\n\t\t\tk = (y2 - y1) / (x2 - x1);\n\t\t\tb = y1 - k * x1;\n\t\t}\n\t}\n\n\tLine(const real k, const Point<int> &p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {}\n\n\tLine(const real k, const real b) : k(k), b(b) {}\n\n\tLine perpendicular(const Point<int> &p1) const {\n\t\tif (isnan(k)) return Line(0, p1.y);\n\t\telse return Line(-1.0 / k, p1);\n\t}\n};\n\nstruct Segment {\n\tPoint<int> p1, p2;\n\tLine line;\n\treal length;\n\n\tSegment(const Point<int> &p1, const Point<int> &p2) : p1(p1), p2(p2), line(p1, p2) {\n\t\tlength = distance(p1, p2);\n\t}\n};\n\nPoint<real> lineIntersection(const Line &a, const Line &b) {\n\tif (isnan(a.k) && isnan(b.k) || a.k == b.k) throw;\n\tif (isnan(a.k)) return Point<real>(a.b, a.b * b.k + b.b);\n\tif (isnan(b.k)) return Point<real>(b.b, b.b * a.k + a.b);\n\tconst real x = (b.b - a.b) / (a.k - b.k);\n\tconst real y = a.k * x + a.b;\n\treturn Point<real>(x, y);\n}\n\nbool pointOnSegment(const Point<real> &p, const Segment &s) {\n\treturn dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length);\n}\n\nbool segmentCircleIntersection(const Segment &s, const Point<int> &p, const real r) {\n\tLine v = s.line.perpendicular(p);\n\tPoint<real> is = lineIntersection(v, s.line);\n\treal min, max;\n\tif (pointOnSegment(is, s)) {\n\t\tmin = distance(is, p);\n\t\tmax = std::max(distance(is, s.p1), distance(is, s.p2));\n\t} else {\n\t\tmin = distance(p, s.p1);\n\t\tmax = distance(p, s.p2);\n\t\tif (min > max) std::swap(min, max);\n\t}\n\n\treturn (min < r || dcmp(min, r)) && (max > r || dcmp(max, r));\n}\n\nstd::list<Ant> ants;\nstd::list<Ant>::iterator cakeOwner = ants.end();\nPoint<int> towers[MAXS];\n\ninline void spawn() {\n\tif (ants.size() < 6) {\n\t\tif (map[0][0].reachable == false) return;\n\n\t\tstatic int cnt = -1;\n\t\tcnt++;\n\t\tants.push_back(Ant(cnt / 6 + 1));\n\t}\n}\n\ninline void incMessage() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tit->position->message += it->hasCake ? 5 : 2;\n\t}\n}\n\ninline void move() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"move(): _cnt = %d\\n\", _cnt);\n\n\t\tint id = -1;\n\t\t// printf(\"move(): lastPosition = [%d, %d]\\n\", it->lastPosition.x, it->lastPosition.y);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint<int> newPosition = it->position.offset(i);\n\n\t\t\tif (!newPosition.valid()) continue;\n\t\t\tif (newPosition == it->lastPosition) continue;\n\t\t\tif (!newPosition->reachable) continue;\n\n\t\t\tif (id == -1 || newPosition->message > it->position.offset(id)->message) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\n\t\t// if (id != -1) printf(\"move(): checking moving to [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\n\t\tif (id != -1 && (it->age() + 1) % 5 == 0) {\n\t\t\t// printf(\"move(): special, before = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t\tPoint<int> newPosition;\n\t\t\tdo {\n\t\t\t\tid = (id - 1 + 4) % 4;\n\t\t\t\tnewPosition = it->position.offset(id);\n\t\t\t} while (!newPosition.valid() || !newPosition->reachable || newPosition == it->lastPosition);\n\t\t\t// printf(\"move(): special, after = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t}\n\n\t\tit->moveTo(it->position.offset(id));\n\t}\n}\n\ninline void getCake() {\n\tif (cakeOwner != ants.end()) return;\n\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(n, m)) {\n\t\t\tcakeOwner = it;\n\t\t\tit->hasCake = true;\n\t\t\tit->hp = std::min(it->hpLimit, it->hp + it->hpLimit / 2);\n\t\t\t// puts(\"getCake(): got\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void attack() {\n\tfor (int i = 0; i < s; i++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"attack(): _cnt = %d\\n\", _cnt);\n\n\t\tstd::list<Ant>::iterator target = ants.end();\n\t\tif (cakeOwner != ants.end() && cakeOwner->attackable(towers[i])) {\n\t\t\ttarget = cakeOwner;\n\t\t}\n\n\t\tif (target == ants.end()) {\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\treal d = distance(it->position, towers[i]);\n\t\t\t\tif ((d < r || dcmp(d, r)) && (target == ants.end() || distance(it->position, towers[i]) < distance(target->position, towers[i]))) {\n\t\t\t\t\ttarget = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (target != ants.end()) {\n\t\t\ttarget->hp -= d;\n\t\t\tSegment s(towers[i], target->position);\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\tif (it != target && segmentCircleIntersection(s, it->position, 0.5)) {\n\t\t\t\t\t// printf(\"attack(): _cnt = %d, through [%d, %d]\\n\", _cnt, it->position.x, it->position.y);\n\t\t\t\t\tit->hp -= d;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if (it == target) printf(\"attack(): _cnt = %d, target [%d, %d]\\n\", _cnt, target->position.x, target->position.y);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void kill() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); ) {\n\t\tif (it->hp < 0) {\n\t\t\tit->position->reachable = true;\n\t\t\tif (it == cakeOwner) cakeOwner = ants.end();\n\t\t\tit = ants.erase(it);\n\t\t} else it++;\n\t}\n}\n\ninline bool check() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(0, 0) && it->hasCake) return false;\n\t}\n\n\treturn true;\n}\n\ninline void decMessage() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (map[i][j].message > 0) map[i][j].message--;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%d %d\\n%d %d %d\", &n, &m, &s, &d, &r);\n\tfor (int i = 0; i < s; i++) {\n\t\tscanf(\"%d %d\", &towers[i].x, &towers[i].y);\n\t\ttowers[i]->reachable = false;\n\t}\n\tscanf(\"%d\", &t);\n\n\ttime = 1;\n\tfor (; time <= t; time++) {\n\t\t// printf(\"main(): time = %d\\n\", time);\n\t\tspawn();\n\t\tincMessage();\n\t\tmove();\n\t\tgetCake();\n\t\tattack();\n\t\tkill();\n\t\tif (!check()) break;\n\t\tdecMessage();\n\n\t\t// for (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.y, it->position.x);\n\t\t// putchar('\\n');\n\t}\n\n\tif (time > t) puts(\"The game is going on\");\n\telse printf(\"Game over after %d seconds\\n\", time);\n\n\tprintf(\"%d\\n\", ants.size());\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.x, it->position.y);\n\n\tfclose(stdin);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2008-antbuster.md","raw":"title: ZJOI2008 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - \n  - \npermalink: zjoi2008-antbuster\ndate: 2016-05-23 21:26:00\n---\n\n[](https://www.zybuluo.com/Jerusalem/note/221811)\n\n<!-- more -->\n\n### \n[BZOJ 1033](http://www.lydsy.com/JudgeOnline/problem.php?id=1033)  \n[COGS 2048](http://cogs.top/cogs/problem/problem.php?pid=2048)\n\n### \n \n\n $ a $ $ b $ $ a $ $ b $\n\n\n\n$$\n\\begin{cases}\na \\leq r \\\\\nb \\gt r\n\\end{cases}\n$$\n\n\n\n\n\n**** \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <list>\n#include <algorithm>\n\ntypedef long double real;\n\nconst int MAXN = 8;\nconst int MAXM = 8;\nconst int MAXS = 20;\nconst int MAXT = 200000;\nconst real EPS = 1e-6;\n\nint n, m, s, d, r, t, time;\n\nstruct Map {\n\tint message;\n\tbool reachable;\n\n\tMap() : message(0), reachable(true) {}\n} map[MAXN + 1][MAXM + 1];\n\ntemplate <typename T>\nstruct Point {\n\tT x, y;\n\n\tPoint(const T x = 0, const T y = 0) : x(x), y(y) {}\n\n\tMap *operator->() const { return &map[static_cast<int>(x)][static_cast<int>(y)]; }\n\n\tPoint offset(const int id) const {\n\t\tswitch (id) {\n\t\t\tcase 0: return Point(x, y + 1);\n\t\t\tcase 1: return Point(x + 1, y);\n\t\t\tcase 2: return Point(x, y - 1);\n\t\t\tcase 3: return Point(x - 1, y);\n\t\t\tdefault: return *this;\n\t\t}\n\t}\n\n\tbool valid() const { return x >= 0 && x <= n && y >= 0 && y <= m; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\n\ninline bool dcmp(const real a) { return fabs(a) <= EPS; }\ninline bool dcmp(const real a, const real b) { return dcmp(a - b); }\n\ninline bool isnan(const real x) { return x != x; }\ninline bool isinf(const real x) { return !isnan(x) && isnan(x - x); }\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ntemplate <typename Ta, typename Tb>\ninline real distance(const Point<Ta> a, const Point<Tb> b) {\n\treturn sqrt(static_cast<real>(sqr(a.x - b.x) + sqr(a.y - b.y)));\n}\n\nstruct Ant {\n\tPoint<int> position, lastPosition;\n\tint level;\n\tint hpLimit, hp;\n\tbool hasCake;\n\tint spawnTime;\n\n\tAnt(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) {\n\t\t// printf(\"spawn Ant(%d)\\n\", level);\n\t\tposition->reachable = false;\n\t}\n\n\tinline void moveTo(const Point<int> &nextPosition) {\n\t\tlastPosition = position;\n\t\tposition = nextPosition;\n\t\tif (lastPosition == position) return;\n\t\t// printf(\"moveTo(): from [%d, %d] to [%d, %d]\\n\", lastPosition.x, lastPosition.y, position.x, position.y);\n\t\tlastPosition->reachable = true;\n\t\tposition->reachable = false;\n\t}\n\n\tinline int age() const {\n\t\treturn time - spawnTime;\n\t}\n\n\tinline bool attackable(const Point<int> &p) {\n\t\tconst real dist = distance(position, p);\n\t\treturn dist < r || dcmp(dist, r);\n\t}\n};\n\nstruct Line {\n\treal k, b;\n\n\t/*\n\t * k != nan: y = kx + b\n\t * k == nan: x = b\n\t */\n\n\tLine(const Point<int> &p1, const Point<int> &p2) {\n\t\tconst real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\t\tif (x1 == x2) {\n\t\t\tk = NAN;\n\t\t\tb = x1;\n\t\t} else {\n\t\t\tk = (y2 - y1) / (x2 - x1);\n\t\t\tb = y1 - k * x1;\n\t\t}\n\t}\n\n\tLine(const real k, const Point<int> &p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {}\n\n\tLine(const real k, const real b) : k(k), b(b) {}\n\n\tLine perpendicular(const Point<int> &p1) const {\n\t\tif (isnan(k)) return Line(0, p1.y);\n\t\telse return Line(-1.0 / k, p1);\n\t}\n};\n\nstruct Segment {\n\tPoint<int> p1, p2;\n\tLine line;\n\treal length;\n\n\tSegment(const Point<int> &p1, const Point<int> &p2) : p1(p1), p2(p2), line(p1, p2) {\n\t\tlength = distance(p1, p2);\n\t}\n};\n\nPoint<real> lineIntersection(const Line &a, const Line &b) {\n\tif (isnan(a.k) && isnan(b.k) || a.k == b.k) throw;\n\tif (isnan(a.k)) return Point<real>(a.b, a.b * b.k + b.b);\n\tif (isnan(b.k)) return Point<real>(b.b, b.b * a.k + a.b);\n\tconst real x = (b.b - a.b) / (a.k - b.k);\n\tconst real y = a.k * x + a.b;\n\treturn Point<real>(x, y);\n}\n\nbool pointOnSegment(const Point<real> &p, const Segment &s) {\n\treturn dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length);\n}\n\nbool segmentCircleIntersection(const Segment &s, const Point<int> &p, const real r) {\n\tLine v = s.line.perpendicular(p);\n\tPoint<real> is = lineIntersection(v, s.line);\n\treal min, max;\n\tif (pointOnSegment(is, s)) {\n\t\tmin = distance(is, p);\n\t\tmax = std::max(distance(is, s.p1), distance(is, s.p2));\n\t} else {\n\t\tmin = distance(p, s.p1);\n\t\tmax = distance(p, s.p2);\n\t\tif (min > max) std::swap(min, max);\n\t}\n\n\treturn (min < r || dcmp(min, r)) && (max > r || dcmp(max, r));\n}\n\nstd::list<Ant> ants;\nstd::list<Ant>::iterator cakeOwner = ants.end();\nPoint<int> towers[MAXS];\n\ninline void spawn() {\n\tif (ants.size() < 6) {\n\t\tif (map[0][0].reachable == false) return;\n\n\t\tstatic int cnt = -1;\n\t\tcnt++;\n\t\tants.push_back(Ant(cnt / 6 + 1));\n\t}\n}\n\ninline void incMessage() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tit->position->message += it->hasCake ? 5 : 2;\n\t}\n}\n\ninline void move() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"move(): _cnt = %d\\n\", _cnt);\n\n\t\tint id = -1;\n\t\t// printf(\"move(): lastPosition = [%d, %d]\\n\", it->lastPosition.x, it->lastPosition.y);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint<int> newPosition = it->position.offset(i);\n\n\t\t\tif (!newPosition.valid()) continue;\n\t\t\tif (newPosition == it->lastPosition) continue;\n\t\t\tif (!newPosition->reachable) continue;\n\n\t\t\tif (id == -1 || newPosition->message > it->position.offset(id)->message) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\n\t\t// if (id != -1) printf(\"move(): checking moving to [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\n\t\tif (id != -1 && (it->age() + 1) % 5 == 0) {\n\t\t\t// printf(\"move(): special, before = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t\tPoint<int> newPosition;\n\t\t\tdo {\n\t\t\t\tid = (id - 1 + 4) % 4;\n\t\t\t\tnewPosition = it->position.offset(id);\n\t\t\t} while (!newPosition.valid() || !newPosition->reachable || newPosition == it->lastPosition);\n\t\t\t// printf(\"move(): special, after = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t}\n\n\t\tit->moveTo(it->position.offset(id));\n\t}\n}\n\ninline void getCake() {\n\tif (cakeOwner != ants.end()) return;\n\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(n, m)) {\n\t\t\tcakeOwner = it;\n\t\t\tit->hasCake = true;\n\t\t\tit->hp = std::min(it->hpLimit, it->hp + it->hpLimit / 2);\n\t\t\t// puts(\"getCake(): got\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void attack() {\n\tfor (int i = 0; i < s; i++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"attack(): _cnt = %d\\n\", _cnt);\n\n\t\tstd::list<Ant>::iterator target = ants.end();\n\t\tif (cakeOwner != ants.end() && cakeOwner->attackable(towers[i])) {\n\t\t\ttarget = cakeOwner;\n\t\t}\n\n\t\tif (target == ants.end()) {\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\treal d = distance(it->position, towers[i]);\n\t\t\t\tif ((d < r || dcmp(d, r)) && (target == ants.end() || distance(it->position, towers[i]) < distance(target->position, towers[i]))) {\n\t\t\t\t\ttarget = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (target != ants.end()) {\n\t\t\ttarget->hp -= d;\n\t\t\tSegment s(towers[i], target->position);\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\tif (it != target && segmentCircleIntersection(s, it->position, 0.5)) {\n\t\t\t\t\t// printf(\"attack(): _cnt = %d, through [%d, %d]\\n\", _cnt, it->position.x, it->position.y);\n\t\t\t\t\tit->hp -= d;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if (it == target) printf(\"attack(): _cnt = %d, target [%d, %d]\\n\", _cnt, target->position.x, target->position.y);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void kill() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); ) {\n\t\tif (it->hp < 0) {\n\t\t\tit->position->reachable = true;\n\t\t\tif (it == cakeOwner) cakeOwner = ants.end();\n\t\t\tit = ants.erase(it);\n\t\t} else it++;\n\t}\n}\n\ninline bool check() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(0, 0) && it->hasCake) return false;\n\t}\n\n\treturn true;\n}\n\ninline void decMessage() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (map[i][j].message > 0) map[i][j].message--;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%d %d\\n%d %d %d\", &n, &m, &s, &d, &r);\n\tfor (int i = 0; i < s; i++) {\n\t\tscanf(\"%d %d\", &towers[i].x, &towers[i].y);\n\t\ttowers[i]->reachable = false;\n\t}\n\tscanf(\"%d\", &t);\n\n\ttime = 1;\n\tfor (; time <= t; time++) {\n\t\t// printf(\"main(): time = %d\\n\", time);\n\t\tspawn();\n\t\tincMessage();\n\t\tmove();\n\t\tgetCake();\n\t\tattack();\n\t\tkill();\n\t\tif (!check()) break;\n\t\tdecMessage();\n\n\t\t// for (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.y, it->position.x);\n\t\t// putchar('\\n');\n\t}\n\n\tif (time > t) puts(\"The game is going on\");\n\telse printf(\"Game over after %d seconds\\n\", time);\n\n\tprintf(\"%d\\n\", ants.size());\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.x, it->position.y);\n\n\tfclose(stdin);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2008-antbuster","published":1,"updated":"2016-05-23T13:27:10.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhq1001m0jxlba1hhfw0"},{"title":"ZJOI2007 -  DP","date":"2016-05-18T03:58:00.000Z","_content":"\n $ i $  $ P_i $  $ i $  $ C_i $ $ N $ $ 1 $  $ 1 $\n\n1.  $ i $  $ 1 $  $ x_i $ $ x_1 = 0 $\n2.  $ i $  $ p_i $\n3.  $ i $  $ c_i $\n\n + \n\n<!-- more -->\n\n### \n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### \n $ S(i) $  $ i $  $ 1 $ $ s(i) $  $ i $ \n\n $ f(i) $  i \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","source":"_posts/zjoi2007-storage.md","raw":"title: ZJOI2007 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - \n  - DP\npermalink: zjoi2007-storage\ndate: 2016-05-18 11:58:00\n---\n\n $ i $  $ P_i $  $ i $  $ C_i $ $ N $ $ 1 $  $ 1 $\n\n1.  $ i $  $ 1 $  $ x_i $ $ x_1 = 0 $\n2.  $ i $  $ p_i $\n3.  $ i $  $ c_i $\n\n + \n\n<!-- more -->\n\n### \n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### \n $ S(i) $  $ i $  $ 1 $ $ s(i) $  $ i $ \n\n $ f(i) $  i \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","slug":"zjoi2007-storage","published":1,"updated":"2016-10-24T23:28:04.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhq7001x0jxl1ofxiq8g"},{"title":"ZJOI2007 - ","date":"2016-09-03T23:38:00.000Z","_content":"\n $ G = (V, E) $ Semi-Connected\n\n> $ \\forall u, v \\in V $ $ u \\rightarrow v $  $ v \\rightarrow u $ $ u $$ v $ $ u $  $ v $  $ v $  $ u $ \n\n $ G' = (V', E') $  $ V' \\subseteq V $$ E' $  $ E $  $ V' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G $ \n\n $ G $ $ G $  $ K $ $ C $ $ C $  $ C $  $ X $ \n\n<!-- more -->\n\n### \n[BZOJ 1093](http://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n### \n\n\n DAG  DP \n\n $ d(i) $  $ u \\rightarrow v $ $ d(v) = d(u) + s(v) $$ s(i) $  $ i $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst int MAXX = 100000000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tstruct SCC *s;\n\tNode *p;\n\tbool inStack, pushed, visited;\n\tint dfn, low, d, sum;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size, inDegree, in, len, sum;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, x;\n\ninline int tarjan() {\n\tint cnt = 0, ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\t\t\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tt.push(v);\n\t\t\t\tv->inStack = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->inStack) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tscc->v.s = scc;\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->s = scc;\n\t\t\t\t\t\tscc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tstd::tr1::unordered_set<unsigned long long> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tunsigned long long x = (static_cast<unsigned long long>(e->s->s - S) << 32) | static_cast<unsigned long long>(e->t->s - S);\n\t\t\tif (e->s->s != e->t->s && !s.count(x)) {\n\t\t\t\ts.insert(x);\n\t\t\t\t// printf(\"[%ld, %ld]\\n\", e->s->s - S + 1, e->t->s - S + 1);\n\t\t\t\te->s->s->v.e = new Edge(&e->s->s->v, &e->t->s->v);\n\t\t\t\te->t->s->inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dp(const int cnt) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"size[%d] = %d\\n\", i, S[i].size);\n\t\tif (S[i].inDegree == 0) q.push(&S[i].v);\n\t\tS[i].v.d = S[i].size;\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\te->t->d = std::max(e->t->d, v->d + e->t->s->size);\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d);\n\treturn ans;\n}\n\ninline int dpSum(const int cnt, const int d) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].inDegree == 0) {\n\t\t\tq.push(&S[i].v);\n\t\t\tS[i].v.sum = 1;\n\t\t}\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->d == v->d + e->t->s->size) (e->t->sum += v->sum) %= x;\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x;\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint d = dp(cnt);\n\n\tprintf(\"%d\\n\", d);\n\tprintf(\"%d\\n\", dpSum(cnt, d));\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2007-semi.md","raw":"title: ZJOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Tarjan\n  - \n  - DP\npermalink: zjoi2007-semi\ndate: 2016-09-04 07:38:00\n---\n\n $ G = (V, E) $ Semi-Connected\n\n> $ \\forall u, v \\in V $ $ u \\rightarrow v $  $ v \\rightarrow u $ $ u $$ v $ $ u $  $ v $  $ v $  $ u $ \n\n $ G' = (V', E') $  $ V' \\subseteq V $$ E' $  $ E $  $ V' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G $ \n\n $ G $ $ G $  $ K $ $ C $ $ C $  $ C $  $ X $ \n\n<!-- more -->\n\n### \n[BZOJ 1093](http://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n### \n\n\n DAG  DP \n\n $ d(i) $  $ u \\rightarrow v $ $ d(v) = d(u) + s(v) $$ s(i) $  $ i $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst int MAXX = 100000000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tstruct SCC *s;\n\tNode *p;\n\tbool inStack, pushed, visited;\n\tint dfn, low, d, sum;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size, inDegree, in, len, sum;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, x;\n\ninline int tarjan() {\n\tint cnt = 0, ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\t\t\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tt.push(v);\n\t\t\t\tv->inStack = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->inStack) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tscc->v.s = scc;\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->s = scc;\n\t\t\t\t\t\tscc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tstd::tr1::unordered_set<unsigned long long> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tunsigned long long x = (static_cast<unsigned long long>(e->s->s - S) << 32) | static_cast<unsigned long long>(e->t->s - S);\n\t\t\tif (e->s->s != e->t->s && !s.count(x)) {\n\t\t\t\ts.insert(x);\n\t\t\t\t// printf(\"[%ld, %ld]\\n\", e->s->s - S + 1, e->t->s - S + 1);\n\t\t\t\te->s->s->v.e = new Edge(&e->s->s->v, &e->t->s->v);\n\t\t\t\te->t->s->inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dp(const int cnt) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"size[%d] = %d\\n\", i, S[i].size);\n\t\tif (S[i].inDegree == 0) q.push(&S[i].v);\n\t\tS[i].v.d = S[i].size;\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\te->t->d = std::max(e->t->d, v->d + e->t->s->size);\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d);\n\treturn ans;\n}\n\ninline int dpSum(const int cnt, const int d) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].inDegree == 0) {\n\t\t\tq.push(&S[i].v);\n\t\t\tS[i].v.sum = 1;\n\t\t}\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->d == v->d + e->t->s->size) (e->t->sum += v->sum) %= x;\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x;\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint d = dp(cnt);\n\n\tprintf(\"%d\\n\", d);\n\tprintf(\"%d\\n\", dpSum(cnt, d));\n\n\treturn 0;\n}\n```","slug":"zjoi2007-semi","published":1,"updated":"2016-09-03T23:51:14.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhqc00270jxlzju38atf"},{"title":"ZJOI2006 -  + DP","date":"2016-05-23T13:41:00.000Z","_content":"\n $ A $  $ B $ $ n $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)  \n[COGS 1824](http://cogs.top/cogs/problem/problem.php?pid=1824)\n\n### \n\n\n $ c(l,\\ r) $  $ l $  $ r $  $ f(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + k + c(j + 1,\\ i) \\} $$\n\n $ c(j + 1,\\ i) $  $ j + 1 $  $ i $ \n\n $ f(n) - k $ $ O(n ^ 2 m \\log m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <utility>\n#include <functional>\n\nstruct Node;\nstruct Edge;\n\nconst int MAXN = 20;\nconst int MAXD = 100;\n\nstruct Node {\n\tEdge *e;\n\tint d;\n\tbool flag[MAXD], invalid;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const int w) {\n\tN[u].e = new Edge(&N[u], &N[v], w);\n\tN[v].e = new Edge(&N[v], &N[u], w);\n}\n\nint d, n, k, m, c[MAXD + 1][MAXD + 1];\nint f[MAXD + 1];\n\ninline int dijkstra(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].d = INT_MAX;\n\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tN[s].d = 0;\n\tq.push(std::make_pair(0, &N[s]));\n\n\twhile (!q.empty()) {\n\t\tconst std::pair<int, Node *> p = q.top();\n\t\tq.pop();\n\n\t\tNode *v = p.second;\n\n\t\tif (v->d != p.first) continue;\n\t\tif (v->d > N[t].d) break;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\n\t\t\tif (e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\tq.push(std::make_pair(e->t->d, e->t));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn N[t].d;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &d, &n, &k, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint u, l, r;\n\t\tscanf(\"%d %d %d\", &u, &l, &r), u--, l--, r--;\n\t\tstd::fill(N[u].flag + l, N[u].flag + r + 1, true);\n\t}\n\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = i; j <= d; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tN[k].invalid = false;\n\t\t\t\tfor (int l = i; l <= j; l++) {\n\t\t\t\t\tif (N[k].flag[l - 1]) {\n\t\t\t\t\t\tN[k].invalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc[i][j] = dijkstra(0, n - 1);\n\t\t\tif (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1);\n\t\t\t// printf(\"%d\\n\", c[i][j]);\n\t\t}\n\t}\n\n\tstd::fill(f, f + d + 1, INT_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (c[j + 1][i] != INT_MAX) {\n\t\t\t\tf[i] = std::min(f[i], f[j] + k + c[j + 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[d] - k);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2006-trans.md","raw":"title: ZJOI2006 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - DP\npermalink: zjoi2006-trans\ndate: 2016-05-23 21:41:00\n---\n\n $ A $  $ B $ $ n $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)  \n[COGS 1824](http://cogs.top/cogs/problem/problem.php?pid=1824)\n\n### \n\n\n $ c(l,\\ r) $  $ l $  $ r $  $ f(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + k + c(j + 1,\\ i) \\} $$\n\n $ c(j + 1,\\ i) $  $ j + 1 $  $ i $ \n\n $ f(n) - k $ $ O(n ^ 2 m \\log m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <utility>\n#include <functional>\n\nstruct Node;\nstruct Edge;\n\nconst int MAXN = 20;\nconst int MAXD = 100;\n\nstruct Node {\n\tEdge *e;\n\tint d;\n\tbool flag[MAXD], invalid;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const int w) {\n\tN[u].e = new Edge(&N[u], &N[v], w);\n\tN[v].e = new Edge(&N[v], &N[u], w);\n}\n\nint d, n, k, m, c[MAXD + 1][MAXD + 1];\nint f[MAXD + 1];\n\ninline int dijkstra(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].d = INT_MAX;\n\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tN[s].d = 0;\n\tq.push(std::make_pair(0, &N[s]));\n\n\twhile (!q.empty()) {\n\t\tconst std::pair<int, Node *> p = q.top();\n\t\tq.pop();\n\n\t\tNode *v = p.second;\n\n\t\tif (v->d != p.first) continue;\n\t\tif (v->d > N[t].d) break;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\n\t\t\tif (e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\tq.push(std::make_pair(e->t->d, e->t));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn N[t].d;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &d, &n, &k, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint u, l, r;\n\t\tscanf(\"%d %d %d\", &u, &l, &r), u--, l--, r--;\n\t\tstd::fill(N[u].flag + l, N[u].flag + r + 1, true);\n\t}\n\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = i; j <= d; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tN[k].invalid = false;\n\t\t\t\tfor (int l = i; l <= j; l++) {\n\t\t\t\t\tif (N[k].flag[l - 1]) {\n\t\t\t\t\t\tN[k].invalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc[i][j] = dijkstra(0, n - 1);\n\t\t\tif (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1);\n\t\t\t// printf(\"%d\\n\", c[i][j]);\n\t\t}\n\t}\n\n\tstd::fill(f, f + d + 1, INT_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (c[j + 1][i] != INT_MAX) {\n\t\t\t\tf[i] = std::min(f[i], f[j] + k + c[j + 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[d] - k);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2006-trans","published":1,"updated":"2016-05-23T13:42:15.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhqi002i0jxlfvryob26"},{"title":"ZJOI2004 - ","date":"2016-10-07T22:54:00.000Z","_content":"\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1898](www.lydsy.com/JudgeOnline/problem.php?id=1898)  \n[COGS 1469](http://cogs.pro/cogs/problem/problem.php?pid=1469)\n\n### \n $ k $  $ s $  $ t $ \n\n****\n\n $ \\mathrm{lcm}(2, 3, 4) = 12 $ $ 12 $  $ 12 $  $ k $  $ 12 $  $ 11 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 50;\nconst int MAXM = 20;\nconst long long MAXK = 2e9;\nconst int CYCLE_LCM = 12;\nconst int MOD = 10000;\n\nstruct Matrix {\n\tint a[MAXN][MAXN];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXN; i++) a[i][i] = 1;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res;\n\tfor (int i = 0; i < MAXN; i++) for (int j = 0; j < MAXN; j++) for (int k = 0; k < MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"swamp.in\", \"r\", stdin);\n\tfreopen(\"swamp.out\", \"w\", stdout);\n\n\tint n, m, st, ed, k;\n\tscanf(\"%d %d %d %d %d\", &n, &m, &st, &ed, &k);\n\n\tMatrix g;\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tg(u, v)++;\n\t\tg(v, u)++;\n\t}\n\n\tMatrix gs[CYCLE_LCM];\n\tfor (int i = 0; i < CYCLE_LCM; i++) gs[i] = g;\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint cycle;\n\t\tscanf(\"%d\", &cycle);\n\t\tfor (int i = 0; i < cycle; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfor (int j = i; j < CYCLE_LCM; j += cycle) {\n\t\t\t\tfor (int l = 0; l < n; l++) gs[j](x, l) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", g(i, j), j == n - 1 ? '\\n' : ' ');\n\tputs(\"-------------\");\n\tfor (int l = 0; l < CYCLE_LCM; l++) {\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", gs[l](i, j), j == n - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------\");\n\t}\n#endif\n\n#ifndef FORCE\n\tMatrix prod(true);\n\tfor (int i = 0; i < CYCLE_LCM; i++) prod = prod * gs[i];\n\n\tMatrix res = pow(prod, k / CYCLE_LCM);\n\tfor (int i = 0; i < k % CYCLE_LCM; i++) res = res * gs[i];\n#else\n\tMatrix res(true);\n\tfor (int i = 0; i < k; i++) res = res * gs[i % CYCLE_LCM];\n#endif\n\n\tprintf(\"%d\\n\", res(st, ed));\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", res(i, j), j == n - 1 ? '\\n' : ' ');\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2004-swamp.md","raw":"title: ZJOI2004 - \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - DP\npermalink: zjoi2004-swamp\ndate: 2016-10-08 06:54:00\n---\n\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1898](www.lydsy.com/JudgeOnline/problem.php?id=1898)  \n[COGS 1469](http://cogs.pro/cogs/problem/problem.php?pid=1469)\n\n### \n $ k $  $ s $  $ t $ \n\n****\n\n $ \\mathrm{lcm}(2, 3, 4) = 12 $ $ 12 $  $ 12 $  $ k $  $ 12 $  $ 11 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 50;\nconst int MAXM = 20;\nconst long long MAXK = 2e9;\nconst int CYCLE_LCM = 12;\nconst int MOD = 10000;\n\nstruct Matrix {\n\tint a[MAXN][MAXN];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXN; i++) a[i][i] = 1;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res;\n\tfor (int i = 0; i < MAXN; i++) for (int j = 0; j < MAXN; j++) for (int k = 0; k < MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"swamp.in\", \"r\", stdin);\n\tfreopen(\"swamp.out\", \"w\", stdout);\n\n\tint n, m, st, ed, k;\n\tscanf(\"%d %d %d %d %d\", &n, &m, &st, &ed, &k);\n\n\tMatrix g;\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tg(u, v)++;\n\t\tg(v, u)++;\n\t}\n\n\tMatrix gs[CYCLE_LCM];\n\tfor (int i = 0; i < CYCLE_LCM; i++) gs[i] = g;\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint cycle;\n\t\tscanf(\"%d\", &cycle);\n\t\tfor (int i = 0; i < cycle; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfor (int j = i; j < CYCLE_LCM; j += cycle) {\n\t\t\t\tfor (int l = 0; l < n; l++) gs[j](x, l) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", g(i, j), j == n - 1 ? '\\n' : ' ');\n\tputs(\"-------------\");\n\tfor (int l = 0; l < CYCLE_LCM; l++) {\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", gs[l](i, j), j == n - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------\");\n\t}\n#endif\n\n#ifndef FORCE\n\tMatrix prod(true);\n\tfor (int i = 0; i < CYCLE_LCM; i++) prod = prod * gs[i];\n\n\tMatrix res = pow(prod, k / CYCLE_LCM);\n\tfor (int i = 0; i < k % CYCLE_LCM; i++) res = res * gs[i];\n#else\n\tMatrix res(true);\n\tfor (int i = 0; i < k; i++) res = res * gs[i % CYCLE_LCM];\n#endif\n\n\tprintf(\"%d\\n\", res(st, ed));\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", res(i, j), j == n - 1 ? '\\n' : ' ');\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"zjoi2004-swamp","published":1,"updated":"2016-10-07T23:08:49.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhqn002q0jxlwblyl8l1"},{"title":"OS X  Linux ","date":"2016-03-07T01:04:27.000Z","_content":"\nOS X  GNU/Linux  GNU/Linux  OS X  OS X  GNU/Linux   \n\n `VirtualBox`  Archlinux  OS X \n\n<!-- more -->\n\n##  OpenSSH\n Arch Linux \n\n OpenSSH\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## \nNAT\n\n![](virtualbox-archlinux/network.png)\n\n\n\n![](virtualbox-archlinux/port.png)\n\n `22` `1000`  OS X  `root`  `1000` \n\n Terminal \n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## \n Virtualbox \n\n![](virtualbox-archlinux/share.png)\n\n\n\n### `rc.local` \n\nArchlinux  systemd  `rc.local` \n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n `rc.local` \n\n```bash\nsudo systemctl enable rc-local\n```\n\n### \n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n\n\n## SSH \n SSH \n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n `~/.ssh` \n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n\n\n SSH \n\n##  Terminal \nTerminal  `Command + N` SSH \n\n### \n Terminal BasicBasic Linux `Shell`  SSH Shell \n\n![](virtualbox-archlinux/terminal.png)\n\n\n\n### \n\n\n\n\n![](virtualbox-archlinux/hotkey.png)\n\n\n\n## \n Terminal  `Command + B`\n\n![](virtualbox-archlinux/screenfetch.png)\n\n `screenfetch`\n","source":"_posts/virtualbox-archlinux.md","raw":"title: OS X  Linux \ncategories: Geek\ntags: \n  - OS X\n  - Linux\n  - Archlinux\n  - VirtualBox\n  - \n  - SSH\npermalink: virtualbox-archlinux\ndate: 2016-03-07 09:04:27\n---\n\nOS X  GNU/Linux  GNU/Linux  OS X  OS X  GNU/Linux   \n\n `VirtualBox`  Archlinux  OS X \n\n<!-- more -->\n\n##  OpenSSH\n Arch Linux \n\n OpenSSH\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## \nNAT\n\n![](virtualbox-archlinux/network.png)\n\n\n\n![](virtualbox-archlinux/port.png)\n\n `22` `1000`  OS X  `root`  `1000` \n\n Terminal \n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## \n Virtualbox \n\n![](virtualbox-archlinux/share.png)\n\n\n\n### `rc.local` \n\nArchlinux  systemd  `rc.local` \n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n `rc.local` \n\n```bash\nsudo systemctl enable rc-local\n```\n\n### \n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n\n\n## SSH \n SSH \n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n `~/.ssh` \n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n\n\n SSH \n\n##  Terminal \nTerminal  `Command + N` SSH \n\n### \n Terminal BasicBasic Linux `Shell`  SSH Shell \n\n![](virtualbox-archlinux/terminal.png)\n\n\n\n### \n\n\n\n\n![](virtualbox-archlinux/hotkey.png)\n\n\n\n## \n Terminal  `Command + B`\n\n![](virtualbox-archlinux/screenfetch.png)\n\n `screenfetch`\n","slug":"virtualbox-archlinux","published":1,"updated":"2016-05-11T09:33:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhqt002y0jxlpvxp6lah"},{"title":"UVa 1362Exploring Pyramids -  DP + ","date":"2016-03-14T08:32:16.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### \n $ f(i, j) $  $ S $  $ i $  $ j $ \n\n1.  $ i = j $ $ f(i, j) = 1 $\n2.  $ S(i) \\neq S(j) $ $ f(i, j) = 0 $\n\n $ k $ $ i = k = j $  $ (i, k) $  $ [k, j] $ \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","source":"_posts/uva-1362.md","raw":"title: UVa 1362Exploring Pyramids -  DP + \ncategories: OI\ntags: \n  - UVa\n  - \n  - DP\n  -  DP\n  - \npermalink: uva-1362\ndate: 2016-03-14 16:32:16\n---\n\n\n\n<!-- more -->\n\n### \n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### \n $ f(i, j) $  $ S $  $ i $  $ j $ \n\n1.  $ i = j $ $ f(i, j) = 1 $\n2.  $ S(i) \\neq S(j) $ $ f(i, j) = 0 $\n\n $ k $ $ i = k = j $  $ (i, k) $  $ [k, j] $ \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","slug":"uva-1362","published":1,"updated":"2016-10-24T23:28:14.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhru003d0jxlspk5qhq1"},{"title":"UVa 11806Cheerleaders -  + ","date":"2016-03-11T14:10:34.000Z","_content":"\n $ M * N $  $ K $  $ \nM $  $ N $ \n\n<!-- more -->\n\n### \n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### \n1.  $ A $$ C $  $ M $ \n****\n2.  $ B $$ D $  $ N $ \n****\n3.  $ S $  $ M * N $ **** $ K $ \n\n\n $ S $  $ A $$ B $$ C $$ D $ \n\n\n\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11806.md","raw":"title: UVa 11806Cheerleaders -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11806\ndate: 2016-03-11 22:10:34\n---\n\n $ M * N $  $ K $  $ \nM $  $ N $ \n\n<!-- more -->\n\n### \n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### \n1.  $ A $$ C $  $ M $ \n****\n2.  $ B $$ D $  $ N $ \n****\n3.  $ S $  $ M * N $ **** $ K $ \n\n\n $ S $  $ A $$ B $$ C $$ D $ \n\n\n\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11806","published":1,"updated":"2016-05-11T09:33:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhrz003n0jxlw115yahf"},{"title":"UVa 11538Chess Queen - ","date":"2016-03-12T02:47:13.000Z","_content":"\n $ N * M $ \n\n<!-- more -->\n\n### \n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### \n\n\n $ f(a, b) $  $ a $  $ b $  $ a = 1 $ $ b $  $ b - 1 $ \n\n$$ f(1, b) = b(b - 1) $$\n\n\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n\n\n $ m  n $ $ m - n + 1 $  $ n $ $ n - 1 $ \n\n![ \nLibreOffice Calc \n](uva-11538/cells.png)\n\n $ m - n + 1 $  $ n $ **** $ f(m - n + 1, n) $\n\n\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n$ O(n) $ \n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11538.md","raw":"title: UVa 11538Chess Queen - \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11538\ndate: 2016-03-12 10:47:13\n---\n\n $ N * M $ \n\n<!-- more -->\n\n### \n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### \n\n\n $ f(a, b) $  $ a $  $ b $  $ a = 1 $ $ b $  $ b - 1 $ \n\n$$ f(1, b) = b(b - 1) $$\n\n\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n\n\n $ m  n $ $ m - n + 1 $  $ n $ $ n - 1 $ \n\n![ \nLibreOffice Calc \n](uva-11538/cells.png)\n\n $ m - n + 1 $  $ n $ **** $ f(m - n + 1, n) $\n\n\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n$ O(n) $ \n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11538","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhs6003v0jxlhah65gxj"},{"title":"UVa 11375Matches - ","date":"2016-03-13T03:07:45.000Z","_content":"\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### \n 0  $ f(i) $  $ i $  $ c(x) $  x \n\n 1 ~ 9 \n\n $ f(i) $  $ f(i + c(x)) $$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $ $ f(i) $  $ x $ \n\n $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $  $ n \\geq 6 $  0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11375.md","raw":"title: UVa 11375Matches - \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11375\ndate: 2016-03-13 11:07:45\n---\n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### \n 0  $ f(i) $  $ i $  $ c(x) $  x \n\n 1 ~ 9 \n\n $ f(i) $  $ f(i + c(x)) $$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $ $ f(i) $  $ x $ \n\n $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $  $ n \\geq 6 $  0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11375","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhsk00410jxl41s1ltan"},{"title":"UVa 11361Investigating Div-Sum Property -  DP","date":"2016-03-15T00:53:05.000Z","_content":"\n $ [a, b] $  $ x $ \n\n1. $ x $  $ k $ \n2. $ x $  $ k $ \n\n<!-- more -->\n\n### \n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### \n $ {\\rm sum}(x) $  $ x $ $ g(x, m_1, m_2) $  $ [0, x] $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ g(b, 0, 0) - g(a - 1, 0, 0) $\n\n $ f(n, m_1, m_2) $  $ n $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ f $  1 ~ 9\n\n$ g $  $ x $  $ t $ $ [0, t) $  $ f $  $ x $\n\n$ k $  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11361.md","raw":"title: UVa 11361Investigating Div-Sum Property -  DP\ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - DP\n  -  DP\npermalink: uva-11361\ndate: 2016-03-15 08:53:05\n---\n\n $ [a, b] $  $ x $ \n\n1. $ x $  $ k $ \n2. $ x $  $ k $ \n\n<!-- more -->\n\n### \n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### \n $ {\\rm sum}(x) $  $ x $ $ g(x, m_1, m_2) $  $ [0, x] $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ g(b, 0, 0) - g(a - 1, 0, 0) $\n\n $ f(n, m_1, m_2) $  $ n $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ f $  1 ~ 9\n\n$ g $  $ x $  $ t $ $ [0, t) $  $ f $  $ x $\n\n$ k $  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11361","published":1,"updated":"2016-10-24T23:28:44.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhsn00490jxlfz88b4yy"},{"title":"UVa 11174Stand in a Line -  + ","date":"2016-03-13T09:20:34.000Z","_content":"\n $ N $$ N \\leq 40000 $\n\n<!-- more -->\n\n### \n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### \n\n\n $ f(i) $  $ i $  $ s(i) $  $ i $ \n\n$ i $ \n\n$ i $ ********\n\n\n\n $ c(i) $  $ i $ \n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11174.md","raw":"title: UVa 11174Stand in a Line -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: uva-11174\ndate: 2016-03-13 17:20:34\n---\n\n $ N $$ N \\leq 40000 $\n\n<!-- more -->\n\n### \n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### \n\n\n $ f(i) $  $ i $  $ s(i) $  $ i $ \n\n$ i $ \n\n$ i $ ********\n\n\n\n $ c(i) $  $ i $ \n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11174","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhsr004h0jxlv181n4al"},{"title":"UVa 11137Ingenuous Cubrency -  /  DP","date":"2016-03-13T03:56:43.000Z","_content":"\n $ N $$ N \\leq 1000 $ $ N $ \n\n<!-- more -->\n\n### \n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### \n $ f(i, j) $  $ i $  $ j $  i  j $ i^3 $  $ x $  $ j + xi^3 \\leq 1000 $ $ f(i - 1, j) $  $ f(i, j + xi^3) $ $ f(21, n) $ \n\n 1000 \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11137.md","raw":"title: UVa 11137Ingenuous Cubrency -  /  DP\ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - DP\n  -  DP\npermalink: uva-11137\ndate: 2016-03-13 11:56:43\n---\n\n $ N $$ N \\leq 1000 $ $ N $ \n\n<!-- more -->\n\n### \n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### \n $ f(i, j) $  $ i $  $ j $  i  j $ i^3 $  $ x $  $ j + xi^3 \\leq 1000 $ $ f(i - 1, j) $  $ f(i, j + xi^3) $ $ f(21, n) $ \n\n 1000 \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11137","published":1,"updated":"2016-10-24T23:28:29.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhsv004t0jxlhor559m8"},{"title":"UVa 11021Tribles - ","date":"2016-05-31T12:05:00.000Z","_content":"\n $ k $  Tribles Trible  Trible  $ p_i $  $ i $  Tribles $ m $  Tribles \n\n<!-- more -->\n\n### \n[UVa 11021](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=481&page=show_problem&problem=1962)  \n[COGS 1487](http://cogs.top/cogs/problem/problem.php?pid=1487)\n\n### \n $ f(i) $  Trible  $ i $  $ x $  Trible  $ i $  $ f(i) ^ x $\n\n Trible  $ n $  Tribles  $ i - 1 $ \n\n $ f(0) = 1 $\n\n$$ f(i) = \\sum\\limits_{j = 0} ^ {n - 1} f(i - 1) ^ j \\times p(j) $$\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXK = 1000;\nconst int MAXM = 1000;\n\nint main() {\n\tint t, n, k, m;\n\tscanf(\"%d\", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\tscanf(\"%d %d %d\", &n, &k, &m);\n\t\tstatic double p[MAXN], f[MAXK + 1];\n\t\tfor (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n\t\tstd::fill(f, f + m + 1, 0);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i] += p[j] * pow(f[i - 1], j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case #%d: %.7lf\\n\", i, pow(f[m], k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11021.md","raw":"title: UVa 11021Tribles - \ncategories: OI\ntags: \n  - UVa\n  - COGS\n  - DP\n  - \n  - \npermalink: uva-11021\ndate: 2016-05-31 20:05:00\n---\n\n $ k $  Tribles Trible  Trible  $ p_i $  $ i $  Tribles $ m $  Tribles \n\n<!-- more -->\n\n### \n[UVa 11021](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=481&page=show_problem&problem=1962)  \n[COGS 1487](http://cogs.top/cogs/problem/problem.php?pid=1487)\n\n### \n $ f(i) $  Trible  $ i $  $ x $  Trible  $ i $  $ f(i) ^ x $\n\n Trible  $ n $  Tribles  $ i - 1 $ \n\n $ f(0) = 1 $\n\n$$ f(i) = \\sum\\limits_{j = 0} ^ {n - 1} f(i - 1) ^ j \\times p(j) $$\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXK = 1000;\nconst int MAXM = 1000;\n\nint main() {\n\tint t, n, k, m;\n\tscanf(\"%d\", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\tscanf(\"%d %d %d\", &n, &k, &m);\n\t\tstatic double p[MAXN], f[MAXK + 1];\n\t\tfor (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n\t\tstd::fill(f, f + m + 1, 0);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i] += p[j] * pow(f[i - 1], j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case #%d: %.7lf\\n\", i, pow(f[m], k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11021","published":1,"updated":"2016-10-24T23:28:54.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jht000510jxlofly25s2"},{"title":"UVa 10253Series-Parallel Networks -  + ","date":"2016-03-15T07:35:55.000Z","_content":"\n\n\n1. \n2.  $ G1 $  $ G2 $ \n3.  $ G1 $  $ G2 $  $ G1 $  $ G2 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### \n\n\n $ N $  $ f(n) $    $ n $ ****\n\n $ k $  $ i $ $ k $  $ f(i) $  $ k $  $ \\binom{f(i) + k - 1}{k} $\n\n $ f(n) * 2 $ $ n = 1 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","source":"_posts/uva-10253.md","raw":"title: UVa 10253Series-Parallel Networks -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: uva-10253\ndate: 2016-03-15 15:35:55\n---\n\n\n\n1. \n2.  $ G1 $  $ G2 $ \n3.  $ G1 $  $ G2 $  $ G1 $  $ G2 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### \n\n\n $ N $  $ f(n) $    $ n $ ****\n\n $ k $  $ i $ $ k $  $ f(i) $  $ k $  $ \\binom{f(i) + k - 1}{k} $\n\n $ f(n) * 2 $ $ n = 1 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","slug":"uva-10253","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jht400590jxlt6p97yn7"},{"title":"Tyvj 3317 -  DP","id":"18","updated":"2016-01-19T13:05:08.000Z","date":"2016-01-11T21:29:30.000Z","_content":"\nn2  n  10000\n\n$$\\cases{0< XL1 & C1 \\\\ L1< XL2 & C2 \\\\ L2< XL3 & C3}$$\n\nL1L2L3C1C2C3($1  L1 < L2 < L3  10^9$, $1  C1 < C2 < C3  10^9$) L3\n\n\n\n\n\n<!-- more -->\n\n### \n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### \n $a[i]$ `0`  `i`  $f[i]$  `s`  `i` \n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]L3\\} $$\n\n\n\n$$ f[s] = 0 $$\n\n### \n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```\n","source":"_posts/tyvj-3317.md","raw":"title: Tyvj 3317 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  -  DP\npermalink: tyvj-3317\nid: 18\nupdated: '2016-01-19 21:05:08'\ndate: 2016-01-12 05:29:30\n---\n\nn2  n  10000\n\n$$\\cases{0< XL1 & C1 \\\\ L1< XL2 & C2 \\\\ L2< XL3 & C3}$$\n\nL1L2L3C1C2C3($1  L1 < L2 < L3  10^9$, $1  C1 < C2 < C3  10^9$) L3\n\n\n\n\n\n<!-- more -->\n\n### \n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### \n $a[i]$ `0`  `i`  $f[i]$  `s`  `i` \n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]L3\\} $$\n\n\n\n$$ f[s] = 0 $$\n\n### \n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```\n","slug":"tyvj-3317","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhtc005l0jxla7u7kf08"},{"title":"TJOI2015 -  DP + ","date":"2016-10-07T23:39:00.000Z","_content":"\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4000](http://www.lydsy.com/JudgeOnline/problem.php?id=4000)  \n[COGS 1979](http://cogs.pro/cogs/problem/problem.php?pid=1979)\n\n### \n\n\n $ f(i, j) $  $ i $  $ i $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\nconst int MAXM = 6;\nconst int MAXSTATUS = 1 << 6;\n\nstruct Matrix {\n\tunsigned int a[MAXSTATUS][MAXSTATUS];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXSTATUS; i++) a[i][i] = true;\n\t}\n\n\tunsigned int &operator()(const int i, const int j) { return a[i][j]; }\n\tconst unsigned int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) for (int k = 0; k < MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j);\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\n#ifdef DBG\ninline void print(const int x, const int m) {\n\tfor (int i = 0; i < m; i++) putchar((x & (1 << i)) ? '1' : '0');\n\t// putchar('\\n');\n}\n#endif\n\nint m, w, pos;\n\ninline void apply(const bool *tpl, const int j, bool *target) {\n\tfor (int k = 0; k < w; k++) {\n\t\tif (j - pos + k >= 0 && j - pos + k < m && tpl[k]) target[j - pos + k] = true;\n\t}\n}\n\nint main() {\n\tfreopen(\"tjoi2015_board.in\", \"r\", stdin);\n\tfreopen(\"tjoi2015_board.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d %d %d %d\", &n, &m, &w, &pos);\n\n\tstatic bool attack[3][MAXM];\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < w; j++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tattack[i][j] = x;\n\t}\n\tattack[1][pos] = false;\n\n\tstatic bool valid[MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tstatic bool tmp[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmp[k] = false;\n\t\tvalid[i] = true;\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j)) apply(attack[1], j, tmp);\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j) && tmp[j]) {\n\t\t\tvalid[i] = false;\n\t\t\tbreak;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(valid[i] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar('\\n');\n#endif\n\t}\n\n\tstatic bool near[MAXSTATUS][MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) for (int j = 0; j < (1 << m); j++) {\n\t\tif (!valid[i] || !valid[j]) {\n\t\t\tnear[i][j] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnear[i][j] = true;\n\t\tstatic bool tmpA[MAXM], tmpB[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmpA[k] = tmpB[k] = false;\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(i & (1 << k))) continue;\n\t\t\tapply(attack[2], k, tmpB);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(j & (1 << k))) continue;\n\t\t\tapply(attack[0], k, tmpA);\n\t\t}\n\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (((i & (1 << k)) && tmpA[k]) || ((j & (1 << k)) && tmpB[k])) {\n\t\t\t\tnear[i][j] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(near[i][j] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar(' ');\n\t\tprint(j, m);\n\t\tputchar('\\n');\n\n\t\tif (valid[i] && valid[j]) printf(\"near[%d][%d] = %d\\n\", i, j, static_cast<int>(near[i][j]));\n#endif\n\t}\n\n#ifdef DBG\n\tstatic unsigned int f[MAXN + 1][MAXSTATUS];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tif (!valid[j]) continue;\n\t\t\tfor (int k = 0; k < (1 << m); k++) {\n\t\t\t\tif (!valid[k]) continue;\n\t\t\t\tif (near[k][j]) f[i][j] += f[i - 1][k];\n\t\t\t}\n\n\t\t\tprintf(\"f(%d, [\", i);\n\t\t\tprint(j, m);\n\t\t\tprintf(\"] = %u\\n\", f[i][j]);\n\t\t}\n\t}\n\n\tunsigned int ansCheck = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ansCheck += f[n][i];\n#endif\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tif (valid[i]) {\n\t\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\t\tif (valid[j]) {\n\t\t\t\t\tif (near[j][i]) {\n\t\t\t\t\t\tshift(j, i) = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\n#ifndef FORCE\n\tMatrix res = pow(shift, n) * init;\n#else\n\tMatrix res(true);\n\tfor (int i = 1; i <= n; i++) {\n\t\tres = res * shift;\n#ifdef DBG\n\t\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) printf(\"%d%c\", res(i, j), j == MAXSTATUS - 1 ? '\\n' : ' ');\n#endif\n\t}\n\tres = res * init;\n#endif\n\n\tunsigned int ans = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ans += res(i, 0);\n\tprintf(\"%u\\n\", ans);\n\n#ifdef DBG\n\tprintf(\"ansCheck = %u\\n\", ansCheck);\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2015-chessboard.md","raw":"title: TJOI2015 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  -  DP\n  - \npermalink: tjoi2015-chessboard\ndate: 2016-10-08 07:39:00\n---\n\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4000](http://www.lydsy.com/JudgeOnline/problem.php?id=4000)  \n[COGS 1979](http://cogs.pro/cogs/problem/problem.php?pid=1979)\n\n### \n\n\n $ f(i, j) $  $ i $  $ i $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\nconst int MAXM = 6;\nconst int MAXSTATUS = 1 << 6;\n\nstruct Matrix {\n\tunsigned int a[MAXSTATUS][MAXSTATUS];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXSTATUS; i++) a[i][i] = true;\n\t}\n\n\tunsigned int &operator()(const int i, const int j) { return a[i][j]; }\n\tconst unsigned int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) for (int k = 0; k < MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j);\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\n#ifdef DBG\ninline void print(const int x, const int m) {\n\tfor (int i = 0; i < m; i++) putchar((x & (1 << i)) ? '1' : '0');\n\t// putchar('\\n');\n}\n#endif\n\nint m, w, pos;\n\ninline void apply(const bool *tpl, const int j, bool *target) {\n\tfor (int k = 0; k < w; k++) {\n\t\tif (j - pos + k >= 0 && j - pos + k < m && tpl[k]) target[j - pos + k] = true;\n\t}\n}\n\nint main() {\n\tfreopen(\"tjoi2015_board.in\", \"r\", stdin);\n\tfreopen(\"tjoi2015_board.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d %d %d %d\", &n, &m, &w, &pos);\n\n\tstatic bool attack[3][MAXM];\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < w; j++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tattack[i][j] = x;\n\t}\n\tattack[1][pos] = false;\n\n\tstatic bool valid[MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tstatic bool tmp[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmp[k] = false;\n\t\tvalid[i] = true;\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j)) apply(attack[1], j, tmp);\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j) && tmp[j]) {\n\t\t\tvalid[i] = false;\n\t\t\tbreak;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(valid[i] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar('\\n');\n#endif\n\t}\n\n\tstatic bool near[MAXSTATUS][MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) for (int j = 0; j < (1 << m); j++) {\n\t\tif (!valid[i] || !valid[j]) {\n\t\t\tnear[i][j] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnear[i][j] = true;\n\t\tstatic bool tmpA[MAXM], tmpB[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmpA[k] = tmpB[k] = false;\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(i & (1 << k))) continue;\n\t\t\tapply(attack[2], k, tmpB);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(j & (1 << k))) continue;\n\t\t\tapply(attack[0], k, tmpA);\n\t\t}\n\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (((i & (1 << k)) && tmpA[k]) || ((j & (1 << k)) && tmpB[k])) {\n\t\t\t\tnear[i][j] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(near[i][j] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar(' ');\n\t\tprint(j, m);\n\t\tputchar('\\n');\n\n\t\tif (valid[i] && valid[j]) printf(\"near[%d][%d] = %d\\n\", i, j, static_cast<int>(near[i][j]));\n#endif\n\t}\n\n#ifdef DBG\n\tstatic unsigned int f[MAXN + 1][MAXSTATUS];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tif (!valid[j]) continue;\n\t\t\tfor (int k = 0; k < (1 << m); k++) {\n\t\t\t\tif (!valid[k]) continue;\n\t\t\t\tif (near[k][j]) f[i][j] += f[i - 1][k];\n\t\t\t}\n\n\t\t\tprintf(\"f(%d, [\", i);\n\t\t\tprint(j, m);\n\t\t\tprintf(\"] = %u\\n\", f[i][j]);\n\t\t}\n\t}\n\n\tunsigned int ansCheck = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ansCheck += f[n][i];\n#endif\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tif (valid[i]) {\n\t\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\t\tif (valid[j]) {\n\t\t\t\t\tif (near[j][i]) {\n\t\t\t\t\t\tshift(j, i) = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\n#ifndef FORCE\n\tMatrix res = pow(shift, n) * init;\n#else\n\tMatrix res(true);\n\tfor (int i = 1; i <= n; i++) {\n\t\tres = res * shift;\n#ifdef DBG\n\t\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) printf(\"%d%c\", res(i, j), j == MAXSTATUS - 1 ? '\\n' : ' ');\n#endif\n\t}\n\tres = res * init;\n#endif\n\n\tunsigned int ans = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ans += res(i, 0);\n\tprintf(\"%u\\n\", ans);\n\n#ifdef DBG\n\tprintf(\"ansCheck = %u\\n\", ansCheck);\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"tjoi2015-chessboard","published":1,"updated":"2016-10-24T23:29:16.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhtg005u0jxl71xjxb76"},{"title":"TJOI2013 - AC ","date":"2016-09-11T23:07:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 3172](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n### \nAC  AC  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1e6 + 200;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst char BASE_CHAR = '`';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n#ifdef DBG\n\t\tchar ch;\n#endif\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n#ifdef DBG\n\t\tv = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = &(*v)->c[*p];\n\t\t\t(*v)->ch = *p + 'a';\n\t\t}\n#endif\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\tchar *p = s;\n\n\tstatic Trie::Node *node[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n\t\t*p++ = 0;\n\t\tnode[i] = t.insert(s, s + len);\n\t}\n\n\t*--p = 0;\n\t// for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR);\n\n\tt.build();\n\tt.exec(s, p);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", node[i]->ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-word.md","raw":"title: TJOI2013 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - \n  - AC \npermalink: tjoi2013-word\ndate: 2016-09-12 07:07:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3172](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n### \nAC  AC  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1e6 + 200;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst char BASE_CHAR = '`';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n#ifdef DBG\n\t\tchar ch;\n#endif\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n#ifdef DBG\n\t\tv = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = &(*v)->c[*p];\n\t\t\t(*v)->ch = *p + 'a';\n\t\t}\n#endif\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\tchar *p = s;\n\n\tstatic Trie::Node *node[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n\t\t*p++ = 0;\n\t\tnode[i] = t.insert(s, s + len);\n\t}\n\n\t*--p = 0;\n\t// for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR);\n\n\tt.build();\n\tt.exec(s, p);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", node[i]->ans);\n\n\treturn 0;\n}\n```\n","slug":"tjoi2013-word","published":1,"updated":"2016-10-07T23:45:42.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhtj00620jxluowegsux"},{"title":"TJOI2013 -  + ","date":"2016-04-03T14:49:33.000Z","_content":"\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-lis.md","raw":"title: TJOI2013 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - \n  - Splay\n  - \npermalink: tjoi2013-lis\ndate: 2016-04-03 22:49:33\n---\n\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tjoi2013-lis","published":1,"updated":"2016-10-07T23:45:34.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhtq006a0jxlhucuqzzr"},{"title":"Tarjan ","date":"2016-03-03T13:12:23.000Z","_content":"\n********************\n\nTarjan  $ O(n + m) $ \n\n<!-- more -->\n\n### \nTarjan  DFS\n\n\n\n$ {\\rm dfn}(u) $  $ u $ \n\n$ {\\rm low}(u) $  $ u $  $ u $  $ {\\rm dfn} $  $ {\\rm dfn} $\n\n### \n1.  DFS\n2.  $ {\\rm dfn} $  $ {\\rm low} $ \n3.  $ v $ \n4.  $ u $  $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $\n5.  $ u $  $ u $  DFS $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $\n6.  $ {\\rm low}(v) = {\\rm dfn}(v) $ $ v $ \n\n### \n $ v $  $ u $ \n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n $ v $  $ u $  $ v $ \n\n $ u $  $ u $  DFS\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n $ u $  $ v $  $ {\\rm low}(u) $  $ v $  $ u $  $ v $ \n\n\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n\n\n$ {\\rm low} $ **** $ {\\rm low} $ \n\n### \n DFS `s` Tarjan  `t`\n\n\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","source":"_posts/tarjan-scc-notes.md","raw":"title: Tarjan \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Tarjan\n  - \npermalink: tarjan-scc-notes\ndate: 2016-03-03 21:12:23\n---\n\n********************\n\nTarjan  $ O(n + m) $ \n\n<!-- more -->\n\n### \nTarjan  DFS\n\n\n\n$ {\\rm dfn}(u) $  $ u $ \n\n$ {\\rm low}(u) $  $ u $  $ u $  $ {\\rm dfn} $  $ {\\rm dfn} $\n\n### \n1.  DFS\n2.  $ {\\rm dfn} $  $ {\\rm low} $ \n3.  $ v $ \n4.  $ u $  $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $\n5.  $ u $  $ u $  DFS $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $\n6.  $ {\\rm low}(v) = {\\rm dfn}(v) $ $ v $ \n\n### \n $ v $  $ u $ \n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n $ v $  $ u $  $ v $ \n\n $ u $  $ u $  DFS\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n $ u $  $ v $  $ {\\rm low}(u) $  $ v $  $ u $  $ v $ \n\n\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n\n\n$ {\\rm low} $ **** $ {\\rm low} $ \n\n### \n DFS `s` Tarjan  `t`\n\n\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","slug":"tarjan-scc-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhtv006k0jxln9wevpt5"},{"title":"Tarjan ","date":"2016-09-08T11:45:00.000Z","_content":"\n $ v $  $ v $ ****\n\n<!-- more -->\n\n### \n$ \\mathrm{dfn}(u) $  $ u $ \n\n$ \\mathrm{low}(u) $  $ u $  $ u $  $ \\mathrm{dfn} $  $ \\mathrm{dfn} $\n\n### \n Tarjan \n\n1.  DFS\n2.  $ \\mathrm{dfn} $  $ \\mathrm{low} $ \n3.  $ v $ \n4.  $ u $  $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{dfn}(u)) $\n5.  $ u $  $ u $  DFS $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{low(u)}) $\n6.  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n7. \n\n### \n> \n\n\n\n>  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n\n$ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ v $  $ u $ \n\n### \n```c++\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n```","source":"_posts/tarjan-cut-notes.md","raw":"title: Tarjan \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Tarjan\n  - \npermalink: tarjan-cut-notes\ndate: 2016-09-08 19:45:00\n---\n\n $ v $  $ v $ ****\n\n<!-- more -->\n\n### \n$ \\mathrm{dfn}(u) $  $ u $ \n\n$ \\mathrm{low}(u) $  $ u $  $ u $  $ \\mathrm{dfn} $  $ \\mathrm{dfn} $\n\n### \n Tarjan \n\n1.  DFS\n2.  $ \\mathrm{dfn} $  $ \\mathrm{low} $ \n3.  $ v $ \n4.  $ u $  $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{dfn}(u)) $\n5.  $ u $  $ u $  DFS $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{low(u)}) $\n6.  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n7. \n\n### \n> \n\n\n\n>  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n\n$ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ v $  $ u $ \n\n### \n```c++\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n```","slug":"tarjan-cut-notes","published":1,"updated":"2016-09-08T12:17:14.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhu1006v0jxluod96ozu"},{"title":"","date":"2016-01-01T16:18:34.000Z","_content":"\n $x_i-x_j>=d$ \n\n<!-- more -->\n\n### \n\n\n `from``to` `$` \n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n\n\n```php\n$to - $from >= w\n```\n\n********\n\n****\n\n### \n $x_i-x_j>=d$ `j`  `i`  `d`\n\n $x_i-x_j>=d$ `-1` $x_j-x_i<=-d$ `i`  `j`  `-d`\n\n `dist`  `0` `dist`  `dist` \n\n Bellman-Ford  Bellman-Ford  `n - 1` ****\n\n Bellman-Ford  `n` ****\n\n### \n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF \n\n `n`  $x_i-x_j<=d$  $x_i-x_j>=d$  $x_1$  $x_n$  `-1` $x_1$  $x_n$  `-2`\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/system-of-difference-constraints-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: system-of-difference-constraints-notes\ndate: 2016-01-02 00:18:34\n---\n\n $x_i-x_j>=d$ \n\n<!-- more -->\n\n### \n\n\n `from``to` `$` \n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n\n\n```php\n$to - $from >= w\n```\n\n********\n\n****\n\n### \n $x_i-x_j>=d$ `j`  `i`  `d`\n\n $x_i-x_j>=d$ `-1` $x_j-x_i<=-d$ `i`  `j`  `-d`\n\n `dist`  `0` `dist`  `dist` \n\n Bellman-Ford  Bellman-Ford  `n - 1` ****\n\n Bellman-Ford  `n` ****\n\n### \n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF \n\n `n`  $x_i-x_j<=d$  $x_i-x_j>=d$  $x_1$  $x_n$  `-1` $x_1$  $x_n$  `-2`\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"system-of-difference-constraints-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhu700730jxlieacqas9"},{"title":"","date":"2016-04-12T11:29:14.000Z","_content":"\n OI   \n\n<!-- more -->\n\n### \n $ s $  $ 0 $  $ {\\rm length}(s) $\n\n$ {\\rm suffix}(i) $  $ s $  $ i $  $ s[i] $ ~ $ s[n - 1] $ \n\n  \n ASCII  ASCII   \n  \n\n\n****\n\n$ {\\rm SA}[] $  $ s $ $ {\\rm SA}[i] $  $ i $ \n\n$ {\\rm rank}[] $  $ {\\rm SA}[] $ $ {\\rm rank}[i] $  $ {\\rm suffix}(i) $  $ {\\rm rank}[{\\rm SA}[i]] = i $ $ i $  $ i $\n\n$ {\\rm height}[] $ Longest Common PrefixLCP\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n $ {\\rm height}[i] $  $ x $ $ k \\in [0, x) $  $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $\n\n### \n#### \n $ O(n ^ 2 \\log n) $\n\n**** $ O(n) $  $ O(n) $ \n\n#####  Hash \n Hash BKDRHash  $ O(n) $  $ O(1) $  Hash \n\n LCP  $ O(n \\log n \\log n) $\n\n Hash  `std::set` Hash \n\n#### \n**** $ i $  $ 2 ^ k $ \n\n `\"heheda\"` $ 2 ^ 0 = 1 $ \n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n $ 2 ^ 1 = 2 $  $ i $  $ 2 ^ 0 = 1 $  $ i $ **** $ i + 2 ^ 0 = i + 1 $  $ 2 ^ 0 = 1 $  $ i $ ****\n\n $ i + 2 ^ 0 \\geq n $  $ -1 $\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n $ 2 ^ 2 = 4 $ \n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n $ {\\rm rank}[] $  $ O(\\log n) $  $ {\\rm rank}[] $ \n\n $ O(n \\log n \\log n) $ Hash  $ [-1, n) $  $ O(n) $  $ O(n \\log n) $\n\n##### \n\n $ [0, n) $ \n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir`  `sec` `buc`  $ [-1, n) $\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n $ O(\\log n) $ \n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n$ {\\rm tmp}[i] $  $ i $ ****\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n $ {\\rm tmp}[] $  $ {\\rm tmp}[] $ \n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n $ {\\rm SA}[] $  $ {\\rm rank}[] $\n\n1.  $ 0 $\n2. \n3.  $ + 1 $\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n DC3\n\n### \n $ {\\rm height}[] $  $ {\\rm height}[] $ $ O(n ^ 2) $\n\n#### \n $ h(i) $  $ i $  $ {\\rm rank}[i] > 0 $ \n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n $ h(i) $\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n $ h(i - 1) < 1 $  $ h(i - 1) \\geq 1 $ \n\n $ u = {\\rm suffix}(i) $$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $ $ i $   \n $ u' = {\\rm suffix}(i - 1) $$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $ $ i - 1 $ \n\n $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $\n\n `\"heheheda\"` \n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n $ h(i - 1) \\geq 1 $ $ u' $  $ v' $  $ {\\rm LCP}(u', v') - 1 $ $ u $  $ v $\t $ u $  $ v $ $ {\\rm LCP}(u, v) $ \n\n#### \n $ {\\rm height}[{\\rm SA}[i]] $   \n $ k = {\\rm height}[{\\rm rank}[i - 1]] $ $ h(i - 1) $ $ {\\rm height}[{\\rm rank}[i]] $ $ k $  $ 1 $ $ n $ $ O(n) $  \n $ O(n \\log n) $ \n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n$ {\\rm height}[0] $ \n\n### \n $ {\\rm height}[] $\n\n************\n\n $ {\\rm height} $ \n\nRange Minimum/Maximum QueryRMQSparse TableST $ O(n \\log n) $  $ O(1) $ \n\n#### \n $ {\\rm st}[i][t] $  $ [i, i + 2 ^ t] $  $ {\\rm LCP}(i, i + 2 ^ t) $\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### \n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","source":"_posts/suffix-array-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: suffix-array-notes\ndate: 2016-04-12 19:29:14\n---\n\n OI   \n\n<!-- more -->\n\n### \n $ s $  $ 0 $  $ {\\rm length}(s) $\n\n$ {\\rm suffix}(i) $  $ s $  $ i $  $ s[i] $ ~ $ s[n - 1] $ \n\n  \n ASCII  ASCII   \n  \n\n\n****\n\n$ {\\rm SA}[] $  $ s $ $ {\\rm SA}[i] $  $ i $ \n\n$ {\\rm rank}[] $  $ {\\rm SA}[] $ $ {\\rm rank}[i] $  $ {\\rm suffix}(i) $  $ {\\rm rank}[{\\rm SA}[i]] = i $ $ i $  $ i $\n\n$ {\\rm height}[] $ Longest Common PrefixLCP\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n $ {\\rm height}[i] $  $ x $ $ k \\in [0, x) $  $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $\n\n### \n#### \n $ O(n ^ 2 \\log n) $\n\n**** $ O(n) $  $ O(n) $ \n\n#####  Hash \n Hash BKDRHash  $ O(n) $  $ O(1) $  Hash \n\n LCP  $ O(n \\log n \\log n) $\n\n Hash  `std::set` Hash \n\n#### \n**** $ i $  $ 2 ^ k $ \n\n `\"heheda\"` $ 2 ^ 0 = 1 $ \n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n $ 2 ^ 1 = 2 $  $ i $  $ 2 ^ 0 = 1 $  $ i $ **** $ i + 2 ^ 0 = i + 1 $  $ 2 ^ 0 = 1 $  $ i $ ****\n\n $ i + 2 ^ 0 \\geq n $  $ -1 $\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n $ 2 ^ 2 = 4 $ \n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n $ {\\rm rank}[] $  $ O(\\log n) $  $ {\\rm rank}[] $ \n\n $ O(n \\log n \\log n) $ Hash  $ [-1, n) $  $ O(n) $  $ O(n \\log n) $\n\n##### \n\n $ [0, n) $ \n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir`  `sec` `buc`  $ [-1, n) $\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n $ O(\\log n) $ \n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n$ {\\rm tmp}[i] $  $ i $ ****\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n $ {\\rm tmp}[] $  $ {\\rm tmp}[] $ \n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n $ {\\rm SA}[] $  $ {\\rm rank}[] $\n\n1.  $ 0 $\n2. \n3.  $ + 1 $\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n DC3\n\n### \n $ {\\rm height}[] $  $ {\\rm height}[] $ $ O(n ^ 2) $\n\n#### \n $ h(i) $  $ i $  $ {\\rm rank}[i] > 0 $ \n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n $ h(i) $\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n $ h(i - 1) < 1 $  $ h(i - 1) \\geq 1 $ \n\n $ u = {\\rm suffix}(i) $$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $ $ i $   \n $ u' = {\\rm suffix}(i - 1) $$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $ $ i - 1 $ \n\n $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $\n\n `\"heheheda\"` \n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n $ h(i - 1) \\geq 1 $ $ u' $  $ v' $  $ {\\rm LCP}(u', v') - 1 $ $ u $  $ v $\t $ u $  $ v $ $ {\\rm LCP}(u, v) $ \n\n#### \n $ {\\rm height}[{\\rm SA}[i]] $   \n $ k = {\\rm height}[{\\rm rank}[i - 1]] $ $ h(i - 1) $ $ {\\rm height}[{\\rm rank}[i]] $ $ k $  $ 1 $ $ n $ $ O(n) $  \n $ O(n \\log n) $ \n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n$ {\\rm height}[0] $ \n\n### \n $ {\\rm height}[] $\n\n************\n\n $ {\\rm height} $ \n\nRange Minimum/Maximum QueryRMQSparse TableST $ O(n \\log n) $  $ O(1) $ \n\n#### \n $ {\\rm st}[i][t] $  $ [i, i + 2 ^ t] $  $ {\\rm LCP}(i, i + 2 ^ t) $\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### \n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","slug":"suffix-array-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhua007b0jxl75qjkacf"},{"title":"STL  OI ","id":"8","updated":"2016-02-17T02:35:37.000Z","date":"2015-12-23T21:43:15.000Z","_content":"\n OI  C++CPascal C++   Standard Template Library STLSTL  STLNOI  2011  C++  STL STL C++ \n\n<!-- more -->\n\n### \n> STL containersiteratorsallocatoradaptersalgorithmsfunctors\n\n\n\n### \nnamespace C++  Menci  Fuxey  `work()`  `Menci::work()`  `Fuxey::work()`\n\nSTL  `std` \n\n STL  `sort` \n\n```cpp\nstd::sort(a, a + n);\n```\n\n `std::sort`  `sort(a, a + n)`   \n `using` \n\n```cpp\nusing std::sort;\n```\n\n `max`  STL  `max`   \n `using namespace` \n\n```cpp\nusing namespace std;\n```\n\n### \nSTL  `<algorithm>` \n\n##### \nSTL  `sort`  `stable_sort``sort`  $O(n {\\log} n)$`stable_sort`  $O(n {\\log} n)$\n\n`sort` `stable_sort`  `sort`\n\n `sort` `stable_sort` \n\n [l, r)  `sort(l, r)` l  r ********\n\n****STL  a  n  [a, a + n) a  0a + n  n ****\n\n`sort` \n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n nn <= 100000****\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n****************\n\n********\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n `operator<`   \n `compare` ********\n\n `const`  `&` \n\n##### \n\n `unique`  `sort`  `unique` \n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` \n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n nn <= 100000\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### \n\n `max`  `min` \n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); //  890\ny = std::min(a, b); //  -1\n```\n\n##### \n\nSTL `lower_bound``upper_bound``binary_search` `lower_bound` \n\n`lower_bound` ********\n\n`upper_bound` ********\n\n`binary_search`  `true`  `false`\n\n$O({\\log}n)$\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1  a  4  a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2  a  5  a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3  a  7  a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n a  8  *p4 \n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false  a  3\n```\n\n##### \n `swap` \n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### \n STL \n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n `p` `CONTAINER`  `vector``set` `T` \n\n `begin()` **** `end()` ******** `[begin(), end())`**** `end()``end()`  `end()` \n\n STL \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n**** `vector[i]`  `vector.begin() + i` `set` \n\n `++`  `--` \n\n `p` `*p`  `->` \n\n\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### \n\n#####  vector\nSTL  `<vector>` **** `vector`\n\n `vector` `int` 0\n\n```cpp\nstd::vector<int> v;\n```\n\n `vector` `int` n\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector`  `begin()`  `end()`********\n\n v \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n `size()`  `vector`  `resize()`  `vector` \n\n `push_back()`  `pop_back()`  `vector` ****$O(1)$\n\n `insert()` $O(n)$\n\n `erase()` $O(n)$\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n//  1234523333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n `vector`  `vector`  $O(n)$ \n\n#####  set\nSTL  `<set>` **** `set`**** `set` ****\n\n `int` \n\n```cpp\nstd::set<int> s;\n```\n\n `insert()` $O({\\log}n)$\n\n `erase()` ********$O({\\log}n)$\n\n`set`  `lower_bound()`  `find()` \n\n `set` ****`set`  `set<T>::iterator` `T` \n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // \ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end() 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n//  -123333\n```\n\n STL \n\n#####  string\nSTL  `<string>`  `string` \n\n `cin`  `cout` \n\n `find()`  0 \n\n `c_str()`  `string`  `const char *`  C \n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos 23333\n\npos = s.find(\"ci\");\n// pos = 3 4 \n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n//  Menci\n```\n\n#####  queue\nSTL  `<queue>` FIFO `queue`\n\n `push()` \n\n `front()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n//  2333366666\n```\n\n#####  stack\nSTL  `<stack>` LIFO `stack`\n\n `push()` \n\n `top()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n//  6666623333\n```\n\n#####  priority_queue\nSTL  `<queue>`  `priority_queue`****\n\n `push()` $O({\\log}n)$\n\n `top()` ****$O(1)$\n\n `pop()` ****$O({\\log}n)$\n\n `empty()` \n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n//  6666623333-1\n```\n\n`priority_queue` **** `priority_queue` ****\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n `T`  `int``std::greater<T>`  `>>` \n","source":"_posts/stl-in-oi.md","raw":"title: STL  OI \ncategories: OI\ntags: \n  - C++\n  - STL\npermalink: stl-in-oi\nid: 8\nupdated: '2016-02-17 10:35:37'\ndate: 2015-12-24 05:43:15\n---\n\n OI  C++CPascal C++   Standard Template Library STLSTL  STLNOI  2011  C++  STL STL C++ \n\n<!-- more -->\n\n### \n> STL containersiteratorsallocatoradaptersalgorithmsfunctors\n\n\n\n### \nnamespace C++  Menci  Fuxey  `work()`  `Menci::work()`  `Fuxey::work()`\n\nSTL  `std` \n\n STL  `sort` \n\n```cpp\nstd::sort(a, a + n);\n```\n\n `std::sort`  `sort(a, a + n)`   \n `using` \n\n```cpp\nusing std::sort;\n```\n\n `max`  STL  `max`   \n `using namespace` \n\n```cpp\nusing namespace std;\n```\n\n### \nSTL  `<algorithm>` \n\n##### \nSTL  `sort`  `stable_sort``sort`  $O(n {\\log} n)$`stable_sort`  $O(n {\\log} n)$\n\n`sort` `stable_sort`  `sort`\n\n `sort` `stable_sort` \n\n [l, r)  `sort(l, r)` l  r ********\n\n****STL  a  n  [a, a + n) a  0a + n  n ****\n\n`sort` \n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n nn <= 100000****\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n****************\n\n********\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n `operator<`   \n `compare` ********\n\n `const`  `&` \n\n##### \n\n `unique`  `sort`  `unique` \n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` \n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n nn <= 100000\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### \n\n `max`  `min` \n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); //  890\ny = std::min(a, b); //  -1\n```\n\n##### \n\nSTL `lower_bound``upper_bound``binary_search` `lower_bound` \n\n`lower_bound` ********\n\n`upper_bound` ********\n\n`binary_search`  `true`  `false`\n\n$O({\\log}n)$\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1  a  4  a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2  a  5  a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3  a  7  a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n a  8  *p4 \n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false  a  3\n```\n\n##### \n `swap` \n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### \n STL \n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n `p` `CONTAINER`  `vector``set` `T` \n\n `begin()` **** `end()` ******** `[begin(), end())`**** `end()``end()`  `end()` \n\n STL \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n**** `vector[i]`  `vector.begin() + i` `set` \n\n `++`  `--` \n\n `p` `*p`  `->` \n\n\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### \n\n#####  vector\nSTL  `<vector>` **** `vector`\n\n `vector` `int` 0\n\n```cpp\nstd::vector<int> v;\n```\n\n `vector` `int` n\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector`  `begin()`  `end()`********\n\n v \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n `size()`  `vector`  `resize()`  `vector` \n\n `push_back()`  `pop_back()`  `vector` ****$O(1)$\n\n `insert()` $O(n)$\n\n `erase()` $O(n)$\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n//  1234523333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n `vector`  `vector`  $O(n)$ \n\n#####  set\nSTL  `<set>` **** `set`**** `set` ****\n\n `int` \n\n```cpp\nstd::set<int> s;\n```\n\n `insert()` $O({\\log}n)$\n\n `erase()` ********$O({\\log}n)$\n\n`set`  `lower_bound()`  `find()` \n\n `set` ****`set`  `set<T>::iterator` `T` \n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // \ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end() 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n//  -123333\n```\n\n STL \n\n#####  string\nSTL  `<string>`  `string` \n\n `cin`  `cout` \n\n `find()`  0 \n\n `c_str()`  `string`  `const char *`  C \n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos 23333\n\npos = s.find(\"ci\");\n// pos = 3 4 \n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n//  Menci\n```\n\n#####  queue\nSTL  `<queue>` FIFO `queue`\n\n `push()` \n\n `front()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n//  2333366666\n```\n\n#####  stack\nSTL  `<stack>` LIFO `stack`\n\n `push()` \n\n `top()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n//  6666623333\n```\n\n#####  priority_queue\nSTL  `<queue>`  `priority_queue`****\n\n `push()` $O({\\log}n)$\n\n `top()` ****$O(1)$\n\n `pop()` ****$O({\\log}n)$\n\n `empty()` \n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n//  6666623333-1\n```\n\n`priority_queue` **** `priority_queue` ****\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n `T`  `int``std::greater<T>`  `>>` \n","slug":"stl-in-oi","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhud007k0jxljvfl81sy"},{"title":"SPOJ 694Distinct Substrings - ","date":"2016-04-12T13:40:06.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### \n $ i $  $ i - 1 $  $ {\\rm height}[i] $ \n\n 1 \n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/spoj-694.md","raw":"title: SPOJ 694Distinct Substrings - \ncategories: OI\ntags: \n  - SPOJ\n  - \n  - \npermalink: spoj-694\ndate: 2016-04-12 21:40:06\n---\n\n\n\n<!-- more -->\n\n### \n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### \n $ i $  $ i - 1 $  $ {\\rm height}[i] $ \n\n 1 \n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"spoj-694","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhug007q0jxle6nwr5o1"},{"title":"Splay ","date":"2016-01-19T12:02:00.000Z","_content":"\nSplay  Splay  Splay \n\n<!-- more -->\n\n### \n0 1 \n\n `count` \n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay \n `NULL` \n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n###  / \n `Splay` \n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### \n `k` **`k`  `[rank + 1, rank + count]`**\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-3.md","raw":"title: Splay \ncategories: OI\ntags: \n  - Splay\n  - \n  - \n  - \n  - \npermalink: splay-notes-3\ndate: 2016-01-19 20:02:00\n---\n\nSplay  Splay  Splay \n\n<!-- more -->\n\n### \n0 1 \n\n `count` \n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay \n `NULL` \n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n###  / \n `Splay` \n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### \n `k` **`k`  `[rank + 1, rank + count]`**\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-3","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhuk007w0jxl1g4zch8w"},{"title":"Splay ","id":"7","updated":"2016-01-19T13:07:35.000Z","date":"2015-12-22T21:44:41.000Z","_content":"\n Splay  Splay  /  Splay \n\n<!-- more -->\n\n### \nSplay  Splay  Splay **** Splay\n\n Splay **** `lazy-tag` \n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n `reversed`  Splay`bound`  Splay  `MIN`  `MAX` \n\n### de\n Splay `build()`********\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n****\n\n****Splay ****** Splay ** Splay \n\n### de\n `lazy-tag`  Splay \n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n`^= 1` \n\n### de\n `select()`  Splay  `k` \n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n****`while`  `node->lsize()`  `node` ****\n\n### de\n `select()` ****\n\n Splay \n\n1.  `Splay` ****\n2.  `Splay` ****\n3. \n\n********\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### de\n\n\n\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### de\n `fetch()` \n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n `pushdown()` \n\n### \n****\n\n `pushdown()`** `relation()`**\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay`  `pushdown()` `relation()`\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n `select()`  `dfs()`  `pushdown()`\n\n### Tyvj / BZOJ \n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n Splay  Splay ","source":"_posts/splay-notes-2.md","raw":"title: Splay \ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - \n  - \n  - \npermalink: splay-notes-2\nid: 7\nupdated: '2016-01-19 21:07:35'\ndate: 2015-12-23 05:44:41\n---\n\n Splay  Splay  /  Splay \n\n<!-- more -->\n\n### \nSplay  Splay  Splay **** Splay\n\n Splay **** `lazy-tag` \n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n `reversed`  Splay`bound`  Splay  `MIN`  `MAX` \n\n### de\n Splay `build()`********\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n****\n\n****Splay ****** Splay ** Splay \n\n### de\n `lazy-tag`  Splay \n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n`^= 1` \n\n### de\n `select()`  Splay  `k` \n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n****`while`  `node->lsize()`  `node` ****\n\n### de\n `select()` ****\n\n Splay \n\n1.  `Splay` ****\n2.  `Splay` ****\n3. \n\n********\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### de\n\n\n\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### de\n `fetch()` \n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n `pushdown()` \n\n### \n****\n\n `pushdown()`** `relation()`**\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay`  `pushdown()` `relation()`\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n `select()`  `dfs()`  `pushdown()`\n\n### Tyvj / BZOJ \n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n Splay  Splay ","slug":"splay-notes-2","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhuo00830jxlazg62izo"},{"title":"Splay ","id":"6","updated":"2016-01-19T13:07:47.000Z","date":"2015-12-19T21:36:24.000Z","_content":"\n Splay FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n\n<!-- more -->\n\n### Splay ?\nSplay Tree$O({\\log} n)$ Splay\n\n### \nSplay  Splay <  <  Splay \n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n `root` **** Splay `size`  Splay  `size`\n\n### \n `node_t` \n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n `node_t` \n\n `0` `1``relation()`  `child()`  `x` ****\n\n`maintain()`  Splay ****\n\n### \n Splay  `rotate()` ****\n\n1.  Splay \n2.  `size` \n3. `*root`  Splay \n\n\n\n1. ****\n2. ********\n3. ****\n4.  `*root`\n\n FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n![splay](splay-notes-1/splay.png)\n\n\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay \nSplay \n\n `Splay` `Splay` \n\n1. \n2. ********\n3. \n\n\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### \n\n\n `target` `target`  `target`  `target`  `NULL`\n\n `Splay` \n\n\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n**** Splay ****\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### \n `NULL`\n\n********\n\n `Splay` \n\n\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### \n****\n\n Splay  `Splay`  `size + 1`  `1` \n\n `1`  `0`\n\n\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### \n**** `k` \n\nSplay \n\n1. \n2. ** Splay ** `k - 1`\n3.  `k`  `k` ********\n\n `Splay` \n\n\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n###  / \n********\n\n Splay \n\n1.  `Splay` \n2. ****************\n3.  1\n\n `Splay` \n\n\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n###  / \n `x`  `x`  `x`  `x` \n\n\n\n1. \n2.  1 \n\n\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n###  / \nSplay \n\nSplay \n\n1.  `Splay` \n2.  `Splay` ****\n3. ****\n4.  `size`\n\n\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### Tyvj / BZOJ / CodeVS \n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-1.md","raw":"title: Splay \ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - \n  - \n  - \npermalink: splay-notes-1\nid: 6\nupdated: '2016-01-19 21:07:47'\ndate: 2015-12-20 05:36:24\n---\n\n Splay FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n\n<!-- more -->\n\n### Splay ?\nSplay Tree$O({\\log} n)$ Splay\n\n### \nSplay  Splay <  <  Splay \n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n `root` **** Splay `size`  Splay  `size`\n\n### \n `node_t` \n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n `node_t` \n\n `0` `1``relation()`  `child()`  `x` ****\n\n`maintain()`  Splay ****\n\n### \n Splay  `rotate()` ****\n\n1.  Splay \n2.  `size` \n3. `*root`  Splay \n\n\n\n1. ****\n2. ********\n3. ****\n4.  `*root`\n\n FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n![splay](splay-notes-1/splay.png)\n\n\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay \nSplay \n\n `Splay` `Splay` \n\n1. \n2. ********\n3. \n\n\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### \n\n\n `target` `target`  `target`  `target`  `NULL`\n\n `Splay` \n\n\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n**** Splay ****\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### \n `NULL`\n\n********\n\n `Splay` \n\n\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### \n****\n\n Splay  `Splay`  `size + 1`  `1` \n\n `1`  `0`\n\n\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### \n**** `k` \n\nSplay \n\n1. \n2. ** Splay ** `k - 1`\n3.  `k`  `k` ********\n\n `Splay` \n\n\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n###  / \n********\n\n Splay \n\n1.  `Splay` \n2. ****************\n3.  1\n\n `Splay` \n\n\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n###  / \n `x`  `x`  `x`  `x` \n\n\n\n1. \n2.  1 \n\n\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n###  / \nSplay \n\nSplay \n\n1.  `Splay` \n2.  `Splay` ****\n3. ****\n4.  `size`\n\n\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### Tyvj / BZOJ / CodeVS \n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-1","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhuu008a0jxluy4x61qz"},{"title":"SHOI2008 - ","date":"2016-10-19T06:30:00.000Z","_content":"\n $ 2 $  $ C $  $ 2C $  $ 3C - 2 $ \n\n\n1. `Close r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n2. `Open r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n3. `Ask r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n\n<!-- more -->\n\n### \n[BZOJ 1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018)\n\n### \n $ (i, 0) $  $ (i, 1) $  $ i $ \n\n $ [l, r] $  $ (l, 0), (l, 1) $  $ (r, 0), (r, 1) $ \n\n $ i $  $ [l = i, r = i] $  $ (l, 0) $  $ (r, 1) $$ (l, 1) $  $ (r, 0) $ \n\n $ [l, m] $  $ [m + 1, r] $  $ m \\leftrightarrow m + 1 $ \n\n $ [l, r] $  $ l $  $ l' $  $ r $  $ r' $ $ [l', r'] $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nbool right[MAXN][2], middle[MAXN + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(const bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\nConnectivity merge(Connectivity a, Connectivity b, const int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tConnectivity conn;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {}\n\n\tvoid update(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tconn(0, 0) = conn(1, 1) = true;\n\t\t\tconn(0, 1) = conn(1, 0) = middle[mid];\n\t\t\treturn;\n\t\t} else if (!(l <= this->l && r >= this->r)) {\n\t\t\tlc->update(l, r);\n\t\t\trc->update(l, r);\n\t\t} else if (this->l == this->r - 1) lc->update(l, r), rc->update(l, r);\n\t\tconn = merge(lc->conn, rc->conn, mid);\n\t}\n\n\tConnectivity query(const int l, const int r) {\n\t\tif (l <= this->l && r >= this->r) return conn;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\ninline void update(int r1, int c1, int r2, int c2, const bool val) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = val;\n\t} else {\n\t\tmiddle[c1] = val;\n\t}\n\tsegment->update(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tConnectivity res = segment->query(mid, c1);\n\t\tif (res(0, r1) || res(1, r1)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lconn = segment->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segment->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rconn = segment->query(c2, rpos);\n\n\tConnectivity conn = segment->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lconn(i, r1) && rconn(r2, j) && conn(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegment = SegmentTree::build(1, n);\n\n\tchar cmd[5];\n\twhile (~scanf(\"%s\", cmd)) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse if (cmd[0] == 'O') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, true);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, false);\n\t\t} else if (cmd[0] == 'A') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tif (c1 > c2) std::swap(c1, c2), std::swap(r1, r2);\n\t\t\tputs(query(r1 - 1, c1, r2 - 1, c2) ? \"Y\" : \"N\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-traffic.md","raw":"title: SHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \npermalink: shoi2008-traffic\ndate: 2016-10-19 14:30:00\n---\n\n $ 2 $  $ C $  $ 2C $  $ 3C - 2 $ \n\n\n1. `Close r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n2. `Open r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n3. `Ask r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n\n<!-- more -->\n\n### \n[BZOJ 1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018)\n\n### \n $ (i, 0) $  $ (i, 1) $  $ i $ \n\n $ [l, r] $  $ (l, 0), (l, 1) $  $ (r, 0), (r, 1) $ \n\n $ i $  $ [l = i, r = i] $  $ (l, 0) $  $ (r, 1) $$ (l, 1) $  $ (r, 0) $ \n\n $ [l, m] $  $ [m + 1, r] $  $ m \\leftrightarrow m + 1 $ \n\n $ [l, r] $  $ l $  $ l' $  $ r $  $ r' $ $ [l', r'] $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nbool right[MAXN][2], middle[MAXN + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(const bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\nConnectivity merge(Connectivity a, Connectivity b, const int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tConnectivity conn;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {}\n\n\tvoid update(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tconn(0, 0) = conn(1, 1) = true;\n\t\t\tconn(0, 1) = conn(1, 0) = middle[mid];\n\t\t\treturn;\n\t\t} else if (!(l <= this->l && r >= this->r)) {\n\t\t\tlc->update(l, r);\n\t\t\trc->update(l, r);\n\t\t} else if (this->l == this->r - 1) lc->update(l, r), rc->update(l, r);\n\t\tconn = merge(lc->conn, rc->conn, mid);\n\t}\n\n\tConnectivity query(const int l, const int r) {\n\t\tif (l <= this->l && r >= this->r) return conn;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\ninline void update(int r1, int c1, int r2, int c2, const bool val) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = val;\n\t} else {\n\t\tmiddle[c1] = val;\n\t}\n\tsegment->update(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tConnectivity res = segment->query(mid, c1);\n\t\tif (res(0, r1) || res(1, r1)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lconn = segment->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segment->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rconn = segment->query(c2, rpos);\n\n\tConnectivity conn = segment->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lconn(i, r1) && rconn(r2, j) && conn(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegment = SegmentTree::build(1, n);\n\n\tchar cmd[5];\n\twhile (~scanf(\"%s\", cmd)) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse if (cmd[0] == 'O') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, true);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, false);\n\t\t} else if (cmd[0] == 'A') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tif (c1 > c2) std::swap(c1, c2), std::swap(r1, r2);\n\t\t\tputs(query(r1 - 1, c1, r2 - 1, c2) ? \"Y\" : \"N\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"shoi2008-traffic","published":1,"updated":"2016-10-19T06:30:27.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhv5008h0jxly9it3py0"},{"title":"SHOI2008 - ","date":"2016-10-19T07:53:00.000Z","_content":"\n $ n $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1022](http://www.lydsy.com/JudgeOnline/problem.php?id=1022)\n\n### \n\n\n****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint s = 0;\n\t\tbool flag = false;\n\t\twhile (n--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ts ^= x;\n\t\t\tif (x > 1) flag = true;\n\t\t}\n\n\t\tputs(((!flag && s == 0) || (flag && s != 0)) ? \"John\" : \"Brother\");\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-john.md","raw":"title: SHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - \npermalink: shoi2008-john\ndate: 2016-10-19 15:53:00\n---\n\n $ n $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1022](http://www.lydsy.com/JudgeOnline/problem.php?id=1022)\n\n### \n\n\n****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint s = 0;\n\t\tbool flag = false;\n\t\twhile (n--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ts ^= x;\n\t\t\tif (x > 1) flag = true;\n\t\t}\n\n\t\tputs(((!flag && s == 0) || (flag && s != 0)) ? \"John\" : \"Brother\");\n\t}\n\n\treturn 0;\n}\n```","slug":"shoi2008-john","published":1,"updated":"2016-10-19T07:53:47.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhva008n0jxlk725w5pb"},{"title":"SHOI2008 - DP","date":"2016-10-19T07:24:00.000Z","_content":"\nABACBABCCA  CB A \n\n1. \n2. \n\n  \n\n\n<!-- more -->\n\n### \n[BZOJ 1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019)\n\n### \n $ f(j, i) $  $ i $  $ j $  $ g(j, i) $ \n\n $ j - 1 $  $ f(j - 1, i) $  $ g(j - 1, i) $  $ a = g(j - 1, i) $ $ b = 3 - a - i $ $ j $  $ b $ \n\n $ a $  $ j - 1 $  $ g(j - 1, a) $  $ g(j - 1, a) = b $ $ b $  $ j $  $ b $  $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) $$ g(j, i) = b $\n\n $ g(j - 1, a) = i $  $ j - 1 $  $ i $  $ a $  $ j - 1 $  $ a $  $ g(j - 1, i) = a $ $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) $$ g(j, i) = a $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 30;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int g[MAXN + 1][3];\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tint a = s[0] - 'A', b = s[1] - 'A';\n\t\tif (g[1][a] == -1) g[1][a] = b;\n\t}\n\n\tstatic long long f[MAXN + 1][3];\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-hannoi.md","raw":"title: SHOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\npermalink: shoi2008-hannoi\ndate: 2016-10-19 15:24:00\n---\n\nABACBABCCA  CB A \n\n1. \n2. \n\n  \n\n\n<!-- more -->\n\n### \n[BZOJ 1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019)\n\n### \n $ f(j, i) $  $ i $  $ j $  $ g(j, i) $ \n\n $ j - 1 $  $ f(j - 1, i) $  $ g(j - 1, i) $  $ a = g(j - 1, i) $ $ b = 3 - a - i $ $ j $  $ b $ \n\n $ a $  $ j - 1 $  $ g(j - 1, a) $  $ g(j - 1, a) = b $ $ b $  $ j $  $ b $  $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) $$ g(j, i) = b $\n\n $ g(j - 1, a) = i $  $ j - 1 $  $ i $  $ a $  $ j - 1 $  $ a $  $ g(j - 1, i) = a $ $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) $$ g(j, i) = a $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 30;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int g[MAXN + 1][3];\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tint a = s[0] - 'A', b = s[1] - 'A';\n\t\tif (g[1][a] == -1) g[1][a] = b;\n\t}\n\n\tstatic long long f[MAXN + 1][3];\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\n\treturn 0;\n}\n```","slug":"shoi2008-hannoi","published":1,"updated":"2016-10-19T07:24:21.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhve008u0jxlin8rvina"},{"title":"SHOI2008 - DP","date":"2016-10-19T07:35:00.000Z","_content":"\nABC  $ 1, 5, 10, 20, 50, 100 $ \n\n<!-- more -->\n\n### \n[BZOJ 1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)\n\n### \n $ f(i, a, b) $  $ i $  A  $ a $ B  $ b $ \n\n****\n\n* $ a \\rightarrow b, c $\n* $ b \\rightarrow a, c $\n* $ c \\rightarrow a, b $\n* $ a, b \\rightarrow c $\n* $ a, c \\rightarrow b $\n* $ b, c \\rightarrow a $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tconst int min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c < 0) {\n\t\tconst int max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tint has[3][6 + 1];\n\tint sum = 0, sums[3] = { 0, 0, 0 };\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &has[i][6 - j]);\n\t\t\tsums[i] += has[i][6 - j] * VAL[6 - j];\n#ifdef DBG\n\t\t\tfor (int k = 0; k < has[i][6 - j]; k++) printf(\"%d\\n\", VAL[6 - j]);\n#endif\n\t\t}\n\t\tsum += sums[i];\n#ifdef DBG\n\t\tputchar('\\n');\n#endif\n\t}\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", sums[0], sums[1], sums[2]);\n#endif\n\n\tstatic int f[6 + 1][MAXN + 1][MAXN + 1];\n\tfor (int i = 0; i <= 6; i++) for (int j = 0; j <= MAXN; j++) for (int k = 0; k <= MAXN; k++) f[i][j][k] = INT_MAX;\n\n\tf[0][sums[0]][sums[1]] = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= sum; a++) {\n\t\t\tfor (int b = 0; b <= sum - a; b++) {\n\t\t\t\tconst int c = sum - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= has[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= has[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= has[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= has[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tif (_a < 0 || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tif (_a > sum || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef DBG\n\t\t\t\tif (f[i + 1][a][b] != INT_MAX) printf(\"f(%d, %d, %d) = %d\\n\", i + 1, a, b, f[i + 1][a][b]);\n#endif\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b;\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", resA, resB, resC);\n#endif\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-debt.md","raw":"title: SHOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\npermalink: shoi2008-debt\ndate: 2016-10-19 15:35:00\n---\n\nABC  $ 1, 5, 10, 20, 50, 100 $ \n\n<!-- more -->\n\n### \n[BZOJ 1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)\n\n### \n $ f(i, a, b) $  $ i $  A  $ a $ B  $ b $ \n\n****\n\n* $ a \\rightarrow b, c $\n* $ b \\rightarrow a, c $\n* $ c \\rightarrow a, b $\n* $ a, b \\rightarrow c $\n* $ a, c \\rightarrow b $\n* $ b, c \\rightarrow a $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tconst int min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c < 0) {\n\t\tconst int max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tint has[3][6 + 1];\n\tint sum = 0, sums[3] = { 0, 0, 0 };\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &has[i][6 - j]);\n\t\t\tsums[i] += has[i][6 - j] * VAL[6 - j];\n#ifdef DBG\n\t\t\tfor (int k = 0; k < has[i][6 - j]; k++) printf(\"%d\\n\", VAL[6 - j]);\n#endif\n\t\t}\n\t\tsum += sums[i];\n#ifdef DBG\n\t\tputchar('\\n');\n#endif\n\t}\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", sums[0], sums[1], sums[2]);\n#endif\n\n\tstatic int f[6 + 1][MAXN + 1][MAXN + 1];\n\tfor (int i = 0; i <= 6; i++) for (int j = 0; j <= MAXN; j++) for (int k = 0; k <= MAXN; k++) f[i][j][k] = INT_MAX;\n\n\tf[0][sums[0]][sums[1]] = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= sum; a++) {\n\t\t\tfor (int b = 0; b <= sum - a; b++) {\n\t\t\t\tconst int c = sum - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= has[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= has[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= has[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= has[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tif (_a < 0 || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tif (_a > sum || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef DBG\n\t\t\t\tif (f[i + 1][a][b] != INT_MAX) printf(\"f(%d, %d, %d) = %d\\n\", i + 1, a, b, f[i + 1][a][b]);\n#endif\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b;\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", resA, resB, resC);\n#endif\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","slug":"shoi2008-debt","published":1,"updated":"2016-10-19T07:35:55.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhvi008z0jxleh86b9be"},{"title":"SHOI2008 -  DP","date":"2016-10-26T00:02:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023)\n\n### \nDFS  $ f(i) $  **DFS  $ i $ ** $ i $ \n\n DP DP **** $ f(i) $  $ i $ \n\n DFS  $ \\mathrm{dfn}(i) $  $ \\mathrm{low}(i) $ $ i $  $ j $$ j $  $ i $  $ \\mathrm{low}(j) > \\mathrm{dfn}(i) $ $ j $  $ i $  $ f(j) $  $ f(i) $ $ j $  $ i $  $ \\mathrm{dfn}(j) > \\mathrm{dfn}(i) $ $ i $  $ j $ \n\n**** $ i $ $ f(i) $  $ i $  $ f(i) $  $ j $$ f(i) $  $ f(j) + \\mathrm{dist}(j) $ \n\n $ f(i) + f(j) + \\mathrm{dist}(i, j) $  $ s(i) $  $ i $ $ f'(i) $  $ i $  $ f $  $ f'(i) + f'(j) + s(i) - s(j) $  $ f'(j) - s(j) $  $ s(i) - s(j) $  $ f $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 50000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tint dfn, low, len;\n\tbool visited, pushed;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nint n;\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void updateCircle(Node *top, Node *u, int &ans) {\n#ifdef DBG\n\tprintf(\"updateCircle(%lu, %lu)\\n\", top - N + 1, u - N + 1);\n#endif\n\tstatic Node *v[MAXN * 2];\n\tint cnt = 0;\n\twhile (1) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->parent;\n\t}\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAXN * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\t// ans = max{ f[i] + f[j] + i - j }\n\t// maintain the max of f[j] - j\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n#ifdef DBG\n\t\tprintf(\"updateCircle: ans <- %d\\n\", v[*l]->len + v[i]->len + i - *l);\n#endif\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\t// printf(\"updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\\n\", top - N + 1, u - N + 1, v[i] - N + 1, v[i]->len, i, cnt - i);\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n#ifdef CHECK\n\tprintf(\"updateCircle(%lu, %lu) = %d\\n\", top - N + 1, u - N + 1, res);\n#endif\n\n\ttop->len = std::max(top->len, res);\n}\n\ninline int tarjan() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].pushed = true;\n\n\tint ts = 0, ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->dfn = v->low = ++ts;\n\t\t}\n\n\t\tif (v->c && v->c->t == v->parent) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\tif (e->t->dfn) {\n\t\t\t\tv->low = std::min(v->low, e->t->dfn);\n\t\t\t} else {\n\t\t\t\te->t->pushed = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t == v->parent) continue;\n\n\t\t\t\tif (e->t->low > v->dfn) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: ans <- (f[%lu] = %d) + (f[%lu] = %d) + 1\\n\", v - N + 1, v->len, e->t - N + 1, e->t->len);\n#endif\n\t\t\t\t\tans = std::max(ans, v->len + e->t->len + 1);\n\t\t\t\t\tv->len = std::max(v->len, e->t->len + 1);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e->t->parent != v && e->t->dfn > v->dfn) {\n\t\t\t\t\tupdateCircle(v, e->t, ans);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d (from circle)\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->parent) v->parent->low = std::min(v->parent->low, v->low);\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u), u--, k--;\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v), v--;\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", tarjan());\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-cactus.md","raw":"title: SHOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\n  - \n  - Tarjan\npermalink: shoi2008-cactus\ndate: 2016-10-26 08:02:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023)\n\n### \nDFS  $ f(i) $  **DFS  $ i $ ** $ i $ \n\n DP DP **** $ f(i) $  $ i $ \n\n DFS  $ \\mathrm{dfn}(i) $  $ \\mathrm{low}(i) $ $ i $  $ j $$ j $  $ i $  $ \\mathrm{low}(j) > \\mathrm{dfn}(i) $ $ j $  $ i $  $ f(j) $  $ f(i) $ $ j $  $ i $  $ \\mathrm{dfn}(j) > \\mathrm{dfn}(i) $ $ i $  $ j $ \n\n**** $ i $ $ f(i) $  $ i $  $ f(i) $  $ j $$ f(i) $  $ f(j) + \\mathrm{dist}(j) $ \n\n $ f(i) + f(j) + \\mathrm{dist}(i, j) $  $ s(i) $  $ i $ $ f'(i) $  $ i $  $ f $  $ f'(i) + f'(j) + s(i) - s(j) $  $ f'(j) - s(j) $  $ s(i) - s(j) $  $ f $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 50000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tint dfn, low, len;\n\tbool visited, pushed;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nint n;\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void updateCircle(Node *top, Node *u, int &ans) {\n#ifdef DBG\n\tprintf(\"updateCircle(%lu, %lu)\\n\", top - N + 1, u - N + 1);\n#endif\n\tstatic Node *v[MAXN * 2];\n\tint cnt = 0;\n\twhile (1) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->parent;\n\t}\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAXN * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\t// ans = max{ f[i] + f[j] + i - j }\n\t// maintain the max of f[j] - j\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n#ifdef DBG\n\t\tprintf(\"updateCircle: ans <- %d\\n\", v[*l]->len + v[i]->len + i - *l);\n#endif\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\t// printf(\"updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\\n\", top - N + 1, u - N + 1, v[i] - N + 1, v[i]->len, i, cnt - i);\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n#ifdef CHECK\n\tprintf(\"updateCircle(%lu, %lu) = %d\\n\", top - N + 1, u - N + 1, res);\n#endif\n\n\ttop->len = std::max(top->len, res);\n}\n\ninline int tarjan() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].pushed = true;\n\n\tint ts = 0, ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->dfn = v->low = ++ts;\n\t\t}\n\n\t\tif (v->c && v->c->t == v->parent) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\tif (e->t->dfn) {\n\t\t\t\tv->low = std::min(v->low, e->t->dfn);\n\t\t\t} else {\n\t\t\t\te->t->pushed = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t == v->parent) continue;\n\n\t\t\t\tif (e->t->low > v->dfn) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: ans <- (f[%lu] = %d) + (f[%lu] = %d) + 1\\n\", v - N + 1, v->len, e->t - N + 1, e->t->len);\n#endif\n\t\t\t\t\tans = std::max(ans, v->len + e->t->len + 1);\n\t\t\t\t\tv->len = std::max(v->len, e->t->len + 1);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e->t->parent != v && e->t->dfn > v->dfn) {\n\t\t\t\t\tupdateCircle(v, e->t, ans);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d (from circle)\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->parent) v->parent->low = std::min(v->parent->low, v->low);\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u), u--, k--;\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v), v--;\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", tarjan());\n\n\treturn 0;\n}\n```","slug":"shoi2008-cactus","published":1,"updated":"2016-10-26T00:02:45.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhvm00940jxli0hmhjcu"},{"title":"SHOI2007 - ","date":"2016-06-21T07:04:00.000Z","_content":"\n $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1934](http://www.lydsy.com/JudgeOnline/problem.php?id=1934)\n\n### \n $ 1 $\n\n $ S - u - v - T $$ u $ $ v $  $ u - v $  $ u $  $ v $  $ +1 $ $ S - u $  $ v - T $ $ u $  $ v $  $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->e; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\t// printf(\"[%d, %d, %d, %d]\\n\", s, t, c, rc);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) {\n\t\t\taddEdge(s, i, 1);\n\t\t} else {\n\t\t\taddEdge(i, t, 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v, 1, 1);\n\t}\n\n\tint maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/shoi2007-vote.md","raw":"title: SHOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - Dinic\n  - \npermalink: shoi2007-vote\ndate: 2016-06-21 15:04:00\n---\n\n $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1934](http://www.lydsy.com/JudgeOnline/problem.php?id=1934)\n\n### \n $ 1 $\n\n $ S - u - v - T $$ u $ $ v $  $ u - v $  $ u $  $ v $  $ +1 $ $ S - u $  $ v - T $ $ u $  $ v $  $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->e; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\t// printf(\"[%d, %d, %d, %d]\\n\", s, t, c, rc);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) {\n\t\t\taddEdge(s, i, 1);\n\t\t} else {\n\t\t\taddEdge(i, t, 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v, 1, 1);\n\t}\n\n\tint maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"shoi2007-vote","published":1,"updated":"2016-06-21T07:04:25.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhvr009c0jxl1nw5ofqt"},{"title":"SHOI2007 - CDQ","date":"2016-06-25T02:54:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1935](http://www.lydsy.com/JudgeOnline/problem.php?id=1935)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 10000000;\n\nstruct Triple {\n\tint x, y, *ans, k;\n\n\tTriple() {}\n\tTriple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {}\n} a[MAXN + MAXM * 4];\n\nint max = 0;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t// printf(\"sum[1, %d] = %d\\n\", x, ans);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\t// printf(\"a[%d] += %d\\n\", x, delta);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\t// printf(\"a[%d] = 0\\n\", x);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\nvoid cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM * 4];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\t// printf(\"ans += %d\\n\", bit.query(q->y) * q->k);\n\t\t\tif (q->ans) *q->ans += bit.query(q->y) * q->k;\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y), a[i].x += 2, a[i].y += 2;\n\t\tmax = std::max(max, a[i].y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint cnt = n;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2;\n\t\tint *p = &ans[i];\n\n\t\ta[cnt++] = Triple(x2, y2, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y2, p, -1);\n\t\ta[cnt++] = Triple(x2, y1 - 1, p, -1);\n\n\t\tmax = std::max(max, y1);\n\t\tmax = std::max(max, y2);\n\t}\n\n\t// for (int i = 0; i < cnt; i++) {\n\t// \tif (a[i].ans) printf(\"Query [%d, %d] for ans[%ld]\\n\", a[i].x, a[i].y, a[i].ans - ans);\n\t// \telse printf(\"Update [%d, %d] = 1\\n\", a[i].x, a[i].y);\n\t// }\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/shoi2007-tree.md","raw":"title: SHOI2007 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - CDQ\n  - \n  - \npermalink: shoi2007-tree\ndate: 2016-06-25 10:54:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1935](http://www.lydsy.com/JudgeOnline/problem.php?id=1935)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 10000000;\n\nstruct Triple {\n\tint x, y, *ans, k;\n\n\tTriple() {}\n\tTriple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {}\n} a[MAXN + MAXM * 4];\n\nint max = 0;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t// printf(\"sum[1, %d] = %d\\n\", x, ans);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\t// printf(\"a[%d] += %d\\n\", x, delta);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\t// printf(\"a[%d] = 0\\n\", x);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\nvoid cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM * 4];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\t// printf(\"ans += %d\\n\", bit.query(q->y) * q->k);\n\t\t\tif (q->ans) *q->ans += bit.query(q->y) * q->k;\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y), a[i].x += 2, a[i].y += 2;\n\t\tmax = std::max(max, a[i].y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint cnt = n;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2;\n\t\tint *p = &ans[i];\n\n\t\ta[cnt++] = Triple(x2, y2, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y2, p, -1);\n\t\ta[cnt++] = Triple(x2, y1 - 1, p, -1);\n\n\t\tmax = std::max(max, y1);\n\t\tmax = std::max(max, y2);\n\t}\n\n\t// for (int i = 0; i < cnt; i++) {\n\t// \tif (a[i].ans) printf(\"Query [%d, %d] for ans[%ld]\\n\", a[i].x, a[i].y, a[i].ans - ans);\n\t// \telse printf(\"Update [%d, %d] = 1\\n\", a[i].x, a[i].y);\n\t// }\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"shoi2007-tree","published":1,"updated":"2016-06-25T03:07:53.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhvt009j0jxl6h2c2f7x"},{"title":"SDOI2016 - ","date":"2016-04-18T09:06:53.000Z","_content":"\n $ n $  $ m $  $ 0 $  $ n - 1 $  $ 0 $  $ m - 1 $   \n $ i $  $ j $  $ (i \\ {\\rm xor} \\ j) $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n $ 1 $ $ 0 $   \n$ k $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n $ k $   \n $ p $ \n\n<!-- more -->\n\n### \n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### \n DP   \n\n\n\n $ x < 2 ^ N $$ y < 2 ^ N $ $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n>  $ N $  $ 0 $ $ 1 $\n\n $ x \\neq y $ $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n>  $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $ $ x \\ {\\rm xor} \\ a = z $$ y \\ {\\rm xor} \\ a = z $ $ x = y $\n\n $ x < 2 ^ N $$ [0, 2 ^ N - 1] $  $ x $  $ [0, 2 ^ N - 1] $ \n\n>  2  $ N $  $ 2 ^ N $ $ 2 ^ N - 1 $  $ [0, 2 ^ N - 1] $ \n\n $ n > m $$ n $ $ m $ \n\n $ k $ $ n = m = 2 ^ N $$ N = 3 $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ \n\n $ N = \\lfloor \\log_2 n \\rfloor $$ M = \\lfloor \\log_2 m \\rfloor $ $ N = M $ \n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n $ [2 ^ N, 2 ^ N + 2 ^ M - 1] $ \n\n $ n $  $ m $ \n\n $ N > M $ $ n > m $  $ N < M $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ $ 2 ^ N $ $ 2 ^ N $  $ N = M $  $ 2 ^ N $ \n\n $ k $  $ 0, 1, 2, 3,  n $  $ \\leq k $  $ 0 $ $ k $ $ 1 $  $ n - k $ \n\n $ k $  $ n $  $ k $ \n\n $ n $  $ 1 $ $ O(T \\log (\\max(n, m))) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-table.md","raw":"title: SDOI2016 - \ndate: 2016-04-18 17:06:53\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \npermalink: sdoi2016-table\n---\n\n $ n $  $ m $  $ 0 $  $ n - 1 $  $ 0 $  $ m - 1 $   \n $ i $  $ j $  $ (i \\ {\\rm xor} \\ j) $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n $ 1 $ $ 0 $   \n$ k $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n $ k $   \n $ p $ \n\n<!-- more -->\n\n### \n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### \n DP   \n\n\n\n $ x < 2 ^ N $$ y < 2 ^ N $ $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n>  $ N $  $ 0 $ $ 1 $\n\n $ x \\neq y $ $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n>  $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $ $ x \\ {\\rm xor} \\ a = z $$ y \\ {\\rm xor} \\ a = z $ $ x = y $\n\n $ x < 2 ^ N $$ [0, 2 ^ N - 1] $  $ x $  $ [0, 2 ^ N - 1] $ \n\n>  2  $ N $  $ 2 ^ N $ $ 2 ^ N - 1 $  $ [0, 2 ^ N - 1] $ \n\n $ n > m $$ n $ $ m $ \n\n $ k $ $ n = m = 2 ^ N $$ N = 3 $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ \n\n $ N = \\lfloor \\log_2 n \\rfloor $$ M = \\lfloor \\log_2 m \\rfloor $ $ N = M $ \n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n $ [2 ^ N, 2 ^ N + 2 ^ M - 1] $ \n\n $ n $  $ m $ \n\n $ N > M $ $ n > m $  $ N < M $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ $ 2 ^ N $ $ 2 ^ N $  $ N = M $  $ 2 ^ N $ \n\n $ k $  $ 0, 1, 2, 3,  n $  $ \\leq k $  $ 0 $ $ k $ $ 1 $  $ n - k $ \n\n $ k $  $ n $  $ k $ \n\n $ n $  $ 1 $ $ O(T \\log (\\max(n, m))) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-table","published":1,"updated":"2016-09-10T05:54:16.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhvx009t0jxlw5x1kt86"},{"title":"SDOI2016 Round1 ","date":"2016-04-09T13:59:32.000Z","_content":"\n \n\n<!-- more -->\n\n### Day 0\n     \n\n   \n\n  **** \n\n \n\n EK  \n\n \n\n QwQ \n\n yts1999 %%%\n\n Blog  \n\n### Day 1\n   \n XP  Windows    \n7:59  WC  \n\n \n\n   DP   \n30min    \n  20  \n\n    Miller  Rabin    \n +    \n  \npapapa  $ 1000 \\times 1000 $    $ O((n + m) ^ 3) $   \n     EK    \n   \n   \n  \n $ b_i $    \n   \n`Wrong Answer on Test #7`md     \n`Wrong Answer on Test #13`md     \n `Accepted`    \n\n  \n     SegmentTree Beats    \n BFS    \n $ a = 0 $    \n  \n      \n`Wrong Answer on Test #18`     \n`Wrong Answer on Test #32`       \nmd      \nmd  `size`    \n`s.top()`  `s.pop()`   \n 12:40    \n\n T2  maya      \nT2  $ O( $  $ ) $    $ n = 200 $    \n 1.5s   \n   \nT  T    \n\n140rank9 \n\nheheda AK   \nstd rank2\n\n\n\n     KMP   \n\nDay1   \n Day2 \n\n### Day 2\n  7:50 \n\nwow  \n\n7:57  \n\n \n\nmaya 60  60   \n 30 `std::set< std::vector<int> >`    \n\nmaya        \n     \n 10   $ O(n!) $  \n\n DP10 $ O(n ^ 3) $  DP  30    \n\n   `std::sort`    \n `height`   `height`    \n\n $ O(n ^ 2 \\log n + n ^ 2) $  \n\n \n\n1.5h  `height`  \n\n \n\n$ O(n ^ 2) $  `height`    \n `height` `height + 1` 0   \n `\"heheda\"`    \n   \n   \n\n\n\n     \n   \n `std::sort` \n\n $ O(n \\log n \\log n + n) $ \n\n    \n   \n `height`   \n   \n   \nmaya  \n\n   \n\n\n $ O(n \\log n \\log n + n ^ 2) $   \n `height`      \n\n  \n       \n\n 30  DP  12:40    \nmaya   \n  maya   \n   \n `double`    \n     \n\n12:50       \nmaya   \n\n13:00    \n\n \n\nDay1 T1 DP  \nT2      \nT3  Orz\n\nDay2 T1   \n   \nT2 maya 60    \nT3      \n\n  90    60  \n\n Day1  Flag \n\n \n","source":"_posts/sdoi2016-round1.md","raw":"title: SDOI2016 Round1 \ncategories: \n  - Diary\npermalink: sdoi2016-round1\ndate: 2016-04-09 21:59:32\n---\n\n \n\n<!-- more -->\n\n### Day 0\n     \n\n   \n\n  **** \n\n \n\n EK  \n\n \n\n QwQ \n\n yts1999 %%%\n\n Blog  \n\n### Day 1\n   \n XP  Windows    \n7:59  WC  \n\n \n\n   DP   \n30min    \n  20  \n\n    Miller  Rabin    \n +    \n  \npapapa  $ 1000 \\times 1000 $    $ O((n + m) ^ 3) $   \n     EK    \n   \n   \n  \n $ b_i $    \n   \n`Wrong Answer on Test #7`md     \n`Wrong Answer on Test #13`md     \n `Accepted`    \n\n  \n     SegmentTree Beats    \n BFS    \n $ a = 0 $    \n  \n      \n`Wrong Answer on Test #18`     \n`Wrong Answer on Test #32`       \nmd      \nmd  `size`    \n`s.top()`  `s.pop()`   \n 12:40    \n\n T2  maya      \nT2  $ O( $  $ ) $    $ n = 200 $    \n 1.5s   \n   \nT  T    \n\n140rank9 \n\nheheda AK   \nstd rank2\n\n\n\n     KMP   \n\nDay1   \n Day2 \n\n### Day 2\n  7:50 \n\nwow  \n\n7:57  \n\n \n\nmaya 60  60   \n 30 `std::set< std::vector<int> >`    \n\nmaya        \n     \n 10   $ O(n!) $  \n\n DP10 $ O(n ^ 3) $  DP  30    \n\n   `std::sort`    \n `height`   `height`    \n\n $ O(n ^ 2 \\log n + n ^ 2) $  \n\n \n\n1.5h  `height`  \n\n \n\n$ O(n ^ 2) $  `height`    \n `height` `height + 1` 0   \n `\"heheda\"`    \n   \n   \n\n\n\n     \n   \n `std::sort` \n\n $ O(n \\log n \\log n + n) $ \n\n    \n   \n `height`   \n   \n   \nmaya  \n\n   \n\n\n $ O(n \\log n \\log n + n ^ 2) $   \n `height`      \n\n  \n       \n\n 30  DP  12:40    \nmaya   \n  maya   \n   \n `double`    \n     \n\n12:50       \nmaya   \n\n13:00    \n\n \n\nDay1 T1 DP  \nT2      \nT3  Orz\n\nDay2 T1   \n   \nT2 maya 60    \nT3      \n\n  90    60  \n\n Day1  Flag \n\n \n","slug":"sdoi2016-round1","published":1,"updated":"2016-11-20T15:49:24.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhw200a50jxlsi0yt35o"},{"title":"SDOI2016 -  + ","date":"2016-04-13T03:45:13.000Z","_content":"\n $ n $  $ A $\n\n* $ 1 $ ~ $ n $  $ n $ \n*  $ i $  $ A[i] $  $ i $ $ i $  $ m $ \n\n $ 10 ^ 9 + 7 $ \n\n<!-- more -->\n\n### \n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### \n\n\n $ n $  $ m $  $ n - m $ \n\n $ f(i) $  i \n\n$$ C(n, m) * f(n - m) $$\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-permutation.md","raw":"title: SDOI2016 -  + \ndate: 2016-04-13 11:45:13\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \n  - \npermalink: sdoi2016-permutation\n---\n\n $ n $  $ A $\n\n* $ 1 $ ~ $ n $  $ n $ \n*  $ i $  $ A[i] $  $ i $ $ i $  $ m $ \n\n $ 10 ^ 9 + 7 $ \n\n<!-- more -->\n\n### \n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### \n\n\n $ n $  $ m $  $ n - m $ \n\n $ f(i) $  i \n\n$$ C(n, m) * f(n - m) $$\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-permutation","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhw400a80jxlkkx4eymd"},{"title":"SDOI2016 - ","date":"2016-04-09T10:06:43.000Z","_content":"\n $ n $  $ i $  $ a_i $ $ b_i $  $ c_i $\n\n $ a_i $$ a_j $ $ a_i $  $ a_j $  $ \\frac{a_i}{a_j} $  $ c_i \\times c_j $ \n\n  \n $ 0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### \n $ 10 ^ 6 $ \n\n $ X $  $ b_i $  $ 0 $ $ Y $  $ b_i $  $ 0 $ $ X $  $ Y $  $ -(c_i \\times c_j) $\n\n $ \\leq 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-pair.md","raw":"title: SDOI2016 - \ndate: 2016-04-09 18:06:43\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - Edmonds-Karp\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: sdoi2016-pair\n---\n\n $ n $  $ i $  $ a_i $ $ b_i $  $ c_i $\n\n $ a_i $$ a_j $ $ a_i $  $ a_j $  $ \\frac{a_i}{a_j} $  $ c_i \\times c_j $ \n\n  \n $ 0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### \n $ 10 ^ 6 $ \n\n $ X $  $ b_i $  $ 0 $ $ Y $  $ b_i $  $ 0 $ $ X $  $ Y $  $ -(c_i \\times c_j) $\n\n $ \\leq 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-pair","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhw800ai0jxld3azfk3q"},{"title":"SDOI2016 -  DP","date":"2016-04-17T14:46:04.000Z","_content":"\nPine  $ S $  $ T $   \n $ S $  $ T $  $ n $   \nPine  $ m $  $ T $  $ m $  Pine   \nPine   \n Pine \n\n $ v $$ v \\times m ^ 2 $  $ v \\times m ^ 2 $\n\n<!-- more -->\n\n### \n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### \n $ a_i $ $ S = \\sum\\limits_{i = 1} ^ n a_i $\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n $ m $ $ S ^ 2 $ \n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n\n\n $ f[j][i] $  $ i $  $ j $ \n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\nDP $ O(nm) $ $ O(nm ^ 2) $ 60 \n\n $ g(i) = f[j - 1][i] $ $ k $  $ k = a $  $ k = b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n\n\n1. \n2.  $ a $  $ b $ $ a > b $ $ 2 s_i $ $ a $ \n\n 2 \n\n $ i $ $ k $ 2 $ k $  1  $ O(1) $ $ O(nm) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-journey.md","raw":"title: SDOI2016 -  DP\ndate: 2016-04-17 22:46:04\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - DP\n  - \n  - \npermalink: sdoi2016-journey\n---\n\nPine  $ S $  $ T $   \n $ S $  $ T $  $ n $   \nPine  $ m $  $ T $  $ m $  Pine   \nPine   \n Pine \n\n $ v $$ v \\times m ^ 2 $  $ v \\times m ^ 2 $\n\n<!-- more -->\n\n### \n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### \n $ a_i $ $ S = \\sum\\limits_{i = 1} ^ n a_i $\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n $ m $ $ S ^ 2 $ \n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n\n\n $ f[j][i] $  $ i $  $ j $ \n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\nDP $ O(nm) $ $ O(nm ^ 2) $ 60 \n\n $ g(i) = f[j - 1][i] $ $ k $  $ k = a $  $ k = b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n\n\n1. \n2.  $ a $  $ b $ $ a > b $ $ 2 s_i $ $ a $ \n\n 2 \n\n $ i $ $ k $ 2 $ k $  1  $ O(1) $ $ O(nm) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-journey","published":1,"updated":"2016-10-24T23:29:40.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhwd00ax0jxlvvusrna8"},{"title":"SDOI2016 - ","date":"2016-04-12T13:57:57.000Z","_content":"\n $ 1 $$ 2 $  $ [1, 2] $  \n $ S $  $ S $   \n $ S = [1, 2, 1] $  $ [1] $$ [2] $$ [1, 2] $$ [2, 1] $$ [1, 2, 1] $ $ S = [1, 1, 1] $  $ [1] $$ [1, 1] $$ [1, 1, 1] $   \n $ S $  $ n $  $ S $  $ S $ \n\n<!-- more -->\n\n### \n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### \n $ {\\rm height} $ \n\n\n\n `std::set` \n\n $ i $ $ pred $$ succ $\n\n$ pred $$ succ $ $ pred $$ succ $  $ i $ \n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n $ i $ \n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-incantation.md","raw":"title: SDOI2016 - \ndate: 2016-04-12 21:57:57\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - RMQ\npermalink: sdoi2016-incantation\n---\n\n $ 1 $$ 2 $  $ [1, 2] $  \n $ S $  $ S $   \n $ S = [1, 2, 1] $  $ [1] $$ [2] $$ [1, 2] $$ [2, 1] $$ [1, 2, 1] $ $ S = [1, 1, 1] $  $ [1] $$ [1, 1] $$ [1, 1, 1] $   \n $ S $  $ n $  $ S $  $ S $ \n\n<!-- more -->\n\n### \n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### \n $ {\\rm height} $ \n\n\n\n `std::set` \n\n $ i $ $ pred $$ succ $\n\n$ pred $$ succ $ $ pred $$ succ $  $ i $ \n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n $ i $ \n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-incantation","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhwg00b50jxlrmn6lq89"},{"title":"SDOI2016 - ","date":"2016-04-15T14:25:55.000Z","_content":"\nAlice  Bob   \n $ n $  $ 123456789123456789 $  \nAlice  $ s $  $ t $  $ r $ $ r $  $ s $  $ dis $ Alice  $ r $  $ a \\times dis + b $  \nBob  $ s $  $ t $   \nBob  Bob Bob \n\n<!-- more -->\n\n### \n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### \n\n\n $ p = {\\rm LCA}(s, t) $  $ s \\rightarrow p $$ p \\rightarrow t $\n\n![Tree](sdoi2016-game/tree.png)\n\n $ {\\rm dist}(u, v) $  uv \n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n $ a \\times {\\rm dist}(s, root) + b $ \n\n\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ \n\n $ x $  $ y $ \n\n\n\n1. \n2.  `mid` \n\n `mid` \n\n\n\n****\n\n\n\n\n\n\n\n![Line](sdoi2016-game/line.png)\n\n****\n\n\n\n $ O(\\log n) $  $ O(\\log n) $  $ O(\\log n) $  $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-game.md","raw":"title: SDOI2016 - \ndate: 2016-04-15 22:25:55\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \n  - \n  - \npermalink: sdoi2016-game\n---\n\nAlice  Bob   \n $ n $  $ 123456789123456789 $  \nAlice  $ s $  $ t $  $ r $ $ r $  $ s $  $ dis $ Alice  $ r $  $ a \\times dis + b $  \nBob  $ s $  $ t $   \nBob  Bob Bob \n\n<!-- more -->\n\n### \n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### \n\n\n $ p = {\\rm LCA}(s, t) $  $ s \\rightarrow p $$ p \\rightarrow t $\n\n![Tree](sdoi2016-game/tree.png)\n\n $ {\\rm dist}(u, v) $  uv \n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n $ a \\times {\\rm dist}(s, root) + b $ \n\n\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ \n\n $ x $  $ y $ \n\n\n\n1. \n2.  `mid` \n\n `mid` \n\n\n\n****\n\n\n\n\n\n\n\n![Line](sdoi2016-game/line.png)\n\n****\n\n\n\n $ O(\\log n) $  $ O(\\log n) $  $ O(\\log n) $  $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-game","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhwj00be0jxlzu67kd1z"},{"title":"SDOI2015 - ","date":"2016-02-29T07:42:11.000Z","_content":"\nY  $ N $  X  $ i $  $ A_i $ 0 X  $ M $  $ i $  $ B_i $ Y  X  Y \n\n<!-- more -->\n\n### \n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### \n\n\n1.   \n2. \n3. \n\nw \n\n Dinic \n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n\ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble flow = dinic(s, t, n + m + 2);\n\n\tcleanUp(n + m + 2);\n\n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n\ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", dichotomy());\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-war.md","raw":"title: SDOI2015 - \ndate: 2016-02-29 15:42:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Dinic\n  - \n  - \n  - \n  - \npermalink: sdoi2015-war\n---\n\nY  $ N $  X  $ i $  $ A_i $ 0 X  $ M $  $ i $  $ B_i $ Y  X  Y \n\n<!-- more -->\n\n### \n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### \n\n\n1.   \n2. \n3. \n\nw \n\n Dinic \n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n\ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble flow = dinic(s, t, n + m + 2);\n\n\tcleanUp(n + m + 2);\n\n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n\ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", dichotomy());\n\n\treturn 0;\n}\n```\n","slug":"sdoi2015-war","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhws00bp0jxlxm6c6ph5"},{"title":"SDOI2015 -  + NTT","date":"2016-06-12T01:27:00.000Z","_content":"\n C  $ S $ $ M $  $ N $  $ S $\n\n C  C  $ x $ $ \\bmod M $  $ x $  C  $ \\{ A_i \\} $  $ \\{B_i\\} $  $ i $ $ A_i \\neq B_i $ C  $ \\bmod 1004535809 $ \n\n<!-- more -->\n\n### \n[BZOJ 3992](http://www.lydsy.com/JudgeOnline/problem.php?id=3992)\n\n### \n $ x $  $ S_i $  $ x $  $ M $  $ \\log S_i $  $ \\log x $ \n\n $ M $  $ 0 $ $ M - 2 $  $ [1,\\ M - 1] $  $ [0,\\ M - 2] $ $ g ^ {M - 1} \\equiv g ^ 0 \\equiv 1 \\pmod {M} $\n\n\n\n$$ A(x) = \\sum\\limits_{i = 0} ^ {\\infty} a_i x ^ i $$\n\n $ S_i $ $ a_{\\log S_i} = 1 $ $ a_{\\log S_i} = 0 $\n\n $ A ^ N(x) $  $ \\log x $  NTT\n\n $ \\bmod {M - 1} $  $ \\log x $ $ \\bmod {M - 1} $  $ i $  $ i $ \n\n $ O(M \\sqrt M + M \\log M \\log N) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXM = 8000;\nconst int MAXM_EXTENDED = 16384;\nconst long long MOD = 1004535809;\n\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\t// printf(\"root(%lld) = %d\\n\", p, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nint m;\nlong long log[MAXM];\n\ninline void prepare() {\n\tlong long t = 1, r = root(m);\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tlog[t] = i;\n\t\t// printf(\"log(%lld) = %d\\n\", t, i);\n\t\tt = t * r % m;\n\t}\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t\t// printf(\"omega[%d] = %lld\\n\", i, omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t\tassert(t < MAXM_EXTENDED);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tassert(n / l * i < MAXM_EXTENDED);\n\t\t\t\t\tassert(p - a + i < MAXM_EXTENDED);\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\t// printf(\"use omega = %lld\\n\", omega[n / l * i]);\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n\n\tvoid operator()(long long *a, long long *b, const int n) {\n\t\tassert(n <= MAXM_EXTENDED);\n\t\t/*\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tprintf(\" * \");\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tdft(a, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tif (a != b) dft(b, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;\n\n\t\tidft(a, n);\n\t\tif (a != b) idft(b, n);\n\t}\n} ntt;\n\ninline void pow(const long long *a, const int m, const int n, long long *res) {\n\tint size = 1;\n\twhile (size < m + m) size *= 2;\n\tntt.init(size);\n\t// printf(\"size = %d, m = %d\\n\", size, m);\n\n\tstatic long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED];\n\tstd::copy(a, a + m, buf);\n\tstd::copy(a, a + m, res);\n\tint tmp = n - 1;\n\n\t/*\n\tfor (int i = 0; i < tmp; i++) {\n\t\tntt(res, buf, size);\n\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t}\n\treturn;\n\t*/\n\n\tassert(size <= MAXM_EXTENDED);\n\n\twhile (tmp) {\n\t\tif (tmp & 1) {\n\t\t\tntt.dft(res, size);\n\t\t\tstd::copy(buf, buf + size, bufDft);\n\t\t\tntt.dft(bufDft, size);\n\t\t\tfor (int i = 0; i < size; i++) (res[i] *= bufDft[i]) %= MOD;\n\t\t\tntt.idft(res, size);\n\t\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t\t}\n\t\ttmp >>= 1;\n\n\t\tntt.dft(buf, size);\n\t\tfor (int i = 0; i < size; i++) (buf[i] *= buf[i]) %= MOD;\n\t\tntt.idft(buf, size);\n\t\tfor (int i = m; i < size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0;\n\t}\n}\n\nint main() {\n\tlong long n;\n\tint x, s;\n\tstatic long long a[MAXM];\n\n\tscanf(\"%lld %d %d %d\", &n, &m, &x, &s);\n\tfor (int i = 0; i < s; i++) scanf(\"%lld\", &a[i]);\n\n\tprepare();\n\n\tstatic long long f[MAXM_EXTENDED];\n\tfor (int i = 0; i < s; i++) {\n\t\tif (a[i] == 0) continue;\n\t\tf[log[a[i] % m]]++;\n\t}\n\n\tstatic long long res[MAXM_EXTENDED];\n\tpow(f, m - 1, n, res);\n\n\tassert(log[x] < MAXM_EXTENDED);\n\n\tlong long ans = res[log[x]];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-sequence.md","raw":"title: SDOI2015 -  + NTT\ndate: 2016-06-12 09:27:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - FFT\n  - NTT\n  - \n  - \n  - \n  - \npermalink: sdoi2015-sequence\n---\n\n C  $ S $ $ M $  $ N $  $ S $\n\n C  C  $ x $ $ \\bmod M $  $ x $  C  $ \\{ A_i \\} $  $ \\{B_i\\} $  $ i $ $ A_i \\neq B_i $ C  $ \\bmod 1004535809 $ \n\n<!-- more -->\n\n### \n[BZOJ 3992](http://www.lydsy.com/JudgeOnline/problem.php?id=3992)\n\n### \n $ x $  $ S_i $  $ x $  $ M $  $ \\log S_i $  $ \\log x $ \n\n $ M $  $ 0 $ $ M - 2 $  $ [1,\\ M - 1] $  $ [0,\\ M - 2] $ $ g ^ {M - 1} \\equiv g ^ 0 \\equiv 1 \\pmod {M} $\n\n\n\n$$ A(x) = \\sum\\limits_{i = 0} ^ {\\infty} a_i x ^ i $$\n\n $ S_i $ $ a_{\\log S_i} = 1 $ $ a_{\\log S_i} = 0 $\n\n $ A ^ N(x) $  $ \\log x $  NTT\n\n $ \\bmod {M - 1} $  $ \\log x $ $ \\bmod {M - 1} $  $ i $  $ i $ \n\n $ O(M \\sqrt M + M \\log M \\log N) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXM = 8000;\nconst int MAXM_EXTENDED = 16384;\nconst long long MOD = 1004535809;\n\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\t// printf(\"root(%lld) = %d\\n\", p, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nint m;\nlong long log[MAXM];\n\ninline void prepare() {\n\tlong long t = 1, r = root(m);\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tlog[t] = i;\n\t\t// printf(\"log(%lld) = %d\\n\", t, i);\n\t\tt = t * r % m;\n\t}\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t\t// printf(\"omega[%d] = %lld\\n\", i, omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t\tassert(t < MAXM_EXTENDED);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tassert(n / l * i < MAXM_EXTENDED);\n\t\t\t\t\tassert(p - a + i < MAXM_EXTENDED);\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\t// printf(\"use omega = %lld\\n\", omega[n / l * i]);\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n\n\tvoid operator()(long long *a, long long *b, const int n) {\n\t\tassert(n <= MAXM_EXTENDED);\n\t\t/*\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tprintf(\" * \");\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tdft(a, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tif (a != b) dft(b, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;\n\n\t\tidft(a, n);\n\t\tif (a != b) idft(b, n);\n\t}\n} ntt;\n\ninline void pow(const long long *a, const int m, const int n, long long *res) {\n\tint size = 1;\n\twhile (size < m + m) size *= 2;\n\tntt.init(size);\n\t// printf(\"size = %d, m = %d\\n\", size, m);\n\n\tstatic long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED];\n\tstd::copy(a, a + m, buf);\n\tstd::copy(a, a + m, res);\n\tint tmp = n - 1;\n\n\t/*\n\tfor (int i = 0; i < tmp; i++) {\n\t\tntt(res, buf, size);\n\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t}\n\treturn;\n\t*/\n\n\tassert(size <= MAXM_EXTENDED);\n\n\twhile (tmp) {\n\t\tif (tmp & 1) {\n\t\t\tntt.dft(res, size);\n\t\t\tstd::copy(buf, buf + size, bufDft);\n\t\t\tntt.dft(bufDft, size);\n\t\t\tfor (int i = 0; i < size; i++) (res[i] *= bufDft[i]) %= MOD;\n\t\t\tntt.idft(res, size);\n\t\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t\t}\n\t\ttmp >>= 1;\n\n\t\tntt.dft(buf, size);\n\t\tfor (int i = 0; i < size; i++) (buf[i] *= buf[i]) %= MOD;\n\t\tntt.idft(buf, size);\n\t\tfor (int i = m; i < size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0;\n\t}\n}\n\nint main() {\n\tlong long n;\n\tint x, s;\n\tstatic long long a[MAXM];\n\n\tscanf(\"%lld %d %d %d\", &n, &m, &x, &s);\n\tfor (int i = 0; i < s; i++) scanf(\"%lld\", &a[i]);\n\n\tprepare();\n\n\tstatic long long f[MAXM_EXTENDED];\n\tfor (int i = 0; i < s; i++) {\n\t\tif (a[i] == 0) continue;\n\t\tf[log[a[i] % m]]++;\n\t}\n\n\tstatic long long res[MAXM_EXTENDED];\n\tpow(f, m - 1, n, res);\n\n\tassert(log[x] < MAXM_EXTENDED);\n\n\tlong long ans = res[log[x]];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2015-sequence","published":1,"updated":"2016-06-17T13:39:09.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhww00bz0jxl99fyirb0"},{"title":"SDOI2014 - ","date":"2016-09-02T13:39:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 3531](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)\n\n### \n $ O(n \\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 1e5;\nconst int MAXQ = 1e5;\nconst int MAXC = 1e5;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint max, sum;\n\n\tSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {}\n\n\tvoid update(const int pos, const int val) {\n\t\tif (l != r) {\n\t\t\tSegmentTree *&c = pos <= mid ? lc : rc;\n\t\t\tif (!c) c = (pos <= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r);\n\t\t\tc->update(pos, val);\n\t\t\tif (val == 0 && !c->lc && !c->rc) delete c, c = NULL;\n\t\t\tmax = sum = 0;\n\t\t\tif (lc) max = std::max(max, lc->max), sum += lc->sum;\n\t\t\tif (rc) max = std::max(max, rc->max), sum += rc->sum;\n\t\t} else sum = max = val;\n\t}\n\n\tint querySum(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return (lc ? lc->querySum(l, r) : 0) + (rc ? rc->querySum(l, r) : 0);\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc ? lc->queryMax(l, r) : 0, rc ? rc->queryMax(l, r) : 0);\n\t}\n} *seg[MAXC];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i;\n\tbool f;\n\tNode *p, *c, *t;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, q, f[MAXN], v[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].d = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->f) {\n\t\t\tv->f = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n\t\t\t\te->t->d = v->d + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->s = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->s += e->t->s;\n\t\t\t\tif (!v->c || v->c->s < e->t->s) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\ts.push(&N[0]);\n\tint i = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (v->f) {\n\t\t\tv->f = false;\n\t\t\tv->i = i++;\n\t\t\tif (!v->p || v != v->p->c) v->t = v;\n\t\t\telse v->t = v->p->t;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else s.pop();\n\t}\n}\n\ninline int querySum(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans += seg->querySum(a->t->i, a->i);\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn ans + seg->querySum(a->i, b->i);\n}\n\ninline int queryMax(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans = std::max(ans, seg->queryMax(a->t->i, a->i));\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn std::max(ans, seg->queryMax(a->i, b->i));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (int i = 0; i < MAXC; i++) seg[i] = new SegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &v[i], &f[i]);\n\t\tf[i]--;\n\t\t// printf(\"seg[%d]->update(%d, %d)\\n\", f[i], i, v[i]);\n\t\t// seg[f[i]]->update(i, v[i]);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < n; i++) seg[f[i]]->update(N[i].i, v[i]);\n\n\twhile (q-- ) {\n\t\tchar s[3];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", s, &a, &b);\n\t\t\n\t\tif (s[1] == 'C') {\n\t\t\ta--, b--;\n\t\t\tseg[f[a]]->update(N[a].i, 0);\n\t\t\tseg[b]->update(N[a].i, v[a]);\n\t\t\tf[a] = b;\n\t\t} else if (s[1] == 'W') {\n\t\t\ta--;\n\t\t\tseg[f[a]]->update(N[a].i, b);\n\t\t\tv[a] = b;\n\t\t} else if (s[1] == 'S') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", querySum(a, b, seg[f[a]]));\n\t\t} else if (s[1] == 'M') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", queryMax(a, b, seg[f[a]]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/sdoi2014-journey.md","raw":"title: SDOI2014 - \ndate: 2016-09-02 21:39:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \npermalink: sdoi2014-journey\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3531](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)\n\n### \n $ O(n \\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 1e5;\nconst int MAXQ = 1e5;\nconst int MAXC = 1e5;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint max, sum;\n\n\tSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {}\n\n\tvoid update(const int pos, const int val) {\n\t\tif (l != r) {\n\t\t\tSegmentTree *&c = pos <= mid ? lc : rc;\n\t\t\tif (!c) c = (pos <= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r);\n\t\t\tc->update(pos, val);\n\t\t\tif (val == 0 && !c->lc && !c->rc) delete c, c = NULL;\n\t\t\tmax = sum = 0;\n\t\t\tif (lc) max = std::max(max, lc->max), sum += lc->sum;\n\t\t\tif (rc) max = std::max(max, rc->max), sum += rc->sum;\n\t\t} else sum = max = val;\n\t}\n\n\tint querySum(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return (lc ? lc->querySum(l, r) : 0) + (rc ? rc->querySum(l, r) : 0);\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc ? lc->queryMax(l, r) : 0, rc ? rc->queryMax(l, r) : 0);\n\t}\n} *seg[MAXC];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i;\n\tbool f;\n\tNode *p, *c, *t;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, q, f[MAXN], v[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].d = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->f) {\n\t\t\tv->f = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n\t\t\t\te->t->d = v->d + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->s = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->s += e->t->s;\n\t\t\t\tif (!v->c || v->c->s < e->t->s) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\ts.push(&N[0]);\n\tint i = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (v->f) {\n\t\t\tv->f = false;\n\t\t\tv->i = i++;\n\t\t\tif (!v->p || v != v->p->c) v->t = v;\n\t\t\telse v->t = v->p->t;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else s.pop();\n\t}\n}\n\ninline int querySum(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans += seg->querySum(a->t->i, a->i);\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn ans + seg->querySum(a->i, b->i);\n}\n\ninline int queryMax(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans = std::max(ans, seg->queryMax(a->t->i, a->i));\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn std::max(ans, seg->queryMax(a->i, b->i));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (int i = 0; i < MAXC; i++) seg[i] = new SegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &v[i], &f[i]);\n\t\tf[i]--;\n\t\t// printf(\"seg[%d]->update(%d, %d)\\n\", f[i], i, v[i]);\n\t\t// seg[f[i]]->update(i, v[i]);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < n; i++) seg[f[i]]->update(N[i].i, v[i]);\n\n\twhile (q-- ) {\n\t\tchar s[3];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", s, &a, &b);\n\t\t\n\t\tif (s[1] == 'C') {\n\t\t\ta--, b--;\n\t\t\tseg[f[a]]->update(N[a].i, 0);\n\t\t\tseg[b]->update(N[a].i, v[a]);\n\t\t\tf[a] = b;\n\t\t} else if (s[1] == 'W') {\n\t\t\ta--;\n\t\t\tseg[f[a]]->update(N[a].i, b);\n\t\t\tv[a] = b;\n\t\t} else if (s[1] == 'S') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", querySum(a, b, seg[f[a]]));\n\t\t} else if (s[1] == 'M') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", queryMax(a, b, seg[f[a]]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"sdoi2014-journey","published":1,"updated":"2016-09-02T13:42:35.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhx700cd0jxlmwf8s7tz"},{"title":"SDOI2013 - LCA +  + ","date":"2016-09-05T13:49:00.000Z","_content":"\n $ n $ $ m $  $ T $ \n\n1.  $ k $ \n2. \n\n<!-- more -->\n\n### \n[BZOJ 3123](http://www.lydsy.com/JudgeOnline/problem.php?id=3123)\n\n### \n $ k $ \n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 80000;\nconst int MAXN_LOG = 17;\n\nstruct UnionFindSet {\n\tint a[MAXN], s[MAXN];\n\n\tinline void init(const int n) { for (register int i = 0; i < n; i++) a[i] = i, s[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tinline int getSize(const int x) { return s[find(x)]; }\n\n\tinline void merge(const int x, const int y) {\n\t\tconst register int p = find(x), q = find(y);\n\t\ta[p] = q;\n\t\ts[q] += s[p];\n\t}\n} ufs;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint cnt, refCnt;\n\n\tinline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {}\n\n\tinline static SegmentTree *newNode();\n\tinline static void deleteNode(SegmentTree *v);\n\n\t~SegmentTree() {\n\t\tif (r - l < 600) return;\n\t\tif (lc && lc->unref()) deleteNode(lc);\n\t\tif (rc && rc->unref()) deleteNode(rc);\n\t}\n\n\tinline SegmentTree *buildChild(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x <= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0);\n\t\telse return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0);\n\t}\n\n\tSegmentTree *insertSelf(const int x) {\n\t\tcnt++;\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return this;\n\t\telse if (x <= mid) return (lc = buildChild(x))->insertSelf(x), this;\n\t\telse return (rc = buildChild(x))->insertSelf(x), this;\n\t}\n\n\tSegmentTree *insert(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1);\n\t\telse if (x <= mid) return new (newNode()) SegmentTree(l, r, lc ? lc->insert(x) : buildChild(x)->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\telse return new (newNode()) SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : buildChild(x)->insertSelf(x), cnt + 1);\n\t}\n\n\tinline SegmentTree *ref() {\n\t\trefCnt++;\n\t\treturn this;\n\t}\n\n\tinline bool unref() {\n\t\treturn !--refCnt;\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse return lc->query(l, r) + rc->query(l, r);\n\t}\n\n\tinline int rank() {\n\t\treturn lc ? lc->cnt : 0;\n\t}\n} *segRoot;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[sizeof(T) * SIZE], *p;\n\tT *recycle[SIZE], **pr;\n\t\n\tinline MemoryPool() : p(buf), pr(recycle) {}\n\n\tinline T *alloc() {\n\t\tif (p == buf + sizeof(T) * SIZE) {\n\t\t\tif (pr <= recycle) throw std::bad_alloc();\n\t\t\telse return *--pr;\n\t\t} else {\n\t\t\tregister char *res = p;\n\t\t\tp += sizeof(T);\n\t\t\treturn reinterpret_cast<T *>(res);\n\t\t}\n\t}\n\n\tinline void free(T *p) {\n\t\t*pr++ = p;\n\t}\n};\n\nMemoryPool<SegmentTree, MAXN * MAXN_LOG * 10> pool;\ninline SegmentTree *SegmentTree::newNode() {\n\treturn pool.alloc();\n}\n\ninline void SegmentTree::deleteNode(SegmentTree *p) {\n\tp->~SegmentTree();\n\tpool.free(p);\n}\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *p;\n\tint w, ts, d;\n\tbool v;\n\tSegmentTree *seg;\n\tNode *f[MAXN_LOG + 1];\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {};\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nint n, ts, logn = 0;\n\ninline void bfs(Node *start, const bool init = true) {\n\t++ts;\n\tstd::queue<Node *> q;\n\tstart->ts = ts;\n\tif (init) {\n\t\tstart->p = start->f[0] = start;\n\t\tstart->seg = segRoot->insert(start->w);\n\t\tstart->d = 0;\n\t}\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (register int j = 1; j <= logn; j++) {\n\t\t\tv->f[j] = v->f[j - 1]->f[j - 1];\n\t\t}\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->ts != ts && (init || e->t != start->p)) {\n\t\t\te->t->ts = ts;\n\t\t\te->t->p = e->t->f[0] = v;\n\t\t\tif (e->t->seg) SegmentTree::deleteNode(e->t->seg);\n\t\t\te->t->seg = v->seg->insert(e->t->w);\n\t\t\te->t->d = v->d + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void bfs() {\n\tfor (register int i = 0; i < n; i++) if (N[i].ts == 0) bfs(&N[i]);\n}\n\ninline void link(int u, int v) {\n\tconst register int su = ufs.getSize(u), sv = ufs.getSize(v);\n\tif (su > sv) std::swap(u, v);\n\n\taddEdge(u, v);\n\tN[u].p = N[u].f[0] = &N[v];\n\tSegmentTree::deleteNode(N[u].seg);\n\tN[u].seg = N[v].seg->insert(N[u].w);\n\tN[u].d = N[v].d + 1;\n\tbfs(&N[u], false);\n\n\tufs.merge(u, v);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\tif (u->d < v->d) std::swap(u, v);\n\tif (u->d != v->d) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i]->d >= v->d) u = u->f[i];\n\t}\n\tif (u != v) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n\t\treturn u->p;\n\t}\n\treturn u;\n}\n\ninline int query(Node *u, Node *v, int k) {\n\tNode *p = lca(u, v);\n\tregister int min = 0, max = n - 1;\n\tSegmentTree *sa = u->seg, *sb = v->seg, *sc = p->seg, *sd = p->p != p ? p->p->seg : segRoot;\n\twhile (min != max) {\n\t\tconst register int mid = min + (max - min) / 2;\n\t\tregister int t = 0;\n\t\tif (sa) t += sa->rank();\n\t\tif (sb) t += sb->rank();\n\t\tif (sc) t -= sc->rank();\n\t\tif (sd) t -= sd->rank();\n\t\tif (k <= t) {\n\t\t\tif (sa) sa = sa->lc;\n\t\t\tif (sb) sb = sb->lc;\n\t\t\tif (sc) sc = sc->lc;\n\t\t\tif (sd) sd = sd->lc;\n\t\t\tmax = mid;\n\t\t} else {\n\t\t\tif (sa) sa = sa->rc;\n\t\t\tif (sb) sb = sb->rc;\n\t\t\tif (sc) sc = sc->rc;\n\t\t\tif (sd) sd = sd->rc;\n\t\t\tk -= t, min = mid + 1;\n\t\t}\n\t}\n\treturn min;\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tint m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tufs.init(n);\n\tfor (; (1 << (logn + 1)) <= n; logn++);\n\n\tfor (register int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\tstatic int set[MAXN];\n\tfor (register int i = 0; i < n; i++) set[i] = N[i].w;\n\tstd::sort(set, set + n);\n\tregister int *end = std::unique(set, set + n);\n\tfor (register int i = 0; i < n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set;\n\n\tsegRoot = new SegmentTree(0, n - 1);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbfs();\n\n\tregister int lastAns = 0;\n\twhile (t--) {\n\t\tchar cmd[2];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", cmd, &u, &v), u ^= lastAns, v ^= lastAns, u--, v--;\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tk ^= lastAns;\n\t\t\tprintf(\"%d\\n\", lastAns = set[query(&N[u], &N[v], k)]);\n\t\t} else {\n\t\t\tlink(u, v);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2013-rforest.md","raw":"title: SDOI2013 - LCA +  + \ndate: 2016-09-05 21:49:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \n  - \n  - \npermalink: sdoi2013-rforest\n---\n\n $ n $ $ m $  $ T $ \n\n1.  $ k $ \n2. \n\n<!-- more -->\n\n### \n[BZOJ 3123](http://www.lydsy.com/JudgeOnline/problem.php?id=3123)\n\n### \n $ k $ \n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 80000;\nconst int MAXN_LOG = 17;\n\nstruct UnionFindSet {\n\tint a[MAXN], s[MAXN];\n\n\tinline void init(const int n) { for (register int i = 0; i < n; i++) a[i] = i, s[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tinline int getSize(const int x) { return s[find(x)]; }\n\n\tinline void merge(const int x, const int y) {\n\t\tconst register int p = find(x), q = find(y);\n\t\ta[p] = q;\n\t\ts[q] += s[p];\n\t}\n} ufs;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint cnt, refCnt;\n\n\tinline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {}\n\n\tinline static SegmentTree *newNode();\n\tinline static void deleteNode(SegmentTree *v);\n\n\t~SegmentTree() {\n\t\tif (r - l < 600) return;\n\t\tif (lc && lc->unref()) deleteNode(lc);\n\t\tif (rc && rc->unref()) deleteNode(rc);\n\t}\n\n\tinline SegmentTree *buildChild(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x <= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0);\n\t\telse return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0);\n\t}\n\n\tSegmentTree *insertSelf(const int x) {\n\t\tcnt++;\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return this;\n\t\telse if (x <= mid) return (lc = buildChild(x))->insertSelf(x), this;\n\t\telse return (rc = buildChild(x))->insertSelf(x), this;\n\t}\n\n\tSegmentTree *insert(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1);\n\t\telse if (x <= mid) return new (newNode()) SegmentTree(l, r, lc ? lc->insert(x) : buildChild(x)->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\telse return new (newNode()) SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : buildChild(x)->insertSelf(x), cnt + 1);\n\t}\n\n\tinline SegmentTree *ref() {\n\t\trefCnt++;\n\t\treturn this;\n\t}\n\n\tinline bool unref() {\n\t\treturn !--refCnt;\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse return lc->query(l, r) + rc->query(l, r);\n\t}\n\n\tinline int rank() {\n\t\treturn lc ? lc->cnt : 0;\n\t}\n} *segRoot;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[sizeof(T) * SIZE], *p;\n\tT *recycle[SIZE], **pr;\n\t\n\tinline MemoryPool() : p(buf), pr(recycle) {}\n\n\tinline T *alloc() {\n\t\tif (p == buf + sizeof(T) * SIZE) {\n\t\t\tif (pr <= recycle) throw std::bad_alloc();\n\t\t\telse return *--pr;\n\t\t} else {\n\t\t\tregister char *res = p;\n\t\t\tp += sizeof(T);\n\t\t\treturn reinterpret_cast<T *>(res);\n\t\t}\n\t}\n\n\tinline void free(T *p) {\n\t\t*pr++ = p;\n\t}\n};\n\nMemoryPool<SegmentTree, MAXN * MAXN_LOG * 10> pool;\ninline SegmentTree *SegmentTree::newNode() {\n\treturn pool.alloc();\n}\n\ninline void SegmentTree::deleteNode(SegmentTree *p) {\n\tp->~SegmentTree();\n\tpool.free(p);\n}\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *p;\n\tint w, ts, d;\n\tbool v;\n\tSegmentTree *seg;\n\tNode *f[MAXN_LOG + 1];\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {};\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nint n, ts, logn = 0;\n\ninline void bfs(Node *start, const bool init = true) {\n\t++ts;\n\tstd::queue<Node *> q;\n\tstart->ts = ts;\n\tif (init) {\n\t\tstart->p = start->f[0] = start;\n\t\tstart->seg = segRoot->insert(start->w);\n\t\tstart->d = 0;\n\t}\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (register int j = 1; j <= logn; j++) {\n\t\t\tv->f[j] = v->f[j - 1]->f[j - 1];\n\t\t}\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->ts != ts && (init || e->t != start->p)) {\n\t\t\te->t->ts = ts;\n\t\t\te->t->p = e->t->f[0] = v;\n\t\t\tif (e->t->seg) SegmentTree::deleteNode(e->t->seg);\n\t\t\te->t->seg = v->seg->insert(e->t->w);\n\t\t\te->t->d = v->d + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void bfs() {\n\tfor (register int i = 0; i < n; i++) if (N[i].ts == 0) bfs(&N[i]);\n}\n\ninline void link(int u, int v) {\n\tconst register int su = ufs.getSize(u), sv = ufs.getSize(v);\n\tif (su > sv) std::swap(u, v);\n\n\taddEdge(u, v);\n\tN[u].p = N[u].f[0] = &N[v];\n\tSegmentTree::deleteNode(N[u].seg);\n\tN[u].seg = N[v].seg->insert(N[u].w);\n\tN[u].d = N[v].d + 1;\n\tbfs(&N[u], false);\n\n\tufs.merge(u, v);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\tif (u->d < v->d) std::swap(u, v);\n\tif (u->d != v->d) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i]->d >= v->d) u = u->f[i];\n\t}\n\tif (u != v) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n\t\treturn u->p;\n\t}\n\treturn u;\n}\n\ninline int query(Node *u, Node *v, int k) {\n\tNode *p = lca(u, v);\n\tregister int min = 0, max = n - 1;\n\tSegmentTree *sa = u->seg, *sb = v->seg, *sc = p->seg, *sd = p->p != p ? p->p->seg : segRoot;\n\twhile (min != max) {\n\t\tconst register int mid = min + (max - min) / 2;\n\t\tregister int t = 0;\n\t\tif (sa) t += sa->rank();\n\t\tif (sb) t += sb->rank();\n\t\tif (sc) t -= sc->rank();\n\t\tif (sd) t -= sd->rank();\n\t\tif (k <= t) {\n\t\t\tif (sa) sa = sa->lc;\n\t\t\tif (sb) sb = sb->lc;\n\t\t\tif (sc) sc = sc->lc;\n\t\t\tif (sd) sd = sd->lc;\n\t\t\tmax = mid;\n\t\t} else {\n\t\t\tif (sa) sa = sa->rc;\n\t\t\tif (sb) sb = sb->rc;\n\t\t\tif (sc) sc = sc->rc;\n\t\t\tif (sd) sd = sd->rc;\n\t\t\tk -= t, min = mid + 1;\n\t\t}\n\t}\n\treturn min;\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tint m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tufs.init(n);\n\tfor (; (1 << (logn + 1)) <= n; logn++);\n\n\tfor (register int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\tstatic int set[MAXN];\n\tfor (register int i = 0; i < n; i++) set[i] = N[i].w;\n\tstd::sort(set, set + n);\n\tregister int *end = std::unique(set, set + n);\n\tfor (register int i = 0; i < n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set;\n\n\tsegRoot = new SegmentTree(0, n - 1);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbfs();\n\n\tregister int lastAns = 0;\n\twhile (t--) {\n\t\tchar cmd[2];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", cmd, &u, &v), u ^= lastAns, v ^= lastAns, u--, v--;\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tk ^= lastAns;\n\t\t\tprintf(\"%d\\n\", lastAns = set[query(&N[u], &N[v], k)]);\n\t\t} else {\n\t\t\tlink(u, v);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"sdoi2013-rforest","published":1,"updated":"2016-10-19T09:24:21.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhxa00cj0jxlokn57yl1"},{"title":"SDOI2011 -  + EXGCD + BSGS","date":"2016-06-13T04:07:00.000Z","_content":"\n\n\n1.  $ y $$ z $$ p $ $ y ^ z \\bmod p $ \n2.  $ y $$ z $$ p $ $ xy \\equiv z \\pmod p $  $ x $\n3.  $ y $$ z $$ p $ $ y ^ x \\equiv z \\pmod p $ $ x $\n\n<!-- more -->\n\n### \n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242)\n\n### \n\n\n $ y \\equiv 0 \\pmod p $  $ z \\not \\equiv 0 \\pmod p $   \n $ z \\equiv 0 \\pmod p $  $ 0 $\n\n $ y $  $ p $ \n\n$$ x \\equiv z \\times y ^ {-1} \\pmod p $$\n\nEXGCD \n\nBSGS \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <tr1/unordered_map>\n\ntemplate <typename T>\ninline T pow(const T a, const T n, const T p) {\n\tT ans = 1;\n\tfor (T x = a, tmp = n; tmp; tmp >>= 1, x = x * x % p) if (tmp & 1) ans = ans * x % p;\n\treturn ans;\n}\n\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tif (a == 0) {\n\t\treturn b == 0 ? 1 : -1;\n\t}\n\n\tstd::tr1::unordered_map<T, T> map;\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT r = b, k = inv(t, p) % p;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(r)) return map[r] + i * m;\n\t\tr = r * k % p;\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\twhile (t--) {\n\t\tlong long a, b, p;\n\t\tscanf(\"%lld %lld %lld\", &a, &b, &p);\n\t\tif (k == 1) {\n\t\t\tprintf(\"%lld\\n\", pow(a, b, p));\n\t\t} else if (k == 2) {\n\t\t\tif (a > p && a % p == 0) puts(\"Orz, I cannot find x!\");\n\t\t\telse {\n\t\t\t\tlong long t = inv(a, p);\n\t\t\t\tprintf(\"%lld\\n\", b * t % p);\n\t\t\t}\n\t\t} else if (k == 3) {\n\t\t\tlong long ans = bsgs(a % p, b % p, p);\n\t\t\tif (ans == -1) puts(\"Orz, I cannot find x!\");\n\t\t\telse printf(\"%lld\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2011-calc.md","raw":"title: SDOI2011 -  + EXGCD + BSGS\ndate: 2016-06-13 12:07:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - EXGCD\n  - \n  - BSGS\npermalink: sdoi2011-calc\n---\n\n\n\n1.  $ y $$ z $$ p $ $ y ^ z \\bmod p $ \n2.  $ y $$ z $$ p $ $ xy \\equiv z \\pmod p $  $ x $\n3.  $ y $$ z $$ p $ $ y ^ x \\equiv z \\pmod p $ $ x $\n\n<!-- more -->\n\n### \n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242)\n\n### \n\n\n $ y \\equiv 0 \\pmod p $  $ z \\not \\equiv 0 \\pmod p $   \n $ z \\equiv 0 \\pmod p $  $ 0 $\n\n $ y $  $ p $ \n\n$$ x \\equiv z \\times y ^ {-1} \\pmod p $$\n\nEXGCD \n\nBSGS \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <tr1/unordered_map>\n\ntemplate <typename T>\ninline T pow(const T a, const T n, const T p) {\n\tT ans = 1;\n\tfor (T x = a, tmp = n; tmp; tmp >>= 1, x = x * x % p) if (tmp & 1) ans = ans * x % p;\n\treturn ans;\n}\n\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tif (a == 0) {\n\t\treturn b == 0 ? 1 : -1;\n\t}\n\n\tstd::tr1::unordered_map<T, T> map;\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT r = b, k = inv(t, p) % p;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(r)) return map[r] + i * m;\n\t\tr = r * k % p;\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\twhile (t--) {\n\t\tlong long a, b, p;\n\t\tscanf(\"%lld %lld %lld\", &a, &b, &p);\n\t\tif (k == 1) {\n\t\t\tprintf(\"%lld\\n\", pow(a, b, p));\n\t\t} else if (k == 2) {\n\t\t\tif (a > p && a % p == 0) puts(\"Orz, I cannot find x!\");\n\t\t\telse {\n\t\t\t\tlong long t = inv(a, p);\n\t\t\t\tprintf(\"%lld\\n\", b * t % p);\n\t\t\t}\n\t\t} else if (k == 3) {\n\t\t\tlong long ans = bsgs(a % p, b % p, p);\n\t\t\tif (ans == -1) puts(\"Orz, I cannot find x!\");\n\t\t\telse printf(\"%lld\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"sdoi2011-calc","published":1,"updated":"2016-06-13T04:07:43.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhxd00cu0jxl2mv4tj77"},{"title":"SDOI2010 - ","date":"2016-02-29T13:30:11.000Z","_content":"\n $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### \n  \n\n****\n\n1.  1\n2.  1 \n3.  1 \n4.  1 \n5.  1  0  1 \n\n   \n\n  \n\n\n\n****\n\n1. \n2.  1 \n3.  1 \n4.  1 \n5. **** 1 \n\n  \n\n  \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-starrace.md","raw":"title: SDOI2010 -  \ndate: 2016-02-29 21:30:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Edmonds-Karp\n  - \n  - \n  - \npermalink: sdoi2010-starrace\n---\n\n $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### \n  \n\n****\n\n1.  1\n2.  1 \n3.  1 \n4.  1 \n5.  1  0  1 \n\n   \n\n  \n\n\n\n****\n\n1. \n2.  1 \n3.  1 \n4.  1 \n5. **** 1 \n\n  \n\n  \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-starrace","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhxi00d40jxliobqdimd"},{"title":"SDOI2010 - DP","date":"2016-06-20T07:49:00.000Z","_content":"\n\n\n $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1925](http://www.lydsy.com/JudgeOnline/problem.php?id=1925)\n\n### \n $ 0 $ ~ $ n - 1 $ \n\n $ f(i,\\ j) $  $ 0 $ ~ $ i $  $ j $$ j \\leq i $****\n\n**** $ j - 1 $  $ j - 1 $  $ f(i,\\ j - 1) $  \n**** $ j - 1 $  $ 0 $ ~ $ i - 1 $ **** $ x $  $ (i - 1) - x $ $ f(i - 1,\\ (i - 1) - (j - 1)) $\n\n $ f(i,\\ j) = f(i,\\ j - 1) + f(i - 1, i - j) $\n\n $ 2 \\sum\\limits_{i = 0} ^ {n - 1} f(n - 1,\\ i) $**** $ 2 $\n\n### \n 30M+ \n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\nint _f[MAXN * (MAXN + 1) / 2];\nint *f[MAXN + 1];\n\ninline void init() {\n\tint *curr = _f;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i] = curr;\n\t\tcurr += i + 1;\n\t}\n\t// printf(\"%ld %d\\n\", curr - _f, n * (n + 1) / 2);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\tinit();\n\n\tf[1][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p;\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[n - 1][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\n\tstatic int f[2][MAXN];\n\tf[1 % 2][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[(n - 1) % 2][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-goblin.md","raw":"title: SDOI2010 - DP\ndate: 2016-06-20 15:49:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - DP\npermalink: sdoi2010-goblin\n---\n\n\n\n $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1925](http://www.lydsy.com/JudgeOnline/problem.php?id=1925)\n\n### \n $ 0 $ ~ $ n - 1 $ \n\n $ f(i,\\ j) $  $ 0 $ ~ $ i $  $ j $$ j \\leq i $****\n\n**** $ j - 1 $  $ j - 1 $  $ f(i,\\ j - 1) $  \n**** $ j - 1 $  $ 0 $ ~ $ i - 1 $ **** $ x $  $ (i - 1) - x $ $ f(i - 1,\\ (i - 1) - (j - 1)) $\n\n $ f(i,\\ j) = f(i,\\ j - 1) + f(i - 1, i - j) $\n\n $ 2 \\sum\\limits_{i = 0} ^ {n - 1} f(n - 1,\\ i) $**** $ 2 $\n\n### \n 30M+ \n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\nint _f[MAXN * (MAXN + 1) / 2];\nint *f[MAXN + 1];\n\ninline void init() {\n\tint *curr = _f;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i] = curr;\n\t\tcurr += i + 1;\n\t}\n\t// printf(\"%ld %d\\n\", curr - _f, n * (n + 1) / 2);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\tinit();\n\n\tf[1][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p;\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[n - 1][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\n\tstatic int f[2][MAXN];\n\tf[1 % 2][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[(n - 1) % 2][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-goblin","published":1,"updated":"2016-06-20T07:50:35.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhxm00dc0jxlgdx8kafy"},{"title":"SDOI2009 - ","date":"2016-06-21T12:24:00.000Z","_content":"\n $ N $  $ M $ Elaxia Elaxia  $ 1 $ $ N $ Elaxia   \n\n\n<!-- more -->\n\n### \n[BZOJ 1877](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)\n\n### \n $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\t// printf(\"%d %d\\n\", f, c);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->d > v->d + e->w && e->f < e->c) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\t// printf(\"[%ld, %ld]\\n\", e->s - N, e->t - N);\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1, 0);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\taddEdge(u + n, v, 1, w);\n\t}\n\n\taddEdge(s, 1 + n, INT_MAX, 0);\n\taddEdge(n, t, INT_MAX, 0);\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tprintf(\"%d %d\\n\", f, c);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2009-run.md","raw":"title: SDOI2009 - \ndate: 2016-06-21 20:24:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \n  - Edmonds-Karp\npermalink: sdoi2009-run\n---\n\n $ N $  $ M $ Elaxia Elaxia  $ 1 $ $ N $ Elaxia   \n\n\n<!-- more -->\n\n### \n[BZOJ 1877](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)\n\n### \n $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\t// printf(\"%d %d\\n\", f, c);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->d > v->d + e->w && e->f < e->c) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\t// printf(\"[%ld, %ld]\\n\", e->s - N, e->t - N);\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1, 0);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\taddEdge(u + n, v, 1, w);\n\t}\n\n\taddEdge(s, 1 + n, INT_MAX, 0);\n\taddEdge(n, t, INT_MAX, 0);\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tprintf(\"%d %d\\n\", f, c);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2009-run","published":1,"updated":"2016-06-21T12:24:51.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhxq00dh0jxlz0w3qc57"},{"title":"SDOI2008 - ","date":"2016-09-02T13:07:00.000Z","_content":"\nA  $ 5 $  $ S $$ S $ $ S $  \n\n$ 5 $ \n\n1. $ A = A \\cup B $\n2. $ A = A \\cap B $\n3. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} $\n4. $ A = \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n5. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} \\cup \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n\n<!-- more -->\n\n### \n[BZOJ 3226](http://www.lydsy.com/JudgeOnline/problem.php?id=3226)\n\n### \n $ (a, b) $ $ [a + 0.5, b - 0.5] $ $ \\times 2 $ $ [2a + 1, 2b - 1] $\n\n\n\n1.  $ B $  $ 1 $\n2.  $ B $  $ 0 $\n3.  $ B $  $ 0 $\n4.  $ B $  $ 0 $\n5.  $ B $ \n\n $ 0 $  $ 1 $  $ 0 $  $ 1 $ $ 1 $  $ 0 $\n\n $ 0 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 65535;\nconst int MAXM = 70000;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tenum TagType {\n\t\tZero, One, Reverse, None\n\t} tag;\n\tbool val;\n\n\tSegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {}\n\n\tvoid setTag(const TagType t) {\n\t\tif (t == Reverse) {\n\t\t\tif (l == r) val ^= 1;\n\t\t\telse {\n\t\t\t\tif (tag == Reverse) tag = None;\n\t\t\t\telse if (tag == Zero) tag = One;\n\t\t\t\telse if (tag == One) tag = Zero;\n\t\t\t\telse tag = Reverse;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l == r) val = t == One;\n\t\t\telse tag = t;\n\t\t}\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag != None) {\n\t\t\tlc->setTag(tag);\n\t\t\trc->setTag(tag);\n\t\t\ttag = None;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const TagType t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) setTag(t);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, t);\n\t\t\trc->update(l, r, t);\n\t\t}\n\t}\n\n\tbool query(const int pos) {\n\t\tSegmentTree *v = this;\n\t\tbool rev = false;\n\t\twhile (!(v->l == v->r || v->tag == Zero || v->tag == One)) {\n\t\t\tif (v->tag == Reverse) rev ^= 1;\n\t\t\tv = (pos <= v->mid) ? v->lc : v->rc;\n\t\t}\n\t\tif (v->tag == Zero) v->val = false;\n\t\telse if (v->tag == One) v->val = true;\n\t\treturn rev ? v->val ^ 1 : v->val;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, l, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\t/*\n\tstatic bool a[MAXN * 2 + 1];\n\n\tstatic void update(const int l, const int r, const TagType t) {\n\t\tif (l > r) return;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (t == Zero) a[i] = false;\n\t\t\telse if (t == One) a[i] = true;\n\t\t\telse if (t == Reverse) a[i] ^= 1;\n\t\t}\n\t}\n\n\tstatic bool query(const int pos) { return a[pos]; }\n\n\tstatic SegmentTree *build(const int l, const int r) { return NULL; }\n\t*/\n} *segment;\n\n// bool SegmentTree::a[MAXN * 2 + 1];\n\ninline void parse(char *s, int &l, int &r) {\n\tchar ch;\n\tbool fl = false;\n\tch = *s++;\n\tif (ch == '(') fl = true;\n\tl = 0;\n\twhile ((ch = *s++) != ',') l = l * 10 + ch - '0';\n\tl *= 2;\n\tif (fl) l++;\n\tr = 0;\n\twhile ((ch = *s++), (ch >= '0' && ch <= '9')) r = r * 10 + ch - '0';\n\tr *= 2;\n\tif (ch == ')') r--;\n}\n\ninline void print() {\n\tint l = -1;\n\tbool flag = false;\n\tfor (int i = 0; i <= MAXN * 2; i++) {\n\t\tbool val = segment->query(i);\n\t\tif (l == -1 && val) {\n\t\t\tl = i;\n\t\t} else if (l != -1 && !val) {\n\t\t\tprintf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')');\n\t\t\tflag = true;\n\t\t\tl = -1;\n\t\t}\n\t}\n\tif (l != -1) printf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true;\n\tif (!flag) printf(\"empty set\");\n\tputchar('\\n');\n}\n\nint main() {\n\tsegment = SegmentTree::build(0, MAXN * 2);\n\tchar cmd[2], s[100];\n\twhile (~scanf(\"%s %s\", cmd, s)) {\n\t\tint l, r;\n\t\tparse(s, l, r);\n\t\t// printf(\"read: [%d, %d]\\n\", l, r);\n\n\t\tif (cmd[0] == 'U') {\n\t\t\tsegment->update(l, r, SegmentTree::One);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'D') {\n\t\t\tsegment->update(l, r, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tsegment->update(0, MAXN * 2, SegmentTree::Reverse);\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'S') {\n\t\t\tsegment->update(l, r, SegmentTree::Reverse);\n\t\t}\n\n\t\t// print();\n\t}\n\n\tprint();\n\n\treturn 0;\n}\n```","source":"_posts/sdoi2008-interval.md","raw":"title: SDOI2008 - \ndate: 2016-09-02 21:07:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \npermalink: sdoi2008-interval\n---\n\nA  $ 5 $  $ S $$ S $ $ S $  \n\n$ 5 $ \n\n1. $ A = A \\cup B $\n2. $ A = A \\cap B $\n3. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} $\n4. $ A = \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n5. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} \\cup \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n\n<!-- more -->\n\n### \n[BZOJ 3226](http://www.lydsy.com/JudgeOnline/problem.php?id=3226)\n\n### \n $ (a, b) $ $ [a + 0.5, b - 0.5] $ $ \\times 2 $ $ [2a + 1, 2b - 1] $\n\n\n\n1.  $ B $  $ 1 $\n2.  $ B $  $ 0 $\n3.  $ B $  $ 0 $\n4.  $ B $  $ 0 $\n5.  $ B $ \n\n $ 0 $  $ 1 $  $ 0 $  $ 1 $ $ 1 $  $ 0 $\n\n $ 0 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 65535;\nconst int MAXM = 70000;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tenum TagType {\n\t\tZero, One, Reverse, None\n\t} tag;\n\tbool val;\n\n\tSegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {}\n\n\tvoid setTag(const TagType t) {\n\t\tif (t == Reverse) {\n\t\t\tif (l == r) val ^= 1;\n\t\t\telse {\n\t\t\t\tif (tag == Reverse) tag = None;\n\t\t\t\telse if (tag == Zero) tag = One;\n\t\t\t\telse if (tag == One) tag = Zero;\n\t\t\t\telse tag = Reverse;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l == r) val = t == One;\n\t\t\telse tag = t;\n\t\t}\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag != None) {\n\t\t\tlc->setTag(tag);\n\t\t\trc->setTag(tag);\n\t\t\ttag = None;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const TagType t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) setTag(t);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, t);\n\t\t\trc->update(l, r, t);\n\t\t}\n\t}\n\n\tbool query(const int pos) {\n\t\tSegmentTree *v = this;\n\t\tbool rev = false;\n\t\twhile (!(v->l == v->r || v->tag == Zero || v->tag == One)) {\n\t\t\tif (v->tag == Reverse) rev ^= 1;\n\t\t\tv = (pos <= v->mid) ? v->lc : v->rc;\n\t\t}\n\t\tif (v->tag == Zero) v->val = false;\n\t\telse if (v->tag == One) v->val = true;\n\t\treturn rev ? v->val ^ 1 : v->val;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, l, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\t/*\n\tstatic bool a[MAXN * 2 + 1];\n\n\tstatic void update(const int l, const int r, const TagType t) {\n\t\tif (l > r) return;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (t == Zero) a[i] = false;\n\t\t\telse if (t == One) a[i] = true;\n\t\t\telse if (t == Reverse) a[i] ^= 1;\n\t\t}\n\t}\n\n\tstatic bool query(const int pos) { return a[pos]; }\n\n\tstatic SegmentTree *build(const int l, const int r) { return NULL; }\n\t*/\n} *segment;\n\n// bool SegmentTree::a[MAXN * 2 + 1];\n\ninline void parse(char *s, int &l, int &r) {\n\tchar ch;\n\tbool fl = false;\n\tch = *s++;\n\tif (ch == '(') fl = true;\n\tl = 0;\n\twhile ((ch = *s++) != ',') l = l * 10 + ch - '0';\n\tl *= 2;\n\tif (fl) l++;\n\tr = 0;\n\twhile ((ch = *s++), (ch >= '0' && ch <= '9')) r = r * 10 + ch - '0';\n\tr *= 2;\n\tif (ch == ')') r--;\n}\n\ninline void print() {\n\tint l = -1;\n\tbool flag = false;\n\tfor (int i = 0; i <= MAXN * 2; i++) {\n\t\tbool val = segment->query(i);\n\t\tif (l == -1 && val) {\n\t\t\tl = i;\n\t\t} else if (l != -1 && !val) {\n\t\t\tprintf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')');\n\t\t\tflag = true;\n\t\t\tl = -1;\n\t\t}\n\t}\n\tif (l != -1) printf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true;\n\tif (!flag) printf(\"empty set\");\n\tputchar('\\n');\n}\n\nint main() {\n\tsegment = SegmentTree::build(0, MAXN * 2);\n\tchar cmd[2], s[100];\n\twhile (~scanf(\"%s %s\", cmd, s)) {\n\t\tint l, r;\n\t\tparse(s, l, r);\n\t\t// printf(\"read: [%d, %d]\\n\", l, r);\n\n\t\tif (cmd[0] == 'U') {\n\t\t\tsegment->update(l, r, SegmentTree::One);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'D') {\n\t\t\tsegment->update(l, r, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tsegment->update(0, MAXN * 2, SegmentTree::Reverse);\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'S') {\n\t\t\tsegment->update(l, r, SegmentTree::Reverse);\n\t\t}\n\n\t\t// print();\n\t}\n\n\tprint();\n\n\treturn 0;\n}\n```","slug":"sdoi2008-interval","published":1,"updated":"2016-09-02T13:38:18.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhy300do0jxla3uosqkh"},{"title":"SDOI2008 - Link-Cut Tree","date":"2016-03-15T12:06:34.000Z","_content":"\n $ u $  $ v $  `Connect u v` $ u $  $ v $  `Destroy u v` `Query u v` $ u $  $ v $ \n\n<!-- more -->\n\n### \n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### \n Link-Cut Tree \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/sdoi2008-cave.md","raw":"title: SDOI2008 - Link-Cut Tree \ndate: 2016-03-15 20:06:34\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - CodeVS\n  - \n  - \n  - \n  - Link-Cut Tree\npermalink: sdoi2008-cave\n---\n\n $ u $  $ v $  `Connect u v` $ u $  $ v $  `Destroy u v` `Query u v` $ u $  $ v $ \n\n<!-- more -->\n\n### \n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### \n Link-Cut Tree \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"sdoi2008-cave","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhy500du0jxldjgae5f4"},{"title":"SCOI2015 - set","date":"2016-03-25T00:53:27.000Z","_content":"\n $ A $  $ C $ $ B $\n\n1. $ B_0 = A_0 $\n2.  $ C_x = + $ $ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $\n3.  $ C_x = * $ $ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $\n\n $ A $  $ C $  $ B $  $ B $  $ B_0 $  $ B_0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### \n B $ B_0 = A_0 $ $ B_i $  $ B_{i + 1} $\n\n\n\n `set`  \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-password.md","raw":"title: SCOI2015 - set\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - set\n  - \npermalink: scoi2015-password\ndate: 2016-03-25 08:53:27\n---\n\n $ A $  $ C $ $ B $\n\n1. $ B_0 = A_0 $\n2.  $ C_x = + $ $ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $\n3.  $ C_x = * $ $ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $\n\n $ A $  $ C $  $ B $  $ B $  $ B_0 $  $ B_0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### \n B $ B_0 = A_0 $ $ B_i $  $ B_{i + 1} $\n\n\n\n `set`  \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-password","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhyf00e50jxl2rkktiu2"},{"title":"SCOI2015 -  + Link-Cut Tree","date":"2016-03-22T10:09:12.000Z","_content":"\n $ n $  1  $ n - 1 $  1 \n\n\n1.  $ T $ \n2.  $ X $  $ Y $ \n\n 0 1  0 2  1\n\n $ C $ $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### \n Link-Cut Tree \n\n 30 \n\n30 ~ 60  $ C = 0 $ 1 1 \n\n 40  $ C + 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-message.md","raw":"title: SCOI2015 -  + Link-Cut Tree\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - Link-Cut Tree\n  - \n  - \npermalink: scoi2015-message\ndate: 2016-03-22 18:09:12\n---\n\n $ n $  1  $ n - 1 $  1 \n\n\n1.  $ T $ \n2.  $ X $  $ Y $ \n\n 0 1  0 2  1\n\n $ C $ $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### \n Link-Cut Tree \n\n 30 \n\n30 ~ 60  $ C = 0 $ 1 1 \n\n 40  $ C + 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-message","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhyk00ef0jxlfi3hum08"},{"title":"SCOI2015 - ","date":"2016-03-22T09:56:34.000Z","_content":"\n $ N * M $$ N \\leq M $ $ A $ $ N $ $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### \n $ K $  $ N - K + 1 $\n\n $ K $  $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-matrix.md","raw":"title: SCOI2015 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \n  - \n  - Dinic\npermalink: scoi2015-matrix\ndate: 2016-03-22 17:56:34\n---\n\n $ N * M $$ N \\leq M $ $ A $ $ N $ $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### \n $ K $  $ N - K + 1 $\n\n $ K $  $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-matrix","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhyt00eo0jxlffxopl90"},{"title":"SCOI2015 -  DP","date":"2016-03-23T15:16:05.000Z","_content":"\n $ n $  $ A_i $ $ B_i $ $ 1 $  $ 1 $  $ V $  $ U $  $ V $  $ D_{u, v} $ $ A_v $\n\n<!-- more -->\n\n### \n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### \n $ f_{x, i} $  $ x $  $ i $ \n\n\n $ x $ \n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n DP$ g_{x, i} $  $ x $  $ i $ \n\n $ x $ \n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n\n$ i = 0 $  $ {\\rm dist} $  $ 0 $  $ 0 $\n\n $ g_{1, 0} $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-light.md","raw":"title: SCOI2015 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - DP\n  -  DP\npermalink: scoi2015-light\ndate: 2016-03-23 23:16:05\n---\n\n $ n $  $ A_i $ $ B_i $ $ 1 $  $ 1 $  $ V $  $ U $  $ V $  $ D_{u, v} $ $ A_v $\n\n<!-- more -->\n\n### \n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### \n $ f_{x, i} $  $ x $  $ i $ \n\n\n $ x $ \n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n DP$ g_{x, i} $  $ x $  $ i $ \n\n $ x $ \n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n\n$ i = 0 $  $ {\\rm dist} $  $ 0 $  $ 0 $\n\n $ g_{1, 0} $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-light","published":1,"updated":"2016-10-24T23:31:27.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhz100ey0jxlvk5y4o9j"},{"title":"SCOI2015 -  + ","date":"2016-03-22T10:25:14.000Z","_content":"\nA  $ M $  $ 1 $  $ M $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### \n\n\n\n\n40  $ O(n ^ 2) $\n\n70  $ O(n \\log n) $ `std::upper_bound` -1 \n\n100  $ O(n \\log n) $  $ next_{i, j} $  $ i $  $ 2 ^ j $  $ O(\\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-flag.md","raw":"title: SCOI2015 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \npermalink: scoi2015-flag\ndate: 2016-03-22 18:25:14\n---\n\nA  $ M $  $ 1 $  $ M $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### \n\n\n\n\n40  $ O(n ^ 2) $\n\n70  $ O(n \\log n) $ `std::upper_bound` -1 \n\n100  $ O(n \\log n) $  $ next_{i, j} $  $ i $  $ 2 ^ j $  $ O(\\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-flag","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhz600f60jxl1iyckm0a"},{"title":"SCOI2012 - AC ","date":"2016-09-29T13:26:00.000Z","_content":"\n $ N $  $ M $ \n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 2754](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n\n### \n AC \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","source":"_posts/scoi2012-name.md","raw":"title: SCOI2012 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - AC \npermalink: scoi2012-name\ndate: 2016-09-29 21:26:00\n---\n\n $ N $  $ M $ \n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 2754](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n\n### \n AC \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","slug":"scoi2012-name","published":1,"updated":"2016-09-29T13:28:38.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhza00fe0jxljp60eehn"},{"title":"SCOI2011 -  + ","date":"2016-03-04T13:32:23.000Z","_content":"\n $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### \n\n\n Tarjan  Tarjan\n\n 0 1 1\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2011-candy.md","raw":"title: SCOI2011 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - Tarjan\n  - \n  - \n  - \npermalink: scoi2011-candy\ndate: 2016-03-04 21:32:23\n---\n\n $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### \n\n\n Tarjan  Tarjan\n\n 0 1 1\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","slug":"scoi2011-candy","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhzg00fk0jxlepycwmee"},{"title":"SCOI2010 - ","date":"2016-03-07T01:43:18.000Z","_content":"\n $ [1, 10000] $   BOSS  $ 1 $  BOSS  $ 1 $  BOSS $ 2 $  BOSS $ 3 $  BOSS   BOSS \n\n<!-- more -->\n\n### \n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### \n $ N  1000000 $ $ O(n) $  $ O(n) $  \n\n\n\n\n\n $ 1 $  $ 1 $  $ X $  $ \\{X, Y\\} $  $ X $ $ Y $ $ Y < X $\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2010-game.md","raw":"title: SCOI2010 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \n  - \npermalink: scoi2010-game\ndate: 2016-03-07 09:43:18\n---\n\n $ [1, 10000] $   BOSS  $ 1 $  BOSS  $ 1 $  BOSS $ 2 $  BOSS $ 3 $  BOSS   BOSS \n\n<!-- more -->\n\n### \n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### \n $ N  1000000 $ $ O(n) $  $ O(n) $  \n\n\n\n\n\n $ 1 $  $ 1 $  $ X $  $ \\{X, Y\\} $  $ X $ $ Y $ $ Y < X $\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","slug":"scoi2010-game","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhzl00fu0jxl20qrqjn2"},{"title":"SCOI2009windy  -  DP","date":"2016-05-12T09:25:00.000Z","_content":"\nwindy  windy  $ 2 $  windy \n\nwindy  $ A $  $ B $  $ A $  $ B $ windy \n\n<!-- more -->\n\n### \n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### \n DP\n\n$$ f[n][last][notZero][limited] $$\n\n $ n $  $ n $  $ last $\n\nPS\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","source":"_posts/scoi2009-windy.md","raw":"title: SCOI2009windy  -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  -  DP\n  - DP\npermalink: scoi2009-windy\ndate: 2016-05-12 17:25:00\n---\n\nwindy  windy  $ 2 $  windy \n\nwindy  $ A $  $ B $  $ A $  $ B $ windy \n\n<!-- more -->\n\n### \n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### \n DP\n\n$$ f[n][last][notZero][limited] $$\n\n $ n $  $ n $  $ last $\n\nPS\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","slug":"scoi2009-windy","published":1,"updated":"2016-10-24T23:30:33.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jhzx00g40jxlwokto70o"},{"title":"SCOI2009 -  DP","date":"2016-07-11T14:59:00.000Z","_content":"\nwindy  $ N $  $ M $   windy  windy  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1296](http://www.lydsy.com/JudgeOnline/problem.php?id=1296)\n\n### \n $ f(j, k) $  $ j $  $ k $ \n\n $ w(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXT = 2500;\n\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\n\tstatic int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tstatic char s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\tint cnt[2] = { 0, 0 };\n\t\t\t\tfor (int l = j - 1; l >= k - 1; l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tf[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1]));\n\t\t\t\t\tw[i][k] = std::max(w[i][k], f[j][k]);\n\t\t\t\t}\n\t\t\t\t// printf(\"f[%d][%d][%d] = %d\\n\", i, j, k, f[j][k]);\n\t\t\t}\n\t\t}\n\n\t\t// for (int j = 1; j <= m; j++) printf(\"w[%d][%d] = %d\\n\", i, j, w[i][j]);\n\t}\n\n\tstatic int g[MAXT + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = t; j >= 0; j--) {\n\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\tif (k <= j) g[j] = std::max(g[j], g[j - k] + w[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[t]);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2009-paint.md","raw":"title: SCOI2009 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - DP\n  -  DP\npermalink: scoi2009-paint\ndate: 2016-07-11 22:59:00\n---\n\nwindy  $ N $  $ M $   windy  windy  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1296](http://www.lydsy.com/JudgeOnline/problem.php?id=1296)\n\n### \n $ f(j, k) $  $ j $  $ k $ \n\n $ w(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXT = 2500;\n\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\n\tstatic int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tstatic char s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\tint cnt[2] = { 0, 0 };\n\t\t\t\tfor (int l = j - 1; l >= k - 1; l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tf[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1]));\n\t\t\t\t\tw[i][k] = std::max(w[i][k], f[j][k]);\n\t\t\t\t}\n\t\t\t\t// printf(\"f[%d][%d][%d] = %d\\n\", i, j, k, f[j][k]);\n\t\t\t}\n\t\t}\n\n\t\t// for (int j = 1; j <= m; j++) printf(\"w[%d][%d] = %d\\n\", i, j, w[i][j]);\n\t}\n\n\tstatic int g[MAXT + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = t; j >= 0; j--) {\n\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\tif (k <= j) g[j] = std::max(g[j], g[j - k] + w[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[t]);\n\n\treturn 0;\n}\n```\n","slug":"scoi2009-paint","published":1,"updated":"2016-10-24T23:30:41.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji0100ga0jxl1rgx0bca"},{"title":"SCOI2009 -  +  DP","date":"2016-11-13T00:24:00.000Z","_content":"\nwindy  $ 1 $  $ N $  $ N $  $ 1 $  $ N $  windy  $ 1, 2, 3, \\ldots, N $  $ 1, 2, 3, \\ldots, N $\n\n$ 1, 2, 3, 4, 5, 6 $ \n\n$$\n\\begin{cases}\n1 \\rightarrow 2 \\\\\n2 \\rightarrow 3 \\\\\n3 \\rightarrow 1 \\\\\n4 \\rightarrow 5 \\\\\n5 \\rightarrow 4 \\\\\n6 \\rightarrow 6\n\\end{cases}\n$$\n\nwindy \n\n$$\n\\begin{gather}\n1, 2, 3, 4, 5, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 5, 4, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 4, 5, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 5, 4, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 4, 5, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 5, 4, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 4, 5, 6\n\\end{gather}\n$$\n\n $ 1 $  $ N $  $ 7 $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025)\n\n### \n\n\n$$ \\{ x_1, x_2, \\ldots, x_m \\} $$\n\n $ x_k $  $ p $ $ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) $  $ p $  $ x_k $  $ x_i $ \n\n $ x_i $  $ x_i = 1 $ \n\n$$\n\\begin{cases}\nx_1 = p_1 ^ {k_1} \\\\\nx_2 = p_2 ^ {k_2} \\\\\n\\cdots \\\\\nx_m = p_m ^ {k_m}\n\\end{cases}\n$$\n\n$ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) = x_1 \\times x_2 \\times \\ldots \\times x_m $ $ \\{ x_1. x_2, \\ldots, x_m \\} $  $ x_1 + x_2 + \\ldots + x_m = n $ $ 1 $  $ x_1 + x_2 + \\ldots + x_m \\leq n $ \n\n $ p_i $ $ p_i ^ {k_i} $ $ \\leq n $   $ i $  $ p_i ^ 1, p_i ^ 2, \\ldots p_i ^ {k_i} $$ p_i ^ {k_i} \\leq n $ $ n $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\n\nint primes[MAXN], isNotPrime[MAXN + 1], cnt;\n\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * primes[j] <= MAXN; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n\t// for (int i = 0; i < cnt; i++) printf(\"%d\\n\", primes[i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tgetPrimes();\n\n\tstatic long long f[MAXN + 1][MAXN + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int k = 0; k <= n; k++) f[i][k] = f[i - 1][k];\n\t\tfor (int p = primes[i]; p <= n; p *= primes[i]) {\n\t\t\tfor (int k = p; k <= n; k++) {\n\t\t\t\tf[i][k] += f[i - 1][k - p];\n\t\t\t}\n\t\t}\n\t\t// for (int k = 0; k <= n; k++) printf(\"f[%d][%d] = %d\\n\", i, k, f[i][k]);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) ans += f[cnt][i];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2009-game.md","raw":"title: SCOI2009 -  +  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  -  DP\n  - DP\npermalink: scoi2009-game\ndate: 2016-11-13 08:24:00\n---\n\nwindy  $ 1 $  $ N $  $ N $  $ 1 $  $ N $  windy  $ 1, 2, 3, \\ldots, N $  $ 1, 2, 3, \\ldots, N $\n\n$ 1, 2, 3, 4, 5, 6 $ \n\n$$\n\\begin{cases}\n1 \\rightarrow 2 \\\\\n2 \\rightarrow 3 \\\\\n3 \\rightarrow 1 \\\\\n4 \\rightarrow 5 \\\\\n5 \\rightarrow 4 \\\\\n6 \\rightarrow 6\n\\end{cases}\n$$\n\nwindy \n\n$$\n\\begin{gather}\n1, 2, 3, 4, 5, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 5, 4, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 4, 5, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 5, 4, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 4, 5, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 5, 4, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 4, 5, 6\n\\end{gather}\n$$\n\n $ 1 $  $ N $  $ 7 $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025)\n\n### \n\n\n$$ \\{ x_1, x_2, \\ldots, x_m \\} $$\n\n $ x_k $  $ p $ $ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) $  $ p $  $ x_k $  $ x_i $ \n\n $ x_i $  $ x_i = 1 $ \n\n$$\n\\begin{cases}\nx_1 = p_1 ^ {k_1} \\\\\nx_2 = p_2 ^ {k_2} \\\\\n\\cdots \\\\\nx_m = p_m ^ {k_m}\n\\end{cases}\n$$\n\n$ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) = x_1 \\times x_2 \\times \\ldots \\times x_m $ $ \\{ x_1. x_2, \\ldots, x_m \\} $  $ x_1 + x_2 + \\ldots + x_m = n $ $ 1 $  $ x_1 + x_2 + \\ldots + x_m \\leq n $ \n\n $ p_i $ $ p_i ^ {k_i} $ $ \\leq n $   $ i $  $ p_i ^ 1, p_i ^ 2, \\ldots p_i ^ {k_i} $$ p_i ^ {k_i} \\leq n $ $ n $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\n\nint primes[MAXN], isNotPrime[MAXN + 1], cnt;\n\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * primes[j] <= MAXN; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n\t// for (int i = 0; i < cnt; i++) printf(\"%d\\n\", primes[i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tgetPrimes();\n\n\tstatic long long f[MAXN + 1][MAXN + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int k = 0; k <= n; k++) f[i][k] = f[i - 1][k];\n\t\tfor (int p = primes[i]; p <= n; p *= primes[i]) {\n\t\t\tfor (int k = p; k <= n; k++) {\n\t\t\t\tf[i][k] += f[i - 1][k - p];\n\t\t\t}\n\t\t}\n\t\t// for (int k = 0; k <= n; k++) printf(\"f[%d][%d] = %d\\n\", i, k, f[i][k]);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) ans += f[cnt][i];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"scoi2009-game","published":1,"updated":"2016-11-13T00:47:58.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji0e00gg0jxljymxdo1t"},{"title":"SCOI2009 - ","date":"2016-11-12T13:17:00.000Z","_content":"\nwindy  $ X $  $ Y $  windy $ N $ windy  $ N $ windy  $ N - 1 $  $ N $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024)\n\n### \n**** $ k \\over n $ $ k $ \n\nDFS \n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 10;\n\ndouble dfs(const int n, const double x, const double y) {\n\tif (n == 1) {\n\t\treturn std::max(x, y) / std::min(x, y);\n\t}\n\n\tdouble res1 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y)));\n\t}\n\n\tdouble res2 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n)));\n\t}\n\n\treturn std::min(res1, res2);\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(n, x, y));\n\treturn 0;\n}\n```","source":"_posts/scoi2009-cake.md","raw":"title: SCOI2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - DFS\npermalink: scoi2009-cake\ndate: 2016-11-12 21:17:00\n---\n\nwindy  $ X $  $ Y $  windy $ N $ windy  $ N $ windy  $ N - 1 $  $ N $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024)\n\n### \n**** $ k \\over n $ $ k $ \n\nDFS \n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 10;\n\ndouble dfs(const int n, const double x, const double y) {\n\tif (n == 1) {\n\t\treturn std::max(x, y) / std::min(x, y);\n\t}\n\n\tdouble res1 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y)));\n\t}\n\n\tdouble res2 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n)));\n\t}\n\n\treturn std::min(res1, res2);\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(n, x, y));\n\treturn 0;\n}\n```","slug":"scoi2009-cake","published":1,"updated":"2016-11-12T13:17:41.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji0p00gp0jxl2iwuxwuu"},{"title":"SCOI2007 - ","date":"2016-03-09T01:52:35.000Z","_content":"\n $ N $  $ M $  $ M $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### \n****\n\n $ i $  $ j $  $ t_{i, j} $ $ i $  $ v_i $ $ i $  $ k $  $ k $  $ v_{j, k} $$ k {\\in} [1, n] $\n\n 1 0 $ v_i $  $ v_{j, k} $  1 $ t_{i, j} * k $ $ v_{j, k} $  1 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### \n $ n $$ m $  \n\n EK  \n\nhehe\n","source":"_posts/scoi2007-repair.md","raw":"title: SCOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - SCOI\n  - \n  - \n  - \n  - Edmonds-Karp\npermalink: scoi2007-repair\ndate: 2016-03-09 09:52:35\n---\n\n $ N $  $ M $  $ M $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### \n****\n\n $ i $  $ j $  $ t_{i, j} $ $ i $  $ v_i $ $ i $  $ k $  $ k $  $ v_{j, k} $$ k {\\in} [1, n] $\n\n 1 0 $ v_i $  $ v_{j, k} $  1 $ t_{i, j} * k $ $ v_{j, k} $  1 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### \n $ n $$ m $  \n\n EK  \n\nhehe\n","slug":"scoi2007-repair","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji0w00gx0jxlg21ghfiw"},{"title":"SCOI2007 - ","date":"2016-09-03T13:47:00.000Z","_content":"\n $ r $  $ c $ \n\n $ 1 $ $ d $**** $ d $ \n\n $ 1 $ $ 1 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1066](http://www.lydsy.com/JudgeOnline/problem.php?id=1066)\n\n### \n $ d $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXD = 4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"addEdge(%d, %d, %d)\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j, const int l) {\n\treturn l * n * m + i * m + j + 1;\n}\n\nint main() {\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &d);\n\n\t/*\n\tprintf(\"%d -> %d\\n\", id(2, 2, 1), id(2, 2, 0));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 0), id(2, 2, 2));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 2), id(2, 1, 1));\n\tprintf(\"%d -> %d\\n\", id(2, 1, 1), id(3, 1, 0));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 0), id(3, 1, 2));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 2), id(3, 0, 1));\n\t*/\n\t/*\n\tfor (int h = 0; h <= d; h++) for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%d\\n\", id(i, j, h));\n\tprintf(\"t = %d\\n\", n * m * (d + 1) + 1);\n\treturn 0;\n\t*/\n\n\tconst int s = 0, t = n * m * 2 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\taddEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0');\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\tif (abs(i - k) + abs(j - l) <= d) {\n\t\t\t\t\t\taddEdge(id(i, j, 1), id(k, l, 0), INT_MAX);\n\t\t\t\t\t\taddEdge(id(k, l, 1), id(i, j, 0), INT_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < d || i > n - d - 1 || j < d || j > m - d - 1) addEdge(id(i, j, 1), t, INT_MAX);\n\t\t}\n\t}\n\n\tint ans = dinic(s, t, n * m * 2 + 2);\n\tprintf(\"%d\\n\", cnt - ans);\n\n\treturn 0;\n}\n```","source":"_posts/scoi2007-lizard.md","raw":"title: SCOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - Dinic\npermalink: scoi2007-lizard\ndate: 2016-09-03 21:47:00\n---\n\n $ r $  $ c $ \n\n $ 1 $ $ d $**** $ d $ \n\n $ 1 $ $ 1 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1066](http://www.lydsy.com/JudgeOnline/problem.php?id=1066)\n\n### \n $ d $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXD = 4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"addEdge(%d, %d, %d)\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j, const int l) {\n\treturn l * n * m + i * m + j + 1;\n}\n\nint main() {\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &d);\n\n\t/*\n\tprintf(\"%d -> %d\\n\", id(2, 2, 1), id(2, 2, 0));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 0), id(2, 2, 2));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 2), id(2, 1, 1));\n\tprintf(\"%d -> %d\\n\", id(2, 1, 1), id(3, 1, 0));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 0), id(3, 1, 2));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 2), id(3, 0, 1));\n\t*/\n\t/*\n\tfor (int h = 0; h <= d; h++) for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%d\\n\", id(i, j, h));\n\tprintf(\"t = %d\\n\", n * m * (d + 1) + 1);\n\treturn 0;\n\t*/\n\n\tconst int s = 0, t = n * m * 2 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\taddEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0');\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\tif (abs(i - k) + abs(j - l) <= d) {\n\t\t\t\t\t\taddEdge(id(i, j, 1), id(k, l, 0), INT_MAX);\n\t\t\t\t\t\taddEdge(id(k, l, 1), id(i, j, 0), INT_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < d || i > n - d - 1 || j < d || j > m - d - 1) addEdge(id(i, j, 1), t, INT_MAX);\n\t\t}\n\t}\n\n\tint ans = dinic(s, t, n * m * 2 + 2);\n\tprintf(\"%d\\n\", cnt - ans);\n\n\treturn 0;\n}\n```","slug":"scoi2007-lizard","published":1,"updated":"2016-09-03T13:51:23.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji1300h60jxl3ql6zfy7"},{"title":"SCOI2003 -  DP","date":"2016-07-06T03:54:00.000Z","_content":"\n\n\n1. \n2. $ X(S) $  $ X(X > 1) $  $ S $ \n3.  $ A $  $ A $ $ B $  $ B $  $ AB $  $ AB $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1090](http://www.lydsy.com/JudgeOnline/problem.php?id=1090)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n\n\n1.  $ r - l + 1 $\n2. \n3. \n4. \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nint n;\nchar s[MAXN + 1];\n\ninline int numberLength(int x) {\n\tint res = 0;\n\tdo res++; while (x /= 10);\n\treturn res;\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1;\n\telse if (l > r) return ans = 0;\n\n\tans = r - l + 1;\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(l, l + i - 1);\n\t\tint pos = l + i, cnt = 1;\n\t\twhile (pos + i - 1 <= r && strncmp(s + l, s + pos, i) == 0) pos += i, cnt++;\n\t\tans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(r - i + 1, r);\n\t\tint pos = r - i - i + 1, cnt = 1;\n\t\twhile (pos >= l && strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++;\n\t\tans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1 - 1; i++) {\n\t\tans = std::min(ans, dp(l, i) + dp(i + 1, r));\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tprintf(\"%d\\n\", dp(0, n - 1));\n\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/scoi2003-fold.md","raw":"title: SCOI2003 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - DP\n  -  DP\npermalink: scoi2003-fold\ndate: 2016-07-06 11:54:00\n---\n\n\n\n1. \n2. $ X(S) $  $ X(X > 1) $  $ S $ \n3.  $ A $  $ A $ $ B $  $ B $  $ AB $  $ AB $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1090](http://www.lydsy.com/JudgeOnline/problem.php?id=1090)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n\n\n1.  $ r - l + 1 $\n2. \n3. \n4. \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nint n;\nchar s[MAXN + 1];\n\ninline int numberLength(int x) {\n\tint res = 0;\n\tdo res++; while (x /= 10);\n\treturn res;\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1;\n\telse if (l > r) return ans = 0;\n\n\tans = r - l + 1;\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(l, l + i - 1);\n\t\tint pos = l + i, cnt = 1;\n\t\twhile (pos + i - 1 <= r && strncmp(s + l, s + pos, i) == 0) pos += i, cnt++;\n\t\tans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(r - i + 1, r);\n\t\tint pos = r - i - i + 1, cnt = 1;\n\t\twhile (pos >= l && strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++;\n\t\tans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1 - 1; i++) {\n\t\tans = std::min(ans, dp(l, i) + dp(i + 1, r));\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tprintf(\"%d\\n\", dp(0, n - 1));\n\n\treturn 0;\n}\n```\n\n\n\n","slug":"scoi2003-fold","published":1,"updated":"2016-10-24T23:31:18.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji1b00hc0jxlarebyb5m"},{"title":"POJ 3461Oulipo - KMP","date":"2016-04-09T13:36:23.000Z","_content":"\n\n\n<!-- more -->\n\n### \nKMP  \n\n `next`  `char`  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/poj-3461.md","raw":"title: POJ 3461Oulipo - KMP\ncategories: OI\ntags: \n  - POJ\n  - KMP\n  - \n  - \npermalink: poj-3461\ndate: 2016-04-09 21:36:23\n---\n\n\n\n<!-- more -->\n\n### \nKMP  \n\n `next`  `char`  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","slug":"poj-3461","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji1e00hi0jxl0rs675r1"},{"title":"POJ 2728Desert King - 01 ","date":"2016-03-11T01:33:14.000Z","_content":"\n $ N $  $ (x, y) $  $ z $ $ N $ \n\n<!-- more -->\n\n### \n[POJ 2728](http://poj.org/problem?id=2728)\n\n### \n01   Orz\n\nPS WA  TLE G++  VC++  AC  \n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-2728.md","raw":"title: POJ 2728Desert King - 01 \ncategories: OI\ntags: \n  - POJ\n  - Prim\n  - \n  - \n  - \n  - \npermalink: poj-2728\ndate: 2016-03-11 09:33:14\n---\n\n $ N $  $ (x, y) $  $ z $ $ N $ \n\n<!-- more -->\n\n### \n[POJ 2728](http://poj.org/problem?id=2728)\n\n### \n01   Orz\n\nPS WA  TLE G++  VC++  AC  \n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","slug":"poj-2728","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji1n00hq0jxlsglddarh"},{"title":"POJ 1737Connected Graph -  +  + ","date":"2016-03-14T04:12:45.000Z","_content":"\n $ N $$ N \\leq 50 $\n\n<!-- more -->\n\n### \n[POJ 1737](http://poj.org/problem?id=1737)\n\n### \n N  N **** $ \\frac{N(N - 1)}{2} $  $ 2 ^ {\\frac{N(N - 1)}{2}} $ \n\n $ N $  $ v $ $ K $$ 1 \\leq K \\leq N - 1 $**** $ v $  $ K - 1 $  $ \\binom{N - 1}{K - 1} $**** $ N - K $ \n\n $ n $  $ f(n) $ $ g(n) $ $ h(n) $ $ f(n) $ \n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-1737.md","raw":"title: POJ 1737Connected Graph -  +  + \ncategories: OI\ntags: \n  - POJ\n  - \n  - \n  - \n  - \n  - \npermalink: poj-1737\ndate: 2016-03-14 12:12:45\n---\n\n $ N $$ N \\leq 50 $\n\n<!-- more -->\n\n### \n[POJ 1737](http://poj.org/problem?id=1737)\n\n### \n N  N **** $ \\frac{N(N - 1)}{2} $  $ 2 ^ {\\frac{N(N - 1)}{2}} $ \n\n $ N $  $ v $ $ K $$ 1 \\leq K \\leq N - 1 $**** $ v $  $ K - 1 $  $ \\binom{N - 1}{K - 1} $**** $ N - K $ \n\n $ n $  $ f(n) $ $ g(n) $ $ h(n) $ $ f(n) $ \n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"poj-1737","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji1w00i10jxlkv0xl6av"},{"title":"POI2008BLO - ","date":"2016-09-08T10:37:00.000Z","_content":"\nByteotia  $ n $  towns$ m $  roads road  towns road towns \n\n******** $ (u, v) $ \n\n<!-- more -->\n\n### \n[BZOJ 1123](http://www.lydsy.com/JudgeOnline/problem.php?id=1123)\n\n### \n $ 2 \\times (n - 1) $\n\n\n\nDFS  DFS  $ u $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $  $ v $  $ u $ \n\n $ x_1, x_2, \\ldots, x_k $$ s = \\sum\\limits_{i = 1} ^ k x_i $\n\n$$\n\\begin{aligned}\n& x_1x_2 + x_1x_3 + \\ldots + x_1x_k + \\ldots + x_kx_{k - 1} \\\\\n= & x_1(x_2 + x_3 + \\ldots + x_k) + x_2(x_1 + x_3 + \\ldots + x_k) + \\ldots + x_k(x_1 + x_2 + \\ldots + x_{k - 1}) \\\\\n= & \\sum\\limits_{i = 1} ^ k x_i \\times (s - x_i)\n\\end{aligned}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low, size;\n\tlong long ans;\n\tbool flag, pushed, v;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline long long calc(const std::vector<long long> &vec) {\n\tlong long s = 0, ans = 0;\n\tfor (size_t i = 0; i < vec.size(); i++) s += vec[i];\n\tfor (size_t i = 0; i < vec.size(); i++) ans += (s - vec[i]) * vec[i];\n\treturn ans;\n}\n\ninline void tarjan() {\n\tint ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::stack<Node *> s;\n\t\tN[i].pushed = true;\n\t\ts.push(&N[i]);\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\t\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->size = 1;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tstd::vector<long long> vec;\n\t\t\t\tif (v != &N[i]) {\n\t\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\t\tif (e->t->p != v) continue;\n\t\t\t\t\t\tif (e->t->low >= v->dfn) {\n\t\t\t\t\t\t\tv->flag = true;\n\t\t\t\t\t\t\tvec.push_back(e->t->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->size += e->t->size;\n\t\t\t\t\t}\n\t\t\t\t\tint t = n - 1;\n\t\t\t\t\tfor (size_t i = 0; i < vec.size(); i++) t -= vec[i];\n\t\t\t\t\tvec.push_back(t);\n\t\t\t\t\tif (v->flag) v->ans = calc(vec);\n\t\t\t\t\t// if (v->flag) printf(\"tarjan(): found %lu\\n\", v - N + 1);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<long long> vec;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) vec.push_back(e->t->size);\n\t\tif (vec.size() >= 2) N[i].ans = calc(vec), N[i].flag = true;\n\t\t// if (N[i].flag) printf(\"tarjan(): found %d\\n\", i + 1);\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\ttarjan();\n\n\tfor (int i = 0; i < n; i++) printf(\"%lld\\n\", N[i].ans + (n - 1) * 2);\n\n\treturn 0;\n}\n```","source":"_posts/poi2008-blo.md","raw":"title: POI2008BLO - \ncategories: OI\ntags: \n  - BZOJ\n  - POI\n  - Tarjan\n  - \n  - \npermalink: poi2008-blo\ndate: 2016-09-08 18:37:00\n---\n\nByteotia  $ n $  towns$ m $  roads road  towns road towns \n\n******** $ (u, v) $ \n\n<!-- more -->\n\n### \n[BZOJ 1123](http://www.lydsy.com/JudgeOnline/problem.php?id=1123)\n\n### \n $ 2 \\times (n - 1) $\n\n\n\nDFS  DFS  $ u $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $  $ v $  $ u $ \n\n $ x_1, x_2, \\ldots, x_k $$ s = \\sum\\limits_{i = 1} ^ k x_i $\n\n$$\n\\begin{aligned}\n& x_1x_2 + x_1x_3 + \\ldots + x_1x_k + \\ldots + x_kx_{k - 1} \\\\\n= & x_1(x_2 + x_3 + \\ldots + x_k) + x_2(x_1 + x_3 + \\ldots + x_k) + \\ldots + x_k(x_1 + x_2 + \\ldots + x_{k - 1}) \\\\\n= & \\sum\\limits_{i = 1} ^ k x_i \\times (s - x_i)\n\\end{aligned}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low, size;\n\tlong long ans;\n\tbool flag, pushed, v;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline long long calc(const std::vector<long long> &vec) {\n\tlong long s = 0, ans = 0;\n\tfor (size_t i = 0; i < vec.size(); i++) s += vec[i];\n\tfor (size_t i = 0; i < vec.size(); i++) ans += (s - vec[i]) * vec[i];\n\treturn ans;\n}\n\ninline void tarjan() {\n\tint ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::stack<Node *> s;\n\t\tN[i].pushed = true;\n\t\ts.push(&N[i]);\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\t\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->size = 1;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tstd::vector<long long> vec;\n\t\t\t\tif (v != &N[i]) {\n\t\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\t\tif (e->t->p != v) continue;\n\t\t\t\t\t\tif (e->t->low >= v->dfn) {\n\t\t\t\t\t\t\tv->flag = true;\n\t\t\t\t\t\t\tvec.push_back(e->t->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->size += e->t->size;\n\t\t\t\t\t}\n\t\t\t\t\tint t = n - 1;\n\t\t\t\t\tfor (size_t i = 0; i < vec.size(); i++) t -= vec[i];\n\t\t\t\t\tvec.push_back(t);\n\t\t\t\t\tif (v->flag) v->ans = calc(vec);\n\t\t\t\t\t// if (v->flag) printf(\"tarjan(): found %lu\\n\", v - N + 1);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<long long> vec;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) vec.push_back(e->t->size);\n\t\tif (vec.size() >= 2) N[i].ans = calc(vec), N[i].flag = true;\n\t\t// if (N[i].flag) printf(\"tarjan(): found %d\\n\", i + 1);\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\ttarjan();\n\n\tfor (int i = 0; i < n; i++) printf(\"%lld\\n\", N[i].ans + (n - 1) * 2);\n\n\treturn 0;\n}\n```","slug":"poi2008-blo","published":1,"updated":"2016-09-08T10:58:08.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji2700i90jxl1qh44l65"},{"title":"POI2006Szk-Schools - ","date":"2016-06-22T10:20:00.000Z","_content":"\n $ n $  $ a_i $ $ [1,\\ n] $  $ n $ \n\n1. $ a_i $  $ [l_i,\\ r_i] $ \n2. $ a_i $  $ x $  $ k \\times | a_i - x | $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1520](http://www.lydsy.com/JudgeOnline/problem.php?id=1520)\n\n### \n $ i $  $ [l_i,\\ r_i] $  $ 1 $\n\n $ 1 $ $ 1 $\n\n $ n $ \n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint d, f;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint m, l, r, k;\n\t\tscanf(\"%d %d %d %d\", &m, &l, &r, &k);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\n\t\tfor (int j = l; j <= r; j++) {\n\t\t\taddEdge(i, n + j, 1, k * abs(j - m));\n\t\t}\n\t}\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tif (f != n) puts(\"NIE\");\n\telse printf(\"%d\\n\", c);\n\n\treturn 0;\n}\n```\n","source":"_posts/poi2006-szk.md","raw":"title: POI2006Szk-Schools - \ndate: 2016-06-22 18:20:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - \n  - Edmonds-Karp\npermalink: poi2006-szk\n---\n\n $ n $  $ a_i $ $ [1,\\ n] $  $ n $ \n\n1. $ a_i $  $ [l_i,\\ r_i] $ \n2. $ a_i $  $ x $  $ k \\times | a_i - x | $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1520](http://www.lydsy.com/JudgeOnline/problem.php?id=1520)\n\n### \n $ i $  $ [l_i,\\ r_i] $  $ 1 $\n\n $ 1 $ $ 1 $\n\n $ n $ \n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint d, f;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint m, l, r, k;\n\t\tscanf(\"%d %d %d %d\", &m, &l, &r, &k);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\n\t\tfor (int j = l; j <= r; j++) {\n\t\t\taddEdge(i, n + j, 1, k * abs(j - m));\n\t\t}\n\t}\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tif (f != n) puts(\"NIE\");\n\telse printf(\"%d\\n\", c);\n\n\treturn 0;\n}\n```\n","slug":"poi2006-szk","published":1,"updated":"2016-06-22T10:20:59.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji2b00ih0jxlx5jbyndt"},{"title":"POI2005Kos-Dicing -  + ","date":"2016-06-22T10:25:00.000Z","_content":"\nDicing \n\n<!-- more -->\n\n### \n[BZOJ 1532](http://www.lydsy.com/JudgeOnline/problem.php?id=1532)\n\n### \n $ x $ $ x $ $ 1 $ $ 1 $ $ m $ \n\n $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c > e->f) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c > e->f) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\t// printf(\"dinic() = %d\\n\", res);\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\nEdge *E[MAXN];\n\ninline void reset(const int c) {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tif (i < n) E[i]->c = c;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n\t}\n}\n\ninline int solve(const int s, const int t, const int n) {\n\tint l = 0, r = m;\n\twhile (l < r) {\n\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\tint mid = l + (r - l) / 2;\n\n\t\treset(mid);\n\n\t\tif (dinic(s, t, n) < m) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) E[i - 1] = addEdge(s, i, 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\taddEdge(a, n + i, 1);\n\t\taddEdge(b, n + i, 1);\n\n\t\taddEdge(n + i, t, 1);\n\t}\n\n\tprintf(\"%d\\n\", solve(s, t, n + m + 2));\n\n\treturn 0;\n}\n```\n","source":"_posts/poi2005-kos.md","raw":"title: POI2005Kos-Dicing -  + \ndate: 2016-06-22 18:25:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - Dinic\n  - \npermalink: poi2005-kos\n---\n\nDicing \n\n<!-- more -->\n\n### \n[BZOJ 1532](http://www.lydsy.com/JudgeOnline/problem.php?id=1532)\n\n### \n $ x $ $ x $ $ 1 $ $ 1 $ $ m $ \n\n $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c > e->f) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c > e->f) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\t// printf(\"dinic() = %d\\n\", res);\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\nEdge *E[MAXN];\n\ninline void reset(const int c) {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tif (i < n) E[i]->c = c;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n\t}\n}\n\ninline int solve(const int s, const int t, const int n) {\n\tint l = 0, r = m;\n\twhile (l < r) {\n\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\tint mid = l + (r - l) / 2;\n\n\t\treset(mid);\n\n\t\tif (dinic(s, t, n) < m) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) E[i - 1] = addEdge(s, i, 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\taddEdge(a, n + i, 1);\n\t\taddEdge(b, n + i, 1);\n\n\t\taddEdge(n + i, t, 1);\n\t}\n\n\tprintf(\"%d\\n\", solve(s, t, n + m + 2));\n\n\treturn 0;\n}\n```\n","slug":"poi2005-kos","published":1,"updated":"2016-06-22T10:25:54.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji2l00io0jxl0mk62xlj"},{"title":"POI2000 - AC  + ","date":"2016-09-12T23:46:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 2938](http://www.lydsy.com/JudgeOnline/problem.php?id=2938)\n\n### \n AC \n\n AC  $ 0 $  $ 1 $  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\nconst int MAXN = 30000;\n\nint n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) {\n\t\t\tthis->id = n++;\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint inDegree;\n\tbool invalid, flag, visited;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\t// printf(\"Edge(%d, %d)\\n\", s, t);\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].inDegree++;\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) N[v->id].invalid = true;\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *u = v;\n\t\t\twhile (u != t.root && !u->c[i]) u = u->fail;\n\t\t\tif (u->c[i]) {\n\t\t\t\tif (!v->isWord && !v->next && !u->c[i]->isWord) addEdge(v->id, u->c[i]->id);\n\t\t\t} else {\n\t\t\t\tif (!v->isWord && !v->next) addEdge(v->id, t.root->id);\n\t\t\t}\n\n\t\t\tif (!v->c[i]) continue;\n\t\t\tv->c[i]->visited = true;\n\t\t\tq.push(v->c[i]);\n\t\t}\n\t}\n}\n\ninline bool solve() {\n\tstd::queue<Node *> q;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!N[i].inDegree && !N[i].invalid) {\n\t\tq.push(&N[i]);\n\t\tcnt++;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt--;\n\t\tv->flag = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\t\t\tif (!--e->t->inDegree) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cnt) return false;\n\n\tq.push(&N[0]);\n\tN[0].visited = true;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tif (!v->flag) return true;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->visited && !e->t->invalid) e->t->visited = true, q.push(e->t);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\n\tputs(solve() ? \"TAK\" : \"NIE\");\n\n\treturn 0;\n}\n```","source":"_posts/poi2000-wir.md","raw":"title: POI2000 - AC  + \ndate: 2016-09-13 07:46:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - AC \n  - \npermalink: poi2000-wir\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2938](http://www.lydsy.com/JudgeOnline/problem.php?id=2938)\n\n### \n AC \n\n AC  $ 0 $  $ 1 $  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\nconst int MAXN = 30000;\n\nint n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) {\n\t\t\tthis->id = n++;\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint inDegree;\n\tbool invalid, flag, visited;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\t// printf(\"Edge(%d, %d)\\n\", s, t);\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].inDegree++;\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) N[v->id].invalid = true;\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *u = v;\n\t\t\twhile (u != t.root && !u->c[i]) u = u->fail;\n\t\t\tif (u->c[i]) {\n\t\t\t\tif (!v->isWord && !v->next && !u->c[i]->isWord) addEdge(v->id, u->c[i]->id);\n\t\t\t} else {\n\t\t\t\tif (!v->isWord && !v->next) addEdge(v->id, t.root->id);\n\t\t\t}\n\n\t\t\tif (!v->c[i]) continue;\n\t\t\tv->c[i]->visited = true;\n\t\t\tq.push(v->c[i]);\n\t\t}\n\t}\n}\n\ninline bool solve() {\n\tstd::queue<Node *> q;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!N[i].inDegree && !N[i].invalid) {\n\t\tq.push(&N[i]);\n\t\tcnt++;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt--;\n\t\tv->flag = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\t\t\tif (!--e->t->inDegree) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cnt) return false;\n\n\tq.push(&N[0]);\n\tN[0].visited = true;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tif (!v->flag) return true;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->visited && !e->t->invalid) e->t->visited = true, q.push(e->t);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\n\tputs(solve() ? \"TAK\" : \"NIE\");\n\n\treturn 0;\n}\n```","slug":"poi2000-wir","published":1,"updated":"2016-09-12T23:51:54.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji2r00iv0jxl56teognz"},{"title":"","date":"2016-01-19T13:48:24.000Z","_content":"\n OI \n\n<!-- more -->\n\n### \n OI \n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b  0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### \n `exgcd`  $\\gcd(a,b)$  $ax+by=\\gcd(a,b)$\n\n $\\gcd(47,30)$ \n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n $\\gcd(47,30)=1$ \n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n $x=-7,y=11$\n\n `x`  `y` `y`  `x` \n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes \n\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n\n1.  $i^2$  $i$  $i'$$i*i'$  $i'$ \n2.  $[2,\\sqrt{n}]$  $p>\\sqrt{n}$ $k$  $p=k*k'$  $k< \\sqrt{n}$ $p$  $k$ \n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### \n $n$  $k$  $i$  $a_i$\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n $n$  $p_i$   \n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n $n$ $p$  $p-1$ \n\n $n$\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // \n\treturn ans;\n}\n```\n\n \n","source":"_posts/number-theory-notes-1.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  -   \npermalink: number-theory-notes-1\ndate: 2016-01-19 21:48:24\n---\n\n OI \n\n<!-- more -->\n\n### \n OI \n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b  0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### \n `exgcd`  $\\gcd(a,b)$  $ax+by=\\gcd(a,b)$\n\n $\\gcd(47,30)$ \n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n $\\gcd(47,30)=1$ \n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n $x=-7,y=11$\n\n `x`  `y` `y`  `x` \n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes \n\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n\n1.  $i^2$  $i$  $i'$$i*i'$  $i'$ \n2.  $[2,\\sqrt{n}]$  $p>\\sqrt{n}$ $k$  $p=k*k'$  $k< \\sqrt{n}$ $p$  $k$ \n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### \n $n$  $k$  $i$  $a_i$\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n $n$  $p_i$   \n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n $n$ $p$  $p-1$ \n\n $n$\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // \n\treturn ans;\n}\n```\n\n \n","slug":"number-theory-notes-1","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji3100j20jxlpbo9n3u5"},{"title":" std::stack  DFS","date":"2016-04-08T06:30:21.000Z","_content":"\n Windows  Windows  1M DFS  DFS\n\n<!-- more -->\n\n### \n DFS\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n\n\n DFS \n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan \n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### \n DFS \n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","source":"_posts/non-recursion-dfs-with-stack.md","raw":"title:  std::stack  DFS\ncategories: OI\ntags: \n  - STL\n  - DFS\n  - \n  - Tarjan\n  - \n  - \npermalink: non-recursion-dfs-with-stack\ndate: 2016-04-08 14:30:21\n---\n\n Windows  Windows  1M DFS  DFS\n\n<!-- more -->\n\n### \n DFS\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n\n\n DFS \n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan \n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### \n DFS \n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","slug":"non-recursion-dfs-with-stack","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji4a00j80jxl1gazm2mr"},{"title":"NOIP2016 ","date":"2016-11-20T15:47:00.000Z","_content":"\n NOIP  \n NOIP\n\n<!-- more -->\n\n### Day0\n\n\n lwyz  %  10  \n\n zyzwjh  xzy  Erii\n\nDev-C++  VC6 Linux root  sda3  Windows  \n\n### Day1\nlyx  \n\n\n\n   DFS      + $ S_i = 1 $ \n\n Floyd $ m = 0 $  $ m = 1 $ $ m = 2 $  $ k = 1 $    DP \n\n zyz T2   T3  DP    \n\n     \n\n zyz \n\n### Day2\n\n\n Pascal  +  $ O(2000 ^ 2 + Tn) $ lyx  lyh    QAQ\n\n +  CCF   \n\n GDB  Windows  BugDFS  $ T = 5, n = 18 $  T BFS  $ O(T \\times (2 ^ n n ^ 2)) $ \n\n---\n\n\n\nDay1 Day2 \n\n   \n\n---\n\n>  \n  \n> \n\n> ","source":"_posts/noip2016.md","raw":"title: NOIP2016 \ncategories: Diary\npermalink: noip2016\ndate: 2016-11-20 23:47:00\n---\n\n NOIP  \n NOIP\n\n<!-- more -->\n\n### Day0\n\n\n lwyz  %  10  \n\n zyzwjh  xzy  Erii\n\nDev-C++  VC6 Linux root  sda3  Windows  \n\n### Day1\nlyx  \n\n\n\n   DFS      + $ S_i = 1 $ \n\n Floyd $ m = 0 $  $ m = 1 $ $ m = 2 $  $ k = 1 $    DP \n\n zyz T2   T3  DP    \n\n     \n\n zyz \n\n### Day2\n\n\n Pascal  +  $ O(2000 ^ 2 + Tn) $ lyx  lyh    QAQ\n\n +  CCF   \n\n GDB  Windows  BugDFS  $ T = 5, n = 18 $  T BFS  $ O(T \\times (2 ^ n n ^ 2)) $ \n\n---\n\n\n\nDay1 Day2 \n\n   \n\n---\n\n>  \n  \n> \n\n> ","slug":"noip2016","published":1,"updated":"2016-11-20T15:48:34.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji4l00jg0jxlvehtidf2"},{"title":"NOIP2016 - ","date":"2016-11-29T03:25:00.000Z","_content":"\n\n\n\n\n `singer`  $ 3 $  $ 1 $  $ 2 $ \n\n \n\n\n\n`singer`  $ 3 $  `archer`  \n`archer`  $ 1 $  `thinker`  \n`thinker`  $ 2 $  `writer`\n\n `writer` \n\n\n\n $ n $  $ 1 $  $ m $  $ i $ / $ s_i $ \n\n<!-- more -->\n\n### \n[Luogu 1563](https://www.luogu.org/problem/show?pid=1563)  \n[LYOI #99](https://ly.men.ci/problem/99)\n\n### \n $ n $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 1e5 + 10;\n\nint main() {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic struct Node {\n\t\tchar name[10 + 1];\n\t\tint opposite;\n\t} a[MAXN];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &a[i].opposite, a[i].name);\n\t}\n\n\tint curr = 0;\n\twhile (m--) {\n\t\t// printf(\"%d: %s\\n\", curr, a[curr].name);\n\n\t\tint k, s;\n\t\tscanf(\"%d %d\", &k, &s);\n\n\t\tint d = (k ^ a[curr].opposite) ? 1 : -1;\n\n\t\t(((curr += d * s) %= n) += n) %= n;\n\t}\n\n\tprintf(\"%s\\n\", a[curr].name);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-toy.md","raw":"title: NOIP2016 - \ncategories: OI\ntags: \n  - NOIP\n  - \npermalink: noip2016-toy\ndate: 2016-11-29 11:25:00\n---\n\n\n\n\n\n `singer`  $ 3 $  $ 1 $  $ 2 $ \n\n \n\n\n\n`singer`  $ 3 $  `archer`  \n`archer`  $ 1 $  `thinker`  \n`thinker`  $ 2 $  `writer`\n\n `writer` \n\n\n\n $ n $  $ 1 $  $ m $  $ i $ / $ s_i $ \n\n<!-- more -->\n\n### \n[Luogu 1563](https://www.luogu.org/problem/show?pid=1563)  \n[LYOI #99](https://ly.men.ci/problem/99)\n\n### \n $ n $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 1e5 + 10;\n\nint main() {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic struct Node {\n\t\tchar name[10 + 1];\n\t\tint opposite;\n\t} a[MAXN];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &a[i].opposite, a[i].name);\n\t}\n\n\tint curr = 0;\n\twhile (m--) {\n\t\t// printf(\"%d: %s\\n\", curr, a[curr].name);\n\n\t\tint k, s;\n\t\tscanf(\"%d %d\", &k, &s);\n\n\t\tint d = (k ^ a[curr].opposite) ? 1 : -1;\n\n\t\t(((curr += d * s) %= n) += n) %= n;\n\t}\n\n\tprintf(\"%s\\n\", a[curr].name);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-toy","published":1,"updated":"2016-11-29T07:36:08.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji4n00ji0jxlmtc0obw5"},{"title":"NOIP2016 -  + ","date":"2016-11-29T07:10:00.000Z","_content":"\n C \n\n $ n $  $ n - 1 $  $ 1 $  $ n $ \n\n $ m $  $ i $  $ S_i $ $ T_i $ $ 0 $  \n\n C  $ j $  $ W_j $  $ W_j $  $ j $ C \n\n $ j $  $ W_j $  $ j $  $ W_j $  $ j $ \n\n<!-- more -->\n\n### \n[Luogu 1600](https://www.luogu.org/problem/show?pid=1600)  \n[LYOI #100](https://ly.men.ci/problem/100)\n\n### \n $ L $  $ [0, L) $  $ S_j $  $ T_j $$ S_j < T_j $ $ i $  $ W_i = i - S_j $\n\n![](noip2016-running/linear-forward1.svg)\n\n $ S_j < 0 $ \n\n![](noip2016-running/linear-forward2.svg)\n\n $ S_j > T_j $  $ W_i = S_j - i $\n\n![](noip2016-running/linear-backward1.svg)\n\n$ S_j > L $ \n\n $ S_j < T_j $ $ S_j = i - W_i $ $ i $  $ X_i = i - W_i $\n\n1.  $ [S_j, T_j] $ \n2.  $ i $ $ X_i $\n\n $ S_j > T_j $ $ S_j = W_i + i $ $ X_i = i + W_i $ \n\n $ S_j $  $ T_j $  $ j $ $ j $\n\n $ O(n) $  $ O(\\log n) $  $ 0 $ $ S_j < T_j $  $ S_j > T_j $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 299998;\n\nstruct Tag {\n#ifdef FORCE\n\tint s, t, x;\n\n\tTag(int s, int t, int x) : s(s), t(t), x(x) {\n#ifdef DBG\n\t\tprintf(\"Tag(%d, %d, %d)\\n\", s, t, x);\n#endif\n\t}\n#else\n\tint x;\n\tbool remove;\n\n\tTag(int x, bool remove) : x(x), remove(remove) {}\n#endif\n};\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent, *child;\n\tint depth, size, w, index, x, ans;\n\tbool visited;\n\tstruct Chain *chain;\n#ifndef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Chain {\n\tNode *top, *bottom;\n\tstd::vector<Node *> nodes;\n#ifdef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n\tint len;\n} chains[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, chainCnt;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->depth) {\n\t\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\t\te->t->parent = v;\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->child || v->child->size < e->t->size) v->child = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].visited = false;\n\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\n\t\t\tif (!v->parent || v != v->parent->child) {\n\t\t\t\tv->chain = &chains[++chainCnt];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->index = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->parent->chain;\n\t\t\t\tv->index = v->parent->index + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bottom = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->parent == v) {\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= chainCnt; i++) chains[i].len = chains[i].nodes.size();\n\n#ifdef DBG\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tprintf(\"chains[%d]: top = %lu, bottom = %lu, nodes = [\", i, chains[i].top - N, chains[i].bottom - N);\n\t\tfor (int j = 0; j < chains[i].len; j++) {\n\t\t\tprintf(\"%lu%s\", chains[i].nodes[j] - N, j == chains[i].len - 1 ? \"]\\n\" : \", \");\n\t\t}\n\t}\n#endif\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->parent;\n\t}\n\tif (u->depth > v->depth) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->depth + v->depth - p->depth * 2;\n}\n\ninline void addTag(bool forward, Chain *chain, int s, int t, int x) {\n#ifdef FORCE\n\tif (forward) {\n\t\tchain->tagsForward.push_back(Tag(s, t, x));\n\t} else {\n\t\tchain->tagsBackward.push_back(Tag(s, t, x));\n\t}\n#else\n\tif (forward) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->tagsForward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsForward.push_back(Tag(x, true));\n\t} else {\n\t\tif (t > s) return;\n\t\tchain->nodes[s]->tagsBackward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsBackward.push_back(Tag(x, true));\n\t}\n#ifdef DBG\n\tprintf(\"addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\\n\", forward, chain - chains, s, t, x);\n#endif\n#endif\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n#ifdef DBG\n\tprintf(\"play(s = %lu, t = %lu, p = %lu)\\n\", s - N, t - N, p - N);\n#endif\n\n\tif (p != s) {\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\t// S -> P, backward on chain\n\t\twhile (u->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\t\taddTag(false, u->chain, u->index, 0, s->depth - u->chain->bottom->depth);\n\t\t\tu = u->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\taddTag(false, u->chain, u->index, p->index + 1, s->depth - u->chain->bottom->depth);\n\t}\n\n\tif (p != t) {\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\t// P -> T, forward on chain\n\t\twhile (v->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\t\taddTag(true, v->chain, 0, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t\t\tv = v->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\taddTag(true, v->chain, p->index + 1, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t}\n}\n\ninline void solve() {\n#ifdef FORCE\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) {\n\t\t\tfor (int j = it->s; j <= it->t; j++) {\n\t\t\t\tif (chain.nodes[j]->w - j == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) {\n\t\t\tfor (int j = it->s; j >= it->t; j--) {\n\t\t\t\tif (chain.nodes[j]->w - chain.len + j + 1 == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#else\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n\t\tstatic int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN;\n\t\t\n\t\t// forward\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - j], chain.nodes[j]->w - j);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// backward\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - chain.len + j + 1];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - chain.len + j + 1], chain.nodes[j]->w - chain.len + j + 1);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].w);\n\t}\n\n\tsplit();\n\n\twhile (m--) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tplay(&N[s], &N[t]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-running.md","raw":"title: NOIP2016 -  + \ncategories: OI\ntags: \n  - NOIP\n  - \n  - \npermalink: noip2016-running\ndate: 2016-11-29 15:10:00\n---\n\n C \n\n $ n $  $ n - 1 $  $ 1 $  $ n $ \n\n $ m $  $ i $  $ S_i $ $ T_i $ $ 0 $  \n\n C  $ j $  $ W_j $  $ W_j $  $ j $ C \n\n $ j $  $ W_j $  $ j $  $ W_j $  $ j $ \n\n<!-- more -->\n\n### \n[Luogu 1600](https://www.luogu.org/problem/show?pid=1600)  \n[LYOI #100](https://ly.men.ci/problem/100)\n\n### \n $ L $  $ [0, L) $  $ S_j $  $ T_j $$ S_j < T_j $ $ i $  $ W_i = i - S_j $\n\n![](noip2016-running/linear-forward1.svg)\n\n $ S_j < 0 $ \n\n![](noip2016-running/linear-forward2.svg)\n\n $ S_j > T_j $  $ W_i = S_j - i $\n\n![](noip2016-running/linear-backward1.svg)\n\n$ S_j > L $ \n\n $ S_j < T_j $ $ S_j = i - W_i $ $ i $  $ X_i = i - W_i $\n\n1.  $ [S_j, T_j] $ \n2.  $ i $ $ X_i $\n\n $ S_j > T_j $ $ S_j = W_i + i $ $ X_i = i + W_i $ \n\n $ S_j $  $ T_j $  $ j $ $ j $\n\n $ O(n) $  $ O(\\log n) $  $ 0 $ $ S_j < T_j $  $ S_j > T_j $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 299998;\n\nstruct Tag {\n#ifdef FORCE\n\tint s, t, x;\n\n\tTag(int s, int t, int x) : s(s), t(t), x(x) {\n#ifdef DBG\n\t\tprintf(\"Tag(%d, %d, %d)\\n\", s, t, x);\n#endif\n\t}\n#else\n\tint x;\n\tbool remove;\n\n\tTag(int x, bool remove) : x(x), remove(remove) {}\n#endif\n};\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent, *child;\n\tint depth, size, w, index, x, ans;\n\tbool visited;\n\tstruct Chain *chain;\n#ifndef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Chain {\n\tNode *top, *bottom;\n\tstd::vector<Node *> nodes;\n#ifdef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n\tint len;\n} chains[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, chainCnt;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->depth) {\n\t\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\t\te->t->parent = v;\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->child || v->child->size < e->t->size) v->child = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].visited = false;\n\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\n\t\t\tif (!v->parent || v != v->parent->child) {\n\t\t\t\tv->chain = &chains[++chainCnt];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->index = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->parent->chain;\n\t\t\t\tv->index = v->parent->index + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bottom = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->parent == v) {\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= chainCnt; i++) chains[i].len = chains[i].nodes.size();\n\n#ifdef DBG\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tprintf(\"chains[%d]: top = %lu, bottom = %lu, nodes = [\", i, chains[i].top - N, chains[i].bottom - N);\n\t\tfor (int j = 0; j < chains[i].len; j++) {\n\t\t\tprintf(\"%lu%s\", chains[i].nodes[j] - N, j == chains[i].len - 1 ? \"]\\n\" : \", \");\n\t\t}\n\t}\n#endif\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->parent;\n\t}\n\tif (u->depth > v->depth) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->depth + v->depth - p->depth * 2;\n}\n\ninline void addTag(bool forward, Chain *chain, int s, int t, int x) {\n#ifdef FORCE\n\tif (forward) {\n\t\tchain->tagsForward.push_back(Tag(s, t, x));\n\t} else {\n\t\tchain->tagsBackward.push_back(Tag(s, t, x));\n\t}\n#else\n\tif (forward) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->tagsForward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsForward.push_back(Tag(x, true));\n\t} else {\n\t\tif (t > s) return;\n\t\tchain->nodes[s]->tagsBackward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsBackward.push_back(Tag(x, true));\n\t}\n#ifdef DBG\n\tprintf(\"addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\\n\", forward, chain - chains, s, t, x);\n#endif\n#endif\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n#ifdef DBG\n\tprintf(\"play(s = %lu, t = %lu, p = %lu)\\n\", s - N, t - N, p - N);\n#endif\n\n\tif (p != s) {\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\t// S -> P, backward on chain\n\t\twhile (u->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\t\taddTag(false, u->chain, u->index, 0, s->depth - u->chain->bottom->depth);\n\t\t\tu = u->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\taddTag(false, u->chain, u->index, p->index + 1, s->depth - u->chain->bottom->depth);\n\t}\n\n\tif (p != t) {\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\t// P -> T, forward on chain\n\t\twhile (v->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\t\taddTag(true, v->chain, 0, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t\t\tv = v->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\taddTag(true, v->chain, p->index + 1, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t}\n}\n\ninline void solve() {\n#ifdef FORCE\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) {\n\t\t\tfor (int j = it->s; j <= it->t; j++) {\n\t\t\t\tif (chain.nodes[j]->w - j == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) {\n\t\t\tfor (int j = it->s; j >= it->t; j--) {\n\t\t\t\tif (chain.nodes[j]->w - chain.len + j + 1 == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#else\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n\t\tstatic int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN;\n\t\t\n\t\t// forward\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - j], chain.nodes[j]->w - j);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// backward\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - chain.len + j + 1];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - chain.len + j + 1], chain.nodes[j]->w - chain.len + j + 1);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].w);\n\t}\n\n\tsplit();\n\n\twhile (m--) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tplay(&N[s], &N[t]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-running","published":1,"updated":"2016-11-29T07:36:19.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji4v00jn0jxld7ik8eru"},{"title":"NOIP2016 -  + ","date":"2016-11-29T12:54:00.000Z","_content":"\n $ n $  $ m $  $ (1, 2, 3) $  $ (1, 2) $$ (1, 3) $$ (2, 3) $ \n\n\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n $ n! = 1 \\times 2 \\times \\cdots \\times n $\n\n $ n $$ m $  $ k $ $ 0 \\leq i \\leq n $$ 0 \\leq j \\leq \\min(i, m) $  $ (i, j) $  $ k $ \n\n<!-- more -->\n\n### \n[Luogu 2822](https://www.luogu.org/problem/show?pid=2822)  \n[LYOI #102](https://ly.men.ci/problem/102)\n\n### \n Pascal \n\n$$ C_n ^ m = C_{n - 1} ^ {m - 1} + C_{n - 1} ^ {m} $$\n\n $ C_i ^ j \\bmod k $ $ s(u, i) $  $ 1 \\leq j \\leq i $ $ C_u ^ j \\bmod k = 0 $ $ O(n) $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000 + 10;\n\nint C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1];\n\nint main() {\n\tfreopen(\"problem.in\", \"r\", stdin);\n\tfreopen(\"problem.out\", \"w\", stdout);\n\t\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\t\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcnt[i][j] = cnt[i][j - 1];\n\t\t\tif (C[i][j] == 0) cnt[i][j]++;\n\t\t}\n\t}\n\t\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += cnt[i][std::min(i, m)];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-problem.md","raw":"title: NOIP2016 -  + \ncategories: OI\ntags: \n  - NOIP\n  - \n  - \n  - \npermalink: noip2016-problem\ndate: 2016-11-29 20:54:00\n---\n\n $ n $  $ m $  $ (1, 2, 3) $  $ (1, 2) $$ (1, 3) $$ (2, 3) $ \n\n\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n $ n! = 1 \\times 2 \\times \\cdots \\times n $\n\n $ n $$ m $  $ k $ $ 0 \\leq i \\leq n $$ 0 \\leq j \\leq \\min(i, m) $  $ (i, j) $  $ k $ \n\n<!-- more -->\n\n### \n[Luogu 2822](https://www.luogu.org/problem/show?pid=2822)  \n[LYOI #102](https://ly.men.ci/problem/102)\n\n### \n Pascal \n\n$$ C_n ^ m = C_{n - 1} ^ {m - 1} + C_{n - 1} ^ {m} $$\n\n $ C_i ^ j \\bmod k $ $ s(u, i) $  $ 1 \\leq j \\leq i $ $ C_u ^ j \\bmod k = 0 $ $ O(n) $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000 + 10;\n\nint C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1];\n\nint main() {\n\tfreopen(\"problem.in\", \"r\", stdin);\n\tfreopen(\"problem.out\", \"w\", stdout);\n\t\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\t\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcnt[i][j] = cnt[i][j - 1];\n\t\t\tif (C[i][j] == 0) cnt[i][j]++;\n\t\t}\n\t}\n\t\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += cnt[i][std::min(i, m)];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"noip2016-problem","published":1,"updated":"2016-11-29T13:12:22.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji5i00jt0jxlhvrk8prx"},{"title":"NOIP2016 - ","date":"2016-11-29T13:10:00.000Z","_content":"\n $ \\lfloor c \\rfloor $  $ c $ $ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $\n\n\n\n $ n $ $ n $  $ i $  $ a_i $$ i = 1, 2, \\ldots , n $ $ 0 $ \n\n $ p $ $ 0 < p < 1 $  $ x $ $ \\lfloor px \\rfloor $  $ x - \\lfloor px \\rfloor $  $ 0 $ $ 0 $  $ q $\n\n $ m $  $ m $ \n\n $ m $ \n\n* $ m $  $ m $ \n* $ m $  $ n + m $ \n\n \n\n<!-- more -->\n\n### \n[Luogu 2827](https://www.luogu.org/problem/show?pid=2827)  \n[LYOI #103](https://ly.men.ci/problem/103)\n\n### \n $ q = 0 $ \n\n $ q \\neq 0 $ \n\n $ O(n \\log n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 7000000;\n\ntemplate <typename T>\nstruct Queue {\n    T a[MAXN + MAXM], *l, *r;\n\n    Queue() : l(a), r(a - 1) {}\n\n    void push(const T &x) { *++r = x; }\n    void pop() { ++l; }\n    T &front() { return *l; }\n    bool empty() const { return l > r; }\n};\n\n#ifdef DBG\nstd::queue<int> q[3];\n#else\nQueue<int> q[3];\n#endif\n\ninline int getMax() {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\n#ifdef DBG\ninline void printAll(int d) {\n    std::vector<int> v;\n    for (int i = 0; i < 3; i++) {\n        std::queue<int> a = ::q[i];\n        while (!a.empty()) v.push_back(a.front()), a.pop();\n    }\n    std::sort(v.begin(), v.end());\n    printf(\"%lu: \", v.size());\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) printf(\"%d%c\", *it, it == --v.end() ? '\\n' : ' ');\n}\n#endif\n\nint main() {\n    freopen(\"earthworm.in\", \"r\", stdin);\n    freopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n    static int a[MAXN + 1];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    std::sort(a + 1, a + n + 1);\n\n    for (int i = n; i >= 1; i--) q[0].push(a[i]);\n\n    int d = 0;\n    for (int i = 1; i <= m; i++) {\n        int j = getMax();\n\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n\n        int a = static_cast<long long>(x) * u / v, b = x - a;\n\n        d += k;\n        a -= d, b -= d;\n\n        q[1].push(a), q[2].push(b);\n    }\n\n    putchar('\\n');\n\n    for (int i = 1; i <= n + m; i++) {\n        int j = getMax();\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n    }\n\n    putchar('\\n');\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","source":"_posts/noip2016-earthworm.md","raw":"title: NOIP2016 - \ncategories: OI\ntags: \n  - NOIP\n  - \npermalink: noip2016-earthworm\ndate: 2016-11-29 21:10:00\n---\n\n $ \\lfloor c \\rfloor $  $ c $ $ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $\n\n\n\n $ n $ $ n $  $ i $  $ a_i $$ i = 1, 2, \\ldots , n $ $ 0 $ \n\n $ p $ $ 0 < p < 1 $  $ x $ $ \\lfloor px \\rfloor $  $ x - \\lfloor px \\rfloor $  $ 0 $ $ 0 $  $ q $\n\n $ m $  $ m $ \n\n $ m $ \n\n* $ m $  $ m $ \n* $ m $  $ n + m $ \n\n \n\n<!-- more -->\n\n### \n[Luogu 2827](https://www.luogu.org/problem/show?pid=2827)  \n[LYOI #103](https://ly.men.ci/problem/103)\n\n### \n $ q = 0 $ \n\n $ q \\neq 0 $ \n\n $ O(n \\log n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 7000000;\n\ntemplate <typename T>\nstruct Queue {\n    T a[MAXN + MAXM], *l, *r;\n\n    Queue() : l(a), r(a - 1) {}\n\n    void push(const T &x) { *++r = x; }\n    void pop() { ++l; }\n    T &front() { return *l; }\n    bool empty() const { return l > r; }\n};\n\n#ifdef DBG\nstd::queue<int> q[3];\n#else\nQueue<int> q[3];\n#endif\n\ninline int getMax() {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\n#ifdef DBG\ninline void printAll(int d) {\n    std::vector<int> v;\n    for (int i = 0; i < 3; i++) {\n        std::queue<int> a = ::q[i];\n        while (!a.empty()) v.push_back(a.front()), a.pop();\n    }\n    std::sort(v.begin(), v.end());\n    printf(\"%lu: \", v.size());\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) printf(\"%d%c\", *it, it == --v.end() ? '\\n' : ' ');\n}\n#endif\n\nint main() {\n    freopen(\"earthworm.in\", \"r\", stdin);\n    freopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n    static int a[MAXN + 1];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    std::sort(a + 1, a + n + 1);\n\n    for (int i = n; i >= 1; i--) q[0].push(a[i]);\n\n    int d = 0;\n    for (int i = 1; i <= m; i++) {\n        int j = getMax();\n\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n\n        int a = static_cast<long long>(x) * u / v, b = x - a;\n\n        d += k;\n        a -= d, b -= d;\n\n        q[1].push(a), q[2].push(b);\n    }\n\n    putchar('\\n');\n\n    for (int i = 1; i <= n + m; i++) {\n        int j = getMax();\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n    }\n\n    putchar('\\n');\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","slug":"noip2016-earthworm","published":1,"updated":"2016-11-29T13:11:22.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji5o00jz0jxlbbzi2bed"},{"title":"NOIP2016 - Floyd + DP + ","date":"2016-11-29T07:35:00.000Z","_content":"\n\n\n $ 2n $  $ n $  $ i $ $ 1 \\leq  i \\leq n $ $ c_i $  $ d_i $ \n\n $ n $ i $ i $  $ d_i $  $ c_i $ \n\n $ i $  $ k_i $\n\n $ m $  $ m $  $ m $ \n\n\n\n $ v $  $ e $  $ i $$ 1 \\leq i \\leq n - 1 $\n\n\n\n<!-- more -->\n\n### \n[Luogu 1850](https://www.luogu.org/problem/show?pid=1850)  \n[LYOI #101](https://ly.men.ci/problem/101)\n\n### \n Floyd  $ f(i, j, k) $  $ i $  $ j $ $ k \\in \\{ 0, 1 \\} $  $ i $ \n\n $ f(i, j, 0) $ \n\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i, j, 1) $ \n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n $ O(v ^ 3 + nm) $\n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <climits>\n#include <algorithm>\n\nconst int MAXCNT = 2000;\nconst int MAXN = 300;\n\nint cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1];\ndouble k[MAXCNT + 1];\n\nint main() {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d %d %d\", &cnt, &max, &n, &m);\n\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[u][v] = g[v][u] = std::min(g[u][v], w);\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (g[i][k] != INT_MAX && g[k][j] != INT_MAX && g[i][j] > g[i][k] + g[k][j]) {\n\t\t\t\t\tg[i][j] = g[i][k] + g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) g[i][i] = 0;\n\n\tstatic double f[MAXCNT + 1][MAXCNT + 1][2];\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\n\tfor (int i = 2; i <= cnt; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= max; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tfor (int j = 0; j <= max; j++) {\n\t\t\tprintf(\"f[%d][%d][0] = %.4lf\\n\", i, j, f[i][j][0]);\n\t\t\tprintf(\"f[%d][%d][1] = %.4lf\\n\", i, j, f[i][j][1]);\n\t\t}\n#endif\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor (int i = 0; i <= max; i++) {\n\t\tans = std::min(ans, f[cnt][i][0]);\n\t\tans = std::min(ans, f[cnt][i][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-classroom.md","raw":"title: NOIP2016 - Floyd + DP + \ncategories: OI\ntags: \n  - NOIP\n  - DP\n  - Floyd\n  - \npermalink: noip2016-classroom\ndate: 2016-11-29 15:35:00\n---\n\n\n\n $ 2n $  $ n $  $ i $ $ 1 \\leq  i \\leq n $ $ c_i $  $ d_i $ \n\n $ n $ i $ i $  $ d_i $  $ c_i $ \n\n $ i $  $ k_i $\n\n $ m $  $ m $  $ m $ \n\n\n\n $ v $  $ e $  $ i $$ 1 \\leq i \\leq n - 1 $\n\n\n\n<!-- more -->\n\n### \n[Luogu 1850](https://www.luogu.org/problem/show?pid=1850)  \n[LYOI #101](https://ly.men.ci/problem/101)\n\n### \n Floyd  $ f(i, j, k) $  $ i $  $ j $ $ k \\in \\{ 0, 1 \\} $  $ i $ \n\n $ f(i, j, 0) $ \n\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i, j, 1) $ \n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n $ O(v ^ 3 + nm) $\n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <climits>\n#include <algorithm>\n\nconst int MAXCNT = 2000;\nconst int MAXN = 300;\n\nint cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1];\ndouble k[MAXCNT + 1];\n\nint main() {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d %d %d\", &cnt, &max, &n, &m);\n\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[u][v] = g[v][u] = std::min(g[u][v], w);\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (g[i][k] != INT_MAX && g[k][j] != INT_MAX && g[i][j] > g[i][k] + g[k][j]) {\n\t\t\t\t\tg[i][j] = g[i][k] + g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) g[i][i] = 0;\n\n\tstatic double f[MAXCNT + 1][MAXCNT + 1][2];\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\n\tfor (int i = 2; i <= cnt; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= max; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tfor (int j = 0; j <= max; j++) {\n\t\t\tprintf(\"f[%d][%d][0] = %.4lf\\n\", i, j, f[i][j][0]);\n\t\t\tprintf(\"f[%d][%d][1] = %.4lf\\n\", i, j, f[i][j][1]);\n\t\t}\n#endif\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor (int i = 0; i <= max; i++) {\n\t\tans = std::min(ans, f[cnt][i][0]);\n\t\tans = std::min(ans, f[cnt][i][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-classroom","published":1,"updated":"2016-11-29T07:36:33.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji5x00k40jxlr168hhms"},{"title":"NOIP2016 -  + BFS","date":"2016-11-29T13:21:00.000Z","_content":"\nKiana \n\n\n\n $ (0, 0) $  Kiana  $ y = ax ^ 2 + bx $  $ a $$ b $  Kiana  $ a < 0 $\n\n $ x $ \n\n $ n $  $ i $  $ (x_i, y_i) $\n\n$ (x_i, y_i) $ $ i $ \n\n$ (x_i, y_i) $ $ i $ \n\n $ (1, 3) $  $ (3, 3) $Kiana  $ y = -x ^ 2 + 4x $ \n\n\n\n Kiana  Kiana \n\n $ T $  Kiana \n\n<!-- more -->\n\n### \n[Luogu 2831](https://www.luogu.org/problem/show?pid=2831)  \n[LYOI #104](https://ly.men.ci/problem/104)\n\n### \n $ y = ax ^ 2 + bx + c $  $ c $  $ a \\leq 0 $  $ O(n ^ 2) $ \n\nBFS \n\n $ O(2 ^ n n ^ 2) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 18 + 3;\nconst int MAXSTATUS = (1 << (MAXN + 1));\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    \n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp(double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp(double x, double y) {\n    return dcmp(x - y);\n}\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n    \n    Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {}\n    \n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n    \n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool visited;\n    int dist;\n} N[MAXSTATUS];\n\nint n, cmd, limit, lineCnt;\n\n/*\n#ifdef DBG\ninline void print(int s) {\n    for (int i = 0; i < n; i++) putchar((s & (1u << i)) ? '1' : '0');\n}\n#endif\n*/\n\ninline int bfs(int status) {\n    if (!status) return 0;\n    \n    std::queue<int> q;\n    q.push(status);\n    N[status].visited = true;\n    N[status].dist = 0;\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        if (N[v].dist == limit) continue;\n        \n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill;\n                \n                if (!N[u].visited) {\n                    N[u].visited = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    \n    return n;\n}\n\n/*\ninline void massert(bool x) {\n    if (!x) {\n        int b = 0;\n        b = 1;\n        b = 2;\n    }\n}\n*/\n\ninline Line getLine(const Point &a, const Point &b) {\n    Line l;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n    // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2)\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    // b = (y1 - a * x1 ^ 2) / x1\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n//    if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) {\n//        printf(\"ERROR: %lf %lf\\n\", l.b, (b.y - l.a * b.x * b.x) / b.x);\n//    }\n    return l;\n}\n\ninline bool onLine(const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve() {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n            \n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n        /*\n#ifdef DBG\n        printf(\"[a = %lf, b = %lf]: \", lines[i].a, lines[i].b);\n        print(lines[i].kill);\n        putchar('\\n');\n#endif\n        */\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1));\n        }\n    }\n        \n    std::sort(lines + 1, lines + lineCnt + 1);\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            }\n        }\n    }\n    \n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].visited = false;\n    }\n    \n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n    \n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n        \n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    fclose(stdin);\n    fclose(stdout);\n}\n```","source":"_posts/noip2016-angrybirds.md","raw":"title: NOIP2016 -  + BFS\ncategories: OI\ntags: \n  - NOIP\n  - \n  - \n  - BFS\npermalink: noip2016-angrybirds\ndate: 2016-11-29 21:21:00\n---\n\nKiana \n\n\n\n $ (0, 0) $  Kiana  $ y = ax ^ 2 + bx $  $ a $$ b $  Kiana  $ a < 0 $\n\n $ x $ \n\n $ n $  $ i $  $ (x_i, y_i) $\n\n$ (x_i, y_i) $ $ i $ \n\n$ (x_i, y_i) $ $ i $ \n\n $ (1, 3) $  $ (3, 3) $Kiana  $ y = -x ^ 2 + 4x $ \n\n\n\n Kiana  Kiana \n\n $ T $  Kiana \n\n<!-- more -->\n\n### \n[Luogu 2831](https://www.luogu.org/problem/show?pid=2831)  \n[LYOI #104](https://ly.men.ci/problem/104)\n\n### \n $ y = ax ^ 2 + bx + c $  $ c $  $ a \\leq 0 $  $ O(n ^ 2) $ \n\nBFS \n\n $ O(2 ^ n n ^ 2) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 18 + 3;\nconst int MAXSTATUS = (1 << (MAXN + 1));\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    \n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp(double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp(double x, double y) {\n    return dcmp(x - y);\n}\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n    \n    Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {}\n    \n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n    \n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool visited;\n    int dist;\n} N[MAXSTATUS];\n\nint n, cmd, limit, lineCnt;\n\n/*\n#ifdef DBG\ninline void print(int s) {\n    for (int i = 0; i < n; i++) putchar((s & (1u << i)) ? '1' : '0');\n}\n#endif\n*/\n\ninline int bfs(int status) {\n    if (!status) return 0;\n    \n    std::queue<int> q;\n    q.push(status);\n    N[status].visited = true;\n    N[status].dist = 0;\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        if (N[v].dist == limit) continue;\n        \n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill;\n                \n                if (!N[u].visited) {\n                    N[u].visited = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    \n    return n;\n}\n\n/*\ninline void massert(bool x) {\n    if (!x) {\n        int b = 0;\n        b = 1;\n        b = 2;\n    }\n}\n*/\n\ninline Line getLine(const Point &a, const Point &b) {\n    Line l;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n    // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2)\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    // b = (y1 - a * x1 ^ 2) / x1\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n//    if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) {\n//        printf(\"ERROR: %lf %lf\\n\", l.b, (b.y - l.a * b.x * b.x) / b.x);\n//    }\n    return l;\n}\n\ninline bool onLine(const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve() {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n            \n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n        /*\n#ifdef DBG\n        printf(\"[a = %lf, b = %lf]: \", lines[i].a, lines[i].b);\n        print(lines[i].kill);\n        putchar('\\n');\n#endif\n        */\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1));\n        }\n    }\n        \n    std::sort(lines + 1, lines + lineCnt + 1);\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            }\n        }\n    }\n    \n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].visited = false;\n    }\n    \n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n    \n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n        \n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    fclose(stdin);\n    fclose(stdout);\n}\n```","slug":"noip2016-angrybirds","published":1,"updated":"2016-11-29T13:22:13.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji6100kb0jxl78v23ri9"},{"title":"NOIP2015 -  +  + ","date":"2016-10-19T09:19:00.000Z","_content":"\n $ m $  $ u_i \\leftrightarrow v_i $ $ 0 $ $ m $ \n\n<!-- more -->\n\n### \n[CodeVS 4632](http://codevs.cn/problem/4632/)  \n[CodeVS 5440](http://codevs.cn/problem/5440/)  \n[BZOJ 4326](http://www.lydsy.com/JudgeOnline/problem.php?id=4326)  \n\n### \n $ x $ $ > x $  $ \\leq x $ $ x $ \n\n**** $ u_i \\leftrightarrow v_i $ $ p_i = \\mathrm{lca}(u_i, v_i) $ $ u_i $  $ v_i $  $ +1 $  $ p_i $  $ -2 $ \n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <new>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 300000;\nconst int MAXM = 300000;\nconst int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tbool visited;\n\tint pos, depth, cover, dist;\n} N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w, cover;\n\tEdge *next;\n\n\tEdge() {}\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n} mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1];\n\nstruct Path {\n\tNode *u, *v, *p;\n\tint dist;\n} a[MAXM];\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new (pEdge++) Edge(&N[s], &N[t], w);\n\tN[t].e = new (pEdge++) Edge(&N[t], &N[s], w);\n}\n\nint n, m, log[MAXN * 2 + 1], max, eulerTourLen;\n\ninline void dfs() {\n\tstatic Node *s[MAXN];\n\tNode **top = s;\n\t*s = &N[0];\n\tN[0].depth = 1;\n\n\tint ts = 0;\n\twhile (top >= s) {\n\t\tNode *v = *top;\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->pos = eulerTourLen;\n\t\t\tdfsSequence[ts++] = v;\n\t\t}\n\n\t\teulerTour[eulerTourLen++] = v;\n\n\t\twhile (v->c && v->c->t->depth) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tif (!v->c->t->depth) {\n\t\t\t\tv->c->t->depth = v->depth + 1;\n\t\t\t\tv->c->t->dist = v->dist + v->c->w;\n\t\t\t\tv->c->t->in = v->c;\n\t\t\t\t*++top = v->c->t;\n\t\t\t}\n\t\t\tv->c = v->c->next;\n\t\t} else {\n\t\t\ttop--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) E[i - 1] = N[i].in;\n}\n\ninline Node *min(Node *a, Node *b) {\n\treturn a->depth < b->depth ? a : b;\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < eulerTourLen; i++) st[i][0] = eulerTour[i];\n\tfor (int j = 1; (1 << j) <= eulerTourLen; j++) {\n\t\tfor (int i = 0; i < eulerTourLen; i++) {\n\t\t\tif (i + (1 << (j - 1)) < eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= eulerTourLen; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t}\n}\n\ninline Node *rmq(const int l, const int r) {\n\tif (l == r) return st[l][0];\n\telse {\n\t\tconst int t = log[r - l];\n\t\treturn min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n}\n\ninline Node *lca(Node *u, Node *v) {\n\treturn rmq(std::min(u->pos, v->pos), std::max(u->pos, v->pos));\n}\n\ninline int distance(Node *u, Node *v, Node *p) {\n\treturn u->dist + v->dist - p->dist * 2;\n}\n\ninline bool check(const int limit) {\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[i].dist > limit) {\n\t\t\ta[i].p->cover -= 2;\n\t\t\ta[i].u->cover++;\n\t\t\ta[i].v->cover++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (dfsSequence[i]->in) {\n\t\t\tdfsSequence[i]->in->cover = dfsSequence[i]->cover;\n\t\t\tdfsSequence[i]->in->s->cover += dfsSequence[i]->cover;\n\t\t}\n\t\tdfsSequence[i]->cover = 0;\n\t}\n\n\tEdge *maxEdge = NULL;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (E[i]->cover == cnt && (!maxEdge || E[i]->w > maxEdge->w)) maxEdge = E[i];\n\t}\n\n\treturn maxEdge && max - maxEdge->w <= limit;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tdfs();\n\tsparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v), u--, v--;\n\t\ta[i].u = &N[u], a[i].v = &N[v];\n\t\ta[i].p = lca(a[i].u, a[i].v);\n\t\ta[i].dist = distance(a[i].u, a[i].v, a[i].p);\n\t\tmax = std::max(max, a[i].dist);\n\t\t// printf(\"lca(%lu, %lu) = %lu\\n\", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1);\n\t}\n\n\tint l = 0, r = max;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\t// check(11);\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2015-transport.md","raw":"title: NOIP2015 -  +  + \ncategories: OI\ntags: \n  - NOIP\n  - BZOJ\n  - CodeVS\n  - \npermalink: noip2015-transport\ndate: 2016-10-19 17:19:00\n---\n\n $ m $  $ u_i \\leftrightarrow v_i $ $ 0 $ $ m $ \n\n<!-- more -->\n\n### \n[CodeVS 4632](http://codevs.cn/problem/4632/)  \n[CodeVS 5440](http://codevs.cn/problem/5440/)  \n[BZOJ 4326](http://www.lydsy.com/JudgeOnline/problem.php?id=4326)  \n\n### \n $ x $ $ > x $  $ \\leq x $ $ x $ \n\n**** $ u_i \\leftrightarrow v_i $ $ p_i = \\mathrm{lca}(u_i, v_i) $ $ u_i $  $ v_i $  $ +1 $  $ p_i $  $ -2 $ \n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <new>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 300000;\nconst int MAXM = 300000;\nconst int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tbool visited;\n\tint pos, depth, cover, dist;\n} N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w, cover;\n\tEdge *next;\n\n\tEdge() {}\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n} mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1];\n\nstruct Path {\n\tNode *u, *v, *p;\n\tint dist;\n} a[MAXM];\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new (pEdge++) Edge(&N[s], &N[t], w);\n\tN[t].e = new (pEdge++) Edge(&N[t], &N[s], w);\n}\n\nint n, m, log[MAXN * 2 + 1], max, eulerTourLen;\n\ninline void dfs() {\n\tstatic Node *s[MAXN];\n\tNode **top = s;\n\t*s = &N[0];\n\tN[0].depth = 1;\n\n\tint ts = 0;\n\twhile (top >= s) {\n\t\tNode *v = *top;\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->pos = eulerTourLen;\n\t\t\tdfsSequence[ts++] = v;\n\t\t}\n\n\t\teulerTour[eulerTourLen++] = v;\n\n\t\twhile (v->c && v->c->t->depth) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tif (!v->c->t->depth) {\n\t\t\t\tv->c->t->depth = v->depth + 1;\n\t\t\t\tv->c->t->dist = v->dist + v->c->w;\n\t\t\t\tv->c->t->in = v->c;\n\t\t\t\t*++top = v->c->t;\n\t\t\t}\n\t\t\tv->c = v->c->next;\n\t\t} else {\n\t\t\ttop--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) E[i - 1] = N[i].in;\n}\n\ninline Node *min(Node *a, Node *b) {\n\treturn a->depth < b->depth ? a : b;\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < eulerTourLen; i++) st[i][0] = eulerTour[i];\n\tfor (int j = 1; (1 << j) <= eulerTourLen; j++) {\n\t\tfor (int i = 0; i < eulerTourLen; i++) {\n\t\t\tif (i + (1 << (j - 1)) < eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= eulerTourLen; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t}\n}\n\ninline Node *rmq(const int l, const int r) {\n\tif (l == r) return st[l][0];\n\telse {\n\t\tconst int t = log[r - l];\n\t\treturn min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n}\n\ninline Node *lca(Node *u, Node *v) {\n\treturn rmq(std::min(u->pos, v->pos), std::max(u->pos, v->pos));\n}\n\ninline int distance(Node *u, Node *v, Node *p) {\n\treturn u->dist + v->dist - p->dist * 2;\n}\n\ninline bool check(const int limit) {\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[i].dist > limit) {\n\t\t\ta[i].p->cover -= 2;\n\t\t\ta[i].u->cover++;\n\t\t\ta[i].v->cover++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (dfsSequence[i]->in) {\n\t\t\tdfsSequence[i]->in->cover = dfsSequence[i]->cover;\n\t\t\tdfsSequence[i]->in->s->cover += dfsSequence[i]->cover;\n\t\t}\n\t\tdfsSequence[i]->cover = 0;\n\t}\n\n\tEdge *maxEdge = NULL;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (E[i]->cover == cnt && (!maxEdge || E[i]->w > maxEdge->w)) maxEdge = E[i];\n\t}\n\n\treturn maxEdge && max - maxEdge->w <= limit;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tdfs();\n\tsparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v), u--, v--;\n\t\ta[i].u = &N[u], a[i].v = &N[v];\n\t\ta[i].p = lca(a[i].u, a[i].v);\n\t\ta[i].dist = distance(a[i].u, a[i].v, a[i].p);\n\t\tmax = std::max(max, a[i].dist);\n\t\t// printf(\"lca(%lu, %lu) = %lu\\n\", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1);\n\t}\n\n\tint l = 0, r = max;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\t// check(11);\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```\n","slug":"noip2015-transport","published":1,"updated":"2016-10-19T13:07:29.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji6e00kj0jxlpa2aval8"},{"title":"NOIP2015 - DP","date":"2016-10-19T08:48:00.000Z","_content":"\n $ A $  $ B $ $ A $  $ k $  $ k $  $ A $  $ B $   \n\n\n<!-- more -->\n\n### \n[CodeVS 4560](http://codevs.cn/problem/4560/)\n\n### \n $ f(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ $ g(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ \n\n $ f(i, j, t) $ \n\n$$\nf(i, j, t) =\n\\begin{cases}\nf(i - 1, j - 1, t) + g(i - 1, j - 1, t - 1) & A_i = B_j \\\\\n0 & A_i \\neq B_j\n\\end{cases}\n$$\n\n$ g(i, j, t) $ \n\n$$\ng(i, j, t) =\n\\begin{cases}\ng(i - 1, j, t) + f(i, j, t) & A_i = B_j \\\\\ng(i - 1, j, t) & A_i \\neq B_j\n\\end{cases}\n$$\n\n $ f(i, 0, 0) = g(i, 0, 0) = 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char a[MAXN + 1], b[MAXM + 1];\n\tscanf(\"%s\\n%s\", a, b);\n\n\tstatic int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1];\n\tg[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int curr = i % 2, prev = !curr;\n\t\tmemset(f[curr], 0, sizeof(f[curr]));\n\t\tmemset(g[curr], 0, sizeof(g[curr]));\n\n\t\tg[curr][0][0] = f[curr][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= std::min(j, k); t++) {\n\t\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\t\tf[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD;\n\t\t\t\t\tg[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD;\n#ifdef DBG\n\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\", i, j, t, g[curr][j][t]);\n\t\t\t\t\tprintf(\"f[%d][%d][%d] = %d\\n\", i, j, t, f[curr][j][t]);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tf[curr][j][t] = 0;\n\t\t\t\t\tg[curr][j][t] = g[prev][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2015-substring.md","raw":"title: NOIP2015 - DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - DP\npermalink: noip2015-substring\ndate: 2016-10-19 16:48:00\n---\n\n $ A $  $ B $ $ A $  $ k $  $ k $  $ A $  $ B $   \n\n\n<!-- more -->\n\n### \n[CodeVS 4560](http://codevs.cn/problem/4560/)\n\n### \n $ f(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ $ g(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ \n\n $ f(i, j, t) $ \n\n$$\nf(i, j, t) =\n\\begin{cases}\nf(i - 1, j - 1, t) + g(i - 1, j - 1, t - 1) & A_i = B_j \\\\\n0 & A_i \\neq B_j\n\\end{cases}\n$$\n\n$ g(i, j, t) $ \n\n$$\ng(i, j, t) =\n\\begin{cases}\ng(i - 1, j, t) + f(i, j, t) & A_i = B_j \\\\\ng(i - 1, j, t) & A_i \\neq B_j\n\\end{cases}\n$$\n\n $ f(i, 0, 0) = g(i, 0, 0) = 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char a[MAXN + 1], b[MAXM + 1];\n\tscanf(\"%s\\n%s\", a, b);\n\n\tstatic int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1];\n\tg[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int curr = i % 2, prev = !curr;\n\t\tmemset(f[curr], 0, sizeof(f[curr]));\n\t\tmemset(g[curr], 0, sizeof(g[curr]));\n\n\t\tg[curr][0][0] = f[curr][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= std::min(j, k); t++) {\n\t\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\t\tf[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD;\n\t\t\t\t\tg[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD;\n#ifdef DBG\n\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\", i, j, t, g[curr][j][t]);\n\t\t\t\t\tprintf(\"f[%d][%d][%d] = %d\\n\", i, j, t, f[curr][j][t]);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tf[curr][j][t] = 0;\n\t\t\t\t\tg[curr][j][t] = g[prev][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n```\n","slug":"noip2015-substring","published":1,"updated":"2016-11-02T06:50:28.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji6h00kp0jxld0pde07f"},{"title":"NOIP2015 - ","date":"2016-10-19T08:30:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 4325](http://www.lydsy.com/JudgeOnline/problem.php?id=4325)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n 64 \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 13;\n\nconst int CARD_JOKER = 0;\nconst int CARD_2 = 1;\nconst int CARD_3 = 2;\nconst int CARD_4 = 3;\nconst int CARD_5 = 4;\nconst int CARD_6 = 5;\nconst int CARD_7 = 6;\nconst int CARD_8 = 7;\nconst int CARD_9 = 8;\nconst int CARD_10 = 9;\nconst int CARD_J = 10;\nconst int CARD_Q = 11;\nconst int CARD_K = 12;\nconst int CARD_A = 13;\n\ntypedef unsigned long long Status;\n\ninline int id(const int x) {\n\tif (x == 1) return 13;\n\treturn (x >= 2 && x <= 13) ? (x - 1) : x;\n}\n\ninline int get(const Status &s, const int index) {\n\treturn (s >> (index << 2)) & 15ll;\n}\n\n#ifdef DBG\ninline void print(const Status &s, const bool newLine = true) {\n\t// for (int i = 0; i < 64; i++) putchar((s & (1ll << i)) ? '1' : '0');\n\tfor (int i = 0; i < 14; i++) printf(\"%d \", get(s, i));\n\tif (newLine) putchar('\\n');\n}\n#endif\n\ninline void set(Status &s, const int index, const int val) {\n\t/*\n\tif (val < 0) {\n\t\tputs(\"???\");\n\t}\n\t*/\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"=> \");\n#endif\n\ts &= ~(15ll << (index << 2));\n\ts |= (val & 15ll) << (index << 2);\n#ifdef DBG\n\tprint(s);\n#endif\n}\n\ninline void change(Status &s, const int index, const int delta) {\n\tset(s, index, get(s, index) + delta);\n}\n\nint n, ans;\n// std::tr1::unordered_map<Status, int> map;\n\nstruct HashMap {\n\tconst static int HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tStatus key;\n\t\tint val, time;\n\t} N[HASH_SIZE];\n\n\tint time;\n\n\tHashMap() : time(1) {}\n\n\tint locate(const Status &key) {\n\t\tint i;\n\t\tfor (i = key % HASH_SIZE; N[i].time == time && N[i].key != key; (i < HASH_SIZE - 1) ? (i++) : (i = 0));\n\t\tif (N[i].time != time) {\n\t\t\tN[i].time = time;\n\t\t\tN[i].key = key;\n\t\t\tN[i].val = INT_MAX;\n\t\t}\n\t\treturn i;\n\t}\n\n\tint &operator[](const Status &key) {\n\t\treturn N[locate(key)].val;\n\t}\n\n\tvoid clear() {\n\t\ttime++;\n\t}\n} map;\n\ninline void search(const Status &s, const int step = 0) {\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"[%d, %d]\\n\", step, ans);\n#endif\n\tif (step >= ans) return;\n\n\tint &x = map[s];\n\tif (step >= x) return;\n\tx = step;\n\n\t/*\n\tstd::tr1::unordered_map<Status, int>::iterator it = map.find(s);\n\tif (it != map.end() && step >= it->second) return;\n\tmap[s] = step;\n\t*/\n\n\tif (!s) {\n\t\tans = step;\n\t\treturn;\n\t}\n\n\t// 333 444\n\tfor (int i = CARD_3; i <= CARD_K; i++) {\n\t\tStatus next = s;\n\t\tint x = get(next, i);\n\t\tif (x < 3) {\n\t\t\tcontinue;\n\t\t} else set(next, i, x - 3);\n\n\t\tfor (int j = i + 1; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 3) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 3);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 33 44 55\n\tfor (int i = CARD_3; i <= CARD_Q; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 2; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 2);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 2; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3 4 5 6 7\n\tfor (int i = CARD_3; i <= CARD_10; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 4; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 1);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 4; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::vector<int> four, three, two, one;\n\tfor (int i = CARD_JOKER; i <= CARD_A; i++) {\n\t\tint x = get(s, i);\n\t\tif (x == 4) four.push_back(i);\n\t\telse if (x == 3) three.push_back(i);\n\t\telse if (x == 2) two.push_back(i);\n\t\telse if (x == 1) one.push_back(i);\n\t}\n\n\t// 2222 [3 4] / 2222 [33 44]\n\tfor (std::vector<int>::const_iterator it = four.begin(); it != four.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) continue;\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != two.end(); b++) {\n\t\t\t\tif (*b == 0) continue;\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -2);\n\t\t\t\tchange(next, *b, -2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = four.begin(); a != four.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != one.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -1);\n\t\t\t\tchange(next, *b, -1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 222 [3] / 222 [33]\n\tfor (std::vector<int>::const_iterator it = three.begin(); it != three.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = three.begin(); a != three.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) {\n\t\t\t\t// Take only one joker\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 22\n\tfor (std::vector<int>::const_iterator it = two.begin(); it != two.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n\n\t// 2\n\tfor (std::vector<int>::const_iterator it = one.begin(); it != one.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d %d\", &t, &n);\n\twhile (t--) {\n\t\tStatus init = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tchange(init, id(a), 1);\n\t\t}\n\n\t\tmap.clear();\n\t\tans = INT_MAX;\n\t\tsearch(init);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2015-landlords.md","raw":"title: NOIP2015 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BZOJ\n  - \npermalink: noip2015-landlords\ndate: 2016-10-19 16:30:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4325](http://www.lydsy.com/JudgeOnline/problem.php?id=4325)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n 64 \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 13;\n\nconst int CARD_JOKER = 0;\nconst int CARD_2 = 1;\nconst int CARD_3 = 2;\nconst int CARD_4 = 3;\nconst int CARD_5 = 4;\nconst int CARD_6 = 5;\nconst int CARD_7 = 6;\nconst int CARD_8 = 7;\nconst int CARD_9 = 8;\nconst int CARD_10 = 9;\nconst int CARD_J = 10;\nconst int CARD_Q = 11;\nconst int CARD_K = 12;\nconst int CARD_A = 13;\n\ntypedef unsigned long long Status;\n\ninline int id(const int x) {\n\tif (x == 1) return 13;\n\treturn (x >= 2 && x <= 13) ? (x - 1) : x;\n}\n\ninline int get(const Status &s, const int index) {\n\treturn (s >> (index << 2)) & 15ll;\n}\n\n#ifdef DBG\ninline void print(const Status &s, const bool newLine = true) {\n\t// for (int i = 0; i < 64; i++) putchar((s & (1ll << i)) ? '1' : '0');\n\tfor (int i = 0; i < 14; i++) printf(\"%d \", get(s, i));\n\tif (newLine) putchar('\\n');\n}\n#endif\n\ninline void set(Status &s, const int index, const int val) {\n\t/*\n\tif (val < 0) {\n\t\tputs(\"???\");\n\t}\n\t*/\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"=> \");\n#endif\n\ts &= ~(15ll << (index << 2));\n\ts |= (val & 15ll) << (index << 2);\n#ifdef DBG\n\tprint(s);\n#endif\n}\n\ninline void change(Status &s, const int index, const int delta) {\n\tset(s, index, get(s, index) + delta);\n}\n\nint n, ans;\n// std::tr1::unordered_map<Status, int> map;\n\nstruct HashMap {\n\tconst static int HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tStatus key;\n\t\tint val, time;\n\t} N[HASH_SIZE];\n\n\tint time;\n\n\tHashMap() : time(1) {}\n\n\tint locate(const Status &key) {\n\t\tint i;\n\t\tfor (i = key % HASH_SIZE; N[i].time == time && N[i].key != key; (i < HASH_SIZE - 1) ? (i++) : (i = 0));\n\t\tif (N[i].time != time) {\n\t\t\tN[i].time = time;\n\t\t\tN[i].key = key;\n\t\t\tN[i].val = INT_MAX;\n\t\t}\n\t\treturn i;\n\t}\n\n\tint &operator[](const Status &key) {\n\t\treturn N[locate(key)].val;\n\t}\n\n\tvoid clear() {\n\t\ttime++;\n\t}\n} map;\n\ninline void search(const Status &s, const int step = 0) {\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"[%d, %d]\\n\", step, ans);\n#endif\n\tif (step >= ans) return;\n\n\tint &x = map[s];\n\tif (step >= x) return;\n\tx = step;\n\n\t/*\n\tstd::tr1::unordered_map<Status, int>::iterator it = map.find(s);\n\tif (it != map.end() && step >= it->second) return;\n\tmap[s] = step;\n\t*/\n\n\tif (!s) {\n\t\tans = step;\n\t\treturn;\n\t}\n\n\t// 333 444\n\tfor (int i = CARD_3; i <= CARD_K; i++) {\n\t\tStatus next = s;\n\t\tint x = get(next, i);\n\t\tif (x < 3) {\n\t\t\tcontinue;\n\t\t} else set(next, i, x - 3);\n\n\t\tfor (int j = i + 1; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 3) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 3);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 33 44 55\n\tfor (int i = CARD_3; i <= CARD_Q; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 2; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 2);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 2; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3 4 5 6 7\n\tfor (int i = CARD_3; i <= CARD_10; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 4; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 1);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 4; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::vector<int> four, three, two, one;\n\tfor (int i = CARD_JOKER; i <= CARD_A; i++) {\n\t\tint x = get(s, i);\n\t\tif (x == 4) four.push_back(i);\n\t\telse if (x == 3) three.push_back(i);\n\t\telse if (x == 2) two.push_back(i);\n\t\telse if (x == 1) one.push_back(i);\n\t}\n\n\t// 2222 [3 4] / 2222 [33 44]\n\tfor (std::vector<int>::const_iterator it = four.begin(); it != four.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) continue;\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != two.end(); b++) {\n\t\t\t\tif (*b == 0) continue;\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -2);\n\t\t\t\tchange(next, *b, -2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = four.begin(); a != four.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != one.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -1);\n\t\t\t\tchange(next, *b, -1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 222 [3] / 222 [33]\n\tfor (std::vector<int>::const_iterator it = three.begin(); it != three.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = three.begin(); a != three.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) {\n\t\t\t\t// Take only one joker\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 22\n\tfor (std::vector<int>::const_iterator it = two.begin(); it != two.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n\n\t// 2\n\tfor (std::vector<int>::const_iterator it = one.begin(); it != one.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d %d\", &t, &n);\n\twhile (t--) {\n\t\tStatus init = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tchange(init, id(a), 1);\n\t\t}\n\n\t\tmap.clear();\n\t\tans = INT_MAX;\n\t\tsearch(init);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2015-landlords","published":1,"updated":"2016-10-19T08:32:59.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji6m00ku0jxlusw0v9u6"},{"title":"NOIP2014 - Hash","date":"2016-10-19T08:25:00.000Z","_content":"\n\n\n$$ a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $$\n\n $ [1, m] $ \n\n<!-- more -->\n\n### \n[BZOJ 3751](http://www.lydsy.com/JudgeOnline/problem.php?id=3751)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n $ f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $ $ p $  $ f(x) = 0 $ $ f(x) \\bmod p = 0 $\n\n $ f(x) \\bmod p = 0 $  $ x $ $ n $  $ x' = x + kp \\leq m $  $ p' $  $ f(x') \\bmod p' = 0 $ $ x' $ \n\n $ O(np + n \\frac{nm}{p}) $ $ p \\approx \\sqrt {nm} $  $ O(n \\sqrt{nm}) $\n\n### \n```c++\n#include <cstdio>\n#include <list>\n\nconst int MAXN = 100;\nconst int MAXLEN = 10000 + 1;\nconst int MAXM = 1000000;\nconst int MOD = 21893;\nconst int MOD2 = 18341629;\n\nint parse(const char *s, const int mod) {\n\tint res = 0, sgn = 1;\n\tif (*s == '-') s++, sgn = -1;\n\tfor (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod;\n\treturn res * sgn;\n}\n\nint main() {\n\tstatic char s[MAXN + 1][MAXLEN + 1];\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 0; i <= n; i++) a[i] = parse(s[i], MOD);\n\n\tstd::list<int> roots;\n\tfor (int i = 1; i < MOD; i++) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD;\n\t\t\tpow = pow * i % MOD;\n\t\t}\n\t\t\n\t\tif (val == 0) {\n\t\t\tfor (int j = i; j <= m; j += MOD) roots.push_back(j);\n\t\t}\n\t}\n\n\tfor (int j = 0; j <= n; j++) a[j] = parse(s[j], MOD2);\n\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD2;\n\t\t\tpow = pow * *it % MOD2;\n\t\t}\n\n\t\tif (val != 0) it = roots.erase(it);\n\t\telse it++;\n\t}\n\n\tprintf(\"%lu\\n\", roots.size());\n\troots.sort();\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","source":"_posts/noip2014-equation.md","raw":"title: NOIP2014 - Hash\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BZOJ\n  - Hash\n  - \npermalink: noip2014-equation\ndate: 2016-10-19 16:25:00\n---\n\n\n\n$$ a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $$\n\n $ [1, m] $ \n\n<!-- more -->\n\n### \n[BZOJ 3751](http://www.lydsy.com/JudgeOnline/problem.php?id=3751)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n $ f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $ $ p $  $ f(x) = 0 $ $ f(x) \\bmod p = 0 $\n\n $ f(x) \\bmod p = 0 $  $ x $ $ n $  $ x' = x + kp \\leq m $  $ p' $  $ f(x') \\bmod p' = 0 $ $ x' $ \n\n $ O(np + n \\frac{nm}{p}) $ $ p \\approx \\sqrt {nm} $  $ O(n \\sqrt{nm}) $\n\n### \n```c++\n#include <cstdio>\n#include <list>\n\nconst int MAXN = 100;\nconst int MAXLEN = 10000 + 1;\nconst int MAXM = 1000000;\nconst int MOD = 21893;\nconst int MOD2 = 18341629;\n\nint parse(const char *s, const int mod) {\n\tint res = 0, sgn = 1;\n\tif (*s == '-') s++, sgn = -1;\n\tfor (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod;\n\treturn res * sgn;\n}\n\nint main() {\n\tstatic char s[MAXN + 1][MAXLEN + 1];\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 0; i <= n; i++) a[i] = parse(s[i], MOD);\n\n\tstd::list<int> roots;\n\tfor (int i = 1; i < MOD; i++) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD;\n\t\t\tpow = pow * i % MOD;\n\t\t}\n\t\t\n\t\tif (val == 0) {\n\t\t\tfor (int j = i; j <= m; j += MOD) roots.push_back(j);\n\t\t}\n\t}\n\n\tfor (int j = 0; j <= n; j++) a[j] = parse(s[j], MOD2);\n\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD2;\n\t\t\tpow = pow * *it % MOD2;\n\t\t}\n\n\t\tif (val != 0) it = roots.erase(it);\n\t\telse it++;\n\t}\n\n\tprintf(\"%lu\\n\", roots.size());\n\troots.sort();\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","slug":"noip2014-equation","published":1,"updated":"2016-10-19T08:26:26.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji6s00l00jxl0ksb0u9r"},{"title":"NOIP2014 -  DP","date":"2016-10-08T09:06:00.000Z","_content":"\n*  $ n $ $ m $  $ k $ \n* \n*  $ 1 $ $ X $ $ Y $ $ X $  $ Y $ \n*  $ 0 $  $ m $ \n\n,\n\n<!-- more -->\n\n### \n[COGS 1805](http://cogs.pro/cogs/problem/problem.php?pid=1805)  \n[CodeVS 3729](http://codevs.cn/problem/3729/)\n\n### \n $ f(i, j) $  $ i $ $ j $ \n\n   $ i - 1 $  $ k $  $ k \\times X $  $ Y $  $ k $\n\n$$\nf(i, j) = \\min(\\min\\limits_k \\{ f(i - 1, j - kX) \\} + k, f(i - 1, j + Y))\n$$\n\n $ O(m) $ $ O(nm ^ 2) $\n\n $ k $  $ k - 1 $  $ k $  $ j $ $ k - 1 $  $ j - X $\n\n$$ f(i, j) = \\min(f(i - 1, j - X) + 1, f(i, j - X) + 1) $$\n\n\n\n   $ k - 1 $  $ k $  $ k $  $ k - 1 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n\tbool exist;\n\tint top, bottom;\n} a[MAXN + 1];\n\nint n, m, k, up[MAXN + 1], down[MAXN + 1];\n\ntemplate <typename T> bool cmin(T &a, const T &b) {\n\treturn (a > b) ? (a = b, true) : false;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &up[i], &down[i]);\n\t}\n\n\twhile (k--) {\n\t\tint i;\n\t\tscanf(\"%d\", &i);\n\t\tscanf(\"%d %d\", &a[i].bottom, &a[i].top);\n\t\ta[i].exist = true;\n\t}\n\n\tstatic int f[MAXN + 1][MAXM + 1];\n\t// for (int i = 1; i <= m; i++) f[0][i] = 0;\n\tf[0][0] = INT_MAX;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = INT_MAX;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tf[i][j] = INT_MAX;\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\n\t\t\tif (j >= up[i - 1]) {\n\t\t\t\tif (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1);\n\t\t\t\tif (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (j <= m - down[i - 1]) {\n\t\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t\t}\n\t\t\t*/\n\n#ifdef DBG\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n#endif\n\t\t}\n\n\t\tfor (int j = 1; j <= m - down[i - 1]; j++) {\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t}\n\n\t\tf[i][m] = INT_MAX;\n\t\t// if (a[i].exist) continue;\n\t\tfor (int k = m - up[i - 1]; k <= m; k++) {\n\t\t\tif (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n\t\t\tif (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n\t\t}\n\n\t\tif (a[i].exist) for (int j = 1; j <= m; j++) if (j <= a[i].bottom || j >= a[i].top) f[i][j] = INT_MAX;\n\t}\n\n\tint clicks = INT_MAX;\n\tfor (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n\n\tif (clicks != INT_MAX) {\n\t\tprintf(\"1\\n%d\\n\", clicks);\n\t} else {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (f[i][j] != INT_MAX) {\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos != -1) break;\n\t\t}\n\n\t\tint pipeCnt = 0;\n\t\tfor (int i = 1; i <= pos; i++) if (a[i].exist) pipeCnt++;\n\n\t\tprintf(\"0\\n%d\\n\", pipeCnt);\n\t}\n\n\treturn 0;\n}\n```\t\n","source":"_posts/noip2014-bird.md","raw":"title: NOIP2014 -  DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - COGS\n  - DP\n  -  DP\npermalink: noip2014-bird\ndate: 2016-10-08 17:06:00\n---\n\n*  $ n $ $ m $  $ k $ \n* \n*  $ 1 $ $ X $ $ Y $ $ X $  $ Y $ \n*  $ 0 $  $ m $ \n\n,\n\n<!-- more -->\n\n### \n[COGS 1805](http://cogs.pro/cogs/problem/problem.php?pid=1805)  \n[CodeVS 3729](http://codevs.cn/problem/3729/)\n\n### \n $ f(i, j) $  $ i $ $ j $ \n\n   $ i - 1 $  $ k $  $ k \\times X $  $ Y $  $ k $\n\n$$\nf(i, j) = \\min(\\min\\limits_k \\{ f(i - 1, j - kX) \\} + k, f(i - 1, j + Y))\n$$\n\n $ O(m) $ $ O(nm ^ 2) $\n\n $ k $  $ k - 1 $  $ k $  $ j $ $ k - 1 $  $ j - X $\n\n$$ f(i, j) = \\min(f(i - 1, j - X) + 1, f(i, j - X) + 1) $$\n\n\n\n   $ k - 1 $  $ k $  $ k $  $ k - 1 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n\tbool exist;\n\tint top, bottom;\n} a[MAXN + 1];\n\nint n, m, k, up[MAXN + 1], down[MAXN + 1];\n\ntemplate <typename T> bool cmin(T &a, const T &b) {\n\treturn (a > b) ? (a = b, true) : false;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &up[i], &down[i]);\n\t}\n\n\twhile (k--) {\n\t\tint i;\n\t\tscanf(\"%d\", &i);\n\t\tscanf(\"%d %d\", &a[i].bottom, &a[i].top);\n\t\ta[i].exist = true;\n\t}\n\n\tstatic int f[MAXN + 1][MAXM + 1];\n\t// for (int i = 1; i <= m; i++) f[0][i] = 0;\n\tf[0][0] = INT_MAX;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = INT_MAX;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tf[i][j] = INT_MAX;\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\n\t\t\tif (j >= up[i - 1]) {\n\t\t\t\tif (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1);\n\t\t\t\tif (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (j <= m - down[i - 1]) {\n\t\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t\t}\n\t\t\t*/\n\n#ifdef DBG\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n#endif\n\t\t}\n\n\t\tfor (int j = 1; j <= m - down[i - 1]; j++) {\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t}\n\n\t\tf[i][m] = INT_MAX;\n\t\t// if (a[i].exist) continue;\n\t\tfor (int k = m - up[i - 1]; k <= m; k++) {\n\t\t\tif (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n\t\t\tif (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n\t\t}\n\n\t\tif (a[i].exist) for (int j = 1; j <= m; j++) if (j <= a[i].bottom || j >= a[i].top) f[i][j] = INT_MAX;\n\t}\n\n\tint clicks = INT_MAX;\n\tfor (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n\n\tif (clicks != INT_MAX) {\n\t\tprintf(\"1\\n%d\\n\", clicks);\n\t} else {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (f[i][j] != INT_MAX) {\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos != -1) break;\n\t\t}\n\n\t\tint pipeCnt = 0;\n\t\tfor (int i = 1; i <= pos; i++) if (a[i].exist) pipeCnt++;\n\n\t\tprintf(\"0\\n%d\\n\", pipeCnt);\n\t}\n\n\treturn 0;\n}\n```\t\n","slug":"noip2014-bird","published":1,"updated":"2016-11-08T12:07:12.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji7000l80jxl8rg8yhez"},{"title":"NOIP2013 - BFS + SPFA","date":"2016-11-13T09:00:00.000Z","_content":"\n1.  $ n \\times m $  $ n\\times m $  $ n \\times m - 1 $  $ 1 \\times 1 $ \n2. \n3. \n\n $ q $  $ i $  $ EX_i $  $ EY_i $  $ SX_i $  $ SY_i $  $ TX_i $  $ TY_i $ \n\n B  B \n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n  \n\n $ f(i, j, a, b) $  $ (i, j) $ $ a $  $ b $ \n\n\n\n1. \n2. \n\n $ (i, j, k) $    $ (i, j) $  $ k $  $ f(i, j, a, b) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXQ = 500;\nconst int di[] = { 1, 0, 0, -1 };\nconst int dj[] = { 0, 1, -1, 0 };\n\nint n, m;\n\nstruct Node {\n\tbool invalid;\n\tint cost[4][4];\n\tint dist;    // BFS prepare\n\tstruct {\n\t\tint dist;\n\t\tbool inq;\n\t} v[4];      // SPFA\n} map[MAXN + 1][MAXN + 1];\n\nstruct Point {\n\tint i, j;\n\n\tPoint() {}\n\tPoint(int i, int j) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n\n\tbool valid() const {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tbool operator==(const Point &other) const {\n\t\treturn i == other.i && j == other.j;\n\t}\n};\n\nstruct Status {\n\tPoint p;\n\tint d;\n\n\tStatus(Point p, int d) : p(p), d(d) {}\n};\n\ninline int bfs(Point s, Point t, Point p) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmap[i][j].dist = INT_MAX;\n\t\t}\n\t}\n\n\tstd::queue<Point> q;\n\ts->dist = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return v->dist;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\n\t\t\tif (u->invalid || u == p) continue;\n\n\t\t\tif (u->dist > v->dist + 1) {\n\t\t\t\tu->dist = v->dist + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (map[i][j].invalid) continue;\n\n\t\t\tPoint v(i, j);\n\t\t\tfor (int s = 0; s < 4; s++) {\n\t\t\t\tPoint ps = v.move(s);\n\n\t\t\t\tfor (int t = s + 1; t < 4; t++) {\n\t\t\t\t\tPoint pt = v.move(t);\n\n\t\t\t\t\tif (!ps.valid() || ps->invalid || !pt.valid() || pt->invalid) v->cost[s][t] = v->cost[t][s] = INT_MAX;\n\t\t\t\t\telse v->cost[s][t] = v->cost[t][s] = bfs(ps, pt, v);\n\n#ifdef DBG\n\t\t\t\t\tprintf(\"[%d, %d] %d => %d = %d\\n\", v.i, v.j, s, t, v->cost[s][t]);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int spfa(Status s, Point t) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmap[i][j].v[k].dist = INT_MAX;\n\t\t\t\tmap[i][j].v[k].inq = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::queue<Status> q;\n\tq.push(s);\n\ts.p->v[s.d].dist = 0;\n\n\twhile (!q.empty()) {\n\t\tStatus status = q.front();\n\t\tq.pop();\n\n\t\tPoint &v = status.p;\n\t\tint &d = status.d;\n\n\t\tv->v[d].inq = false;\n\n\t\t// Move the empty block\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i == d || v->cost[d][i] == INT_MAX) continue;\n\n\t\t\tif (v->v[i].dist > v->v[d].dist + v->cost[d][i]) {\n\t\t\t\tv->v[i].dist = v->v[d].dist + v->cost[d][i];\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d]->v[%d]->dist = %d\\n\", v.i, v.j, i, v->v[i].dist);\n#endif\n\t\t\t\tif (!v->v[i].inq) {\n\t\t\t\t\tv->v[i].inq = true;\n\t\t\t\t\tq.push(Status(v, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap\n\t\tif (v->v[d].dist != INT_MAX) {\n\t\t\tPoint u = v.move(d);\n\t\t\tint t = 3 - d;\n\t\t\tif (u->v[t].dist > v->v[d].dist + 1) {\n\t\t\t\tu->v[t].dist = v->v[d].dist + 1;\n\t\t\t\tif (!u->v[t].inq) {\n\t\t\t\t\tu->v[t].inq = true;\n\t\t\t\t\tq.push(Status(u, t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INT_MAX;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = std::min(res, t->v[i].dist);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmap[i][j].invalid = (x == 0);\n\t\t}\n\t}\n\n\tprepare();\n\n\twhile (q--) {\n\t\tPoint empty, s, t;\n\t\tscanf(\"%d %d %d %d %d %d\", &empty.i, &empty.j, &s.i, &s.j, &t.i, &t.j);\n\n\t\tif (s == t) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v = s.move(i);\n\t\t\tif (!v.valid()) continue;\n\n\t\t\tint d1 = bfs(empty, v, s);\n\t\t\tif (d1 == INT_MAX) continue;\n\n\t\t\tint d2 = spfa(Status(s, i), t);\n\t\t\tif (d2 == INT_MAX) continue;\n\n\t\t\tans = std::min(ans, d1 + d2);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2013-puzzle.md","raw":"title: NOIP2013 - BFS + SPFA\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \n  - SPFA\n  - BFS\npermalink: noip2013-puzzle\ndate: 2016-11-13 17:00:00\n---\n\n1.  $ n \\times m $  $ n\\times m $  $ n \\times m - 1 $  $ 1 \\times 1 $ \n2. \n3. \n\n $ q $  $ i $  $ EX_i $  $ EY_i $  $ SX_i $  $ SY_i $  $ TX_i $  $ TY_i $ \n\n B  B \n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n  \n\n $ f(i, j, a, b) $  $ (i, j) $ $ a $  $ b $ \n\n\n\n1. \n2. \n\n $ (i, j, k) $    $ (i, j) $  $ k $  $ f(i, j, a, b) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXQ = 500;\nconst int di[] = { 1, 0, 0, -1 };\nconst int dj[] = { 0, 1, -1, 0 };\n\nint n, m;\n\nstruct Node {\n\tbool invalid;\n\tint cost[4][4];\n\tint dist;    // BFS prepare\n\tstruct {\n\t\tint dist;\n\t\tbool inq;\n\t} v[4];      // SPFA\n} map[MAXN + 1][MAXN + 1];\n\nstruct Point {\n\tint i, j;\n\n\tPoint() {}\n\tPoint(int i, int j) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n\n\tbool valid() const {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tbool operator==(const Point &other) const {\n\t\treturn i == other.i && j == other.j;\n\t}\n};\n\nstruct Status {\n\tPoint p;\n\tint d;\n\n\tStatus(Point p, int d) : p(p), d(d) {}\n};\n\ninline int bfs(Point s, Point t, Point p) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmap[i][j].dist = INT_MAX;\n\t\t}\n\t}\n\n\tstd::queue<Point> q;\n\ts->dist = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return v->dist;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\n\t\t\tif (u->invalid || u == p) continue;\n\n\t\t\tif (u->dist > v->dist + 1) {\n\t\t\t\tu->dist = v->dist + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (map[i][j].invalid) continue;\n\n\t\t\tPoint v(i, j);\n\t\t\tfor (int s = 0; s < 4; s++) {\n\t\t\t\tPoint ps = v.move(s);\n\n\t\t\t\tfor (int t = s + 1; t < 4; t++) {\n\t\t\t\t\tPoint pt = v.move(t);\n\n\t\t\t\t\tif (!ps.valid() || ps->invalid || !pt.valid() || pt->invalid) v->cost[s][t] = v->cost[t][s] = INT_MAX;\n\t\t\t\t\telse v->cost[s][t] = v->cost[t][s] = bfs(ps, pt, v);\n\n#ifdef DBG\n\t\t\t\t\tprintf(\"[%d, %d] %d => %d = %d\\n\", v.i, v.j, s, t, v->cost[s][t]);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int spfa(Status s, Point t) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmap[i][j].v[k].dist = INT_MAX;\n\t\t\t\tmap[i][j].v[k].inq = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::queue<Status> q;\n\tq.push(s);\n\ts.p->v[s.d].dist = 0;\n\n\twhile (!q.empty()) {\n\t\tStatus status = q.front();\n\t\tq.pop();\n\n\t\tPoint &v = status.p;\n\t\tint &d = status.d;\n\n\t\tv->v[d].inq = false;\n\n\t\t// Move the empty block\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i == d || v->cost[d][i] == INT_MAX) continue;\n\n\t\t\tif (v->v[i].dist > v->v[d].dist + v->cost[d][i]) {\n\t\t\t\tv->v[i].dist = v->v[d].dist + v->cost[d][i];\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d]->v[%d]->dist = %d\\n\", v.i, v.j, i, v->v[i].dist);\n#endif\n\t\t\t\tif (!v->v[i].inq) {\n\t\t\t\t\tv->v[i].inq = true;\n\t\t\t\t\tq.push(Status(v, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap\n\t\tif (v->v[d].dist != INT_MAX) {\n\t\t\tPoint u = v.move(d);\n\t\t\tint t = 3 - d;\n\t\t\tif (u->v[t].dist > v->v[d].dist + 1) {\n\t\t\t\tu->v[t].dist = v->v[d].dist + 1;\n\t\t\t\tif (!u->v[t].inq) {\n\t\t\t\t\tu->v[t].inq = true;\n\t\t\t\t\tq.push(Status(u, t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INT_MAX;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = std::min(res, t->v[i].dist);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmap[i][j].invalid = (x == 0);\n\t\t}\n\t}\n\n\tprepare();\n\n\twhile (q--) {\n\t\tPoint empty, s, t;\n\t\tscanf(\"%d %d %d %d %d %d\", &empty.i, &empty.j, &s.i, &s.j, &t.i, &t.j);\n\n\t\tif (s == t) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v = s.move(i);\n\t\t\tif (!v.valid()) continue;\n\n\t\t\tint d1 = bfs(empty, v, s);\n\t\t\tif (d1 == INT_MAX) continue;\n\n\t\t\tint d2 = spfa(Status(s, i), t);\n\t\t\tif (d2 == INT_MAX) continue;\n\n\t\t\tans = std::min(ans, d1 + d2);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noip2013-puzzle","published":1,"updated":"2016-11-13T10:35:58.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji7500lf0jxl11ef297x"},{"title":"NOIP2013 - ","date":"2016-10-13T08:15:00.000Z","_content":"\n $ n $ \n\n$$ \\sum\\limits_{i = 1} ^ n (a_i - b_i) ^ 2 $$\n\n $ a_i $  $ i $ $ b_i $  $ i $ \n\n\n\n<!-- more -->\n\n### \n[CodeVS 3286](http://codevs.cn/problem/3286/)\n\n### \n $ k \\in [1, n] $ $ k $  $ k $ \n\n $ a $ $ i $  $ k $  $ k $  $ j $  $ a[i] = j $ $ a $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Match {\n\tint index, rank, value, w;\n} a[MAXN + 1], b[MAXN + 1];\n\nint n;\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n} bit;\n\ninline bool byVal(const Match &a, const Match &b) {\n\treturn a.value < b.value;\n}\n\ninline bool byID(const Match &a, const Match &b) {\n\treturn a.index < b.index;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].value), a[i].index = i;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &b[i].value), b[i].index = i;\n\n\tstd::sort(a + 1, a + n + 1, &byVal);\n\tstd::sort(b + 1, b + n + 1, &byVal);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].rank = b[i].rank = i;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i].w = a[i].index;\n\t}\n\n\tstd::sort(b + 1, b + n + 1, &byID);\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d\\n\", b[i].w);\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += bit.query(b[i].w + 1, n);\n\t\tbit.update(b[i].w, 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans % MOD);\n\n\treturn 0;\n}\n```","source":"_posts/noip2013-match.md","raw":"title: NOIP2013 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \npermalink: noip2013-match\ndate: 2016-10-13 16:15:00\n---\n\n $ n $ \n\n$$ \\sum\\limits_{i = 1} ^ n (a_i - b_i) ^ 2 $$\n\n $ a_i $  $ i $ $ b_i $  $ i $ \n\n\n\n<!-- more -->\n\n### \n[CodeVS 3286](http://codevs.cn/problem/3286/)\n\n### \n $ k \\in [1, n] $ $ k $  $ k $ \n\n $ a $ $ i $  $ k $  $ k $  $ j $  $ a[i] = j $ $ a $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Match {\n\tint index, rank, value, w;\n} a[MAXN + 1], b[MAXN + 1];\n\nint n;\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n} bit;\n\ninline bool byVal(const Match &a, const Match &b) {\n\treturn a.value < b.value;\n}\n\ninline bool byID(const Match &a, const Match &b) {\n\treturn a.index < b.index;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].value), a[i].index = i;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &b[i].value), b[i].index = i;\n\n\tstd::sort(a + 1, a + n + 1, &byVal);\n\tstd::sort(b + 1, b + n + 1, &byVal);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].rank = b[i].rank = i;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i].w = a[i].index;\n\t}\n\n\tstd::sort(b + 1, b + n + 1, &byID);\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d\\n\", b[i].w);\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += bit.query(b[i].w + 1, n);\n\t\tbit.update(b[i].w, 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans % MOD);\n\n\treturn 0;\n}\n```","slug":"noip2013-match","published":1,"updated":"2016-11-13T08:15:38.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji7a00lo0jxl3as39urf"},{"title":"NOIP2013 - ","date":"2016-10-13T08:42:00.000Z","_content":"\n\n\n $ h_1, h_2, \\ldots, h_n $ $ g_1, g_2, \\ldots, g_m $\n\n A $ 1 < i < \\frac{m}{2} $$ g_{2i} > g_{2i - 1} $  $ g_{2i} > g_{2i + 1} $  \n B $ 1 < i < \\frac{m}{2} $$ g_{2i} < g_{2i - 1} $  $ g_{2i} < g_{2i + 1} $\n\n $ m = 1 $  $ m > 1 $   \n\n\n<!-- more -->\n\n### \n[CodeVS 3289](http://codevs.cn/problem/3289/)\n\n### \n\n\n $ x $  $ y $ $ z $ \n\n $ x < y $  $ y > z $$ x > y $  $ y < z $ $ z $  $ + 1 $\n\n $ x < y $  $ y < z $$ x > y $  $ y > z $ $ z $  $ y $ $ z $  $ k < y < z $  $ k $  $ z $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint prev, curr, ans = 1;\n\tscanf(\"%d\", &curr);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (x == curr) continue;\n\n\t\tif (ans == 1 || (prev < curr) != (curr < x)) {\n\t\t\tans++;\n\t\t\tprev = curr;\n\t\t\tcurr = x;\n\t\t} else {\n\t\t\tif (prev < curr) curr = std::max(curr, x);\n\t\t\telse curr = std::min(curr, x);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/noip2013-flower.md","raw":"title: NOIP2013 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \npermalink: noip2013-flower\ndate: 2016-10-13 16:42:00\n---\n\n\n\n $ h_1, h_2, \\ldots, h_n $ $ g_1, g_2, \\ldots, g_m $\n\n A $ 1 < i < \\frac{m}{2} $$ g_{2i} > g_{2i - 1} $  $ g_{2i} > g_{2i + 1} $  \n B $ 1 < i < \\frac{m}{2} $$ g_{2i} < g_{2i - 1} $  $ g_{2i} < g_{2i + 1} $\n\n $ m = 1 $  $ m > 1 $   \n\n\n<!-- more -->\n\n### \n[CodeVS 3289](http://codevs.cn/problem/3289/)\n\n### \n\n\n $ x $  $ y $ $ z $ \n\n $ x < y $  $ y > z $$ x > y $  $ y < z $ $ z $  $ + 1 $\n\n $ x < y $  $ y < z $$ x > y $  $ y > z $ $ z $  $ y $ $ z $  $ k < y < z $  $ k $  $ z $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint prev, curr, ans = 1;\n\tscanf(\"%d\", &curr);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (x == curr) continue;\n\n\t\tif (ans == 1 || (prev < curr) != (curr < x)) {\n\t\t\tans++;\n\t\t\tprev = curr;\n\t\t\tcurr = x;\n\t\t} else {\n\t\t\tif (prev < curr) curr = std::max(curr, x);\n\t\t\telse curr = std::min(curr, x);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"noip2013-flower","published":1,"updated":"2016-11-13T08:42:45.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji7f00lv0jxl2nct5vvp"},{"title":"NOIP2012 - ","date":"2016-01-19T13:20:19.000Z","_content":"\n `x`  $ax  1 ({\\rm mod} \\ b)$ \n\n<!-- more -->\n\n### \n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### \n `x`  `b` `b` \n\n### \n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-mod.md","raw":"title: NOIP2012 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Tyvj\n  - \n  - EXGCD\n  - \npermalink: noip2012-mod\ndate: 2016-01-19 21:20:19\n---\n\n `x`  $ax  1 ({\\rm mod} \\ b)$ \n\n<!-- more -->\n\n### \n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### \n `x`  `b` `b` \n\n### \n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","slug":"noip2012-mod","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji7i00m00jxlx7op7ycf"},{"title":"NOIP2012 - ","date":"2016-11-13T09:14:00.000Z","_content":"\n A  B  $ 1 $  $ N $  $ i $  $ H_i $ $ i $  $ j $  $ d(i, j) $  $ d(i, j) = |H_i  H_j| $\n\n A  B  A  $ S $  $ X $  A  B  B  A  $ X $ \n\n A \n\n1.  $ X = X_0 $ A  B  B  $ 0 $ A  B \n2.  $ X = X_i $  $ S_i $ A  B \n\n<!-- more -->\n\n### \n[CodeVS 1199](http://codevs.cn/problem/1199/)\n\n### \n +  A  B \n\n $ f(k, i, j) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $ $ g(k, i, j, l) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $  A$ l = 0 $ B$ l = 1 $ $ l = 2 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\nconst int MAXM = 10000;\n\nstruct Node {\n\tlong long x;\n\tNode *nextA, *nextB;\n\tstd::list<Node *>::iterator it;\n} N[MAXN + 1];\n\nint n, logn, f[2][MAXN + 1][MAXN_LOG + 1];\nlong long g[2][MAXN + 1][MAXN_LOG + 1][3];\n\ninline bool compareNode(Node *a, Node *b) {\n\treturn a->x < b->x;\n}\n\ninline bool comparePair(const std::pair<long long, Node *> &a, const std::pair<long long, Node *> &b) {\n\tif (a.first == b.first) return a.second->x < b.second->x;\n\telse return a.first < b.first;\n}\n\ninline void prepare() {\n\tstd::list<Node *> list;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlist.push_back(&N[i]);\n\t\tN[i].it = --list.end();\n\t}\n\n\tlist.sort(&compareNode);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tstd::vector< std::pair<long long, Node *> > vec;\n\n\t\tstd::list<Node *>::iterator near;\n\t\tnear = N[i].it, near++;\n\n\t\tif (near != list.end()) {\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (++near != list.end()) {\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tnear = N[i].it;\n\t\tif (near != list.begin()) {\n\t\t\tnear--;\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (near != list.begin()) {\n\t\t\t\tnear--;\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(vec.begin(), vec.end(), comparePair);\n\n\t\tif (vec.size() >= 2) {\n\t\t\tN[i].nextA = vec[1].second;\n#ifdef DBG\n\t\t\tprintf(\"nextA(%lld) = %lld\\n\", N[i].x, N[i].nextA->x);\n#endif\n\t\t} else N[i].nextA = &N[0];\n\n\t\tif (vec.size() >= 1) {\n\t\t\tN[i].nextB = vec[0].second;\n#ifdef DBG\n\t\t\tprintf(\"nextB(%lld) = %lld\\n\", N[i].x, N[i].nextB->x);\n#endif\n\t\t} else N[i].nextB = &N[0];\n\n\t\tlist.erase(N[i].it);\n\t}\n\tN[0].nextA = N[0].nextB = &N[0];\n\n\t// Build graph\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[0][i][0] = N[i].nextA - N;\n\t\tf[0][i][1] = N[i].nextA->nextB - N;\n\t\t\n\t\tf[1][i][0] = N[i].nextB - N;\n\t\tf[1][i][1] = N[i].nextB->nextA - N;\n\n\t\tg[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &N[0] ? 0 : llabs(N[i].x - N[i].nextA->x);\n\t\tg[0][i][0][1] = 0;\n\n\t\tg[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &N[0] ? 0 : llabs(N[i].x - N[i].nextB->x);\n\t\tg[1][i][0][0] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[0][i][1][0] = g[0][i][0][0];\n\t\tg[0][i][1][1] = g[1][N[i].nextA - N][0][1];\n\t\tg[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1];\n\n\t\tg[1][i][1][1] = g[1][i][0][1];\n\t\tg[1][i][1][0] = g[0][N[i].nextB - N][0][0];\n\t\tg[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0];\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 2; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tg[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l];\n\t\t\t\t}\n\t\t\t\tf[k][i][j] = f[k][f[k][i][j - 1]][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int j = 0; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tprintf(\"f(%d, %d, %d) = %d [%lld]\\n\\n\", k, i, j, f[k][i][j], N[f[k][i][j]].x);\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tprintf(\"g(%d, %d, %d, %d) = %lld\\n\", k, i, j, l, g[k][i][j][l]);\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\ninline long long solve(int start, long long limit, long long &sumA, long long &sumB) {\n\tint curr = start;\n\tlong long sum = sumA = sumB = 0;\n\tfor (int i = logn; i >= 1 && curr != 0; i--) {\n\t\twhile (curr && limit >= sum + g[0][curr][i][2]) {\n\t\t\tsum += g[0][curr][i][2];\n\t\t\tsumA += g[0][curr][i][0];\n\t\t\tsumB += g[0][curr][i][1];\n\t\t\tcurr = f[0][curr][i];\n\t\t}\n\t}\n\n\tif (curr && limit >= sum + g[0][curr][0][0]) {\n\t\tsumA += g[0][curr][0][0];\n\t\tsum += g[0][curr][0][0];\n\t}\n\n\treturn sum;\n}\n\ninline int solve(long long limit) {\n\tint ans = 0;\n\tdouble k = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long tmpA, tmpB;\n\t\tsolve(i, limit, tmpA, tmpB);\n\t\tdouble t = static_cast<double>(tmpA) / static_cast<double>(tmpB);\n\t\tif (k == -1 || t < k || (t == k && N[i].x > N[ans].x)) {\n\t\t\tk = t;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].x);\n\n\tprepare();\n\n\tlong long limit;\n\tscanf(\"%lld\", &limit);\n\tprintf(\"%d\\n\", solve(limit));\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint start;\n\t\tlong long limit;\n\t\tscanf(\"%d %lld\", &start, &limit);\n\t\tlong long sumA, sumB;\n\t\tsolve(start, limit, sumA, sumB);\n\t\tprintf(\"%lld %lld\\n\", sumA, sumB);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-drive.md","raw":"title: NOIP2012 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \npermalink: noip2012-drive\ndate: 2016-11-13 17:14:00\n---\n\n A  B  $ 1 $  $ N $  $ i $  $ H_i $ $ i $  $ j $  $ d(i, j) $  $ d(i, j) = |H_i  H_j| $\n\n A  B  A  $ S $  $ X $  A  B  B  A  $ X $ \n\n A \n\n1.  $ X = X_0 $ A  B  B  $ 0 $ A  B \n2.  $ X = X_i $  $ S_i $ A  B \n\n<!-- more -->\n\n### \n[CodeVS 1199](http://codevs.cn/problem/1199/)\n\n### \n +  A  B \n\n $ f(k, i, j) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $ $ g(k, i, j, l) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $  A$ l = 0 $ B$ l = 1 $ $ l = 2 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\nconst int MAXM = 10000;\n\nstruct Node {\n\tlong long x;\n\tNode *nextA, *nextB;\n\tstd::list<Node *>::iterator it;\n} N[MAXN + 1];\n\nint n, logn, f[2][MAXN + 1][MAXN_LOG + 1];\nlong long g[2][MAXN + 1][MAXN_LOG + 1][3];\n\ninline bool compareNode(Node *a, Node *b) {\n\treturn a->x < b->x;\n}\n\ninline bool comparePair(const std::pair<long long, Node *> &a, const std::pair<long long, Node *> &b) {\n\tif (a.first == b.first) return a.second->x < b.second->x;\n\telse return a.first < b.first;\n}\n\ninline void prepare() {\n\tstd::list<Node *> list;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlist.push_back(&N[i]);\n\t\tN[i].it = --list.end();\n\t}\n\n\tlist.sort(&compareNode);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tstd::vector< std::pair<long long, Node *> > vec;\n\n\t\tstd::list<Node *>::iterator near;\n\t\tnear = N[i].it, near++;\n\n\t\tif (near != list.end()) {\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (++near != list.end()) {\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tnear = N[i].it;\n\t\tif (near != list.begin()) {\n\t\t\tnear--;\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (near != list.begin()) {\n\t\t\t\tnear--;\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(vec.begin(), vec.end(), comparePair);\n\n\t\tif (vec.size() >= 2) {\n\t\t\tN[i].nextA = vec[1].second;\n#ifdef DBG\n\t\t\tprintf(\"nextA(%lld) = %lld\\n\", N[i].x, N[i].nextA->x);\n#endif\n\t\t} else N[i].nextA = &N[0];\n\n\t\tif (vec.size() >= 1) {\n\t\t\tN[i].nextB = vec[0].second;\n#ifdef DBG\n\t\t\tprintf(\"nextB(%lld) = %lld\\n\", N[i].x, N[i].nextB->x);\n#endif\n\t\t} else N[i].nextB = &N[0];\n\n\t\tlist.erase(N[i].it);\n\t}\n\tN[0].nextA = N[0].nextB = &N[0];\n\n\t// Build graph\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[0][i][0] = N[i].nextA - N;\n\t\tf[0][i][1] = N[i].nextA->nextB - N;\n\t\t\n\t\tf[1][i][0] = N[i].nextB - N;\n\t\tf[1][i][1] = N[i].nextB->nextA - N;\n\n\t\tg[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &N[0] ? 0 : llabs(N[i].x - N[i].nextA->x);\n\t\tg[0][i][0][1] = 0;\n\n\t\tg[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &N[0] ? 0 : llabs(N[i].x - N[i].nextB->x);\n\t\tg[1][i][0][0] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[0][i][1][0] = g[0][i][0][0];\n\t\tg[0][i][1][1] = g[1][N[i].nextA - N][0][1];\n\t\tg[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1];\n\n\t\tg[1][i][1][1] = g[1][i][0][1];\n\t\tg[1][i][1][0] = g[0][N[i].nextB - N][0][0];\n\t\tg[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0];\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 2; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tg[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l];\n\t\t\t\t}\n\t\t\t\tf[k][i][j] = f[k][f[k][i][j - 1]][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int j = 0; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tprintf(\"f(%d, %d, %d) = %d [%lld]\\n\\n\", k, i, j, f[k][i][j], N[f[k][i][j]].x);\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tprintf(\"g(%d, %d, %d, %d) = %lld\\n\", k, i, j, l, g[k][i][j][l]);\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\ninline long long solve(int start, long long limit, long long &sumA, long long &sumB) {\n\tint curr = start;\n\tlong long sum = sumA = sumB = 0;\n\tfor (int i = logn; i >= 1 && curr != 0; i--) {\n\t\twhile (curr && limit >= sum + g[0][curr][i][2]) {\n\t\t\tsum += g[0][curr][i][2];\n\t\t\tsumA += g[0][curr][i][0];\n\t\t\tsumB += g[0][curr][i][1];\n\t\t\tcurr = f[0][curr][i];\n\t\t}\n\t}\n\n\tif (curr && limit >= sum + g[0][curr][0][0]) {\n\t\tsumA += g[0][curr][0][0];\n\t\tsum += g[0][curr][0][0];\n\t}\n\n\treturn sum;\n}\n\ninline int solve(long long limit) {\n\tint ans = 0;\n\tdouble k = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long tmpA, tmpB;\n\t\tsolve(i, limit, tmpA, tmpB);\n\t\tdouble t = static_cast<double>(tmpA) / static_cast<double>(tmpB);\n\t\tif (k == -1 || t < k || (t == k && N[i].x > N[ans].x)) {\n\t\t\tk = t;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].x);\n\n\tprepare();\n\n\tlong long limit;\n\tscanf(\"%lld\", &limit);\n\tprintf(\"%d\\n\", solve(limit));\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint start;\n\t\tlong long limit;\n\t\tscanf(\"%d %lld\", &start, &limit);\n\t\tlong long sumA, sumB;\n\t\tsolve(start, limit, sumA, sumB);\n\t\tprintf(\"%lld %lld\\n\", sumA, sumB);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noip2012-drive","published":1,"updated":"2016-11-13T09:14:22.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji7n00m80jxlb1jydej2"},{"title":"NOIP2012 -  / ","date":"2016-10-08T08:56:00.000Z","_content":"\n $ n $  $ i $  $ r_i $  $ m $  $ d_j, s_j, t_j $ $ s_j $  $ t_j $  $ s_j $  $ t_j $  $ d_j $  \n\n\n\n<!-- more -->\n\n### \n[COGS 1266](http://cogs.pro/cogs/problem/problem.php?pid=1266)  \n[CodeVS 1217](http://codevs.cn/problem/1217/)\n\n### \n#### \n\n\n 100 ** 95 **\n\n#### \n $ x $ +  $ x $ \n\n 100  100 \n\n### \nTLE\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 1000000;\nconst int MAXR = 1000000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar a[SIZE * sizeof(T)];\n\tT *p;\n\n\tMemoryPool() : p((T *)a) {}\n\n\tT *alloc() {\n\t\treturn p++;\n\t}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, min, lazy;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (lchild) lchild->value += lazy, lchild->min += lazy, lchild->lazy += lazy;\n\t\t\t\tif (rchild) rchild->value += lazy, rchild->min += lazy, rchild->lazy += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tint queryMin(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\t\telse if (l <= this->l && r >= this->r) return min;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tif (lchild) ans = std::min(ans, lchild->queryMin(l, r));\n\t\t\t\tif (rchild) ans = std::min(ans, rchild->queryMin(l, r));\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) value += x, min += x, lazy += x;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tif (lchild) lchild->update(l, r, x);\n\t\t\t\tif (rchild) rchild->update(l, r, x);\n\n\t\t\t\tmin = INT_MAX;\n\t\t\t\tif (lchild) min = std::min(min, lchild->min);\n\t\t\t\tif (rchild) min = std::min(min, rchild->min);\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tstatic MemoryPool<Node, MAXN * 2> pool;\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL);\n\t\telse return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tint queryMin(int l, int r) {\n\t\treturn root->queryMin(l, r);\n\t}\n\n\tvoid update(int l, int r, int x) {\n\t\troot->update(l, r, x);\n\t}\n};\n\nint n, m;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nint main() {\n\tread(n), read(m);\n\n\tSegmentTree segmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tread(x);\n\n\t\tsegmentTree.update(i, i, x);\n\t}\n\n\tint day = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, l, r;\n\t\tread(x), read(l), read(r);\n\n\t\tsegmentTree.update(l, r, -x);\n\t\tif (segmentTree.queryMin(1, n) < 0) {\n\t\t\tday = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (day != 0) printf(\"-1\\n%d\\n\", day);\n\telse puts(\"0\");\n\n\treturn 0;\n}\n```\n\nAC\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e6;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int available[MAXN];\n\tstatic struct Request {\n\t\tint l, r, cnt;\n\t} req[MAXN];\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &available[i]);\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d\", &req[i].cnt, &req[i].l, &req[i].r), req[i].l--, req[i].r--;\n\n\tint l = -1, r = m - 1;\n\tstatic int used[MAXN];\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tbool valid = true;\n\n\t\tfor (int i = 0; i < n; i++) used[i] = 0;\n\t\tfor (int i = 0; i <= mid; i++) {\n\t\t\tused[req[i].l] += req[i].cnt;\n\t\t\tif (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) used[i] += used[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] > available[i]) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"[%d, %d] => %d\\n\", l, r, mid);\n#endif\n\n\t\tif (valid) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\n\tif (l == m - 1) puts(\"0\");\n\telse printf(\"-1\\n%d\\n\", l + 1 + 1);\n\n\treturn 0;\n}\n```","source":"_posts/noip2012-classrooms.md","raw":"title: NOIP2012 -  / \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - COGS\n  - \n  - \n  - \npermalink: noip2012-classrooms\ndate: 2016-10-08 16:56:00\n---\n\n $ n $  $ i $  $ r_i $  $ m $  $ d_j, s_j, t_j $ $ s_j $  $ t_j $  $ s_j $  $ t_j $  $ d_j $  \n\n\n\n<!-- more -->\n\n### \n[COGS 1266](http://cogs.pro/cogs/problem/problem.php?pid=1266)  \n[CodeVS 1217](http://codevs.cn/problem/1217/)\n\n### \n#### \n\n\n 100 ** 95 **\n\n#### \n $ x $ +  $ x $ \n\n 100  100 \n\n### \nTLE\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 1000000;\nconst int MAXR = 1000000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar a[SIZE * sizeof(T)];\n\tT *p;\n\n\tMemoryPool() : p((T *)a) {}\n\n\tT *alloc() {\n\t\treturn p++;\n\t}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, min, lazy;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (lchild) lchild->value += lazy, lchild->min += lazy, lchild->lazy += lazy;\n\t\t\t\tif (rchild) rchild->value += lazy, rchild->min += lazy, rchild->lazy += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tint queryMin(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\t\telse if (l <= this->l && r >= this->r) return min;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tif (lchild) ans = std::min(ans, lchild->queryMin(l, r));\n\t\t\t\tif (rchild) ans = std::min(ans, rchild->queryMin(l, r));\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) value += x, min += x, lazy += x;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tif (lchild) lchild->update(l, r, x);\n\t\t\t\tif (rchild) rchild->update(l, r, x);\n\n\t\t\t\tmin = INT_MAX;\n\t\t\t\tif (lchild) min = std::min(min, lchild->min);\n\t\t\t\tif (rchild) min = std::min(min, rchild->min);\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tstatic MemoryPool<Node, MAXN * 2> pool;\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL);\n\t\telse return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tint queryMin(int l, int r) {\n\t\treturn root->queryMin(l, r);\n\t}\n\n\tvoid update(int l, int r, int x) {\n\t\troot->update(l, r, x);\n\t}\n};\n\nint n, m;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nint main() {\n\tread(n), read(m);\n\n\tSegmentTree segmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tread(x);\n\n\t\tsegmentTree.update(i, i, x);\n\t}\n\n\tint day = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, l, r;\n\t\tread(x), read(l), read(r);\n\n\t\tsegmentTree.update(l, r, -x);\n\t\tif (segmentTree.queryMin(1, n) < 0) {\n\t\t\tday = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (day != 0) printf(\"-1\\n%d\\n\", day);\n\telse puts(\"0\");\n\n\treturn 0;\n}\n```\n\nAC\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e6;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int available[MAXN];\n\tstatic struct Request {\n\t\tint l, r, cnt;\n\t} req[MAXN];\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &available[i]);\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d\", &req[i].cnt, &req[i].l, &req[i].r), req[i].l--, req[i].r--;\n\n\tint l = -1, r = m - 1;\n\tstatic int used[MAXN];\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tbool valid = true;\n\n\t\tfor (int i = 0; i < n; i++) used[i] = 0;\n\t\tfor (int i = 0; i <= mid; i++) {\n\t\t\tused[req[i].l] += req[i].cnt;\n\t\t\tif (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) used[i] += used[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] > available[i]) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"[%d, %d] => %d\\n\", l, r, mid);\n#endif\n\n\t\tif (valid) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\n\tif (l == m - 1) puts(\"0\");\n\telse printf(\"-1\\n%d\\n\", l + 1 + 1);\n\n\treturn 0;\n}\n```","slug":"noip2012-classrooms","published":1,"updated":"2016-10-08T09:04:11.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji7r00md0jxlki46vz8z"},{"title":"NOIP2012 -  +  + ","date":"2016-11-13T09:44:00.000Z","_content":"\nH  $ n $  $ n $  $ n - 1 $ $ 1 $ \n\nH \n\n H \n\n\n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n $ t $ $ t $ \n\n****\n\n $ X $  $ Y $ \n\n $ X $  $ Y $ $ X $  $ Y $  $ X $  $ Y $ \n\n $ X $  $ Y $  $ X $  $ Y $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <list>\n\nconst int MAXN = 50000;\nconst int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tbool visited, settled, childSettled;\n\tstd::vector<int> arrived;\n} N[MAXN + 1], *seq[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tint w;\n\tbool visited;\n\tstd::list<Edge *>::iterator it;\n\n\tEdge(Node *s, Node *t, int w) : s(s), t(t), next(s->e), w(w) {}\n};\n\ninline void addEdge(int s, int t, int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, m, a[MAXN + 1], logn;\n\nint f[MAXN + 1][MAXN_LOG + 1];\nlong long g[MAXN + 1][MAXN_LOG + 1];\n\ninline void prepare() {\n\tstd::queue<Node *> q;\n\n\tN[1].visited = true;\n\tf[1][0] = 1;\n\tg[1][0] = 0;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\tf[e->t - N][0] = v - N;\n\t\t\t\tg[e->t - N][0] = e->w;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n}\n\ninline bool compare(Edge *a, Edge *b) {\n\treturn a->w < b->w;\n}\n\ninline bool check(long long limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].arrived.clear();\n\t\tN[i].settled = false;\n\t\tN[i].childSettled = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = a[i];\n\n\t\tlong long dist = 0;\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (dist + g[u][j] <= limit && f[u][j] != 1) {\n\t\t\t\tdist += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\n\t\tN[u].arrived.push_back(limit - dist);\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (seq[i]->e->next || i == 1) { // It's not a leaf\n\t\t\tseq[i]->childSettled = true;\n\t\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\t\tif (e->t == seq[i]->parent) continue;\n\n\t\t\t\tif (!e->t->settled) {\n\t\t\t\t\tseq[i]->childSettled = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d, settled = %d\\n\", seq[i] - N, seq[i]->childSettled, seq[i]->settled);\n#endif\n\n\t\tseq[i]->settled = seq[i]->childSettled;\n\n\t\tif (seq[i]->arrived.size()) {\n\t\t\tseq[i]->settled = true;\n\t\t}\n\t}\n\n\tif (N[1].settled) return true;\n\n\tstd::list< std::pair<int, Edge *> > atRoot;\n\tstd::list<Edge *> needSettle;\n\tfor (Edge *e = N[1].e; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d\\n\", e->t - N, e->t->childSettled);\n#endif\n\n\t\tstd::vector<int> &vec = e->t->arrived;\n\t\tstd::sort(vec.begin(), vec.end());\n\n\t\tbool remain = e->t->childSettled;\n\t\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i] >= e->w) atRoot.push_back(std::make_pair(vec[i] - e->w, e));\n\t\t\telse remain = true;\n\t\t}\n\n\t\tif (remain) {\n\t\t\te->visited = true;\n\t\t} else {\n\t\t\tneedSettle.push_back(e);\n\t\t\te->it = --needSettle.end();\n\t\t\te->visited = false;\n\t\t}\n\t}\n\n\tatRoot.sort();\n\tneedSettle.sort(&compare);\n\n#ifdef DBG\n\tstd::vector< std::pair<int, Edge *> > _atRoot(atRoot.begin(), atRoot.end());\n\tstd::vector<Edge *> _needSettle(needSettle.begin(), needSettle.end());\n#endif\n\t// std::sort(needSettle.begin(), needSettle.end(), &compare);\n\n\tfor (std::list< std::pair<int, Edge *> >::iterator it = atRoot.begin(); it != atRoot.end(); it++) {\n\t\tif (needSettle.empty()) break;\n\t\tif (!it->second->visited) {\n\t\t\tit->second->visited = true;\n\t\t\tneedSettle.erase(it->second->it);\n\t\t} else {\n\t\t\tif (needSettle.front()->w <= it->first) {\n\t\t\t\tneedSettle.front()->visited = true;\n\t\t\t\tneedSettle.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSettle.empty();\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\tsum += w;\n\t\taddEdge(u, v, w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (Edge *e = N[1].e; e; e = e->next) cnt++;\n\n\tif (cnt > m) puts(\"-1\");\n\telse {\n\t\tint l = 0, r = sum;\n\t\twhile (l < r) {\n\t\t\tint mid = l + (r - l) / 2;\n#ifdef DBG\n\t\t\tprintf(\"[%d, %d], mid = %d\\n\", l, r, mid);\n#endif\n\t\t\tif (check(mid)) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2012-blockade.md","raw":"title: NOIP2012 -  +  + \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \n  - \npermalink: noip2012-blockade\ndate: 2016-11-13 17:44:00\n---\n\nH  $ n $  $ n $  $ n - 1 $ $ 1 $ \n\nH \n\n H \n\n\n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n $ t $ $ t $ \n\n****\n\n $ X $  $ Y $ \n\n $ X $  $ Y $ $ X $  $ Y $  $ X $  $ Y $ \n\n $ X $  $ Y $  $ X $  $ Y $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <list>\n\nconst int MAXN = 50000;\nconst int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tbool visited, settled, childSettled;\n\tstd::vector<int> arrived;\n} N[MAXN + 1], *seq[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tint w;\n\tbool visited;\n\tstd::list<Edge *>::iterator it;\n\n\tEdge(Node *s, Node *t, int w) : s(s), t(t), next(s->e), w(w) {}\n};\n\ninline void addEdge(int s, int t, int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, m, a[MAXN + 1], logn;\n\nint f[MAXN + 1][MAXN_LOG + 1];\nlong long g[MAXN + 1][MAXN_LOG + 1];\n\ninline void prepare() {\n\tstd::queue<Node *> q;\n\n\tN[1].visited = true;\n\tf[1][0] = 1;\n\tg[1][0] = 0;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\tf[e->t - N][0] = v - N;\n\t\t\t\tg[e->t - N][0] = e->w;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n}\n\ninline bool compare(Edge *a, Edge *b) {\n\treturn a->w < b->w;\n}\n\ninline bool check(long long limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].arrived.clear();\n\t\tN[i].settled = false;\n\t\tN[i].childSettled = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = a[i];\n\n\t\tlong long dist = 0;\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (dist + g[u][j] <= limit && f[u][j] != 1) {\n\t\t\t\tdist += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\n\t\tN[u].arrived.push_back(limit - dist);\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (seq[i]->e->next || i == 1) { // It's not a leaf\n\t\t\tseq[i]->childSettled = true;\n\t\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\t\tif (e->t == seq[i]->parent) continue;\n\n\t\t\t\tif (!e->t->settled) {\n\t\t\t\t\tseq[i]->childSettled = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d, settled = %d\\n\", seq[i] - N, seq[i]->childSettled, seq[i]->settled);\n#endif\n\n\t\tseq[i]->settled = seq[i]->childSettled;\n\n\t\tif (seq[i]->arrived.size()) {\n\t\t\tseq[i]->settled = true;\n\t\t}\n\t}\n\n\tif (N[1].settled) return true;\n\n\tstd::list< std::pair<int, Edge *> > atRoot;\n\tstd::list<Edge *> needSettle;\n\tfor (Edge *e = N[1].e; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d\\n\", e->t - N, e->t->childSettled);\n#endif\n\n\t\tstd::vector<int> &vec = e->t->arrived;\n\t\tstd::sort(vec.begin(), vec.end());\n\n\t\tbool remain = e->t->childSettled;\n\t\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i] >= e->w) atRoot.push_back(std::make_pair(vec[i] - e->w, e));\n\t\t\telse remain = true;\n\t\t}\n\n\t\tif (remain) {\n\t\t\te->visited = true;\n\t\t} else {\n\t\t\tneedSettle.push_back(e);\n\t\t\te->it = --needSettle.end();\n\t\t\te->visited = false;\n\t\t}\n\t}\n\n\tatRoot.sort();\n\tneedSettle.sort(&compare);\n\n#ifdef DBG\n\tstd::vector< std::pair<int, Edge *> > _atRoot(atRoot.begin(), atRoot.end());\n\tstd::vector<Edge *> _needSettle(needSettle.begin(), needSettle.end());\n#endif\n\t// std::sort(needSettle.begin(), needSettle.end(), &compare);\n\n\tfor (std::list< std::pair<int, Edge *> >::iterator it = atRoot.begin(); it != atRoot.end(); it++) {\n\t\tif (needSettle.empty()) break;\n\t\tif (!it->second->visited) {\n\t\t\tit->second->visited = true;\n\t\t\tneedSettle.erase(it->second->it);\n\t\t} else {\n\t\t\tif (needSettle.front()->w <= it->first) {\n\t\t\t\tneedSettle.front()->visited = true;\n\t\t\t\tneedSettle.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSettle.empty();\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\tsum += w;\n\t\taddEdge(u, v, w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (Edge *e = N[1].e; e; e = e->next) cnt++;\n\n\tif (cnt > m) puts(\"-1\");\n\telse {\n\t\tint l = 0, r = sum;\n\t\twhile (l < r) {\n\t\t\tint mid = l + (r - l) / 2;\n#ifdef DBG\n\t\t\tprintf(\"[%d, %d], mid = %d\\n\", l, r, mid);\n#endif\n\t\t\tif (check(mid)) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2012-blockade","published":1,"updated":"2016-11-13T09:44:18.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji7x00mn0jxlfbcd3klw"},{"title":"NOIP2010 - ","id":"54","updated":"2016-02-19T08:06:06.000Z","date":"2016-02-19T08:00:26.000Z","_content":"\nS  `N`  `1 ~ N` Z  Z \n\n<!-- more -->\n\n### \n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[ 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### \n `x`  `x` \n\n BFS\n\n $ O(n{log}n) $ 100%  Tyvj  TLE \n\n  qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-prison.md","raw":"title: NOIP2010 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Vijos\n  - \n  - \n  - \n  - \npermalink: noip2010-prison\nid: 54\nupdated: '2016-02-19 16:06:06'\ndate: 2016-02-19 16:00:26\n---\n\nS  `N`  `1 ~ N` Z  Z \n\n<!-- more -->\n\n### \n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[ 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### \n `x`  `x` \n\n BFS\n\n $ O(n{log}n) $ 100%  Tyvj  TLE \n\n  qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","slug":"noip2010-prison","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji8300mu0jxln6hvfxr0"},{"title":"NOIP2010 - BFS + DP","date":"2016-11-13T09:23:00.000Z","_content":"\n $ N $  $ M $ \n\n $ 1 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[CodeVS 1066](http://codevs.cn/problem/1066/)\n\n### \n Floodfill\n\n Floodfill $ m $    DP \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 500;\n\nconst int di[] = { 0, 1, 0, -1 };\nconst int dj[] = { -1, 0, 1, 0 };\n\nstruct Node {\n\tint height;\n\tbool visited;\n} map[MAXN + 2][MAXN + 2];\n\nint n, m;\n\nstruct Point {\n\tint i, j;\n\t\n\tPoint(int i = 0, int j = 0) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tbool valid() {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n};\n\nstruct Interval {\n\tint l, r;\n\n\tInterval(int l = 0, int r = 0) : l(l), r(r) {}\n\n\tbool operator<(const Interval &other) const {\n\t\treturn (l == other.l) ? (r < other.r) : (l < other.l);\n\t}\n};\n\ninline int bfs(Point start, Interval &interval) {\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) map[i][j].visited = false;\n\n\tstd::queue<Point> q;\n\tif (start.i == 0 && start.j == 0) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap[1][i].visited = true;\n\t\t\tq.push(Point(1, i));\n\t\t}\n\t} else {\n\t\tq.push(start);\n\t\tstart->visited = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\t\t\tif (!u.valid()) continue;\n\n\t\t\tif (u->height < v->height && !u->visited) {\n\t\t\t\tu->visited = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start.i == 0 && start.j == 0) {\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) if (!map[n][i].visited) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool flag = false;\n#ifdef DBG\n\tprintf(\"%d:\", start.j);\n#endif\n\tfor (int i = 1; i <= m + 1; i++) {\n#ifdef DBG\n\t\tif (map[n][i].visited) {\n\t\t\tprintf(\" %d\", i);\n\t\t}\n#endif\n\t\tif (!flag && map[n][i].visited) {\n\t\t\tinterval.l = i;\n\t\t\tflag = true;\n\t\t} else if (flag && !map[n][i].visited) {\n\t\t\tinterval.r = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\" = [%d, %d]\\n\", interval.l, interval.r);\n#endif\n\n\treturn flag;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf(\"%d\", &map[i][j].height);\n\n\tInterval tmp;\n\tint cnt = bfs(Point(0, 0), tmp);\n\n\tif (cnt) {\n\t\tprintf(\"0\\n%d\\n\", cnt);\n\t} else {\n\t\tstatic Interval a[MAXN + 1];\n\t\tint k  = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tInterval interval;\n\t\t\tif (bfs(Point(1, i), interval)) {\n\t\t\t\ta[++k] = interval;\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(a + 1, a + k+ 1);\n\n\t\tstatic int f[MAXN + 1];\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tf[i] = INT_MAX;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[j].r >= a[i].l - 1) {\n\t\t\t\t\tf[i] = std::min(f[i], f[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i].r == m) ans = std::min(ans, f[i]);\n\t\t}\n\n\t\tprintf(\"1\\n%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-flow.md","raw":"title: NOIP2010 - BFS + DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BFS\n  - DP\n  -  DP\npermalink: noip2010-flow\ndate: 2016-11-13 17:23:00\n---\n\n $ N $  $ M $ \n\n $ 1 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[CodeVS 1066](http://codevs.cn/problem/1066/)\n\n### \n Floodfill\n\n Floodfill $ m $    DP \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 500;\n\nconst int di[] = { 0, 1, 0, -1 };\nconst int dj[] = { -1, 0, 1, 0 };\n\nstruct Node {\n\tint height;\n\tbool visited;\n} map[MAXN + 2][MAXN + 2];\n\nint n, m;\n\nstruct Point {\n\tint i, j;\n\t\n\tPoint(int i = 0, int j = 0) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tbool valid() {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n};\n\nstruct Interval {\n\tint l, r;\n\n\tInterval(int l = 0, int r = 0) : l(l), r(r) {}\n\n\tbool operator<(const Interval &other) const {\n\t\treturn (l == other.l) ? (r < other.r) : (l < other.l);\n\t}\n};\n\ninline int bfs(Point start, Interval &interval) {\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) map[i][j].visited = false;\n\n\tstd::queue<Point> q;\n\tif (start.i == 0 && start.j == 0) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap[1][i].visited = true;\n\t\t\tq.push(Point(1, i));\n\t\t}\n\t} else {\n\t\tq.push(start);\n\t\tstart->visited = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\t\t\tif (!u.valid()) continue;\n\n\t\t\tif (u->height < v->height && !u->visited) {\n\t\t\t\tu->visited = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start.i == 0 && start.j == 0) {\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) if (!map[n][i].visited) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool flag = false;\n#ifdef DBG\n\tprintf(\"%d:\", start.j);\n#endif\n\tfor (int i = 1; i <= m + 1; i++) {\n#ifdef DBG\n\t\tif (map[n][i].visited) {\n\t\t\tprintf(\" %d\", i);\n\t\t}\n#endif\n\t\tif (!flag && map[n][i].visited) {\n\t\t\tinterval.l = i;\n\t\t\tflag = true;\n\t\t} else if (flag && !map[n][i].visited) {\n\t\t\tinterval.r = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\" = [%d, %d]\\n\", interval.l, interval.r);\n#endif\n\n\treturn flag;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf(\"%d\", &map[i][j].height);\n\n\tInterval tmp;\n\tint cnt = bfs(Point(0, 0), tmp);\n\n\tif (cnt) {\n\t\tprintf(\"0\\n%d\\n\", cnt);\n\t} else {\n\t\tstatic Interval a[MAXN + 1];\n\t\tint k  = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tInterval interval;\n\t\t\tif (bfs(Point(1, i), interval)) {\n\t\t\t\ta[++k] = interval;\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(a + 1, a + k+ 1);\n\n\t\tstatic int f[MAXN + 1];\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tf[i] = INT_MAX;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[j].r >= a[i].l - 1) {\n\t\t\t\t\tf[i] = std::min(f[i], f[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i].r == m) ans = std::min(ans, f[i]);\n\t\t}\n\n\t\tprintf(\"1\\n%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2010-flow","published":1,"updated":"2016-11-13T09:23:38.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji8900n60jxl519665nt"},{"title":"NOIP2006 -  DP","id":"19","updated":"2016-01-19T13:04:41.000Z","date":"2016-01-12T21:19:28.000Z","_content":"\nMarsMarsNMarsmrrn$m*r*n$Marsmn\nMars\n\n<!-- more -->\n\n### \n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### \n\n\nDP $a[i]$  `i`  `i + 1`  $f[i][j]$  `i`  `j`  `k` `k` \n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n\n\n $O(n^4)$ $n=100$  TvT\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2006-energy.md","raw":"title: NOIP2006 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - Tyvj\n  -  DP\npermalink: noip2006-energy\nid: 19\nupdated: '2016-01-19 21:04:41'\ndate: 2016-01-13 05:19:28\n---\n\nMarsMarsNMarsmrrn$m*r*n$Marsmn\nMars\n\n<!-- more -->\n\n### \n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### \n\n\nDP $a[i]$  `i`  `i + 1`  $f[i][j]$  `i`  `j`  `k` `k` \n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n\n\n $O(n^4)$ $n=100$  TvT\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noip2006-energy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji8h00ne0jxlw6ja836i"},{"title":"NOIP2006 -  DP +  DP","id":"25","updated":"2016-01-19T13:02:58.000Z","date":"2016-01-16T22:11:03.000Z","_content":"\nN\n\n012N51~5510NN\n\n<!-- more -->\n\n### \n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[ 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### \n DP \n\n 01 \n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n 01 \n\n `0`  `0` \n\n~~~~\n\nPS TLE  `10`  `10` \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2006-budget.md","raw":"title: NOIP2006 -  DP +  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - Vijos\n  -  DP\n  - \n  -  DP\npermalink: noip2006-budget\nid: 25\nupdated: '2016-01-19 21:02:58'\ndate: 2016-01-17 06:11:03\n---\n\nN\n\n012N51~5510NN\n\n<!-- more -->\n\n### \n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[ 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### \n DP \n\n 01 \n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n 01 \n\n `0`  `0` \n\n~~~~\n\nPS TLE  `10`  `10` \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```\n","slug":"noip2006-budget","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji8l00nl0jxllush6kxt"},{"title":"NOIP2003 -  DP","id":"20","updated":"2016-01-19T13:04:15.000Z","date":"2016-01-13T20:23:38.000Z","_content":"\n `n` 50 `m` 9 `m`  10  `k` `k` \n\n<!-- more -->\n\n### \n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[ 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### \n DP  ** `10` **\n\n $ f[i][j] $  `i`  `j` \n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2003-game.md","raw":"title: NOIP2003 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  -  DP\n  - \n  - Tyvj\npermalink: noip2003-game\nid: 20\nupdated: '2016-01-19 21:04:15'\ndate: 2016-01-14 04:23:38\n---\n\n `n` 50 `m` 9 `m`  10  `k` `k` \n\n<!-- more -->\n\n### \n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[ 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### \n DP  ** `10` **\n\n $ f[i][j] $  `i`  `j` \n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```\n","slug":"noip2003-game","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji8q00nu0jxl91wqcyc7"},{"title":"NOIP2000 -  DP","id":"16","updated":"2016-01-19T13:05:38.000Z","date":"2016-01-08T21:10:45.000Z","_content":"\n `N`<= 400 `K`<= 6\n\n<!-- more -->\n\n### \n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### \n DP `f[n][k]`  `n`  `k`  `a[i][j]`  `i`  `j` \n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n `long long` \n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```\n","source":"_posts/noip2000-cheng-ji-zui-da.md","raw":"title: NOIP2000 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  -  DP\npermalink: noip2000-cheng-ji-zui-da\nid: 16\nupdated: '2016-01-19 21:05:38'\ndate: 2016-01-09 05:10:45\n---\n\n `N`<= 400 `K`<= 6\n\n<!-- more -->\n\n### \n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### \n DP `f[n][k]`  `n`  `k`  `a[i][j]`  `i`  `j` \n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n `long long` \n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```\n","slug":"noip2000-cheng-ji-zui-da","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji8v00o20jxluffykmg8"},{"title":"NOI2016 - ","date":"2016-09-05T23:19:00.000Z","_content":"\n $ n $  $ [l_1, r_1], [l_2, r_2] , \\ldots, [l_n, r_n] $ $ m $  $ m $  $ x $ $ [l_i, r_i] $ $ l_i \\leq x \\leq r_i $\n\n $ [l_i, r_i] $  $ r_i  l_i $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4653](http://www.lydsy.com/JudgeOnline/problem.php?id=4653)\n\n### \n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint val, tag;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {}\n\n\tvoid cover(const int delta) {\n\t\tval += delta;\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, delta);\n\t\t\trc->update(l, r, delta);\n\t\t\tval = std::max(lc->val, rc->val);\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return val;\n\t\telse {\n\t\t\tpushDown();\n\t\t\treturn std::max(lc->query(l, r), rc->query(l, r));\n\t\t}\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\nstruct Interval {\n\tint l, r, len;\n\n\tbool operator<(const Interval &other) const { return len < other.len; }\n} a[MAXN];\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].l, &a[i].r), a[i].len = a[i].r - a[i].l;\n\n\tstatic int set[MAXN * 2];\n\tint cnt = 0, max = 0;\n\tfor (int i = 0; i < n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r;\n\tstd::sort(set, set + n * 2);\n\tint *end = std::unique(set, set + n * 2);\n\tfor (int i = 0; i < n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r);\n\n\tstd::sort(a, a + n);\n\n\tsegment = SegmentTree::build(0, max);\n\n\tint ans = INT_MAX;\n\tfor (Interval *l = a, *r = a; r != a + n; r++) {\n\t\tsegment->update(r->l, r->r, 1);\n\t\twhile (l <= r && segment->query(0, max) >= m) {\n\t\t\tans = std::min(ans, r->len - l->len);\n\t\t\tsegment->update(l->l, l->r, -1);\n\t\t\tl++;\n\t\t}\n\t}\n\n\tif (ans == INT_MAX) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2016-interval.md","raw":"title: NOI2016 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \npermalink: noi2016-interval\ndate: 2016-09-06 07:19:00\n---\n\n $ n $  $ [l_1, r_1], [l_2, r_2] , \\ldots, [l_n, r_n] $ $ m $  $ m $  $ x $ $ [l_i, r_i] $ $ l_i \\leq x \\leq r_i $\n\n $ [l_i, r_i] $  $ r_i  l_i $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4653](http://www.lydsy.com/JudgeOnline/problem.php?id=4653)\n\n### \n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint val, tag;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {}\n\n\tvoid cover(const int delta) {\n\t\tval += delta;\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, delta);\n\t\t\trc->update(l, r, delta);\n\t\t\tval = std::max(lc->val, rc->val);\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return val;\n\t\telse {\n\t\t\tpushDown();\n\t\t\treturn std::max(lc->query(l, r), rc->query(l, r));\n\t\t}\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\nstruct Interval {\n\tint l, r, len;\n\n\tbool operator<(const Interval &other) const { return len < other.len; }\n} a[MAXN];\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].l, &a[i].r), a[i].len = a[i].r - a[i].l;\n\n\tstatic int set[MAXN * 2];\n\tint cnt = 0, max = 0;\n\tfor (int i = 0; i < n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r;\n\tstd::sort(set, set + n * 2);\n\tint *end = std::unique(set, set + n * 2);\n\tfor (int i = 0; i < n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r);\n\n\tstd::sort(a, a + n);\n\n\tsegment = SegmentTree::build(0, max);\n\n\tint ans = INT_MAX;\n\tfor (Interval *l = a, *r = a; r != a + n; r++) {\n\t\tsegment->update(r->l, r->r, 1);\n\t\twhile (l <= r && segment->query(0, max) >= m) {\n\t\t\tans = std::min(ans, r->len - l->len);\n\t\t\tsegment->update(l->l, l->r, -1);\n\t\t\tl++;\n\t\t}\n\t}\n\n\tif (ans == INT_MAX) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2016-interval","published":1,"updated":"2016-09-05T23:39:11.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji9100o80jxlamv8t5n4"},{"title":"NOI2016 - ","date":"2016-09-08T11:40:00.000Z","_content":"\n $ n \\times m $  $ c $ \n\n<!-- more -->\n\n### \n[BZOJ 4651](http://www.lydsy.com/JudgeOnline/problem.php?id=4651)  \n[UOJ #220](http://uoj.ac/problem/220)\n\n### \n $ 2 $$ -1 $$ 0 $$ 1 $ \n\n#### \n\n\n1. \n2. \n\n $ n \\times m = c $  $ n $  $ m $ $ n \\times m = c + 2 $ $ | x_1 - x_2 | + | y_1 - y_2 | = 1 $ \n\n####  $ 0 $\n $ 0 $ ****\n\n FloodFill $ O(c) $ \n\n  ****\n\n FloodFill**** $ 0 $\n\n####  $ 1 $\n $ 1 $ ****\n\n\n\n\n\n```plain\n.......\n...111.\n...1*1.\n.11111.\n.1*1...\n.111...\n.......\n```\n\n $ 1 $   \n\n****\n\n```plain\n..22222\n..21112\n2221*12\n2111112\n21*1222\n21112..\n22222..\n```\n\n** $ 1 $ **\n\n#### \n $ 1 $\n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define HASH(x, y) (static_cast<unsigned long long>(x) << 32) | static_cast<unsigned long long>(y)\n#define inline inline __attribute__((always_inline))\n\nconst int MAXC = 100000;\nconst int MAXN = MAXC * 24;\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\ntemplate <typename Tk, typename Tv>\nstruct HashMap {\n\tconst static size_t HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tstruct Pair {\n\t\t\tTk first;\n\t\t\tTv second;\n\t\t} p;\n\t\tint time;\n\t} N[HASH_SIZE];\n\n\ttypedef typename Node::Pair *iterator;\n\n\tint time;\n\n\tinline HashMap() : time(1) {}\n\n\tinline int hash(const Tk &k) {\n\t\treturn k % HASH_SIZE;\n\t}\n\n\tinline Node *locate(const Tk &k) {\n\t\tregister int i;\n\t\tfor (i = hash(k); N[i].time == time && N[i].p.first != k; (++i == HASH_SIZE) && (i = 0));\n\t\treturn &N[i];\n\t}\n\n\tinline iterator find(const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) return end();\n\t\treturn &v->p;\n\t}\n\n\tinline Tv &operator[](const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) {\n\t\t\tv->time = time, v->p.first = k, v->p.second = Tv();\n\t\t}\n\t\treturn v->p.second;\n\t}\n\n\tinline void clear() { time++; }\n\n\tinline iterator end() const { return NULL; }\n};\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint type, dfn, low;\n\tbool v, pushed, flag;\n\tint x, y;\n} N[MAXN], *p = N;\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tinline Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(Node *s, Node *t) {\n\ts->e = new Edge(s, t);\n}\n\nint n, m, c;\nstruct Point {\n\tint x, y;\n\n\tinline Point(const int x = 0, const int y = 0) : x(x), y(y) {}\n\n\tinline bool operator<(const Point &other) const {\n\t\treturn y < other.y;\n\t}\n} a[MAXN];\n\nHashMap<unsigned long long, Node *> map;\n\ninline Node *clear(Node *p) {\n\tfor (Edge *&e = p->e, *next; e; next = e->next, delete e, e = next);\n\tmemset(p, 0, sizeof(Node));\n\treturn p;\n}\n\n#ifdef DBG\nchar str[1000][1000];\n#endif\n\ninline void getNodes(const int x, const int y, const bool second = false) {\n\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(x + fx < 1 || x + fx > n || y + fy < 1 || y + fy > m)) {\n\t\tregister int nx = x + fx, ny = y + fy;\n\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx, ny));\n\t\tif (it == map.end() || it->second != NULL) {\n\t\t\tNode *v;\n\t\t\tif (it == map.end()) {\n\t\t\t\tv = map[HASH(nx, ny)] = clear(p++);\n\t\t\t\tv->x = nx, v->y = ny;\n\t\t\t} else v = it->second;\n\t\t\tv->type = 1;\n#ifdef DBG\n\t\t\tstr[v->x][v->y] = 'A';\n#endif\n\t\t\tif (second) for (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(nx + fx < 1 || nx + fx > n || ny + fy < 1 || ny + fy > m)) {\n\t\t\t\tregister int nx2 = nx + fx, ny2 = ny + fy;\n\t\t\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx2, ny2));\n\t\t\t\tif (it == map.end()) {\n\t\t\t\t\tclear(p);\n\t\t\t\t\tp->type = 2;\n\t\t\t\t\tp->x = nx2, p->y = ny2;\n#ifdef DBG\n\t\t\t\t\tstr[p->x][p->y] = 'B';\n#endif\n\t\t\t\t\tmap[HASH(nx2, ny2)] = p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void addEdges() {\n\t// for (HashMap<unsigned long long, Node *>::iterator it = map.begin(); it != map.end(); it++) if (it->second) {\n\tfor (Node *v = N; v != p; v++) {\n\t\tregister int &x = v->x, &y = v->y;\n\t\tfor (register int i = 0; i < 4; i++) if (!(x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m)) {\n\t\t\tregister int nx = x + dx[i], ny = y + dy[i];\n\t\t\tregister HashMap<unsigned long long, Node *>::iterator it2 = map.find(HASH(nx, ny));\n\t\t\tif (it2 != map.end() && it2->second) {\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d] -> [%d, %d]\\n\", v->x, v->y, it2->second->x, it2->second->y);\n#endif\n\t\t\t\taddEdge(v, it2->second);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int tarjan() {\n\tregister int ts = 0, cnt = 0;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\n\t\tstatic Node *s[MAXN];\n\t\tNode **top = s;\n\t\tstart->pushed = true;\n\t\t*top = start;\n\n\t\twhile (top != s - 1) {\n\t\t\tNode *v = *top;\n\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v && e->t != v->p) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) *++top = e->t, e->t->pushed = true, e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != start) for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t->low >= v->dfn) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v->flag && v->type == 1) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ttop--;\n\t\t\t}\n\t\t}\n\n\t\tint ch = 0;\n\t\tfor (Edge *e = start->e; e; e = e->next) if (e->t->p == start) ch++;\n\t\tstart->flag = ch >= 2;\n\t\tif (start->flag && start->type == 1) cnt++;\n\t}\n\n\treturn cnt;\n}\n\ninline bool isOne() {\n\tfor (register int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tmap[HASH(x, y)] = NULL;\n\t}\n\n\tp = N;\n\n\tfor (register int i = 0; i < c; i++) {\n\t\tgetNodes(a[i].x, a[i].y, true);\n\t}\n\n\taddEdges();\n\n\treturn tarjan() != 0;\n}\n\ninline bool bfsCount() {\n\tbool flag = false;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\t\tif (flag) return true;\n\t\tflag = true;\n\n\t\tstatic Node *q[MAXN];\n\t\tNode **l = q, **r = q;\n\t\tstart->v = true;\n\t\t*l = start;\n\n\t\twhile (l <= r) {\n\t\t\tNode *v = *l++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->v) {\n\t\t\t\te->t->v = true;\n\t\t\t\t*++r = e->t;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline bool isZero() {\n\tstatic HashMap<unsigned long long, bool> map2;\n\tmap2.clear();\n\tfor (register int i = 0; i < c; i++) {\n\t\tmap2[HASH(a[i].x, a[i].y)] = false;\n\t}\n\tbool ans = false;\n#ifdef DBG\n\tint id = 0;\n#endif\n\tfor (int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tregister bool &f = map2[HASH(x, y)];\n\t\tif (f) continue;\n\t\tf = true;\n\n#ifdef DBG\n\t\tid++;\n#endif\n\n\t\tstatic Point vec[MAXC];\n\t\tint cnt = 0;\n\n\t\tmap.clear();\n\t\tp = N;\n\n\t\tstatic Point q[MAXC];\n\t\tPoint *l = q, *r = q;\n\t\t*l = Point(x, y);\n\t\twhile (l <= r) {\n\t\t\tPoint p = *l++;\n\n#ifdef DBG\n\t\t\tstr[p.x][p.y] = id + '0';\n#endif\n\n\t\t\tmap[HASH(p.x, p.y)] = NULL;\n\t\t\tvec[cnt++] = p;\n\n\t\t\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(p.x + fx < 1 || p.x + fx > n || p.y + fy < 1 || p.y + fy > m)) {\n\t\t\t\tregister int nx = p.x + fx, ny = p.y + fy;\n\t\t\t\tHashMap<unsigned long long, bool>::iterator it = map2.find(HASH(nx, ny));\n\t\t\t\tif (it != map2.end() && it->second == false) {\n\t\t\t\t\tit->second = true;\n\t\t\t\t\t*++r = Point(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) getNodes(vec[i].x, vec[i].y);\n\t\taddEdges();\n\t\tif (bfsCount()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmap.clear();\n\treturn ans;\n}\n\ninline bool isInvalid() {\n\tconst unsigned long long r = static_cast<unsigned long long>(n) * m - c;\n\tif (r < 2) return true;\n\telse if (r == 2) {\n\t\tstatic bool flag[MAXC];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tflag[(a[i].x - 1) * m + a[i].y - 1] = true;\n\t\t}\n\n\t\tPoint pts[2];\n\t\tfor (int i = 0, cnt = 0; i < n; i++) for (int j = 0; j < m; j++) {\n\t\t\tif (!flag[i * m + j]) pts[cnt++] = Point(i, j);\n\t\t\tflag[i * m + j] = false;\n\t\t}\n\n\t\treturn abs(pts[0].x - pts[1].x) + abs(pts[0].y - pts[1].y) == 1;\n\t} else return false;\n}\n\ninline const char *special() {\n\tstd::sort(a, a + c);\n\tint last = 0, cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (a[i].y != last + 1) {\n\t\t\tcnt++;\n\t\t}\n\t\tlast = a[i].y;\n\t}\n\tif (last != m) cnt++;\n\treturn cnt == 1 ? \"1\" : \"0\";\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar_unlocked(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar_unlocked(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tint t;\n\tread(t);\n\twhile (t--) {\n\t\tread(n), read(m), read(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tread(a[i].x), read(a[i].y);\n\t\t\tif (n > m) std::swap(a[i].x, a[i].y);\n\t\t}\n\n\t\tif (n > m) std::swap(n, m);\n\n\t\tif (isInvalid()) puts(\"-1\");\n\t\telse if (n == 1) puts(special());\n\t\telse if (isZero()) puts(\"0\");\n\t\telse if (isOne()) puts(\"1\");\n\t\telse puts(\"2\");\n\n#ifdef DBG\n\t\tfor (Node *v = N; v != p; v++) {\n\t\t\tprintf(\"[%d, %d] => %d\\n\", v->x, v->y, v->type);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tHashMap<unsigned long long, Node *>::iterator it = map.find(HASH(i, j));\n\t\t\t\tif (it == map.end()) putchar('-');\n\t\t\t\telse if (!it->second) putchar('X');\n\t\t\t\telse putchar('0' + it->second->type);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tputchar(str[i][j] ? str[i][j] : '-');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n#endif\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2016-grid.md","raw":"title: NOI2016 - \ncategories: OI\ntags: \n  - BZOJ\n  - NOI\n  - Tarjan\n  - \n  - \npermalink: noi2016-grid\ndate: 2016-09-08 19:40:00\n---\n\n $ n \\times m $  $ c $ \n\n<!-- more -->\n\n### \n[BZOJ 4651](http://www.lydsy.com/JudgeOnline/problem.php?id=4651)  \n[UOJ #220](http://uoj.ac/problem/220)\n\n### \n $ 2 $$ -1 $$ 0 $$ 1 $ \n\n#### \n\n\n1. \n2. \n\n $ n \\times m = c $  $ n $  $ m $ $ n \\times m = c + 2 $ $ | x_1 - x_2 | + | y_1 - y_2 | = 1 $ \n\n####  $ 0 $\n $ 0 $ ****\n\n FloodFill $ O(c) $ \n\n  ****\n\n FloodFill**** $ 0 $\n\n####  $ 1 $\n $ 1 $ ****\n\n\n\n\n\n```plain\n.......\n...111.\n...1*1.\n.11111.\n.1*1...\n.111...\n.......\n```\n\n $ 1 $   \n\n****\n\n```plain\n..22222\n..21112\n2221*12\n2111112\n21*1222\n21112..\n22222..\n```\n\n** $ 1 $ **\n\n#### \n $ 1 $\n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define HASH(x, y) (static_cast<unsigned long long>(x) << 32) | static_cast<unsigned long long>(y)\n#define inline inline __attribute__((always_inline))\n\nconst int MAXC = 100000;\nconst int MAXN = MAXC * 24;\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\ntemplate <typename Tk, typename Tv>\nstruct HashMap {\n\tconst static size_t HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tstruct Pair {\n\t\t\tTk first;\n\t\t\tTv second;\n\t\t} p;\n\t\tint time;\n\t} N[HASH_SIZE];\n\n\ttypedef typename Node::Pair *iterator;\n\n\tint time;\n\n\tinline HashMap() : time(1) {}\n\n\tinline int hash(const Tk &k) {\n\t\treturn k % HASH_SIZE;\n\t}\n\n\tinline Node *locate(const Tk &k) {\n\t\tregister int i;\n\t\tfor (i = hash(k); N[i].time == time && N[i].p.first != k; (++i == HASH_SIZE) && (i = 0));\n\t\treturn &N[i];\n\t}\n\n\tinline iterator find(const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) return end();\n\t\treturn &v->p;\n\t}\n\n\tinline Tv &operator[](const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) {\n\t\t\tv->time = time, v->p.first = k, v->p.second = Tv();\n\t\t}\n\t\treturn v->p.second;\n\t}\n\n\tinline void clear() { time++; }\n\n\tinline iterator end() const { return NULL; }\n};\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint type, dfn, low;\n\tbool v, pushed, flag;\n\tint x, y;\n} N[MAXN], *p = N;\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tinline Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(Node *s, Node *t) {\n\ts->e = new Edge(s, t);\n}\n\nint n, m, c;\nstruct Point {\n\tint x, y;\n\n\tinline Point(const int x = 0, const int y = 0) : x(x), y(y) {}\n\n\tinline bool operator<(const Point &other) const {\n\t\treturn y < other.y;\n\t}\n} a[MAXN];\n\nHashMap<unsigned long long, Node *> map;\n\ninline Node *clear(Node *p) {\n\tfor (Edge *&e = p->e, *next; e; next = e->next, delete e, e = next);\n\tmemset(p, 0, sizeof(Node));\n\treturn p;\n}\n\n#ifdef DBG\nchar str[1000][1000];\n#endif\n\ninline void getNodes(const int x, const int y, const bool second = false) {\n\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(x + fx < 1 || x + fx > n || y + fy < 1 || y + fy > m)) {\n\t\tregister int nx = x + fx, ny = y + fy;\n\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx, ny));\n\t\tif (it == map.end() || it->second != NULL) {\n\t\t\tNode *v;\n\t\t\tif (it == map.end()) {\n\t\t\t\tv = map[HASH(nx, ny)] = clear(p++);\n\t\t\t\tv->x = nx, v->y = ny;\n\t\t\t} else v = it->second;\n\t\t\tv->type = 1;\n#ifdef DBG\n\t\t\tstr[v->x][v->y] = 'A';\n#endif\n\t\t\tif (second) for (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(nx + fx < 1 || nx + fx > n || ny + fy < 1 || ny + fy > m)) {\n\t\t\t\tregister int nx2 = nx + fx, ny2 = ny + fy;\n\t\t\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx2, ny2));\n\t\t\t\tif (it == map.end()) {\n\t\t\t\t\tclear(p);\n\t\t\t\t\tp->type = 2;\n\t\t\t\t\tp->x = nx2, p->y = ny2;\n#ifdef DBG\n\t\t\t\t\tstr[p->x][p->y] = 'B';\n#endif\n\t\t\t\t\tmap[HASH(nx2, ny2)] = p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void addEdges() {\n\t// for (HashMap<unsigned long long, Node *>::iterator it = map.begin(); it != map.end(); it++) if (it->second) {\n\tfor (Node *v = N; v != p; v++) {\n\t\tregister int &x = v->x, &y = v->y;\n\t\tfor (register int i = 0; i < 4; i++) if (!(x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m)) {\n\t\t\tregister int nx = x + dx[i], ny = y + dy[i];\n\t\t\tregister HashMap<unsigned long long, Node *>::iterator it2 = map.find(HASH(nx, ny));\n\t\t\tif (it2 != map.end() && it2->second) {\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d] -> [%d, %d]\\n\", v->x, v->y, it2->second->x, it2->second->y);\n#endif\n\t\t\t\taddEdge(v, it2->second);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int tarjan() {\n\tregister int ts = 0, cnt = 0;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\n\t\tstatic Node *s[MAXN];\n\t\tNode **top = s;\n\t\tstart->pushed = true;\n\t\t*top = start;\n\n\t\twhile (top != s - 1) {\n\t\t\tNode *v = *top;\n\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v && e->t != v->p) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) *++top = e->t, e->t->pushed = true, e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != start) for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t->low >= v->dfn) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v->flag && v->type == 1) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ttop--;\n\t\t\t}\n\t\t}\n\n\t\tint ch = 0;\n\t\tfor (Edge *e = start->e; e; e = e->next) if (e->t->p == start) ch++;\n\t\tstart->flag = ch >= 2;\n\t\tif (start->flag && start->type == 1) cnt++;\n\t}\n\n\treturn cnt;\n}\n\ninline bool isOne() {\n\tfor (register int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tmap[HASH(x, y)] = NULL;\n\t}\n\n\tp = N;\n\n\tfor (register int i = 0; i < c; i++) {\n\t\tgetNodes(a[i].x, a[i].y, true);\n\t}\n\n\taddEdges();\n\n\treturn tarjan() != 0;\n}\n\ninline bool bfsCount() {\n\tbool flag = false;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\t\tif (flag) return true;\n\t\tflag = true;\n\n\t\tstatic Node *q[MAXN];\n\t\tNode **l = q, **r = q;\n\t\tstart->v = true;\n\t\t*l = start;\n\n\t\twhile (l <= r) {\n\t\t\tNode *v = *l++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->v) {\n\t\t\t\te->t->v = true;\n\t\t\t\t*++r = e->t;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline bool isZero() {\n\tstatic HashMap<unsigned long long, bool> map2;\n\tmap2.clear();\n\tfor (register int i = 0; i < c; i++) {\n\t\tmap2[HASH(a[i].x, a[i].y)] = false;\n\t}\n\tbool ans = false;\n#ifdef DBG\n\tint id = 0;\n#endif\n\tfor (int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tregister bool &f = map2[HASH(x, y)];\n\t\tif (f) continue;\n\t\tf = true;\n\n#ifdef DBG\n\t\tid++;\n#endif\n\n\t\tstatic Point vec[MAXC];\n\t\tint cnt = 0;\n\n\t\tmap.clear();\n\t\tp = N;\n\n\t\tstatic Point q[MAXC];\n\t\tPoint *l = q, *r = q;\n\t\t*l = Point(x, y);\n\t\twhile (l <= r) {\n\t\t\tPoint p = *l++;\n\n#ifdef DBG\n\t\t\tstr[p.x][p.y] = id + '0';\n#endif\n\n\t\t\tmap[HASH(p.x, p.y)] = NULL;\n\t\t\tvec[cnt++] = p;\n\n\t\t\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(p.x + fx < 1 || p.x + fx > n || p.y + fy < 1 || p.y + fy > m)) {\n\t\t\t\tregister int nx = p.x + fx, ny = p.y + fy;\n\t\t\t\tHashMap<unsigned long long, bool>::iterator it = map2.find(HASH(nx, ny));\n\t\t\t\tif (it != map2.end() && it->second == false) {\n\t\t\t\t\tit->second = true;\n\t\t\t\t\t*++r = Point(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) getNodes(vec[i].x, vec[i].y);\n\t\taddEdges();\n\t\tif (bfsCount()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmap.clear();\n\treturn ans;\n}\n\ninline bool isInvalid() {\n\tconst unsigned long long r = static_cast<unsigned long long>(n) * m - c;\n\tif (r < 2) return true;\n\telse if (r == 2) {\n\t\tstatic bool flag[MAXC];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tflag[(a[i].x - 1) * m + a[i].y - 1] = true;\n\t\t}\n\n\t\tPoint pts[2];\n\t\tfor (int i = 0, cnt = 0; i < n; i++) for (int j = 0; j < m; j++) {\n\t\t\tif (!flag[i * m + j]) pts[cnt++] = Point(i, j);\n\t\t\tflag[i * m + j] = false;\n\t\t}\n\n\t\treturn abs(pts[0].x - pts[1].x) + abs(pts[0].y - pts[1].y) == 1;\n\t} else return false;\n}\n\ninline const char *special() {\n\tstd::sort(a, a + c);\n\tint last = 0, cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (a[i].y != last + 1) {\n\t\t\tcnt++;\n\t\t}\n\t\tlast = a[i].y;\n\t}\n\tif (last != m) cnt++;\n\treturn cnt == 1 ? \"1\" : \"0\";\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar_unlocked(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar_unlocked(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tint t;\n\tread(t);\n\twhile (t--) {\n\t\tread(n), read(m), read(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tread(a[i].x), read(a[i].y);\n\t\t\tif (n > m) std::swap(a[i].x, a[i].y);\n\t\t}\n\n\t\tif (n > m) std::swap(n, m);\n\n\t\tif (isInvalid()) puts(\"-1\");\n\t\telse if (n == 1) puts(special());\n\t\telse if (isZero()) puts(\"0\");\n\t\telse if (isOne()) puts(\"1\");\n\t\telse puts(\"2\");\n\n#ifdef DBG\n\t\tfor (Node *v = N; v != p; v++) {\n\t\t\tprintf(\"[%d, %d] => %d\\n\", v->x, v->y, v->type);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tHashMap<unsigned long long, Node *>::iterator it = map.find(HASH(i, j));\n\t\t\t\tif (it == map.end()) putchar('-');\n\t\t\t\telse if (!it->second) putchar('X');\n\t\t\t\telse putchar('0' + it->second->type);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tputchar(str[i][j] ? str[i][j] : '-');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n#endif\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2016-grid","published":1,"updated":"2016-09-11T23:54:29.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji9600oe0jxlrllepmdx"},{"title":"NOI2016 - Hash","date":"2016-09-05T23:34:00.000Z","_content":"\n `AABB`  $ A $  $ B $ \n\n `aabaabaa` $ A = \\texttt{aab}, B = \\texttt{a} $ `AABB` \n\n $ A = \\texttt{a}, B = \\texttt{baa} $ `AABB`  `abaabaa` \n\n $ n $  $ S $\n\n<!-- more -->\n\n### \n[](https://blog.sengxian.com/solutions/bzoj-4650)\n\n### \nHash T  \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\ntypedef unsigned __int128 hash1_t;\n\nconst int MAXN = 30000;\nconst hash1_t BASE1 = 233;\n// const hash2_t BASE2 = 233;\n// const hash3_t BASE3 = 53;\n\nchar s[MAXN];\nint n;\nlong long forward[MAXN + 1], backward[MAXN + 1];\n\nhash1_t hash1[MAXN], base1[MAXN + 1];\n// hash2_t hash2[MAXN], base2[MAXN + 1];\n// hash3_t hash3[MAXN], base3[MAXN + 1];\n\ninline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) {\n\treturn hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len];\n\t\t// && hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len]\n\t\t// && hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len];\n\t// register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len];\n\t// register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len];\n\t// const bool res = h1 == h2;\n\t// assert(res == (memcmp(&s[a], &s[b], len) == 0));\n\t// return h1 == h2;\n\t// return memcmp(&s[a], &s[b], len) == 0;\n}\n\ninline __attribute__((always_inline)) int lcp(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = n - b;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a, b, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\ninline __attribute__((always_inline)) int lcs(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = a + 1;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a - m + 1, b - m + 1, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\t// base1[0] = base2[0] = base3[0] = 1;\n\tbase1[0] = 1;\n\t// for (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE % MOD;\n\tfor (register int i = 1; i <= MAXN; i++) {\n\t\tbase1[i] = base1[i - 1] * BASE1;\n\t\t// base2[i] = base2[i - 1] * BASE2;\n\t\t// base3[i] = base3[i - 1] * BASE3;\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tfor (register int i = 0; i < n; i++) s[i] -= 'a' - 1;\n\n\t\t// hash1[0] = hash2[0] = hash3[0] = s[0];\n\t\thash1[0] = s[0];\n\t\t// for (int i = 1; i < n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD;\n\t\tfor (register int i = 1; i < n; i++) {\n\t\t\thash1[i] = (hash1[i - 1] * BASE1 + s[i]);\n\t\t\t// hash2[i] = (hash2[i - 1] * BASE2 + s[i]);\n\t\t\t// hash3[i] = (hash3[i - 1] * BASE3 + s[i]);\n\t\t}\n\n\t\tfor (register int k = 1; k <= n / 2; k++) {\n\t\t\t// printf(\"k = %d\\n\", k);\n\t\t\tfor (register int i = 0; i < n; i += k) {\n\t\t\t\tconst register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k);\n\t\t\t\t// printf(\"lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\\n\", i, i + k, a, i, i + k, b);\n\t\t\t\tif (a + b >= k) {\n\t\t\t\t\tregister int l, r;\n\t\t\t\t\tl = i + k + k - a - 1, r = l + (a + b - k);\n\t\t\t\t\t// l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1);\n\t\t\t\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\t\t\t\t// for (int i = l; i <= r; i++) backward[i]++;\n\t\t\t\t\tbackward[l]++, backward[r + 1]--;\n\t\t\t\t\tr = r - 2 * k + 1, l = l - 2 * k + 1;\n\t\t\t\t\t// for (int i = l; i <= r; i++) forward[i]++;\n\t\t\t\t\tforward[l]++, forward[r + 1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (register int i = 1; i < n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1];\n\n\t\tregister long long ans = 0;\n\t\tfor (register int i = 1; i < n; i++) ans += backward[i - 1] * forward[i];\n\n\t\tfor (register int i = 0; i < n; i++) {\n\t\t\thash1[i] = 0;\n\t\t\t// hash2[i] = 0;\n\t\t\t// hash3[i] = 0;\n\t\t\tbackward[i] = forward[i] = 0;\n\t\t}\n\t\tforward[n] = backward[n] = 0;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2016-excellent.md","raw":"title: NOI2016 - Hash\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - Hash\npermalink: noi2016-excellent\ndate: 2016-09-06 07:34:00\n---\n\n `AABB`  $ A $  $ B $ \n\n `aabaabaa` $ A = \\texttt{aab}, B = \\texttt{a} $ `AABB` \n\n $ A = \\texttt{a}, B = \\texttt{baa} $ `AABB`  `abaabaa` \n\n $ n $  $ S $\n\n<!-- more -->\n\n### \n[](https://blog.sengxian.com/solutions/bzoj-4650)\n\n### \nHash T  \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\ntypedef unsigned __int128 hash1_t;\n\nconst int MAXN = 30000;\nconst hash1_t BASE1 = 233;\n// const hash2_t BASE2 = 233;\n// const hash3_t BASE3 = 53;\n\nchar s[MAXN];\nint n;\nlong long forward[MAXN + 1], backward[MAXN + 1];\n\nhash1_t hash1[MAXN], base1[MAXN + 1];\n// hash2_t hash2[MAXN], base2[MAXN + 1];\n// hash3_t hash3[MAXN], base3[MAXN + 1];\n\ninline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) {\n\treturn hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len];\n\t\t// && hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len]\n\t\t// && hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len];\n\t// register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len];\n\t// register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len];\n\t// const bool res = h1 == h2;\n\t// assert(res == (memcmp(&s[a], &s[b], len) == 0));\n\t// return h1 == h2;\n\t// return memcmp(&s[a], &s[b], len) == 0;\n}\n\ninline __attribute__((always_inline)) int lcp(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = n - b;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a, b, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\ninline __attribute__((always_inline)) int lcs(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = a + 1;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a - m + 1, b - m + 1, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\t// base1[0] = base2[0] = base3[0] = 1;\n\tbase1[0] = 1;\n\t// for (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE % MOD;\n\tfor (register int i = 1; i <= MAXN; i++) {\n\t\tbase1[i] = base1[i - 1] * BASE1;\n\t\t// base2[i] = base2[i - 1] * BASE2;\n\t\t// base3[i] = base3[i - 1] * BASE3;\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tfor (register int i = 0; i < n; i++) s[i] -= 'a' - 1;\n\n\t\t// hash1[0] = hash2[0] = hash3[0] = s[0];\n\t\thash1[0] = s[0];\n\t\t// for (int i = 1; i < n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD;\n\t\tfor (register int i = 1; i < n; i++) {\n\t\t\thash1[i] = (hash1[i - 1] * BASE1 + s[i]);\n\t\t\t// hash2[i] = (hash2[i - 1] * BASE2 + s[i]);\n\t\t\t// hash3[i] = (hash3[i - 1] * BASE3 + s[i]);\n\t\t}\n\n\t\tfor (register int k = 1; k <= n / 2; k++) {\n\t\t\t// printf(\"k = %d\\n\", k);\n\t\t\tfor (register int i = 0; i < n; i += k) {\n\t\t\t\tconst register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k);\n\t\t\t\t// printf(\"lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\\n\", i, i + k, a, i, i + k, b);\n\t\t\t\tif (a + b >= k) {\n\t\t\t\t\tregister int l, r;\n\t\t\t\t\tl = i + k + k - a - 1, r = l + (a + b - k);\n\t\t\t\t\t// l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1);\n\t\t\t\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\t\t\t\t// for (int i = l; i <= r; i++) backward[i]++;\n\t\t\t\t\tbackward[l]++, backward[r + 1]--;\n\t\t\t\t\tr = r - 2 * k + 1, l = l - 2 * k + 1;\n\t\t\t\t\t// for (int i = l; i <= r; i++) forward[i]++;\n\t\t\t\t\tforward[l]++, forward[r + 1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (register int i = 1; i < n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1];\n\n\t\tregister long long ans = 0;\n\t\tfor (register int i = 1; i < n; i++) ans += backward[i - 1] * forward[i];\n\n\t\tfor (register int i = 0; i < n; i++) {\n\t\t\thash1[i] = 0;\n\t\t\t// hash2[i] = 0;\n\t\t\t// hash3[i] = 0;\n\t\t\tbackward[i] = forward[i] = 0;\n\t\t}\n\t\tforward[n] = backward[n] = 0;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2016-excellent","published":1,"updated":"2016-09-05T23:42:03.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji9e00ol0jxl22hg3d0r"},{"title":"NOI2015 -  + ","date":"2016-06-26T10:14:00.000Z","_content":"\n $ S $  $ f(i) $ $ r \\in [0,\\ n - 1] $\n\n1.  $ \\mathrm {LCP}(\\mathrm{suffix}(i),\\ \\mathrm{suffix}(j)) \\geq r $  $ (i,\\ j) $ \n2.  $ (i, j) $  $ f(i) \\times f(j) $ \n\n<!-- more -->\n\n### \n[BZOJ 4199](http://www.lydsy.com/JudgeOnline/problem.php?id=4199)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n LCP LCP  $ \\geq r $**** $ x $  $ \\frac{x (x + 1)}{2} $\n\n $ f(i) $  $ f(i) $ \n\n\n\n $ r $  $ r $  $ \\mathrm{height}(i) $ $ \\mathrm{height} $ ****\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 300000;\n\nchar s[MAXN + 1];\nint a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\t\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%3d %2d %s\\n\", ::a[sa[i]], ht[i], &s[sa[i]]);\n\tputs(\"----------------\");\n#endif\n}\n\nstruct UnionFindSet {\n\tint f[MAXN], size[MAXN];\n\tint max[MAXN], max2[MAXN], min[MAXN], min2[MAXN];\n#ifdef DBG\n\tbool invalid[MAXN];\n\tint top[MAXN], bottom[MAXN];\n#endif\n\n\tvoid init() {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ti[f] = i;\n\t\t\ti[size] = 1;\n\t\t\tif (A[i] > A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1;\n\t\t\telse i[max] = i[min2] = i - 1, i[min] = i[max2] = i;\n#ifdef DBG\n\t\t\ti[top] = i[bottom] = i;\n\t\t\ti[invalid] = false;\n#endif\n\t\t}\n\t}\n\n\ttemplate <typename T>\n\tvoid updateMinMax(int &m, int &m2, const int x, T compare) {\n\t\tif (compare(A[x], A[m])) m2 = m, m = x;\n\t\telse if (x != m && compare(A[x], A[m2])) m2 = x;\n\t}\n\n\tvoid addTo(const int a, const int b) {\n#ifdef DBG\n\t\ta[invalid] = true;\n\t\tb[top] = std::min(b[top], a[top]);\n\t\tb[bottom] = std::max(b[bottom], a[bottom]);\n#endif\n\t\tb[size] = a[size] + b[size];\n\t\ta[size] = 0;\n\n\t\tupdateMinMax(b[max], b[max2], a[max], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[max2], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min2], std::greater<int>());\n\n\t\tupdateMinMax(b[min], b[min2], a[min], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[min2], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max2], std::less<int>());\n\t}\n\n\tint find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) {\n\t\tint res = x;\n\t\twhile (res[f] != res) res = res[f];\n\t\tfor (int i = x, tmp; i != res; ) {\n\t\t\ttmp = i[f];\n\t\t\taddTo(i, res);\n\t\t\ti[f] = res;\n\t\t\ti = tmp;\n\t\t}\n\n\t\tif (size) *size = this->size[res];\n\t\tif (max) *max = A[this->max[res]];\n\t\tif (max2) *max2 = A[this->max2[res]];\n\t\tif (min) *min = A[this->min[res]];\n\t\tif (min2) *min2 = A[this->min2[res]];\n\n\t\treturn res;\n\t}\n\n\tbool test(const int a, const int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(const int a, const int b) {\n\t\t// printf(\"merge(%d, %d)\\n\", a, b);\n\t\tint x = find(a), y = find(b);\n\t\t// printf(\"-- merge(%d, %d)\\n\", x, y);\n\t\tassert(x != y);\n\t\taddTo(x, y);\n\t\tx[f] = y;\n\t}\n\n#ifdef DBG\n\tvoid print() {\n\t\tfor (int i = 1; i < n; i++) find(i);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (invalid[i]) continue;\n\t\t\tprintf(\"[%d]: \", i);\n\t\t\tif (f[i] == i) printf(\"root, \");\n\t\t\telse printf(\"f = %d, \", f[i]);\n\n\t\t\tprintf(\"[%d, %d], size = %d, max = [%d] -> %d, max2 = [%d] -> %d, min = [%d] -> %d, min2 = [%d] -> %d\\n\", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]);\n\t\t}\n\t}\n#endif\n} ufs;\n\ninline long long calcCnt(const int x) {\n\tint size;\n\tufs.find(x, &size);\n\tlong long cnt = static_cast<long long>(size) * (size + 1) / 2;\n\t// printf(\"cnt(%d) = %d\\n\", x, cnt);\n\treturn cnt;\n}\n\ninline long long calcMax(const int x) {\n\tint max, max2, min, min2;\n\tufs.find(x, NULL, &max, &max2, &min, &min2);\n\treturn std::max(static_cast<long long>(max) * max2, static_cast<long long>(min) * min2);\n}\n\nint main() {\n\tscanf(\"%d\\n%s\", &n, s);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) A[i] = a[sa[i]];\n\n\tufs.init();\n\n\tstd::vector<int> v[MAXN];\n\tfor (int i = 1; i < n; i++) v[ht[i]].push_back(i);\n\n\tlong long cnt = 0, max = LLONG_MIN;\n\tstd::stack< std::pair<long long, long long> > stack;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t// printf(\"ht[%d] = %d\\n\", *it, ht[*it]);\n\n\t\t\tif (!(it != v[i].end() - 1 && ufs.test(*(it + 1), *it + 1))) {\n\t\t\t\tif (*it != n - 1) {\n\t\t\t\t\tif (ht[*it + 1] >= ht[*it] && !ufs.test(*it + 1, *it)) {\n\t\t\t\t\t\t// puts(\"------- + 1\");\n\t\t\t\t\t\tcnt -= calcCnt(*it + 1);\n\t\t\t\t\t\tufs.merge(*it, *it + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*it != 1 && ht[*it - 1] >= ht[*it] && !ufs.test(*it - 1, *it)) {\n\t\t\t\t// puts(\"------- - 1\");\n\t\t\t\tcnt -= calcCnt(*it - 1);\n\t\t\t\tufs.merge(*it, *it - 1);\n\t\t\t}\n\n\t\t\t// puts(\"+++++++\");\n\t\t\tcnt += calcCnt(*it);\n\t\t\tmax = std::max(max, calcMax(*it));\n#ifdef DBG\n\t\t\tprintf(\"calcMax(%d) = %lld\\n\", *it, calcMax(*it));\n#endif\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", cnt, max == LLONG_MIN ? 0 : max);\n\t\tif (cnt != 0) ufs.print();\n#else\n\t\tstack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max));\n#endif\n\t}\n\n#ifndef DBG\n\twhile (!stack.empty()) {\n\t\tprintf(\"%lld %lld\\n\", stack.top().first, stack.top().second);\n\t\tstack.pop();\n\t}\n#endif\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-savour.md","raw":"title: NOI2015 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-savour\ndate: 2016-06-26 18:14:00\n---\n\n $ S $  $ f(i) $ $ r \\in [0,\\ n - 1] $\n\n1.  $ \\mathrm {LCP}(\\mathrm{suffix}(i),\\ \\mathrm{suffix}(j)) \\geq r $  $ (i,\\ j) $ \n2.  $ (i, j) $  $ f(i) \\times f(j) $ \n\n<!-- more -->\n\n### \n[BZOJ 4199](http://www.lydsy.com/JudgeOnline/problem.php?id=4199)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n LCP LCP  $ \\geq r $**** $ x $  $ \\frac{x (x + 1)}{2} $\n\n $ f(i) $  $ f(i) $ \n\n\n\n $ r $  $ r $  $ \\mathrm{height}(i) $ $ \\mathrm{height} $ ****\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 300000;\n\nchar s[MAXN + 1];\nint a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\t\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%3d %2d %s\\n\", ::a[sa[i]], ht[i], &s[sa[i]]);\n\tputs(\"----------------\");\n#endif\n}\n\nstruct UnionFindSet {\n\tint f[MAXN], size[MAXN];\n\tint max[MAXN], max2[MAXN], min[MAXN], min2[MAXN];\n#ifdef DBG\n\tbool invalid[MAXN];\n\tint top[MAXN], bottom[MAXN];\n#endif\n\n\tvoid init() {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ti[f] = i;\n\t\t\ti[size] = 1;\n\t\t\tif (A[i] > A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1;\n\t\t\telse i[max] = i[min2] = i - 1, i[min] = i[max2] = i;\n#ifdef DBG\n\t\t\ti[top] = i[bottom] = i;\n\t\t\ti[invalid] = false;\n#endif\n\t\t}\n\t}\n\n\ttemplate <typename T>\n\tvoid updateMinMax(int &m, int &m2, const int x, T compare) {\n\t\tif (compare(A[x], A[m])) m2 = m, m = x;\n\t\telse if (x != m && compare(A[x], A[m2])) m2 = x;\n\t}\n\n\tvoid addTo(const int a, const int b) {\n#ifdef DBG\n\t\ta[invalid] = true;\n\t\tb[top] = std::min(b[top], a[top]);\n\t\tb[bottom] = std::max(b[bottom], a[bottom]);\n#endif\n\t\tb[size] = a[size] + b[size];\n\t\ta[size] = 0;\n\n\t\tupdateMinMax(b[max], b[max2], a[max], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[max2], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min2], std::greater<int>());\n\n\t\tupdateMinMax(b[min], b[min2], a[min], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[min2], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max2], std::less<int>());\n\t}\n\n\tint find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) {\n\t\tint res = x;\n\t\twhile (res[f] != res) res = res[f];\n\t\tfor (int i = x, tmp; i != res; ) {\n\t\t\ttmp = i[f];\n\t\t\taddTo(i, res);\n\t\t\ti[f] = res;\n\t\t\ti = tmp;\n\t\t}\n\n\t\tif (size) *size = this->size[res];\n\t\tif (max) *max = A[this->max[res]];\n\t\tif (max2) *max2 = A[this->max2[res]];\n\t\tif (min) *min = A[this->min[res]];\n\t\tif (min2) *min2 = A[this->min2[res]];\n\n\t\treturn res;\n\t}\n\n\tbool test(const int a, const int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(const int a, const int b) {\n\t\t// printf(\"merge(%d, %d)\\n\", a, b);\n\t\tint x = find(a), y = find(b);\n\t\t// printf(\"-- merge(%d, %d)\\n\", x, y);\n\t\tassert(x != y);\n\t\taddTo(x, y);\n\t\tx[f] = y;\n\t}\n\n#ifdef DBG\n\tvoid print() {\n\t\tfor (int i = 1; i < n; i++) find(i);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (invalid[i]) continue;\n\t\t\tprintf(\"[%d]: \", i);\n\t\t\tif (f[i] == i) printf(\"root, \");\n\t\t\telse printf(\"f = %d, \", f[i]);\n\n\t\t\tprintf(\"[%d, %d], size = %d, max = [%d] -> %d, max2 = [%d] -> %d, min = [%d] -> %d, min2 = [%d] -> %d\\n\", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]);\n\t\t}\n\t}\n#endif\n} ufs;\n\ninline long long calcCnt(const int x) {\n\tint size;\n\tufs.find(x, &size);\n\tlong long cnt = static_cast<long long>(size) * (size + 1) / 2;\n\t// printf(\"cnt(%d) = %d\\n\", x, cnt);\n\treturn cnt;\n}\n\ninline long long calcMax(const int x) {\n\tint max, max2, min, min2;\n\tufs.find(x, NULL, &max, &max2, &min, &min2);\n\treturn std::max(static_cast<long long>(max) * max2, static_cast<long long>(min) * min2);\n}\n\nint main() {\n\tscanf(\"%d\\n%s\", &n, s);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) A[i] = a[sa[i]];\n\n\tufs.init();\n\n\tstd::vector<int> v[MAXN];\n\tfor (int i = 1; i < n; i++) v[ht[i]].push_back(i);\n\n\tlong long cnt = 0, max = LLONG_MIN;\n\tstd::stack< std::pair<long long, long long> > stack;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t// printf(\"ht[%d] = %d\\n\", *it, ht[*it]);\n\n\t\t\tif (!(it != v[i].end() - 1 && ufs.test(*(it + 1), *it + 1))) {\n\t\t\t\tif (*it != n - 1) {\n\t\t\t\t\tif (ht[*it + 1] >= ht[*it] && !ufs.test(*it + 1, *it)) {\n\t\t\t\t\t\t// puts(\"------- + 1\");\n\t\t\t\t\t\tcnt -= calcCnt(*it + 1);\n\t\t\t\t\t\tufs.merge(*it, *it + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*it != 1 && ht[*it - 1] >= ht[*it] && !ufs.test(*it - 1, *it)) {\n\t\t\t\t// puts(\"------- - 1\");\n\t\t\t\tcnt -= calcCnt(*it - 1);\n\t\t\t\tufs.merge(*it, *it - 1);\n\t\t\t}\n\n\t\t\t// puts(\"+++++++\");\n\t\t\tcnt += calcCnt(*it);\n\t\t\tmax = std::max(max, calcMax(*it));\n#ifdef DBG\n\t\t\tprintf(\"calcMax(%d) = %lld\\n\", *it, calcMax(*it));\n#endif\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", cnt, max == LLONG_MIN ? 0 : max);\n\t\tif (cnt != 0) ufs.print();\n#else\n\t\tstack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max));\n#endif\n\t}\n\n#ifndef DBG\n\twhile (!stack.empty()) {\n\t\tprintf(\"%lld %lld\\n\", stack.top().first, stack.top().second);\n\t\tstack.pop();\n\t}\n#endif\n\n\treturn 0;\n}\n```\n","slug":"noi2015-savour","published":1,"updated":"2016-07-01T01:28:39.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji9h00or0jxljgkyge18"},{"title":"NOI2015 -  + ","id":"34","updated":"2016-01-21T13:36:13.000Z","date":"2016-01-21T13:32:49.000Z","_content":"\n `n` $x_i=x_j$$x_ix_j$ / \n\n<!-- more -->\n\n### \n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### \n`x` \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-prog.md","raw":"title: NOI2015 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  - map\npermalink: noi2015-prog\nid: 34\nupdated: '2016-01-21 21:36:13'\ndate: 2016-01-21 21:32:49\n---\n\n `n` $x_i=x_j$$x_ix_j$ / \n\n<!-- more -->\n\n### \n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### \n`x` \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2015-prog","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji9l00oy0jxlkk7qscrm"},{"title":"NOI2015 - ","id":"35","updated":"2016-01-29T00:22:32.000Z","date":"2016-01-23T02:10:12.000Z","_content":"\n A  B A  B BA 0  0 \n\n<!-- more -->\n\n### \n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### \n\n\n1. \n2. \n3. \n4. \n\n DFS DFS  DFS  DFS  DFS  DFS \n\n### \n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2015-manager.md","raw":"title: NOI2015 - \ncategories: OI\ntags: \n  - NOI\n  - CodeVS\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-manager\nid: 35\nupdated: '2016-01-29 08:22:32'\ndate: 2016-01-23 10:10:12\n---\n\n A  B A  B BA 0  0 \n\n<!-- more -->\n\n### \n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### \n\n\n1. \n2. \n3. \n4. \n\n DFS DFS  DFS  DFS  DFS  DFS \n\n### \n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2015-manager","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji9u00pa0jxlt7vc9165"},{"title":"NOI2015 - DP + ","date":"2016-06-29T10:33:00.000Z","_content":"\n $ n $ \n\n1.  $ 45 ^ \\circ $ $ 45 ^ \\circ $ ********\n2.  (1) \n3.  (1) **** $ 45 ^ \\circ $ $ 45 ^ \\circ $  DAG DAG \n\n<!-- more -->\n\n### \n[BZOJ 4200](http://www.lydsy.com/JudgeOnline/problem.php?id=4200)  \n[UOJ #132](http://uoj.ac/problem/132)\n\n### \n#### \n $ (x_1, y_1) $  $ (x_2, y_2) $ $ y_1 = y_2 $ $ x_1 + y_1 = x_2 + y_2 $  $ x_1 - y_1 = x_2 - y_2 $\n\n\n\n\n\n1. \n2. \n\n  \n\n $ a $$ b $$ a $  $ b $  $ a $  $ b $  $ a $  $ a $  $ b $\n\n $ a $  $ b $  $ a $  $ 1 $  $ b $ \n\n|   | 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 5 | 0 | 1 | 2 | 3 | 4 |\n| 5 | 4 | 0 | 2 | 3 | 4 |\n| 5 | 4 | 3 | 0 | 3 | 4 |\n| 5 | 4 | 3 | 2 | 0 | 4 |\n| 5 | 4 | 3 | 2 | 1 | 0 |\n\n $ b $  $ b $  $ O(\\log n) $ \n\n $ O(n \\log n) $\n\n#### \n\n\n\n\n#### \n\n\n $ 1 $ $ +\\infty $ \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <tr1/functional>\n\nconst int MAXN = 50000 + 1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, in;\n} N[MAXN + 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f;\n\t\t\t\te->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"dinic(%d, %d, %d) = %d\\n\", s, t, n, res);\n#endif\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n#ifdef DBG\n\tprintf(\"E(%d, %d, %d)\\n\", s, t, c);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void addEdge(const int s, const int t, const int l, const int r) {\n\tN[s].in -= l;\n\tN[t].in += l;\n\taddEdge(s, t, r - l);\n}\n\ninline int minFlow(const int s, const int t, const int n) {\n\tconst int S = n, T = n + 1;\n\tint full = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].in > 0) addEdge(S, i, N[i].in), full += N[i].in;\n\t\telse if (N[i].in < 0) addEdge(i, T, -N[i].in);\n\t}\n\tEdge *e = addEdge(t, s, INT_MAX);\n\n\tassert(dinic(S, T, n + 2) == full);\n\n\tint f = e->f;\n\n\te->c = e->r->c = 0;\n\tfor (e = N[s].e; e; e = e->next) e->c = e->r->c = 0;\n\tfor (e = N[t].e; e; e = e->next) e->c = e->r->c = 0;\n\n\treturn f - dinic(t, s, n);\n}\n\nstruct DPValue;\nstruct Point;\n\nstruct DPValue {\n\tPoint *prec;\n\tint x;\n\n\tDPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {}\n\n\tDPValue extend(Point &p, const int delta) { return DPValue(&p, x + delta); }\n\n\toperator int() const { return x; }\n};\n\nstruct Point {\n\tint id, x, y, lineIndex;\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator itX, itDiagonal1, itDiagonal2;\n\tDPValue dpUp, dpInline;\n\tbool flagUp, flagInline;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorY() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorX() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal1() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal2() const;\n};\n\nbool compareByY(const Point &a, const Point &b) { return a.y > b.y; }\nbool compareByX(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal1(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal2(const Point &a, const Point &b) { return a.x < b.x; }\n\nint n, lineCnt;\nPoint a[MAXN];\nstd::vector< std::tr1::reference_wrapper<Point> > lines[MAXN];\nstd::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > > mapX, mapDiagonal1, mapDiagonal2;\n\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorY() const { return lines[lineIndex]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorX() const { return mapX[x]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; }\n\ninline void dpUp(const int lineIndex) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = v.begin(); it != v.end(); it++) {\n\t\tPoint &p = it->get();\n\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\tif (p.itX != p.getVectorX().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itX - 1)->get().dpInline.extend((p.itX - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)->get().dpInline.extend((p.itDiagonal1 - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)->get().dpInline.extend((p.itDiagonal2 - 1)->get(), 1));\n\t\t}\n\t}\n}\n\ninline void dpInline(const int lineIndex) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\n\tsegment = SegmentTree::build(0, v.size() - 1);\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), i));\n\t}\n\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i].get().dpInline = segment->query();\n\t\tif (i < v.size() - 1) {\n\t\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1));\n\t\t\tsegment->update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0));\n\t\t}\n\t}\n\n\tdelete segment;\n}\n\ninline void dp() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != 0) dpUp(i);\n\t\tdpInline(i);\n\t}\n}\n\ninline void getInlinePath(std::vector<Point *> &v, Point *s, Point *t) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &line = s->getVectorY();\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator a = std::lower_bound(line.begin(), line.end(), *s, &compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &compareByX);\n\n\tassert(&a->get() == s);\n\tassert(&b->get() == t);\n\n#ifdef DBG\n\tprintf(\"getInlinePath(%d(%d, %d), %d(%d, %d))\\n\", s->id, s->x, s->y, t->id, t->x, t->y);\n#endif\n\n\tif (a < b) {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= line.begin(); it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it <= b; it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t} else {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it != line.end(); it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= b; it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t}\n}\n\ninline void getPath(std::vector<Point *> &v) {\n\tPoint *p = &a[n - 1];\n\tbool flag = false;\n\twhile (p->dpUp.x || (!flag && p->dpInline.x && p->dpInline.prec != p)) {\n\t\tif (flag || p->dpInline.prec == p || p->dpInline.x <= p->dpUp.x) {\n#ifdef DBG\n\t\t\tprintf(\"%d(%d, %d) -> %d(%d, %d)\\n\", p->id, p->x, p->y, p->dpUp.prec->id, p->dpUp.prec->x, p->dpUp.prec->y);\n#endif\n\t\t\tp = p->dpUp.prec;\n\t\t\tv.push_back(p);\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tgetInlinePath(v, p, p->dpInline.prec);\n\t\t\tp = p->dpInline.prec;\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\ninline void getEdges(std::vector< std::pair<Point *, Point *> > &E) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\t\tbool flag;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (flag) pushDown();\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (flag) {\n\t\t\t\tif (lc || rc) {\n\t\t\t\t\tif (val.x == lc->val.x) lc->flag = true;\n\t\t\t\t\tif (val.x == rc->val.x) rc->flag = true;\n\t\t\t\t} else {\n\t\t\t\t\tval.prec->flagInline = true;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tpushDown();\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tvoid mark() { flag = true; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\ta[n - 1].flagUp = true;\n\n\tfor (int i = lineCnt - 1; i >= 0; i--) {\n\t\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[i];\n\t\tsegment = SegmentTree::build(0, v.size() - 1);\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), j));\n\t\t}\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagUp) {\n\t\t\t\tsegment->mark();\n\t\t\t}\n\n\t\t\tif (j < v.size() - 1) {\n\t\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1));\n\t\t\t\tsegment->update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0));\n\t\t\t}\n\t\t}\n\n\t\tdelete segment;\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagInline) {\n\t\t\t\tPoint &p = v[j].get();\n\t\t\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\t\t\tif (p.itX != p.getVectorX().begin() && p.dpUp.x == (p.itX - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itX - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itX - 1)->get().x, (p.itX - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itX - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin() && p.dpUp.x == (p.itDiagonal1 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal1 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal1 - 1)->get().x, (p.itDiagonal1 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal1 - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin() && p.dpUp.x == (p.itDiagonal2 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal2 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal2 - 1)->get().x, (p.itDiagonal2 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal2 - 1)->get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void sort() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tstd::sort(lines[i].begin(), lines[i].end(), &compareByX);\n\t}\n\t\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByY);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itX = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal2);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal1 = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal1);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal2 = it2;\n\t\t}\n\t}\n}\n\n#ifdef DBG\ninline void debugPrint() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tprintf(\"lines[%d] = { \", i);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) {\n\t\t\tconst Point &p = *it;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it + 1 == lines[i].end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tprintf(\"x[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tprintf(\"diagonal1[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tprintf(\"diagonal2[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"(%d, %d): \", a[i].x, a[i].y);\n\t\tif (a[i].dpUp.prec) printf(\"dpUp[%d] = { (%d, %d), %d }, \", i, a[i].dpUp.prec->x, a[i].dpUp.prec->y, a[i].dpUp.x);\n\t\telse printf(\"dpUp[%d] = { nullptr, %d }, \", i, a[i].dpUp.x);\n\t\tif (a[i].dpInline.prec) printf(\"dpInline[%d] = { (%d, %d), %d }\\n\", i, a[i].dpInline.prec->x, a[i].dpInline.prec->y, a[i].dpInline.x);\n\t\telse printf(\"dpInline[%d] = { nullptr, %d }\\n\", i, a[i].dpInline.x);\n\t}\n}\n#endif\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t\ta[i].id = i;\n\t}\n\ta[n].x = 0, a[n].y = 0, a[n].id = n, n++;\n\n\tstd::sort(a, a + n, &compareByY);\n\n\tfor (int i = 0, last; i < n; i++) {\n\t\tPoint &p = a[i];\n\n\t\tif (!i || p.y != a[last].y) ++lineCnt;\n\t\tlines[lineCnt - 1].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tp.lineIndex = lineCnt - 1;\n\n\t\tmapX[p.x].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\n\t\tlast = i;\n\t}\n\n\tsort();\n\n\n#ifdef DBG\n\tdebugPrint();\n#endif\n\t\n\tdp();\n\n\tint cnt = a[n - 1].dpInline.x;\n\tprintf(\"%d\\n\", cnt);\n\n\tstd::vector<Point *> v;\n\tgetPath(v);\n#ifdef DBG\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d: (%d, %d)\\n\", v[i]->id + 1, v[i]->x, v[i]->y);\n#else\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d%c\", v[i]->id + 1, i == v.size() - 1 ? '\\n' : ' ');\n#endif\n\n\tstd::vector< std::pair<Point *, Point *> > E;\n\tgetEdges(E);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX);\n\tfor (std::vector< std::pair<Point *, Point *> >::const_iterator it = E.begin(); it != E.end(); it++) {\n\t\taddEdge(it->first->id + 1, it->second->id + 1, 1, INT_MAX);\n\t}\n\n\tprintf(\"%d\\n\", minFlow(s, t, n + 2));\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-farm.md","raw":"title: NOI2015 - DP + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - DP\n  - \n  - \n  - Dinic\npermalink: noi2015-farm\ndate: 2016-06-29 18:33:00\n---\n\n $ n $ \n\n1.  $ 45 ^ \\circ $ $ 45 ^ \\circ $ ********\n2.  (1) \n3.  (1) **** $ 45 ^ \\circ $ $ 45 ^ \\circ $  DAG DAG \n\n<!-- more -->\n\n### \n[BZOJ 4200](http://www.lydsy.com/JudgeOnline/problem.php?id=4200)  \n[UOJ #132](http://uoj.ac/problem/132)\n\n### \n#### \n $ (x_1, y_1) $  $ (x_2, y_2) $ $ y_1 = y_2 $ $ x_1 + y_1 = x_2 + y_2 $  $ x_1 - y_1 = x_2 - y_2 $\n\n\n\n\n\n1. \n2. \n\n  \n\n $ a $$ b $$ a $  $ b $  $ a $  $ b $  $ a $  $ a $  $ b $\n\n $ a $  $ b $  $ a $  $ 1 $  $ b $ \n\n|   | 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 5 | 0 | 1 | 2 | 3 | 4 |\n| 5 | 4 | 0 | 2 | 3 | 4 |\n| 5 | 4 | 3 | 0 | 3 | 4 |\n| 5 | 4 | 3 | 2 | 0 | 4 |\n| 5 | 4 | 3 | 2 | 1 | 0 |\n\n $ b $  $ b $  $ O(\\log n) $ \n\n $ O(n \\log n) $\n\n#### \n\n\n\n\n#### \n\n\n $ 1 $ $ +\\infty $ \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <tr1/functional>\n\nconst int MAXN = 50000 + 1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, in;\n} N[MAXN + 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f;\n\t\t\t\te->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"dinic(%d, %d, %d) = %d\\n\", s, t, n, res);\n#endif\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n#ifdef DBG\n\tprintf(\"E(%d, %d, %d)\\n\", s, t, c);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void addEdge(const int s, const int t, const int l, const int r) {\n\tN[s].in -= l;\n\tN[t].in += l;\n\taddEdge(s, t, r - l);\n}\n\ninline int minFlow(const int s, const int t, const int n) {\n\tconst int S = n, T = n + 1;\n\tint full = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].in > 0) addEdge(S, i, N[i].in), full += N[i].in;\n\t\telse if (N[i].in < 0) addEdge(i, T, -N[i].in);\n\t}\n\tEdge *e = addEdge(t, s, INT_MAX);\n\n\tassert(dinic(S, T, n + 2) == full);\n\n\tint f = e->f;\n\n\te->c = e->r->c = 0;\n\tfor (e = N[s].e; e; e = e->next) e->c = e->r->c = 0;\n\tfor (e = N[t].e; e; e = e->next) e->c = e->r->c = 0;\n\n\treturn f - dinic(t, s, n);\n}\n\nstruct DPValue;\nstruct Point;\n\nstruct DPValue {\n\tPoint *prec;\n\tint x;\n\n\tDPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {}\n\n\tDPValue extend(Point &p, const int delta) { return DPValue(&p, x + delta); }\n\n\toperator int() const { return x; }\n};\n\nstruct Point {\n\tint id, x, y, lineIndex;\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator itX, itDiagonal1, itDiagonal2;\n\tDPValue dpUp, dpInline;\n\tbool flagUp, flagInline;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorY() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorX() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal1() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal2() const;\n};\n\nbool compareByY(const Point &a, const Point &b) { return a.y > b.y; }\nbool compareByX(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal1(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal2(const Point &a, const Point &b) { return a.x < b.x; }\n\nint n, lineCnt;\nPoint a[MAXN];\nstd::vector< std::tr1::reference_wrapper<Point> > lines[MAXN];\nstd::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > > mapX, mapDiagonal1, mapDiagonal2;\n\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorY() const { return lines[lineIndex]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorX() const { return mapX[x]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; }\n\ninline void dpUp(const int lineIndex) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = v.begin(); it != v.end(); it++) {\n\t\tPoint &p = it->get();\n\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\tif (p.itX != p.getVectorX().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itX - 1)->get().dpInline.extend((p.itX - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)->get().dpInline.extend((p.itDiagonal1 - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)->get().dpInline.extend((p.itDiagonal2 - 1)->get(), 1));\n\t\t}\n\t}\n}\n\ninline void dpInline(const int lineIndex) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\n\tsegment = SegmentTree::build(0, v.size() - 1);\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), i));\n\t}\n\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i].get().dpInline = segment->query();\n\t\tif (i < v.size() - 1) {\n\t\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1));\n\t\t\tsegment->update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0));\n\t\t}\n\t}\n\n\tdelete segment;\n}\n\ninline void dp() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != 0) dpUp(i);\n\t\tdpInline(i);\n\t}\n}\n\ninline void getInlinePath(std::vector<Point *> &v, Point *s, Point *t) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &line = s->getVectorY();\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator a = std::lower_bound(line.begin(), line.end(), *s, &compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &compareByX);\n\n\tassert(&a->get() == s);\n\tassert(&b->get() == t);\n\n#ifdef DBG\n\tprintf(\"getInlinePath(%d(%d, %d), %d(%d, %d))\\n\", s->id, s->x, s->y, t->id, t->x, t->y);\n#endif\n\n\tif (a < b) {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= line.begin(); it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it <= b; it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t} else {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it != line.end(); it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= b; it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t}\n}\n\ninline void getPath(std::vector<Point *> &v) {\n\tPoint *p = &a[n - 1];\n\tbool flag = false;\n\twhile (p->dpUp.x || (!flag && p->dpInline.x && p->dpInline.prec != p)) {\n\t\tif (flag || p->dpInline.prec == p || p->dpInline.x <= p->dpUp.x) {\n#ifdef DBG\n\t\t\tprintf(\"%d(%d, %d) -> %d(%d, %d)\\n\", p->id, p->x, p->y, p->dpUp.prec->id, p->dpUp.prec->x, p->dpUp.prec->y);\n#endif\n\t\t\tp = p->dpUp.prec;\n\t\t\tv.push_back(p);\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tgetInlinePath(v, p, p->dpInline.prec);\n\t\t\tp = p->dpInline.prec;\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\ninline void getEdges(std::vector< std::pair<Point *, Point *> > &E) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\t\tbool flag;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (flag) pushDown();\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (flag) {\n\t\t\t\tif (lc || rc) {\n\t\t\t\t\tif (val.x == lc->val.x) lc->flag = true;\n\t\t\t\t\tif (val.x == rc->val.x) rc->flag = true;\n\t\t\t\t} else {\n\t\t\t\t\tval.prec->flagInline = true;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tpushDown();\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tvoid mark() { flag = true; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\ta[n - 1].flagUp = true;\n\n\tfor (int i = lineCnt - 1; i >= 0; i--) {\n\t\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[i];\n\t\tsegment = SegmentTree::build(0, v.size() - 1);\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), j));\n\t\t}\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagUp) {\n\t\t\t\tsegment->mark();\n\t\t\t}\n\n\t\t\tif (j < v.size() - 1) {\n\t\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1));\n\t\t\t\tsegment->update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0));\n\t\t\t}\n\t\t}\n\n\t\tdelete segment;\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagInline) {\n\t\t\t\tPoint &p = v[j].get();\n\t\t\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\t\t\tif (p.itX != p.getVectorX().begin() && p.dpUp.x == (p.itX - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itX - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itX - 1)->get().x, (p.itX - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itX - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin() && p.dpUp.x == (p.itDiagonal1 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal1 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal1 - 1)->get().x, (p.itDiagonal1 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal1 - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin() && p.dpUp.x == (p.itDiagonal2 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal2 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal2 - 1)->get().x, (p.itDiagonal2 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal2 - 1)->get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void sort() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tstd::sort(lines[i].begin(), lines[i].end(), &compareByX);\n\t}\n\t\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByY);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itX = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal2);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal1 = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal1);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal2 = it2;\n\t\t}\n\t}\n}\n\n#ifdef DBG\ninline void debugPrint() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tprintf(\"lines[%d] = { \", i);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) {\n\t\t\tconst Point &p = *it;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it + 1 == lines[i].end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tprintf(\"x[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tprintf(\"diagonal1[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tprintf(\"diagonal2[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"(%d, %d): \", a[i].x, a[i].y);\n\t\tif (a[i].dpUp.prec) printf(\"dpUp[%d] = { (%d, %d), %d }, \", i, a[i].dpUp.prec->x, a[i].dpUp.prec->y, a[i].dpUp.x);\n\t\telse printf(\"dpUp[%d] = { nullptr, %d }, \", i, a[i].dpUp.x);\n\t\tif (a[i].dpInline.prec) printf(\"dpInline[%d] = { (%d, %d), %d }\\n\", i, a[i].dpInline.prec->x, a[i].dpInline.prec->y, a[i].dpInline.x);\n\t\telse printf(\"dpInline[%d] = { nullptr, %d }\\n\", i, a[i].dpInline.x);\n\t}\n}\n#endif\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t\ta[i].id = i;\n\t}\n\ta[n].x = 0, a[n].y = 0, a[n].id = n, n++;\n\n\tstd::sort(a, a + n, &compareByY);\n\n\tfor (int i = 0, last; i < n; i++) {\n\t\tPoint &p = a[i];\n\n\t\tif (!i || p.y != a[last].y) ++lineCnt;\n\t\tlines[lineCnt - 1].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tp.lineIndex = lineCnt - 1;\n\n\t\tmapX[p.x].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\n\t\tlast = i;\n\t}\n\n\tsort();\n\n\n#ifdef DBG\n\tdebugPrint();\n#endif\n\t\n\tdp();\n\n\tint cnt = a[n - 1].dpInline.x;\n\tprintf(\"%d\\n\", cnt);\n\n\tstd::vector<Point *> v;\n\tgetPath(v);\n#ifdef DBG\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d: (%d, %d)\\n\", v[i]->id + 1, v[i]->x, v[i]->y);\n#else\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d%c\", v[i]->id + 1, i == v.size() - 1 ? '\\n' : ' ');\n#endif\n\n\tstd::vector< std::pair<Point *, Point *> > E;\n\tgetEdges(E);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX);\n\tfor (std::vector< std::pair<Point *, Point *> >::const_iterator it = E.begin(); it != E.end(); it++) {\n\t\taddEdge(it->first->id + 1, it->second->id + 1, 1, INT_MAX);\n\t}\n\n\tprintf(\"%d\\n\", minFlow(s, t, n + 2));\n\n\treturn 0;\n}\n```\n","slug":"noi2015-farm","published":1,"updated":"2016-11-01T11:59:21.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63ji9z00pi0jxlsroyq9l5"},{"title":"NOI2015 - ","date":"2016-07-01T01:27:00.000Z","_content":"\n $ n $  $ 1 $  $ n $  $ i $  $ W_i $ $ k $  $ S_i $  $ i $  $ 1 \\leq i,j \\leq n,\\ i \\neq j $$ S_i $  $ S_j $ \n\n1. \n2.  $ S_i $ \n\n<!-- more -->\n\n### \n[BZOJ 4198](http://www.lydsy.com/JudgeOnline/problem.php?id=4198)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n $ k = 2 $ \n\n$ k \\neq 2 $ $ k $ \n\n $ S_i $  $ S_i $ \n\n $ k $  $ 1 $  $ k $  $ k - 1 $  $ n - 1 $   $ W_i = 0 $ $ (n - 1) \\bmod (k - 1) = 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100000;\nconst int MAXK = 9;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tstd::priority_queue< std::pair<long long, int>, std::vector< std::pair<long long, int> >, std::greater< std::pair<long long, int> > > q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long x;\n\t\tscanf(\"%lld\", &x);\n\t\tq.push(std::make_pair(x, 0));\n\t}\n\n\twhile ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0));\n\n\tlong long ans = 0;\n\twhile (q.size() > 1) {\n\t\tstd::pair<long long, int> newNode;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstd::pair<long long, int> p = q.top();\n\t\t\tq.pop();\n\t\t\tans += p.first;\n\t\t\tnewNode.first += p.first;\n\t\t\tnewNode.second = std::max(newNode.second, p.second);\n\t\t}\n\n\t\tnewNode.second++;\n\n\t\tq.push(newNode);\n\t}\n\n\tstd::pair<long long, int> p = q.top();\n\tprintf(\"%lld\\n%d\\n\", ans, p.second);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-epic.md","raw":"title: NOI2015 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-epic\ndate: 2016-07-01 09:27:00\n---\n\n $ n $  $ 1 $  $ n $  $ i $  $ W_i $ $ k $  $ S_i $  $ i $  $ 1 \\leq i,j \\leq n,\\ i \\neq j $$ S_i $  $ S_j $ \n\n1. \n2.  $ S_i $ \n\n<!-- more -->\n\n### \n[BZOJ 4198](http://www.lydsy.com/JudgeOnline/problem.php?id=4198)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n $ k = 2 $ \n\n$ k \\neq 2 $ $ k $ \n\n $ S_i $  $ S_i $ \n\n $ k $  $ 1 $  $ k $  $ k - 1 $  $ n - 1 $   $ W_i = 0 $ $ (n - 1) \\bmod (k - 1) = 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100000;\nconst int MAXK = 9;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tstd::priority_queue< std::pair<long long, int>, std::vector< std::pair<long long, int> >, std::greater< std::pair<long long, int> > > q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long x;\n\t\tscanf(\"%lld\", &x);\n\t\tq.push(std::make_pair(x, 0));\n\t}\n\n\twhile ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0));\n\n\tlong long ans = 0;\n\twhile (q.size() > 1) {\n\t\tstd::pair<long long, int> newNode;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstd::pair<long long, int> p = q.top();\n\t\t\tq.pop();\n\t\t\tans += p.first;\n\t\t\tnewNode.first += p.first;\n\t\t\tnewNode.second = std::max(newNode.second, p.second);\n\t\t}\n\n\t\tnewNode.second++;\n\n\t\tq.push(newNode);\n\t}\n\n\tstd::pair<long long, int> p = q.top();\n\tprintf(\"%lld\\n%d\\n\", ans, p.second);\n\n\treturn 0;\n}\n```\n","slug":"noi2015-epic","published":1,"updated":"2016-07-01T01:28:31.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jia500pr0jxla8w03zeh"},{"title":"NOI2015 -  DP","date":"2016-07-01T05:23:00.000Z","_content":"\n $ 2 $ ~ $ n $  $ n - 1 $  $ a $  $ b $ $ \\gcd(a, b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 4197](http://www.lydsy.com/JudgeOnline/problem.php?id=4197)  \n[UOJ #129](http://uoj.ac/problem/129)\n\n### \n $ f(a, b) $$ a $$ b $  $ a $ $ b $ \n\n $ x $  $ \\sqrt x $  $ 8 $   $ 2, 3, 5, 7, 11, 13, 17, 19 $\n\n $ z $ $ z $  $ z $ \n\n $ z $  $ i $  $ S_i $\n\n $ f(a, b) $ **** $ a $ $ b $ \n\n $ g(i, k, a, b) $  $ i $  $ k $  $ a $ $ b $ \n\n $ x $ $ g(i - 1, 0) $  $ g(i - 1, 1) $  $ g(i, 0) $  $ g(i, 1) $\n\n$$\n\\begin{aligned}\ng(i, 0, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap b \\neq \\emptyset \\\\\n  \\sum\\limits_{a' \\cup S_i = a} g(i - 1, a', b) + f(a, b) & S_i \\cap b = \\emptyset\n  \\end{cases} \\\\\ng(i, 1, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap a \\neq \\emptyset \\\\\n  \\sum\\limits_{b' \\cup S_i = b} g(i - 1, a, b') + f(a, b) & S_i \\cap a = \\emptyset\n  \\end{cases}\n\\end{aligned}\n$$\n\n $ a' $  $ b' $  $ a' $  $ b' $  $ a $  $ b $  $ a' \\leq a $$ b' \\leq b $ $ i $ $ a $  $ b $ $ g(0) $  $ g(1) $\n\n$$\n\\mathrm {for \\ each} \\ i.\\ a = U \\to \\emptyset,\\ b = U \\to \\emptyset \\\\\n\\begin{aligned}\ng(0, a \\cup S_i, b) \\leftarrow g(0, a \\cup S_i, b) + g(0, a, b) && S_i \\cap b = \\emptyset \\\\\ng(0, a, b \\cup S_i) \\leftarrow g(0, a, b \\cup S_i) + g(0, a, b) && S_i \\cap a = \\emptyset \\\\\n\\end{aligned}\n$$\n\n $ \\sqrt x $  $ x $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 500;\nconst int MAXK = 8;\nconst int MAXSTAT = 1 << 8;\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };\n\nint main() {\n\tint n, p;\n\tscanf(\"%d %d\", &n, &p);\n\n\tstd::vector< std::vector<int> > v;\n\tstd::vector< std::pair<int, int> > tmp;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x = i, t = 0;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (x % PRIMES[j] == 0) {\n\t\t\t\twhile (x % PRIMES[j] == 0) x /= PRIMES[j];\n\t\t\t\tt |= 1 << j;\n\t\t\t}\n\t\t}\n\n\t\ttmp.push_back(std::make_pair(x, t));\n\t}\n\n\tstd::sort(tmp.begin(), tmp.end());\n\n\tfor (std::vector< std::pair<int, int> >::const_iterator it = tmp.begin(); it != tmp.end(); it++) {\n\t\tif (it == tmp.begin() || it->first == 1 || it->first != (it - 1)->first) {\n\t\t\tv.resize(v.size() + 1);\n\t\t}\n\t\tv.back().push_back(it->second);\n\t}\n\n\tstatic int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT];\n\tf[0][0] = 1;\n\tfor (std::vector< std::vector<int> >::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tmemcpy(g[0], f, sizeof(f));\n\t\tmemcpy(g[1], f, sizeof(f));\n\n\t\t// puts(\"new\");\n\t\tfor (std::vector<int>::const_iterator it2 = it->begin(); it2 != it->end(); it2++) {\n\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\t\t// printf(\"%d %d\\n\", a, b);\n\t\t\t\t\tif (!(b & *it2)) /* printf(\"[0] += %d\\n\", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p;\n\t\t\t\t\tif (!(a & *it2)) /* printf(\"[1] += %d\\n\", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p;\n\t\t\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\t\t\t// printf(\"%d %d\\n\", g[0][a][b], g[1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\tf[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\tif (!(a & b)) (ans += f[a][b]) %= p;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-dinner.md","raw":"title: NOI2015 -  DP\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - DP\n  -  DP\n  -  DP\npermalink: noi2015-dinner\ndate: 2016-07-01 13:23:00\n---\n\n $ 2 $ ~ $ n $  $ n - 1 $  $ a $  $ b $ $ \\gcd(a, b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 4197](http://www.lydsy.com/JudgeOnline/problem.php?id=4197)  \n[UOJ #129](http://uoj.ac/problem/129)\n\n### \n $ f(a, b) $$ a $$ b $  $ a $ $ b $ \n\n $ x $  $ \\sqrt x $  $ 8 $   $ 2, 3, 5, 7, 11, 13, 17, 19 $\n\n $ z $ $ z $  $ z $ \n\n $ z $  $ i $  $ S_i $\n\n $ f(a, b) $ **** $ a $ $ b $ \n\n $ g(i, k, a, b) $  $ i $  $ k $  $ a $ $ b $ \n\n $ x $ $ g(i - 1, 0) $  $ g(i - 1, 1) $  $ g(i, 0) $  $ g(i, 1) $\n\n$$\n\\begin{aligned}\ng(i, 0, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap b \\neq \\emptyset \\\\\n  \\sum\\limits_{a' \\cup S_i = a} g(i - 1, a', b) + f(a, b) & S_i \\cap b = \\emptyset\n  \\end{cases} \\\\\ng(i, 1, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap a \\neq \\emptyset \\\\\n  \\sum\\limits_{b' \\cup S_i = b} g(i - 1, a, b') + f(a, b) & S_i \\cap a = \\emptyset\n  \\end{cases}\n\\end{aligned}\n$$\n\n $ a' $  $ b' $  $ a' $  $ b' $  $ a $  $ b $  $ a' \\leq a $$ b' \\leq b $ $ i $ $ a $  $ b $ $ g(0) $  $ g(1) $\n\n$$\n\\mathrm {for \\ each} \\ i.\\ a = U \\to \\emptyset,\\ b = U \\to \\emptyset \\\\\n\\begin{aligned}\ng(0, a \\cup S_i, b) \\leftarrow g(0, a \\cup S_i, b) + g(0, a, b) && S_i \\cap b = \\emptyset \\\\\ng(0, a, b \\cup S_i) \\leftarrow g(0, a, b \\cup S_i) + g(0, a, b) && S_i \\cap a = \\emptyset \\\\\n\\end{aligned}\n$$\n\n $ \\sqrt x $  $ x $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 500;\nconst int MAXK = 8;\nconst int MAXSTAT = 1 << 8;\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };\n\nint main() {\n\tint n, p;\n\tscanf(\"%d %d\", &n, &p);\n\n\tstd::vector< std::vector<int> > v;\n\tstd::vector< std::pair<int, int> > tmp;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x = i, t = 0;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (x % PRIMES[j] == 0) {\n\t\t\t\twhile (x % PRIMES[j] == 0) x /= PRIMES[j];\n\t\t\t\tt |= 1 << j;\n\t\t\t}\n\t\t}\n\n\t\ttmp.push_back(std::make_pair(x, t));\n\t}\n\n\tstd::sort(tmp.begin(), tmp.end());\n\n\tfor (std::vector< std::pair<int, int> >::const_iterator it = tmp.begin(); it != tmp.end(); it++) {\n\t\tif (it == tmp.begin() || it->first == 1 || it->first != (it - 1)->first) {\n\t\t\tv.resize(v.size() + 1);\n\t\t}\n\t\tv.back().push_back(it->second);\n\t}\n\n\tstatic int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT];\n\tf[0][0] = 1;\n\tfor (std::vector< std::vector<int> >::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tmemcpy(g[0], f, sizeof(f));\n\t\tmemcpy(g[1], f, sizeof(f));\n\n\t\t// puts(\"new\");\n\t\tfor (std::vector<int>::const_iterator it2 = it->begin(); it2 != it->end(); it2++) {\n\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\t\t// printf(\"%d %d\\n\", a, b);\n\t\t\t\t\tif (!(b & *it2)) /* printf(\"[0] += %d\\n\", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p;\n\t\t\t\t\tif (!(a & *it2)) /* printf(\"[1] += %d\\n\", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p;\n\t\t\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\t\t\t// printf(\"%d %d\\n\", g[0][a][b], g[1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\tf[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\tif (!(a & b)) (ans += f[a][b]) %= p;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2015-dinner","published":1,"updated":"2016-10-24T23:37:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiab00q00jxlodj9h0wr"},{"title":"NOI2014 - KMP","date":"2016-07-11T15:41:00.000Z","_content":"\n $ S $  $ i $  $ \\mathrm {num}(i) $\n\n$$\n\\prod\\limits_{i = 1} ^ n (\\mathrm{num}(i) + 1) \\pmod {1000000007}\n$$\n\n<!-- more -->\n\n### \n[BZOJ 3670](http://www.lydsy.com/JudgeOnline/problem.php?id=3670)  \n[UOJ #5](http://uoj.ac/problem/5)\n\n### \n DP  $ \\mathrm{num}(i) = \\mathrm{num}(\\mathrm{next}(i)) + 1 $\n\n   $ \\mathrm{next} $  $ \\mathrm{next2} $ $ \\mathrm{num} $ $ \\mathrm{num2} $ $ \\mathrm{num2}(i) = \\mathrm{num2}(\\mathrm{next2}(i)) + 1 $ \n\n$$ \\mathrm{num2}(i) = \\mathrm{num}(\\mathrm{next2}(i)) + 1 $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 5;\nconst int MAXN = 1000000;\nconst unsigned long long MOD = 1000000007;\n\nint n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1];\nchar s[MAXN + 1];\n\ninline unsigned long long kmp() {\n\tnext[0] = next[1] = num[0] = num[1] = 0;\n\tfor (int i = 2, t = 0, k = 0; i <= n; i++) {\n\t\twhile (t && s[t] != s[i - 1]) t = next[t];\n\t\twhile ((k && s[k] != s[i - 1]) || k >= i / 2) k = next[k];\n\n\t\tif (s[k] == s[i - 1]) num2[i] = num[++k] + 1;\n\t\telse num2[i] = 0;\n\n\t\tif (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1;\n\t\telse next[i] = num[i] = 0;\n\t}\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", f[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num2[i], i == n ? '\\n' : ' ');\n\n\tunsigned long long ans = 1;\n\tfor (int i = 1; i <= n; i++) (ans *= (num2[i] + 1)) %= MOD;\n\treturn ans;\n}\n\nint main() {\n\tint t = 1;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\n\t\tprintf(\"%llu\\n\", kmp());\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-zoo.md","raw":"title: NOI2014 - KMP\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - KMP\n  - \npermalink: noi2014-zoo\ndate: 2016-07-11 23:41:00\n---\n\n $ S $  $ i $  $ \\mathrm {num}(i) $\n\n$$\n\\prod\\limits_{i = 1} ^ n (\\mathrm{num}(i) + 1) \\pmod {1000000007}\n$$\n\n<!-- more -->\n\n### \n[BZOJ 3670](http://www.lydsy.com/JudgeOnline/problem.php?id=3670)  \n[UOJ #5](http://uoj.ac/problem/5)\n\n### \n DP  $ \\mathrm{num}(i) = \\mathrm{num}(\\mathrm{next}(i)) + 1 $\n\n   $ \\mathrm{next} $  $ \\mathrm{next2} $ $ \\mathrm{num} $ $ \\mathrm{num2} $ $ \\mathrm{num2}(i) = \\mathrm{num2}(\\mathrm{next2}(i)) + 1 $ \n\n$$ \\mathrm{num2}(i) = \\mathrm{num}(\\mathrm{next2}(i)) + 1 $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 5;\nconst int MAXN = 1000000;\nconst unsigned long long MOD = 1000000007;\n\nint n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1];\nchar s[MAXN + 1];\n\ninline unsigned long long kmp() {\n\tnext[0] = next[1] = num[0] = num[1] = 0;\n\tfor (int i = 2, t = 0, k = 0; i <= n; i++) {\n\t\twhile (t && s[t] != s[i - 1]) t = next[t];\n\t\twhile ((k && s[k] != s[i - 1]) || k >= i / 2) k = next[k];\n\n\t\tif (s[k] == s[i - 1]) num2[i] = num[++k] + 1;\n\t\telse num2[i] = 0;\n\n\t\tif (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1;\n\t\telse next[i] = num[i] = 0;\n\t}\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", f[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num2[i], i == n ? '\\n' : ' ');\n\n\tunsigned long long ans = 1;\n\tfor (int i = 1; i <= n; i++) (ans *= (num2[i] + 1)) %= MOD;\n\treturn ans;\n}\n\nint main() {\n\tint t = 1;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\n\t\tprintf(\"%llu\\n\", kmp());\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2014-zoo","published":1,"updated":"2016-07-11T15:41:47.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiag00q70jxlfyvo3irb"},{"title":"NOI2014 -  + ","date":"2016-04-03T14:39:31.000Z","_content":"\ndrd drd  $ n $  $ \\rm op $  $ t $ $ \\rm OR $$ \\rm XOR $$ \\rm AND $  $ x $ $ x ~ {\\rm op} ~ t $ drd  $ x $  $ n $ \n atm  $ 0 $  $ m $  $ 0 $$ 1 $$  $$ m $  $ m $  drd \n\n<!-- more -->\n\n### \n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### \n $ 0 $  $ 1 $ $ 1 $ $ 1 $  $ 1 $\n\n `unsigned int`\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-sleep.md","raw":"title: NOI2014 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \npermalink: noi2014-sleep\ndate: 2016-04-03 22:39:31\n---\n\ndrd drd  $ n $  $ \\rm op $  $ t $ $ \\rm OR $$ \\rm XOR $$ \\rm AND $  $ x $ $ x ~ {\\rm op} ~ t $ drd  $ x $  $ n $ \n atm  $ 0 $  $ m $  $ 0 $$ 1 $$  $$ m $  $ m $  drd \n\n<!-- more -->\n\n### \n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### \n $ 0 $  $ 1 $ $ 1 $ $ 1 $  $ 1 $\n\n `unsigned int`\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-sleep","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiak00qd0jxln1g31rxu"},{"title":"NOI2014 - LCT","date":"2016-07-11T15:50:00.000Z","_content":"\n $ N $  $ M $  $ 1 \\ldots N $ $ 1 \\ldots M $ E  $ 1 $ $ N $\n\n $ E_i $  $ A_i $  $ B_i $ A  $ A_i $ B  $ B_i $\n\n E \n\n<!-- more -->\n\n### \n[BZOJ 3669](http://www.lydsy.com/JudgeOnline/problem.php?id=3669)  \n[UOJ #3](http://uoj.ac/problem/3)\n\n### \n $ A_i $  $ B_i $  LCT  $ B_i $  $ 1 $  $ n $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *p, *pp, *max;\n\t\tint w;\n\t\tbool rev;\n\n\t\tNode() : p(NULL), pp(NULL), max(this), w(0) {}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid maintain() {\n\t\t\tmax = this;\n\t\t\tif (c[0] && c[0]->max->w > max->w) max = c[0]->max;\n\t\t\tif (c[1] && c[1]->max->w > max->w) max = c[1]->max;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pp, p->pp);\n\t\t\tint r = relation();\n\t\t\tNode *o = p;\n\t\t\t\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[r] = c[r ^ 1];\n\t\t\tif (c[r ^ 1]) c[r ^ 1]->p = o;\n\n\t\t\tc[r ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (p) {\n\t\t\t\tif (p->p) p->p->pushDown();\n\t\t\t\tp->pushDown(), pushDown();\n\n\t\t\t\tif (!p->p) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->p, c[1]->pp);\n\t\t\t\tc[1] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pp) return false;\n\t\t\tpp->expose();\n\t\t\tpp->c[1] = this;\n\t\t\tpp->maintain();\n\t\t\tstd::swap(p, pp);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\trev ^= 1;\n\t\t}\n\t} N[MAXN], E[MAXM], *a[MAXM][2];\n\n\tvoid link(Node *u, Node *v) {\n\t\t// printf(\"Linking %ld as %ld's parent.\\n\", u - N + 1, v - N + 1);\n\t\tv->evert();\n\t\tu->expose();\n\t\tv->pp = u;\n\t}\n\n\tvoid link(const int u, const int v, const int i, const int w) {\n\t\tE[i].w = w;\n\t\ta[i][0] = &N[u];\n\t\ta[i][1] = &N[v];\n\t\tlink(&N[u], &E[i]);\n\t\tlink(&E[i], &N[v]);\n\t}\n\n\tvoid cut(Node *u, Node *v) {\n\t\tv->evert();\n\t\tv->expose();\n\t\tu->splay();\n\t\tu->pp = NULL;\n\t}\n\n\tvoid cut(const int i) {\n\t\tcut(a[i][0], &E[i]);\n\t\tcut(&E[i], a[i][1]);\n\t}\n\n\tNode *find(const int u) {\n\t\tNode *v = &N[u];\n\t\tv->access();\n\t\tv->splay();\n\t\tif (!v->c[0]) {\n\t\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\t\treturn v;\n\t\t}\n\t\twhile (v->c[0]) v = v->c[0];\n\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\treturn v;\n\t}\n\n\tbool test(const int u, const int v) {\n\t\treturn find(u) == find(v);\n\t}\n\n\tint queryMax(const int u, const int v) {\n\t\tN[u].evert();\n\t\tN[v].access();\n\t\tN[v].splay();\n\t\tassert(N[v].max >= E);\n\t\treturn N[v].max - E;\n\t}\n} lct;\n\nstruct Edge {\n\tint u, v, a, b;\n\n\tbool operator<(const Edge &other) const { return a < other.a; }\n} E[MAXM];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b), E[i].u--, E[i].v--;\n\tstd::sort(E, E + m);\n\n\tint ans = INT_MAX;\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tif (e.u == e.v) continue;\n\t\tif (lct.test(e.u, e.v)) {\n\t\t\t// printf(\"[%d, %d, %d, %d] will lead to a circle!\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tint max = lct.queryMax(e.u, e.v);\n\t\t\t// printf(\"max = %d\\n\", max);\n\t\t\tif (E[max].b > e.b) {\n\t\t\t\tlct.cut(max);\n\t\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t\t}\n\t\t} else {\n\t\t\t// printf(\"Connecting [%d, %d, %d, %d] ...\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t}\n\n\t\tif (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b);\n\t}\n\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-forest.md","raw":"title: NOI2014 - LCT\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - LCT\n  - \npermalink: noi2014-forest\ndate: 2016-07-11 23:50:00\n---\n\n $ N $  $ M $  $ 1 \\ldots N $ $ 1 \\ldots M $ E  $ 1 $ $ N $\n\n $ E_i $  $ A_i $  $ B_i $ A  $ A_i $ B  $ B_i $\n\n E \n\n<!-- more -->\n\n### \n[BZOJ 3669](http://www.lydsy.com/JudgeOnline/problem.php?id=3669)  \n[UOJ #3](http://uoj.ac/problem/3)\n\n### \n $ A_i $  $ B_i $  LCT  $ B_i $  $ 1 $  $ n $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *p, *pp, *max;\n\t\tint w;\n\t\tbool rev;\n\n\t\tNode() : p(NULL), pp(NULL), max(this), w(0) {}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid maintain() {\n\t\t\tmax = this;\n\t\t\tif (c[0] && c[0]->max->w > max->w) max = c[0]->max;\n\t\t\tif (c[1] && c[1]->max->w > max->w) max = c[1]->max;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pp, p->pp);\n\t\t\tint r = relation();\n\t\t\tNode *o = p;\n\t\t\t\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[r] = c[r ^ 1];\n\t\t\tif (c[r ^ 1]) c[r ^ 1]->p = o;\n\n\t\t\tc[r ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (p) {\n\t\t\t\tif (p->p) p->p->pushDown();\n\t\t\t\tp->pushDown(), pushDown();\n\n\t\t\t\tif (!p->p) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->p, c[1]->pp);\n\t\t\t\tc[1] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pp) return false;\n\t\t\tpp->expose();\n\t\t\tpp->c[1] = this;\n\t\t\tpp->maintain();\n\t\t\tstd::swap(p, pp);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\trev ^= 1;\n\t\t}\n\t} N[MAXN], E[MAXM], *a[MAXM][2];\n\n\tvoid link(Node *u, Node *v) {\n\t\t// printf(\"Linking %ld as %ld's parent.\\n\", u - N + 1, v - N + 1);\n\t\tv->evert();\n\t\tu->expose();\n\t\tv->pp = u;\n\t}\n\n\tvoid link(const int u, const int v, const int i, const int w) {\n\t\tE[i].w = w;\n\t\ta[i][0] = &N[u];\n\t\ta[i][1] = &N[v];\n\t\tlink(&N[u], &E[i]);\n\t\tlink(&E[i], &N[v]);\n\t}\n\n\tvoid cut(Node *u, Node *v) {\n\t\tv->evert();\n\t\tv->expose();\n\t\tu->splay();\n\t\tu->pp = NULL;\n\t}\n\n\tvoid cut(const int i) {\n\t\tcut(a[i][0], &E[i]);\n\t\tcut(&E[i], a[i][1]);\n\t}\n\n\tNode *find(const int u) {\n\t\tNode *v = &N[u];\n\t\tv->access();\n\t\tv->splay();\n\t\tif (!v->c[0]) {\n\t\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\t\treturn v;\n\t\t}\n\t\twhile (v->c[0]) v = v->c[0];\n\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\treturn v;\n\t}\n\n\tbool test(const int u, const int v) {\n\t\treturn find(u) == find(v);\n\t}\n\n\tint queryMax(const int u, const int v) {\n\t\tN[u].evert();\n\t\tN[v].access();\n\t\tN[v].splay();\n\t\tassert(N[v].max >= E);\n\t\treturn N[v].max - E;\n\t}\n} lct;\n\nstruct Edge {\n\tint u, v, a, b;\n\n\tbool operator<(const Edge &other) const { return a < other.a; }\n} E[MAXM];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b), E[i].u--, E[i].v--;\n\tstd::sort(E, E + m);\n\n\tint ans = INT_MAX;\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tif (e.u == e.v) continue;\n\t\tif (lct.test(e.u, e.v)) {\n\t\t\t// printf(\"[%d, %d, %d, %d] will lead to a circle!\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tint max = lct.queryMax(e.u, e.v);\n\t\t\t// printf(\"max = %d\\n\", max);\n\t\t\tif (E[max].b > e.b) {\n\t\t\t\tlct.cut(max);\n\t\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t\t}\n\t\t} else {\n\t\t\t// printf(\"Connecting [%d, %d, %d, %d] ...\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t}\n\n\t\tif (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b);\n\t}\n\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-forest","published":1,"updated":"2016-07-11T15:54:43.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiao00qj0jxl2dalvs1v"},{"title":"NOI2012 - ","date":"2016-10-07T23:29:00.000Z","_content":"\n\n\n$$ x_{n + 1} = (a x_n + c) \\bmod m $$\n\n $ m, a, c, x_0, n, g $ $ x_n \\bmod g $\n\n<!-- more -->\n\n### \n[BZOJ 2875](www.lydsy.com/JudgeOnline/problem.php?id=2875)  \n[COGS 963](http://cogs.pro/cogs/problem/problem.php?pid=963)\n\n### \n\n\n $ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst long long MAXN = 1e18;\nconst long long MAXG = 1e8;\n\nlong long mod;\n\nstruct Matrix {\n\tlong long a[2][2];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\n\tlong long &operator()(const int i, const int j) { return a[i][j]; }\n\tconst long long &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"randoma.in\", \"r\", stdin);\n\tfreopen(\"randoma.out\", \"w\", stdout);\n\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld %lld %lld %lld %lld %lld\", &mod, &a, &c, &x, &n, &g);\n\t// mod = 1e9 + 7;\n\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\n\tMatrix shift(false);\n\tshift(0, 0) = a, shift(0, 1) = 1;\n\tshift(1, 0) = 0, shift(1, 1) = 1;\n\n#ifdef FORCE\n\tMatrix res = init;\n\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\tputs(\"----------------------\");\n\tfor (int i = 0; i < n; i++) {\n\t\tres = shift * res;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\t\tputs(\"----------------------\");\n\t}\n#else\n\tMatrix res = pow(shift, n) * init;\n#endif\n\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/noi2012-random.md","raw":"title: NOI2012 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - COGS\n  - \npermalink: noi2012-random\ndate: 2016-10-08 07:29:00\n---\n\n\n\n$$ x_{n + 1} = (a x_n + c) \\bmod m $$\n\n $ m, a, c, x_0, n, g $ $ x_n \\bmod g $\n\n<!-- more -->\n\n### \n[BZOJ 2875](www.lydsy.com/JudgeOnline/problem.php?id=2875)  \n[COGS 963](http://cogs.pro/cogs/problem/problem.php?pid=963)\n\n### \n\n\n $ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst long long MAXN = 1e18;\nconst long long MAXG = 1e8;\n\nlong long mod;\n\nstruct Matrix {\n\tlong long a[2][2];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\n\tlong long &operator()(const int i, const int j) { return a[i][j]; }\n\tconst long long &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"randoma.in\", \"r\", stdin);\n\tfreopen(\"randoma.out\", \"w\", stdout);\n\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld %lld %lld %lld %lld %lld\", &mod, &a, &c, &x, &n, &g);\n\t// mod = 1e9 + 7;\n\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\n\tMatrix shift(false);\n\tshift(0, 0) = a, shift(0, 1) = 1;\n\tshift(1, 0) = 0, shift(1, 1) = 1;\n\n#ifdef FORCE\n\tMatrix res = init;\n\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\tputs(\"----------------------\");\n\tfor (int i = 0; i < n; i++) {\n\t\tres = shift * res;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\t\tputs(\"----------------------\");\n\t}\n#else\n\tMatrix res = pow(shift, n) * init;\n#endif\n\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"noi2012-random","published":1,"updated":"2016-10-07T23:36:47.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiat00qq0jxl2b1oaoql"},{"title":"NOI2011 - AC ","date":"2016-09-11T23:38:00.000Z","_content":"\n $ 28 $  $ 26 $  `B``P` \n\n\n\n* \n*  `B` \n*  `P` \n\n $ 1 $  $ n $ $ (x, y) $ $ 1 \\leq x, y \\leq n $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2434](http://www.lydsy.com/JudgeOnline/problem.php?id=2434)\n\n### \n Trie  Trie \n\n AC  $ y $  $ x $ $ y $  `fail`  $ x $ AC  $ y $  `fail`  $ x $\n\n `fail`  Fail  Fail  AC  `fail` AC  $ y $  Fail  $ x $ \n\n   AC  $ y $ Fail  $ 1 $ $ y $  $ x $ $ x $  Fail \n\n DFS  +  AC  Fail  $ 1 $ $ 0 $ $ y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next, *p;\n\t\tint id;\n\t\tbool isWord;\n\t\tstruct Query {\n\t\t\tNode *x;\n\t\t\tint *ans;\n\n\t\t\tQuery(Node *x, int *ans) : x(x), ans(ans) {}\n\t\t};\n\t\tstd::vector<Query> q;\n\n\t\tNode(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tint init(const char *s, std::vector<Node *> &vec) {\n\t\tint cnt = 0;\n\t\tNode *v = root = new Node(NULL, false, cnt++);\n\t\tfor (const char *p = s; *p; p++) {\n\t\t\tassert(*p == 'P' || *p == 'B' || (*p >= 'a' && *p <= 'z'));\n\t\t\tif (*p == 'P') v->isWord = true, vec.push_back(v);\n\t\t\telse if (*p == 'B') v = v->p;\n\t\t\telse {\n\t\t\t\tif (!v->c[*p - BASE_CHAR]) v->c[*p - BASE_CHAR] = new Node(v, false, cnt++);\n\t\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root, root->next = NULL;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tassert(v->q.size() < MAXN);\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t\tassert(v->q.size() < MAXN);\n\t\t\t\tassert(c->q.size() < MAXN);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tNode *p, *c, *next;\n\tint l, r;\n\tbool v;\n} N[MAXN];\n\nint n;\n\ninline void addEdge(const int p, const int c) {\n\t// printf(\"addEdge(%d, %d)\\n\", p, c);\n\tN[c].next = N[p].c;\n\tN[p].c = &N[c];\n\tN[c].p = &N[p];\n}\n\ninline void buildFailTree() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *&c = v->c[i];\n\t\t\tif (!c) continue;\n\t\t\taddEdge(c->fail->id, c->id);\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void dfs() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->v) {\n\t\t\tv->v = true;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Node *c = v->c; c; c = c->next) s.push(c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint query(const int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) ans += a[i];\n\t\treturn ans;\n\t}\n} bit;\n\nchar op[MAXN + 1];\ninline void solve() {\n\tbit.init(n);\n\tTrie::Node *y = t.root;\n\tfor (const char *p = op; *p; p++) {\n\t\tif (*p == 'P') {\n\t\t\tfor (std::vector<Trie::Node::Query>::iterator it = y->q.begin(); it != y->q.end(); it++) {\n\t\t\t\t*it->ans = bit.query(N[it->x->id].r) - bit.query(N[it->x->id].l - 1);\n\t\t\t}\n\t\t} else if (*p == 'B') {\n\t\t\tbit.update(N[y->id].l, -1);\n\t\t\ty = y->p;\n\t\t} else {\n\t\t\ty = y->c[*p - BASE_CHAR];\n\t\t\tbit.update(N[y->id].l, 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", op);\n\n\tstd::vector<Trie::Node *> vec;\n\tn = t.init(op, vec);\n\tt.build();\n\n\tbuildFailTree();\n\tdfs();\n\n\tint m;\n\tstatic int ans[MAXN];\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\t\tvec[y]->q.push_back(Trie::Node::Query(vec[x], &ans[i]));\n\t}\n\n\tsolve();\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","source":"_posts/noi2011-type.md","raw":"title: NOI2011 - AC \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - AC \npermalink: noi2011-type\ndate: 2016-09-12 07:38:00\n---\n\n $ 28 $  $ 26 $  `B``P` \n\n\n\n* \n*  `B` \n*  `P` \n\n $ 1 $  $ n $ $ (x, y) $ $ 1 \\leq x, y \\leq n $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2434](http://www.lydsy.com/JudgeOnline/problem.php?id=2434)\n\n### \n Trie  Trie \n\n AC  $ y $  $ x $ $ y $  `fail`  $ x $ AC  $ y $  `fail`  $ x $\n\n `fail`  Fail  Fail  AC  `fail` AC  $ y $  Fail  $ x $ \n\n   AC  $ y $ Fail  $ 1 $ $ y $  $ x $ $ x $  Fail \n\n DFS  +  AC  Fail  $ 1 $ $ 0 $ $ y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next, *p;\n\t\tint id;\n\t\tbool isWord;\n\t\tstruct Query {\n\t\t\tNode *x;\n\t\t\tint *ans;\n\n\t\t\tQuery(Node *x, int *ans) : x(x), ans(ans) {}\n\t\t};\n\t\tstd::vector<Query> q;\n\n\t\tNode(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tint init(const char *s, std::vector<Node *> &vec) {\n\t\tint cnt = 0;\n\t\tNode *v = root = new Node(NULL, false, cnt++);\n\t\tfor (const char *p = s; *p; p++) {\n\t\t\tassert(*p == 'P' || *p == 'B' || (*p >= 'a' && *p <= 'z'));\n\t\t\tif (*p == 'P') v->isWord = true, vec.push_back(v);\n\t\t\telse if (*p == 'B') v = v->p;\n\t\t\telse {\n\t\t\t\tif (!v->c[*p - BASE_CHAR]) v->c[*p - BASE_CHAR] = new Node(v, false, cnt++);\n\t\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root, root->next = NULL;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tassert(v->q.size() < MAXN);\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t\tassert(v->q.size() < MAXN);\n\t\t\t\tassert(c->q.size() < MAXN);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tNode *p, *c, *next;\n\tint l, r;\n\tbool v;\n} N[MAXN];\n\nint n;\n\ninline void addEdge(const int p, const int c) {\n\t// printf(\"addEdge(%d, %d)\\n\", p, c);\n\tN[c].next = N[p].c;\n\tN[p].c = &N[c];\n\tN[c].p = &N[p];\n}\n\ninline void buildFailTree() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *&c = v->c[i];\n\t\t\tif (!c) continue;\n\t\t\taddEdge(c->fail->id, c->id);\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void dfs() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->v) {\n\t\t\tv->v = true;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Node *c = v->c; c; c = c->next) s.push(c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint query(const int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) ans += a[i];\n\t\treturn ans;\n\t}\n} bit;\n\nchar op[MAXN + 1];\ninline void solve() {\n\tbit.init(n);\n\tTrie::Node *y = t.root;\n\tfor (const char *p = op; *p; p++) {\n\t\tif (*p == 'P') {\n\t\t\tfor (std::vector<Trie::Node::Query>::iterator it = y->q.begin(); it != y->q.end(); it++) {\n\t\t\t\t*it->ans = bit.query(N[it->x->id].r) - bit.query(N[it->x->id].l - 1);\n\t\t\t}\n\t\t} else if (*p == 'B') {\n\t\t\tbit.update(N[y->id].l, -1);\n\t\t\ty = y->p;\n\t\t} else {\n\t\t\ty = y->c[*p - BASE_CHAR];\n\t\t\tbit.update(N[y->id].l, 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", op);\n\n\tstd::vector<Trie::Node *> vec;\n\tn = t.init(op, vec);\n\tt.build();\n\n\tbuildFailTree();\n\tdfs();\n\n\tint m;\n\tstatic int ans[MAXN];\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\t\tvec[y]->q.push_back(Trie::Node::Query(vec[x], &ans[i]));\n\t}\n\n\tsolve();\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","slug":"noi2011-type","published":1,"updated":"2016-09-11T23:53:53.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiax00qw0jxl0no0pyd0"},{"title":"NOI2006 - ","date":"2016-03-10T11:33:42.000Z","_content":"\n $ N $  $ i $  $ Pi $$ 1  i  N $ $ M $  $ i $  $ Ai $, $ Bi $  $ Ci $ $ Ai $  $ Bi $  $ Ci $$ 1  i  M $$ 1  Ai $$ Bi  N $\n\n<!-- more -->\n\n### \n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2006-profit.md","raw":"title: NOI2006 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  - \n  - Dinic\npermalink: noi2006-profit\ndate: 2016-03-10 19:33:42\n---\n\n $ N $  $ i $  $ Pi $$ 1  i  N $ $ M $  $ i $  $ Ai $, $ Bi $  $ Ci $ $ Ai $  $ Bi $  $ Ci $$ 1  i  M $$ 1  Ai $$ Bi  N $\n\n<!-- more -->\n\n### \n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"noi2006-profit","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jib100r20jxlqtbqzxgl"},{"title":"NOI2004 - Splay","id":"37","updated":"2016-01-24T15:11:06.000Z","date":"2016-01-24T15:09:03.000Z","_content":"\n `k` \n\n<!-- more -->\n\n### \n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### \n Splay \n\n $[-{\\infty}+1,min-1]$ \n\n\n\n Splay\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","source":"_posts/noi2004-cashier.md","raw":"title: NOI2004 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - Splay\n  - \n  - \npermalink: noi2004-cashier\nid: 37\nupdated: '2016-01-24 23:11:06'\ndate: 2016-01-24 23:09:03\n---\n\n `k` \n\n<!-- more -->\n\n### \n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### \n Splay \n\n $[-{\\infty}+1,min-1]$ \n\n\n\n Splay\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","slug":"noi2004-cashier","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jib800rd0jxlk9cqge99"},{"title":"NOI2003 - Splay","date":"2016-03-06T11:49:35.000Z","_content":"\n|                |  |  |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         |  $ k $  $ k=0 $ |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     |  $ n $  $ s $$ n  1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       |  $ n $ $ n  1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          |  $ n $ $ n  1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | \n| $ {\\rm NEXT}() $       | `Next`           | \n\n<!-- more -->\n\n### \n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### \n Splay w\n\n `build`  $ \\log $\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2003-editor.md","raw":"title: NOI2003 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - Splay\n  - \n  - \npermalink: noi2003-editor\ndate: 2016-03-06 19:49:35\n---\n\n|                |  |  |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         |  $ k $  $ k=0 $ |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     |  $ n $  $ s $$ n  1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       |  $ n $ $ n  1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          |  $ n $ $ n  1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | \n| $ {\\rm NEXT}() $       | `Next`           | \n\n<!-- more -->\n\n### \n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### \n Splay w\n\n `build`  $ \\log $\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2003-editor","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jibj00rl0jxlc6dqbnkh"},{"title":"NOI2002 - ","id":"2","updated":"2016-01-19T13:08:24.000Z","date":"2015-11-22T17:14:53.000Z","_content":"\n 30000 \n\n1. `x`  `y`   \n2. `x`  `y`  `x`  `y` \n\n 500,000 \n\n<!-- more -->\n\n### \n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### \n  \n****\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)`  `head`  `find_head(x)`  `x`  `x` \n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n $O(nm)$  \n  Boom  \n\n `x`  `head[x]`  `prefix[x]`  \n `find(x)`  `pre(x)`  `prefix[x]`  `pre(head[x])`** `x` **  \n\n  \n 1.** `prefix[x]` **  \n 2.** `head[x] == x` **0  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn prefix[x];\n}\n```\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### \n NOI2002   \n    \n A ","source":"_posts/noi2002-galaxy.md","raw":"title: NOI2002 - \ncategories: OI\ntags: \n  - CodeVS\n  - NOI\n  - \npermalink: noi2002-galaxy\nid: 2\nupdated: '2016-01-19 21:08:24'\ndate: 2015-11-23 01:14:53\n---\n\n 30000 \n\n1. `x`  `y`   \n2. `x`  `y`  `x`  `y` \n\n 500,000 \n\n<!-- more -->\n\n### \n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### \n  \n****\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)`  `head`  `find_head(x)`  `x`  `x` \n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n $O(nm)$  \n  Boom  \n\n `x`  `head[x]`  `prefix[x]`  \n `find(x)`  `pre(x)`  `prefix[x]`  `pre(head[x])`** `x` **  \n\n  \n 1.** `prefix[x]` **  \n 2.** `head[x] == x` **0  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn prefix[x];\n}\n```\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### \n NOI2002   \n    \n A ","slug":"noi2002-galaxy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jibp00rs0jxluhik0vjt"},{"title":"","date":"2016-06-17T08:36:00.000Z","_content":"\n\n\n<!-- more -->\n\n****\n\n![](node-devide-notes/tree1.svg)\n\n $ 1 $  $ 1 $ \n\n $ n $ $ n $  $ 1 $ \n\n $ O(n) $  $ O(n ^ 2) $\n\n $ 5 $    $ 5 $  $ 1 $ \n\n### \n********\n\n> \n\n  \n $ n \\over 2 $ $ n + 2 $ \n\n DFS    DFS $ {\\rm size}(i) = \\sum\\limits_{j \\in {\\rm child}(i)} {\\rm size}(j) + 1 $ $ {\\rm max}(i) = \\max\\limits_{j \\in {\\rm child}(i)} \\{ {\\rm size}(j) \\} $ $ \\max \\{ \\max(i),\\ n - \\max(i) \\} $  $ i $ \n\n\n\n$$ T(n) = 2 T(\\frac{n}{2}) + O(n) = O(n \\log n) $$\n\n\n\n![](node-devide-notes/tree2.svg)\n\n### \n `solved` $ n $ \n\n```c++\ninline Node *center(Node *start) {\n    std::stack<Node *> s;\n    s.push(start);\n    start->parent = NULL;\n    start->visited = false;\n\n    static Node *a[MAXN];\n    int cnt = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            a[cnt++] = v;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n                e->t->parent = v;\n                e->t->visited = false;\n                s.push(e->t);\n            }\n        } else {\n            v->size = 1;\n            v->max = 0;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n                v->size += e->t->size;\n                v->max = std::max(v->max, e->t->size);\n            }\n            s.pop();\n        }\n    }\n\n\n    Node *res = NULL;\n    for (int i = 0; i < cnt; i++) {\n        a[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n\n    return res;\n}\n\ninline int solve() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    int ans = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        s.pop();\n\n        Node *root = center(v);\n        root->solved = true;\n\n        ans += calc(root);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n            s.push(e->t);\n        }\n    }\n\n    return ans;\n}\n```\n","source":"_posts/node-devide-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: node-devide-notes\ndate: 2016-06-17 16:36:00\n---\n\n\n\n<!-- more -->\n\n****\n\n![](node-devide-notes/tree1.svg)\n\n $ 1 $  $ 1 $ \n\n $ n $ $ n $  $ 1 $ \n\n $ O(n) $  $ O(n ^ 2) $\n\n $ 5 $    $ 5 $  $ 1 $ \n\n### \n********\n\n> \n\n  \n $ n \\over 2 $ $ n + 2 $ \n\n DFS    DFS $ {\\rm size}(i) = \\sum\\limits_{j \\in {\\rm child}(i)} {\\rm size}(j) + 1 $ $ {\\rm max}(i) = \\max\\limits_{j \\in {\\rm child}(i)} \\{ {\\rm size}(j) \\} $ $ \\max \\{ \\max(i),\\ n - \\max(i) \\} $  $ i $ \n\n\n\n$$ T(n) = 2 T(\\frac{n}{2}) + O(n) = O(n \\log n) $$\n\n\n\n![](node-devide-notes/tree2.svg)\n\n### \n `solved` $ n $ \n\n```c++\ninline Node *center(Node *start) {\n    std::stack<Node *> s;\n    s.push(start);\n    start->parent = NULL;\n    start->visited = false;\n\n    static Node *a[MAXN];\n    int cnt = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            a[cnt++] = v;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n                e->t->parent = v;\n                e->t->visited = false;\n                s.push(e->t);\n            }\n        } else {\n            v->size = 1;\n            v->max = 0;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n                v->size += e->t->size;\n                v->max = std::max(v->max, e->t->size);\n            }\n            s.pop();\n        }\n    }\n\n\n    Node *res = NULL;\n    for (int i = 0; i < cnt; i++) {\n        a[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n\n    return res;\n}\n\ninline int solve() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    int ans = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        s.pop();\n\n        Node *root = center(v);\n        root->solved = true;\n\n        ans += calc(root);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n            s.push(e->t);\n        }\n    }\n\n    return ans;\n}\n```\n","slug":"node-devide-notes","published":1,"updated":"2016-06-17T08:37:21.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jibs00rx0jxl9p8xsxbm"},{"title":"","date":"2016-04-13T04:11:17.000Z","_content":"\n OI \n\n\n\n<!-- more -->\n\n### \n $ {\\rm mod} \\ p $  $ x $  $ x ^ {-1} $  \n\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### \n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ p $ \n\n\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n$ a ^ {p - 2} $  $ a $ \n\n $ a ^ {p - 2} $ $ O(\\log a) $\n\n#### \n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### \nEXGCD $ O(\\log \\max(a, b)) $  $ x $$ y $ \n\n\n$$ ax + by = \\gcd(a, b) $$\n\n\n\n $ b $ $ \\gcd(a, b) = 1 $\n\n$$ ax \\equiv 1 \\pmod b $$\n\n $ O(\\log a) $\n\n#### \n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### \n $ p = k \\times i + r $$ r < i $$ 1 < i < p $\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n $ r ^ {-1} + i ^ {-1} $\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n $ 1 ^ {-1} \\equiv 1 \\pmod p $ $ O(n) $\n\n#### \n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","source":"_posts/mul-inverse.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: mul-inverse\ndate: 2016-04-13 12:11:17\n---\n\n OI \n\n\n\n<!-- more -->\n\n### \n $ {\\rm mod} \\ p $  $ x $  $ x ^ {-1} $  \n\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### \n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ p $ \n\n\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n$ a ^ {p - 2} $  $ a $ \n\n $ a ^ {p - 2} $ $ O(\\log a) $\n\n#### \n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### \nEXGCD $ O(\\log \\max(a, b)) $  $ x $$ y $ \n\n\n$$ ax + by = \\gcd(a, b) $$\n\n\n\n $ b $ $ \\gcd(a, b) = 1 $\n\n$$ ax \\equiv 1 \\pmod b $$\n\n $ O(\\log a) $\n\n#### \n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### \n $ p = k \\times i + r $$ r < i $$ 1 < i < p $\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n $ r ^ {-1} + i ^ {-1} $\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n $ 1 ^ {-1} \\equiv 1 \\pmod p $ $ O(n) $\n\n#### \n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","slug":"mul-inverse","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jic200s40jxlprk119po"},{"title":"","date":"2016-01-14T21:44:45.000Z","_content":"\n DP \n\n<!-- more -->\n\n### \n\n\n `priority_queue`  $O(1)$  $O({\\log}n)$  `set` $\\log$  TLE \n\n $O(1)$ \n\n### \n `Q` `M` `M`  `Q` \n\n `Q`  `x`  `M`  `M`  ** `x` ** `x`  `x` ** `x` **\n\n `Q`  `M`  `M` **** `M`  `Q`  `M`  `M`  `Q` \n\n### \n $f[x]=\\max\\{g(k)\\}+w[x]$ \n\n### \n `deque`  `queue`\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","source":"_posts/monotone-queue-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  -   \npermalink: monotone-queue-notes\ndate: 2016-01-15 05:44:45\n---\n\n DP \n\n<!-- more -->\n\n### \n\n\n `priority_queue`  $O(1)$  $O({\\log}n)$  `set` $\\log$  TLE \n\n $O(1)$ \n\n### \n `Q` `M` `M`  `Q` \n\n `Q`  `x`  `M`  `M`  ** `x` ** `x`  `x` ** `x` **\n\n `Q`  `M`  `M` **** `M`  `Q`  `M`  `M`  `Q` \n\n### \n $f[x]=\\max\\{g(k)\\}+w[x]$ \n\n### \n `deque`  `queue`\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","slug":"monotone-queue-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jic800sb0jxlkq5icu9z"},{"title":"","date":"2016-05-01T00:14:50.000Z","_content":"\n $ [1,\\ n] $ $ [l,\\ r] $ \n\n<!-- more -->\n\n $ [l,\\ r] $  $ [l,\\ r + 1] $$ [l,\\ r - 1] $$ [l - 1,\\ r] $$ [l + 1,\\ r] $  $ O(1) $ $ O(n) $  $ O(n ^ 2) $\n\n $ \\sqrt n $  $ \\sqrt n $********\n\n $ O(\\sqrt n) $  $ O(\\sqrt n) $  $ O((\\sqrt n) ^ 2) = O(n) $ $ O(\\sqrt n) $ $ O((\\sqrt n) ^ 2) = O(n) $  $ O(n) $  $ O(\\sqrt n) $ $ O(n \\sqrt n) $\n\n\n","source":"_posts/mo-algorithm-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \npermalink: mo-algorithm-notes\ndate: 2016-05-01 08:14:50\n---\n\n $ [1,\\ n] $ $ [l,\\ r] $ \n\n<!-- more -->\n\n $ [l,\\ r] $  $ [l,\\ r + 1] $$ [l,\\ r - 1] $$ [l - 1,\\ r] $$ [l + 1,\\ r] $  $ O(1) $ $ O(n) $  $ O(n ^ 2) $\n\n $ \\sqrt n $  $ \\sqrt n $********\n\n $ O(\\sqrt n) $  $ O(\\sqrt n) $  $ O((\\sqrt n) ^ 2) = O(n) $ $ O(\\sqrt n) $ $ O((\\sqrt n) ^ 2) = O(n) $  $ O(n) $  $ O(\\sqrt n) $ $ O(n \\sqrt n) $\n\n\n","slug":"mo-algorithm-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jici00si0jxlec496in3"},{"title":" && ","date":"2016-01-01T22:08:50.000Z","_content":"\n\n\n ~\n\n<!-- more -->\n\n### \n\n#### Kruskal \n****\n\n\n\n $O(m{\\log}m)$ `m` \n\n\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim \nPrim  Kruskal ****\n\n Prim  Dijkstra \n\n\n\n $O(m{\\log}n)$ `n` `m`   \n $O(n^2)$ `n` \n\n\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### \n********\n\n****\n\n#### \n\n\n**** `(u, v, w)` `u`  `v` ****\n\n\n\n#### POJ 1679\n[POJ 1679](http://poj.org/problem?id=1679)\n\n\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/minimum-spanning-tree-notes.md","raw":"title: ' && '\ncategories: OI\ntags: \n  - Kruskal\n  - POJ\n  - Prim\n  - \n  - \n  - \n  - \n  - \n  -   \npermalink: minimum-spanning-tree-notes\ndate: 2016-01-02 06:08:50\n---\n\n\n\n ~\n\n<!-- more -->\n\n### \n\n#### Kruskal \n****\n\n\n\n $O(m{\\log}m)$ `m` \n\n\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim \nPrim  Kruskal ****\n\n Prim  Dijkstra \n\n\n\n $O(m{\\log}n)$ `n` `m`   \n $O(n^2)$ `n` \n\n\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### \n********\n\n****\n\n#### \n\n\n**** `(u, v, w)` `u`  `v` ****\n\n\n\n#### POJ 1679\n[POJ 1679](http://poj.org/problem?id=1679)\n\n\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"minimum-spanning-tree-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jict00so0jxlneecr25r"},{"title":" LaTex  Markdown ","id":"39","updated":"2016-01-27T05:28:28.000Z","date":"2016-01-24T15:43:18.000Z","_content":"\n### \nhttps://github.com/Menci/markdown-latex-helper\n\n### \n LaTex  MathJax \n\n LaTex  `*`  `~` Markdown  LaTex  Markdown \n\n<!-- more -->\n\n\n```latex\n\\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} * {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}}\n```\n\n\n```latex\n\\\\phi\\(n\\)=\\{\\\\sum\\_\\{S\\{\\\\subseteq\\}\\\\\\{p\\_1\\,p\\_2\\,\\\\ldots\\,p\\_k\\\\\\}\\}\\{\\(\\-1\\)^\\{|S|\\}\\} \\*  \\{\\\\frac\\{n\\}\\{ \\{\\\\prod\\_\\{ \\{p\\_i\\}\\{\\\\in\\}S\\} \\} \\\\ p\\_i \\}\\}\\}\n```\n\n### \n```bash\n$ clang++ markdown-latex-helper.cpp -o markdown-latex-helper -std=c++11\n```\n\n`clang++`  `-std=c++11` \n\n```bash\n$ markdown-latex-helper < infile.md > outfile.md\n```\n\n","source":"_posts/markdown-latex-helper.md","raw":"title:  LaTex  Markdown \ncategories: Geek\ntags: \n  - Markdown\n  - LaTex\n  - GitHub\npermalink: markdown-latex-helper\nid: 39\nupdated: '2016-01-27 13:28:28'\ndate: 2016-01-24 23:43:18\n---\n\n### \nhttps://github.com/Menci/markdown-latex-helper\n\n### \n LaTex  MathJax \n\n LaTex  `*`  `~` Markdown  LaTex  Markdown \n\n<!-- more -->\n\n\n```latex\n\\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} * {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}}\n```\n\n\n```latex\n\\\\phi\\(n\\)=\\{\\\\sum\\_\\{S\\{\\\\subseteq\\}\\\\\\{p\\_1\\,p\\_2\\,\\\\ldots\\,p\\_k\\\\\\}\\}\\{\\(\\-1\\)^\\{|S|\\}\\} \\*  \\{\\\\frac\\{n\\}\\{ \\{\\\\prod\\_\\{ \\{p\\_i\\}\\{\\\\in\\}S\\} \\} \\\\ p\\_i \\}\\}\\}\n```\n\n### \n```bash\n$ clang++ markdown-latex-helper.cpp -o markdown-latex-helper -std=c++11\n```\n\n`clang++`  `-std=c++11` \n\n```bash\n$ markdown-latex-helper < infile.md > outfile.md\n```\n\n","slug":"markdown-latex-helper","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jid600t10jxl6w98ehvc"},{"title":" - LYOI'15","date":"2016-11-20T08:19:00.000Z","_content":"\n<div style=\"width: 100%; text-align: center; \">\n<div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div>\n</div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: '',\n        url: 'https://dn-menci.qbox.me/music/pfzl.ogg',\n        pic: 'https://dn-menci.qbox.me/music/pfzl.jpg',\n        lrc: '/lyoi-pingfan/pfzl.lrc'\n    }\n});\n</script>\n\nNOIP2016  LYOI \n\n<!-- more -->\n\nNOIP  LYOI  LYOI'14   \n\n LYOI'15 \n\n  \n\n47  \n\n\n\n\n \n\nAK \n\n OI   \n\n\n\n g++  gdb\n VIMAtom  Npp\n elementary  OS X\n\n\n CS  Jokebird\n lyx  tst\n\n\nLYOI \n\n\n\n\n","source":"_posts/lyoi-pingfan.md","raw":"title:  - LYOI'15\ncategories: Diary\npermalink: lyoi-pingfan\ndate: 2016-11-20 16:19:00\n---\n\n<div style=\"width: 100%; text-align: center; \">\n<div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div>\n</div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: '',\n        url: 'https://dn-menci.qbox.me/music/pfzl.ogg',\n        pic: 'https://dn-menci.qbox.me/music/pfzl.jpg',\n        lrc: '/lyoi-pingfan/pfzl.lrc'\n    }\n});\n</script>\n\nNOIP2016  LYOI \n\n<!-- more -->\n\nNOIP  LYOI  LYOI'14   \n\n LYOI'15 \n\n  \n\n47  \n\n\n\n\n \n\nAK \n\n OI   \n\n\n\n g++  gdb\n VIMAtom  Npp\n elementary  OS X\n\n\n CS  Jokebird\n lyx  tst\n\n\nLYOI \n\n\n\n\n","slug":"lyoi-pingfan","published":1,"updated":"2016-11-20T15:48:41.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jidi00t90jxl3iqz99wr"},{"title":"Link-Cut Tree ","date":"2016-01-19T12:50:40.000Z","_content":"\nLink-Cut Tree  Splay Link-Cut Tree  $O({\\log}n)$\n\n<!-- more -->\n\n### \n Link-Cut Tree ********\n\n Splay \n\n Splay Splay  `Path Parent` Splay **** Splay  `Path Parent`  Splay  `Path Parent` \n\n`value` `sum`  `max` `reversed`  Splay \n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### \nLink-Cut Tree \n\n1. `Access(u)` `u`\n2. `Evert(u)` `u` \n3. `Link(u, v)` `u`  `v`  `u`  `v` \n4. `Cut(u, v)` `u`  `v`  `v` \n5. `FindRoot(u)` `u` \n6. `MakeTree()`\n\n### `Access` \n#### `Expose` \n `Access`  `Expose` \n\n1.  `Splay`  Splay \n2. \n\n\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` \n `Splice` ********\n\n1.  `Splay`  Splay \n2.  `Path Parent` `Splice` \n3.  `Path Parent`  `Expose` \n4.  `Path Parent`  `Path Parent` \n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` \n `Expose`  `Splice``Access` `Expose`  `Splice` \n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` \n `Access`\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` \n `v`  `Path Parent`  `u` \n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` \n`Cut` \n\n1.  `u`  `v`  `u` \n2.  `v`  `Access`  `v`  `u` \n3.  `v`  `Splay`  `v` ** Splay **\n4.  `v` \n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query`  `Update` \n `QueryMax(u, v)`  `Node`  `max`  `Maintain()` \n\n `Access(u)` `Splay`  Splay  `u`  `max`  `u` \n\n `Evert` \n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n `Splay`  Splay \n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` \n\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n###  & \n1.  `Splay`  `Rotate` \n2. `Rotate`  `Path Parent`  `Path Parent`  `Path Parent`  Splay \n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/link-cut-tree-notes.md","raw":"title: Link-Cut Tree \ncategories: OI\ntags: \n  - Link-Cut Tree\n  - \n  - Splay\n  - \n  - \n  -   \npermalink: link-cut-tree-notes\ndate: 2016-01-19 20:50:40\n---\n\nLink-Cut Tree  Splay Link-Cut Tree  $O({\\log}n)$\n\n<!-- more -->\n\n### \n Link-Cut Tree ********\n\n Splay \n\n Splay Splay  `Path Parent` Splay **** Splay  `Path Parent`  Splay  `Path Parent` \n\n`value` `sum`  `max` `reversed`  Splay \n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### \nLink-Cut Tree \n\n1. `Access(u)` `u`\n2. `Evert(u)` `u` \n3. `Link(u, v)` `u`  `v`  `u`  `v` \n4. `Cut(u, v)` `u`  `v`  `v` \n5. `FindRoot(u)` `u` \n6. `MakeTree()`\n\n### `Access` \n#### `Expose` \n `Access`  `Expose` \n\n1.  `Splay`  Splay \n2. \n\n\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` \n `Splice` ********\n\n1.  `Splay`  Splay \n2.  `Path Parent` `Splice` \n3.  `Path Parent`  `Expose` \n4.  `Path Parent`  `Path Parent` \n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` \n `Expose`  `Splice``Access` `Expose`  `Splice` \n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` \n `Access`\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` \n `v`  `Path Parent`  `u` \n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` \n`Cut` \n\n1.  `u`  `v`  `u` \n2.  `v`  `Access`  `v`  `u` \n3.  `v`  `Splay`  `v` ** Splay **\n4.  `v` \n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query`  `Update` \n `QueryMax(u, v)`  `Node`  `max`  `Maintain()` \n\n `Access(u)` `Splay`  Splay  `u`  `max`  `u` \n\n `Evert` \n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n `Splay`  Splay \n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` \n\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n###  & \n1.  `Splay`  `Rotate` \n2. `Rotate`  `Path Parent`  `Path Parent`  `Path Parent`  Splay \n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"link-cut-tree-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jidw00tb0jxl6j1hhhvl"},{"title":"KMP ","date":"2015-12-29T20:19:36.000Z","_content":"\nKMPKnuth-Morris-Pratt\n\n<!-- more -->\n\n### \n `pattern`  `\"utqqutnu\"` `target`  `\"utqlwutqqutnu`\"`\"-\"` `\"|\"` \n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `'l'` \n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n \n\n `\"ut\"` \n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n `'t'`  `'l'` \n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP ****\n\n### de\n************************\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `\"utqqut\"` `\"ut\"` `\"ut\"`  `\"ut\"` \n\n `\"ttitty\"` `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n `\"ttitt\"` `\"tt\"`  `\"t\"` `\"t\"` \n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n `'t'` \n\n `\"tt\"` \n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n\n\n****\n\n### de\nKMP ********\n\n `next`  `i`  `i` ****\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nnext  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n `next[i]` \n\n1.  `next[i - 1]`  0 `i`  `next[i - 1] +`  `next[i]`  `next[i - 1] + 1`\n2.  `next[i - 1]`  0 `i`  `next[i] = 1` `next[i] = 0`\n3.  `next[i - 1]`  0 `i`  `next[i - 1] +` **** `i`  `next[next[i - 1] + 1]`  0\n\n*agct*agc**a**gct*agct*\n\n `'a'`  `'t'`  `\"agctagc\"`  `'c'` **** `'t'` `\"agct\"` \n\n### de\n `next` \n\n1. \n2. ****\n3. ****************\n\n### CodeVS 1204\n C++  `0` \n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint next[MAXN] = { 0 };\n\n\tnext[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = next[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = next[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tnext[i] = k + 1;\n\t\t} else {\n\t\t\tnext[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << next[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n","source":"_posts/kmp-notes.md","raw":"title: KMP \ncategories: OI\ntags: \n  - CodeVS\n  - KMP\n  - \n  - \n  -   \npermalink: kmp-notes\ndate: 2015-12-30 04:19:36\n---\n\nKMPKnuth-Morris-Pratt\n\n<!-- more -->\n\n### \n `pattern`  `\"utqqutnu\"` `target`  `\"utqlwutqqutnu`\"`\"-\"` `\"|\"` \n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `'l'` \n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n \n\n `\"ut\"` \n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n `'t'`  `'l'` \n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP ****\n\n### de\n************************\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `\"utqqut\"` `\"ut\"` `\"ut\"`  `\"ut\"` \n\n `\"ttitty\"` `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n `\"ttitt\"` `\"tt\"`  `\"t\"` `\"t\"` \n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n `'t'` \n\n `\"tt\"` \n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n\n\n****\n\n### de\nKMP ********\n\n `next`  `i`  `i` ****\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nnext  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n `next[i]` \n\n1.  `next[i - 1]`  0 `i`  `next[i - 1] +`  `next[i]`  `next[i - 1] + 1`\n2.  `next[i - 1]`  0 `i`  `next[i] = 1` `next[i] = 0`\n3.  `next[i - 1]`  0 `i`  `next[i - 1] +` **** `i`  `next[next[i - 1] + 1]`  0\n\n*agct*agc**a**gct*agct*\n\n `'a'`  `'t'`  `\"agctagc\"`  `'c'` **** `'t'` `\"agct\"` \n\n### de\n `next` \n\n1. \n2. ****\n3. ****************\n\n### CodeVS 1204\n C++  `0` \n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint next[MAXN] = { 0 };\n\n\tnext[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = next[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = next[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tnext[i] = k + 1;\n\t\t} else {\n\t\t\tnext[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << next[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n","slug":"kmp-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jie700tj0jxlonjcgtqk"},{"title":"JSOI2016 -  + RMQ","date":"2016-04-20T14:56:35.000Z","_content":"\nJSOI  $ N $  $ i $  $ h_i $ $ N $ \n\n $ i $  $ p \\ (p \\geq 0) $ JYY  $ j $ \n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI JYY  JYY \n\n<!-- more -->\n\n### \n\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ O(\\sqrt{n}) $ $ j $ \n\n $ j $  $ p_i $  $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  $ j $  $ p_j $ \n\n i $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  RMQ \n\n $ O(n \\log n + n \\sqrt n) $ 3s \n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-light.md","raw":"title: JSOI2016 -  + RMQ\ncategories: OI\ntags: \n  - JSOI\n  - \n  - \n  - RMQ\npermalink: jsoi2016-light\ndate: 2016-04-20 22:56:35\n---\n\nJSOI  $ N $  $ i $  $ h_i $ $ N $ \n\n $ i $  $ p \\ (p \\geq 0) $ JYY  $ j $ \n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI JYY  JYY \n\n<!-- more -->\n\n### \n\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ O(\\sqrt{n}) $ $ j $ \n\n $ j $  $ p_i $  $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  $ j $  $ p_j $ \n\n i $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  RMQ \n\n $ O(n \\log n + n \\sqrt n) $ 3s \n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-light","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiec00tq0jxlyv5j1pe6"},{"title":"JSOI2016 -  + ","date":"2016-04-23T16:41:33.000Z","_content":"\nJSOI  $ N $  $ 1 $  $ N $ $ i $  $ j $  $ T_{i, j} $ $ T_{i, j} $  $ T_{j, i} $ \n\n $ k $  $ P_k $ \n\nJS Airways  $ M $  $ i $  $ D_i $  $ X_i $  $ Y_i $ \n\n JS Airway  $ 0 $  JS Airways \n\nJYY  JS Airways  $ M $ \n\n<!-- more -->\n\n### \n $ i $  $ k $  $ j $  $ i $$ j $  $ T[i][k] + P[k] + T[k][j] $ Floyd \n\n $ A $  $ B $ $ A $  $ B $\n\n1. $ A $  $ B $  $ A $  $ B $ \n2. $ A $  $ A $  $ B $  $ B $ \n\n$ A \\Rightarrow B $  $ A $  $ B $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-flight.md","raw":"title: JSOI2016 -  + \ncategories: OI\ntags: \n  - JSOI\n  - \n  - Dinic\n  - \n  - Floyd\npermalink: jsoi2016-flight\ndate: 2016-04-24 00:41:33\n---\n\nJSOI  $ N $  $ 1 $  $ N $ $ i $  $ j $  $ T_{i, j} $ $ T_{i, j} $  $ T_{j, i} $ \n\n $ k $  $ P_k $ \n\nJS Airways  $ M $  $ i $  $ D_i $  $ X_i $  $ Y_i $ \n\n JS Airway  $ 0 $  JS Airways \n\nJYY  JS Airways  $ M $ \n\n<!-- more -->\n\n### \n $ i $  $ k $  $ j $  $ i $$ j $  $ T[i][k] + P[k] + T[k][j] $ Floyd \n\n $ A $  $ B $ $ A $  $ B $\n\n1. $ A $  $ B $  $ A $  $ B $ \n2. $ A $  $ A $  $ B $  $ B $ \n\n$ A \\Rightarrow B $  $ A $  $ B $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-flight","published":1,"updated":"2016-05-11T09:33:58.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiel00ty0jxlknqpsk0u"},{"title":"JSOI2009 - AC  + ","date":"2016-09-18T09:29:00.000Z","_content":"\n $ n $  $ m $  $ i $  $ {p_i \\over q_i} (0 \\leq p_i \\leq q_i) $$ T $  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1444](http://www.lydsy.com/JudgeOnline/problem.php?id=1444)\n\n### \n AC  AC  AC \n\n $ p(i) = \\frac{p_i}{q_i} $ $ u $  $ v $  $ \\{ c_i \\} $ $ u $  $ v $  $ P(u, v) = \\sum p(c_i) $\n\n AC **** $ i $  $ x_i $\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= 0 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= 0 \\\\\n\\end{aligned}\n$$\n\n $ 1 $ \n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) + 1 \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= -1 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= -1 \\\\\n\\end{aligned}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst int BASE_CHAR = 'A';\nconst double EPS = 0.005;\n\nint charsetSize, n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < charsetSize; i++) c[i] = NULL;\n\t\t\tthis->id = n++;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\t// c = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\ndouble p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1];\n\ninline void buildMatrix() {\n\tfor (int i = 1; i < n; i++) matrix[i][i] = -1;\n\tmatrix[0][0] = -1, matrix[0][n] = -1;\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) continue;\n\n\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t// printf(\"%d -> %d\\n\", v->id, v->c[i]->id);\n\t\t\tmatrix[v->c[i]->id][v->id] += p[i];\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void gauss() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (fabs(matrix[i][i]) < EPS) {\n\t\t\tfor (int j = i + 1; j < n; j++) if (matrix[j][i] >= EPS) {\n\t\t\t\tstd::swap(matrix[i], matrix[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for (int j = i + 1; j < n; j++) if (max == -1 || fabs(matrix[j][i]) > fabs(matrix[max][i])) max = j;\n\t\t// if (max != i) std::swap(matrix[max], matrix[i]);\n\n\t\tdouble t = matrix[i][i];\n\t\tfor (int j = 0; j < n + 1; j++) matrix[i][j] /= t;\n\n\t\tfor (int j = 0; j < n; j++) if (j != i) {\n\t\t\tdouble t = matrix[j][i];\n\t\t\tfor (int k = i; k < n + 1; k++) matrix[j][k] -= t * matrix[i][k];\n\t\t}\n\t}\n}\n\nbool gauss_jordan() {\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = 0; j < n; ++j) if (fabs(matrix[j][i]) > fabs(matrix[idx][i])) idx = j;\n        // if (fabs(matrix[idx][i]) <= eps) return false;\n        if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j <= n; ++j) std::swap(matrix[i][j], matrix[idx][j]);\n        for (int j = 0; j < n; ++j) if (i != j) {\n            double tmp = matrix[j][i] / matrix[i][i];\n            for (int k = n; k >= i; --k) matrix[j][k] -= matrix[i][k] * tmp;\n        }\n    }\n    return true;\n}\n\nint main() {\n\tint m, l;\n\tscanf(\"%d %d %d\", &m, &l, &charsetSize);\n\tfor (int i = 0; i < charsetSize; i++) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf %lf\", &a, &b);\n\t\tp[i] = a / b;\n\t}\n\n\tstatic Trie::Node *a[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tchar s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\ts[i] -= BASE_CHAR;\n\t\t\tif (p[s[i]] == 0) cnt++;\n\t\t}\n\t\ta[i] = t.insert(s, s + l);\n\t}\n\n\t/*\n\tif (cnt == m) {\n\t\tfor (int i = 0; i < m; i++) puts(\"0.00\");\n\t\treturn 0;\n\t}\n\t*/\n\n\tt.build();\n\n\tbuildMatrix();\n\t// for (int i = 0; i <= n; i++) matrix[0][i] = -matrix[0][i];\n\tgauss();\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) printf(\"%.2lf%c\", matrix[i][j], j == n ? '\\n' : ' ');\n\t}\n\t*/\n\n\tfor (int i = 0; i < m; i++) printf(\"%.2lf\\n\", matrix[a[i]->id][n] < EPS ? 0.0f : matrix[a[i]->id][n]);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2009-game2.md","raw":"title: JSOI2009 - AC  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - AC \n  - \n  - \n  - \npermalink: jsoi2009-game2\ndate: 2016-09-18 17:29:00\n---\n\n $ n $  $ m $  $ i $  $ {p_i \\over q_i} (0 \\leq p_i \\leq q_i) $$ T $  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1444](http://www.lydsy.com/JudgeOnline/problem.php?id=1444)\n\n### \n AC  AC  AC \n\n $ p(i) = \\frac{p_i}{q_i} $ $ u $  $ v $  $ \\{ c_i \\} $ $ u $  $ v $  $ P(u, v) = \\sum p(c_i) $\n\n AC **** $ i $  $ x_i $\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= 0 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= 0 \\\\\n\\end{aligned}\n$$\n\n $ 1 $ \n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) + 1 \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= -1 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= -1 \\\\\n\\end{aligned}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst int BASE_CHAR = 'A';\nconst double EPS = 0.005;\n\nint charsetSize, n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < charsetSize; i++) c[i] = NULL;\n\t\t\tthis->id = n++;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\t// c = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\ndouble p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1];\n\ninline void buildMatrix() {\n\tfor (int i = 1; i < n; i++) matrix[i][i] = -1;\n\tmatrix[0][0] = -1, matrix[0][n] = -1;\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) continue;\n\n\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t// printf(\"%d -> %d\\n\", v->id, v->c[i]->id);\n\t\t\tmatrix[v->c[i]->id][v->id] += p[i];\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void gauss() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (fabs(matrix[i][i]) < EPS) {\n\t\t\tfor (int j = i + 1; j < n; j++) if (matrix[j][i] >= EPS) {\n\t\t\t\tstd::swap(matrix[i], matrix[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for (int j = i + 1; j < n; j++) if (max == -1 || fabs(matrix[j][i]) > fabs(matrix[max][i])) max = j;\n\t\t// if (max != i) std::swap(matrix[max], matrix[i]);\n\n\t\tdouble t = matrix[i][i];\n\t\tfor (int j = 0; j < n + 1; j++) matrix[i][j] /= t;\n\n\t\tfor (int j = 0; j < n; j++) if (j != i) {\n\t\t\tdouble t = matrix[j][i];\n\t\t\tfor (int k = i; k < n + 1; k++) matrix[j][k] -= t * matrix[i][k];\n\t\t}\n\t}\n}\n\nbool gauss_jordan() {\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = 0; j < n; ++j) if (fabs(matrix[j][i]) > fabs(matrix[idx][i])) idx = j;\n        // if (fabs(matrix[idx][i]) <= eps) return false;\n        if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j <= n; ++j) std::swap(matrix[i][j], matrix[idx][j]);\n        for (int j = 0; j < n; ++j) if (i != j) {\n            double tmp = matrix[j][i] / matrix[i][i];\n            for (int k = n; k >= i; --k) matrix[j][k] -= matrix[i][k] * tmp;\n        }\n    }\n    return true;\n}\n\nint main() {\n\tint m, l;\n\tscanf(\"%d %d %d\", &m, &l, &charsetSize);\n\tfor (int i = 0; i < charsetSize; i++) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf %lf\", &a, &b);\n\t\tp[i] = a / b;\n\t}\n\n\tstatic Trie::Node *a[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tchar s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\ts[i] -= BASE_CHAR;\n\t\t\tif (p[s[i]] == 0) cnt++;\n\t\t}\n\t\ta[i] = t.insert(s, s + l);\n\t}\n\n\t/*\n\tif (cnt == m) {\n\t\tfor (int i = 0; i < m; i++) puts(\"0.00\");\n\t\treturn 0;\n\t}\n\t*/\n\n\tt.build();\n\n\tbuildMatrix();\n\t// for (int i = 0; i <= n; i++) matrix[0][i] = -matrix[0][i];\n\tgauss();\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) printf(\"%.2lf%c\", matrix[i][j], j == n ? '\\n' : ' ');\n\t}\n\t*/\n\n\tfor (int i = 0; i < m; i++) printf(\"%.2lf\\n\", matrix[a[i]->id][n] < EPS ? 0.0f : matrix[a[i]->id][n]);\n\n\treturn 0;\n}\n```","slug":"jsoi2009-game2","published":1,"updated":"2016-09-18T09:30:31.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jies00u50jxlrvegeixo"},{"title":"JSOI2009 -  + ","date":"2016-04-28T14:10:42.000Z","_content":"\n $ N \\times M $ AA YY  AA \n\n\n\n AA \n\n<!-- more -->\n\n### \n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### \n AA  AA  AA \n\n\n\n YY  YY ******** AA  YY \n\n\n\n -  -  -   \n\n****\n\n Dinic  BFS********\n\n************ -  -  -   \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","source":"_posts/jsoi2009-game.md","raw":"title: JSOI2009 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \n  - \n  - Dinic\npermalink: jsoi2009-game\ndate: 2016-04-28 22:10:42\n---\n\n $ N \\times M $ AA YY  AA \n\n\n\n AA \n\n<!-- more -->\n\n### \n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### \n AA  AA  AA \n\n\n\n YY  YY ******** AA  YY \n\n\n\n -  -  -   \n\n****\n\n Dinic  BFS********\n\n************ -  -  -   \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","slug":"jsoi2009-game","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jif000uf0jxlok0pj3h7"},{"title":"JSOI2008 -  + ","date":"2016-10-18T13:14:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXM = 200000;\nconst int MAXN = 2 * MAXM;\n\nstruct UnionFindSet {\n\tint a[MAXN], rk[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i, rk[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n\n\tvoid merge(const int x, const int y) {\n\t\tconst int p = find(x), q = find(y);\n\t\tif (p == q) return;\n\t\tif (rk[p] > rk[q]) a[q] = p;\n\t\telse if (rk[q] > rk[p]) a[p] = q;\n\t\telse a[p] = q, rk[q]++;\n\t}\n} ufs;\n\nstruct Edge {\n\tbool added;\n\tint u, v;\n} E[MAXM];\n\nstruct Node {\n\tstd::vector<Edge *> e;\n\tbool added;\n\tbool willDelete;\n} N[MAXN];\n\ninline void addAllEdge(Node *v, int &ans) {\n\tans++;\n\tfor (std::vector<Edge *>::const_iterator it = v->e.begin(); it != v->e.end(); it++) {\n\t\tEdge *const &e = *it;\n\t\tif (!e->added && N[e->u].added && N[e->v].added && !ufs.test(e->u, e->v)) {\n\t\t\tufs.merge(e->u, e->v);\n\t\t\t// printf(\"merge(%d, %d)\\n\", e->u, e->v);\n\t\t\tans--;\n\t\t\te->added = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k, ans;\n\tstatic int a[MAXN];\n\tscanf(\"%d %d\", &n, &m), ans = 0;\n\n\tufs.init(n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v), N[E[i].u].e.push_back(&E[i]), N[E[i].v].e.push_back(&E[i]);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = k - 1; i >= 0; i--) scanf(\"%d\", &a[i]), N[a[i]].willDelete = true;\n\n\tfor (int i = 0; i < n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&N[i], ans);\n\n\tstd::vector<int> anses;\n\tanses.push_back(ans);\n\t\n\tfor (int i = 0; i < k; i++) {\n\t\t// printf(\"before %d\\n\", a[i]);\n\t\tNode *v = &N[a[i]];\n\t\tv->added = true;\n\t\taddAllEdge(v, ans);\n\t\tanses.push_back(ans);\n\t}\n\n\tfor (std::vector<int>::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-starwar.md","raw":"title: JSOI2008 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2008-starwar\ndate: 2016-10-18 21:14:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXM = 200000;\nconst int MAXN = 2 * MAXM;\n\nstruct UnionFindSet {\n\tint a[MAXN], rk[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i, rk[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n\n\tvoid merge(const int x, const int y) {\n\t\tconst int p = find(x), q = find(y);\n\t\tif (p == q) return;\n\t\tif (rk[p] > rk[q]) a[q] = p;\n\t\telse if (rk[q] > rk[p]) a[p] = q;\n\t\telse a[p] = q, rk[q]++;\n\t}\n} ufs;\n\nstruct Edge {\n\tbool added;\n\tint u, v;\n} E[MAXM];\n\nstruct Node {\n\tstd::vector<Edge *> e;\n\tbool added;\n\tbool willDelete;\n} N[MAXN];\n\ninline void addAllEdge(Node *v, int &ans) {\n\tans++;\n\tfor (std::vector<Edge *>::const_iterator it = v->e.begin(); it != v->e.end(); it++) {\n\t\tEdge *const &e = *it;\n\t\tif (!e->added && N[e->u].added && N[e->v].added && !ufs.test(e->u, e->v)) {\n\t\t\tufs.merge(e->u, e->v);\n\t\t\t// printf(\"merge(%d, %d)\\n\", e->u, e->v);\n\t\t\tans--;\n\t\t\te->added = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k, ans;\n\tstatic int a[MAXN];\n\tscanf(\"%d %d\", &n, &m), ans = 0;\n\n\tufs.init(n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v), N[E[i].u].e.push_back(&E[i]), N[E[i].v].e.push_back(&E[i]);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = k - 1; i >= 0; i--) scanf(\"%d\", &a[i]), N[a[i]].willDelete = true;\n\n\tfor (int i = 0; i < n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&N[i], ans);\n\n\tstd::vector<int> anses;\n\tanses.push_back(ans);\n\t\n\tfor (int i = 0; i < k; i++) {\n\t\t// printf(\"before %d\\n\", a[i]);\n\t\tNode *v = &N[a[i]];\n\t\tv->added = true;\n\t\taddAllEdge(v, ans);\n\t\tanses.push_back(ans);\n\t}\n\n\tfor (std::vector<int>::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","slug":"jsoi2008-starwar","published":1,"updated":"2016-10-18T13:20:00.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jif600uo0jxlmy88sxvg"},{"title":"JSOI2008 - Splay + Hash","date":"2016-10-18T12:16:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1014](http://www.lydsy.com/JudgeOnline/problem.php?id=1014)\n\n### \n Splay  Hash Hash  Hash  Hash \n\n LCP \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid rotate() {\n\t\t\tNode *o = p;\n\t\t\tint x = relation();\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (relation() == p->relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = 1;\n\t\t\tif (c[0]) size += c[0]->size;\n\t\t\tif (c[1]) size += c[1]->size;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() { return c[0] ? c[0]->size : 0; }\n\n\t\tvoid print(const int depth = 0) {\n\t\t\tif (c[1]) c[1]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\tprintf(\"%c\\n\", val == 0 ? ' ' : val);\n\t\t\tif (c[0]) c[0]->print(depth + 1);\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {}\n\n\tNode *build(const char *first, const char *last, Node *p) {\n\t\tif (first > last) return NULL;\n\t\tif (first == last) return new Node(p, &r, *first);\n\t\telse {\n\t\t\tconst char *mid = first + (last - first) / 2;\n\t\t\tNode *v = new Node(p, &r, *mid);\n\t\t\tv->c[0] = build(first, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, last, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBounds(const int x) {\n\t\tNode *v = r;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &r, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->p;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *first, const char *last) {\n\t\tr = build(first, last, NULL);\n\t\tbuildBounds(0);\n\t\tbuildBounds(1);\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x < v->lsize() + 1) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(const int l, const int r) {\n\t\tNode *a = select(l - 1), *b = select(r + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\treturn b->c[0];\n\t}\n\n\tNode *insert(const int pos, const char ch) {\n\t\tNode *a = select(pos), *b = select(pos + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\tb->c[0] = new Node(b, &r, ch);\n\t\tNode *v = b->c[0];\n\t\tdo {\n\t\t\tv->maintain();\n\t\t\tv = v->p;\n\t\t} while (v);\n\t\treturn b->c[0]->splay();\n\t}\n\n\tvoid update(const int pos, const char ch) {\n\t\tNode *v = select(pos);\n\t\tv->val = ch;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(const int l, const int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() { return r->size - 2; }\n} splay;\n\ninline void print() {\n\tsplay.r->print();\n\tputs(\"------------------------\");\n}\n\ninline int lcp(const int a, const int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE;\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.update(pos, ch[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.insert(pos, ch[0]);\n\t\t}\n\n\t\t// print();\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-prefix.md","raw":"title: JSOI2008 - Splay + Hash\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - Hash\n  - \npermalink: jsoi2008-prefix\ndate: 2016-10-18 20:16:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1014](http://www.lydsy.com/JudgeOnline/problem.php?id=1014)\n\n### \n Splay  Hash Hash  Hash  Hash \n\n LCP \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid rotate() {\n\t\t\tNode *o = p;\n\t\t\tint x = relation();\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (relation() == p->relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = 1;\n\t\t\tif (c[0]) size += c[0]->size;\n\t\t\tif (c[1]) size += c[1]->size;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() { return c[0] ? c[0]->size : 0; }\n\n\t\tvoid print(const int depth = 0) {\n\t\t\tif (c[1]) c[1]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\tprintf(\"%c\\n\", val == 0 ? ' ' : val);\n\t\t\tif (c[0]) c[0]->print(depth + 1);\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {}\n\n\tNode *build(const char *first, const char *last, Node *p) {\n\t\tif (first > last) return NULL;\n\t\tif (first == last) return new Node(p, &r, *first);\n\t\telse {\n\t\t\tconst char *mid = first + (last - first) / 2;\n\t\t\tNode *v = new Node(p, &r, *mid);\n\t\t\tv->c[0] = build(first, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, last, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBounds(const int x) {\n\t\tNode *v = r;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &r, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->p;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *first, const char *last) {\n\t\tr = build(first, last, NULL);\n\t\tbuildBounds(0);\n\t\tbuildBounds(1);\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x < v->lsize() + 1) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(const int l, const int r) {\n\t\tNode *a = select(l - 1), *b = select(r + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\treturn b->c[0];\n\t}\n\n\tNode *insert(const int pos, const char ch) {\n\t\tNode *a = select(pos), *b = select(pos + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\tb->c[0] = new Node(b, &r, ch);\n\t\tNode *v = b->c[0];\n\t\tdo {\n\t\t\tv->maintain();\n\t\t\tv = v->p;\n\t\t} while (v);\n\t\treturn b->c[0]->splay();\n\t}\n\n\tvoid update(const int pos, const char ch) {\n\t\tNode *v = select(pos);\n\t\tv->val = ch;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(const int l, const int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() { return r->size - 2; }\n} splay;\n\ninline void print() {\n\tsplay.r->print();\n\tputs(\"------------------------\");\n}\n\ninline int lcp(const int a, const int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE;\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.update(pos, ch[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.insert(pos, ch[0]);\n\t\t}\n\n\t\t// print();\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-prefix","published":1,"updated":"2016-10-18T13:10:35.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jifb00uu0jxl0bjautas"},{"title":"JSOI2008 - Splay","id":"56","updated":"2016-02-20T02:13:55.000Z","date":"2016-02-20T02:11:00.000Z","_content":"\n\n\n1.   \n   `Q L`  \n    `L`   \n   `L` \n2. \n   `A n`  \n    `n`  `t` `t`  `t = 0`) `D`   \n   `n` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### \nSplay  \n\n\n\n Splay qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-maxnumber.md","raw":"title: JSOI2008 - Splay\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - \n  - \npermalink: jsoi2008-maxnumber\nid: 56\nupdated: '2016-02-20 10:13:55'\ndate: 2016-02-20 10:11:00\n---\n\n\n\n1.   \n   `Q L`  \n    `L`   \n   `L` \n2. \n   `A n`  \n    `n`  `t` `t`  `t = 0`) `D`   \n   `n` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### \nSplay  \n\n\n\n Splay qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-maxnumber","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jifh00v10jxle8jg037f"},{"title":"JSOI2008 -  DP","date":"2016-07-11T15:10:00.000Z","_content":"\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1017](http://www.lydsy.com/JudgeOnline/problem.php?id=1017)\n\n### \n$ f(i, j) $  $ i $  $ j $ \n\n $ g(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 51;\nconst int MAXM = 2000;\nconst int MAXK = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, val, ind;\n\tbool basic; // , visited;\n\tint f[MAXK + 1][MAXM + 1];\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\t// printf(\"E(%d, %d, %d)\\n\", s, t, w);\n\tN[t].ind++;\n\tN[s].e = new Edge(&N[s], &N[t], w);\n}\n\nint n, m, ans;\n\ninline void bfs() {\n\tint pos = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].ind) continue;\n\t\t// printf(\"%d\\n\", i);\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\t// N[i].visited = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tfor (Edge *e = (seq[--pos] = q.front())->e; e; e = e->next) q.push(e->t); // , e->t->visited = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n}\n\ninline void dp1() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tif (!v->basic) {\n\t\t\tv->cnt = INT_MAX;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->cnt = std::min(v->cnt, e->t->cnt / e->w);\n\t\t\t\tv->cost += e->t->cost * e->w;\n\t\t\t}\n\t\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\t}\n\t}\n}\n\ninline void dp2() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tint (&f)[MAXK + 1][MAXM + 1] = v->f;\n\t\tstatic int g[MAXN + 1][MAXM + 1];\n\n\t\tif (v->basic) {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\tfor (int j = v->cost * i; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::max(f[i][j], std::min(v->cnt - i, (j - v->cost * i) / v->cost) * v->val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\t// memset(g, 0, sizeof(g));\n\t\t\t\tfor (int i = 0; i <= MAXN; i++) for (int j = 0; j <= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN;\n\t\t\t\t// if (!v->e) {\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\t\tf[j][k] = std::max(f[j][k], v->val * (i - j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t// } else {\n\t\t\t\t\t// for (int j = v->cost * i; j <= m; j++) g[j] = v->val * i;\n\n\t\t\t\tint id = 0;\n\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\tid++;\n\t\t\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\t\t\tfor (int k = i * e->w * e->t->cost; k <= j; k++) {\n\t\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->t->f[e->w * i][k]);\n\t\t\t\t\t\t\t// if (j - k * e->t->cost >= v->cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e->t->cost]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// printf(\"g[%d][%d] = %d\\n\", i, j, g[i][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\tf[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v->val);\n\t\t\t\t\t\tans = std::max(ans, f[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &N[i].val);\n\t\tchar s[2];\n\t\tscanf(\"%s\", s);\n\n\t\tif (s[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\twhile (t--) {\n\t\t\t\tint u, w;\n\t\t\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\t\t\taddEdge(i, u, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs();\n\tdp1();\n\tdp2();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2008-dotr.md","raw":"title: JSOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - DP\n  -  DP\npermalink: jsoi2008-dotr\ndate: 2016-07-11 23:10:00\n---\n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1017](http://www.lydsy.com/JudgeOnline/problem.php?id=1017)\n\n### \n$ f(i, j) $  $ i $  $ j $ \n\n $ g(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 51;\nconst int MAXM = 2000;\nconst int MAXK = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, val, ind;\n\tbool basic; // , visited;\n\tint f[MAXK + 1][MAXM + 1];\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\t// printf(\"E(%d, %d, %d)\\n\", s, t, w);\n\tN[t].ind++;\n\tN[s].e = new Edge(&N[s], &N[t], w);\n}\n\nint n, m, ans;\n\ninline void bfs() {\n\tint pos = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].ind) continue;\n\t\t// printf(\"%d\\n\", i);\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\t// N[i].visited = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tfor (Edge *e = (seq[--pos] = q.front())->e; e; e = e->next) q.push(e->t); // , e->t->visited = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n}\n\ninline void dp1() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tif (!v->basic) {\n\t\t\tv->cnt = INT_MAX;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->cnt = std::min(v->cnt, e->t->cnt / e->w);\n\t\t\t\tv->cost += e->t->cost * e->w;\n\t\t\t}\n\t\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\t}\n\t}\n}\n\ninline void dp2() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tint (&f)[MAXK + 1][MAXM + 1] = v->f;\n\t\tstatic int g[MAXN + 1][MAXM + 1];\n\n\t\tif (v->basic) {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\tfor (int j = v->cost * i; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::max(f[i][j], std::min(v->cnt - i, (j - v->cost * i) / v->cost) * v->val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\t// memset(g, 0, sizeof(g));\n\t\t\t\tfor (int i = 0; i <= MAXN; i++) for (int j = 0; j <= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN;\n\t\t\t\t// if (!v->e) {\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\t\tf[j][k] = std::max(f[j][k], v->val * (i - j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t// } else {\n\t\t\t\t\t// for (int j = v->cost * i; j <= m; j++) g[j] = v->val * i;\n\n\t\t\t\tint id = 0;\n\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\tid++;\n\t\t\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\t\t\tfor (int k = i * e->w * e->t->cost; k <= j; k++) {\n\t\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->t->f[e->w * i][k]);\n\t\t\t\t\t\t\t// if (j - k * e->t->cost >= v->cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e->t->cost]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// printf(\"g[%d][%d] = %d\\n\", i, j, g[i][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\tf[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v->val);\n\t\t\t\t\t\tans = std::max(ans, f[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &N[i].val);\n\t\tchar s[2];\n\t\tscanf(\"%s\", s);\n\n\t\tif (s[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\twhile (t--) {\n\t\t\t\tint u, w;\n\t\t\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\t\t\taddEdge(i, u, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs();\n\tdp1();\n\tdp2();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2008-dotr","published":1,"updated":"2016-10-24T23:37:01.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jifl00v80jxlr7o0iqza"},{"title":"JSOI2008 - ","date":"2016-10-18T13:34:00.000Z","_content":"\n $ \\leq 10 $\n\n<!-- more -->\n\n### \n[BZOJ 1016](http://www.lydsy.com/JudgeOnline/problem.php?id=1016)\n\n### \n> \n\nhttps://blog.sengxian.com/solutions/bzoj-1016\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nconst int MAXN = 100;\nconst int MAXM = 1000;\nconst int MAXC = 1000000000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool used;\n\n\tbool operator<(const Edge &other) const { return w < other.w; }\n} E[MAXM];\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tvoid merge(const int x, const int y) {\n\t\ta[find(x)] = find(y);\n\t}\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n} ufs;\n\nstruct EdgeGroup {\n\tint used;\n\tstd::vector<Edge> edges;\n};\n\nint n, m, graph[MAXN][MAXN];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.test(E[i].u, E[i].v)) {\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tE[i].used = true;\n\t\t\tgroups[E[i].w].used++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].edges.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w), E[i].u--, E[i].v--;\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.used == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.edges.size()); s++) {\n\t\t\t\tint popcount = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.edges.size(); i++) if (s & (1 << i)) popcount++;\n\t\t\t\tif (popcount != it->second.used) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tif (!(s & (1 << (e - it->second.edges.begin())))) continue;\n\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tif (graph[i][j]) {\n\t\t\t\t\t\t\tif (ufs.test(i, j)) {\n\t\t\t\t\t\t\t\tgoto nextLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\nnextLoop:;\n\t\t\t}\n\t\t\t// printf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = e->used;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-award.md","raw":"title: JSOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2008-award\ndate: 2016-10-18 21:34:00\n---\n\n $ \\leq 10 $\n\n<!-- more -->\n\n### \n[BZOJ 1016](http://www.lydsy.com/JudgeOnline/problem.php?id=1016)\n\n### \n> \n\nhttps://blog.sengxian.com/solutions/bzoj-1016\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nconst int MAXN = 100;\nconst int MAXM = 1000;\nconst int MAXC = 1000000000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool used;\n\n\tbool operator<(const Edge &other) const { return w < other.w; }\n} E[MAXM];\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tvoid merge(const int x, const int y) {\n\t\ta[find(x)] = find(y);\n\t}\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n} ufs;\n\nstruct EdgeGroup {\n\tint used;\n\tstd::vector<Edge> edges;\n};\n\nint n, m, graph[MAXN][MAXN];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.test(E[i].u, E[i].v)) {\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tE[i].used = true;\n\t\t\tgroups[E[i].w].used++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].edges.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w), E[i].u--, E[i].v--;\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.used == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.edges.size()); s++) {\n\t\t\t\tint popcount = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.edges.size(); i++) if (s & (1 << i)) popcount++;\n\t\t\t\tif (popcount != it->second.used) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tif (!(s & (1 << (e - it->second.edges.begin())))) continue;\n\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tif (graph[i][j]) {\n\t\t\t\t\t\t\tif (ufs.test(i, j)) {\n\t\t\t\t\t\t\t\tgoto nextLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\nnextLoop:;\n\t\t\t}\n\t\t\t// printf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = e->used;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-award","published":1,"updated":"2016-10-18T13:41:02.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jifq00ve0jxlcgb65afe"},{"title":"JSOI2007 - ","date":"2016-11-13T01:11:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029)\n\n### \n****\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 150000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic std::pair<int, int> a[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].second, &a[i].first);\n\n\tstd::sort(a, a + n);\n\n\tstd::priority_queue<int> q;\n\tlong long t = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t + a[i].second <= a[i].first) {\n\t\t\tt += a[i].second;\n\t\t\tq.push(a[i].second);\n\t\t\tans++;\n\t\t} else if (!q.empty() && q.top() > a[i].second) {\n\t\t\tt -= q.top();\n\t\t\tt += a[i].second;\n\t\t\tq.pop();\n\t\t\tq.push(a[i].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-repair.md","raw":"title: JSOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \npermalink: jsoi2007-repair\ndate: 2016-11-13 09:11:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029)\n\n### \n****\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 150000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic std::pair<int, int> a[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].second, &a[i].first);\n\n\tstd::sort(a, a + n);\n\n\tstd::priority_queue<int> q;\n\tlong long t = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t + a[i].second <= a[i].first) {\n\t\t\tt += a[i].second;\n\t\t\tq.push(a[i].second);\n\t\t\tans++;\n\t\t} else if (!q.empty() && q.top() > a[i].second) {\n\t\t\tt -= q.top();\n\t\t\tt += a[i].second;\n\t\t\tq.pop();\n\t\t\tq.push(a[i].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"jsoi2007-repair","published":1,"updated":"2016-11-13T01:25:57.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jifu00vk0jxlkvuve8s3"},{"title":"JSOI2007 -  + ","date":"2016-11-13T00:27:00.000Z","_content":"\n\n $ 1 $  $ n $  $ 3m + 2 $  $ 3m $  $ m $  $ 3m + 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028)\n\n### \n $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 1000;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN];\n\tfor (int i = 0; i < m * 3 + 1; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1]++;\n\t}\n\n\tstatic int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic int b[MAXN];\n\t\tstd::copy(a, a + n, b);\n\t\tb[i]++;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (b[j] >= 2) {\n\t\t\t\tstatic int c[MAXN + 2];\n\t\t\t\tstd::copy(b, b + n, c);\n\t\t\t\tc[j] -= 2;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (c[k] == 0) continue;\n\t\t\t\t\tc[k] %= 3;\n\t\t\t\t\tint x = std::min(std::min(c[k], c[k + 1]), c[k + 2]);\n\t\t\t\t\tif (x < c[k]) goto fail;\n\t\t\t\t\tc[k] -= x, c[k + 1] -= x, c[k + 2] -= x;\n\t\t\t\t}\n\n\t\t\t\tgoto success;\n\nfail:;\n\t\t\t}\n\t\t}\n\n\t\tcontinue;\n\nsuccess:\n\t\tans[cnt++] = i + 1;\n\t}\n\n\tif (cnt) {\n\t\tfor (int i = 0; i < cnt; i++) printf(\"%d%c\", ans[i], i == cnt - 1 ? '\\n' : ' ');\n\t} else puts(\"NO\");\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-mahjong.md","raw":"title: JSOI2007 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2007-mahjong\ndate: 2016-11-13 08:27:00\n---\n\n\n $ 1 $  $ n $  $ 3m + 2 $  $ 3m $  $ m $  $ 3m + 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028)\n\n### \n $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 1000;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN];\n\tfor (int i = 0; i < m * 3 + 1; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1]++;\n\t}\n\n\tstatic int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic int b[MAXN];\n\t\tstd::copy(a, a + n, b);\n\t\tb[i]++;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (b[j] >= 2) {\n\t\t\t\tstatic int c[MAXN + 2];\n\t\t\t\tstd::copy(b, b + n, c);\n\t\t\t\tc[j] -= 2;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (c[k] == 0) continue;\n\t\t\t\t\tc[k] %= 3;\n\t\t\t\t\tint x = std::min(std::min(c[k], c[k + 1]), c[k + 2]);\n\t\t\t\t\tif (x < c[k]) goto fail;\n\t\t\t\t\tc[k] -= x, c[k + 1] -= x, c[k + 2] -= x;\n\t\t\t\t}\n\n\t\t\t\tgoto success;\n\nfail:;\n\t\t\t}\n\t\t}\n\n\t\tcontinue;\n\nsuccess:\n\t\tans[cnt++] = i + 1;\n\t}\n\n\tif (cnt) {\n\t\tfor (int i = 0; i < cnt; i++) printf(\"%d%c\", ans[i], i == cnt - 1 ? '\\n' : ' ');\n\t} else puts(\"NO\");\n\n\treturn 0;\n}\n```","slug":"jsoi2007-mahjong","published":1,"updated":"2016-11-13T00:32:35.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jify00vp0jxl6giayqp0"},{"title":"JSOI2007 - AC ","date":"2016-09-11T23:19:00.000Z","_content":"\n    \n\n $ a $  $ b $ $ b $  $ a $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030)\n\n### \n\n\n DP    $ i $  $ j $  KMP \n\n KMP  AC  $ j $  AC  $ j $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 60;\nconst int MAXM = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\n\nstruct Trie {\n\tstruct Node {\n\t\tint id;\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool next(Node *v, const char ch, Node *&next) {\n\t\twhile (v != root && !v->c[ch]) v = v->fail;\n\t\tnext = v->c[ch] ? v->c[ch] : root;\n\t\tif (!v->c[ch]) return false;\n\t\telse if (v->c[ch]->isWord) return true;\n\t\telse if (v->c[ch]->next) return true;\n\t\telse return false;\n\t}\n\n\tvoid getNodeList(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tvec.push_back(v);\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) if (v->c[i]) q.push(v->c[i]);\n\t\t}\n\t}\n} t;\n\ninline int pow(int x, int n) {\n\tint ans = 1;\n\tfor (; n; n >>= 1, x = x * x % MOD) if (n & 1) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (n--) {\n\t\tchar s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\n\tstd::vector<Trie::Node *> vec;\n\tt.getNodeList(vec);\n\n\t// std::tr1::unordered_map<Trie::Node *, int> f[MAXM + 1];\n\tstatic int f[MAXM + 1][MAXM * MAXN + 1];\n\t// for (size_t i = 0; i < vec.size(); i++) for (int j = 0; j < CHARSET_SIZE; j++) if (!vec[i]->c[j] || !vec[i]->c[j]->isWord) f[1][vec[i]]++;\n\tfor (size_t i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tTrie::Node *next;\n\t\t\t\tif (!t.next(vec[j], k, next)) {\n\t\t\t\t\t(f[i][j] += f[i - 1][next->id]) %= MOD;\n\t\t\t\t\t// if (k <= 5) printf(\"(%d, %lu) => %d (%d)\\n\", i, j, k, f[i - 1][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) printf(\"f(%d, %lu) = %d\\n\", i, j, f[i][vec[j]]);\n\t\tputchar('\\n');\n\t}\n\t// */\n\n\t// printf(\"%d\\n\", f[m][t.root]);\n\tprintf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id]) % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-generator.md","raw":"title: JSOI2007 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - AC \n  - DP\npermalink: jsoi2007-generator\ndate: 2016-09-12 07:19:00\n---\n\n    \n\n $ a $  $ b $ $ b $  $ a $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030)\n\n### \n\n\n DP    $ i $  $ j $  KMP \n\n KMP  AC  $ j $  AC  $ j $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 60;\nconst int MAXM = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\n\nstruct Trie {\n\tstruct Node {\n\t\tint id;\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool next(Node *v, const char ch, Node *&next) {\n\t\twhile (v != root && !v->c[ch]) v = v->fail;\n\t\tnext = v->c[ch] ? v->c[ch] : root;\n\t\tif (!v->c[ch]) return false;\n\t\telse if (v->c[ch]->isWord) return true;\n\t\telse if (v->c[ch]->next) return true;\n\t\telse return false;\n\t}\n\n\tvoid getNodeList(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tvec.push_back(v);\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) if (v->c[i]) q.push(v->c[i]);\n\t\t}\n\t}\n} t;\n\ninline int pow(int x, int n) {\n\tint ans = 1;\n\tfor (; n; n >>= 1, x = x * x % MOD) if (n & 1) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (n--) {\n\t\tchar s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\n\tstd::vector<Trie::Node *> vec;\n\tt.getNodeList(vec);\n\n\t// std::tr1::unordered_map<Trie::Node *, int> f[MAXM + 1];\n\tstatic int f[MAXM + 1][MAXM * MAXN + 1];\n\t// for (size_t i = 0; i < vec.size(); i++) for (int j = 0; j < CHARSET_SIZE; j++) if (!vec[i]->c[j] || !vec[i]->c[j]->isWord) f[1][vec[i]]++;\n\tfor (size_t i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tTrie::Node *next;\n\t\t\t\tif (!t.next(vec[j], k, next)) {\n\t\t\t\t\t(f[i][j] += f[i - 1][next->id]) %= MOD;\n\t\t\t\t\t// if (k <= 5) printf(\"(%d, %lu) => %d (%d)\\n\", i, j, k, f[i - 1][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) printf(\"f(%d, %lu) = %d\\n\", i, j, f[i][vec[j]]);\n\t\tputchar('\\n');\n\t}\n\t// */\n\n\t// printf(\"%d\\n\", f[m][t.root]);\n\tprintf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id]) % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```","slug":"jsoi2007-generator","published":1,"updated":"2016-09-11T23:28:09.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jig400vw0jxlpt3ytw0y"},{"title":"JSOI2007 - ","date":"2016-09-29T13:00:00.000Z","_content":"\n $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5 * 2;\n\nchar s[MAXN];\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\n\ninline void print(const int *a) {\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(fir);\n\t\t// print(sec);\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\t\t// print(tmp);\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(buc);\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\t\t// print(sa);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\t// print(rk);\n\n\t\t// return;\n\t}\n\t// puts(\"----------------\");\n\t// print(sa);\n\t// print(rk);\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", s + sa[i]);\n\t\n\t/*\n\tfor (int i = 0, j, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tj = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\t// k = 0;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\t*/\n\t// print(ht);\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++) s[i + n] = s[i];\n\tn *= 2;\n\tsuffixArray();\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i] + 1, i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 1; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sa[i] < n / 2) {\n\t\t\tputchar(s[sa[i] + n / 2 - 1]);\n\t\t}\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-cipher.md","raw":"title: JSOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2007-cipher\ndate: 2016-09-29 21:00:00\n---\n\n $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5 * 2;\n\nchar s[MAXN];\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\n\ninline void print(const int *a) {\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(fir);\n\t\t// print(sec);\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\t\t// print(tmp);\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(buc);\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\t\t// print(sa);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\t// print(rk);\n\n\t\t// return;\n\t}\n\t// puts(\"----------------\");\n\t// print(sa);\n\t// print(rk);\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", s + sa[i]);\n\t\n\t/*\n\tfor (int i = 0, j, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tj = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\t// k = 0;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\t*/\n\t// print(ht);\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++) s[i + n] = s[i];\n\tn *= 2;\n\tsuffixArray();\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i] + 1, i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 1; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sa[i] < n / 2) {\n\t\t\tputchar(s[sa[i] + n / 2 - 1]);\n\t\t}\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","slug":"jsoi2007-cipher","published":1,"updated":"2016-09-29T13:06:01.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jig900w30jxlz98i3xkd"},{"title":"IOI2011Race - ","date":"2016-06-16T12:01:00.000Z","_content":"\n**** $ K $\n\n<!-- more -->\n\n### \n[BZOJ 2599](http://www.lydsy.com/JudgeOnline/problem.php?id=2599)\n\n### \n $ K $ \n\n $ {\\rm depth}(v) $  $ {\\rm dist}(v) $\n\n $ f(i) $ **** $ i $ \n\n $ {\\rm depth}(i) + f(K - {\\rm dist}(i)) $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n// #include \"rand.h\"\n#include <queue>\n#include <stack>\n\nconst int MAXN = 200000;\nconst int MAXK = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist, depth, size, max;\n\tbool visited, solved;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\nint f[MAXK + 1];\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->visited = false;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// return a[rand(0, cnt - 1)];\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"%d %d\\n\", cnt, start->size);\n\t\tassert(cnt == start->size);\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\treturn res;\n}\n\ninline int calc(Node *root) {\n\tstatic int A[MAXN];\n\tint tot = 0, res = INT_MAX;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(e->t);\n\t\te->t->parent = root;\n\t\te->t->dist = e->w;\n\t\te->t->depth = 1;\n\n\t\tstatic Node *a[MAXN];\n\t\tint cnt = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tif (v->dist > k) continue;\n\n\t\t\tA[tot++] = v->dist;\n\t\t\ta[cnt++] = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t// assert(k - a[i]->dist >= 0 && k - a[i]->dist <= k);\n\t\t\tif (f[k - a[i]->dist] != INT_MAX) res = std::min(res, f[k - a[i]->dist] + a[i]->depth);\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tf[a[i]->dist] = std::min(f[a[i]->dist], a[i]->depth);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) {\n\t\t// assert(A[i] >= 0 && A[i] <= k);\n\t\tf[A[i]] = INT_MAX;\n\t}\n\n\t// printf(\"calc(%ld) = %d\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = INT_MAX;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans = std::min(ans, calc(root));\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\t// assert(n <= MAXN);\n\t// assert(k <= MAXK);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w);\n\t}\n\n\tfor (int i = 1; i <= k; i++) f[i] = INT_MAX;\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/ioi2011-race.md","raw":"title: IOI2011Race - \ncategories: OI\ntags: \n  - IOI\n  - BZOJ\n  - \n  - \npermalink: ioi2011-race\ndate: 2016-06-16 20:01:00\n---\n\n**** $ K $\n\n<!-- more -->\n\n### \n[BZOJ 2599](http://www.lydsy.com/JudgeOnline/problem.php?id=2599)\n\n### \n $ K $ \n\n $ {\\rm depth}(v) $  $ {\\rm dist}(v) $\n\n $ f(i) $ **** $ i $ \n\n $ {\\rm depth}(i) + f(K - {\\rm dist}(i)) $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n// #include \"rand.h\"\n#include <queue>\n#include <stack>\n\nconst int MAXN = 200000;\nconst int MAXK = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist, depth, size, max;\n\tbool visited, solved;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\nint f[MAXK + 1];\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->visited = false;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// return a[rand(0, cnt - 1)];\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"%d %d\\n\", cnt, start->size);\n\t\tassert(cnt == start->size);\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\treturn res;\n}\n\ninline int calc(Node *root) {\n\tstatic int A[MAXN];\n\tint tot = 0, res = INT_MAX;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(e->t);\n\t\te->t->parent = root;\n\t\te->t->dist = e->w;\n\t\te->t->depth = 1;\n\n\t\tstatic Node *a[MAXN];\n\t\tint cnt = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tif (v->dist > k) continue;\n\n\t\t\tA[tot++] = v->dist;\n\t\t\ta[cnt++] = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t// assert(k - a[i]->dist >= 0 && k - a[i]->dist <= k);\n\t\t\tif (f[k - a[i]->dist] != INT_MAX) res = std::min(res, f[k - a[i]->dist] + a[i]->depth);\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tf[a[i]->dist] = std::min(f[a[i]->dist], a[i]->depth);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) {\n\t\t// assert(A[i] >= 0 && A[i] <= k);\n\t\tf[A[i]] = INT_MAX;\n\t}\n\n\t// printf(\"calc(%ld) = %d\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = INT_MAX;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans = std::min(ans, calc(root));\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\t// assert(n <= MAXN);\n\t// assert(k <= MAXK);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w);\n\t}\n\n\tfor (int i = 1; i <= k; i++) f[i] = INT_MAX;\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","slug":"ioi2011-race","published":1,"updated":"2016-06-16T12:01:55.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jige00w90jxlf66yobmu"},{"title":"IOI2008 -  DP","date":"2016-10-24T13:39:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1791](http://www.lydsy.com/JudgeOnline/problem.php?id=1791)\n\n### \n\n\n $ f(i) $  $ i $  $ i $  $ j $$ f(i) = \\max\\{ f(j) + d(i, j) \\} $\n\n $ u $$ v $  $ f(u) + d(i, u) + f(v) + d(i, v) $ \n\n DP\n\n $ f'(i) $  $ i $  $ f $ $ s(i) $  $ i $ \n\n $ i $  $ i $  $ j $ $ i $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + s(i) - s(j) \\pod {i > j} \\\\\n= & f'(j) - s(j) + f'(i) + s(i)\n\\end{aligned}\n$$\n\n $ i $  $ j $$ S $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + S - (s(i) - s(j)) \\pod {i > j} \\\\\n= & f'(i) + f'(j) + S - s(i) + s(j) \\\\\n= & f'(j) + s(j) + S + f'(i) - s(i)\n\\end{aligned}\n$$\n\n $ f'(j) + s(j) + S $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tbool inCircle, solved, visited, pushed;\n\tint depth, inDegree;\n\tlong long len;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long w;\n\tEdge *next, *r;\n\tbool disabled;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nint n;\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline std::vector<Node *> getBlock(Node *start) {\n\tstd::queue<Node *> q;\n\tq.push(start);\n\tstart->inDegree = 0;\n\tstart->visited = true;\n\n\tstd::vector<Node *> block;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tblock.push_back(v);\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e == v->in || e->t->solved) continue;\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->inDegree = 1;\n\t\t\t\te->t->in = e;\n\t\t\t\tq.push(e->t);\n\t\t\t} else e->t->inDegree++;\n\t\t}\n\t}\n\n\treturn block;\n}\n\ninline void toposort(std::vector<Node *> &v) {\n\tstd::queue<Node *> q;\n\tfor (size_t i = 0; i < v.size(); i++) {\n#ifdef DBG\n\t\tprintf(\"toposort(): inDegree[%lu] = %d\\n\", v[i] - N + 1, v[i]->inDegree);\n#endif\n\t\tif (v[i]->inDegree == 1) q.push(v[i]);\n\t\telse v[i]->inCircle = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tv->inCircle = false;\n#ifdef CHECK\n\t\tprintf(\"%lu\\n\", v - N);\n#endif\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->solved) continue;\n\t\t\tif (--e->t->inDegree == 1) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calcTree(std::vector<Node *> &v) {\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i]->visited = false;\n\t\tv[i]->inDegree = 0;\n\t\tv[i]->depth = 0;\n\t}\n\n\tstd::stack<Node *> s;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->depth = 1;\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t}\n\t\t\n\t\twhile (v->c && (v->c->t->inCircle || v->c->t->pushed || v->c->t->solved)) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\te->t->pushed = true;\n\t\t\te->t->parent = v;\n\t\t\ts.push(e->t);\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tv->len = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->inCircle || e->t->parent != v) continue;\n\n\t\t\t\tans = std::max(ans, v->len + e->t->len + e->w);\n\t\t\t\tv->len = std::max(v->len, e->t->len + e->w);\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\"calcTree(size = %lu) = %lld\\n\", v.size(), ans);\n#endif\n\treturn ans;\n}\n\ninline long long calcCircle(std::vector<Node *> &v) {\n\tNode *start;\n\tfor (size_t i = 0; i < v.size(); i++) v[i]->visited = false;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->visited = true;\n\t\t\tstart = v[i];\n\t\t\tbreak;\n\t\t}\n\t\tfor (Edge *e = v[i]->e; e; e = e->next) e->disabled = false;\n\t}\n\n\tstatic Node *c[MAXN];\n\tstatic long long s[MAXN];\n\tint cnt = 0;\n\tlong long sum = 0;\n\n#ifdef DBG\n\tfor (int i = 0; i < MAXN; i++) c[i] = NULL, s[i] = 0;\n#endif\n\n\tNode *u = start;\n\tc[cnt++] = u;\n\twhile (1) {\n\t\tNode *next = NULL;\n\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\tif (!e->t->visited && e->t->inCircle) {\n\t\t\t\tc[cnt] = e->t;\n\t\t\t\ts[cnt] = e->w;\n\t\t\t\tsum += e->w;\n\t\t\t\tcnt++;\n\t\t\t\te->t->visited = true;\n\t\t\t\te->r->disabled = true;\n\t\t\t\tnext = e->t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tu = next;\n\t\t} else {\n\t\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\t\tif (e->t == start) {\n\t\t\t\t\tsum += e->w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n == 0) return 0;\n\t/*\n\tif (cnt == 2) {\n\t\tlong long ans = c[0]->len + c[1]->len + std::max(s[1], sum - s[1]);\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", s[1], sum);\n\t\tprintf(\"calcCircle(size = 2) = %lld\\n\", ans);\n#endif\n\t\treturn ans;\n\t}\n\t*/\n\n\tfor (int i = 1; i < cnt; i++) s[i] += s[i - 1];\n\n\t// ans1 = f[a] + f[b] + s[a] - s[b]\n\t// ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b]\n\t// maintain the max of f[b] - s[b] and f[b] + s[b]\n\tlong long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans = std::max(ans, c[i]->len + s[i] + max1);\n\t\tans = std::max(ans, sum + c[i]->len - s[i] + max2);\n\n\t\tmax1 = std::max(max1, c[i]->len - s[i]);\n\t\tmax2 = std::max(max2, c[i]->len + s[i]);\n\n#ifdef DBG\n\t\tprintf(\"ans = %lld, max1 = %lld, max2 = %lld\\n\", ans, max1, max2);\n#endif\n\t}\n\n#ifdef DBG\n\tprintf(\"calcCircle(size = %lu, cnt = %d) = %lld\\n\", v.size(), cnt, ans);\n#endif\n\treturn ans;\n}\n\ninline long long solve() {\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].solved) continue;\n\n\t\tstd::vector<Node *> block = getBlock(&N[i]);\n\t\ttoposort(block);\n\n\t\tlong long tmp = calcTree(block);\n\t\ttmp = std::max(tmp, calcCircle(block));\n\t\tans += tmp;\n\n\t\tfor (size_t i = 0; i < block.size(); i++) block[i]->solved = true;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u, w;\n\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\taddEdge(i, u, w);\n\t}\n\n\tprintf(\"%lld\\n\", solve());\n\n#ifdef CHECK\n\tfor (int i = 0; i < n; i++) printf(\"f[%d] = %lld\\n\", i, N[i].len);\n#endif\n\n\treturn 0;\n}\n```\n","source":"_posts/ioi2008-island.md","raw":"title: IOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\n  - \n  - Tarjan\npermalink: ioi2008-island\ndate: 2016-10-24 21:39:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1791](http://www.lydsy.com/JudgeOnline/problem.php?id=1791)\n\n### \n\n\n $ f(i) $  $ i $  $ i $  $ j $$ f(i) = \\max\\{ f(j) + d(i, j) \\} $\n\n $ u $$ v $  $ f(u) + d(i, u) + f(v) + d(i, v) $ \n\n DP\n\n $ f'(i) $  $ i $  $ f $ $ s(i) $  $ i $ \n\n $ i $  $ i $  $ j $ $ i $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + s(i) - s(j) \\pod {i > j} \\\\\n= & f'(j) - s(j) + f'(i) + s(i)\n\\end{aligned}\n$$\n\n $ i $  $ j $$ S $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + S - (s(i) - s(j)) \\pod {i > j} \\\\\n= & f'(i) + f'(j) + S - s(i) + s(j) \\\\\n= & f'(j) + s(j) + S + f'(i) - s(i)\n\\end{aligned}\n$$\n\n $ f'(j) + s(j) + S $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tbool inCircle, solved, visited, pushed;\n\tint depth, inDegree;\n\tlong long len;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long w;\n\tEdge *next, *r;\n\tbool disabled;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nint n;\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline std::vector<Node *> getBlock(Node *start) {\n\tstd::queue<Node *> q;\n\tq.push(start);\n\tstart->inDegree = 0;\n\tstart->visited = true;\n\n\tstd::vector<Node *> block;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tblock.push_back(v);\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e == v->in || e->t->solved) continue;\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->inDegree = 1;\n\t\t\t\te->t->in = e;\n\t\t\t\tq.push(e->t);\n\t\t\t} else e->t->inDegree++;\n\t\t}\n\t}\n\n\treturn block;\n}\n\ninline void toposort(std::vector<Node *> &v) {\n\tstd::queue<Node *> q;\n\tfor (size_t i = 0; i < v.size(); i++) {\n#ifdef DBG\n\t\tprintf(\"toposort(): inDegree[%lu] = %d\\n\", v[i] - N + 1, v[i]->inDegree);\n#endif\n\t\tif (v[i]->inDegree == 1) q.push(v[i]);\n\t\telse v[i]->inCircle = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tv->inCircle = false;\n#ifdef CHECK\n\t\tprintf(\"%lu\\n\", v - N);\n#endif\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->solved) continue;\n\t\t\tif (--e->t->inDegree == 1) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calcTree(std::vector<Node *> &v) {\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i]->visited = false;\n\t\tv[i]->inDegree = 0;\n\t\tv[i]->depth = 0;\n\t}\n\n\tstd::stack<Node *> s;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->depth = 1;\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t}\n\t\t\n\t\twhile (v->c && (v->c->t->inCircle || v->c->t->pushed || v->c->t->solved)) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\te->t->pushed = true;\n\t\t\te->t->parent = v;\n\t\t\ts.push(e->t);\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tv->len = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->inCircle || e->t->parent != v) continue;\n\n\t\t\t\tans = std::max(ans, v->len + e->t->len + e->w);\n\t\t\t\tv->len = std::max(v->len, e->t->len + e->w);\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\"calcTree(size = %lu) = %lld\\n\", v.size(), ans);\n#endif\n\treturn ans;\n}\n\ninline long long calcCircle(std::vector<Node *> &v) {\n\tNode *start;\n\tfor (size_t i = 0; i < v.size(); i++) v[i]->visited = false;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->visited = true;\n\t\t\tstart = v[i];\n\t\t\tbreak;\n\t\t}\n\t\tfor (Edge *e = v[i]->e; e; e = e->next) e->disabled = false;\n\t}\n\n\tstatic Node *c[MAXN];\n\tstatic long long s[MAXN];\n\tint cnt = 0;\n\tlong long sum = 0;\n\n#ifdef DBG\n\tfor (int i = 0; i < MAXN; i++) c[i] = NULL, s[i] = 0;\n#endif\n\n\tNode *u = start;\n\tc[cnt++] = u;\n\twhile (1) {\n\t\tNode *next = NULL;\n\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\tif (!e->t->visited && e->t->inCircle) {\n\t\t\t\tc[cnt] = e->t;\n\t\t\t\ts[cnt] = e->w;\n\t\t\t\tsum += e->w;\n\t\t\t\tcnt++;\n\t\t\t\te->t->visited = true;\n\t\t\t\te->r->disabled = true;\n\t\t\t\tnext = e->t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tu = next;\n\t\t} else {\n\t\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\t\tif (e->t == start) {\n\t\t\t\t\tsum += e->w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n == 0) return 0;\n\t/*\n\tif (cnt == 2) {\n\t\tlong long ans = c[0]->len + c[1]->len + std::max(s[1], sum - s[1]);\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", s[1], sum);\n\t\tprintf(\"calcCircle(size = 2) = %lld\\n\", ans);\n#endif\n\t\treturn ans;\n\t}\n\t*/\n\n\tfor (int i = 1; i < cnt; i++) s[i] += s[i - 1];\n\n\t// ans1 = f[a] + f[b] + s[a] - s[b]\n\t// ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b]\n\t// maintain the max of f[b] - s[b] and f[b] + s[b]\n\tlong long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans = std::max(ans, c[i]->len + s[i] + max1);\n\t\tans = std::max(ans, sum + c[i]->len - s[i] + max2);\n\n\t\tmax1 = std::max(max1, c[i]->len - s[i]);\n\t\tmax2 = std::max(max2, c[i]->len + s[i]);\n\n#ifdef DBG\n\t\tprintf(\"ans = %lld, max1 = %lld, max2 = %lld\\n\", ans, max1, max2);\n#endif\n\t}\n\n#ifdef DBG\n\tprintf(\"calcCircle(size = %lu, cnt = %d) = %lld\\n\", v.size(), cnt, ans);\n#endif\n\treturn ans;\n}\n\ninline long long solve() {\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].solved) continue;\n\n\t\tstd::vector<Node *> block = getBlock(&N[i]);\n\t\ttoposort(block);\n\n\t\tlong long tmp = calcTree(block);\n\t\ttmp = std::max(tmp, calcCircle(block));\n\t\tans += tmp;\n\n\t\tfor (size_t i = 0; i < block.size(); i++) block[i]->solved = true;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u, w;\n\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\taddEdge(i, u, w);\n\t}\n\n\tprintf(\"%lld\\n\", solve());\n\n#ifdef CHECK\n\tfor (int i = 0; i < n; i++) printf(\"f[%d] = %lld\\n\", i, N[i].len);\n#endif\n\n\treturn 0;\n}\n```\n","slug":"ioi2008-island","published":1,"updated":"2016-10-25T13:32:29.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jigj00wg0jxldae5qjge"},{"title":"HNOI2016 -  + ","date":"2016-05-11T09:28:00.000Z","_content":"\n A  A  $ N $  $ 1,\\ 2,\\ \\dots,\\ N $ $ 1 $  A \n\n1. \n2.  345  $ M $ \n3.  $ a,\\ b $ $ 1 \\leq a \\leq N $$ 1 \\leq b \\leq $ \n4.  $ a $  $ b $  $ a $  $ b $ )\n5.  4  $ L $  $ a $  $ C $  $ C $  $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $ $ C $  $ C $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### \n\n\n $ k $ \n\n\n\n1. \n2. \n3.  2 \n\n $ O((m + q) \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-tree.md","raw":"title: HNOI2016 -  + \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - \n  - \n  - \npermalink: hnoi2016-tree\ndate: 2016-05-11 17:28:00\n---\n\n A  A  $ N $  $ 1,\\ 2,\\ \\dots,\\ N $ $ 1 $  A \n\n1. \n2.  345  $ M $ \n3.  $ a,\\ b $ $ 1 \\leq a \\leq N $$ 1 \\leq b \\leq $ \n4.  $ a $  $ b $  $ a $  $ b $ )\n5.  4  $ L $  $ a $  $ C $  $ C $  $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $ $ C $  $ C $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### \n\n\n $ k $ \n\n\n\n1. \n2. \n3.  2 \n\n $ O((m + q) \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-tree","published":1,"updated":"2016-09-10T05:51:35.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jigp00wo0jxl3fwewg3w"},{"title":"HNOI2016 -  + RMQ","date":"2016-04-30T13:23:18.000Z","_content":"\n $ n $ $ a_1,\\ a_2,\\ \\dots,\\ a_n $ $ a[1:n] $$ a[l:r] $$ 1 \\leq l \\leq r \\leq n $$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $ $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $ $ a[s:t] $  $ a[l:r] $ \n\n $ q $  $ l $  $ r $$ 1 \\leq l \\leq r \\leq n $ $ a[l:r] $ \n\n<!-- more -->\n\n### \n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### \n[Sengxian ](https://blog.sengxian.com/solutions/bzoj-4540)\n\n\n\n $ [i] $  $ i $  $ a_i $$ [ \\ [l,\\ r],\\ R \\ ] $  $ [l,\\ r] $ $ R $ \n\n $ [l,\\ r - 1] $  $ [r] $  $ r - l + 1 $  $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $\n\n$ [l, r] $  $ [m] $ $ [ \\ [l,\\ m],\\ r \\ ] $  $ [m] $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n $ [ \\ [1,\\ 4],\\ 6 \\ ] $  $ [4] $ $ 1 $\n\n $ r - m $  $ r $  $ [r] $ ****$ r $  $ [r] $ $ [r] $  $ [8] = 3 $ $ {\\rm left}(r) = p $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $  $ r - p = 10 - 8 = 2 $  $ [10] = 4 $ $ (r - p) \\times [r] $\n\n $ [p] = 3 $  $ [6] = 2 $ $ {\\rm left}(p) = p' = 6 $\n\n|  | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $  $ p - p' = 8 - 6 = 2 $  $ [8] = 3 $ $ (p - p') \\times [p] $\n\n $ p' $  $ 1 $ $ {\\rm left}(p') = m = 4 $ $ m $  $ p' - m = 6 - 4 = 2 $  $ [p'] = 2 $ $ (p' - m) \\times [p'] $\n\n $ O(n) $\n\n $ m = \\min[l,\\ r] $  $ [l,\\ r] $  $ f(l, r) $  $ [l,\\ r] $ \n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n $ m $  $ l $ \n\n $ s(i) $  $ i $ \n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n$ {\\rm left}(p') = {\\rm left}(m + 1) = m $********\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n $ {\\rm left}(i) $ $ O(n) $  $ s(i) $\n\n RMQ $ O(n \\log n) $  $ O(1) $  $ O(1) $ $ O(q \\log q + n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-sequence.md","raw":"title: HNOI2016 -  + RMQ\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - RMQ\npermalink: hnoi2016-sequence\ndate: 2016-04-30 21:23:18\n---\n\n $ n $ $ a_1,\\ a_2,\\ \\dots,\\ a_n $ $ a[1:n] $$ a[l:r] $$ 1 \\leq l \\leq r \\leq n $$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $ $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $ $ a[s:t] $  $ a[l:r] $ \n\n $ q $  $ l $  $ r $$ 1 \\leq l \\leq r \\leq n $ $ a[l:r] $ \n\n<!-- more -->\n\n### \n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### \n[Sengxian ](https://blog.sengxian.com/solutions/bzoj-4540)\n\n\n\n $ [i] $  $ i $  $ a_i $$ [ \\ [l,\\ r],\\ R \\ ] $  $ [l,\\ r] $ $ R $ \n\n $ [l,\\ r - 1] $  $ [r] $  $ r - l + 1 $  $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $\n\n$ [l, r] $  $ [m] $ $ [ \\ [l,\\ m],\\ r \\ ] $  $ [m] $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n $ [ \\ [1,\\ 4],\\ 6 \\ ] $  $ [4] $ $ 1 $\n\n $ r - m $  $ r $  $ [r] $ ****$ r $  $ [r] $ $ [r] $  $ [8] = 3 $ $ {\\rm left}(r) = p $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $  $ r - p = 10 - 8 = 2 $  $ [10] = 4 $ $ (r - p) \\times [r] $\n\n $ [p] = 3 $  $ [6] = 2 $ $ {\\rm left}(p) = p' = 6 $\n\n|  | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $  $ p - p' = 8 - 6 = 2 $  $ [8] = 3 $ $ (p - p') \\times [p] $\n\n $ p' $  $ 1 $ $ {\\rm left}(p') = m = 4 $ $ m $  $ p' - m = 6 - 4 = 2 $  $ [p'] = 2 $ $ (p' - m) \\times [p'] $\n\n $ O(n) $\n\n $ m = \\min[l,\\ r] $  $ [l,\\ r] $  $ f(l, r) $  $ [l,\\ r] $ \n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n $ m $  $ l $ \n\n $ s(i) $  $ i $ \n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n$ {\\rm left}(p') = {\\rm left}(m + 1) = m $********\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n $ {\\rm left}(i) $ $ O(n) $  $ s(i) $\n\n RMQ $ O(n \\log n) $  $ O(1) $  $ O(1) $ $ O(q \\log q + n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-sequence","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jigw00wx0jxl452lpeuc"},{"title":"HNOI2016 -  + DFS ","date":"2016-05-11T09:08:00.000Z","_content":"\n\n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### \n DFS  DFS  $ O(\\log n) $ \n\n******** DFS  $ O(\\log n) $  $ O(\\log n) $ \n\n\n\n $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","source":"_posts/hnoi2016-network.md","raw":"title: HNOI2016 -  + DFS \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - \n  - DFS \npermalink: hnoi2016-network\ndate: 2016-05-11 17:08:00\n---\n\n\n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### \n DFS  DFS  $ O(\\log n) $ \n\n******** DFS  $ O(\\log n) $  $ O(\\log n) $ \n\n\n\n $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","slug":"hnoi2016-network","published":1,"updated":"2016-05-11T09:39:49.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jih100x30jxlxbbqo6lf"},{"title":"HNOI2016 -  + ","date":"2016-05-11T08:39:00.000Z","_content":"\n $ N $  $ M $  $ 1,\\ 2,\\ \\dots,\\ n $ $ 2 ^ a 3 ^ b $  $ q $  $ u $$ v $$ a $  $ b $ $ u $  $ v $  $ 2 ^ a 3 ^ b $\n\n<!-- more -->\n\n### \n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### \n******** $ 2 $  $ 3 $  $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $  $ 2 $  $ 3 $  $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $\n\n $ a $  $ b $ \n\n $ a $  $ b $  $ a $  $ b $  $ O(qm \\  \\alpha(m)) $\n\n $ a $  $ a $  $ b $ \n\n $ a $  $ T $  $ a $  $ a $ $ b $  $ a $  $ b $ ****\n\n********\n\n $ O(\\frac{n}{T}) $  $ O(\\frac{n}{T}) $  $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $ $ T $  $ 1 $  $ O(T m \\log m + q \\log q) $ $ T = \\sqrt m $ $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-multiple.md","raw":"title: HNOI2016 -  + \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - CodeVS\n  - HNOI\n  - \n  - \npermalink: hnoi2016-multiple\ndate: 2016-05-11 16:39:00\n---\n\n $ N $  $ M $  $ 1,\\ 2,\\ \\dots,\\ n $ $ 2 ^ a 3 ^ b $  $ q $  $ u $$ v $$ a $  $ b $ $ u $  $ v $  $ 2 ^ a 3 ^ b $\n\n<!-- more -->\n\n### \n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### \n******** $ 2 $  $ 3 $  $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $  $ 2 $  $ 3 $  $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $\n\n $ a $  $ b $ \n\n $ a $  $ b $  $ a $  $ b $  $ O(qm \\  \\alpha(m)) $\n\n $ a $  $ a $  $ b $ \n\n $ a $  $ T $  $ a $  $ a $ $ b $  $ a $  $ b $ ****\n\n********\n\n $ O(\\frac{n}{T}) $  $ O(\\frac{n}{T}) $  $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $ $ T $  $ 1 $  $ O(T m \\log m + q \\log q) $ $ T = \\sqrt m $ $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-multiple","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jih700xb0jxl4wjltdvj"},{"title":"HNOI2012 - ","date":"2016-09-07T23:52:00.000Z","_content":"\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2730](http://www.lydsy.com/JudgeOnline/problem.php?id=2730)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// if (v->flag) printf(\"!!!: %lu\\n\", v - N + 1);\n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n\ninline void solve(int &min, long long &cnt) {\n\tmin = 0, cnt = 1;\n\tfor (int i = 0; i < n; i++) N[i].v = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v || N[i].flag) continue;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].v = true;\n\n\t\tstd::tr1::unordered_set<unsigned long> s;\n\t\tint size = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tsize++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->flag) s.insert(e->t - N);\n\t\t\t\telse if (!e->t->v) q.push(e->t), e->t->v = true;\n\t\t\t}\n\t\t}\n\n\t\tif (s.size() == 1) min++, cnt *= size;\n\t}\n\n\tif (!min) min = 2, cnt = n * (n - 1) / 2;\n}\n\nint main() {\n\tfor (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n\t\tn = 0;\n\t\twhile (m--) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tn = std::max(n, std::max(u, v));\n\t\t\tu--, v--;\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\ttarjan();\n\n\t\tint min;\n\t\tlong long cnt;\n\t\tsolve(min, cnt);\n\t\tprintf(\"Case %d: %d %lld\\n\", i, min, cnt);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].v = N[i].pushed = N[i].flag = false;\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].p = NULL;\n\t\t\tEdge *next;\n\t\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2012-mine.md","raw":"title: HNOI2012 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Tarjan\n  - \n  - \npermalink: hnoi2012-mine\ndate: 2016-09-08 07:52:00\n---\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2730](http://www.lydsy.com/JudgeOnline/problem.php?id=2730)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// if (v->flag) printf(\"!!!: %lu\\n\", v - N + 1);\n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n\ninline void solve(int &min, long long &cnt) {\n\tmin = 0, cnt = 1;\n\tfor (int i = 0; i < n; i++) N[i].v = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v || N[i].flag) continue;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].v = true;\n\n\t\tstd::tr1::unordered_set<unsigned long> s;\n\t\tint size = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tsize++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->flag) s.insert(e->t - N);\n\t\t\t\telse if (!e->t->v) q.push(e->t), e->t->v = true;\n\t\t\t}\n\t\t}\n\n\t\tif (s.size() == 1) min++, cnt *= size;\n\t}\n\n\tif (!min) min = 2, cnt = n * (n - 1) / 2;\n}\n\nint main() {\n\tfor (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n\t\tn = 0;\n\t\twhile (m--) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tn = std::max(n, std::max(u, v));\n\t\t\tu--, v--;\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\ttarjan();\n\n\t\tint min;\n\t\tlong long cnt;\n\t\tsolve(min, cnt);\n\t\tprintf(\"Case %d: %d %lld\\n\", i, min, cnt);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].v = N[i].pushed = N[i].flag = false;\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].p = NULL;\n\t\t\tEdge *next;\n\t\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","slug":"hnoi2012-mine","published":1,"updated":"2016-09-07T23:53:21.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jihd00xj0jxlz6mr3pkn"},{"title":"HNOI2010 -  DP","date":"2016-07-06T04:08:00.000Z","_content":"\n\n\n1. \n2. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1996](http://www.lydsy.com/JudgeOnline/problem.php?id=1996)\n\n### \n\n\n $ [l, r] $  $ A $  $ A $  $ [l, r - 1] $  $ [l, r - 1] $  $ A $ \n\n $ f(l, r, flag) $  $ [l, r] $  $ flag $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MOD = 19650827;\n\nconst int DP_L = 0;\nconst int DP_R = 1;\nconst int DP_LR = 2;\n\nint n, a[MAXN];\n\ninline int dp(const int l, const int r, const int flag) {\n\tstatic int mem[MAXN][MAXN][3];\n\tstatic bool calced[MAXN][MAXN][3];\n\tint &ans = mem[l][r][flag];\n\tif (calced[l][r][flag]) return ans;\n\tcalced[l][r][flag] = true;\n\n\tif (r - l + 1 == 2) {\n\t\tif (a[l] > a[r]) return ans = 0;\n\t\telse if (flag == DP_LR) return ans = 2;\n\t\telse return ans = 1;\n\t}\n\n\tif (flag != DP_L) {\n\t\tconst int L = l, R = r - 1;\n\t\tif (a[r] > a[L] && a[r] > a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[r] > a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[r] > a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\tif (flag != DP_R) {\n\t\tconst int L = l + 1, R = r;\n\t\tif (a[l] < a[L] && a[l] < a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[l] < a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[l] < a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\treturn ans %= MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", dp(0, n - 1, DP_LR));\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2010-chorus.md","raw":"title: HNOI2010 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - DP\n  -  DP\npermalink: hnoi2010-chorus\ndate: 2016-07-06 12:08:00\n---\n\n\n\n1. \n2. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1996](http://www.lydsy.com/JudgeOnline/problem.php?id=1996)\n\n### \n\n\n $ [l, r] $  $ A $  $ A $  $ [l, r - 1] $  $ [l, r - 1] $  $ A $ \n\n $ f(l, r, flag) $  $ [l, r] $  $ flag $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MOD = 19650827;\n\nconst int DP_L = 0;\nconst int DP_R = 1;\nconst int DP_LR = 2;\n\nint n, a[MAXN];\n\ninline int dp(const int l, const int r, const int flag) {\n\tstatic int mem[MAXN][MAXN][3];\n\tstatic bool calced[MAXN][MAXN][3];\n\tint &ans = mem[l][r][flag];\n\tif (calced[l][r][flag]) return ans;\n\tcalced[l][r][flag] = true;\n\n\tif (r - l + 1 == 2) {\n\t\tif (a[l] > a[r]) return ans = 0;\n\t\telse if (flag == DP_LR) return ans = 2;\n\t\telse return ans = 1;\n\t}\n\n\tif (flag != DP_L) {\n\t\tconst int L = l, R = r - 1;\n\t\tif (a[r] > a[L] && a[r] > a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[r] > a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[r] > a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\tif (flag != DP_R) {\n\t\tconst int L = l + 1, R = r;\n\t\tif (a[l] < a[L] && a[l] < a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[l] < a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[l] < a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\treturn ans %= MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", dp(0, n - 1, DP_LR));\n\n\treturn 0;\n}\n```\n","slug":"hnoi2010-chorus","published":1,"updated":"2016-10-24T23:36:49.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jihi00xq0jxl07wax2lb"},{"title":"HNOI2008 - Prfer ","date":"2016-10-11T10:51:00.000Z","_content":"\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005)\n\n### \nPrufer \n\n>  $ n $  Prufer  $ n - 2 $ $ -1 $  Prufer \n\n $ k $ $ d_i $  $ i $ $ s = \\sum\\limits_{d_i \\neq -1} d_i - 1 $ $ s $ \n\n Prufer \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} $$\n\n $ n - k $  $ n - 2 - s $ \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} $$\n\n\n\n$$\n\\begin{aligned}\n&= \\frac{(n - 2)!}{s!(n - 2 - s)!} \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} \\\\\n&= \\frac{(n - 2)! (n - k) ^ {n - 2 - s}}{(n - 2 - s)! \\prod\\limits_{i = 1} ^ k (d_i - 1) !}\n\\end{aligned}\n$$\n\n### \n```java\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint d[] = new int[n], s = 0, k = 0;\n\t\tboolean invalid = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t\tif (d[i] != -1) {\n\t\t\t\tk++;\n\t\t\t\tif (d[i] <= 0 || d[i] >= n + 1) invalid = true;\n\t\t\t\ts += d[i] - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tif (d[0] == 0 || d[0] == -1) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (n == 2) {\n\t\t\tif ((d[0] == 1 || d[0] == -1) && (d[1] == 1 || d[1] == -1)) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (invalid) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tBigInteger fac[] = new BigInteger[n - 1];\n\t\t\tfac[0] = BigInteger.ONE;\n\t\t\tfor (int i = 1; i <= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i));\n\n\t\t\tBigInteger ans = BigInteger.ONE;\n\t\t\tans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]);\n\t\t\tfor (int i = 0; i < n; i++) if (d[i] > 1) ans = ans.divide(fac[d[i] - 1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n```\n","source":"_posts/hnoi2008-tree.md","raw":"title: HNOI2008 - Prfer \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Prfer \n  - \n  - \npermalink: hnoi2008-tree\ndate: 2016-10-11 18:51:00\n---\n\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005)\n\n### \nPrufer \n\n>  $ n $  Prufer  $ n - 2 $ $ -1 $  Prufer \n\n $ k $ $ d_i $  $ i $ $ s = \\sum\\limits_{d_i \\neq -1} d_i - 1 $ $ s $ \n\n Prufer \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} $$\n\n $ n - k $  $ n - 2 - s $ \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} $$\n\n\n\n$$\n\\begin{aligned}\n&= \\frac{(n - 2)!}{s!(n - 2 - s)!} \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} \\\\\n&= \\frac{(n - 2)! (n - k) ^ {n - 2 - s}}{(n - 2 - s)! \\prod\\limits_{i = 1} ^ k (d_i - 1) !}\n\\end{aligned}\n$$\n\n### \n```java\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint d[] = new int[n], s = 0, k = 0;\n\t\tboolean invalid = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t\tif (d[i] != -1) {\n\t\t\t\tk++;\n\t\t\t\tif (d[i] <= 0 || d[i] >= n + 1) invalid = true;\n\t\t\t\ts += d[i] - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tif (d[0] == 0 || d[0] == -1) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (n == 2) {\n\t\t\tif ((d[0] == 1 || d[0] == -1) && (d[1] == 1 || d[1] == -1)) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (invalid) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tBigInteger fac[] = new BigInteger[n - 1];\n\t\t\tfac[0] = BigInteger.ONE;\n\t\t\tfor (int i = 1; i <= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i));\n\n\t\t\tBigInteger ans = BigInteger.ONE;\n\t\t\tans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]);\n\t\t\tfor (int i = 0; i < n; i++) if (d[i] > 1) ans = ans.divide(fac[d[i] - 1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n```\n","slug":"hnoi2008-tree","published":1,"updated":"2016-10-17T03:06:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jihp00xw0jxlwc4w8tcf"},{"title":"HNOI2008 -  DP","date":"2016-04-24T03:23:41.000Z","_content":"\nP  $ 1 $ ~ $ N $  $ N $  $ i $  $ C_i $P  $ i $  $ j $  $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $ $ x $ $ (x - L) ^ 2 $ $ L $ P \n $ L $\n\n<!-- more -->\n\n### \n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### \n $ f[i] $  i  $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $\n\n $ j $ $ j + 1 $ ~ $ i $  $ i - j - 1 + s(i) - s(j) $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n $ O(n ^ 2) $\n\n $ g(i) = s(i) + i - L - 1 $$ h(j) = s(j) + j $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n $ j = a $  $ j = b $$ a > b $ a  b \n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n $ O(1) $ $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2008-toy.md","raw":"title: HNOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - COGS\n  - HNOI\n  - \n  - \n  - DP\npermalink: hnoi2008-toy\ndate: 2016-04-24 11:23:41\n---\n\nP  $ 1 $ ~ $ N $  $ N $  $ i $  $ C_i $P  $ i $  $ j $  $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $ $ x $ $ (x - L) ^ 2 $ $ L $ P \n $ L $\n\n<!-- more -->\n\n### \n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### \n $ f[i] $  i  $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $\n\n $ j $ $ j + 1 $ ~ $ i $  $ i - j - 1 + s(i) - s(j) $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n $ O(n ^ 2) $\n\n $ g(i) = s(i) + i - L - 1 $$ h(j) = s(j) + j $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n $ j = a $  $ j = b $$ a > b $ a  b \n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n $ O(1) $ $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"hnoi2008-toy","published":1,"updated":"2016-10-24T23:36:27.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jihw00y40jxlric3k8wm"},{"title":"HNOI2008 - ","date":"2016-10-17T03:07:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006)\n\n### \nMCS********\n\n\n\n1. \n2.  $ +1 $\n3. \n4.  (2)\n\n $ O(n ^ 2 + m) $  $ O(n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <set>\n#include <list>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nstruct Node {\n\tstruct Edge *e;\n\tint d, color;\n\tbool visited;\n\tstd::list<Node *>::iterator iterator;\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, m;\n\ninline void mcs() {\n\tstatic std::list<Node *> lists[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tN[i].d = 0;\n\t\tN[i].visited = false;\n\t\tlists[0].push_front(&N[i]);\n\t\tN[i].iterator = lists[0].begin();\n\t}\n\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (lists[max].empty()) max--;\n\t\tNode *v = lists[max].front();\n\t\tlists[max].pop_front();\n\t\tseq[i] = v;\n\t\t// printf(\"%lu\\n\", seq[i] - N + 1);\n\t\tv->visited = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\tlists[e->t->d].erase(e->t->iterator);\n\t\t\t\te->t->d++;\n\t\t\t\tlists[e->t->d].push_front(e->t);\n\t\t\t\te->t->iterator = lists[e->t->d].begin();\n\t\t\t\tmax = std::max(max, e->t->d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tmcs();\n\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tstd::set<int> s;\n\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\tif (e->t->color) s.insert(e->t->color);\n\t\t}\n\t\ts.insert(INT_MAX);\n\n\t\tint last = 0;\n\t\tfor (std::set<int>::const_iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tif (last + 1 != *it) {\n\t\t\t\tseq[i]->color = last + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = *it;\n\t\t}\n\n\t\tans = std::max(ans, seq[i]->color);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-kingdom.md","raw":"title: HNOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - \npermalink: hnoi2008-kingdom\ndate: 2016-10-17 11:07:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006)\n\n### \nMCS********\n\n\n\n1. \n2.  $ +1 $\n3. \n4.  (2)\n\n $ O(n ^ 2 + m) $  $ O(n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <set>\n#include <list>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nstruct Node {\n\tstruct Edge *e;\n\tint d, color;\n\tbool visited;\n\tstd::list<Node *>::iterator iterator;\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, m;\n\ninline void mcs() {\n\tstatic std::list<Node *> lists[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tN[i].d = 0;\n\t\tN[i].visited = false;\n\t\tlists[0].push_front(&N[i]);\n\t\tN[i].iterator = lists[0].begin();\n\t}\n\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (lists[max].empty()) max--;\n\t\tNode *v = lists[max].front();\n\t\tlists[max].pop_front();\n\t\tseq[i] = v;\n\t\t// printf(\"%lu\\n\", seq[i] - N + 1);\n\t\tv->visited = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\tlists[e->t->d].erase(e->t->iterator);\n\t\t\t\te->t->d++;\n\t\t\t\tlists[e->t->d].push_front(e->t);\n\t\t\t\te->t->iterator = lists[e->t->d].begin();\n\t\t\t\tmax = std::max(max, e->t->d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tmcs();\n\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tstd::set<int> s;\n\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\tif (e->t->color) s.insert(e->t->color);\n\t\t}\n\t\ts.insert(INT_MAX);\n\n\t\tint last = 0;\n\t\tfor (std::set<int>::const_iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tif (last + 1 != *it) {\n\t\t\t\tseq[i]->color = last + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = *it;\n\t\t}\n\n\t\tans = std::max(ans, seq[i]->color);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"hnoi2008-kingdom","published":1,"updated":"2016-10-17T09:25:23.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jii200yd0jxlf4yqvkk0"},{"title":"HNOI2008GT - KMP + ","date":"2016-10-07T22:43:00.000Z","_content":"\n $ m $  $ T $ $ n $  $ T $ \n\n<!-- more -->\n\n### \n[BZOJ 1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009)\n\n### \n $ T $  KMP  $ f(i, j) $  $ i $  $ T $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e9;\nconst int MAXM = 20;\nconst int MAXK = 1000;\n\nstruct Matrix {\n\tint a[MAXM][MAXM];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i < MAXM; i++) a[i][i] = 1;\n\t\t}\n\t}\n\n\tint &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\n\tconst int &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\n\nint mod;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) for (int k = 0; k < MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tchar s[MAXM + 2];\n\tscanf(\"%d %d %d\\n%s\", &n, &m, &mod, s + 1);\n\n\tint fail[MAXM + 1];\n\tfail[0] = fail[1] = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\tint k = fail[i - 1];\n\t\twhile (k && s[k + 1] != s[i]) k = fail[k];\n\t\tif (s[k + 1] == s[i]) fail[i] = k + 1;\n\t\telse fail[i] = 0;\n\t}\n\n\t// for (int i = 0; i <= m; i++) printf(\"%d%c\", fail[i], i == m ? '\\n' : ' ');\n\n\t/*\n\tint f[50][MAXM + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\t\tint k = j;\n\t\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\t\tif (s[k + 1] == c) k++;\n\n\t\t\t\tf[i + 1][k] += f[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tint k = i;\n\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\tif (s[k + 1] == c) k++;\n\t\t\tif (k < m) shift(i, k)++;\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\tMatrix res = init * pow(shift, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res(0, i)) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\t// for (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) printf(\"%d%c\", res(i, j), j == MAXM - 1 ? '\\n' : ' ');\n\n\t/*\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\t*/\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-gt.md","raw":"title: HNOI2008GT - KMP + \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - DP\n  - KMP\n  - \n  - \n  - \npermalink: hnoi2008-gt\ndate: 2016-10-08 06:43:00\n---\n\n $ m $  $ T $ $ n $  $ T $ \n\n<!-- more -->\n\n### \n[BZOJ 1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009)\n\n### \n $ T $  KMP  $ f(i, j) $  $ i $  $ T $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e9;\nconst int MAXM = 20;\nconst int MAXK = 1000;\n\nstruct Matrix {\n\tint a[MAXM][MAXM];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i < MAXM; i++) a[i][i] = 1;\n\t\t}\n\t}\n\n\tint &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\n\tconst int &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\n\nint mod;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) for (int k = 0; k < MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tchar s[MAXM + 2];\n\tscanf(\"%d %d %d\\n%s\", &n, &m, &mod, s + 1);\n\n\tint fail[MAXM + 1];\n\tfail[0] = fail[1] = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\tint k = fail[i - 1];\n\t\twhile (k && s[k + 1] != s[i]) k = fail[k];\n\t\tif (s[k + 1] == s[i]) fail[i] = k + 1;\n\t\telse fail[i] = 0;\n\t}\n\n\t// for (int i = 0; i <= m; i++) printf(\"%d%c\", fail[i], i == m ? '\\n' : ' ');\n\n\t/*\n\tint f[50][MAXM + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\t\tint k = j;\n\t\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\t\tif (s[k + 1] == c) k++;\n\n\t\t\t\tf[i + 1][k] += f[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tint k = i;\n\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\tif (s[k + 1] == c) k++;\n\t\t\tif (k < m) shift(i, k)++;\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\tMatrix res = init * pow(shift, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res(0, i)) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\t// for (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) printf(\"%d%c\", res(i, j), j == MAXM - 1 ? '\\n' : ' ');\n\n\t/*\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\t*/\n\n\treturn 0;\n}\n```","slug":"hnoi2008-gt","published":1,"updated":"2016-10-07T22:52:45.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jii800yl0jxl713qdc6s"},{"title":"HNOI2008Cards - Burnside ","date":"2016-10-17T02:57:00.000Z","_content":"\n $ n $ 3  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004)\n\n### \nBurnside   \n\n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXX = 20;\nconst int MAXN = 60;\nconst int MAXM = 60;\n\nint a, b, c, n, mod;\n\ninline int calc(const int *map) {\n\tbool flag[MAXM] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = 0;\n\t\tfor (int t = i; !flag[t]; t = map[t]) {\n\t\t\tflag[t] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAXX + 1][MAXX + 1][MAXX + 1];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"calc() = %d\\n\", f[a][b][c]);\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int x) {\n\tint tmp1, tmp2, res;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint map[MAXN];\n\t\tfor (int j = 0; j < n; j++) scanf(\"%d\", &map[j]), map[j]--;\n\t\t(sum += calc(map)) %= mod;\n\t}\n\n\tint map[MAXN];\n\tfor (int i = 0; i < n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-cards.md","raw":"title: HNOI2008Cards - Burnside \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Burnside \n  - \n  - \npermalink: hnoi2008-cards\ndate: 2016-10-17 10:57:00\n---\n\n $ n $ 3  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004)\n\n### \nBurnside   \n\n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXX = 20;\nconst int MAXN = 60;\nconst int MAXM = 60;\n\nint a, b, c, n, mod;\n\ninline int calc(const int *map) {\n\tbool flag[MAXM] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = 0;\n\t\tfor (int t = i; !flag[t]; t = map[t]) {\n\t\t\tflag[t] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAXX + 1][MAXX + 1][MAXX + 1];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"calc() = %d\\n\", f[a][b][c]);\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int x) {\n\tint tmp1, tmp2, res;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint map[MAXN];\n\t\tfor (int j = 0; j < n; j++) scanf(\"%d\", &map[j]), map[j]--;\n\t\t(sum += calc(map)) %= mod;\n\t}\n\n\tint map[MAXN];\n\tfor (int i = 0; i < n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"hnoi2008-cards","published":1,"updated":"2016-10-17T03:03:37.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiif00yu0jxliqykk6jq"},{"title":"HNOI2004 - set","id":"5","updated":"2016-01-19T13:08:01.000Z","date":"2015-12-15T21:14:20.000Z","_content":"\n `N`<= 80000 `a`\n\n<!-- more -->\n\n### \n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### \n$O({\\log} n)$ STL  set\n\n set set  `lower_bound` ********\n\n### \n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2004-pet.md","raw":"title: HNOI2004 - set\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - HNOI\n  - set\n  - STL\npermalink: hnoi2004-pet\nid: 5\nupdated: '2016-01-19 21:08:01'\ndate: 2015-12-16 05:14:20\n---\n\n `N`<= 80000 `a`\n\n<!-- more -->\n\n### \n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### \n$O({\\log} n)$ STL  set\n\n set set  `lower_bound` ********\n\n### \n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"hnoi2004-pet","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiim00z20jxldskk9l7j"},{"title":"HNOI2004L - Trie","date":"2016-09-12T23:40:00.000Z","_content":"\n $ T $  $ D $  $ T $  $ D $ \n\n $ D $ $ D $  $ D $ \n\n<!-- more -->\n\n### \n[BZOJ 1212](http://www.lydsy.com/JudgeOnline/problem.php?id=1212)\n\n### \n $ f_i $  $ i $  $ f_{i - 1} $  $ m $  $ i $  $ f_{i + m - 1} $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1024 * 1024;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAT = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE]; //, *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\t/*\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a';\n\t\tt.insert(s, s + len);\n\t}\n\n\t// t.build();\n\n\twhile (m--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tstatic bool _f[MAXN + 1], *f = _f + 1;\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a', f[i] = false;\n\t\tint ans = -1;\n\t\tf[-1] = true;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!f[i - 1]) continue;\n\t\t\tTrie::Node *v = t.root;\n\t\t\tfor (int j = i; j < len; j++) {\n\t\t\t\t// while (v != t.root && !v->c[s[j]]) v = v->fail;\n\t\t\t\tif (!v->c[s[j]]) break;\n\t\t\t\tv = v->c[s[j]];\n\t\t\t\tif (v->isWord) f[j] = true, ans = std::max(ans, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans + 1);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2004-language.md","raw":"title: HNOI2004L - Trie\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - Trie\npermalink: hnoi2004-language\ndate: 2016-09-13 07:40:00\n---\n\n $ T $  $ D $  $ T $  $ D $ \n\n $ D $ $ D $  $ D $ \n\n<!-- more -->\n\n### \n[BZOJ 1212](http://www.lydsy.com/JudgeOnline/problem.php?id=1212)\n\n### \n $ f_i $  $ i $  $ f_{i - 1} $  $ m $  $ i $  $ f_{i + m - 1} $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1024 * 1024;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAT = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE]; //, *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\t/*\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a';\n\t\tt.insert(s, s + len);\n\t}\n\n\t// t.build();\n\n\twhile (m--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tstatic bool _f[MAXN + 1], *f = _f + 1;\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a', f[i] = false;\n\t\tint ans = -1;\n\t\tf[-1] = true;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!f[i - 1]) continue;\n\t\t\tTrie::Node *v = t.root;\n\t\t\tfor (int j = i; j < len; j++) {\n\t\t\t\t// while (v != t.root && !v->c[s[j]]) v = v->fail;\n\t\t\t\tif (!v->c[s[j]]) break;\n\t\t\t\tv = v->c[s[j]];\n\t\t\t\tif (v->isWord) f[j] = true, ans = std::max(ans, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans + 1);\n\t}\n\n\treturn 0;\n}\n```","slug":"hnoi2004-language","published":1,"updated":"2016-09-12T23:45:11.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiir00z90jxl9v8t7bd3"},{"title":"HEOI2013Eden  -  DP","date":"2016-07-11T15:10:00.000Z","_content":"\n $ n $  $ m $  $ m $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3163](http://www.lydsy.com/JudgeOnline/problem.php?id=3163)\n\n### \n $ f(i, j) $  $ i $ **** $ j $  $ g(i, j) $  $ i $ **** $ j $ \n\n $ a $  $ m $\n\n$$\n\\max\\limits_{i = 0} ^ {m} \\{ f(a - 1, i) + g(a + 1, m - i) \\}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\nconst int MAXLOGN = 10;\nconst int MAXQ = 300000;\n\nint main() {\n\tint n;\n\tstatic int w[MAXN], v[MAXN], cnt[MAXN];\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &w[i], &v[i], &cnt[i]);\n\n\tstatic std::pair<int, int> r[MAXN];\n\tstatic int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN];\n\tint N = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i].first = N + 1;\n\t\tfor (int j = 1; j <= cnt[i]; cnt[i] -= j, j *= 2) {\n\t\t// for (int j = 1; cnt[i]; cnt[i]--) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * j;\n\t\t\tV[N] = v[i] * j;\n\t\t}\n\t\tif (cnt[i]) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * cnt[i];\n\t\t\tV[N] = v[i] * cnt[i];\n\t\t}\n\t\tr[i].second = N;\n\t}\n\n\tstatic int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1];\n\t// for (int i = 0; i <= N; i++) f[i][0] = 1;\n\t// for (int i = 1; i <= N + 1; i++) g[i][0] = 1;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) g[i][j] = g[i + 1][j];\n\t\t\telse g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint id, m;\n\t\tscanf(\"%d %d\", &id, &m);\n\n\t\tint ans = 0, a = r[id].first - 1, b = r[id].second + 1;\n\t\tfor (int j = 0; j <= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/heoi2013-bag.md","raw":"title: HEOI2013Eden  -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HEOI\n  - DP\n  -  DP\npermalink: heoi2013-bag\ndate: 2016-07-11 23:10:00\n---\n\n $ n $  $ m $  $ m $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3163](http://www.lydsy.com/JudgeOnline/problem.php?id=3163)\n\n### \n $ f(i, j) $  $ i $ **** $ j $  $ g(i, j) $  $ i $ **** $ j $ \n\n $ a $  $ m $\n\n$$\n\\max\\limits_{i = 0} ^ {m} \\{ f(a - 1, i) + g(a + 1, m - i) \\}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\nconst int MAXLOGN = 10;\nconst int MAXQ = 300000;\n\nint main() {\n\tint n;\n\tstatic int w[MAXN], v[MAXN], cnt[MAXN];\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &w[i], &v[i], &cnt[i]);\n\n\tstatic std::pair<int, int> r[MAXN];\n\tstatic int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN];\n\tint N = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i].first = N + 1;\n\t\tfor (int j = 1; j <= cnt[i]; cnt[i] -= j, j *= 2) {\n\t\t// for (int j = 1; cnt[i]; cnt[i]--) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * j;\n\t\t\tV[N] = v[i] * j;\n\t\t}\n\t\tif (cnt[i]) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * cnt[i];\n\t\t\tV[N] = v[i] * cnt[i];\n\t\t}\n\t\tr[i].second = N;\n\t}\n\n\tstatic int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1];\n\t// for (int i = 0; i <= N; i++) f[i][0] = 1;\n\t// for (int i = 1; i <= N + 1; i++) g[i][0] = 1;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) g[i][j] = g[i + 1][j];\n\t\t\telse g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint id, m;\n\t\tscanf(\"%d %d\", &id, &m);\n\n\t\tint ans = 0, a = r[id].first - 1, b = r[id].second + 1;\n\t\tfor (int j = 0; j <= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"heoi2013-bag","published":1,"updated":"2016-10-24T23:36:40.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiix00zg0jxlq7bo5lpd"},{"title":"HDU 5906Square Revolution -  +  + ","date":"2016-09-30T10:00:00.000Z","_content":"\n $ S $ prefix-suffix-square free \n\n square `abab``aa`  square `aaa``abba`  prefix-suffix-square free  square\n\n<!-- more -->\n\n### \n[HDU 5906](http://acm.hdu.edu.cn/showproblem.php?pid=5906)\n\n### \n square $ i $  $ i $  square  $ f(i) $ $ i $  $ g(i) $ $ i $ $ j \\in [i, i + f(i) - 2] $  $ i \\geq g(j) $  $ j $ \n\n squareNOI2016  $ k $ $ k $  $ 2k $  square  $ [l, r] $ square $ [L, R] $  $ 2k $  square $ 2k $  $ f(i), i \\in[L, R] $\n\n $ k $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\tinline void build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tinline int rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n\n\tinline int lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint n, forward[MAXN], backward[MAXN];\n\ninline int lcp(const int i, const int j) { return sa1.lcp(i, j); }\ninline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); }\n\ninline void prepare(const int n) {\n\t/*\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int l, const int r, const int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) this->val = std::min(this->val, x);\n\t\t\telse lc->update(l, r, x), rc->update(l, r, x);\n\t\t}\n\n\t\tint query(const int pos) {\n\t\t\treturn (l == r) ? val : std::min(val, ((pos <= mid) ? lc : rc)->query(pos));\n\t\t}\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t\t}\n\t\t}\n\t} *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1);\n\t*/\n\n\tstatic struct UnionFindSet {\n\t\tint a[MAXN], n;\n\n\t\tvoid init(const int n) {\n\t\t\tthis->n = n;\n\t\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t\t}\n\n\t\tint find(const int x) {\n\t\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t\t}\n\n\t\tvoid merge(const int child, const int parent) {\n#ifdef DBG\n\t\t\tprintf(\"merge: %d => %d\\n\", child, parent);\n#endif\n\t\t\tconst int _child = find(child), _parent = find(parent);\n\t\t\ta[_child] = _parent;\n\t\t}\n\n\t\tvoid cover(const int l, const int r, const int x, int *val) {\n#ifdef DBG\n\t\t\tprintf(\"cover(%d, %d, %d)\\n\", l, r, x);\n#endif\n\t\t\tfor (int i = find(l); i <= r; i = find(i + 1)) {\n\t\t\t\tval[i] = std::min(val[i], x);\n\t\t\t\tif (i != n - 1) merge(i, i + 1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t} sForawrd, sBackward;\n\n\tsForawrd.init(n);\n\tsBackward.init(n);\n\n\tfor (int i = 0; i < n; i++) forward[i] = backward[i] = INT_MAX;\n\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i + len < n; i += len) {\n\t\t\tconst int j = i + len;\n\t\t\tconst int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1;\n\t\t\t// const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1;\n#ifdef DBG\n\t\t\tprintf(\"s = %d, len = %d\\n\", s, len);\n#endif\n\t\t\tif (s >= len) {\n#ifdef DBG\n\t\t\t\tprintf(\"!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\\n\", i, j, a, b, len);\n#endif\n\t\t\t\tconst int l = i - a + 1, r = j + b - 1;\n\t\t\t\tsForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward);\n\t\t\t\tsBackward.cover(l + len * 2 - 1, r, len * 2, backward);\n\t\t\t\t// sForawrd->update(l, l + (r - (l + len * 2 - 1)), len * 2);\n\t\t\t\t// sBackward->update(l + len * 2 - 1, r, len * 2);\n\t\t\t\t/*\n\t\t\t\tfor (int i = l + len * 2 - 1; i <= r; i++) {\n\t\t\t\t\tprintf(\"[%d, %d]\\n\", i - len * 2 + 1, i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) forward[i] = sForawrd->query(i);\n\t// for (int i = 0; i < n; i++) backward[i] = sBackward->query(i);\n\n#ifdef DBG\n\tputs(\"forward / backward\");\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\n/*\nstruct ChairmanTree {\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint cnt, refCnt;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc && lc->unRef()) delete lc;\n\t\t\tif (rc && rc->unRef()) delete rc;\n\t\t}\n\n\t\tSegmentTree *ref() {\n\t\t\trefCnt++;\n\t\t\treturn this;\n\t\t}\n\n\t\tbool unRef() {\n\t\t\treturn !refCnt--;\n\t\t}\n\n\t\tint query(const int l, const int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\t\telse return (lc ? lc->query(l, r) : 0) + (rc ? rc->query(l, r) : 0);\n\t\t}\n\n\t\tSegmentTree *insertSelf(const int x) {\n\t\t\tif (l == r) return this;\n\t\t\tif (x <= mid) {\n\t\t\t\tthis->lc = (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x);\n\t\t\t} else {\n\t\t\t\tthis->rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tSegmentTree *insert(const int x) {\n\t\t\tif (x <= mid) {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\t\t} else {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x), cnt + 1);\n\t\t\t}\n\t\t}\n\n\t\tint lcount() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n, l, r;\n\n\tvoid clear() {\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tdelete root[i];\n\t\t}\n\t}\n\n\t// Build tree with array a, whose elements are limited in [l, r]\n\tvoid build(const int *a, const int n, const int l, const int r) {\n\t\tthis->n = n, this->l = l, this->r = r;\n\t\troot[0] = new SegmentTree(0, n, NULL, NULL, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, const int x) {\n\t\t// Adjust input [0, n - 1] to [1, n]\n\t\tSegmentTree *vr = root[r + 1], *vl = root[l];\n\t\tint ans = vr->query(this->l, x);\n\t\tif (vl) ans -= vl->query(this->l, x);\n\t\treturn ans;\n\n\t\t/ *\n\t\twhile (min != max) {\n\t\t\tconst int mid = mid + (max - min) / 2, t = vr->lcount() - (vl ? vl->lcount() : 0);\n\t\t\tif (t < k) {\n\t\t\t\tk -= t, vr = vr->rc;\n\t\t\t\tif (vl) vl = vl->rc;\n\t\t\t} else {\n\t\t\t\tvr = vr->lc;\n\t\t\t\tif (vl) vl = vl->lc;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t\t* /\n\t}\n} t;\n*/\n\ninline unsigned long long solve(const int *limit, const int *forward, const int n) {\n\tstatic struct Query {\n\t\tint type;\n\t\tint pos, val;\n\n\t\tbool operator<(const Query &other) const {\n\t\t\tif (pos < other.pos) return true;\n\t\t\telse if (pos == other.pos && !type && other.type) return true;\n\t\t\telse return false;\n\t\t}\n\t} Q[MAXN * 3];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[i].pos = i;\n\t\tQ[i].type = 0;\n\t\tQ[i].val = limit[i];\n\n#ifdef DBG\n\t\tprintf(\"add(pos = %d, val = %d)\\n\", Q[i].pos, Q[i].val);\n#endif\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[n + i].pos = i - 1;\n\t\tQ[n + i].val = i;\n\t\tQ[n + i].type = -1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i].pos, Q[n + i].val, Q[n + i].type);\n#endif\n\n\t\tQ[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1);\n\t\tQ[n + i + n].val = i;\n\t\tQ[n + i + n].type = 1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type);\n#endif\n\t}\n\n\tstd::sort(Q, Q + n * 3);\n\n\tstatic struct BinaryIndexedTree {\n\t\tint a[MAXN], n;\n\n\t\tstatic int lowbit(const int x) {\n\t\t\treturn x & -x;\n\t\t}\n\n\t\tvoid update(const int x, const int delta) {\n\t\t\t/*\n\t\t\ta[x - 1] += delta;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t\t}\n\n\t\tint query(const int x) {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t\t/*\n\t\t\tfor (int i = 1; i <= x; i++) ans += a[i - 1];\n\t\t\t*/\n\t\t\treturn ans;\n\t\t}\n\n\t\tvoid clear(const int x) {\n\t\t\t/*\n\t\t\ta[x - 1] = 0;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\t\tif (!a[i - 1]) break;\n\t\t\t\ta[i - 1] = 0;\n\t\t\t}\n\t\t}\n\t} bit;\n\n\tbit.n = n;\n\n\tunsigned long long ans = 0;\n\tfor (int i = 0; i < n * 3; i++) {\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].type, Q[i].pos, Q[i].val);\n#endif\n\t\tif (Q[i].type) {\n\t\t\tint t = bit.query(Q[i].val + 1) * Q[i].type;\n\t\t\tans += t;\n#ifdef DBG\n\t\t\tprintf(\"t = %d\\n\", t);\n#endif\n\t\t} else bit.update(Q[i].val + 1, 1);\n\t\t/*\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].l, Q[i].r, Q[i].val);\n#endif\n\t\tif (Q[i].l == -1) bit.update(Q[i].val + 1, 1);\n\t\telse ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l);\n#ifdef DBG\n\t\tprintf(\"ans = %d\\n\", ans);\n#endif\n\t\t*/\n\t}\n\n\tfor (int i = 0; i < n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1);\n\n\treturn ans;\n}\n\nint main() {\n\tint testcase;\n\tscanf(\"%d\", &testcase);\n\n\twhile (testcase--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsa1.build(s, n);\n\t\tstd::reverse(s, s + n);\n\t\tsa2.build(s, n);\n\n\t\tprepare(n);\n\t\tstatic int limit[MAXN];\n\t\tfor (int i = 0; i < n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2);\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", limit[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\n\t\t// t.clear();\n\t\t// t.build(limit, n, 0, n - 1);\n\n\t\t/*\n\t\tunsigned long long ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i);\n\t\t}\n\t\t*/\n\n\t\tunsigned long long ans = solve(limit, forward, n);\n\t\tprintf(\"%llu\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/hdu-5906.md","raw":"title: HDU 5906Square Revolution -  +  + \ncategories: OI\ntags: \n  - HDU\n  - Bestcoder\n  - \n  - \n  - \n  - \n  - \npermalink: hdu-5906\ndate: 2016-09-30 18:00:00\n---\n\n $ S $ prefix-suffix-square free \n\n square `abab``aa`  square `aaa``abba`  prefix-suffix-square free  square\n\n<!-- more -->\n\n### \n[HDU 5906](http://acm.hdu.edu.cn/showproblem.php?pid=5906)\n\n### \n square $ i $  $ i $  square  $ f(i) $ $ i $  $ g(i) $ $ i $ $ j \\in [i, i + f(i) - 2] $  $ i \\geq g(j) $  $ j $ \n\n squareNOI2016  $ k $ $ k $  $ 2k $  square  $ [l, r] $ square $ [L, R] $  $ 2k $  square $ 2k $  $ f(i), i \\in[L, R] $\n\n $ k $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\tinline void build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tinline int rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n\n\tinline int lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint n, forward[MAXN], backward[MAXN];\n\ninline int lcp(const int i, const int j) { return sa1.lcp(i, j); }\ninline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); }\n\ninline void prepare(const int n) {\n\t/*\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int l, const int r, const int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) this->val = std::min(this->val, x);\n\t\t\telse lc->update(l, r, x), rc->update(l, r, x);\n\t\t}\n\n\t\tint query(const int pos) {\n\t\t\treturn (l == r) ? val : std::min(val, ((pos <= mid) ? lc : rc)->query(pos));\n\t\t}\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t\t}\n\t\t}\n\t} *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1);\n\t*/\n\n\tstatic struct UnionFindSet {\n\t\tint a[MAXN], n;\n\n\t\tvoid init(const int n) {\n\t\t\tthis->n = n;\n\t\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t\t}\n\n\t\tint find(const int x) {\n\t\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t\t}\n\n\t\tvoid merge(const int child, const int parent) {\n#ifdef DBG\n\t\t\tprintf(\"merge: %d => %d\\n\", child, parent);\n#endif\n\t\t\tconst int _child = find(child), _parent = find(parent);\n\t\t\ta[_child] = _parent;\n\t\t}\n\n\t\tvoid cover(const int l, const int r, const int x, int *val) {\n#ifdef DBG\n\t\t\tprintf(\"cover(%d, %d, %d)\\n\", l, r, x);\n#endif\n\t\t\tfor (int i = find(l); i <= r; i = find(i + 1)) {\n\t\t\t\tval[i] = std::min(val[i], x);\n\t\t\t\tif (i != n - 1) merge(i, i + 1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t} sForawrd, sBackward;\n\n\tsForawrd.init(n);\n\tsBackward.init(n);\n\n\tfor (int i = 0; i < n; i++) forward[i] = backward[i] = INT_MAX;\n\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i + len < n; i += len) {\n\t\t\tconst int j = i + len;\n\t\t\tconst int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1;\n\t\t\t// const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1;\n#ifdef DBG\n\t\t\tprintf(\"s = %d, len = %d\\n\", s, len);\n#endif\n\t\t\tif (s >= len) {\n#ifdef DBG\n\t\t\t\tprintf(\"!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\\n\", i, j, a, b, len);\n#endif\n\t\t\t\tconst int l = i - a + 1, r = j + b - 1;\n\t\t\t\tsForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward);\n\t\t\t\tsBackward.cover(l + len * 2 - 1, r, len * 2, backward);\n\t\t\t\t// sForawrd->update(l, l + (r - (l + len * 2 - 1)), len * 2);\n\t\t\t\t// sBackward->update(l + len * 2 - 1, r, len * 2);\n\t\t\t\t/*\n\t\t\t\tfor (int i = l + len * 2 - 1; i <= r; i++) {\n\t\t\t\t\tprintf(\"[%d, %d]\\n\", i - len * 2 + 1, i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) forward[i] = sForawrd->query(i);\n\t// for (int i = 0; i < n; i++) backward[i] = sBackward->query(i);\n\n#ifdef DBG\n\tputs(\"forward / backward\");\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\n/*\nstruct ChairmanTree {\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint cnt, refCnt;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc && lc->unRef()) delete lc;\n\t\t\tif (rc && rc->unRef()) delete rc;\n\t\t}\n\n\t\tSegmentTree *ref() {\n\t\t\trefCnt++;\n\t\t\treturn this;\n\t\t}\n\n\t\tbool unRef() {\n\t\t\treturn !refCnt--;\n\t\t}\n\n\t\tint query(const int l, const int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\t\telse return (lc ? lc->query(l, r) : 0) + (rc ? rc->query(l, r) : 0);\n\t\t}\n\n\t\tSegmentTree *insertSelf(const int x) {\n\t\t\tif (l == r) return this;\n\t\t\tif (x <= mid) {\n\t\t\t\tthis->lc = (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x);\n\t\t\t} else {\n\t\t\t\tthis->rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tSegmentTree *insert(const int x) {\n\t\t\tif (x <= mid) {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\t\t} else {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x), cnt + 1);\n\t\t\t}\n\t\t}\n\n\t\tint lcount() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n, l, r;\n\n\tvoid clear() {\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tdelete root[i];\n\t\t}\n\t}\n\n\t// Build tree with array a, whose elements are limited in [l, r]\n\tvoid build(const int *a, const int n, const int l, const int r) {\n\t\tthis->n = n, this->l = l, this->r = r;\n\t\troot[0] = new SegmentTree(0, n, NULL, NULL, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, const int x) {\n\t\t// Adjust input [0, n - 1] to [1, n]\n\t\tSegmentTree *vr = root[r + 1], *vl = root[l];\n\t\tint ans = vr->query(this->l, x);\n\t\tif (vl) ans -= vl->query(this->l, x);\n\t\treturn ans;\n\n\t\t/ *\n\t\twhile (min != max) {\n\t\t\tconst int mid = mid + (max - min) / 2, t = vr->lcount() - (vl ? vl->lcount() : 0);\n\t\t\tif (t < k) {\n\t\t\t\tk -= t, vr = vr->rc;\n\t\t\t\tif (vl) vl = vl->rc;\n\t\t\t} else {\n\t\t\t\tvr = vr->lc;\n\t\t\t\tif (vl) vl = vl->lc;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t\t* /\n\t}\n} t;\n*/\n\ninline unsigned long long solve(const int *limit, const int *forward, const int n) {\n\tstatic struct Query {\n\t\tint type;\n\t\tint pos, val;\n\n\t\tbool operator<(const Query &other) const {\n\t\t\tif (pos < other.pos) return true;\n\t\t\telse if (pos == other.pos && !type && other.type) return true;\n\t\t\telse return false;\n\t\t}\n\t} Q[MAXN * 3];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[i].pos = i;\n\t\tQ[i].type = 0;\n\t\tQ[i].val = limit[i];\n\n#ifdef DBG\n\t\tprintf(\"add(pos = %d, val = %d)\\n\", Q[i].pos, Q[i].val);\n#endif\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[n + i].pos = i - 1;\n\t\tQ[n + i].val = i;\n\t\tQ[n + i].type = -1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i].pos, Q[n + i].val, Q[n + i].type);\n#endif\n\n\t\tQ[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1);\n\t\tQ[n + i + n].val = i;\n\t\tQ[n + i + n].type = 1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type);\n#endif\n\t}\n\n\tstd::sort(Q, Q + n * 3);\n\n\tstatic struct BinaryIndexedTree {\n\t\tint a[MAXN], n;\n\n\t\tstatic int lowbit(const int x) {\n\t\t\treturn x & -x;\n\t\t}\n\n\t\tvoid update(const int x, const int delta) {\n\t\t\t/*\n\t\t\ta[x - 1] += delta;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t\t}\n\n\t\tint query(const int x) {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t\t/*\n\t\t\tfor (int i = 1; i <= x; i++) ans += a[i - 1];\n\t\t\t*/\n\t\t\treturn ans;\n\t\t}\n\n\t\tvoid clear(const int x) {\n\t\t\t/*\n\t\t\ta[x - 1] = 0;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\t\tif (!a[i - 1]) break;\n\t\t\t\ta[i - 1] = 0;\n\t\t\t}\n\t\t}\n\t} bit;\n\n\tbit.n = n;\n\n\tunsigned long long ans = 0;\n\tfor (int i = 0; i < n * 3; i++) {\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].type, Q[i].pos, Q[i].val);\n#endif\n\t\tif (Q[i].type) {\n\t\t\tint t = bit.query(Q[i].val + 1) * Q[i].type;\n\t\t\tans += t;\n#ifdef DBG\n\t\t\tprintf(\"t = %d\\n\", t);\n#endif\n\t\t} else bit.update(Q[i].val + 1, 1);\n\t\t/*\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].l, Q[i].r, Q[i].val);\n#endif\n\t\tif (Q[i].l == -1) bit.update(Q[i].val + 1, 1);\n\t\telse ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l);\n#ifdef DBG\n\t\tprintf(\"ans = %d\\n\", ans);\n#endif\n\t\t*/\n\t}\n\n\tfor (int i = 0; i < n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1);\n\n\treturn ans;\n}\n\nint main() {\n\tint testcase;\n\tscanf(\"%d\", &testcase);\n\n\twhile (testcase--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsa1.build(s, n);\n\t\tstd::reverse(s, s + n);\n\t\tsa2.build(s, n);\n\n\t\tprepare(n);\n\t\tstatic int limit[MAXN];\n\t\tfor (int i = 0; i < n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2);\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", limit[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\n\t\t// t.clear();\n\t\t// t.build(limit, n, 0, n - 1);\n\n\t\t/*\n\t\tunsigned long long ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i);\n\t\t}\n\t\t*/\n\n\t\tunsigned long long ans = solve(limit, forward, n);\n\t\tprintf(\"%llu\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"hdu-5906","published":1,"updated":"2016-09-30T10:00:52.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jij200zn0jxlt6gfu8a8"},{"title":"HDU 5462King's Order -  DP","date":"2016-05-11T23:47:00.000Z","_content":"\n-- $ 3 $ . ---- \n\n $ n $ $ n $ \n\n<!-- more -->\n\n### \n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### \n DP\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n $ n $  $ lastChar $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5642.md","raw":"title: HDU 5462King's Order -  DP\ncategories: OI\ntags: \n  - HDU\n  - BestCoder\n  -  DP\n  - DP\npermalink: hdu-5642\ndate: 2016-05-12 07:47:00\n---\n\n-- $ 3 $ . ---- \n\n $ n $ $ n $ \n\n<!-- more -->\n\n### \n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### \n DP\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n $ n $  $ lastChar $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5642","published":1,"updated":"2016-10-24T23:36:12.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jijb00zy0jxl2zgfkp0i"},{"title":"HDU 632Rikka with Array -  DP","date":"2016-05-12T14:11:00.000Z","_content":"\n $ A(x) $  $ x $  $ 1 $  $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $  $ [i, j] $ \n\n<!-- more -->\n\n### \n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### \n DP\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n $ n $ $ j - i $ $ gap $ $ i \\lt j $  $ i = j $$ i $$ j $ \n\n $ i $$ j $  $ 0 $  $ 1 $ \n\n $ i \\gt j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5632.md","raw":"title: HDU 632Rikka with Array -  DP\ncategories: OI\ntags: \n  - HDU\n  -  DP\n  - DP\npermalink: hdu-5632\ndate: 2016-05-12 22:11:00\n---\n\n $ A(x) $  $ x $  $ 1 $  $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $  $ [i, j] $ \n\n<!-- more -->\n\n### \n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### \n DP\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n $ n $ $ j - i $ $ gap $ $ i \\lt j $  $ i = j $$ i $$ j $ \n\n $ i $$ j $  $ 0 $  $ 1 $ \n\n $ i \\gt j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5632","published":1,"updated":"2016-10-24T23:36:02.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jijh01050jxlbkkxbn3k"},{"title":"HDU 2089 62 -  DP","date":"2016-05-12T03:56:00.000Z","_content":"\n $ 4 $  $ 62 $ $ 62315,\\ 73418,\\ 88914 $ $ 61152 $  $ 6 $  $ 2 $ $ 62 $ \n\n\n\n<!-- more -->\n\n### \n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### \n DP\n\n$$ f[n][last][flag] $$\n\n $ n $  $ n $  $ last $\n\n $ n $  $ 4 $ $ 62 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-2089.md","raw":"title: HDU 2089 62 -  DP\ncategories: OI\ntags: \n  - HDU\n  -  DP\n  - DP\npermalink: hdu-2089\ndate: 2016-05-12 11:56:00\n---\n\n $ 4 $  $ 62 $ $ 62315,\\ 73418,\\ 88914 $ $ 61152 $  $ 6 $  $ 2 $ $ 62 $ \n\n\n\n<!-- more -->\n\n### \n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### \n DP\n\n$$ f[n][last][flag] $$\n\n $ n $  $ n $  $ last $\n\n $ n $  $ 4 $ $ 62 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-2089","published":1,"updated":"2016-10-24T23:35:53.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jijm010a0jxlka1aahon"},{"title":"HAOI2016 -  + DP","date":"2016-04-28T14:20:45.000Z","_content":"\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### \n****\n\n DP \n\n****\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/haoi2016-chain.md","raw":"title: HAOI2016 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - \n  - DP\npermalink: haoi2016-chain\ndate: 2016-04-28 22:20:45\n---\n\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### \n****\n\n DP \n\n****\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"haoi2016-chain","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jijq010f0jxl789rnlgs"},{"title":"HAOI2015 -  + DFS","date":"2016-04-03T14:32:45.000Z","_content":"\n $ N $  $ 1 $  $ M $ \n\n1.  $ x $  $ a $\n2.  $ x $  $ a $\n3.  $ x $ \n\n<!-- more -->\n\n### \n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### \n + DFS  `long long` \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2015-t2.md","raw":"title: HAOI2015 -  + DFS\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - \n  - DFS \npermalink: haoi2015-t2\ndate: 2016-04-03 22:32:45\n---\n\n $ N $  $ 1 $  $ M $ \n\n1.  $ x $  $ a $\n2.  $ x $  $ a $\n3.  $ x $ \n\n<!-- more -->\n\n### \n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### \n + DFS  `long long` \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2015-t2","published":1,"updated":"2016-09-10T09:44:45.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jijx010n0jxl9r9a9qps"},{"title":"HAOI2011Problem b - ","date":"2016-04-08T03:32:33.000Z","_content":"\n $ n $  $ (x, y) $ $ a \\leq x \\leq b $$ c \\leq y \\leq d $ $ \\gcd(x, y) = k $$ \\gcd(x, y) $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### \n\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n $ F $ \n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n $ F(n, m, k) $ \n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n\n\n $ \\frac{n}{k} $  $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n $ F' $  $ \\mu(T) $  $ O(\\sqrt{n}) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2011-problemb.md","raw":"title: HAOI2011Problem b - \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - \n  - \n  - \n  - \npermalink: haoi2011-problemb\ndate: 2016-04-08 11:32:33\n---\n\n $ n $  $ (x, y) $ $ a \\leq x \\leq b $$ c \\leq y \\leq d $ $ \\gcd(x, y) = k $$ \\gcd(x, y) $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### \n\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n $ F $ \n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n $ F(n, m, k) $ \n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n\n\n $ \\frac{n}{k} $  $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n $ F' $  $ \\mu(T) $  $ O(\\sqrt{n}) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2011-problemb","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jik2010u0jxlq257xkju"},{"title":"HAOI2008 -  + DP","date":"2016-11-13T03:31:00.000Z","_content":"\n $ n $  $ i $  $ L_i $$ n $  $ n - 1 $  $ m $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1044](http://www.lydsy.com/JudgeOnline/problem.php?id=1044)\n\n### \n $ t $\n\n $ f(i, j) $  $ i $  $ j $  $ t $ \n\n $ s(i) $  $ i $ \n\n$$ f(i, j) = \\sum\\limits_{s(i) - s(k - 1) \\leq t} f(k - 1, j - 1)  $$\n\n $ k $  $ i $  $ j $ $ k $ \n\n $ f(i, j - 1) $  $ i $  $ k $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 1000;\nconst int MO = 10007;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\n\ninline bool check(int limit) {\n\tint k = m, s = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s + a[i] > limit) k--, s = a[i];\n\t\telse s += a[i];\n\t}\n\treturn k >= 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m), m++;\n\n\tint max = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), max = std::max(max, a[i]);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n\tint l = max, r = s[n];\n\twhile (r - l >= 5) {\n\t\tint mid = l + (r - l) / 2;\n\t\t// printf(\"[%d, %d, %d]\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tint ans;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (check(i)) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d \", ans);\n\n\tint tot = 0;\n\tstatic int f[MAXN + 1][2];\n\tfor (int i = 1; i <= n; i++) f[i][1] = s[i] <= ans ? 1 : 0;\n\tfor (int j = 2; j <= m; j++) {\n\t\tfor (int i = 1; i <= n; i++) (f[i][(j - 1) & 1] += f[i - 1][(j - 1) & 1]) %= MO;\n\t\tfor (int i = 1, k = j; i <= n; i++) {\n\t\t\tf[i][j & 1] = 0;\n\t\t\twhile (k <= i && s[i] - s[k - 1] > ans) k++;\n\t\t\tif (k <= i && s[i] - s[k - 1] <= ans) {\n\t\t\t\t// printf(\"f(%d, %d) += f([%d, %d], %d)\\n\", i, j, i - 1, k - 1, j - 1);\n\t\t\t\t(f[i][j & 1] += f[i - 1][(j - 1) & 1] - f[k - 2][(j - 1) & 1]) %= MO;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = j; k <= i; k++) {\n\t\t\t\tif (s[i] - s[k - 1] <= ans) {\n\t\t\t\t\tf[i][j] += f[k - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\t\t\t// f[i][j] += f[i - 1][j];\n\t\t}\n\t\t(tot += f[n][j & 1]) %= MO;\n\t}\n\n\t// for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\tprintf(\"%d\\n\", (tot + MO) % MO);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-stick.md","raw":"title: HAOI2008 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - DP\npermalink: haoi2008-stick\ndate: 2016-11-13 11:31:00\n---\n\n $ n $  $ i $  $ L_i $$ n $  $ n - 1 $  $ m $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1044](http://www.lydsy.com/JudgeOnline/problem.php?id=1044)\n\n### \n $ t $\n\n $ f(i, j) $  $ i $  $ j $  $ t $ \n\n $ s(i) $  $ i $ \n\n$$ f(i, j) = \\sum\\limits_{s(i) - s(k - 1) \\leq t} f(k - 1, j - 1)  $$\n\n $ k $  $ i $  $ j $ $ k $ \n\n $ f(i, j - 1) $  $ i $  $ k $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 1000;\nconst int MO = 10007;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\n\ninline bool check(int limit) {\n\tint k = m, s = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s + a[i] > limit) k--, s = a[i];\n\t\telse s += a[i];\n\t}\n\treturn k >= 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m), m++;\n\n\tint max = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), max = std::max(max, a[i]);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n\tint l = max, r = s[n];\n\twhile (r - l >= 5) {\n\t\tint mid = l + (r - l) / 2;\n\t\t// printf(\"[%d, %d, %d]\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tint ans;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (check(i)) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d \", ans);\n\n\tint tot = 0;\n\tstatic int f[MAXN + 1][2];\n\tfor (int i = 1; i <= n; i++) f[i][1] = s[i] <= ans ? 1 : 0;\n\tfor (int j = 2; j <= m; j++) {\n\t\tfor (int i = 1; i <= n; i++) (f[i][(j - 1) & 1] += f[i - 1][(j - 1) & 1]) %= MO;\n\t\tfor (int i = 1, k = j; i <= n; i++) {\n\t\t\tf[i][j & 1] = 0;\n\t\t\twhile (k <= i && s[i] - s[k - 1] > ans) k++;\n\t\t\tif (k <= i && s[i] - s[k - 1] <= ans) {\n\t\t\t\t// printf(\"f(%d, %d) += f([%d, %d], %d)\\n\", i, j, i - 1, k - 1, j - 1);\n\t\t\t\t(f[i][j & 1] += f[i - 1][(j - 1) & 1] - f[k - 2][(j - 1) & 1]) %= MO;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = j; k <= i; k++) {\n\t\t\t\tif (s[i] - s[k - 1] <= ans) {\n\t\t\t\t\tf[i][j] += f[k - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\t\t\t// f[i][j] += f[i - 1][j];\n\t\t}\n\t\t(tot += f[n][j & 1]) %= MO;\n\t}\n\n\t// for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\tprintf(\"%d\\n\", (tot + MO) % MO);\n\n\treturn 0;\n}\n```","slug":"haoi2008-stick","published":1,"updated":"2016-11-13T03:31:51.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jika01140jxl777wje9r"},{"title":"HAOI2008 -  DP","date":"2016-07-06T03:37:00.000Z","_content":"\n `WING`  `WING` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1055](http://www.lydsy.com/JudgeOnline/problem.php?id=1055)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 200;\nconst int K = 4;\n\nint n, a[MAXN];\nbool map[K][K][K];\n\ninline int id(const char ch) {\n\tswitch (ch) {\n\t\tcase 'W': return 0;\n\t\tcase 'I': return 1;\n\t\tcase 'N': return 2;\n\t\tcase 'G': return 3;\n\t\tdefault: return -1;\n\t}\n}\n\ninline char letter(const int x) {\n\treturn (\"WING\")[x];\n}\n\ninline void setMap(const int x, const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tmap[id(s[0])][id(s[1])][x] = true;\n\t}\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tstatic bool calced[MAXN][MAXN];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1 << a[l];\n\n\tfor (int i = l; i < r; i++) {\n\t\tconst int a = dp(l, i), b = dp(i + 1, r);\n\n\t\tfor (int i = 0; i < K; i++) if (a & (1 << i)) for (int j = 0; j < K; j++) if (b & (1 << j)) {\n\t\t\tfor (int k = 0; k < K; k++) if (map[i][j][k]) ans |= 1 << k;\n\t\t}\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\treturn ans;\n}\n\nint main() {\n\tint cnt[K];\n\tfor (int i = 0; i < K; i++) scanf(\"%d\", &cnt[i]);\n\tfor (int i = 0; i < K; i++) setMap(i, cnt[i]);\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = id(s[i]);\n\n\tint res = dp(0, n - 1);\n\tbool flag = false;\n\tfor (int i = 0; i < K; i++) if (res & (1 << i)) putchar(letter(i)), flag = true;\n\n\tif (flag) putchar('\\n');\n\telse puts(\"The name is wrong!\");\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2008-name.md","raw":"title: HAOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  -  DP\npermalink: haoi2008-name\ndate: 2016-07-06 11:37:00\n---\n\n `WING`  `WING` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1055](http://www.lydsy.com/JudgeOnline/problem.php?id=1055)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 200;\nconst int K = 4;\n\nint n, a[MAXN];\nbool map[K][K][K];\n\ninline int id(const char ch) {\n\tswitch (ch) {\n\t\tcase 'W': return 0;\n\t\tcase 'I': return 1;\n\t\tcase 'N': return 2;\n\t\tcase 'G': return 3;\n\t\tdefault: return -1;\n\t}\n}\n\ninline char letter(const int x) {\n\treturn (\"WING\")[x];\n}\n\ninline void setMap(const int x, const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tmap[id(s[0])][id(s[1])][x] = true;\n\t}\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tstatic bool calced[MAXN][MAXN];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1 << a[l];\n\n\tfor (int i = l; i < r; i++) {\n\t\tconst int a = dp(l, i), b = dp(i + 1, r);\n\n\t\tfor (int i = 0; i < K; i++) if (a & (1 << i)) for (int j = 0; j < K; j++) if (b & (1 << j)) {\n\t\t\tfor (int k = 0; k < K; k++) if (map[i][j][k]) ans |= 1 << k;\n\t\t}\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\treturn ans;\n}\n\nint main() {\n\tint cnt[K];\n\tfor (int i = 0; i < K; i++) scanf(\"%d\", &cnt[i]);\n\tfor (int i = 0; i < K; i++) setMap(i, cnt[i]);\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = id(s[i]);\n\n\tint res = dp(0, n - 1);\n\tbool flag = false;\n\tfor (int i = 0; i < K; i++) if (res & (1 << i)) putchar(letter(i)), flag = true;\n\n\tif (flag) putchar('\\n');\n\telse puts(\"The name is wrong!\");\n\n\treturn 0;\n}\n```\n","slug":"haoi2008-name","published":1,"updated":"2016-10-24T23:35:44.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jikf011a0jxl563rdiif"},{"title":"HAOI2008 -  DP + ","date":"2016-11-13T03:11:00.000Z","_content":"\n $ 4 $  $ c_1, c_2, c_3, c_4 $ $ n $  $ d_i $  $ c_i $  $ s_i $ \n\n<!-- more -->\n\n### \n[BZOJ 1042](http://www.lydsy.com/JudgeOnline/problem.php?id=1042)\n\n### \n $ c $  $ f(c) $\n\n $ s_i $    -  +  - \n\n $ i $    $ d_i + 1 $  $ i $  $ s - (d_i + 1) \\times c_i $  $ f(s - (d_i + 1) \\times c_i) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MAXM = 100000;\n\nint main() {\n\tint c[4 + 1], n;\n\tscanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &n);\n\n\tstatic long long f[4 + 1][MAXM + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < c[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n\t\t}\n\t}\n\n\twhile (n--) {\n\t\tint d[4 + 1], m;\n\t\tscanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &m);\n\n\t\tlong long ans = f[4][m];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tif (m - (d[i] + 1) * c[i] >= 0) ans -= f[4][m - (d[i] + 1) * c[i]];\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] >= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tfor (int k = j + 1; k <= 4; k++) {\n\t\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] >= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] >= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-coins.md","raw":"title: HAOI2008 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - DP\n  -  DP\n  - \npermalink: haoi2008-coins\ndate: 2016-11-13 11:11:00\n---\n\n $ 4 $  $ c_1, c_2, c_3, c_4 $ $ n $  $ d_i $  $ c_i $  $ s_i $ \n\n<!-- more -->\n\n### \n[BZOJ 1042](http://www.lydsy.com/JudgeOnline/problem.php?id=1042)\n\n### \n $ c $  $ f(c) $\n\n $ s_i $    -  +  - \n\n $ i $    $ d_i + 1 $  $ i $  $ s - (d_i + 1) \\times c_i $  $ f(s - (d_i + 1) \\times c_i) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MAXM = 100000;\n\nint main() {\n\tint c[4 + 1], n;\n\tscanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &n);\n\n\tstatic long long f[4 + 1][MAXM + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < c[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n\t\t}\n\t}\n\n\twhile (n--) {\n\t\tint d[4 + 1], m;\n\t\tscanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &m);\n\n\t\tlong long ans = f[4][m];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tif (m - (d[i] + 1) * c[i] >= 0) ans -= f[4][m - (d[i] + 1) * c[i]];\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] >= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tfor (int k = j + 1; k <= 4; k++) {\n\t\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] >= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] >= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"haoi2008-coins","published":1,"updated":"2016-11-13T03:11:42.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jikk011g0jxlux6trkbp"},{"title":"HAOI2008 - ","date":"2016-11-13T02:56:00.000Z","_content":"\n $ x ^ 2 + y ^ 2 = r ^ 2 $\n\n<!-- more -->\n\n### \n[BZOJ 1041](http://www.lydsy.com/JudgeOnline/problem.php?id=1041)\n\n### \n$$\n\\begin{aligned}\nx ^ 2 + y ^ 2 &= r ^ 2 \\\\\ny ^ 2 &= r ^ 2 - x ^ 2 \\\\\ny ^ 2 &= (r + x) \\times (r - x)\n\\end{aligned}\n$$\n\n $ d = \\gcd(r + x, r - x) $$ a = \\frac{r - x}{d} $$ b = \\frac{r + x}{d} $ $ \\gcd(a, b) = 1 $\n\n$$\n\\begin{aligned}\ny ^ 2 &= (r + x) \\times (r - x) \\\\\n&= d ^ 2 \\times a \\times b\n\\end{aligned}\n$$\n\n$ d ^ 2 $  $ y ^ 2 $  $ a \\times b $  $ \\gcd(a, b) = 1 $ $ a $  $ b $ \n\n$$\n\\begin{aligned}\na + b &= \\frac{r - x}{d} + \\frac{r + x}{d} \\\\\na + b &= \\frac{2r}{d}\n\\end{aligned}\n$$\n\n $ \\{ a, b, d \\} $ $ a $  $ b $  $ d $  $ 2r $ \n\n $ d $ $ \\sqrt a $ $ b $ $ \\gcd(a, b) = 1 $ \n\n $ k $ $ 4k + 4 $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 2e9;\nconst double EPS = 1e-6;\n\nint main() {\n\tlong long r;\n\tscanf(\"%lld\", &r);\n\n\t// 2 * r = d * (a ^ 2 + b ^ 2)\n\tlong long cnt = 0;\n\tfor (long long i = 1; i * i <= r * 2; i++) {\n\t\tif (2 * r % i != 0) continue;\n\n\t\tlong long d = i;\n\t\tlong long t = 2 * r / i;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (long long a = 1; a * a < t / 2; a++) {\n\t\t\t\tdouble b = sqrt(t - a * a);\n\t\t\t\tlong long _b = static_cast<long long>(b);\n\t\t\t\tif (fabs(b - _b) <= EPS && std::__gcd(a, _b) == 1) {\n\t\t\t\t\t// printf(\"d = %lld, a = %lld, b = %lld\\n\", d, a, _b);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != d) std::swap(t, d);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", cnt * 4 + 4);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-cir.md","raw":"title: HAOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \npermalink: haoi2008-cir\ndate: 2016-11-13 10:56:00\n---\n\n $ x ^ 2 + y ^ 2 = r ^ 2 $\n\n<!-- more -->\n\n### \n[BZOJ 1041](http://www.lydsy.com/JudgeOnline/problem.php?id=1041)\n\n### \n$$\n\\begin{aligned}\nx ^ 2 + y ^ 2 &= r ^ 2 \\\\\ny ^ 2 &= r ^ 2 - x ^ 2 \\\\\ny ^ 2 &= (r + x) \\times (r - x)\n\\end{aligned}\n$$\n\n $ d = \\gcd(r + x, r - x) $$ a = \\frac{r - x}{d} $$ b = \\frac{r + x}{d} $ $ \\gcd(a, b) = 1 $\n\n$$\n\\begin{aligned}\ny ^ 2 &= (r + x) \\times (r - x) \\\\\n&= d ^ 2 \\times a \\times b\n\\end{aligned}\n$$\n\n$ d ^ 2 $  $ y ^ 2 $  $ a \\times b $  $ \\gcd(a, b) = 1 $ $ a $  $ b $ \n\n$$\n\\begin{aligned}\na + b &= \\frac{r - x}{d} + \\frac{r + x}{d} \\\\\na + b &= \\frac{2r}{d}\n\\end{aligned}\n$$\n\n $ \\{ a, b, d \\} $ $ a $  $ b $  $ d $  $ 2r $ \n\n $ d $ $ \\sqrt a $ $ b $ $ \\gcd(a, b) = 1 $ \n\n $ k $ $ 4k + 4 $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 2e9;\nconst double EPS = 1e-6;\n\nint main() {\n\tlong long r;\n\tscanf(\"%lld\", &r);\n\n\t// 2 * r = d * (a ^ 2 + b ^ 2)\n\tlong long cnt = 0;\n\tfor (long long i = 1; i * i <= r * 2; i++) {\n\t\tif (2 * r % i != 0) continue;\n\n\t\tlong long d = i;\n\t\tlong long t = 2 * r / i;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (long long a = 1; a * a < t / 2; a++) {\n\t\t\t\tdouble b = sqrt(t - a * a);\n\t\t\t\tlong long _b = static_cast<long long>(b);\n\t\t\t\tif (fabs(b - _b) <= EPS && std::__gcd(a, _b) == 1) {\n\t\t\t\t\t// printf(\"d = %lld, a = %lld, b = %lld\\n\", d, a, _b);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != d) std::swap(t, d);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", cnt * 4 + 4);\n\n\treturn 0;\n}\n```","slug":"haoi2008-cir","published":1,"updated":"2016-11-13T02:56:51.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jikq011o0jxl26gropca"},{"title":"HAOI2008 - ","date":"2016-11-13T03:45:00.000Z","_content":"\n $ n $  $ a_i $  $ 1 $\n\n<!-- more -->\n\n### \n[BZOJ 1045](http://www.lydsy.com/JudgeOnline/problem.php?id=1045)\n\n### \n $ v = \\frac{\\sum\\limits_{i = 1} ^ n a_i}{n} $$ x_1 $  $ i - 1 $  $ i $ \n\n$$\n\\begin{aligned}\nv &= a_i + x_i - x_{i - 1} \\\\\nx_{i + 1} &= x_i - v + a_i\n\\end{aligned}\n$$\n\n\n\n$$\n\\begin{aligned}\nx_2 &= x_1 - v + a_1 \\\\\nx_3 &= x_2 - v + a_2 \\\\\n    &= x_1 - v + a_1 - v + a_2 \\\\\nx_4 &= x_3 - v + a_3 \\\\\n    &= x_1 - v + a_1 - v + a_2 - v + a_3\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ n | x_i | $\n\n $ c_0 = 0, c_i = c_{i - 1} + v - a_i $\n\n$$\n\\begin{aligned}\nx_1 &= x_1 - c_0 \\\\\nx_2 &= x_1 - c_1 \\\\\nx_3 &= x_1 - c_2 \\\\\nx_4 &= x_1 - c_3\n\\end{aligned}\n$$\n\n\n\n$$ \\sum\\limits_{i = 1} ^ n | x_1 - c_{i - 1} | $$\n\n $ c_i $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic long long a[MAXN];\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tlong long avg = sum / n;\n\tstatic long long c[MAXN];\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i++) c[i] = c[i - 1] - a[i] + avg;\n\n\tstd::sort(c, c + n);\n\n\tlong long mid = c[n / 2], ans = 0;\n\tfor (int i = 0; i < n; i++) ans += llabs(c[i] - mid);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-candy.md","raw":"title: HAOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \npermalink: haoi2008-candy\ndate: 2016-11-13 11:45:00\n---\n\n $ n $  $ a_i $  $ 1 $\n\n<!-- more -->\n\n### \n[BZOJ 1045](http://www.lydsy.com/JudgeOnline/problem.php?id=1045)\n\n### \n $ v = \\frac{\\sum\\limits_{i = 1} ^ n a_i}{n} $$ x_1 $  $ i - 1 $  $ i $ \n\n$$\n\\begin{aligned}\nv &= a_i + x_i - x_{i - 1} \\\\\nx_{i + 1} &= x_i - v + a_i\n\\end{aligned}\n$$\n\n\n\n$$\n\\begin{aligned}\nx_2 &= x_1 - v + a_1 \\\\\nx_3 &= x_2 - v + a_2 \\\\\n    &= x_1 - v + a_1 - v + a_2 \\\\\nx_4 &= x_3 - v + a_3 \\\\\n    &= x_1 - v + a_1 - v + a_2 - v + a_3\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ n | x_i | $\n\n $ c_0 = 0, c_i = c_{i - 1} + v - a_i $\n\n$$\n\\begin{aligned}\nx_1 &= x_1 - c_0 \\\\\nx_2 &= x_1 - c_1 \\\\\nx_3 &= x_1 - c_2 \\\\\nx_4 &= x_1 - c_3\n\\end{aligned}\n$$\n\n\n\n$$ \\sum\\limits_{i = 1} ^ n | x_1 - c_{i - 1} | $$\n\n $ c_i $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic long long a[MAXN];\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tlong long avg = sum / n;\n\tstatic long long c[MAXN];\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i++) c[i] = c[i - 1] - a[i] + avg;\n\n\tstd::sort(c, c + n);\n\n\tlong long mid = c[n / 2], ans = 0;\n\tfor (int i = 0; i < n; i++) ans += llabs(c[i] - mid);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2008-candy","published":1,"updated":"2016-11-13T07:24:37.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiku011t0jxle5dm87ui"},{"title":"HAOI2007 - DP + ","date":"2016-12-01T03:43:00.000Z","_content":"\n $ S = \\{ a_1, a_2, a_3, \\ldots , a_n \\} $ $ P = \\{ a_{x_1},a_{x_2}, a_{x_3}, \\ldots, a_{x_m} \\} $ $ x_1 < x_2 < \\ldots < x_m $  $ a_{x_1} < a_{x_2} < \\ldots < a_{x_m} $ $ P $  $ S $  $ P $ \n\n $ S $  $ i $  $ L_i $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1046](http://www.lydsy.com/JudgeOnline/problem.php?id=1046)\n\n### \n $ f(i) $  $ i $ ****\n\n$$ f(i) = \\max\\limits_{j > i, a_j > a_i}\\{ f(j) \\} + 1 $$\n\n $ \\leq l $ $ l $  $ 1 $ $ l \\neq 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int f[MAXN + 1];\n\tfor (int i = n; i >= 1; i--) {\n\t\tf[i] = 1;\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"f[%d] = %d\\n\", i, f[i]);\n#endif\n\t}\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\n\t\tstatic int tmp[MAXN + 1];\n\t\tint cnt = 0;\n\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[i] >= l && a[i] > last) {\n\t\t\t\tl--;\n\t\t\t\tlast = a[i];\n\t\t\t\ttmp[++cnt] = a[i];\n\t\t\t}\n\t\t\tif (!l) break;\n\t\t}\n\n\t\tif (l) puts(\"Impossible\");\n\t\telse for (int i = 1; i <= cnt; i++) printf(\"%d%c\", tmp[i], i == cnt ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2007-lis.md","raw":"title: HAOI2007 - DP + \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  - \npermalink: haoi2007-lis\ndate: 2016-12-01 11:43:00\n---\n\n $ S = \\{ a_1, a_2, a_3, \\ldots , a_n \\} $ $ P = \\{ a_{x_1},a_{x_2}, a_{x_3}, \\ldots, a_{x_m} \\} $ $ x_1 < x_2 < \\ldots < x_m $  $ a_{x_1} < a_{x_2} < \\ldots < a_{x_m} $ $ P $  $ S $  $ P $ \n\n $ S $  $ i $  $ L_i $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1046](http://www.lydsy.com/JudgeOnline/problem.php?id=1046)\n\n### \n $ f(i) $  $ i $ ****\n\n$$ f(i) = \\max\\limits_{j > i, a_j > a_i}\\{ f(j) \\} + 1 $$\n\n $ \\leq l $ $ l $  $ 1 $ $ l \\neq 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int f[MAXN + 1];\n\tfor (int i = n; i >= 1; i--) {\n\t\tf[i] = 1;\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"f[%d] = %d\\n\", i, f[i]);\n#endif\n\t}\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\n\t\tstatic int tmp[MAXN + 1];\n\t\tint cnt = 0;\n\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[i] >= l && a[i] > last) {\n\t\t\t\tl--;\n\t\t\t\tlast = a[i];\n\t\t\t\ttmp[++cnt] = a[i];\n\t\t\t}\n\t\t\tif (!l) break;\n\t\t}\n\n\t\tif (l) puts(\"Impossible\");\n\t\telse for (int i = 1; i <= cnt; i++) printf(\"%d%c\", tmp[i], i == cnt ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2007-lis","published":1,"updated":"2016-12-01T08:25:25.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jil1011y0jxlr4etq1fx"},{"title":"HAOI2006 - ","date":"2016-03-04T13:28:17.000Z","_content":"\n $ N $  $ M $  $ (A,B) $ $ A $  $ B $   $ A $  $ B $ $ B $  $ C $  $ A $  $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2006-cow.md","raw":"title: HAOI2006 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - Tarjan\n  - \npermalink: haoi2006-cow\ndate: 2016-03-04 21:28:17\n---\n\n $ N $  $ M $  $ (A,B) $ $ A $  $ B $   $ A $  $ B $ $ B $  $ C $  $ A $  $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","slug":"haoi2006-cow","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jil601240jxlrre2i061"},{"title":"GDB ","id":"41","updated":"2016-02-05T02:59:41.000Z","date":"2016-02-05T02:58:07.000Z","_content":"\nGDBGNU Debugger GNU  UNIXLinux  Windows  CC++Pascal \n\n<!-- more -->\n\n### \n#### Linux\n Ubuntu  `apt`  GDB\n```bash\nsudo apt-get install gdb\n```\nNOI Linux  GDB\n\n RHEL/Fedora/Archlinux  GDB\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n Windows  Cygwin/MSYS2  GDB MinGW \n\nDev-C++  MinGW `bin`  `gdb.exe` `bin`  `PATH`  `cmd`  `gdb` \n\n### \n `gdb` Windows  GDB\n```bash\ngdb\n```\n GDB  `file` \n```bash\n(gdb) file test\n```\n GDB \n```bash\ngdb test\n```\n `test` \n\n GDB ** `-g` **\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB \n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### \n `run` `r`\n```bash\n(gdb) run\n```\n\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\nRuntime ErrorRE\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n `SIGSEGV` Segmentation fault `6` \n\n\n\n### \n `quit` `q`\n\n `q`  GDB\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n `y`  GDB\n\n### \n `break` `b`\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n `r`  `528` \n\nPascal  `==`  `=`\n\n### \n `continue` `c`\n\n********   \n\n `step` `s`\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n Pascal \n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n `next` `n`****\n\n\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### \n GDB \n\n `print` `p`\n\n A + B \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n `display` `disp`\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n GDB 7.0  `p`  STL \n\n### \n `backtrace` `bt`\n\n\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n 272043 \n\n`bt` \n\n `frame` \n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n`frame 3`  `d(x)`  `p x`  `4`\n\n`frame`  STL  STL \n\n### \n `list` `l`\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","source":"_posts/gnu-debugger.md","raw":"title: GDB \ncategories: OI\ntags: \n  - GDB\n  - \n  - C++\npermalink: gnu-debugger\nid: 41\nupdated: '2016-02-05 10:59:41'\ndate: 2016-02-05 10:58:07\n---\n\nGDBGNU Debugger GNU  UNIXLinux  Windows  CC++Pascal \n\n<!-- more -->\n\n### \n#### Linux\n Ubuntu  `apt`  GDB\n```bash\nsudo apt-get install gdb\n```\nNOI Linux  GDB\n\n RHEL/Fedora/Archlinux  GDB\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n Windows  Cygwin/MSYS2  GDB MinGW \n\nDev-C++  MinGW `bin`  `gdb.exe` `bin`  `PATH`  `cmd`  `gdb` \n\n### \n `gdb` Windows  GDB\n```bash\ngdb\n```\n GDB  `file` \n```bash\n(gdb) file test\n```\n GDB \n```bash\ngdb test\n```\n `test` \n\n GDB ** `-g` **\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB \n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### \n `run` `r`\n```bash\n(gdb) run\n```\n\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\nRuntime ErrorRE\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n `SIGSEGV` Segmentation fault `6` \n\n\n\n### \n `quit` `q`\n\n `q`  GDB\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n `y`  GDB\n\n### \n `break` `b`\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n `r`  `528` \n\nPascal  `==`  `=`\n\n### \n `continue` `c`\n\n********   \n\n `step` `s`\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n Pascal \n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n `next` `n`****\n\n\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### \n GDB \n\n `print` `p`\n\n A + B \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n `display` `disp`\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n GDB 7.0  `p`  STL \n\n### \n `backtrace` `bt`\n\n\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n 272043 \n\n`bt` \n\n `frame` \n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n`frame 3`  `d(x)`  `p x`  `4`\n\n`frame`  STL  STL \n\n### \n `list` `l`\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","slug":"gnu-debugger","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jilb012b0jxl65i0vqqg"},{"title":"FJOI2007 - ","date":"2016-10-17T02:54:00.000Z","_content":"\n $ N $  $ N $ 2  2  $ N $  $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002)\n\n### \n$ f(i) = 3f(i - 1) - f(i - 2) + 2 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MAXN = 100;\n\nstruct BigInt {\n\tstd::vector<int> v;\n\n\tBigInt(const int n = 0) { *this = n; }\n\tBigInt(const std::string &s) { *this = s; }\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n\n\tBigInt &operator=(const std::string &s) {\n\t\tv.resize(s.length());\n\t\tfor (size_t i = 0; i < s.length(); i++) v[i] = s[s.length() - i - 1] - '0';\n\t}\n\n\tvoid print() {\n\t\tfor (int i = v.size() - 1; i >= 0; i--) printf(\"%d\", v[i]);\n\t\tputchar('\\n');\n\t}\n};\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t += b.v[i];\n\t\tif (flag) t++, flag = false;\n\t\tif (t >= 10) t -= 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\tif (flag) res.v.push_back(1);\n\treturn res;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t -= b.v[i];\n\t\tif (flag) t--, flag = false;\n\t\tif (t < 0) t += 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\treturn res;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.resize(a.v.size() + b.v.size() + 1);\n\tfor (size_t i = 0; i < a.v.size(); i++) {\n\t\tfor (size_t j = 0; j < b.v.size(); j++) {\n\t\t\tres.v[i + j] += a.v[i] * b.v[j];\n\t\t\tres.v[i + j + 1] += res.v[i + j] / 10;\n\t\t\tres.v[i + j] %= 10;\n\t\t}\n\t}\n\twhile (res.v.size() > 1 && res.v.back() == 0) res.v.pop_back();\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBigInt f[MAXN + 1];\n\tf[1] = 1, f[2] = 5;\n\tfor (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2;\n\tf[n].print();\n\treturn 0;\n}\n```\n","source":"_posts/fjoi2007-wheel.md","raw":"title: FJOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - FJOI\n  - \npermalink: fjoi2007-wheel\ndate: 2016-10-17 10:54:00\n---\n\n $ N $  $ N $ 2  2  $ N $  $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002)\n\n### \n$ f(i) = 3f(i - 1) - f(i - 2) + 2 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MAXN = 100;\n\nstruct BigInt {\n\tstd::vector<int> v;\n\n\tBigInt(const int n = 0) { *this = n; }\n\tBigInt(const std::string &s) { *this = s; }\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n\n\tBigInt &operator=(const std::string &s) {\n\t\tv.resize(s.length());\n\t\tfor (size_t i = 0; i < s.length(); i++) v[i] = s[s.length() - i - 1] - '0';\n\t}\n\n\tvoid print() {\n\t\tfor (int i = v.size() - 1; i >= 0; i--) printf(\"%d\", v[i]);\n\t\tputchar('\\n');\n\t}\n};\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t += b.v[i];\n\t\tif (flag) t++, flag = false;\n\t\tif (t >= 10) t -= 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\tif (flag) res.v.push_back(1);\n\treturn res;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t -= b.v[i];\n\t\tif (flag) t--, flag = false;\n\t\tif (t < 0) t += 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\treturn res;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.resize(a.v.size() + b.v.size() + 1);\n\tfor (size_t i = 0; i < a.v.size(); i++) {\n\t\tfor (size_t j = 0; j < b.v.size(); j++) {\n\t\t\tres.v[i + j] += a.v[i] * b.v[j];\n\t\t\tres.v[i + j + 1] += res.v[i + j] / 10;\n\t\t\tres.v[i + j] %= 10;\n\t\t}\n\t}\n\twhile (res.v.size() > 1 && res.v.back() == 0) res.v.pop_back();\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBigInt f[MAXN + 1];\n\tf[1] = 1, f[2] = 5;\n\tfor (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2;\n\tf[n].print();\n\treturn 0;\n}\n```\n","slug":"fjoi2007-wheel","published":1,"updated":"2016-10-17T09:26:27.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jilh012i0jxl1du4mz32"},{"title":"","date":"2016-06-17T13:38:00.000Z","_content":"\nFFT Number-Theoretic Transform\n\n<!-- more -->\n\n### \nFFT  $ \\omega_n ^ k = \\cos \\frac{2 \\pi}{n}k + i \\sin\\frac{2 \\pi}{n}k $\n\n1. $ \\omega_n ^ t (0 \\leq t \\leq n - 1) $ \n2. $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n3. $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n3.  $ k \\neq 0 $ $ 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} = 0 $\n\n $ p = qn + 1 $ $ n $  $ 2 $ **** $ g $  $ g ^ i(0 \\leq i \\leq p - 1) $ \n\n#### \n\n $ \\omega_n = g ^ q $ $ 1,\\ g ^ q,\\ g ^ {2q},\\ \\dots,\\ g ^ {(n - 1)q} $ ****\n\n#### \n\n $ \\omega_n = g ^ q $  $ \\omega_{2n} = g ^ { \\frac{q}{2} } $$ p = \\frac{q}{2} \\times 2n + 1 $ $ \\omega_{2n} ^ {2k} = g ^ {2k \\frac{q}{2} } = g ^ {kq} = \\omega_n ^ k $****\n\n#### \n\n\n\n$$ \\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ (\\omega_{n} ^ { \\frac{n}{2} }) ^ 2 = \\omega_n ^ n $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv \\pm 1 \\pmod p $ $ \\omega_n ^ { \\frac{n}{2} } \\neq \\omega_n ^ 0 \\ $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv -1 \\pmod p $ $ \\omega_n ^ { k + \\frac{n}{2} } = \\omega_n ^ k \\times \\omega_n ^ { \\frac{n}{2} } \\equiv -\\omega_n ^ k \\pmod p $****\n\n#### \n $ k \\neq 0 $ \n\n$$\n\\begin{aligned}\nS(\\omega_n ^ k) &= 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} \\\\\n\\omega_n ^ k S(\\omega_n ^ k) &= \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n \\\\\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{aligned}\n$$\n\n****$ (\\omega_n ^ k) ^ n - 1 \\equiv 0 \\pmod p $ $ S(\\omega_n ^ k) \\equiv 0  \\pmod p $****\n\n### \n   $ g $ $ g $  $ p $ \n\n>  $ g $ $ g ^ k \\equiv 1 \\pmod p $  $ k $  $ p - 1 $ \n\n $ k $  $ p - 1 $  $ x $  $ xk > p - 1 > (x - 1)k $\n\n$$ g ^ {xk} \\equiv g ^ {p - 1} \\equiv 1 \\equiv g ^ {xk - (p - 1)} \\pmod p $$\n\n$ xk - (p - 1) < k $\n\n $ p - 1 $  $ q $ $ g ^ q \\not\\equiv 1 \\pmod p $ \n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n```\n\n### \n\n\n $ \\div n $  $ \\times n ^ {-1} $\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n} ntt;\n```\n","source":"_posts/fft-to-ntt.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \n  - \npermalink: fft-to-ntt\ndate: 2016-06-17 21:38:00\n---\n\nFFT Number-Theoretic Transform\n\n<!-- more -->\n\n### \nFFT  $ \\omega_n ^ k = \\cos \\frac{2 \\pi}{n}k + i \\sin\\frac{2 \\pi}{n}k $\n\n1. $ \\omega_n ^ t (0 \\leq t \\leq n - 1) $ \n2. $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n3. $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n3.  $ k \\neq 0 $ $ 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} = 0 $\n\n $ p = qn + 1 $ $ n $  $ 2 $ **** $ g $  $ g ^ i(0 \\leq i \\leq p - 1) $ \n\n#### \n\n $ \\omega_n = g ^ q $ $ 1,\\ g ^ q,\\ g ^ {2q},\\ \\dots,\\ g ^ {(n - 1)q} $ ****\n\n#### \n\n $ \\omega_n = g ^ q $  $ \\omega_{2n} = g ^ { \\frac{q}{2} } $$ p = \\frac{q}{2} \\times 2n + 1 $ $ \\omega_{2n} ^ {2k} = g ^ {2k \\frac{q}{2} } = g ^ {kq} = \\omega_n ^ k $****\n\n#### \n\n\n\n$$ \\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ (\\omega_{n} ^ { \\frac{n}{2} }) ^ 2 = \\omega_n ^ n $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv \\pm 1 \\pmod p $ $ \\omega_n ^ { \\frac{n}{2} } \\neq \\omega_n ^ 0 \\ $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv -1 \\pmod p $ $ \\omega_n ^ { k + \\frac{n}{2} } = \\omega_n ^ k \\times \\omega_n ^ { \\frac{n}{2} } \\equiv -\\omega_n ^ k \\pmod p $****\n\n#### \n $ k \\neq 0 $ \n\n$$\n\\begin{aligned}\nS(\\omega_n ^ k) &= 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} \\\\\n\\omega_n ^ k S(\\omega_n ^ k) &= \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n \\\\\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{aligned}\n$$\n\n****$ (\\omega_n ^ k) ^ n - 1 \\equiv 0 \\pmod p $ $ S(\\omega_n ^ k) \\equiv 0  \\pmod p $****\n\n### \n   $ g $ $ g $  $ p $ \n\n>  $ g $ $ g ^ k \\equiv 1 \\pmod p $  $ k $  $ p - 1 $ \n\n $ k $  $ p - 1 $  $ x $  $ xk > p - 1 > (x - 1)k $\n\n$$ g ^ {xk} \\equiv g ^ {p - 1} \\equiv 1 \\equiv g ^ {xk - (p - 1)} \\pmod p $$\n\n$ xk - (p - 1) < k $\n\n $ p - 1 $  $ q $ $ g ^ q \\not\\equiv 1 \\pmod p $ \n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n```\n\n### \n\n\n $ \\div n $  $ \\times n ^ {-1} $\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n} ntt;\n```\n","slug":"fft-to-ntt","published":1,"updated":"2016-06-17T13:38:12.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiln012o0jxlxvtoz74o"},{"title":"FFT ","date":"2016-06-03T11:41:00.000Z","_content":"\nFast Fourier TransformFFT $ O(n \\log n) $ Discrete Fourier transformDFT OI \n\n<!-- more -->\n\n### \n#### \n##### \n $ A(x) $  $ n - 1 $  $ n $  $ ( a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1} ) $ \n\n$$\n\\begin{align*}\nA(x) &= \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i \\\\\n&= a_0 + a_1 x + a_2 x ^ 2 + \\dots + a_{n - 1} x ^ {n - 1}\n\\end{align*}\n$$\n\n**** $ n $  $ x $  $ n $  $ n $  $ ( x_0,\\ x_1,\\ x_2,\\ \\dots,\\ x_{n - 1} ) $$ ( y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1} ) $\n\n$$\n\\begin{align*}\ny_i &= A(x_i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j x_i\n\\end{align*}\n$$\n\n##### \n>  $ n - 1 $  $ n $ \n\n $ n - 1 $  $ A(x) $$ B(x) $ $ i \\in [0,\\ n - 1] $ $ A(x_i) = B(x_i) $\n\n $ C(x) = A(x) - B(x) $ $ C(x) $  $ n - 1 $  $ i \\in [0,\\ n - 1] $ $ C(x_i) = 0 $\n\n $ C(x) $  $ n $  $ n - 1 $  $ n - 1 $  $ C(x) $  $ n - 1 $ \n\n $ O(n ^ 2) $\n\n**** $ O(n ^ 2) $\n\n##### \n $ A(x) = \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i $  $ B(x) = \\sum\\limits_{i = 0} ^ {n - 1} b_i x ^ i $  $ C(x) $\n\n$$ C(x) = A(x) \\times B(x) = \\sum\\limits_{k = 0} ^ {2n - 2} (\\sum\\limits_{k = i + j} a_i b_j) x_k $$\n\n $ n - 1 $  $ 2n - 2 $  $ O(n ^ 2) $\n\n $ 2n - 1 $ \n\n$$ {y_3}_i = (\\sum\\limits_{j = 0} ^ {2n - 1} a_j x_i) \\times (\\sum\\limits_{j = 0} ^ {2n - 1} b_j x_i) = {y_1}_i \\times {y_2}_i $$\n\n $ O(n) $\n\n#### \n $ a $$ b $ $ i ^ 2 = -1 $ $ a + bi $ **** $ i $ ****\n\n##### \n$ x $ $ y $  $ a + bi $  $ (0,\\ 0) $  $ (a,\\ b) $ \n\n $ \\sqrt {a ^ 2 + b ^ 2} $  $ x $ \n\n\n\n\n\n### \n $ n $  $ 2 $ \n\n$ 1 $  $ n $  $ n $ **** $ \\omega_n $ $ n $ \n\n $ n - 1 $  $ \\omega_n ^ 2,\\ \\omega_n ^ 3,\\ \\dots,\\ \\omega_n ^ n $ $ \\omega_n ^ n = \\omega_n ^ 0 = 1 $\n\n $ 1 \\over n $\n\n$$ \\omega_n ^ k = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n#### \n\n> $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n\n\n\n\n\n$$ \\cos 2k \\frac{2 \\pi}{2n} + i\\sin 2k \\frac{2 \\pi}{2n} = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n> $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n\n $ \\omega_n ^ k $  $ \\omega_n ^ { \\frac{n}{2} } $\n\n$$\n\\begin{align*}\n\\omega_n ^ { \\frac{n}{2} } &= \\cos \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} + i\\sin \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} \\\\\n&= \\cos \\pi + i\\sin \\pi \\\\\n&= -1\n\\end{align*}\n$$\n\n### \n $ A(x) $  $ n $  $ 0 $  $ n - 1 $  $ (A(\\omega_n ^ 0),\\ A(\\omega_n ^ 1),\\ \\dots,\\ A(\\omega_n ^ {n - 1})) $  $ (a_0,\\ a_1,\\ \\dots,\\ a_{n - 1}) $ ****\n\n $ O(n ^ 2) $\n\n\n\n$$ A(x) = (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + \\dots + a_{n - 2} x ^ {n - 2}) + (a_1 x + a_3 x ^ 3 + a_5 x ^ 5 + \\dots + a_{n - 1} x ^ {n - 1}) $$\n\n\n\n$$\n\\begin{align*}\nA_1(x) &= a_0 + a_2 x + a_4 x ^ 2 + \\dots + a_{n - 2} x ^ {\\frac{n}{2} - 1} \\\\\nA_2(x) &= a_1 + a_3 x + a_5 x ^ 2 + \\dots + a_{n - 1} x ^ {\\frac{n}{2} - 1}\n\\end{align*}\n$$\n\n\n\n$$ A(x) = A_1(x ^ 2) + x A_2(x ^ 2) $$\n\n $ k < \\frac{n}{2} $ $ A(\\omega_n ^ k) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ k) &= A_1(\\omega_n ^ {2k}) + \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) + \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n\n\n $ A(\\omega_n ^ {k + \\frac{n}{2}}) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ {k + \\frac{n}{2}}) &= A_1(\\omega_n ^ {2k + n}) + \\omega_n ^ {k + \\frac{n}{2}} A_2(\\omega_n ^ {2k + n}) \\\\\n&= A_1(\\omega_n ^ {2k} \\times \\omega_n ^ n) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k} \\times \\omega_n ^ n) \\\\\n&= A_1(\\omega_n ^ {2k}) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) - \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n $ \\omega_n ^ n = 1 $ \n\n $ k $  $ [0,\\ \\frac{n}{2} - 1] $ $ k $  $ k + \\frac{n}{2} $  $ [0,\\ n - 1] $\n\n $ A_1(x) $  $ A_2(x) $  $ \\omega_{ \\frac{n}{2} } ^ 0,\\ \\omega_{ \\frac{n}{2} } ^ 1,\\ \\dots,\\ \\omega_{ \\frac{n}{2} } ^ { \\frac{n}{2} - 1 } $  $ O(n) $  $ A(x) $  $ \\omega_n ^ 0,\\ \\omega_n ^ 1,\\ \\dots,\\ \\omega_n ^ {n - 1} $  $ A_1(x) $  $ A_2(x) $  $ a_0 $\n\n\n\n$$ T(n) = 2T( \\frac{n}{2} ) + O(n) = O(n \\log n) $$\n\n FFT   Cooley-Tukey \n\n### \n****\n\n $ (y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1}) $  $ (a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1}) $  $ (c_0,\\ c_1,\\ c_2,\\ \\dots,\\ c_{n - 1}) $ \n\n$$\nc_k = \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i\n$$\n\n $ B(x) = y_0 + y_1 x + y_2 x ^ 2 + \\dots + y_{n - 1} x ^ {n - 1} $  $ \\omega_n ^ 0,\\ \\omega_n ^ {-1},\\ \\omega_n ^ {-2},\\ \\dots,\\  \\omega_n ^ {-(n - 1)} $ \n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ i) ^ j) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i (\\omega_n ^ {-k}) ^ i) \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ {j - k}) ^ i \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i)\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} $$\n\n $ k \\neq 0 $  $ \\omega_n ^ k $ \n\n$$ \\omega_n ^ k S(\\omega_n ^ k) = \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n $$\n\n\n\n$$\n\\begin{align*}\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 0 $$\n\n $ k = 0 $  $ S(\\omega_n ^ k) = n $\n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j S(\\omega_n ^ {j - k})\n\\end{align*}\n$$\n\n $ j = k $ $ S(\\omega_n ^ {j - k}) = n $ $ S(\\omega_n ^ {j - k}) = 0 $\n\n$$\n\\begin{align*}\nc_i &= n a_i \\\\\na_i &= \\frac{1}{n} c_i\n\\end{align*}\n$$\n\n $ n $\n\n### \nC++  STL  `complex`  `std::complex<T>` `T`  `double` `long double`  `__float128`\n\n `std::conj()`  IDFT \n\n#### \n\n\n##### \n\n```c++\nconst double PI = acos(-1);\n\nbool inversed = false;\n\ninline std::complex<double> omega(const int n, const int k) {\n    if (!inversed) return std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k));\n    else return std::conj(std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k)));\n}\n\ninline void transform(std::complex<double> *a, const int n) {\n    if (n == 1) return;\n\n    static std::complex<double> buf[MAXN];\n    const int m = n / 2;\n    // \n    for (int i = 0; i < m; i++) {\n        buf[i] = a[i * 2];\n        buf[i + m] = a[i * 2 + 1];\n    }\n    std::copy(buf, buf + n, a);\n\n    // \n    std::complex<double> *a1 = a, *a2 = a + m;\n    fft(a1, m);\n    fft(a2, m);\n\n    // \n    for (int i = 0; i < m; i++) {\n        std::complex<double> x = omega(n, i);\n        buf[i] = a1[i] + x * a2[i];\n        buf[i + m] = a1[i] - x * a2[i];\n    }\n\n    std::copy(buf, buf + n, a);\n}\n```\n\n#### \n FFT \n\n##### \n FFT \n\n```plain\n000 001 010 011 100 101 110 111\n 0   1   2   3   4   5   6   7\n 0   2   4   6 - 1   3   5   7\n 0   4 - 2   6 - 1   5 - 3   7\n 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7\n000 100 010 110 001 101 011 111\n```\n\n\n\n\n\n```c++\nint k = 0;\nwhile ((1 << k) < n) k++;\nfor (int i = 0; i < n; i++) {\n    int t = 0;\n    for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n    if (i < t) std::swap(a[i], a[t]);\n}\n```\n\n##### \n $ A_1(\\omega_{ \\frac{n}{2} } ^ k) $  $ A_2(\\omega_{ \\frac{n}{2} } ^ k) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ b(k) $  $ b(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nb(k) & \\leftarrow a(k) + \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\nb(\\frac{n}{2} + k) & \\leftarrow a(k) - \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\n\\end{align*}\n$$\n\n $ t $ $ b $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nt & \\leftarrow \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\na(\\frac{n}{2} + k) & \\leftarrow a(k) - t \\\\\na(k) & \\leftarrow a(k) + t \\\\\n\\end{align*}\n$$\n\n****\n\n##### \n`omega[k]`  $ \\omega_n ^ k $IDFT  $ \\omega_n ^ {-k} $\n\n $ l $ $ \\frac{l}{2} $  $ l $  $ \\omega_l ^ k = \\omega_n ^ { \\frac{n}{l} k } $\n\n```c++\nvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n    // \n    for (int l = 2; l <= n; l *= 2) {\n        int m = l / 2;\n        //  m  l \n        for (std::complex<double> *p = a; p != a + n; p += l) {\n            for (int i = 0; i < m; i++) {\n                // \n                std::complex<double> t = omega[n / l * i] * p[m + i];\n                p[m + i] = p[i] - t;\n                p[i] += t;\n            }\n        }\n    }\n}\n```\n\n### \n $ n_1 - 1 $  $ n_2 - 1 $ **** $ n_1 + n_2 - 1 $  $ n_1 + n_2 - 2 $ \n\n```c++\nstruct FastFourierTransform {\n    std::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n    void init(const int n) {\n        for (int i = 0; i < n; i++) {\n            omega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n            omegaInverse[i] = std::conj(omega[i]);\n        }\n    }\n\n    void transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n            if (i < t) std::swap(a[i], a[t]);\n        }\n\n        for (int l = 2; l <= n; l *= 2) {\n            int m = l / 2;\n            for (std::complex<double> *p = a; p != a + n; p += l) {\n                for (int i = 0; i < m; i++) {\n                    std::complex<double> t = omega[n / l * i] * p[m + i];\n                    p[m + i] = p[i] - t;\n                    p[i] += t;\n                }\n            }\n        }\n    }\n\n    void dft(std::complex<double> *a, const int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(std::complex<double> *a, const int n) {\n        transform(a, n, omegaInverse);\n        for (int i = 0; i < n; i++) a[i] /= n;\n    }\n} fft;\n\ninline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) {\n    int n = 1;\n    while (n < n1 + n2) n *= 2;\n    static std::complex<double> c1[MAXN], c2[MAXN];\n    for (int i = 0; i < n1; i++) c1[i].real(a1[i]);\n    for (int i = 0; i < n2; i++) c2[i].real(a2[i]);\n    fft.init(n);\n    fft.dft(c1, n), fft.dft(c2, n);\n    for (int i = 0; i < n; i++) c1[i] *= c2[i];\n    fft.idft(c1, n);\n    for (int i = 0; i < n1 + n2 - 1; i++) res[i] = static_cast<int>(floor(c1[i].real() + 0.5));\n}\n```\n\n### \n* [ - ](https://zh.wikipedia.org/zh/%E5%A4%9A%E9%A0%85%E5%BC%8F)Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%B9%B3%E9%9D%A2)Wikipedia\n* [ () - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)Wikipedia\n* [FFT & NTT | ZYK1997](http://zyk1997.github.io/2015/06/08/FFT/)ZYK1997\n* [BZOJ 3992 SDOI2015  - Fuxey -  - CSDN.NET](http://blog.csdn.net/fuxey/article/details/50840881)Fuxey\n* [ - Miskcoo's Space](http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform)Miskcoo\n* [OI  FFT - zball - ](http://www.cnblogs.com/tmzbot/p/4320955.html)zball\n* [Fourier transform](https://pan.baidu.com/wap/album/file?uk=3325080974&album_id=2474841267539644259&fsid=845742707277510&adapt=pc&fr=ftw)\n","source":"_posts/fft-notes.md","raw":"title: FFT \ncategories: OI\ntags: \n  - FFT\n  - \n  - \n  - \n  - \npermalink: fft-notes\ndate: 2016-06-03 19:41:00\n---\n\nFast Fourier TransformFFT $ O(n \\log n) $ Discrete Fourier transformDFT OI \n\n<!-- more -->\n\n### \n#### \n##### \n $ A(x) $  $ n - 1 $  $ n $  $ ( a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1} ) $ \n\n$$\n\\begin{align*}\nA(x) &= \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i \\\\\n&= a_0 + a_1 x + a_2 x ^ 2 + \\dots + a_{n - 1} x ^ {n - 1}\n\\end{align*}\n$$\n\n**** $ n $  $ x $  $ n $  $ n $  $ ( x_0,\\ x_1,\\ x_2,\\ \\dots,\\ x_{n - 1} ) $$ ( y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1} ) $\n\n$$\n\\begin{align*}\ny_i &= A(x_i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j x_i\n\\end{align*}\n$$\n\n##### \n>  $ n - 1 $  $ n $ \n\n $ n - 1 $  $ A(x) $$ B(x) $ $ i \\in [0,\\ n - 1] $ $ A(x_i) = B(x_i) $\n\n $ C(x) = A(x) - B(x) $ $ C(x) $  $ n - 1 $  $ i \\in [0,\\ n - 1] $ $ C(x_i) = 0 $\n\n $ C(x) $  $ n $  $ n - 1 $  $ n - 1 $  $ C(x) $  $ n - 1 $ \n\n $ O(n ^ 2) $\n\n**** $ O(n ^ 2) $\n\n##### \n $ A(x) = \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i $  $ B(x) = \\sum\\limits_{i = 0} ^ {n - 1} b_i x ^ i $  $ C(x) $\n\n$$ C(x) = A(x) \\times B(x) = \\sum\\limits_{k = 0} ^ {2n - 2} (\\sum\\limits_{k = i + j} a_i b_j) x_k $$\n\n $ n - 1 $  $ 2n - 2 $  $ O(n ^ 2) $\n\n $ 2n - 1 $ \n\n$$ {y_3}_i = (\\sum\\limits_{j = 0} ^ {2n - 1} a_j x_i) \\times (\\sum\\limits_{j = 0} ^ {2n - 1} b_j x_i) = {y_1}_i \\times {y_2}_i $$\n\n $ O(n) $\n\n#### \n $ a $$ b $ $ i ^ 2 = -1 $ $ a + bi $ **** $ i $ ****\n\n##### \n$ x $ $ y $  $ a + bi $  $ (0,\\ 0) $  $ (a,\\ b) $ \n\n $ \\sqrt {a ^ 2 + b ^ 2} $  $ x $ \n\n\n\n\n\n### \n $ n $  $ 2 $ \n\n$ 1 $  $ n $  $ n $ **** $ \\omega_n $ $ n $ \n\n $ n - 1 $  $ \\omega_n ^ 2,\\ \\omega_n ^ 3,\\ \\dots,\\ \\omega_n ^ n $ $ \\omega_n ^ n = \\omega_n ^ 0 = 1 $\n\n $ 1 \\over n $\n\n$$ \\omega_n ^ k = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n#### \n\n> $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n\n\n\n\n\n$$ \\cos 2k \\frac{2 \\pi}{2n} + i\\sin 2k \\frac{2 \\pi}{2n} = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n> $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n\n $ \\omega_n ^ k $  $ \\omega_n ^ { \\frac{n}{2} } $\n\n$$\n\\begin{align*}\n\\omega_n ^ { \\frac{n}{2} } &= \\cos \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} + i\\sin \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} \\\\\n&= \\cos \\pi + i\\sin \\pi \\\\\n&= -1\n\\end{align*}\n$$\n\n### \n $ A(x) $  $ n $  $ 0 $  $ n - 1 $  $ (A(\\omega_n ^ 0),\\ A(\\omega_n ^ 1),\\ \\dots,\\ A(\\omega_n ^ {n - 1})) $  $ (a_0,\\ a_1,\\ \\dots,\\ a_{n - 1}) $ ****\n\n $ O(n ^ 2) $\n\n\n\n$$ A(x) = (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + \\dots + a_{n - 2} x ^ {n - 2}) + (a_1 x + a_3 x ^ 3 + a_5 x ^ 5 + \\dots + a_{n - 1} x ^ {n - 1}) $$\n\n\n\n$$\n\\begin{align*}\nA_1(x) &= a_0 + a_2 x + a_4 x ^ 2 + \\dots + a_{n - 2} x ^ {\\frac{n}{2} - 1} \\\\\nA_2(x) &= a_1 + a_3 x + a_5 x ^ 2 + \\dots + a_{n - 1} x ^ {\\frac{n}{2} - 1}\n\\end{align*}\n$$\n\n\n\n$$ A(x) = A_1(x ^ 2) + x A_2(x ^ 2) $$\n\n $ k < \\frac{n}{2} $ $ A(\\omega_n ^ k) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ k) &= A_1(\\omega_n ^ {2k}) + \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) + \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n\n\n $ A(\\omega_n ^ {k + \\frac{n}{2}}) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ {k + \\frac{n}{2}}) &= A_1(\\omega_n ^ {2k + n}) + \\omega_n ^ {k + \\frac{n}{2}} A_2(\\omega_n ^ {2k + n}) \\\\\n&= A_1(\\omega_n ^ {2k} \\times \\omega_n ^ n) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k} \\times \\omega_n ^ n) \\\\\n&= A_1(\\omega_n ^ {2k}) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) - \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n $ \\omega_n ^ n = 1 $ \n\n $ k $  $ [0,\\ \\frac{n}{2} - 1] $ $ k $  $ k + \\frac{n}{2} $  $ [0,\\ n - 1] $\n\n $ A_1(x) $  $ A_2(x) $  $ \\omega_{ \\frac{n}{2} } ^ 0,\\ \\omega_{ \\frac{n}{2} } ^ 1,\\ \\dots,\\ \\omega_{ \\frac{n}{2} } ^ { \\frac{n}{2} - 1 } $  $ O(n) $  $ A(x) $  $ \\omega_n ^ 0,\\ \\omega_n ^ 1,\\ \\dots,\\ \\omega_n ^ {n - 1} $  $ A_1(x) $  $ A_2(x) $  $ a_0 $\n\n\n\n$$ T(n) = 2T( \\frac{n}{2} ) + O(n) = O(n \\log n) $$\n\n FFT   Cooley-Tukey \n\n### \n****\n\n $ (y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1}) $  $ (a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1}) $  $ (c_0,\\ c_1,\\ c_2,\\ \\dots,\\ c_{n - 1}) $ \n\n$$\nc_k = \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i\n$$\n\n $ B(x) = y_0 + y_1 x + y_2 x ^ 2 + \\dots + y_{n - 1} x ^ {n - 1} $  $ \\omega_n ^ 0,\\ \\omega_n ^ {-1},\\ \\omega_n ^ {-2},\\ \\dots,\\  \\omega_n ^ {-(n - 1)} $ \n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ i) ^ j) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i (\\omega_n ^ {-k}) ^ i) \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ {j - k}) ^ i \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i)\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} $$\n\n $ k \\neq 0 $  $ \\omega_n ^ k $ \n\n$$ \\omega_n ^ k S(\\omega_n ^ k) = \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n $$\n\n\n\n$$\n\\begin{align*}\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 0 $$\n\n $ k = 0 $  $ S(\\omega_n ^ k) = n $\n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j S(\\omega_n ^ {j - k})\n\\end{align*}\n$$\n\n $ j = k $ $ S(\\omega_n ^ {j - k}) = n $ $ S(\\omega_n ^ {j - k}) = 0 $\n\n$$\n\\begin{align*}\nc_i &= n a_i \\\\\na_i &= \\frac{1}{n} c_i\n\\end{align*}\n$$\n\n $ n $\n\n### \nC++  STL  `complex`  `std::complex<T>` `T`  `double` `long double`  `__float128`\n\n `std::conj()`  IDFT \n\n#### \n\n\n##### \n\n```c++\nconst double PI = acos(-1);\n\nbool inversed = false;\n\ninline std::complex<double> omega(const int n, const int k) {\n    if (!inversed) return std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k));\n    else return std::conj(std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k)));\n}\n\ninline void transform(std::complex<double> *a, const int n) {\n    if (n == 1) return;\n\n    static std::complex<double> buf[MAXN];\n    const int m = n / 2;\n    // \n    for (int i = 0; i < m; i++) {\n        buf[i] = a[i * 2];\n        buf[i + m] = a[i * 2 + 1];\n    }\n    std::copy(buf, buf + n, a);\n\n    // \n    std::complex<double> *a1 = a, *a2 = a + m;\n    fft(a1, m);\n    fft(a2, m);\n\n    // \n    for (int i = 0; i < m; i++) {\n        std::complex<double> x = omega(n, i);\n        buf[i] = a1[i] + x * a2[i];\n        buf[i + m] = a1[i] - x * a2[i];\n    }\n\n    std::copy(buf, buf + n, a);\n}\n```\n\n#### \n FFT \n\n##### \n FFT \n\n```plain\n000 001 010 011 100 101 110 111\n 0   1   2   3   4   5   6   7\n 0   2   4   6 - 1   3   5   7\n 0   4 - 2   6 - 1   5 - 3   7\n 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7\n000 100 010 110 001 101 011 111\n```\n\n\n\n\n\n```c++\nint k = 0;\nwhile ((1 << k) < n) k++;\nfor (int i = 0; i < n; i++) {\n    int t = 0;\n    for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n    if (i < t) std::swap(a[i], a[t]);\n}\n```\n\n##### \n $ A_1(\\omega_{ \\frac{n}{2} } ^ k) $  $ A_2(\\omega_{ \\frac{n}{2} } ^ k) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ b(k) $  $ b(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nb(k) & \\leftarrow a(k) + \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\nb(\\frac{n}{2} + k) & \\leftarrow a(k) - \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\n\\end{align*}\n$$\n\n $ t $ $ b $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nt & \\leftarrow \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\na(\\frac{n}{2} + k) & \\leftarrow a(k) - t \\\\\na(k) & \\leftarrow a(k) + t \\\\\n\\end{align*}\n$$\n\n****\n\n##### \n`omega[k]`  $ \\omega_n ^ k $IDFT  $ \\omega_n ^ {-k} $\n\n $ l $ $ \\frac{l}{2} $  $ l $  $ \\omega_l ^ k = \\omega_n ^ { \\frac{n}{l} k } $\n\n```c++\nvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n    // \n    for (int l = 2; l <= n; l *= 2) {\n        int m = l / 2;\n        //  m  l \n        for (std::complex<double> *p = a; p != a + n; p += l) {\n            for (int i = 0; i < m; i++) {\n                // \n                std::complex<double> t = omega[n / l * i] * p[m + i];\n                p[m + i] = p[i] - t;\n                p[i] += t;\n            }\n        }\n    }\n}\n```\n\n### \n $ n_1 - 1 $  $ n_2 - 1 $ **** $ n_1 + n_2 - 1 $  $ n_1 + n_2 - 2 $ \n\n```c++\nstruct FastFourierTransform {\n    std::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n    void init(const int n) {\n        for (int i = 0; i < n; i++) {\n            omega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n            omegaInverse[i] = std::conj(omega[i]);\n        }\n    }\n\n    void transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n            if (i < t) std::swap(a[i], a[t]);\n        }\n\n        for (int l = 2; l <= n; l *= 2) {\n            int m = l / 2;\n            for (std::complex<double> *p = a; p != a + n; p += l) {\n                for (int i = 0; i < m; i++) {\n                    std::complex<double> t = omega[n / l * i] * p[m + i];\n                    p[m + i] = p[i] - t;\n                    p[i] += t;\n                }\n            }\n        }\n    }\n\n    void dft(std::complex<double> *a, const int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(std::complex<double> *a, const int n) {\n        transform(a, n, omegaInverse);\n        for (int i = 0; i < n; i++) a[i] /= n;\n    }\n} fft;\n\ninline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) {\n    int n = 1;\n    while (n < n1 + n2) n *= 2;\n    static std::complex<double> c1[MAXN], c2[MAXN];\n    for (int i = 0; i < n1; i++) c1[i].real(a1[i]);\n    for (int i = 0; i < n2; i++) c2[i].real(a2[i]);\n    fft.init(n);\n    fft.dft(c1, n), fft.dft(c2, n);\n    for (int i = 0; i < n; i++) c1[i] *= c2[i];\n    fft.idft(c1, n);\n    for (int i = 0; i < n1 + n2 - 1; i++) res[i] = static_cast<int>(floor(c1[i].real() + 0.5));\n}\n```\n\n### \n* [ - ](https://zh.wikipedia.org/zh/%E5%A4%9A%E9%A0%85%E5%BC%8F)Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%B9%B3%E9%9D%A2)Wikipedia\n* [ () - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)Wikipedia\n* [FFT & NTT | ZYK1997](http://zyk1997.github.io/2015/06/08/FFT/)ZYK1997\n* [BZOJ 3992 SDOI2015  - Fuxey -  - CSDN.NET](http://blog.csdn.net/fuxey/article/details/50840881)Fuxey\n* [ - Miskcoo's Space](http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform)Miskcoo\n* [OI  FFT - zball - ](http://www.cnblogs.com/tmzbot/p/4320955.html)zball\n* [Fourier transform](https://pan.baidu.com/wap/album/file?uk=3325080974&album_id=2474841267539644259&fsid=845742707277510&adapt=pc&fr=ftw)\n","slug":"fft-notes","published":1,"updated":"2016-06-17T13:39:35.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jilu012x0jxlco5jltml"},{"title":"","date":"2016-04-08T05:14:55.000Z","_content":"\n $ O(n) $  $ [1, n] $  $ O(n) $ \n\n<!-- more -->\n\n### \n $ \\phi(n) $  $ n $  $ n $ $ \\phi(1) = 1 $\n\n $ n $  $ \\phi(n) = n - 1 $\n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ $ n' $  $ n $ \n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ p_1 $ \n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### \n $ \\mu(n) $ \n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n $ n $  $ \\mu(n) = -1 $\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ \n\n$$ \\mu(n) = 0 $$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ N - 1 $  $ \\mu(n') \\neq 0 $ $ n' $  $ 1 $\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n $ \\mu(n') = 0 $ $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $\n\n$$ \\mu(n) = 0 $$\n\n $ \\mu(n) = -\\mu(n') $ \n\n\n### \n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","source":"_posts/euler-sieve.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: euler-sieve\ndate: 2016-04-08 13:14:55\n---\n\n $ O(n) $  $ [1, n] $  $ O(n) $ \n\n<!-- more -->\n\n### \n $ \\phi(n) $  $ n $  $ n $ $ \\phi(1) = 1 $\n\n $ n $  $ \\phi(n) = n - 1 $\n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ $ n' $  $ n $ \n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ p_1 $ \n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### \n $ \\mu(n) $ \n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n $ n $  $ \\mu(n) = -1 $\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ \n\n$$ \\mu(n) = 0 $$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ N - 1 $  $ \\mu(n') \\neq 0 $ $ n' $  $ 1 $\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n $ \\mu(n') = 0 $ $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $\n\n$$ \\mu(n) = 0 $$\n\n $ \\mu(n) = -\\mu(n') $ \n\n\n### \n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","slug":"euler-sieve","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jim001340jxlpt0wtodf"},{"title":"Edmonds-Karp ","date":"2016-02-19T09:04:38.000Z","_content":"\n Edmonds-Karp  Dinic  Edmonds-Karp \n\n<!-- more -->\n\n### \n`cost`\n\n Dinic  Edmonds-Karp \n\nEdmonds-Karp \n\n### \n1. \n2. ****  ****\n3. \n\n Bellman-Ford \n\nEdmonds-Karp \n\n### \n```cpp\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","source":"_posts/edmonds-karp-notes.md","raw":"title: Edmonds-Karp \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Edmonds-Karp\n  - \n  -   \npermalink: edmonds-karp-notes\ndate: 2016-02-19 17:04:38\n---\n\n Edmonds-Karp  Dinic  Edmonds-Karp \n\n<!-- more -->\n\n### \n`cost`\n\n Dinic  Edmonds-Karp \n\nEdmonds-Karp \n\n### \n1. \n2. ****  ****\n3. \n\n Bellman-Ford \n\nEdmonds-Karp \n\n### \n```cpp\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","slug":"edmonds-karp-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jim6013b0jxlsevs3mok"},{"title":"Dinic ","date":"2016-02-03T10:57:59.000Z","_content":"\nDinic $ O(n^2m) $\n\n<!-- more -->\n\n### \n* `capacity(e)`  `e(u, v)` \n\n* `flow(e)`  `e(u, v)` \n\n*  `capacity(e) - flow(e)` `e(u, v)` \n\n*  0\n\n* \n\n* augmenting path****\n\n* augmenting****\n\n*  `level(u)`  `u` \n\n* ********\n\n### \n1. \n2. \n3.  `(2)` `(1)` \n4. \n\n\n\n### \nDinic \n\n DFS \n\n### \n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","source":"_posts/dinic-notes.md","raw":"title: Dinic \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Dinic\n  -   \npermalink: dinic-notes\ndate: 2016-02-03 18:57:59\n---\n\nDinic $ O(n^2m) $\n\n<!-- more -->\n\n### \n* `capacity(e)`  `e(u, v)` \n\n* `flow(e)`  `e(u, v)` \n\n*  `capacity(e) - flow(e)` `e(u, v)` \n\n*  0\n\n* \n\n* augmenting path****\n\n* augmenting****\n\n*  `level(u)`  `u` \n\n* ********\n\n### \n1. \n2. \n3.  `(2)` `(1)` \n4. \n\n\n\n### \nDinic \n\n DFS \n\n### \n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","slug":"dinic-notes","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jimd013j0jxl73ghnjmo"},{"title":"","date":"2016-04-13T07:41:16.000Z","_content":"\n $ 1 $ ~ $ n $ \n\n<!-- more -->\n\n $ f(n) $\n\n $ n $  $ n - 1 $  $ 1 $\n\n $ n $  $ n $  $ 1 $  $ n $  $ 1 $ $ f(n - 1) $\n\n   $ n $  1  1  $ n $  1  $ f(n - 2) $\n\n\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","source":"_posts/derangement-number.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \npermalink: derangement-number\ndate: 2016-04-13 15:41:16\n---\n\n $ 1 $ ~ $ n $ \n\n<!-- more -->\n\n $ f(n) $\n\n $ n $  $ n - 1 $  $ 1 $\n\n $ n $  $ n $  $ 1 $  $ n $  $ 1 $ $ f(n - 1) $\n\n   $ n $  1  1  $ n $  1  $ f(n - 2) $\n\n\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","slug":"derangement-number","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jimj013q0jxlxjwyuv2u"},{"title":"","date":"2015-12-27T14:48:11.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n****\n\n### \n![CutTree](cut-tree-notes/cutTree.png)\n\n********\n\n**** $O({\\log}n)$\n\n### \n```cpp\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n```\n\n`depth` `size` `maxSizeChild` `maxDepth`  `maxSizeChild` \n\nPath `top` `pos` \n\n### \n `DFS` `maxSizeChild`  `maxDepth`\n\n```cpp\nstack<Tree *> s;\n\ns.push(root);\nwhile (!s.empty()) {\n\tTree *tree = s.top();\n\tif (tree->visited) {\n\t\ttree->size = 1;\n\t\ttree->maxDepth = tree->depth;\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ttree->size += child->size;\n\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t}\n\t\t}\n\n\t\ts.pop();\n\t} else {\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ts.push(child);\n\t\t}\n\n\t\ttree->visited = true;\n\t}\n}\n```\n\n`DFS`  `BFS`  `BFS`  `BFS`  \n\n `maxDepthChild`\n\n```cpp\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n```\n\n\n\n```cpp\nfor (uint i = 0; i < n; i++) {\n\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n}\n```\n\n### \n\n\n```cpp\ninline void update(uint x, uint w) {\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n```\n\n### \n `[u, v]` \n\n1.  `u`  `v` ******** 1\n2.  `u`  `v` \n\n```cpp\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n```\n\n### \n \n\n```cpp\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### \n zkw \n\n```cpp\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n```\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing std::queue;\nusing std::stack;\nusing std::swap;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 30000;\n\nstruct Node {\n\tstruct Edge *edges;\n\tuint id;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, Edge *next) : from(from), to(to), next(next) {}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n\nuint n, q;\n\ninline void addEdge(uint a, uint b) {\n\tnodes[a].edges = new Edge(&nodes[a], &nodes[b], nodes[a].edges);\n\tnodes[b].edges = new Edge(&nodes[b], &nodes[a], nodes[b].edges);\n}\n\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void cut() {\n\tstack<Tree *> s;\n\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *tree = s.top();\n\t\tif (tree->visited) {\n\t\t\ttree->size = 1;\n\t\t\ttree->maxDepth = tree->depth;\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ttree->size += child->size;\n\t\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t} else {\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ts.push(child);\n\t\t\t}\n\n\t\t\ttree->visited = true;\n\t\t}\n\t}\n\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n\t}\n}\n\ninline void update(uint x, uint w) {\n\ttreeNodes[x].w = w;\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n\ninline int queryMax(uint u, uint v) {\n\tint result = INT_MIN;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult = std::max(result, a->path->segmentTree->queryMax(0, a->pos));\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult = std::max(result, a->path->segmentTree->queryMax(a->pos, b->pos));\n\treturn result;\n}\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tfor (uint i = 0; i < n - 1; i++) {\n\t\tuint a, b;\n\t\tscanf(\"%u %u\", &a, &b);\n\t\ta--, b--;\n\n\t\taddEdge(a, b);\n\t}\n\n\tconvert();\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint w;\n\t\tscanf(\"%u\", &w);\n\t\ttreeNodes[i].w = w;\n\t}\n\n\tcut();\n\n\tscanf(\"%u\", &q);\n\n\tfor (uint i = 0; i < q; i++) {\n\t\tchar command[6 + 1];\n\t\tscanf(\"%s\", command);\n\t\tif (command[1] == 'H') { // CHANGE\n\t\t\tuint x;\n\t\t\tint w;\n\t\t\tscanf(\"%u %d\", &x, &w);\n\t\t\tx--;\n\n\t\t\tupdate(x, w);\n\t\t} else {\n\t\t\tuint u, v;\n\t\t\tscanf(\"%u %u\", &u, &v);\n\t\t\tu--, v--;\n\n\t\t\tif (command[1] == 'M') { // QMAX\n\t\t\t\tprintf(\"%d\\n\", queryMax(u, v));\n\t\t\t} else { // QSUM\n\t\t\t\tprintf(\"%d\\n\", querySum(u, v));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/cut-tree-notes.md","raw":"title: \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  -   \npermalink: cut-tree-notes\ndate: 2015-12-27 22:48:11\n---\n\n\n\n<!-- more -->\n\n### \n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n****\n\n### \n![CutTree](cut-tree-notes/cutTree.png)\n\n********\n\n**** $O({\\log}n)$\n\n### \n```cpp\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n```\n\n`depth` `size` `maxSizeChild` `maxDepth`  `maxSizeChild` \n\nPath `top` `pos` \n\n### \n `DFS` `maxSizeChild`  `maxDepth`\n\n```cpp\nstack<Tree *> s;\n\ns.push(root);\nwhile (!s.empty()) {\n\tTree *tree = s.top();\n\tif (tree->visited) {\n\t\ttree->size = 1;\n\t\ttree->maxDepth = tree->depth;\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ttree->size += child->size;\n\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t}\n\t\t}\n\n\t\ts.pop();\n\t} else {\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ts.push(child);\n\t\t}\n\n\t\ttree->visited = true;\n\t}\n}\n```\n\n`DFS`  `BFS`  `BFS`  `BFS`  \n\n `maxDepthChild`\n\n```cpp\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n```\n\n\n\n```cpp\nfor (uint i = 0; i < n; i++) {\n\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n}\n```\n\n### \n\n\n```cpp\ninline void update(uint x, uint w) {\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n```\n\n### \n `[u, v]` \n\n1.  `u`  `v` ******** 1\n2.  `u`  `v` \n\n```cpp\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n```\n\n### \n \n\n```cpp\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### \n zkw \n\n```cpp\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n```\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing std::queue;\nusing std::stack;\nusing std::swap;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 30000;\n\nstruct Node {\n\tstruct Edge *edges;\n\tuint id;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, Edge *next) : from(from), to(to), next(next) {}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n\nuint n, q;\n\ninline void addEdge(uint a, uint b) {\n\tnodes[a].edges = new Edge(&nodes[a], &nodes[b], nodes[a].edges);\n\tnodes[b].edges = new Edge(&nodes[b], &nodes[a], nodes[b].edges);\n}\n\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void cut() {\n\tstack<Tree *> s;\n\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *tree = s.top();\n\t\tif (tree->visited) {\n\t\t\ttree->size = 1;\n\t\t\ttree->maxDepth = tree->depth;\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ttree->size += child->size;\n\t\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t} else {\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ts.push(child);\n\t\t\t}\n\n\t\t\ttree->visited = true;\n\t\t}\n\t}\n\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n\t}\n}\n\ninline void update(uint x, uint w) {\n\ttreeNodes[x].w = w;\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n\ninline int queryMax(uint u, uint v) {\n\tint result = INT_MIN;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult = std::max(result, a->path->segmentTree->queryMax(0, a->pos));\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult = std::max(result, a->path->segmentTree->queryMax(a->pos, b->pos));\n\treturn result;\n}\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tfor (uint i = 0; i < n - 1; i++) {\n\t\tuint a, b;\n\t\tscanf(\"%u %u\", &a, &b);\n\t\ta--, b--;\n\n\t\taddEdge(a, b);\n\t}\n\n\tconvert();\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint w;\n\t\tscanf(\"%u\", &w);\n\t\ttreeNodes[i].w = w;\n\t}\n\n\tcut();\n\n\tscanf(\"%u\", &q);\n\n\tfor (uint i = 0; i < q; i++) {\n\t\tchar command[6 + 1];\n\t\tscanf(\"%s\", command);\n\t\tif (command[1] == 'H') { // CHANGE\n\t\t\tuint x;\n\t\t\tint w;\n\t\t\tscanf(\"%u %d\", &x, &w);\n\t\t\tx--;\n\n\t\t\tupdate(x, w);\n\t\t} else {\n\t\t\tuint u, v;\n\t\t\tscanf(\"%u %u\", &u, &v);\n\t\t\tu--, v--;\n\n\t\t\tif (command[1] == 'M') { // QMAX\n\t\t\t\tprintf(\"%d\\n\", queryMax(u, v));\n\t\t\t} else { // QSUM\n\t\t\t\tprintf(\"%d\\n\", querySum(u, v));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"cut-tree-notes","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jimo013v0jxlx7g6aw1h"},{"title":"CTSC1999 - ","id":"59","updated":"2016-02-24T13:42:46.000Z","date":"2016-02-24T13:41:36.000Z","_content":"\n `n`  `m`  `i`  `H[i]`  1\n\n<!-- more -->\n\n### \n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### \n  qwq\n\n `t` `t + 1`  0 ********\n\n 1\n\n  qwq\n\n`n`  `m` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/ctsc1999-home.md","raw":"title: CTSC1999 - \ncategories: OI\ntags: \n  - COGS\n  - CTSC\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: ctsc1999-home\nid: 59\nupdated: '2016-02-24 21:42:46'\ndate: 2016-02-24 21:41:36\n---\n\n `n`  `m`  `i`  `H[i]`  1\n\n<!-- more -->\n\n### \n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### \n  qwq\n\n `t` `t + 1`  0 ********\n\n 1\n\n  qwq\n\n`n`  `m` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"ctsc1999-home","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jimx01430jxl3lbo3af1"},{"title":"CTSC1997 -  DP","id":"15","updated":"2016-01-19T13:05:52.000Z","date":"2016-01-06T21:12:01.000Z","_content":"\n N<= 300  M \n\n<!-- more -->\n\n### \n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### \n $f[i][m]$  `i`  `m` \n\n1.  `i` **** `k` `m - k - 1` ****\n2.  `i`  `m` ****\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","source":"_posts/ctsc1997-course.md","raw":"title: CTSC1997 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - CTSC\n  - DP\n  -  DP\npermalink: ctsc1997-course\nid: 15\nupdated: '2016-01-19 21:05:52'\ndate: 2016-01-07 05:12:01\n---\n\n N<= 300  M \n\n<!-- more -->\n\n### \n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### \n $f[i][m]$  `i`  `m` \n\n1.  `i` **** `k` `m - k - 1` ****\n2.  `i`  `m` ****\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","slug":"ctsc1997-course","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jin6014e0jxljjx5fs1o"},{"title":"CTSC2016 & APIO2016 ","date":"2016-05-09T10:18:13.000Z","_content":"\n CTSC & APIO\n\n<!-- more -->\n\n### 5.1\n   \n QAQ  \nqwq\n\nOxer  yts1999 RP++\n\n Teachk  ovo \n\n HA CXC   \n QwQ   \n\n~~sui  Fancy ~~  \nCOGS  QwQ ~~ID ~~  \n ovo  \n NOI LinuxUbuntu 14.04 LTS  \n~~ SDOI ~~\n\nFancy  vim   \n sui ~  \n~~ JSOI  vim ~~\n\n NOI   ~~~~  \n~~~~\n\n QQ smg   \n %fqk    \n QQ  DQS    \n~~~~\n\n COGS   \nsui Menci  \n%%%%%   \n~~Mencimdzz  &@!#@%~& ~~\n\n wmd  Chenyao    \n Chenyao   \n~~mdzz ~~\n~~Chenyao  Orz~~\n\n   \n   \n  qwq\n\n### 5.2\nCTSC2016 Day1\n\n  \n \n\n     \n   \n   \n\n dms    \n     \n   \n~~mdzz ~~\n\n \n\n   \n .jpg  \nSuffix Array 5    \n\n   \n   \n   \n  \n   \n `else`   \n~~mdzz ~~\n\n   \n   \n   \n   `n`    \n~~mdzz~~ \n\n   \n   \n   \n~~ 5 ~~\n\n   \n  \n~~mdzz ~~  \n\n 5  5  \n\n   \n T3 \n\n T3    \n\n Fancy    \nFancy  \nMenci&@!#@%~&   sui    \n~~mdzz  ~~\n\n  \n 01  X    \n  \n     \n  \n 0   \n  \n  \nmdzz   0  \n\n~~ ~~\n\n    XD  \n yts1999    \n  \n   \n\n`5 + 5 + 2 = 12`    \nFancy  0  15  \n\n Fe  \n\nsui  HNOI ~~~~\n\n### 5.3\n  QAQ\n\nfaebdc  \n\n     \n Fancy  \n\n   \n   \n\n   QAQ   mdzz   \n qwq   \nsui   0.0 ovoFancy  Kindle  ovo \n\n \n\nFancy    \nwoc   fqk   \nfqkFancy   \nMenci&@!#@%~&   \nfqkwori  .jpg HA    sb   \nfqk  shenben 2333\n\n### 5.4\nCTSC2016 Day2\n\n\n\n \n\n  \n  \n\n\n QAQ   XD\n\n   \n10   \n 3  \n\n   \n 2333  \n  mdzz   \n\n   SPFA  qwq   \n  md   \nmdzz  youdu\n\n APIO2009  atm    \n Tarjan \n\nTarjan    \n   \n \n\n   \n \n\n~~mdzz ~~    \n\n\n  \n  \n\n\n `O3`   \n n    3M+  \n`checker` 20  \n\n QAQ    \n  XD\n\n \n\n Dashgua SPFA 70    \n~~mdzz ~~  \n Cu    \ndms  A \n\n  ~~mdzz ~~\n\n qwq `O(E)`  SPFA   \n Fe  QAQ\n\nyts1999Oxerdmsheheda    \n 2333 \n\n qwq  \n abclzr lzr \n\nKZ  UbuntuWindows     \n \n\n### 5.5\n\n\n \n\n  \nKZ Menci    \nFancyMenci   \n~~Menci&@!#@%~&~~  \n~~.jpg~~\n\n qvq\n\nFancy    \n \n\n N  \n\n SDOI   &@!#@%~& 233333333\n\n### 5.6\n fqk \n\n XXXX  Orz fqk \n\n qwq \n\n HNOI  APIO  qwq  \nAPIO \n\n### 5.7\nAPIO2016 Day1\n\nAPIO  qwq  vim  \n\n Johann %%% \n\n PDF  qwq\n\n \n\n   \n   \n\n\n   DP    XD\n\n     \n\n 16  \n\n~~mdzz~~     \n30.38    46.38    \n\n 42    \n WA    \n\n CMS  ~~~~  \n~~~~\n\n  \n\nT3      \nT2  2  DP   QAQ\n\n Fe  XD\n\n THU  QwQ  \n Fuxey  Sengxian   qwq  \nSengxian ****46.38  23333\n\n### 5.8\n\n\n  smg   sui      \nmdzz   XD\n\n Fancy    \n   Fancy  XD\n\n  Cu 46  \n\nzdw1999  qvq  \n \n\n HA     ~~~~\n\n~~~~\n\n COGS WWTTTTTTTT \n\n Fancy  Ubuntu KZ   XD\n\n### 5.9\nget   23333\n\n \n\n  qwq\n\n \n\n \n","source":"_posts/ctsc-apio-2016.md","raw":"title: CTSC2016 & APIO2016 \ncategories: \n  - Diary\npermalink: ctsc-apio-2016\ndate: 2016-05-09 18:18:13\n---\n\n CTSC & APIO\n\n<!-- more -->\n\n### 5.1\n   \n QAQ  \nqwq\n\nOxer  yts1999 RP++\n\n Teachk  ovo \n\n HA CXC   \n QwQ   \n\n~~sui  Fancy ~~  \nCOGS  QwQ ~~ID ~~  \n ovo  \n NOI LinuxUbuntu 14.04 LTS  \n~~ SDOI ~~\n\nFancy  vim   \n sui ~  \n~~ JSOI  vim ~~\n\n NOI   ~~~~  \n~~~~\n\n QQ smg   \n %fqk    \n QQ  DQS    \n~~~~\n\n COGS   \nsui Menci  \n%%%%%   \n~~Mencimdzz  &@!#@%~& ~~\n\n wmd  Chenyao    \n Chenyao   \n~~mdzz ~~\n~~Chenyao  Orz~~\n\n   \n   \n  qwq\n\n### 5.2\nCTSC2016 Day1\n\n  \n \n\n     \n   \n   \n\n dms    \n     \n   \n~~mdzz ~~\n\n \n\n   \n .jpg  \nSuffix Array 5    \n\n   \n   \n   \n  \n   \n `else`   \n~~mdzz ~~\n\n   \n   \n   \n   `n`    \n~~mdzz~~ \n\n   \n   \n   \n~~ 5 ~~\n\n   \n  \n~~mdzz ~~  \n\n 5  5  \n\n   \n T3 \n\n T3    \n\n Fancy    \nFancy  \nMenci&@!#@%~&   sui    \n~~mdzz  ~~\n\n  \n 01  X    \n  \n     \n  \n 0   \n  \n  \nmdzz   0  \n\n~~ ~~\n\n    XD  \n yts1999    \n  \n   \n\n`5 + 5 + 2 = 12`    \nFancy  0  15  \n\n Fe  \n\nsui  HNOI ~~~~\n\n### 5.3\n  QAQ\n\nfaebdc  \n\n     \n Fancy  \n\n   \n   \n\n   QAQ   mdzz   \n qwq   \nsui   0.0 ovoFancy  Kindle  ovo \n\n \n\nFancy    \nwoc   fqk   \nfqkFancy   \nMenci&@!#@%~&   \nfqkwori  .jpg HA    sb   \nfqk  shenben 2333\n\n### 5.4\nCTSC2016 Day2\n\n\n\n \n\n  \n  \n\n\n QAQ   XD\n\n   \n10   \n 3  \n\n   \n 2333  \n  mdzz   \n\n   SPFA  qwq   \n  md   \nmdzz  youdu\n\n APIO2009  atm    \n Tarjan \n\nTarjan    \n   \n \n\n   \n \n\n~~mdzz ~~    \n\n\n  \n  \n\n\n `O3`   \n n    3M+  \n`checker` 20  \n\n QAQ    \n  XD\n\n \n\n Dashgua SPFA 70    \n~~mdzz ~~  \n Cu    \ndms  A \n\n  ~~mdzz ~~\n\n qwq `O(E)`  SPFA   \n Fe  QAQ\n\nyts1999Oxerdmsheheda    \n 2333 \n\n qwq  \n abclzr lzr \n\nKZ  UbuntuWindows     \n \n\n### 5.5\n\n\n \n\n  \nKZ Menci    \nFancyMenci   \n~~Menci&@!#@%~&~~  \n~~.jpg~~\n\n qvq\n\nFancy    \n \n\n N  \n\n SDOI   &@!#@%~& 233333333\n\n### 5.6\n fqk \n\n XXXX  Orz fqk \n\n qwq \n\n HNOI  APIO  qwq  \nAPIO \n\n### 5.7\nAPIO2016 Day1\n\nAPIO  qwq  vim  \n\n Johann %%% \n\n PDF  qwq\n\n \n\n   \n   \n\n\n   DP    XD\n\n     \n\n 16  \n\n~~mdzz~~     \n30.38    46.38    \n\n 42    \n WA    \n\n CMS  ~~~~  \n~~~~\n\n  \n\nT3      \nT2  2  DP   QAQ\n\n Fe  XD\n\n THU  QwQ  \n Fuxey  Sengxian   qwq  \nSengxian ****46.38  23333\n\n### 5.8\n\n\n  smg   sui      \nmdzz   XD\n\n Fancy    \n   Fancy  XD\n\n  Cu 46  \n\nzdw1999  qvq  \n \n\n HA     ~~~~\n\n~~~~\n\n COGS WWTTTTTTTT \n\n Fancy  Ubuntu KZ   XD\n\n### 5.9\nget   23333\n\n \n\n  qwq\n\n \n\n \n","slug":"ctsc-apio-2016","published":1,"updated":"2016-11-20T15:49:31.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jinc014k0jxl8tpq7nnn"},{"title":"CQOI2016 -  DP","date":"2016-04-21T15:31:24.000Z","_content":"\n $ 3 $  $ 8 $  $ 4 $$ 3000988721 $$ 23333333333 $$ 14444101000 $$ 1015400080 $$ 10010012022 $\n\n $ 11 $  $ 0 $ $ L $  $ R $ $ [L, R] $ $ L $  $ R $  $ 11 $ \n\n<!-- more -->\n\n### \n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### \n $ F(x) $  $ x $ $ F(R) - F(L - 1) $ \n\n $ F(x) $  DP\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n$ 10 $  $ 4 $ $ 8 $\n\n $ < limit $\n\n DP  $ O(10 ^ 4 * 2 ^ 4) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-number.md","raw":"title: CQOI2016 -  DP\ndate: 2016-04-21 23:31:24\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  -  DP\n  - DP\npermalink: cqoi2016-number\n---\n\n $ 3 $  $ 8 $  $ 4 $$ 3000988721 $$ 23333333333 $$ 14444101000 $$ 1015400080 $$ 10010012022 $\n\n $ 11 $  $ 0 $ $ L $  $ R $ $ [L, R] $ $ L $  $ R $  $ 11 $ \n\n<!-- more -->\n\n### \n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### \n $ F(x) $  $ x $ $ F(R) - F(L - 1) $ \n\n $ F(x) $  DP\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n$ 10 $  $ 4 $ $ 8 $\n\n $ < limit $\n\n DP  $ O(10 ^ 4 * 2 ^ 4) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-number","published":1,"updated":"2016-10-24T23:35:36.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jine014m0jxlfh9g0v1f"},{"title":"CQOI2016 -  + ","date":"2016-04-21T10:57:52.000Z","_content":"\n $ s $$ t $  $ s $$ t $  $ s $$ t $  $ s $$ t $ \n\n $ N $  $ \\frac{N(N  1)}{2} $\n\n<!-- more -->\n\n### \n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### \n $ s $$ t $  $ S $  $ T $ \n\n $ S $ $ T $  $ u $ $ s $  $ u $  $ S' $$ T' $ $ S $  $ S' $ \n\n $ N - 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-cuts.md","raw":"title: CQOI2016 -  + \ndate: 2016-04-21 18:57:52\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: cqoi2016-cuts\n---\n\n $ s $$ t $  $ s $$ t $  $ s $$ t $  $ s $$ t $ \n\n $ N $  $ \\frac{N(N  1)}{2} $\n\n<!-- more -->\n\n### \n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### \n $ s $$ t $  $ S $  $ T $ \n\n $ S $ $ T $  $ u $ $ s $  $ u $  $ S' $$ T' $ $ S $  $ S' $ \n\n $ N - 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-cuts","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jinl014t0jxloqhl8u6s"},{"title":"CQOI2011 - CDQ","date":"2016-06-20T12:10:00.000Z","_content":"\n $ A $ $ i < j $ $ A_i > A_j $  $ (i,\\ j) $  $ 1 $  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 3295](http://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n### \n\n\n  ****************\n\n $ a_i $  $ n - a_i + 1 $******** CDQ \n\n $ i $  $ n - i + 1 $ CDQ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 50000;\n\nstruct Triple {\n\tint id, pos, num;\n\tunsigned int *ans;\n\n\tTriple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tTriple() {}\n\t\n\tbool operator<(const Triple &other) const { return id < other.id; }\n} a[MAXN];\n\nint n, m;\n\nstruct BinaryIndexedTree {\n\tunsigned int a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tunsigned int query(const int x) {\n\t\tunsigned int ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\t/*\n\tfor (Triple *a = l; a <= r; a++) {\n\t\tif (a->ans) {\n\t\t\tfor (Triple *b = l; b < a; b++) {\n\t\t\t\tif (b->pos < a->pos && b->num < a->num) (*a->ans)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tif (l == r) return;\n\n\tTriple *m = l + (r - l) / 2;\n\n\tcdq(l, m);\n\tcdq(m + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = m + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= m && p1->pos <= p2->pos) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tbit.update(q->num, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) *q->ans += bit.query(q->num);\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\tbit.clear(q->num);\n\t\t*p = *q;\n\t\tassert(p->num != 0);\n\t}\n}\n\n/*\ninline void print() {\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"[%d, %d, %d]%s\", a[i].id, a[i].pos, a[i].num, i == n - 1 ? \"\\n\" : \", \");\n\t}\n}\n*/\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int num[MAXN], pos[MAXN], del[MAXM];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &num[i]), pos[num[i] - 1] = i + 1;\n\n\tstatic bool deleted[MAXN];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdel[i] = pos[x - 1];\n\t\tdeleted[del[i] - 1] = true;\n\t}\n\n\tstatic unsigned int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) if (!deleted[i - 1]) {\n\t\ta[cnt] = Triple(i, num[i - 1], &ans[n - cnt - 1]); // , printf(\"ans[%d]\\n\", n - cnt - 1);\n\t\tcnt++;\n\t}\n\n\t// const int invalidCnt = cnt;\n\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\ta[cnt++] = Triple(del[i], num[del[i] - 1], &ans[i]); // , printf(\"ans[%d]\\n\", i);\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t}\n\t\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tstd::sort(a, a + cnt);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t\ta[i].num = n - a[i].num + 1;\n\t}\n\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tfor (int i = n - 2; i >= 0; i--) ans[i] += ans[i + 1];\n\tfor (int i = 0; i < m; i++) printf(\"%u\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2011-inverse.md","raw":"title: CQOI2011 - CDQ\ndate: 2016-06-20 20:10:00\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: cqoi2011-inverse\n---\n\n $ A $ $ i < j $ $ A_i > A_j $  $ (i,\\ j) $  $ 1 $  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 3295](http://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n### \n\n\n  ****************\n\n $ a_i $  $ n - a_i + 1 $******** CDQ \n\n $ i $  $ n - i + 1 $ CDQ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 50000;\n\nstruct Triple {\n\tint id, pos, num;\n\tunsigned int *ans;\n\n\tTriple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tTriple() {}\n\t\n\tbool operator<(const Triple &other) const { return id < other.id; }\n} a[MAXN];\n\nint n, m;\n\nstruct BinaryIndexedTree {\n\tunsigned int a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tunsigned int query(const int x) {\n\t\tunsigned int ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\t/*\n\tfor (Triple *a = l; a <= r; a++) {\n\t\tif (a->ans) {\n\t\t\tfor (Triple *b = l; b < a; b++) {\n\t\t\t\tif (b->pos < a->pos && b->num < a->num) (*a->ans)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tif (l == r) return;\n\n\tTriple *m = l + (r - l) / 2;\n\n\tcdq(l, m);\n\tcdq(m + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = m + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= m && p1->pos <= p2->pos) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tbit.update(q->num, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) *q->ans += bit.query(q->num);\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\tbit.clear(q->num);\n\t\t*p = *q;\n\t\tassert(p->num != 0);\n\t}\n}\n\n/*\ninline void print() {\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"[%d, %d, %d]%s\", a[i].id, a[i].pos, a[i].num, i == n - 1 ? \"\\n\" : \", \");\n\t}\n}\n*/\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int num[MAXN], pos[MAXN], del[MAXM];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &num[i]), pos[num[i] - 1] = i + 1;\n\n\tstatic bool deleted[MAXN];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdel[i] = pos[x - 1];\n\t\tdeleted[del[i] - 1] = true;\n\t}\n\n\tstatic unsigned int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) if (!deleted[i - 1]) {\n\t\ta[cnt] = Triple(i, num[i - 1], &ans[n - cnt - 1]); // , printf(\"ans[%d]\\n\", n - cnt - 1);\n\t\tcnt++;\n\t}\n\n\t// const int invalidCnt = cnt;\n\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\ta[cnt++] = Triple(del[i], num[del[i] - 1], &ans[i]); // , printf(\"ans[%d]\\n\", i);\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t}\n\t\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tstd::sort(a, a + cnt);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t\ta[i].num = n - a[i].num + 1;\n\t}\n\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tfor (int i = n - 2; i >= 0; i--) ans[i] += ans[i + 1];\n\tfor (int i = 0; i < m; i++) printf(\"%u\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2011-inverse","published":1,"updated":"2016-06-20T14:10:53.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jinr01500jxlwkcl3q1i"},{"title":"","date":"2016-03-15T09:16:12.000Z","_content":"\n\n\n<!-- more -->\n\n### \n#### \n $ n $  $ p_i $ \n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### \n $ n $  $ p_i $ \n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### \n \n\n\n\n### \n#### \n $ n $  $ f(n) $ $ f(0) = 1 $\n\n$$ f(n) = f(n - 1) * n $$\n\n $ f(n) = n! $\n\n#### \n $ n $  $ k $  $ P(n, k) $ $ n $  $ n - 1 $  $ k $  $ n - k + 1 $ \n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n $ n! $  $ n - k $ \n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### \n $ k $  $ i $  $ n_i $  $ n = \\sum\\limits_{i = 1}^{k}n_i $ $ n! $\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### \n#### \n n  k  $ C(n, k) $ $ P(n, k) $  n  k  k \n\n$$ P(n, k) = C(n, k) * k! $$\n\n\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### \n$ C(n, 0) = C(n, n) = 1 $ \n\n$ C(n, k) = C(n, n - k) $  $ k $  $ n - k $ \n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ Pascal \n\n#### \n n  k  $ C(n + k - 1, k) $ \n\n#### \n##### \n Pascal \n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### \n `double`  `long long` \n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### \n#### Fibonacci \n $ n $ \n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan \n $ n $  $ n - 3 $  $ n - 2 $  $ f(n) $\n\n $ i $  $ V_i $ $ {V_1}{V_k}{V_n} $$ 1 \\lt k \\lt n $ $ k $  $ n - k + 1 $ \n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### \n#### \n $ \\{ a_1, a_2, \\cdots, a_n \\} $  $ 1 \\lt i \\leq n $  $ a_t - a_{i - 1} = d $\n\n$$ a_i = a_i + (i - 1)d $$\n\n\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### \n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n\n\n#### \n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","source":"_posts/combinatorics-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  -   \npermalink: combinatorics-notes\ndate: 2016-03-15 17:16:12\n---\n\n\n\n<!-- more -->\n\n### \n#### \n $ n $  $ p_i $ \n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### \n $ n $  $ p_i $ \n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### \n \n\n\n\n### \n#### \n $ n $  $ f(n) $ $ f(0) = 1 $\n\n$$ f(n) = f(n - 1) * n $$\n\n $ f(n) = n! $\n\n#### \n $ n $  $ k $  $ P(n, k) $ $ n $  $ n - 1 $  $ k $  $ n - k + 1 $ \n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n $ n! $  $ n - k $ \n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### \n $ k $  $ i $  $ n_i $  $ n = \\sum\\limits_{i = 1}^{k}n_i $ $ n! $\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### \n#### \n n  k  $ C(n, k) $ $ P(n, k) $  n  k  k \n\n$$ P(n, k) = C(n, k) * k! $$\n\n\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### \n$ C(n, 0) = C(n, n) = 1 $ \n\n$ C(n, k) = C(n, n - k) $  $ k $  $ n - k $ \n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ Pascal \n\n#### \n n  k  $ C(n + k - 1, k) $ \n\n#### \n##### \n Pascal \n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### \n `double`  `long long` \n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### \n#### Fibonacci \n $ n $ \n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan \n $ n $  $ n - 3 $  $ n - 2 $  $ f(n) $\n\n $ i $  $ V_i $ $ {V_1}{V_k}{V_n} $$ 1 \\lt k \\lt n $ $ k $  $ n - k + 1 $ \n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### \n#### \n $ \\{ a_1, a_2, \\cdots, a_n \\} $  $ 1 \\lt i \\leq n $  $ a_t - a_{i - 1} = d $\n\n$$ a_i = a_i + (i - 1)d $$\n\n\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### \n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n\n\n#### \n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","slug":"combinatorics-notes","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiny01580jxlbnj0c86i"},{"title":"COGS 746 - ","id":"53","updated":"2016-02-19T03:44:48.000Z","date":"2016-02-19T03:43:42.000Z","_content":"\n $ N * N $ \n\n<!-- more -->\n\n### \n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### \n\n\n> \n\n>  S  T X  S  Y  X  Y \n\n> COGS 734 - \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-746.md","raw":"title: COGS 746 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-746\nid: 53\nupdated: '2016-02-19 11:44:48'\ndate: 2016-02-19 11:43:42\n---\n\n $ N * N $ \n\n<!-- more -->\n\n### \n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### \n\n\n> \n\n>  S  T X  S  Y  X  Y \n\n> COGS 734 - \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-746","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jio3015e0jxlkp4xbrkn"},{"title":"COGS 742 - ","id":"58","updated":"2016-02-23T13:44:58.000Z","date":"2016-02-23T13:44:06.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### \n**** 1 0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-742.md","raw":"title: COGS 742 - \ncategories: OI\ntags: \n  - COGS\n  - Edmonds-Karp\n  -  24 \n  - \n  - \n  - \npermalink: cogs-742\nid: 58\nupdated: '2016-02-23 21:44:58'\ndate: 2016-02-23 21:44:06\n---\n\n\n\n<!-- more -->\n\n### \n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### \n**** 1 0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-742","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiod015n0jxln2742wi2"},{"title":"COGS 741 - ","id":"61","updated":"2016-02-25T07:38:10.000Z","date":"2016-02-25T07:37:15.000Z","_content":"\nG  `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### \n  \n\n\n\n   1****\n\n 0 0****\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-741.md","raw":"title: COGS 741 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Edmonds-Karp\n  - \npermalink: cogs-741\nid: 61\nupdated: '2016-02-25 15:38:10'\ndate: 2016-02-25 15:37:15\n---\n\nG  `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### \n  \n\n\n\n   1****\n\n 0 0****\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-741","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jioj015v0jxlz2w6d909"},{"title":"COGS 740 - ","id":"60","updated":"2016-02-25T00:10:00.000Z","date":"2016-02-25T00:08:29.000Z","_content":"\n `n`  `n`  `i`  `j`  `c[i][j]` `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### \n****\n\n 1 0 1 0 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","source":"_posts/cogs-740.md","raw":"title: COGS 740 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Edmonds-Karp\n  - \n  - \npermalink: cogs-740\nid: 60\nupdated: '2016-02-25 08:10:00'\ndate: 2016-02-25 08:08:29\n---\n\n `n`  `n`  `i`  `j`  `c[i][j]` `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### \n****\n\n 1 0 1 0 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","slug":"cogs-740","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jior01630jxlkgbskxg8"},{"title":"COGS 739 - ","id":"57","updated":"2016-02-23T12:35:48.000Z","date":"2016-02-20T13:37:35.000Z","_content":"\nW  `m`  `n`  `i`  $ a_i $  `j`  $ b_j $  `i`  `j`  $ c_{ij} $\n\n<!-- more -->\n\n### \n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-739.md","raw":"title: COGS 739 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - \n  - Edmonds-Karp\n  -  24 \npermalink: cogs-739\nid: 57\nupdated: '2016-02-23 20:35:48'\ndate: 2016-02-20 21:37:35\n---\n\nW  `m`  `n`  `i`  $ a_i $  `j`  $ b_j $  `i`  `j`  $ c_{ij} $\n\n<!-- more -->\n\n### \n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-739","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jip0016c0jxl889fn0z2"},{"title":"COGS 738 - ","id":"52","updated":"2016-02-19T03:35:21.000Z","date":"2016-02-19T03:33:27.000Z","_content":"\n `n`  `m` \n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### \n\n\n 1 1 0 1 1 1 0\n\n\n\n**** `s`  0 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $ $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-738.md","raw":"title: COGS 738 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - \n  - Edmonds-Karp\n  -  24 \npermalink: cogs-738\nid: 52\nupdated: '2016-02-19 11:35:21'\ndate: 2016-02-19 11:33:27\n---\n\n `n`  `m` \n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### \n\n\n 1 1 0 1 1 1 0\n\n\n\n**** `s`  0 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $ $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-738","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jip8016k0jxlcfcwxwza"},{"title":"COGS 734 - ","id":"51","updated":"2016-02-15T09:03:18.000Z","date":"2016-02-15T09:02:01.000Z","_content":"\n $ M * N $ \n\n<!-- more -->\n\n### \n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### \n\n\n  ****\n\n\n\n S  T X  S  Y  X  Y \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-734.md","raw":"title: COGS 734 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-734\nid: 51\nupdated: '2016-02-15 17:03:18'\ndate: 2016-02-15 17:02:01\n---\n\n $ M * N $ \n\n<!-- more -->\n\n### \n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### \n\n\n  ****\n\n\n\n S  T X  S  Y  X  Y \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-734","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jipf016s0jxlgk5hbfsl"},{"title":"COGS 731 -  DP + ","id":"48","updated":"2016-02-09T06:40:10.000Z","date":"2016-02-09T06:37:32.000Z","_content":"\n `X1 ~ Xn`\n\n1.  `s`\n2.  `s` \n3.  `X1`  `Xn` `s` \n\n<!-- more -->\n\n### \n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### \n****\n\n $X_i$  $F_i$ $F_i$ $K$\n\n\n\n1.  $F_i = K$  1\n2.  $F_i = 1$  1\n3. $ X_jX_i $$F_i=F_j+1$ `i``j` `j`  `i`  1\n\n\n\n `i`  `i`  `i'` `i` `i'`  `i`  `i'`  1  1\n\n `1``n` \n\n**** 1NN\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-731.md","raw":"title: COGS 731 -  DP + \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \npermalink: cogs-731\nid: 48\nupdated: '2016-02-09 14:40:10'\ndate: 2016-02-09 14:37:32\n---\n\n `X1 ~ Xn`\n\n1.  `s`\n2.  `s` \n3.  `X1`  `Xn` `s` \n\n<!-- more -->\n\n### \n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### \n****\n\n $X_i$  $F_i$ $F_i$ $K$\n\n\n\n1.  $F_i = K$  1\n2.  $F_i = 1$  1\n3. $ X_jX_i $$F_i=F_j+1$ `i``j` `j`  `i`  1\n\n\n\n `i`  `i`  `i'` `i` `i'`  `i`  `i'`  1  1\n\n `1``n` \n\n**** 1NN\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-731","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jipm01700jxlwjeh15ux"},{"title":"COGS 729 - ","id":"47","updated":"2016-02-09T06:41:05.000Z","date":"2016-02-09T05:42:59.000Z","_content":"\n `m`  `ri` `n`  `ci` \n\n\n\n<!-- more -->\n\n### \n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### \n\n\n****\n\n `S` `S`  `T` `T`  `1`\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-729.md","raw":"title: COGS 729 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Dinic\npermalink: cogs-729\nid: 47\nupdated: '2016-02-09 14:41:05'\ndate: 2016-02-09 13:42:59\n---\n\n `m`  `ri` `n`  `ci` \n\n\n\n<!-- more -->\n\n### \n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### \n\n\n****\n\n `S` `S`  `T` `T`  `1`\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-729","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jips01770jxlizw4ni94"},{"title":"COGS 728 - ","id":"45","updated":"2016-02-06T14:53:58.000Z","date":"2016-02-06T14:52:12.000Z","_content":"\n $G=(V,E)$  P  G  V  P  P  G P  V  0G  G \n\n G \n\n<!-- more -->\n\n### \n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### \n 1 1\n\n\n\n `(u, v)` `u`  `v` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-728.md","raw":"title: COGS 728 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  - \n  -  24 \npermalink: cogs-728\nid: 45\nupdated: '2016-02-06 22:53:58'\ndate: 2016-02-06 22:52:12\n---\n\n $G=(V,E)$  P  G  V  P  P  G P  V  0G  G \n\n G \n\n<!-- more -->\n\n### \n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### \n 1 1\n\n\n\n `(u, v)` `u`  `v` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-728","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jipy017e0jxlqqfyccci"},{"title":"COGS 727 - ","id":"49","updated":"2016-02-15T00:45:03.000Z","date":"2016-02-15T00:39:38.000Z","_content":"\nW  $ E = \\{ E1, E2, , Em \\} $ $ I = \\{ I1, I2, , In \\} $ $ E_j $  $ R_jI $ $ I_k $  $ c_k $ $ E_j $  $ p_j $ \n\n<!-- more -->\n\n### \n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### \n  ****\n\n********************\n\n Dinic ******** BFSBFS  `S`  `T`  `S`  `T` \n\n `std::set_difference` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-727.md","raw":"title: COGS 727 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-727\nid: 49\nupdated: '2016-02-15 08:45:03'\ndate: 2016-02-15 08:39:38\n---\n\nW  $ E = \\{ E1, E2, , Em \\} $ $ I = \\{ I1, I2, , In \\} $ $ E_j $  $ R_jI $ $ I_k $  $ c_k $ $ E_j $  $ p_j $ \n\n<!-- more -->\n\n### \n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### \n  ****\n\n********************\n\n Dinic ******** BFSBFS  `S`  `T`  `S`  `T` \n\n `std::set_difference` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-727","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiq5017m0jxlwrmwivq6"},{"title":"COGS 439 -  + ","id":"50","updated":"2016-02-15T02:17:27.000Z","date":"2016-02-15T02:13:28.000Z","_content":"\n `n`  BUG `m`  BUG  BUG  BUG  BUG  BUG  BUG  BUG \n\n<!-- more -->\n\n### \n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### \n `unsigned int`  `i`  `i`  BUG  `std::tr1::unordered_map` `map[status]`  `status` \n\n `effectAddition``effectSubtract` BUG BUG\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n BUG  BUG  BUG\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n COGS  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n 24 ~~~~","source":"_posts/cogs-439.md","raw":"title: COGS 439 -  + \ncategories: OI\ntags: \n  - \n  - \n  - \n  - COGS\n  -  24 \n  - map\npermalink: cogs-439\nid: 50\nupdated: '2016-02-15 10:17:27'\ndate: 2016-02-15 10:13:28\n---\n\n `n`  BUG `m`  BUG  BUG  BUG  BUG  BUG  BUG  BUG \n\n<!-- more -->\n\n### \n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### \n `unsigned int`  `i`  `i`  BUG  `std::tr1::unordered_map` `map[status]`  `status` \n\n `effectAddition``effectSubtract` BUG BUG\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n BUG  BUG  BUG\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n COGS  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n 24 ~~~~","slug":"cogs-439","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiqd017u0jxl35p7uqns"},{"title":"COGS 396 - ","id":"46","updated":"2016-02-06T15:04:22.000Z","date":"2016-02-06T15:02:55.000Z","_content":"\n `n` n 1234 ...... \n\n1. \n2.  2 \n\n `n` \n\n<!-- more -->\n\n### \n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-396.md","raw":"title: COGS 396 - \ncategories: OI\ntags: \n  - COGS\n  - \n  -  24 \npermalink: cogs-396\nid: 46\nupdated: '2016-02-06 23:04:22'\ndate: 2016-02-06 23:02:55\n---\n\n `n` n 1234 ...... \n\n1. \n2.  2 \n\n `n` \n\n<!-- more -->\n\n### \n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-396","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiql01830jxl8k0ly7ei"},{"title":"COGS 14 - ","id":"44","updated":"2016-02-06T14:22:28.000Z","date":"2016-02-06T14:21:18.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### \n~~~~\n\n  \n\n `X`  `Y` `S` `S`  `X`  `1` `T` `Y`  `T`  `1` `(u, v)` `u`  `v`  `u`  `v` **** `1`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-14.md","raw":"title: COGS 14 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  - \n  -  24 \npermalink: cogs-14\nid: 44\nupdated: '2016-02-06 22:22:28'\ndate: 2016-02-06 22:21:18\n---\n\n\n\n<!-- more -->\n\n### \n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### \n~~~~\n\n  \n\n `X`  `Y` `S` `S`  `X`  `1` `T` `Y`  `T`  `1` `(u, v)` `u`  `v`  `u`  `v` **** `1`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-14","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiqq01880jxlwqka11uv"},{"title":"CodeVS 3269 -  DP","id":"3","updated":"2016-01-19T13:08:13.000Z","date":"2015-11-22T21:00:15.000Z","_content":"\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> 1\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n  \n  \n `f[v]`  `v` `v` <= `V`    \n 01 \n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `v` `v`  `V`  `0`  `f[v]`  `v`  `f[v]`  `Vi`  `i`  `f[v]` `f[v - Vi]` **** `i`   \n\n `V` / `Vi`  `01`  01   \n 01  01 ******** `f[v]` `f[v - Vi]` **** `i`  `v`  `0`  `V`   \n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `V = 10` `Vi = 3` `Wi = 5`  \n\n `01`   \n `v = 10` **`f[v - Vi] = f[7] = 0`**`f[v]`  `5`  \n `v = 9` `f[v - Vi] = f[6] = 0``f[v]`  `5`  \n `v = 8` `f[v - Vi] = f[5] = 0``f[v]`  `5`  \n** `v = 7` `f[v - Vi] = f[4] = 0``f[v]`  `5`**  \n  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n `v = 3` `f[v - Vi] = f[0] = 0``f[v]`  `5`  \n\n  \n `v = 3` **`f[v - Vi] = f[0] = 0`**`f[v]`  `5`  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n  \n** `v = 6` `f[v - Vi] = f[3] = 5``f[v]`  `10`**  \n  \n** `v = 9` `f[v - Vi] = f[6] = 10``f[v]`  `15`**  \n `v = 10` `f[v - Vi] = f[7] = 10``f[v]`  `15`  \n\n 01   \n\n01   \n `Mi`  `Mi`  01  01 $O(V*{\\Sigma}Mi)$  \n `t`  01  `k`****${\\Sigma}k = Mi$ `k`  $1$,$2$,$4$,,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$  \n `Mi = 17`  `5`  `k`  `1`,`2`,`4`,`8`,`2`  \n$O(V * {\\Sigma}{\\log}Wi)$  \n`t[i].v`  `t[i].w`  `Vi`  `Wi`  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j  1  j  2  j \n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { //  2  k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### \n dp liujz    \n >_<\n","source":"_posts/codevs-3269.md","raw":"title: CodeVS 3269 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  -  DP\npermalink: codevs-3269\nid: 3\nupdated: '2016-01-19 21:08:13'\ndate: 2015-11-23 05:00:15\n---\n\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> 1\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n  \n  \n `f[v]`  `v` `v` <= `V`    \n 01 \n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `v` `v`  `V`  `0`  `f[v]`  `v`  `f[v]`  `Vi`  `i`  `f[v]` `f[v - Vi]` **** `i`   \n\n `V` / `Vi`  `01`  01   \n 01  01 ******** `f[v]` `f[v - Vi]` **** `i`  `v`  `0`  `V`   \n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `V = 10` `Vi = 3` `Wi = 5`  \n\n `01`   \n `v = 10` **`f[v - Vi] = f[7] = 0`**`f[v]`  `5`  \n `v = 9` `f[v - Vi] = f[6] = 0``f[v]`  `5`  \n `v = 8` `f[v - Vi] = f[5] = 0``f[v]`  `5`  \n** `v = 7` `f[v - Vi] = f[4] = 0``f[v]`  `5`**  \n  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n `v = 3` `f[v - Vi] = f[0] = 0``f[v]`  `5`  \n\n  \n `v = 3` **`f[v - Vi] = f[0] = 0`**`f[v]`  `5`  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n  \n** `v = 6` `f[v - Vi] = f[3] = 5``f[v]`  `10`**  \n  \n** `v = 9` `f[v - Vi] = f[6] = 10``f[v]`  `15`**  \n `v = 10` `f[v - Vi] = f[7] = 10``f[v]`  `15`  \n\n 01   \n\n01   \n `Mi`  `Mi`  01  01 $O(V*{\\Sigma}Mi)$  \n `t`  01  `k`****${\\Sigma}k = Mi$ `k`  $1$,$2$,$4$,,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$  \n `Mi = 17`  `5`  `k`  `1`,`2`,`4`,`8`,`2`  \n$O(V * {\\Sigma}{\\log}Wi)$  \n`t[i].v`  `t[i].w`  `Vi`  `Wi`  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j  1  j  2  j \n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { //  2  k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### \n dp liujz    \n >_<\n","slug":"codevs-3269","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiqy018g0jxln5w6qfzm"},{"title":"CodeVS 3269 -  DP + ","id":"23","updated":"2016-01-19T13:03:26.000Z","date":"2016-01-14T21:47:45.000Z","_content":"\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> `1`\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n01 \n\n`n` `w` `c` \n\n\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n $r=i ~~ \\% ~~ c$$m=i ~~ / ~~ c$\n\n`m`   \n`r` \n\n `i`  `r` $[0,m]$  `d` $(m-d)*c+r$ `i`\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ k=m-d $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n$ f[k*c+r] $ `n + 1`  `n + 1`  $g(k,r)$ $O(1)$ \n\n `m`  `k` `k` ****\n\n### \n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3269-monotone-queue.md","raw":"title: CodeVS 3269 -  DP + \ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\npermalink: codevs-3269-monotone-queue\nid: 23\nupdated: '2016-01-19 21:03:26'\ndate: 2016-01-15 05:47:45\n---\n\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> `1`\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n01 \n\n`n` `w` `c` \n\n\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n $r=i ~~ \\% ~~ c$$m=i ~~ / ~~ c$\n\n`m`   \n`r` \n\n `i`  `r` $[0,m]$  `d` $(m-d)*c+r$ `i`\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ k=m-d $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n$ f[k*c+r] $ `n + 1`  `n + 1`  $g(k,r)$ $O(1)$ \n\n `m`  `k` `k` ****\n\n### \n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```\n","slug":"codevs-3269-monotone-queue","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jir3018l0jxl6ef7lfzw"},{"title":"CodeVS 3168 / 3162 -  DP / ","id":"14","updated":"2016-01-06T13:03:26.000Z","date":"2016-01-05T21:47:45.000Z","_content":"\n `M`  `K` \n\n<!-- more -->\n\n### \n[CodeVS 3162 - ](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 -  3](http://codevs.cn/problem/3168/)\n\n###  DP\n $a[m]$  `m` $f[m][k]$  `m`  `k` \n\n\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n `k`  `k - 1`  `k`  `k - 1`  `m - 1`  `k`  `k` \n\n $O(km^2)$\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### \n DP ************\n\n $O(m{\\log}m)$\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### \n~~ WA  8 ~~\n\n****\n\n\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n###  DPCodeVS 3162\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### CodeVS 3162CodeVS 3168\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3168-3162.md","raw":"title: CodeVS 3168 / 3162 -  DP / \ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\n  - \npermalink: codevs-3168-3162\nid: 14\nupdated: '2016-01-06 21:03:26'\ndate: 2016-01-06 05:47:45\n---\n\n `M`  `K` \n\n<!-- more -->\n\n### \n[CodeVS 3162 - ](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 -  3](http://codevs.cn/problem/3168/)\n\n###  DP\n $a[m]$  `m` $f[m][k]$  `m`  `k` \n\n\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n `k`  `k - 1`  `k`  `k - 1`  `m - 1`  `k`  `k` \n\n $O(km^2)$\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### \n DP ************\n\n $O(m{\\log}m)$\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### \n~~ WA  8 ~~\n\n****\n\n\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n###  DPCodeVS 3162\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### CodeVS 3162CodeVS 3168\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","slug":"codevs-3168-3162","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jira018r0jxlngvllqkb"},{"title":"CodeVS 2822 - ","date":"2016-03-04T02:47:42.000Z","_content":"\n N  A  BB  C A  C\n\n -1\n\n<!-- more -->\n\n### \n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/codevs-2822.md","raw":"title: CodeVS 2822 - \ncategories: OI\ntags: \n  - CodeVS\n  - \n  - Tarjan\n  - \n  - \npermalink: codevs-2822\ndate: 2016-03-04 10:47:42\n---\n\n N  A  BB  C A  C\n\n -1\n\n<!-- more -->\n\n### \n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"codevs-2822","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiri018y0jxlcegvlc9d"},{"title":"CodeVS 2598 -  DP","id":"17","updated":"2016-01-19T13:05:21.000Z","date":"2016-01-08T21:32:19.000Z","_content":"\n A  B  2  A  B\n\n1. \n2. \n3. \n\n A  B  A  B \n\n AB 4000\n\n<!-- more -->\n\n### \n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### \n\n `f[i][j]`  A  `i`  B  `j` \n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i]  B[j]} $$\n\n $ A[i]=B[j] $ \n\n $ A[i]B[j] $ \n\n1.  B  `j`  $A[i]$  $B[j-1]$  B  `j` \n2.  B  `j`  $A[i-1]$  $B[j]$  A  `i` \n3.  B  `j`  $A[i-1]$  $B[j-1]$  A  `i`  B  `j` \n\n### \n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```\n","source":"_posts/codevs-2598.md","raw":"title: CodeVS 2598 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\npermalink: codevs-2598\nid: 17\nupdated: '2016-01-19 21:05:21'\ndate: 2016-01-09 05:32:19\n---\n\n A  B  2  A  B\n\n1. \n2. \n3. \n\n A  B  A  B \n\n AB 4000\n\n<!-- more -->\n\n### \n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### \n\n `f[i][j]`  A  `i`  B  `j` \n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i]  B[j]} $$\n\n $ A[i]=B[j] $ \n\n $ A[i]B[j] $ \n\n1.  B  `j`  $A[i]$  $B[j-1]$  B  `j` \n2.  B  `j`  $A[i-1]$  $B[j]$  A  `i` \n3.  B  `j`  $A[i-1]$  $B[j-1]$  A  `i`  B  `j` \n\n### \n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```\n","slug":"codevs-2598","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jirr01950jxl22kg9cfx"},{"title":"CodeVS 1563 - ","id":"42","updated":"2016-02-06T14:23:12.000Z","date":"2016-02-05T13:06:41.000Z","_content":"\n `s`  `t` \n\n<!-- more -->\n\n### \n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[ 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### \n\n\n\n\n  \n\n `i`  `i'` `i` `i'`  `i`  `i'`  1 `(i, j)` `(i', j)`\n\n `s'`  `t`  `s`  `t'`\n\n###\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1563.md","raw":"title: CodeVS 1563 - \ncategories: OI\ntags: \n  - CodeVS\n  - USACO\n  - \n  - Dinic\n  - \npermalink: codevs-1563\nid: 42\nupdated: '2016-02-06 22:23:12'\ndate: 2016-02-05 21:06:41\n---\n\n `s`  `t` \n\n<!-- more -->\n\n### \n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[ 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### \n\n\n\n\n  \n\n `i`  `i'` `i` `i'`  `i`  `i'`  1 `(i, j)` `(i', j)`\n\n `s'`  `t`  `s`  `t'`\n\n###\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","slug":"codevs-1563","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jirx019b0jxlpre59c2m"},{"title":"CodeVS 1345 -  DP","id":"21","updated":"2016-01-19T13:04:02.000Z","date":"2016-01-13T21:17:18.000Z","_content":"\n `n` 1000\n\n<!-- more -->\n\n### \n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### \n \n\n  ****\n\n $ f[i] $  `i`  `i` \n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n****\n\n $ max\\{f[i],i{\\in}[1,n]\\} $ $f[n]$\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1345.md","raw":"title: CodeVS 1345 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - USACO\n  - DP\n  -  DP\npermalink: codevs-1345\nid: 21\nupdated: '2016-01-19 21:04:02'\ndate: 2016-01-14 05:17:18\n---\n\n `n` 1000\n\n<!-- more -->\n\n### \n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### \n \n\n  ****\n\n $ f[i] $  `i`  `i` \n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n****\n\n $ max\\{f[i],i{\\in}[1,n]\\} $ $f[n]$\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"codevs-1345","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jis5019j0jxlz1kng6of"},{"title":"BZOJ 3881Divljak - AC  + ","date":"2016-09-17T23:27:00.000Z","_content":"\n $ n $  $ S_1, S_2, \\ldots, S_n $ $ T $  \n $ q $  $ T $  $ P $ $ T $  $ S_i $\n\n<!-- more -->\n\n### \n[BZOJ 3881](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)\n\n### \n $ S_i $  AC  $ P $  $ P $  $ +1 $\n\n $ O(n ^ 2) $  $ O(n) $ Fail \n\n $ P $  Fail **** $ +1 $\n\n DFS \n\n $ +1 $ $ -1 $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 2000000;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nint tot;\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tint id;\n\t\tbool isWord, visited;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, std::vector<int> &vec) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) vec.push_back(v->id);\n\t\t\telse if (v->next) vec.push_back(v->next->id);\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint l, r, depth, size;\n\tNode *p, *c, *top;\n\tbool visited;\n} N[MAXLEN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n#ifdef DBG\n\tprintf(\"addEdge: %d -> %d\\n\", s + 1, t + 1);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->fail != v) addEdge(v->id, v->fail->id);\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].depth = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) {\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->c || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->top = (!v->p || v != v->p->c) ? v : v->p->top;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) {\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) assert(N[i].l && N[i].r);\n\n#ifdef DBG\n\tfor (int i = 0; i < tot; i++) {\n\t\tprintf(\"N[%d] => [%d, %d]\\n\", i + 1, N[i].l, N[i].r);\n\t}\n#endif\n}\n\ninline Node *lca(Node *a, Node *b) {\n\twhile (a->top != b->top) {\n\t\tif (a->top->depth < b->top->depth) std::swap(a, b);\n\t\ta = a->top->p;\n\t}\n\tNode *res = a->depth < b->depth ? a : b;\n#ifdef DBG\n\tprintf(\"lca(%lu, %lu) = %lu\\n\", a - N + 1, b - N + 1, res - N + 1);\n#endif\n\treturn res;\n}\n\ninline bool compare(const int a, const int b) {\n\treturn N[a].l < N[b].l;\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN + 1 + 1 + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n#ifdef DBG\n\t\tprintf(\"BIT: %d add %d\\n\", pos, delta);\n#endif\n#ifdef FORCE\n\t\ta[pos] += delta;\n\t\treturn;\n#endif\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint sum(const int pos) {\n\t\tint res = 0;\n#ifdef FORCE\n\t\tfor (int i = 1; i <= pos; i++) res += a[i];\n\t\t// printf(\"sum(%d) = %d\\n\", pos, res);\n\t\treturn res;\n#endif\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef FORCE\n\t\tint res = 0;\n\t\tfor (int i = l; i <= r; i++) res += a[i];\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, res);\n\t\treturn res;\n#endif\n\t\treturn sum(r) - sum(l - 1);\n\t}\n} bit;\n\ninline void add(const char *begin, const char *end) {\n\tstd::vector<int> vec;\n\tt.exec(begin, end, vec);\n\tstd::sort(vec.begin(), vec.end(), compare);\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n#ifdef DBG\n\tprintf(\"%lu matched:\", vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++) printf(\" %d\", vec[i] + 1);\n\tputchar('\\n');\n#endif\n\n\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\tbit.update(N[vec[i]].l, 1);\n\t\tif (i != 0) {\n\t\t\tNode *p = lca(&N[vec[i]], &N[vec[i - 1]]);\n\t\t\tbit.update(p->l, -1);\n\t\t}\n\t}\n}\n\ninline int solve(const int x) {\n\treturn bit.query(N[x].l, N[x].r);\n}\n\nint main() {\n\tint n;\n\tstatic char s[MAXLEN + 1];\n\tscanf(\"%d\", &n);\n\tTrie::Node *a[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\ta[i] = t.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\tsplit();\n\tbit.init(tot);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tconst int len = strlen(s);\n#ifdef DBG\n\t\t\tprintf(\"add(\\\"%s\\\"): \", s);\n#endif\n\t\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\t\tadd(s, s + len);\n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%d\\n\", solve(a[x]->id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/coci2015-divljak.md","raw":"title: BZOJ 3881Divljak - AC  + \ncategories: OI\ntags: \n  - BZOJ\n  - COCI\n  - \n  - AC \n  - \n  - \npermalink: bzoj-3881\ndate: 2016-09-18 07:27:00\n---\n\n $ n $  $ S_1, S_2, \\ldots, S_n $ $ T $  \n $ q $  $ T $  $ P $ $ T $  $ S_i $\n\n<!-- more -->\n\n### \n[BZOJ 3881](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)\n\n### \n $ S_i $  AC  $ P $  $ P $  $ +1 $\n\n $ O(n ^ 2) $  $ O(n) $ Fail \n\n $ P $  Fail **** $ +1 $\n\n DFS \n\n $ +1 $ $ -1 $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 2000000;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nint tot;\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tint id;\n\t\tbool isWord, visited;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, std::vector<int> &vec) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) vec.push_back(v->id);\n\t\t\telse if (v->next) vec.push_back(v->next->id);\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint l, r, depth, size;\n\tNode *p, *c, *top;\n\tbool visited;\n} N[MAXLEN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n#ifdef DBG\n\tprintf(\"addEdge: %d -> %d\\n\", s + 1, t + 1);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->fail != v) addEdge(v->id, v->fail->id);\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].depth = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) {\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->c || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->top = (!v->p || v != v->p->c) ? v : v->p->top;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) {\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) assert(N[i].l && N[i].r);\n\n#ifdef DBG\n\tfor (int i = 0; i < tot; i++) {\n\t\tprintf(\"N[%d] => [%d, %d]\\n\", i + 1, N[i].l, N[i].r);\n\t}\n#endif\n}\n\ninline Node *lca(Node *a, Node *b) {\n\twhile (a->top != b->top) {\n\t\tif (a->top->depth < b->top->depth) std::swap(a, b);\n\t\ta = a->top->p;\n\t}\n\tNode *res = a->depth < b->depth ? a : b;\n#ifdef DBG\n\tprintf(\"lca(%lu, %lu) = %lu\\n\", a - N + 1, b - N + 1, res - N + 1);\n#endif\n\treturn res;\n}\n\ninline bool compare(const int a, const int b) {\n\treturn N[a].l < N[b].l;\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN + 1 + 1 + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n#ifdef DBG\n\t\tprintf(\"BIT: %d add %d\\n\", pos, delta);\n#endif\n#ifdef FORCE\n\t\ta[pos] += delta;\n\t\treturn;\n#endif\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint sum(const int pos) {\n\t\tint res = 0;\n#ifdef FORCE\n\t\tfor (int i = 1; i <= pos; i++) res += a[i];\n\t\t// printf(\"sum(%d) = %d\\n\", pos, res);\n\t\treturn res;\n#endif\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef FORCE\n\t\tint res = 0;\n\t\tfor (int i = l; i <= r; i++) res += a[i];\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, res);\n\t\treturn res;\n#endif\n\t\treturn sum(r) - sum(l - 1);\n\t}\n} bit;\n\ninline void add(const char *begin, const char *end) {\n\tstd::vector<int> vec;\n\tt.exec(begin, end, vec);\n\tstd::sort(vec.begin(), vec.end(), compare);\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n#ifdef DBG\n\tprintf(\"%lu matched:\", vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++) printf(\" %d\", vec[i] + 1);\n\tputchar('\\n');\n#endif\n\n\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\tbit.update(N[vec[i]].l, 1);\n\t\tif (i != 0) {\n\t\t\tNode *p = lca(&N[vec[i]], &N[vec[i - 1]]);\n\t\t\tbit.update(p->l, -1);\n\t\t}\n\t}\n}\n\ninline int solve(const int x) {\n\treturn bit.query(N[x].l, N[x].r);\n}\n\nint main() {\n\tint n;\n\tstatic char s[MAXLEN + 1];\n\tscanf(\"%d\", &n);\n\tTrie::Node *a[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\ta[i] = t.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\tsplit();\n\tbit.init(tot);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tconst int len = strlen(s);\n#ifdef DBG\n\t\t\tprintf(\"add(\\\"%s\\\"): \", s);\n#endif\n\t\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\t\tadd(s, s + len);\n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%d\\n\", solve(a[x]->id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3881","published":1,"updated":"2016-09-18T23:01:08.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jisf019p0jxlrat500k9"},{"title":"","date":"2016-05-11T13:06:00.000Z","_content":"\n $ k $ \n\n<!-- more -->\n\n### \n\n\n $ k $    $ k $  $ k $  $ k $  $ k $ \n\n $ O(\\log n) $\n\n### \n $ k $  $ n $  $ a $  $ n $  $ i $ $ a_1 $ ~ $ a_i $  $ [l, r] $  $ k $  $ r $  $ l - 1 $  $ k $ \n\n\n\n1.  $ O(n \\log n) $  $ O(n ^ 2 \\log n) $\n2.  $ O(n \\log n) $  $ O(n \\log n) $  $ O((n + m) n \\log n) $\n\n**** $ O(n ^ 2) $ \n\n### \n $ n $  $ O(\\log n) $  $ O(n \\log n) $ \n\n $ 0 $  $ O(\\log n) $  $ O(n \\log n) $\n\n $ O(n \\log n) $  $ O(\\log n) $ \n\n### \n[POJ 2104](http://poj.org/problem?id=2104)  \n\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/chairman-tree-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: chairman-tree-notes\ndate: 2016-05-11 21:06:00\n---\n\n $ k $ \n\n<!-- more -->\n\n### \n\n\n $ k $    $ k $  $ k $  $ k $  $ k $ \n\n $ O(\\log n) $\n\n### \n $ k $  $ n $  $ a $  $ n $  $ i $ $ a_1 $ ~ $ a_i $  $ [l, r] $  $ k $  $ r $  $ l - 1 $  $ k $ \n\n\n\n1.  $ O(n \\log n) $  $ O(n ^ 2 \\log n) $\n2.  $ O(n \\log n) $  $ O(n \\log n) $  $ O((n + m) n \\log n) $\n\n**** $ O(n ^ 2) $ \n\n### \n $ n $  $ O(\\log n) $  $ O(n \\log n) $ \n\n $ 0 $  $ O(\\log n) $  $ O(n \\log n) $\n\n $ O(n \\log n) $  $ O(\\log n) $ \n\n### \n[POJ 2104](http://poj.org/problem?id=2104)  \n\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"chairman-tree-notes","published":1,"updated":"2016-05-11T13:06:44.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jisv019z0jxlfp30zchk"},{"title":"Codeforces 716EDigit Tree - ","date":"2016-09-21T02:30:00.000Z","_content":"\n $ [1, 9] $  $ (u, v) $  $ u $  $ v $  $ m $  $ \\gcd(m, 10) = 1 $\n\n<!-- more -->\n\n### \n[Codeforces 716E](http://codeforces.com/contest/716/problem/E)\n\n### \n\n\n $ a_i $  $ i $ $ b_i $ $ d_i $  $ i $  $ a_i $  $ b_i $ \n\n![](/cf-716e/example.svg)\n\n$$\n\\begin{cases}\na_u = 321 & a_v = 54 \\\\\nb_u = 123 & b_v = 45 \\\\\nd_u = 3 & d_v = 2\n\\end{cases}\n$$\n\n $ u $  $ v $ \n\n$$ a_u \\times 10 ^ {d_v} + b_v $$\n\n\n\n$$ a_u \\times 10 ^ {d_v} + b_v \\equiv 0 \\pmod m $$\n\n $ a_i $  $ b_i $ \n\n\n\n$$ a_u \\equiv -b_v \\times \\frac{1}{10 ^ {d_v}} \\pmod m $$\n\n $ u $ $ a_u $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tint size, depth, max;\n\tbool visited, solved;\n\tlong long backward, forward;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, mod;\nlong long pow10[MAXN + 1], pow10Inv[MAXN + 1];\n\nvoid exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long x) {\n\tlong long tmp1, res, tmp2;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline long long calc(Node *root, const int pre = 0) {\n\tif (pre != 0) {\n\t\troot->forward = root->backward = pre;\n\t\troot->depth = 1;\n\t} else {\n\t\troot->forward = root->backward = 0;\n\t\troot->depth = 0;\n\t}\n\troot->parent = NULL;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\n\tstd::map<long long, int> map;\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tmap[(mod - v->forward) * pow10Inv[v->depth] % mod]++;\n\t\tassert((mod - v->forward) * pow10Inv[v->depth] % mod >= 0);\n\t\ta[cnt++] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->forward = (v->forward * 10 + e->w) % mod;\n\t\t\te->t->backward = (e->w * pow10[v->depth] + v->backward) % mod;\n#ifdef DBG\n\t\t\tprintf(\"%lld <--> %lld\\n\", e->t->forward, e->t->backward);\n#endif\n\t\t\te->t->parent = v;\n\t\t\te->t->depth = v->depth + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tlong long ans = 0; // pre ? 0 : -1 * 0;\n#ifdef FORCE\n\tfor (int i = 0; i < cnt; i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif ((a[i]->backward * pow10[a[j]->depth] + a[j]->forward) % 3 == 0 /*&& !(a[i]->backward == 0 && a[j]->forward == 0)*/) {\n\t\t\t\tans++;\n#ifdef DBG\n\t\t\t\tprintf(\"%lld\\n\", a[i]->backward * pow10[a[j]->depth] + a[j]->forward);\n#endif\n\t\t\t}\n\t\t\tif (a[i]->backward == 0 && a[j]->forward == 0) printf(\"%lu %lu in %lu, %d\\n\", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--;\n\t\t}\n\t}\n#else\n\tmap[0]--;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans += map[a[i]->backward];\n#ifdef DBG\n\t\tprintf(\"back = %lld, ans + %d\\n\", a[i]->backward, map[a[i]->backward]);\n#endif\n\t}\n#endif\n#ifdef DBG\n\tfor (std::map<long long, int>::const_iterator it = map.begin(); it != map.end(); it++) printf(\"[%lld => %d]\\n\", it->first, it->second);\n\tprintf(\"** ans = %lld\\n\", ans);\n#endif\n\n\treturn ans;\n}\n\ninline long long solve() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n#ifdef DBG\n\t\tputs(\"+++++++++++++++++++\");\n#endif\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n#ifdef DBG\n\t\t\tputs(\"-------------------\");\n#endif\n\t\t\tans -= calc(e->t, e->w);\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &mod);\n#ifdef FORCE\n\tmod = 1e9 + 7;\n#endif\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w % mod);\n\t}\n\n\tpow10[0] = pow10Inv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10 % mod;\n\t\tpow10Inv[i] = inv(pow10[i]);\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}\n```","source":"_posts/cf-716e.md","raw":"title: Codeforces 716EDigit Tree - \ncategories: OI\ntags: \n  - Codeforces\n  - \n  - \n  - \n  - \n  - \npermalink: cf-716e\ndate: 2016-09-21 10:30:00\n---\n\n $ [1, 9] $  $ (u, v) $  $ u $  $ v $  $ m $  $ \\gcd(m, 10) = 1 $\n\n<!-- more -->\n\n### \n[Codeforces 716E](http://codeforces.com/contest/716/problem/E)\n\n### \n\n\n $ a_i $  $ i $ $ b_i $ $ d_i $  $ i $  $ a_i $  $ b_i $ \n\n![](/cf-716e/example.svg)\n\n$$\n\\begin{cases}\na_u = 321 & a_v = 54 \\\\\nb_u = 123 & b_v = 45 \\\\\nd_u = 3 & d_v = 2\n\\end{cases}\n$$\n\n $ u $  $ v $ \n\n$$ a_u \\times 10 ^ {d_v} + b_v $$\n\n\n\n$$ a_u \\times 10 ^ {d_v} + b_v \\equiv 0 \\pmod m $$\n\n $ a_i $  $ b_i $ \n\n\n\n$$ a_u \\equiv -b_v \\times \\frac{1}{10 ^ {d_v}} \\pmod m $$\n\n $ u $ $ a_u $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tint size, depth, max;\n\tbool visited, solved;\n\tlong long backward, forward;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, mod;\nlong long pow10[MAXN + 1], pow10Inv[MAXN + 1];\n\nvoid exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long x) {\n\tlong long tmp1, res, tmp2;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline long long calc(Node *root, const int pre = 0) {\n\tif (pre != 0) {\n\t\troot->forward = root->backward = pre;\n\t\troot->depth = 1;\n\t} else {\n\t\troot->forward = root->backward = 0;\n\t\troot->depth = 0;\n\t}\n\troot->parent = NULL;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\n\tstd::map<long long, int> map;\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tmap[(mod - v->forward) * pow10Inv[v->depth] % mod]++;\n\t\tassert((mod - v->forward) * pow10Inv[v->depth] % mod >= 0);\n\t\ta[cnt++] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->forward = (v->forward * 10 + e->w) % mod;\n\t\t\te->t->backward = (e->w * pow10[v->depth] + v->backward) % mod;\n#ifdef DBG\n\t\t\tprintf(\"%lld <--> %lld\\n\", e->t->forward, e->t->backward);\n#endif\n\t\t\te->t->parent = v;\n\t\t\te->t->depth = v->depth + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tlong long ans = 0; // pre ? 0 : -1 * 0;\n#ifdef FORCE\n\tfor (int i = 0; i < cnt; i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif ((a[i]->backward * pow10[a[j]->depth] + a[j]->forward) % 3 == 0 /*&& !(a[i]->backward == 0 && a[j]->forward == 0)*/) {\n\t\t\t\tans++;\n#ifdef DBG\n\t\t\t\tprintf(\"%lld\\n\", a[i]->backward * pow10[a[j]->depth] + a[j]->forward);\n#endif\n\t\t\t}\n\t\t\tif (a[i]->backward == 0 && a[j]->forward == 0) printf(\"%lu %lu in %lu, %d\\n\", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--;\n\t\t}\n\t}\n#else\n\tmap[0]--;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans += map[a[i]->backward];\n#ifdef DBG\n\t\tprintf(\"back = %lld, ans + %d\\n\", a[i]->backward, map[a[i]->backward]);\n#endif\n\t}\n#endif\n#ifdef DBG\n\tfor (std::map<long long, int>::const_iterator it = map.begin(); it != map.end(); it++) printf(\"[%lld => %d]\\n\", it->first, it->second);\n\tprintf(\"** ans = %lld\\n\", ans);\n#endif\n\n\treturn ans;\n}\n\ninline long long solve() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n#ifdef DBG\n\t\tputs(\"+++++++++++++++++++\");\n#endif\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n#ifdef DBG\n\t\t\tputs(\"-------------------\");\n#endif\n\t\t\tans -= calc(e->t, e->w);\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &mod);\n#ifdef FORCE\n\tmod = 1e9 + 7;\n#endif\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w % mod);\n\t}\n\n\tpow10[0] = pow10Inv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10 % mod;\n\t\tpow10Inv[i] = inv(pow10[i]);\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}\n```","slug":"cf-716e","published":1,"updated":"2016-09-21T06:44:32.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jit201a50jxl7llyjv18"},{"title":"Codeforces 628DMagic Numbers -  DP","date":"2016-05-12T07:47:00.000Z","_content":"\n `d-magic`  $ d $ \n\n$ 1727374,\\ 17,\\ 1 $  `7-magic`  $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $  `7-magic` \n\n `m`  `d-magic`  $ [a, b] $ \n\n<!-- more -->\n\n### \n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### \n DP\n\n$$ f[n][limit][r] $$\n\n $ n $  $ limit $ $ m $  $ r $ \n\n $ [a, b] $  $ g(x) $  $ [0, x] $  $ g(b) - g(a - 1) $ $ a $  $ g(b) - g(a) $ $ a $ \n\n### \n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","source":"_posts/cf-628d.md","raw":"title: Codeforces 628DMagic Numbers -  DP\ncategories: OI\ntags: \n  - Codeforces\n  -  DP\n  - DP\npermalink: cf-628d\ndate: 2016-05-12 15:47:00\n---\n\n `d-magic`  $ d $ \n\n$ 1727374,\\ 17,\\ 1 $  `7-magic`  $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $  `7-magic` \n\n `m`  `d-magic`  $ [a, b] $ \n\n<!-- more -->\n\n### \n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### \n DP\n\n$$ f[n][limit][r] $$\n\n $ n $  $ limit $ $ m $  $ r $ \n\n $ [a, b] $  $ g(x) $  $ [0, x] $  $ g(b) - g(a - 1) $ $ a $  $ g(b) - g(a) $ $ a $ \n\n### \n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","slug":"cf-628d","published":1,"updated":"2016-10-24T23:38:39.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiti01ae0jxlfa5r1yru"},{"title":"CEOI2008Order - ","date":"2016-06-22T08:07:00.000Z","_content":"\n $ N $ $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1391](http://www.lydsy.com/JudgeOnline/problem.php?id=1391)\n\n### \n\n\n\n\n\n\n\n\n### \n MLE \n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #include <queue>\n// #include <vector>\n\nconst int MAXN = 1200;\nconst int MAXM = 1200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t// std::queue<Node *> q;\n\t\t// q.push(s);\n\t\tstatic Node *q[MAXN + MAXM + 2];\n\t\tNode **l = q, **r = q - 1;\n\t\t*++r = s;\n\n\t\ts->l = 1;\n\n\t\twhile (l <= r /* !q.empty() */) {\n\t\t\tNode *v = *l++ /* q.front() */;\n\t\t\t// q.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse *++r = e->t; // q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w, k;\n\t\tscanf(\"%d %d\", &w, &k);\n\t\tsum += w;\n\n\t\taddEdge(s, i, w);\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\taddEdge(i, n + x, c);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(n + i, t, x);\n\t}\n\n\t/*\n\tstatic int w[MAXN];\n\tstatic std::vector< std::pair<int, int> > used[MAXN];\n\tstatic std::vector<int> borrow[MAXM];\n\tstatic std::pair<int, int> buy[MAXM];\n\tint id = n + 1, sum = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k;\n\t\tscanf(\"%d %d\", &w[i - 1], &k);\n\t\tsum += w[i - 1];\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\tint t = id++;\n\t\t\tused[i - 1].push_back(std::make_pair(t, c));\n\t\t\tborrow[x - 1].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &buy[i].second);\n\t\tbuy[i].first = id++;\n\t}\n\n\tconst int s = 0, t = id++;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, w[i - 1]);\n\n\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) {\n\t\t\taddEdge(i, it->first, it->second);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (std::vector<int>::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) {\n\t\t\taddEdge(*it, buy[i].first, INT_MAX);\n\t\t}\n\t\taddEdge(buy[i].first, t, buy[i].second);\n\t}\n\t*/\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/ceoi2008-order.md","raw":"title: CEOI2008Order - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: ceoi2008-order\ndate: 2016-06-22 16:07:00\n---\n\n $ N $ $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1391](http://www.lydsy.com/JudgeOnline/problem.php?id=1391)\n\n### \n\n\n\n\n\n\n\n\n### \n MLE \n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #include <queue>\n// #include <vector>\n\nconst int MAXN = 1200;\nconst int MAXM = 1200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t// std::queue<Node *> q;\n\t\t// q.push(s);\n\t\tstatic Node *q[MAXN + MAXM + 2];\n\t\tNode **l = q, **r = q - 1;\n\t\t*++r = s;\n\n\t\ts->l = 1;\n\n\t\twhile (l <= r /* !q.empty() */) {\n\t\t\tNode *v = *l++ /* q.front() */;\n\t\t\t// q.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse *++r = e->t; // q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w, k;\n\t\tscanf(\"%d %d\", &w, &k);\n\t\tsum += w;\n\n\t\taddEdge(s, i, w);\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\taddEdge(i, n + x, c);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(n + i, t, x);\n\t}\n\n\t/*\n\tstatic int w[MAXN];\n\tstatic std::vector< std::pair<int, int> > used[MAXN];\n\tstatic std::vector<int> borrow[MAXM];\n\tstatic std::pair<int, int> buy[MAXM];\n\tint id = n + 1, sum = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k;\n\t\tscanf(\"%d %d\", &w[i - 1], &k);\n\t\tsum += w[i - 1];\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\tint t = id++;\n\t\t\tused[i - 1].push_back(std::make_pair(t, c));\n\t\t\tborrow[x - 1].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &buy[i].second);\n\t\tbuy[i].first = id++;\n\t}\n\n\tconst int s = 0, t = id++;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, w[i - 1]);\n\n\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) {\n\t\t\taddEdge(i, it->first, it->second);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (std::vector<int>::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) {\n\t\t\taddEdge(*it, buy[i].first, INT_MAX);\n\t\t}\n\t\taddEdge(buy[i].first, t, buy[i].second);\n\t}\n\t*/\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"ceoi2008-order","published":1,"updated":"2016-06-22T08:07:58.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jitp01aj0jxlngy9sfgo"},{"title":"CEOI2004 -  DP","date":"2016-05-18T10:03:00.000Z","_content":"\n $ n $ \n\n\n<!-- more -->\n\n### \n[COGS 362](http://cogs.top/cogs/problem/problem.php?pid=362)\n\n### \n $ 0 $ \n\n $ f[i][j] $  $ i $  $ j $  $ f(i) $  $ f[i][j] $$ g(i) $  $ f[i][j - 1] $$ S(i) $  $ i $  $ 0 $ $ s(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i} \\{ g(j) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n{(g(a) - S(a) + s(a) \\times d(a + 1)) - (g(b) - S(b) + s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1)} < s(i)\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 3;\n\nint n;\nlong long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1];\nlong long g[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n    std::reverse(w + 1, w + n + 1);\n    std::reverse(d + 1, d + n + 1);\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n        s[i] = s[i - 1] + w[i];\n        S[i] = S[i - 1] + w[i] * d[i];\n    }\n}\n\n/*\ninline void force() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int _j = -1;\n            for (int j = 0; j < i; j++) {\n                if (f[i] > g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                    f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                    _j = j;\n                }\n            }\n            printf(\"%d --> %d\\n\", i, _j);\n        }\n    }\n}\n*/\n\ninline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; }\n\ninline double slope(const int a, const int b) {\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n\ninline void dp() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n\n        static int q[MAXN];\n        int *l = q, *r = q;\n        *r = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n\n            int &j = *l;\n            f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n            // printf(\"%d --> %d\\n\", i, j);\n\n            if (i < n) {\n                while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n                *++r = i;\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"two.in\", \"r\", stdin);\n    freopen(\"two.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld\", &w[i], &d[i]);\n    }\n\n    prepare();\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/ceoi2004-two.md","raw":"title: CEOI2004 -  DP\ncategories: OI\ntags: \n  - COGS\n  - CEOI\n  - \n  - \n  - DP\npermalink: ceoi2004-two\ndate: 2016-05-18 18:03:00\n---\n\n $ n $ \n\n\n<!-- more -->\n\n### \n[COGS 362](http://cogs.top/cogs/problem/problem.php?pid=362)\n\n### \n $ 0 $ \n\n $ f[i][j] $  $ i $  $ j $  $ f(i) $  $ f[i][j] $$ g(i) $  $ f[i][j - 1] $$ S(i) $  $ i $  $ 0 $ $ s(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i} \\{ g(j) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n{(g(a) - S(a) + s(a) \\times d(a + 1)) - (g(b) - S(b) + s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1)} < s(i)\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 3;\n\nint n;\nlong long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1];\nlong long g[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n    std::reverse(w + 1, w + n + 1);\n    std::reverse(d + 1, d + n + 1);\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n        s[i] = s[i - 1] + w[i];\n        S[i] = S[i - 1] + w[i] * d[i];\n    }\n}\n\n/*\ninline void force() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int _j = -1;\n            for (int j = 0; j < i; j++) {\n                if (f[i] > g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                    f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                    _j = j;\n                }\n            }\n            printf(\"%d --> %d\\n\", i, _j);\n        }\n    }\n}\n*/\n\ninline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; }\n\ninline double slope(const int a, const int b) {\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n\ninline void dp() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n\n        static int q[MAXN];\n        int *l = q, *r = q;\n        *r = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n\n            int &j = *l;\n            f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n            // printf(\"%d --> %d\\n\", i, j);\n\n            if (i < n) {\n                while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n                *++r = i;\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"two.in\", \"r\", stdin);\n    freopen(\"two.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld\", &w[i], &d[i]);\n    }\n\n    prepare();\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"ceoi2004-two","published":1,"updated":"2016-10-24T23:34:14.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jity01ap0jxlnkaar0tr"},{"title":"BZOJ 4403 - ","date":"2016-04-08T14:11:34.000Z","_content":"\n $ N $$ L $  $ R $ $ 1 $  $ N $  $ L $  $ R $  $ 10 ^ 6 + 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### \n $ [1, R - L + 1] $  $ N $ \n\n\n\n$$ M = R - L + 1 $$\n\n\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n Lucas \n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n $ n \\lt p, m \\lt p $ ****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4403.md","raw":"title: BZOJ 4403 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - \n  - Lucas \n  - \npermalink: bzoj-4403\ndate: 2016-04-08 22:11:34\n---\n\n $ N $$ L $  $ R $ $ 1 $  $ N $  $ L $  $ R $  $ 10 ^ 6 + 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### \n $ [1, R - L + 1] $  $ N $ \n\n\n\n$$ M = R - L + 1 $$\n\n\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n Lucas \n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n $ n \\lt p, m \\lt p $ ****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4403","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiu701ax0jxlu9758zln"},{"title":"BZOJ 4318OSU! - ","date":"2016-05-31T09:32:00.000Z","_content":"\n osu! : \n\n $ n $  $ 1 $ $ 0 $$ n $  $ 1 $  $ n $  01  $ x $  $ 1 $  $ x ^ 3 $  $ x $  $ 1 $  $ 1 $  $ 1 $\n\n $ n $\n\n<!-- more -->\n\n### \n[BZOJ 4318](http://www.lydsy.com/JudgeOnline/problem.php?id=4318)\n\n### \n $ f(i) $  $ i $ $ p(i) $  $ i $ \n\n $ 1 $  $ x $  $ i $  $ x_i = x_{i - 1} + 1 $ $ x ^ 3 $ \n\n$$ (x + 1) ^ 3 - x ^ 3 = 3x ^ 2 + 3x + 1 $$\n\n $ E_{x ^ 2} $  $ E_x $\n\n$$ E_{(x + 1) ^ 3 - x ^ 3} = 3E_{x ^ 2} + 3E_x + 1 $$\n\n $ i - 1 $ \n\n$$ f(i) = f(i - 1) + (3E_{x ^ 2}(i) + 3E_x(i) + 1) \\times p(i) $$\n\n $ E_{x ^ 2}(i) $  $ E_x(i) $\n\n\n\n$$ E_{x + 1} = E_x + 1 $$\n\n $ p(i) $  $ 1 $  $ 1 - p(i) $  $ 0 $\n\n$$ E_x(i) = (E_x(i - 1) + 1) \\times p(i) $$\n\n\n\n$$ E_{(x + 1) ^ 2} = E_{x ^ 2} + 2E_{x} + 1 $$\n\n\n\n$$ E_{x ^ 2}(i) = E_{x ^ 2}(i - 1) + 2E_{x}(i - 1) + 1 $$\n\n$ E_{x ^ 2}(i) $$ E_{x}(i) $$ f(i) $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n\nconst int MAXN = 100000;\n\nint n;\ndouble p[MAXN + 1], f[MAXN + 1];\ndouble ex1[MAXN + 1], ex2[MAXN + 1];\n\ninline void dp() {\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tex1[i] = (ex1[i - 1] + 1) * p[i];\n\t\tex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i];\n\t\tdouble t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i];\n\t\tf[i] = f[i - 1] + t;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n\n\tdp();\n\n\tprintf(\"%.1lf\\n\", floor(f[n] * 10 + 0.5) / 10);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4318.md","raw":"title: BZOJ 4318OSU! - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - DP\npermalink: bzoj-4318\ndate: 2016-05-31 17:32:00\n---\n\n osu! : \n\n $ n $  $ 1 $ $ 0 $$ n $  $ 1 $  $ n $  01  $ x $  $ 1 $  $ x ^ 3 $  $ x $  $ 1 $  $ 1 $  $ 1 $\n\n $ n $\n\n<!-- more -->\n\n### \n[BZOJ 4318](http://www.lydsy.com/JudgeOnline/problem.php?id=4318)\n\n### \n $ f(i) $  $ i $ $ p(i) $  $ i $ \n\n $ 1 $  $ x $  $ i $  $ x_i = x_{i - 1} + 1 $ $ x ^ 3 $ \n\n$$ (x + 1) ^ 3 - x ^ 3 = 3x ^ 2 + 3x + 1 $$\n\n $ E_{x ^ 2} $  $ E_x $\n\n$$ E_{(x + 1) ^ 3 - x ^ 3} = 3E_{x ^ 2} + 3E_x + 1 $$\n\n $ i - 1 $ \n\n$$ f(i) = f(i - 1) + (3E_{x ^ 2}(i) + 3E_x(i) + 1) \\times p(i) $$\n\n $ E_{x ^ 2}(i) $  $ E_x(i) $\n\n\n\n$$ E_{x + 1} = E_x + 1 $$\n\n $ p(i) $  $ 1 $  $ 1 - p(i) $  $ 0 $\n\n$$ E_x(i) = (E_x(i - 1) + 1) \\times p(i) $$\n\n\n\n$$ E_{(x + 1) ^ 2} = E_{x ^ 2} + 2E_{x} + 1 $$\n\n\n\n$$ E_{x ^ 2}(i) = E_{x ^ 2}(i - 1) + 2E_{x}(i - 1) + 1 $$\n\n$ E_{x ^ 2}(i) $$ E_{x}(i) $$ f(i) $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n\nconst int MAXN = 100000;\n\nint n;\ndouble p[MAXN + 1], f[MAXN + 1];\ndouble ex1[MAXN + 1], ex2[MAXN + 1];\n\ninline void dp() {\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tex1[i] = (ex1[i - 1] + 1) * p[i];\n\t\tex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i];\n\t\tdouble t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i];\n\t\tf[i] = f[i - 1] + t;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n\n\tdp();\n\n\tprintf(\"%.1lf\\n\", floor(f[n] * 10 + 0.5) / 10);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4318","published":1,"updated":"2016-05-31T12:06:27.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jium01b70jxltukfy57l"},{"title":"BZOJ 4247 -  DP","date":"2016-07-11T15:22:00.000Z","_content":"\nJOI  $ N $  $ 1 \\to N $ JOI\n\n $ 1 $ \n\nJOI \n\n<!-- more -->\n\n### \n[BZOJ 4247](http://www.lydsy.com/JudgeOnline/problem.php?id=4247)\n\n### \n $ -n $  $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic struct Array {\n\t\tint a[MAXN * 2 + 1];\n\t\tint &operator[](const int i) { return a[i + MAXN]; }\n\t} f[MAXN + 1];\n\n\tfor (int i = -n; i < 0; i++) f[0][i] = INT_MIN;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, v;\n\t\tscanf(\"%d %d\", &x, &v);\n\n\t\tconst int w = 1 - x;\n\n\t\tfor (int j = -n; j <= n; j++) {\n\t\t\tif (j - w >= -n && j - w <= n && f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v);\n\t\t\telse if (j - w > n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v);\n\t\t\telse f[i][j] = f[i - 1][j];\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = -n; i <= 1; i++) ans = std::max(ans, f[n][i]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4247.md","raw":"title: BZOJ 4247 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-4247\ndate: 2016-07-11 23:22:00\n---\n\nJOI  $ N $  $ 1 \\to N $ JOI\n\n $ 1 $ \n\nJOI \n\n<!-- more -->\n\n### \n[BZOJ 4247](http://www.lydsy.com/JudgeOnline/problem.php?id=4247)\n\n### \n $ -n $  $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic struct Array {\n\t\tint a[MAXN * 2 + 1];\n\t\tint &operator[](const int i) { return a[i + MAXN]; }\n\t} f[MAXN + 1];\n\n\tfor (int i = -n; i < 0; i++) f[0][i] = INT_MIN;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, v;\n\t\tscanf(\"%d %d\", &x, &v);\n\n\t\tconst int w = 1 - x;\n\n\t\tfor (int j = -n; j <= n; j++) {\n\t\t\tif (j - w >= -n && j - w <= n && f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v);\n\t\t\telse if (j - w > n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v);\n\t\t\telse f[i][j] = f[i - 1][j];\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = -n; i <= 1; i++) ans = std::max(ans, f[n][i]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4247","published":1,"updated":"2016-10-24T23:34:05.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiuw01bd0jxl8aydlzrj"},{"title":"BZOJ 4145The Prices -  DP","date":"2016-07-11T15:29:00.000Z","_content":"\n $ m $  $ n $  $ i $  $ d(i) $ $ i $  $ j $  $ c(i)(j) $\n\n<!-- more -->\n\n### \n[BZOJ 4145](http://www.lydsy.com/JudgeOnline/problem.php?id=4145)\n\n### \n $ f(i, j) $  $ i $  $ j $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int maxn = 100;\nconst int maxm = 16;\nconst int maxstatus = 1 << 16;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int c[maxn][maxm], d[maxn];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d[i]);\n\t\tfor (int j = 0; j < m; j++) scanf(\"%d\", &c[i][j]);\n\t}\n\n\tstatic int f[maxn][maxstatus];\n\tfor (int j = 0; j < (1 << m); j++) {\n\t\tf[0][j] = d[0];\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (j & (1 << k)) f[0][j] += c[0][k];\n\t\t}\n\t}\n\tf[0][0] = 0;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = f[i - 1][j] + d[i];\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (j & (1 << k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 << k)] + c[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", f[n - 1][(1 << m) - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4145.md","raw":"title: BZOJ 4145The Prices -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-4145\ndate: 2016-07-11 23:29:00\n---\n\n $ m $  $ n $  $ i $  $ d(i) $ $ i $  $ j $  $ c(i)(j) $\n\n<!-- more -->\n\n### \n[BZOJ 4145](http://www.lydsy.com/JudgeOnline/problem.php?id=4145)\n\n### \n $ f(i, j) $  $ i $  $ j $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int maxn = 100;\nconst int maxm = 16;\nconst int maxstatus = 1 << 16;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int c[maxn][maxm], d[maxn];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d[i]);\n\t\tfor (int j = 0; j < m; j++) scanf(\"%d\", &c[i][j]);\n\t}\n\n\tstatic int f[maxn][maxstatus];\n\tfor (int j = 0; j < (1 << m); j++) {\n\t\tf[0][j] = d[0];\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (j & (1 << k)) f[0][j] += c[0][k];\n\t\t}\n\t}\n\tf[0][0] = 0;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = f[i - 1][j] + d[i];\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (j & (1 << k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 << k)] + c[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", f[n - 1][(1 << m) - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4145","published":1,"updated":"2016-10-24T23:33:52.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiv401bi0jxl44g6o5y8"},{"title":"BZOJ 3940Censoring - AC ","date":"2016-09-13T23:52:00.000Z","_content":"\n $ S $  $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 3940](http://www.lydsy.com/JudgeOnline/problem.php?id=3940)\n\n### \n AC \n\n  \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <list>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint length;\n\n\t\tNode(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, end - begin);\n\t\telse (*v)->isWord = true, (*v)->length = end - begin;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(std::list<char> &list) {\n\t\tNode *v = root;\n\t\tstd::stack<Node *> history;\n\t\tfor (std::list<char>::iterator it = list.begin(); it != list.end(); ) {\n\t\t\thistory.push(v);\n\t\t\t// while (v != root && !v->c[*it]) v = v->fail, assert(false);\n\t\t\tif (v->c[*it]) v = v->c[*it];\n\t\t\tif (!v->isWord && v->next) v = v->next;\n\t\t\tif (v->isWord) {\n\t\t\t\tfor (int i = 1; i < v->length; i++) it--;\n\t\t\t\tfor (int i = 0; i < v->length; i++) it = list.erase(it);\n\t\t\t\tfor (int i = 1; i < v->length; i++) history.pop();\n\t\t\t\tv = history.top();\n\t\t\t\thistory.pop();\n\t\t\t} else it++;\n\t\t}\n\t}\n} t;\n\nint main() {\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tstd::list<char> list;\n\tfor (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tt.exec(list);\n\n\tfor (std::list<char>::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR);\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3940.md","raw":"title: BZOJ 3940Censoring - AC \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - AC \n  - \n  - \npermalink: bzoj-3940\ndate: 2016-09-14 07:52:00\n---\n\n $ S $  $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 3940](http://www.lydsy.com/JudgeOnline/problem.php?id=3940)\n\n### \n AC \n\n  \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <list>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint length;\n\n\t\tNode(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, end - begin);\n\t\telse (*v)->isWord = true, (*v)->length = end - begin;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(std::list<char> &list) {\n\t\tNode *v = root;\n\t\tstd::stack<Node *> history;\n\t\tfor (std::list<char>::iterator it = list.begin(); it != list.end(); ) {\n\t\t\thistory.push(v);\n\t\t\t// while (v != root && !v->c[*it]) v = v->fail, assert(false);\n\t\t\tif (v->c[*it]) v = v->c[*it];\n\t\t\tif (!v->isWord && v->next) v = v->next;\n\t\t\tif (v->isWord) {\n\t\t\t\tfor (int i = 1; i < v->length; i++) it--;\n\t\t\t\tfor (int i = 0; i < v->length; i++) it = list.erase(it);\n\t\t\t\tfor (int i = 1; i < v->length; i++) history.pop();\n\t\t\t\tv = history.top();\n\t\t\t\thistory.pop();\n\t\t\t} else it++;\n\t\t}\n\t}\n} t;\n\nint main() {\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tstd::list<char> list;\n\tfor (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tt.exec(list);\n\n\tfor (std::list<char>::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR);\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","slug":"bzoj-3940","published":1,"updated":"2016-09-13T23:47:40.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jive01bn0jxlu624pw3g"},{"title":"BZOJ 3894 - ","date":"2016-06-21T09:51:00.000Z","_content":"\n P  $ n \\times m $ \n\n1.  $ i $  $ j $  $ a[i][j] $  $ b[i][j] $ \n2.  $ i $  $ j $  $ A[i][j] $ \n3.  $ i $  $ j $  $ B[i][j] $ \n\n P \n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n $ 3 $  TA  $ b[i][j] - a[i][j] $TA  TA TA  TA   \n**TA  TA ** TA  TA  TA  TA \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 3 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3];\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &A[i][j]), sum += A[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &B[i][j]);\n\t\n\tint x = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < 3; k++) id[i][j][k] = x++;\n\n\tconst int s = 0, t = n * m * 3 + 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n\t\t\telse addEdge(id[i][j][0], t, -x);\n\t\t\taddEdge(id[i][j][1], t, A[i][j]);\n\t\t\taddEdge(s, id[i][j][2], B[i][j]), sum += B[i][j];\n\n\t\t\taddEdge(id[i][j][0], id[i][j][1], INT_MAX);\n\t\t\taddEdge(id[i][j][2], id[i][j][0], INT_MAX);\n\n\t\t\tif (i != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m * 3 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3894.md","raw":"title: BZOJ 3894 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3894\ndate: 2016-06-21 17:51:00\n---\n\n P  $ n \\times m $ \n\n1.  $ i $  $ j $  $ a[i][j] $  $ b[i][j] $ \n2.  $ i $  $ j $  $ A[i][j] $ \n3.  $ i $  $ j $  $ B[i][j] $ \n\n P \n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n $ 3 $  TA  $ b[i][j] - a[i][j] $TA  TA TA  TA   \n**TA  TA ** TA  TA  TA  TA \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 3 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3];\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &A[i][j]), sum += A[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &B[i][j]);\n\t\n\tint x = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < 3; k++) id[i][j][k] = x++;\n\n\tconst int s = 0, t = n * m * 3 + 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n\t\t\telse addEdge(id[i][j][0], t, -x);\n\t\t\taddEdge(id[i][j][1], t, A[i][j]);\n\t\t\taddEdge(s, id[i][j][2], B[i][j]), sum += B[i][j];\n\n\t\t\taddEdge(id[i][j][0], id[i][j][1], INT_MAX);\n\t\t\taddEdge(id[i][j][2], id[i][j][0], INT_MAX);\n\n\t\t\tif (i != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m * 3 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3894","published":1,"updated":"2016-06-22T08:25:43.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jivv01bx0jxlx0tblncd"},{"title":"BZOJ 3796Mushroom -  + AC ","date":"2016-09-29T23:41:00.000Z","_content":"\n $ s_1, s_2, s_3 $ $ w $\n\n1. $ w $  $ s_1 $ \n2. $ w $  $ s_2 $ \n3. $ s_3 $  $ w $ \n\n<!-- more -->\n\n### \n[BZOJ 3796](http://www.lydsy.com/JudgeOnline/problem.php?id=3796)\n\n### \n $ s_1 $  $ s_2 $  $ s_1 $  $ s_2 $ \n\n 3 $ s_3 $  AC  $ s_3 $  $ s_1 $  $ i $  $ s_3 $  $ r(i) $ $ i $  $ r(i) - i + \\mathrm{len}(s_3) - 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\nconst int CHARSET_SIZE = 12;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail;\n\t\tbool isWord;\n\t\tint depth;\n\n\t\tNode(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p - BASE_CHAR];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root;\n\t\troot->depth = 0;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc->depth = v->depth + 1;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, bool *match) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\tif (v->isWord) match[p - begin - v->depth + 1] = true;\n\t\t}\n\t}\n} t;\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\ttemplate <typename T>\n\tvoid build(const T *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"build: %s\\n\", s);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) < n) st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\telse st[i][j] = st[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tint rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\telse {\n\t\t\tconst int t = log[r - l];\n\t\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t\t}\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint main() {\n\tstatic char buf[MAXN];\n\tscanf(\"%s\", buf);\n\tconst int n1 = strlen(buf);\n\tbuf[n1] = '$';\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n2 = strlen(buf + n1 + 1);\n\tsa1.build(buf, n1 + 1 + n2);\n\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n3 = strlen(buf + n1 + 1);\n\t// sa2.build(buf, n1 + 1 + n3);\n\n\tt.insert(buf + n1 + 1, buf + n1 + 1 + n3);\n\tt.build();\n\n\tstatic bool match[MAXN];\n\tt.exec(buf, buf + n1, match);\n\n\tstatic int nextMatch[MAXN];\n\tfor (int i = n1 - 1, x = INT_MAX; i >= 0; i--) {\n\t\tif (match[i]) x = i;\n\t\tnextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1;\n\t}\n\n#ifdef DBG\n\tputs(\"KMP:\");\n\tbuf[n1] = '\\0';\n\tfor (int i = 0; i < n1; i++) printf(\"%d %s\\n\", nextMatch[i], &buf[i]);\n#endif\n\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 1, x = -1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) l[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\tfor (int i = n1 + n2 + 1 - 1, x = -1; i >= 1; i--) {\n\t\tif (sa1.sa[i] < n1) r[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\n#ifdef DBG\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) printf(\"l[%d] = %d\\n\", i, l[i]);\n\t\tif (sa1.sa[i] < n1) printf(\"r[%d] = %d\\n\", i, r[i]);\n\t}\n#endif\n\n\tint ans = 0;\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] > n1) continue;\n\t\tint x;\n\t\tif (l[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (r[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3796.md","raw":"title: BZOJ 3796Mushroom -  + AC \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - AC \npermalink: bzoj-3796\ndate: 2016-09-30 07:41:00\n---\n\n $ s_1, s_2, s_3 $ $ w $\n\n1. $ w $  $ s_1 $ \n2. $ w $  $ s_2 $ \n3. $ s_3 $  $ w $ \n\n<!-- more -->\n\n### \n[BZOJ 3796](http://www.lydsy.com/JudgeOnline/problem.php?id=3796)\n\n### \n $ s_1 $  $ s_2 $  $ s_1 $  $ s_2 $ \n\n 3 $ s_3 $  AC  $ s_3 $  $ s_1 $  $ i $  $ s_3 $  $ r(i) $ $ i $  $ r(i) - i + \\mathrm{len}(s_3) - 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\nconst int CHARSET_SIZE = 12;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail;\n\t\tbool isWord;\n\t\tint depth;\n\n\t\tNode(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p - BASE_CHAR];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root;\n\t\troot->depth = 0;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc->depth = v->depth + 1;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, bool *match) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\tif (v->isWord) match[p - begin - v->depth + 1] = true;\n\t\t}\n\t}\n} t;\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\ttemplate <typename T>\n\tvoid build(const T *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"build: %s\\n\", s);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) < n) st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\telse st[i][j] = st[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tint rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\telse {\n\t\t\tconst int t = log[r - l];\n\t\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t\t}\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint main() {\n\tstatic char buf[MAXN];\n\tscanf(\"%s\", buf);\n\tconst int n1 = strlen(buf);\n\tbuf[n1] = '$';\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n2 = strlen(buf + n1 + 1);\n\tsa1.build(buf, n1 + 1 + n2);\n\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n3 = strlen(buf + n1 + 1);\n\t// sa2.build(buf, n1 + 1 + n3);\n\n\tt.insert(buf + n1 + 1, buf + n1 + 1 + n3);\n\tt.build();\n\n\tstatic bool match[MAXN];\n\tt.exec(buf, buf + n1, match);\n\n\tstatic int nextMatch[MAXN];\n\tfor (int i = n1 - 1, x = INT_MAX; i >= 0; i--) {\n\t\tif (match[i]) x = i;\n\t\tnextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1;\n\t}\n\n#ifdef DBG\n\tputs(\"KMP:\");\n\tbuf[n1] = '\\0';\n\tfor (int i = 0; i < n1; i++) printf(\"%d %s\\n\", nextMatch[i], &buf[i]);\n#endif\n\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 1, x = -1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) l[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\tfor (int i = n1 + n2 + 1 - 1, x = -1; i >= 1; i--) {\n\t\tif (sa1.sa[i] < n1) r[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\n#ifdef DBG\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) printf(\"l[%d] = %d\\n\", i, l[i]);\n\t\tif (sa1.sa[i] < n1) printf(\"r[%d] = %d\\n\", i, r[i]);\n\t}\n#endif\n\n\tint ans = 0;\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] > n1) continue;\n\t\tint x;\n\t\tif (l[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (r[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"bzoj-3796","published":1,"updated":"2016-09-29T23:48:43.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiw901c40jxl6cg3y307"},{"title":"BZOJ 3697 - ","date":"2016-06-15T02:26:00.000Z","_content":"\n\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3697](http://www.lydsy.com/JudgeOnline/problem.php?id=3697)\n\n### \n\n\n $ 0 $  $ -1 $\n\n DFS  $ f(i,\\ 0) $  $ i $ ** $ i $ **$ f(i,\\ 1) $  $ i $ ** $ i $ **\n\n $ i $  $ -i $    $ i $ \n\n DFS  $ c(i) $  $ i $  $ f(i,\\ 0) $  $ f(i,\\ 1 ) $ \n\n $ g(i,\\ 0) $$ g(i,\\ 1) $ \n\n$$ \\sum\\limits_i f(i,\\ 0) g(-i,\\ 1) + f(i,\\ 1) g(-i,\\ 0) + f(i,\\ 1) g(-i,\\ 1) $$\n\n $ g(0,\\ 0) $  $ 1 $\n\n$$ (g(0,\\ 0) - 1) \\times f(0,\\ 0) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100003;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, max, dist;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ntemplate <typename T, int L, int R>\nstruct Array {\n\tT a[R - L + 1];\n\n\tT &operator[](const int pos) { return a[pos - L]; }\n\n\tconst T &operator[](const int pos) const { return a[pos - L]; }\n};\n\nArray<long long [2], -(MAXN - 1), MAXN - 1> f, g;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline void dfs(Node *start, const int dist, int &max) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->dist = dist;\n\tstart->visited = false;\n\n\tstatic int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tf[v->dist][!cnt[v->dist] ? 0 : 1]++;\n\t\t\tcnt[v->dist]++;\n\n\t\t\tmax = std::max(max, v->dist);\n\t\t\tmax = std::max(max, abs(v->dist));\n\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tcnt[v->dist]--;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\n/*\ninline void print(const int max) {\n\tfor (int i = -max; i <= max; i++) {\n\t\tprintf(\"f[%d][0] = %lld, f[%d][1] = %lld\\n\", i, f[i][0], i, f[i][1]);\n\t\tprintf(\"g[%d][0] = %lld, g[%d][1] = %lld\\n\", i, g[i][0], i, g[i][1]);\n\t}\n\tputchar('\\n');\n}\n*/\n\ninline long long calc(Node *root) {\n\tlong long res = 0;\n\tint max = 0;\n\tg[0][0] = 1;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tint curr = 0;\n\t\tdfs(e->t, e->w, curr);\n\t\t// print(max);\n\n\t\tres += (g[0][0] - 1) * f[0][0];\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\t// printf(\"res += %lld\\n\", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]));\n\t\t\tres += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]);\n\t\t}\n\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\tg[i][0] += f[i][0];\n\t\t\tg[i][1] += f[i][1];\n\t\t\tf[i][0] = f[i][1] = 0;\n\t\t}\n\n\t\tmax = std::max(max, curr);\n\t}\n\n\tfor (int i = -max; i <= max; i++) {\n\t\tg[i][0] = g[i][1] = 0;\n\t}\n\n\t// printf(\"calc(%ld) = %lld\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline long long solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\t\tans += calc(root);\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\tif (w == 0) w = -1;\n\t\taddEdge(u, v, w);\n\t}\n\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\t// printf(\"counter: %lld\\n\", counter);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3697.md","raw":"title: BZOJ 3697 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3697\ndate: 2016-06-15 10:26:00\n---\n\n\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3697](http://www.lydsy.com/JudgeOnline/problem.php?id=3697)\n\n### \n\n\n $ 0 $  $ -1 $\n\n DFS  $ f(i,\\ 0) $  $ i $ ** $ i $ **$ f(i,\\ 1) $  $ i $ ** $ i $ **\n\n $ i $  $ -i $    $ i $ \n\n DFS  $ c(i) $  $ i $  $ f(i,\\ 0) $  $ f(i,\\ 1 ) $ \n\n $ g(i,\\ 0) $$ g(i,\\ 1) $ \n\n$$ \\sum\\limits_i f(i,\\ 0) g(-i,\\ 1) + f(i,\\ 1) g(-i,\\ 0) + f(i,\\ 1) g(-i,\\ 1) $$\n\n $ g(0,\\ 0) $  $ 1 $\n\n$$ (g(0,\\ 0) - 1) \\times f(0,\\ 0) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100003;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, max, dist;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ntemplate <typename T, int L, int R>\nstruct Array {\n\tT a[R - L + 1];\n\n\tT &operator[](const int pos) { return a[pos - L]; }\n\n\tconst T &operator[](const int pos) const { return a[pos - L]; }\n};\n\nArray<long long [2], -(MAXN - 1), MAXN - 1> f, g;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline void dfs(Node *start, const int dist, int &max) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->dist = dist;\n\tstart->visited = false;\n\n\tstatic int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tf[v->dist][!cnt[v->dist] ? 0 : 1]++;\n\t\t\tcnt[v->dist]++;\n\n\t\t\tmax = std::max(max, v->dist);\n\t\t\tmax = std::max(max, abs(v->dist));\n\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tcnt[v->dist]--;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\n/*\ninline void print(const int max) {\n\tfor (int i = -max; i <= max; i++) {\n\t\tprintf(\"f[%d][0] = %lld, f[%d][1] = %lld\\n\", i, f[i][0], i, f[i][1]);\n\t\tprintf(\"g[%d][0] = %lld, g[%d][1] = %lld\\n\", i, g[i][0], i, g[i][1]);\n\t}\n\tputchar('\\n');\n}\n*/\n\ninline long long calc(Node *root) {\n\tlong long res = 0;\n\tint max = 0;\n\tg[0][0] = 1;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tint curr = 0;\n\t\tdfs(e->t, e->w, curr);\n\t\t// print(max);\n\n\t\tres += (g[0][0] - 1) * f[0][0];\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\t// printf(\"res += %lld\\n\", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]));\n\t\t\tres += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]);\n\t\t}\n\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\tg[i][0] += f[i][0];\n\t\t\tg[i][1] += f[i][1];\n\t\t\tf[i][0] = f[i][1] = 0;\n\t\t}\n\n\t\tmax = std::max(max, curr);\n\t}\n\n\tfor (int i = -max; i <= max; i++) {\n\t\tg[i][0] = g[i][1] = 0;\n\t}\n\n\t// printf(\"calc(%ld) = %lld\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline long long solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\t\tans += calc(root);\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\tif (w == 0) w = -1;\n\t\taddEdge(u, v, w);\n\t}\n\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\t// printf(\"counter: %lld\\n\", counter);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3697","published":1,"updated":"2016-09-25T13:05:40.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiwh01ca0jxlk0fksknq"},{"title":"BZOJ 3511 - ","date":"2016-04-06T14:33:05.000Z","_content":"\n $ n $  $ m $  $ 1 $  $ A $$ n $  $ B $\n\n1.  $ i $ $ A $  $ VA_i $  $ B $  $ VB_i $ \n2.  $ i $ $ A $  $ EA_i $  $ B $  $ EB_i $  $ EC_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### \n $ A $  $ S $ $ B $  $ T $ \n\n $ u $ $ (S, u) = VA_i $ $ A $  $ (u, T) = VB_i $ $ B $ \n\n $ 1 $  $ n $ $ (S, 1) $  $ (n, T) $\n\n $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $  $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $\n\n $ A $  $ EB_i $  $ B $  $ EA_i $  $ EA_i $ $ EB_i $ \n\n$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3511.md","raw":"title: BZOJ 3511 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3511\ndate: 2016-04-06 22:33:05\n---\n\n $ n $  $ m $  $ 1 $  $ A $$ n $  $ B $\n\n1.  $ i $ $ A $  $ VA_i $  $ B $  $ VB_i $ \n2.  $ i $ $ A $  $ EA_i $  $ B $  $ EB_i $  $ EC_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### \n $ A $  $ S $ $ B $  $ T $ \n\n $ u $ $ (S, u) = VA_i $ $ A $  $ (u, T) = VB_i $ $ B $ \n\n $ 1 $  $ n $ $ (S, 1) $  $ (n, T) $\n\n $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $  $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $\n\n $ A $  $ EB_i $  $ B $  $ EA_i $  $ EA_i $ $ EB_i $ \n\n$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3511","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiwv01cf0jxl66e57f5q"},{"title":"BZOJ 3438 M  - ","date":"2016-06-21T07:18:00.000Z","_content":"\n M  $ A $  $ B $ $ n $ i $ A $  $ a_i $  $ B $  $ b_i $   \n $ m $  $ i $  $ A $  $ c_{1_i} $ $ B $  $ c_{2_i} $   \n\n\n<!-- more -->\n\n### \n[BZOJ 3438](http://www.lydsy.com/JudgeOnline/problem.php?id=3438)\n\n### \n $ A $  $ \\sum\\limits_{i = 1} ^ n a_i + \\sum\\limits_{i = 1} ^ m c_{1_i} $\n\n $ B $  $ B $  $ i $  $ c_{1_i} $ **** $ B $  $ i $  $ c_{2_i} $ \n\n $ B_i - A_i $ $ c_{1_i} $ $ c_{2_i} $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"[%d, %d] = %d\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\n\tconst int s = 0, t = n + m * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w = b[i - 1] - a[i - 1];\n\t\tif (w > 0) addEdge(s, i, w), sum += w;\n\t\telse addEdge(i, t, -w);\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint k, c1, c2;\n\t\tscanf(\"%d %d %d\", &k, &c1, &c2);\n\n\t\taddEdge(i, t, c1);\n\t\taddEdge(s, i + m, c2);\n\n\t\tsum += c1 + c2;\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(x, i, INT_MAX);\n\t\t\taddEdge(i + m, x, INT_MAX);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3438.md","raw":"title: BZOJ 3438 M  - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3438\ndate: 2016-06-21 15:18:00\n---\n\n M  $ A $  $ B $ $ n $ i $ A $  $ a_i $  $ B $  $ b_i $   \n $ m $  $ i $  $ A $  $ c_{1_i} $ $ B $  $ c_{2_i} $   \n\n\n<!-- more -->\n\n### \n[BZOJ 3438](http://www.lydsy.com/JudgeOnline/problem.php?id=3438)\n\n### \n $ A $  $ \\sum\\limits_{i = 1} ^ n a_i + \\sum\\limits_{i = 1} ^ m c_{1_i} $\n\n $ B $  $ B $  $ i $  $ c_{1_i} $ **** $ B $  $ i $  $ c_{2_i} $ \n\n $ B_i - A_i $ $ c_{1_i} $ $ c_{2_i} $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"[%d, %d] = %d\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\n\tconst int s = 0, t = n + m * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w = b[i - 1] - a[i - 1];\n\t\tif (w > 0) addEdge(s, i, w), sum += w;\n\t\telse addEdge(i, t, -w);\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint k, c1, c2;\n\t\tscanf(\"%d %d %d\", &k, &c1, &c2);\n\n\t\taddEdge(i, t, c1);\n\t\taddEdge(s, i + m, c2);\n\n\t\tsum += c1 + c2;\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(x, i, INT_MAX);\n\t\t\taddEdge(i + m, x, INT_MAX);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3438","published":1,"updated":"2016-06-21T07:18:27.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jix901cm0jxl98w2oj35"},{"title":"BZOJ 3365Distance Statistics - ","date":"2016-06-16T10:09:00.000Z","_content":"\n $ K $$ 1 \\leq K \\leq 10 ^ 9 $ $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 3365](http://www.lydsy.com/JudgeOnline/problem.php?id=3365)\n\n### \n [BZOJ 1468](bzoj-1468) \n\n### \n```c++\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// printf(\"start->size - cnt = %d\\n\", start->size - cnt);\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tchar s[2];\n\t\tscanf(\"%d %d %d %s\", &u, &v, &w, s), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3365.md","raw":"title: BZOJ 3365Distance Statistics - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3365\ndate: 2016-06-16 18:09:00\n---\n\n $ K $$ 1 \\leq K \\leq 10 ^ 9 $ $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 3365](http://www.lydsy.com/JudgeOnline/problem.php?id=3365)\n\n### \n [BZOJ 1468](bzoj-1468) \n\n### \n```c++\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// printf(\"start->size - cnt = %d\\n\", start->size - cnt);\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tchar s[2];\n\t\tscanf(\"%d %d %d %s\", &u, &v, &w, s), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3365","published":1,"updated":"2016-06-16T10:09:41.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jixp01ct0jxl7il6ob6a"},{"title":"BZOJ 3280 R  - ","date":"2016-09-03T23:21:00.000Z","_content":"\n $ n $  $ i $  $ a_i $  $ m $  $ j $  $ l_j $  $ p_j $ \n\n $ k $  $ i $  $ d_i $  $ q_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3280](http://www.lydsy.com/JudgeOnline/problem.php?id=3280)\n\n### \n\n\n $ a_i $\n\n $ m $  $ l_i $ $ p_i $\n\n $ i $  $ i + d_i $  $ q_i $\n\n $ a_i $ $ a_i $ $ \\sum a_i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXK = 50;\n\nstruct Node {\n\tstruct Edge *e, *in;\n\tbool q;\n\tint d, f;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].q = false;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].f = 0;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t}\n}\n\ninline void clear(const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t\tconst int s = 0, t = n * 2 + 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i, t, x, 0);\n\t\t\taddEdge(s, i + n, x, 0);\n\t\t\tsum += x;\n\n\t\t\tif (i != n) addEdge(i, i + 1, INT_MAX, 0);\n\t\t}\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\taddEdge(s, 1, a, b);\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b), a++;\n\t\t\tfor (int j = 1; j <= n - a; j++) addEdge(j + n, j + a, INT_MAX, b);\n\t\t}\n\n\t\tint flow, cost;\n\t\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\t\tprintf(\"Case %d: \", i);\n\t\tif (flow == sum) printf(\"%d\\n\", cost);\n\t\telse puts(\"impossible\");\n\n\t\tclear(n * 2 + 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3280.md","raw":"title: BZOJ 3280 R  - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Edmonds-Karp\npermalink: bzoj-3280\ndate: 2016-09-04 07:21:00\n---\n\n $ n $  $ i $  $ a_i $  $ m $  $ j $  $ l_j $  $ p_j $ \n\n $ k $  $ i $  $ d_i $  $ q_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3280](http://www.lydsy.com/JudgeOnline/problem.php?id=3280)\n\n### \n\n\n $ a_i $\n\n $ m $  $ l_i $ $ p_i $\n\n $ i $  $ i + d_i $  $ q_i $\n\n $ a_i $ $ a_i $ $ \\sum a_i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXK = 50;\n\nstruct Node {\n\tstruct Edge *e, *in;\n\tbool q;\n\tint d, f;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].q = false;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].f = 0;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t}\n}\n\ninline void clear(const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t\tconst int s = 0, t = n * 2 + 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i, t, x, 0);\n\t\t\taddEdge(s, i + n, x, 0);\n\t\t\tsum += x;\n\n\t\t\tif (i != n) addEdge(i, i + 1, INT_MAX, 0);\n\t\t}\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\taddEdge(s, 1, a, b);\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b), a++;\n\t\t\tfor (int j = 1; j <= n - a; j++) addEdge(j + n, j + a, INT_MAX, b);\n\t\t}\n\n\t\tint flow, cost;\n\t\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\t\tprintf(\"Case %d: \", i);\n\t\tif (flow == sum) printf(\"%d\\n\", cost);\n\t\telse puts(\"impossible\");\n\n\t\tclear(n * 2 + 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3280","published":1,"updated":"2016-09-10T11:54:33.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiy401cy0jxl6ggnbtmp"},{"title":"BZOJ 3277 -  +  + ","date":"2016-09-29T23:24:00.000Z","_content":"\n $ n $  $ n $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 3277](http://www.lydsy.com/JudgeOnline/problem.php?id=3277)  \n[Codeforces 204E](http://codeforces.com/problemset/problem/204/E)\n\n### \n$ \\geq x $  $ \\geq k $  $ x $ \n\n $ x $ $ \\geq x $  `set`  $ x $  $ < x $ \n\n $ x $  $ x - 1 $  $ x - 1 $  $ x - 1 $  $ x $ \n\n $ k = 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 100000 + MAXN;\n\nint s[MAXLEN];\nint n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN];\n\ninline void suffixArray() {\n\tstatic int set[MAXLEN], a[MAXLEN];\n\tstd::copy(s, s + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\t\t\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tbool unique = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\tif (unique) break;\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\nstruct UnionFindSet {\n\tint a[MAXLEN], l[MAXLEN], r[MAXLEN];\n\tstd::set<int> set[MAXLEN];\n\n\tvoid init(const int n, const int *belong) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = i;\n\t\t\trk[i] = 1;\n\t\t\tl[i] = r[i] = i;\n\t\t\tset[i].insert(belong[i]);\n\t\t}\n\t}\n\n\tint find(const int x) {\n\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t}\n\n\tint merge(const int x, const int y) {\n#ifdef DBG\n\t\tprintf(\"merge(%d, %d)\\n\", x, y);\n#endif\n\t\tint _x = find(x), _y = find(y);\n\t\tif (set[_x].size() < set[_y].size()) std::swap(_x, _y);\n\t\ta[_y] = _x;\n\t\tset[_x].insert(set[_y].begin(), set[_y].end());\n\t\tl[_x] = std::min(l[_x], l[_y]);\n\t\tr[_x] = std::max(r[_x], r[_y]);\n\t\treturn _x;\n\t}\n\n\tint uniqueCount(const int x) {\n\t\treturn set[x].size();\n\t}\n\n\tvoid getRange(const int x, int &l, int &r) {\n\t\tl = this->l[x];\n\t\tr = this->r[x];\n\t}\n} ufs;\n\nlong long gap[MAXLEN + 1];\ninline void apply(const int id, const int val = 1) {\n\tint l, r;\n\tufs.getRange(id, l, r);\n\tgap[l] += val, gap[r + 1] -= val;\n#ifdef DBG\n\tfor (int i = l; i <= r; i++) printf(\"ans[%d] += %d\\n\", belong[i], val);\n#endif\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d\", &m, &k);\n\n\tint *p = s;\n\tint spliter = 233;\n\tfor (int i = 0; i < m; i++) {\n#ifdef DBG\n\t\tprintf(\"%d\\n\", i);\n#endif\n\t\tpos[i] = p - s;\n\t\tstatic char buf[MAXLEN];\n\t\tscanf(\"%s\", buf);\n\t\tint len = strlen(buf);\n\t\tif (k == 1) {\n\t\t\tstd::cout << (static_cast<long long>(len) * (len + 1) / 2) << (i == m - 1 ? '\\n' : ' ');\n\t\t}\n\t\tfor (int i = 0; i < len; i++) *p++ = buf[i];\n\t\t*p++ = spliter++;\n\t}\n\t\n\tif (k == 1) return 0;\n\n\t*--p = '\\0';\n\tn = p - s;\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1;\n\tufs.init(n, belong);\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d %s\\n\", belong[i], ht[i], &s[sa[i]]);\n\t}\n#endif\n\n\tstd::vector<int> v[MAXLEN];\n\tint maxH = 0;\n\tfor (int i = 0; i < n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]);\n\tfor (int i = maxH; i > 0; i--) {\n#ifdef DBG\n\t\tprintf(\"Now processing h = %d\\n\", i);\n#endif\n\t\tstd::vector<int> vec;\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\tint id = ufs.merge(*it, *it - 1);\n\t\t\tif (ufs.uniqueCount(id) >= k) {\n\t\t\t\t// apply(id);\n\t\t\t\tvec.push_back(id);\n\t\t\t}\n\t\t}\n\t\tfor (std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it);\n\t\tstd::sort(vec.begin(), vec.end());\n\t\tstd::vector<int>::const_iterator end = std::unique(vec.begin(), vec.end());\n\t\tfor (std::vector<int>::const_iterator it = vec.begin(); it != end; it++) {\n\t\t\tint l, r;\n\t\t\tufs.getRange(*it, l, r);\n\t\t\tint x = ht[l];\n\t\t\tif (r != n - 1) x = std::max(x, ht[r + 1]);\n\t\t\tapply(*it, i - x);\n\t\t}\n\t}\n\n\tstatic long long ans[MAXN];\n\tfor (int i = 1; i < n; i++) gap[i] += gap[i - 1];\n\tfor (int i = 0; i < n; i++) ans[belong[i]] += gap[i];\n\n\t// for (int i = 0; i < m; i++) printf(\"%lld%c\", ans[i], i == m - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::cout << ans[i]; //  << (i == m - 1 ? '\\0' : ' ');\n\t\tif (i != m - 1) std::cout << ' ';\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3277.md","raw":"title: BZOJ 3277 -  +  + \ncategories: OI\ntags: \n  - BZOJ\n  - Codeforces\n  - \n  - \n  - \n  - \npermalink: bzoj-3277\ndate: 2016-09-30 07:24:00\n---\n\n $ n $  $ n $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 3277](http://www.lydsy.com/JudgeOnline/problem.php?id=3277)  \n[Codeforces 204E](http://codeforces.com/problemset/problem/204/E)\n\n### \n$ \\geq x $  $ \\geq k $  $ x $ \n\n $ x $ $ \\geq x $  `set`  $ x $  $ < x $ \n\n $ x $  $ x - 1 $  $ x - 1 $  $ x - 1 $  $ x $ \n\n $ k = 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 100000 + MAXN;\n\nint s[MAXLEN];\nint n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN];\n\ninline void suffixArray() {\n\tstatic int set[MAXLEN], a[MAXLEN];\n\tstd::copy(s, s + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\t\t\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tbool unique = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\tif (unique) break;\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\nstruct UnionFindSet {\n\tint a[MAXLEN], l[MAXLEN], r[MAXLEN];\n\tstd::set<int> set[MAXLEN];\n\n\tvoid init(const int n, const int *belong) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = i;\n\t\t\trk[i] = 1;\n\t\t\tl[i] = r[i] = i;\n\t\t\tset[i].insert(belong[i]);\n\t\t}\n\t}\n\n\tint find(const int x) {\n\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t}\n\n\tint merge(const int x, const int y) {\n#ifdef DBG\n\t\tprintf(\"merge(%d, %d)\\n\", x, y);\n#endif\n\t\tint _x = find(x), _y = find(y);\n\t\tif (set[_x].size() < set[_y].size()) std::swap(_x, _y);\n\t\ta[_y] = _x;\n\t\tset[_x].insert(set[_y].begin(), set[_y].end());\n\t\tl[_x] = std::min(l[_x], l[_y]);\n\t\tr[_x] = std::max(r[_x], r[_y]);\n\t\treturn _x;\n\t}\n\n\tint uniqueCount(const int x) {\n\t\treturn set[x].size();\n\t}\n\n\tvoid getRange(const int x, int &l, int &r) {\n\t\tl = this->l[x];\n\t\tr = this->r[x];\n\t}\n} ufs;\n\nlong long gap[MAXLEN + 1];\ninline void apply(const int id, const int val = 1) {\n\tint l, r;\n\tufs.getRange(id, l, r);\n\tgap[l] += val, gap[r + 1] -= val;\n#ifdef DBG\n\tfor (int i = l; i <= r; i++) printf(\"ans[%d] += %d\\n\", belong[i], val);\n#endif\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d\", &m, &k);\n\n\tint *p = s;\n\tint spliter = 233;\n\tfor (int i = 0; i < m; i++) {\n#ifdef DBG\n\t\tprintf(\"%d\\n\", i);\n#endif\n\t\tpos[i] = p - s;\n\t\tstatic char buf[MAXLEN];\n\t\tscanf(\"%s\", buf);\n\t\tint len = strlen(buf);\n\t\tif (k == 1) {\n\t\t\tstd::cout << (static_cast<long long>(len) * (len + 1) / 2) << (i == m - 1 ? '\\n' : ' ');\n\t\t}\n\t\tfor (int i = 0; i < len; i++) *p++ = buf[i];\n\t\t*p++ = spliter++;\n\t}\n\t\n\tif (k == 1) return 0;\n\n\t*--p = '\\0';\n\tn = p - s;\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1;\n\tufs.init(n, belong);\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d %s\\n\", belong[i], ht[i], &s[sa[i]]);\n\t}\n#endif\n\n\tstd::vector<int> v[MAXLEN];\n\tint maxH = 0;\n\tfor (int i = 0; i < n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]);\n\tfor (int i = maxH; i > 0; i--) {\n#ifdef DBG\n\t\tprintf(\"Now processing h = %d\\n\", i);\n#endif\n\t\tstd::vector<int> vec;\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\tint id = ufs.merge(*it, *it - 1);\n\t\t\tif (ufs.uniqueCount(id) >= k) {\n\t\t\t\t// apply(id);\n\t\t\t\tvec.push_back(id);\n\t\t\t}\n\t\t}\n\t\tfor (std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it);\n\t\tstd::sort(vec.begin(), vec.end());\n\t\tstd::vector<int>::const_iterator end = std::unique(vec.begin(), vec.end());\n\t\tfor (std::vector<int>::const_iterator it = vec.begin(); it != end; it++) {\n\t\t\tint l, r;\n\t\t\tufs.getRange(*it, l, r);\n\t\t\tint x = ht[l];\n\t\t\tif (r != n - 1) x = std::max(x, ht[r + 1]);\n\t\t\tapply(*it, i - x);\n\t\t}\n\t}\n\n\tstatic long long ans[MAXN];\n\tfor (int i = 1; i < n; i++) gap[i] += gap[i - 1];\n\tfor (int i = 0; i < n; i++) ans[belong[i]] += gap[i];\n\n\t// for (int i = 0; i < m; i++) printf(\"%lld%c\", ans[i], i == m - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::cout << ans[i]; //  << (i == m - 1 ? '\\0' : ' ');\n\t\tif (i != m - 1) std::cout << ' ';\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3277","published":1,"updated":"2016-09-29T23:40:34.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiyg01d40jxl9wxatk99"},{"title":"BZOJ 3275Number - ","date":"2016-05-23T13:50:00.000Z","_content":"\n $ N $ \n\n $ a,\\ b $  $ a,\\ b $ \n\n1.  $ c $ $ a ^ 2 + b ^ 2 = c ^ 2 $\n2. $ \\gcd(a,\\ b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 3275](http://www.lydsy.com/JudgeOnline/problem.php?id=3275)  \n[COGS 1389](http://cogs.top/cogs/problem/problem.php?pid=1389)\n\n### \n\n\n $ X $  $ Y $  $ X $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n\tlong long x;\n\tbool color, v;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const long long c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], 0);\n\t(N[u].e->r = N[v].e)->r = N[u].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlong long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tlong long flow = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->f += flow;\n\t\t\t\t\te->r->f -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlong long operator()(const int s, const int t, const int n) {\n\t\tlong long res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tlong long flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\nint n;\nbool flag[MAXN][MAXN];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\n\ntemplate <typename T>\ninline bool isSquare(const T x) {\n\tT t = static_cast<T>(sqrt(static_cast<double>(x)));\n\treturn t * t == x;\n}\n\ntemplate <typename T>\ninline T gcd(const T a, const T b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].color = true;\n\t\tN[i].v = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->v) {\n\t\t\t\t\te->t->v = true;\n\t\t\t\t\te->t->color = !v->color;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else assert(e->t->color != v->color);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void clean() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &N[i].x);\n\t\tsum += N[i].x;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (isSquare(sqr(N[i].x) + sqr(N[j].x)) && gcd(N[i].x, N[j].x) == 1) {\n\t\t\t\tflag[i][j] = flag[j][i] = true;\n\t\t\t\taddEdge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcolor();\n\tclean();\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].color) addEdge(s, i, N[i].x);\n\t\telse addEdge(i, t, N[i].x);\n\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (flag[i][j]) {\n\t\t\t\tif (N[i].color) addEdge(i, j, LLONG_MAX);\n\t\t\t\telse addEdge(j, i, LLONG_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%lld\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3275.md","raw":"title: BZOJ 3275Number - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \n  - \npermalink: bzoj-3275\ndate: 2016-05-23 21:50:00\n---\n\n $ N $ \n\n $ a,\\ b $  $ a,\\ b $ \n\n1.  $ c $ $ a ^ 2 + b ^ 2 = c ^ 2 $\n2. $ \\gcd(a,\\ b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 3275](http://www.lydsy.com/JudgeOnline/problem.php?id=3275)  \n[COGS 1389](http://cogs.top/cogs/problem/problem.php?pid=1389)\n\n### \n\n\n $ X $  $ Y $  $ X $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n\tlong long x;\n\tbool color, v;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const long long c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], 0);\n\t(N[u].e->r = N[v].e)->r = N[u].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlong long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tlong long flow = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->f += flow;\n\t\t\t\t\te->r->f -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlong long operator()(const int s, const int t, const int n) {\n\t\tlong long res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tlong long flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\nint n;\nbool flag[MAXN][MAXN];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\n\ntemplate <typename T>\ninline bool isSquare(const T x) {\n\tT t = static_cast<T>(sqrt(static_cast<double>(x)));\n\treturn t * t == x;\n}\n\ntemplate <typename T>\ninline T gcd(const T a, const T b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].color = true;\n\t\tN[i].v = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->v) {\n\t\t\t\t\te->t->v = true;\n\t\t\t\t\te->t->color = !v->color;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else assert(e->t->color != v->color);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void clean() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &N[i].x);\n\t\tsum += N[i].x;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (isSquare(sqr(N[i].x) + sqr(N[j].x)) && gcd(N[i].x, N[j].x) == 1) {\n\t\t\t\tflag[i][j] = flag[j][i] = true;\n\t\t\t\taddEdge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcolor();\n\tclean();\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].color) addEdge(s, i, N[i].x);\n\t\telse addEdge(i, t, N[i].x);\n\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (flag[i][j]) {\n\t\t\t\tif (N[i].color) addEdge(i, j, LLONG_MAX);\n\t\t\t\telse addEdge(j, i, LLONG_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%lld\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3275","published":1,"updated":"2016-05-23T15:09:19.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiyt01dc0jxla5ey09jb"},{"title":"BZOJ 3262 - CDQ","date":"2016-06-19T12:56:00.000Z","_content":"\n $ A_i = (a,\\ b,\\ c) $  \n $ a_i \\leq a_j,\\ b_i \\leq b_j,\\ c_i \\leq c_j $ $ A_j $  $ A_i $   \n $ A_i $  $ A_j $  $ A_i $  $ A_j $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 3262](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n### \n CDQ \n\n CDQ  $ a $  $ b $ \n\n $ b $  $ c $  $ c $  $ c $  $ b $  $ a $ CDQ \n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXK = 200000;\n\nstruct Triple {\n\tint a, b, c, cnt, ans;\n} a[MAXN], A[MAXN];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.a < b.a || (a.a == b.a && a.b < b.b) || (a.a == b.a && a.b == b.b && a.c < b.c);\n}\n\nint n, k;\n\nstruct BinaryIndexedTree {\n\tint a[MAXK];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clean(const int x) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->b <= p2->b && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tbit.clean(p->c);\n\t\t*q = *p;\n\t}\n\n\t/*\n\tprintf(\"cdq(%ld, %ld): \", l - A + 1, r - A + 1);\n\tfor (Triple *p = l; p <= r; p++) {\n\t\tprintf(\"(%d, %d, %d)%s\", p->a, p->b, p->c, p == r ? \"\\n\" : \", \");\n\t}\n\t*/\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T &x) {\n\tstatic char s[20];\n\tint cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tread(n), read(k);\n\tfor (int i = 0; i < n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1;\n\t// scanf(\"%d %d\", &n, &k);\n\t// for (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\n\tstd::sort(a, a + n);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[cnt++] = a[i];\n\t\telse A[cnt - 1].cnt++;\n\t}\n\n\tcdq(A, A + cnt - 1);\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0; i < cnt; i++) ans[A[i].ans] += A[i].cnt;\n\t\n\tfor (int i = 0; i < n; i++) write(ans[i]);\n\t// for (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3262.md","raw":"title: BZOJ 3262 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-3262\ndate: 2016-06-19 20:56:00\n---\n\n $ A_i = (a,\\ b,\\ c) $  \n $ a_i \\leq a_j,\\ b_i \\leq b_j,\\ c_i \\leq c_j $ $ A_j $  $ A_i $   \n $ A_i $  $ A_j $  $ A_i $  $ A_j $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 3262](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n### \n CDQ \n\n CDQ  $ a $  $ b $ \n\n $ b $  $ c $  $ c $  $ c $  $ b $  $ a $ CDQ \n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXK = 200000;\n\nstruct Triple {\n\tint a, b, c, cnt, ans;\n} a[MAXN], A[MAXN];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.a < b.a || (a.a == b.a && a.b < b.b) || (a.a == b.a && a.b == b.b && a.c < b.c);\n}\n\nint n, k;\n\nstruct BinaryIndexedTree {\n\tint a[MAXK];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clean(const int x) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->b <= p2->b && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tbit.clean(p->c);\n\t\t*q = *p;\n\t}\n\n\t/*\n\tprintf(\"cdq(%ld, %ld): \", l - A + 1, r - A + 1);\n\tfor (Triple *p = l; p <= r; p++) {\n\t\tprintf(\"(%d, %d, %d)%s\", p->a, p->b, p->c, p == r ? \"\\n\" : \", \");\n\t}\n\t*/\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T &x) {\n\tstatic char s[20];\n\tint cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tread(n), read(k);\n\tfor (int i = 0; i < n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1;\n\t// scanf(\"%d %d\", &n, &k);\n\t// for (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\n\tstd::sort(a, a + n);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[cnt++] = a[i];\n\t\telse A[cnt - 1].cnt++;\n\t}\n\n\tcdq(A, A + cnt - 1);\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0; i < cnt; i++) ans[A[i].ans] += A[i].cnt;\n\t\n\tfor (int i = 0; i < n; i++) write(ans[i]);\n\t// for (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3262","published":1,"updated":"2016-06-19T12:56:40.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jiz401dj0jxlu6j1rktr"},{"title":"BZOJ 3230 - ","date":"2016-09-29T22:59:00.000Z","_content":"\n $ N $  $ S $ $ f = a ^ 2 + b ^ 2 $  $ a $$ b $ $ S[l \\ldots l + a - 1] = S[p \\ldots p + a - 1] $$ S[r - b + 1 \\ldots r] = S[q - b + 1 \\ldots q] $$ 0 \\leq a \\leq r - l + 1 $$ 0 \\leq b \\leq q - p + 1 $\n\n $ i $  $ j $ \n\n<!-- more -->\n\n### \n[BZOJ 3230](http://www.lydsy.com/JudgeOnline/problem.php?id=3230)\n\n### \n $ N $  $ O(N ^ 2) $ \n\n $ i $  $ i - 1 $  $ l $ $ i $  $ i - 1 $  $ \\mathrm{len}(i) - l $  $ l + 1 $\n\n $ i $ $ a $  $ b $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812;\n\nchar s[MAXN], sRev[MAXN];\nint n, log[MAXN + 1];\nlong long cnt[MAXN];\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1];\n\n\tvoid build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n\t\t// */\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef TEST\n\t\tassert(l <= r);\n#endif\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\tint res = std::min(st[l][t], st[r - (1 << t) + 1][t]);\n#ifdef TEST\n\t\tint ans = n;\n\t\tfor (int k = l; k <= r; k++) ans = std::min(ans, ht[k]);\n\t\tassert(res == ans);\n#endif\n\t\treturn res;\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn query(a + 1, b);\n\t}\n} sa, saRev;\n\ninline int lcp(const int i, const int j) {\n\tint res = sa.lcp(i, j);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i + ans < n && j + ans < n && s[i + ans] == s[j + ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline int lcs(const int i, const int j) {\n\tint res = saRev.lcp(n - i - 1, n - j - 1);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i - ans >= 0 && j - ans >= 0 && s[i - ans] == s[j - ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline void prepare() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t\t// printf(\"log(%d) = %d\\n\", i, log[i]);\n\t}\n\n\tsa.build(s, n);\n\n\tlong long x = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tx += n - sa.sa[i];\n\t\tif (i) x -= sa.ht[i];\n\t\tcnt[i] = x;\n\t\t// printf(\"%lld\\n\", x);\n\t}\n\n\tstd::copy(s, s + n, sRev);\n\tstd::reverse(sRev, sRev + n);\n\tsaRev.build(sRev, n);\n}\n\ninline bool locate(const long long k, int &l, int &r) {\n\tlong long *p = std::upper_bound(cnt, cnt + n, k - 1);\n\tif (p == cnt + n) return false;\n\tint t = *p - k;\n\tl = sa.sa[p - cnt];\n\tr = n - t - 1;\n\treturn true;\n}\n\ninline void all() {\n\tstd::vector<std::string> v;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) v.push_back(std::string(&s[i], &s[j]));\n\tstd::sort(v.begin(), v.end());\n\tv.erase(std::unique(v.begin(), v.end()), v.end());\n\tint i = 1;\n\tfor (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tint l, r;\n\t\tlocate(i++, l, r);\n\t\t// printf(\"%d %d\\n\", l, r);\n\t\tfor (int j = l; j <= r; j++) putchar(s[j]);\n\t\tputchar('\\n');\n\t\tprintf(\"%s\\n\", it->c_str());\n\t}\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\\n%s\", &n, &q, s);\n\tn = strlen(s);\n\tprepare();\n\t// all();\n\n\t/*\n\tputs(\"left query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"lq(%d, %d) = %d\\n\", i, j, query(stp, i, j));\n\n\tputs(\"right query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"rq(%d, %d) = %d\\n\", i, j, query(sts, i, j));\n\t*/\n\n\t/*\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcp(%d, %d) = %d\\n\", i, j, lcp(i, j));\n\tputchar('\\n');\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcs(%d, %d) = %d\\n\", i, j, lcs(i, j));\n\t*/\n\n\twhile (q--) {\n\t\tlong long i, j;\n\t\tscanf(\"%lld %lld\", &i, &j);\n\t\tint l1, r1, l2, r2;\n\t\tif (!locate(i, l1, r1) || !locate(j, l2, r2)) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint lim = std::min(r1 - l1 + 1, r2 - l2 + 1);\n\t\tlong long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2));\n\t\tprintf(\"%lld\\n\", a * a + b * b);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3230.md","raw":"title: BZOJ 3230 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3230\ndate: 2016-09-30 06:59:00\n---\n\n $ N $  $ S $ $ f = a ^ 2 + b ^ 2 $  $ a $$ b $ $ S[l \\ldots l + a - 1] = S[p \\ldots p + a - 1] $$ S[r - b + 1 \\ldots r] = S[q - b + 1 \\ldots q] $$ 0 \\leq a \\leq r - l + 1 $$ 0 \\leq b \\leq q - p + 1 $\n\n $ i $  $ j $ \n\n<!-- more -->\n\n### \n[BZOJ 3230](http://www.lydsy.com/JudgeOnline/problem.php?id=3230)\n\n### \n $ N $  $ O(N ^ 2) $ \n\n $ i $  $ i - 1 $  $ l $ $ i $  $ i - 1 $  $ \\mathrm{len}(i) - l $  $ l + 1 $\n\n $ i $ $ a $  $ b $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812;\n\nchar s[MAXN], sRev[MAXN];\nint n, log[MAXN + 1];\nlong long cnt[MAXN];\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1];\n\n\tvoid build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n\t\t// */\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef TEST\n\t\tassert(l <= r);\n#endif\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\tint res = std::min(st[l][t], st[r - (1 << t) + 1][t]);\n#ifdef TEST\n\t\tint ans = n;\n\t\tfor (int k = l; k <= r; k++) ans = std::min(ans, ht[k]);\n\t\tassert(res == ans);\n#endif\n\t\treturn res;\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn query(a + 1, b);\n\t}\n} sa, saRev;\n\ninline int lcp(const int i, const int j) {\n\tint res = sa.lcp(i, j);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i + ans < n && j + ans < n && s[i + ans] == s[j + ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline int lcs(const int i, const int j) {\n\tint res = saRev.lcp(n - i - 1, n - j - 1);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i - ans >= 0 && j - ans >= 0 && s[i - ans] == s[j - ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline void prepare() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t\t// printf(\"log(%d) = %d\\n\", i, log[i]);\n\t}\n\n\tsa.build(s, n);\n\n\tlong long x = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tx += n - sa.sa[i];\n\t\tif (i) x -= sa.ht[i];\n\t\tcnt[i] = x;\n\t\t// printf(\"%lld\\n\", x);\n\t}\n\n\tstd::copy(s, s + n, sRev);\n\tstd::reverse(sRev, sRev + n);\n\tsaRev.build(sRev, n);\n}\n\ninline bool locate(const long long k, int &l, int &r) {\n\tlong long *p = std::upper_bound(cnt, cnt + n, k - 1);\n\tif (p == cnt + n) return false;\n\tint t = *p - k;\n\tl = sa.sa[p - cnt];\n\tr = n - t - 1;\n\treturn true;\n}\n\ninline void all() {\n\tstd::vector<std::string> v;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) v.push_back(std::string(&s[i], &s[j]));\n\tstd::sort(v.begin(), v.end());\n\tv.erase(std::unique(v.begin(), v.end()), v.end());\n\tint i = 1;\n\tfor (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tint l, r;\n\t\tlocate(i++, l, r);\n\t\t// printf(\"%d %d\\n\", l, r);\n\t\tfor (int j = l; j <= r; j++) putchar(s[j]);\n\t\tputchar('\\n');\n\t\tprintf(\"%s\\n\", it->c_str());\n\t}\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\\n%s\", &n, &q, s);\n\tn = strlen(s);\n\tprepare();\n\t// all();\n\n\t/*\n\tputs(\"left query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"lq(%d, %d) = %d\\n\", i, j, query(stp, i, j));\n\n\tputs(\"right query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"rq(%d, %d) = %d\\n\", i, j, query(sts, i, j));\n\t*/\n\n\t/*\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcp(%d, %d) = %d\\n\", i, j, lcp(i, j));\n\tputchar('\\n');\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcs(%d, %d) = %d\\n\", i, j, lcs(i, j));\n\t*/\n\n\twhile (q--) {\n\t\tlong long i, j;\n\t\tscanf(\"%lld %lld\", &i, &j);\n\t\tint l1, r1, l2, r2;\n\t\tif (!locate(i, l1, r1) || !locate(j, l2, r2)) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint lim = std::min(r1 - l1 + 1, r2 - l2 + 1);\n\t\tlong long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2));\n\t\tprintf(\"%lld\\n\", a * a + b * b);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3230","published":1,"updated":"2016-09-29T23:26:11.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jizd01dq0jxlld4l2j8g"},{"title":"BZOJ 3196 - ","date":"2016-06-19T01:37:00.000Z","_content":"\n\n\n1.  $ k $ \n2.  $ k $ \n3. \n4.  $ k $  $ x $\n5.  $ k $  $ x $\n\n<!-- more -->\n\n### \n[BZOJ 3196](http://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n### \n\n\n $ O(\\log n) $  $ O(n \\log n) $ $ O(n \\log ^ 2 n) $ \n\n#### \n $ O(\\log n) $ \n\n#### \n\n\n $ x $ $ x $  $ k $ $ x $\n\n\n\n#### \n\n\n#### \n $ O(\\log n) $ \n\n $ O(n \\log ^ 3 n) $ Splay  BZOJ \n\n $ O(n \\log ^ 2 n) $ 512M \n\n![](http://127.0.0.1/lemon.png)\n\n $ O(n \\sqrt n \\log n) $\n\n### \n SplayRP  TLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\n\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size, cnt, val;\n\n\t\tNode(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) {\n\t\t\tc[L] = c[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = cnt;\n\t\t\tif (c[L]) size += c[L]->size;\n\t\t\tif (c[R]) size += c[R]->size;\n\t\t}\n\n\t\tRelation relatain() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relatain();\n\t\t\tNode *o = p;\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relatain()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (p->relatain() == relatain()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prec() {\n\t\t\tsplay();\n\t\t\tNode *v = c[L];\n\t\t\twhile (v->c[R]) v = v->c[R];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = c[R];\n\t\t\twhile (v->c[L]) v = v->c[L];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tint left() const { return c[L] ? c[L]->size : 0; }\n\n#ifdef DBG\n\t\tvoid validate() {\n\t\t\tint size = 0;\n\t\t\tif (c[L]) c[L]->validate(), assert(this->val > c[L]->val), size += c[L]->size;\n\t\t\tif (c[R]) c[R]->validate(), assert(this->val < c[R]->val), size += c[R]->size;\n\t\t\tassert(this->size == size + cnt);\n\t\t}\n\n\t\tvoid print(const int depth = 0);\n#endif\n\t} *r;\n#ifdef DBG\n\tint id;\n#endif\n\n\tSplay(const int *a, const int n) : r(NULL) {\n\t\tinsert(INT_MAX), insert(INT_MIN);\n#ifdef DBG\n\t\tstatic int time = 0;\n\t\ttime++;\n\t\tid = time;\n\t\tprintf(\"build(%d): \", id);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~Splay() { delete r; }\n\n\tNode *find(const int x) {\n\t\tNode *v = r;\n\t\twhile (v && x != v->val) {\n\t\t\tif (x < v->val) v = v->c[L];\n\t\t\telse v = v->c[R];\n\t\t}\n\t\treturn v ? v->splay() : NULL;\n\t}\n\n\tNode *insert(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) {\n\t\t\tv->cnt++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &r, *p = NULL;\n\t\twhile (*target) {\n\t\t\tp = *target;\n\t\t\tp->size++;\n\t\t\tif (x< p->val) target = &p->c[L];\n\t\t\telse target = &p->c[R];\n\t\t}\n\n\t\treturn (*target = new Node(p, x, &r))->splay();\n\t}\n\n\tint rank(const int x) {\n\t\tNode *v = find(x);\n\t\tint res;\n\t\tif (v) res = v->left();\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tres = v->left();\n\t\t\terase(v);\n\t\t}\n#ifdef DBG\n\t\tprintf(\"rank(%d) in (%d) = %d\\n\", x, id, res);\n#endif\n\t\treturn res;\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (!(x >= v->left() + 1 && x <= v->left() + v->cnt)) {\n\t\t\tif (x < v->left() + 1) v = v->c[L];\n\t\t\telse x -= v->left() + v->cnt, v = v->c[R];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->cnt != 1) {\n\t\t\tv->cnt--, v->size--;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode *prec = v->prec(), *succ = v->succ();\n\n\t\tprec->splay();\n\t\tsucc->splay(prec);\n\n\t\tdelete succ->c[L];\n\t\tsucc->c[L] = NULL;\n\n\t\tsucc->maintain(), prec->maintain();\n\t}\n\n\tvoid erase(const int x) {\n\t\tNode *v = find(x);\n\t\terase(v);\n\t}\n\n\tint prec(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->prec()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->prec()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint succ(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->succ()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tr->validate();\n\t}\n#endif\n};\n\n#ifdef DBG\nvoid Splay::Node::print(const int depth) {\n\tif (c[L]) c[L]->print(depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' '), putchar(' ');\n\tprintf(\"%d\\n\", val);\n\tif (c[R]) c[R]->print(depth + 1);\n}\n#endif\n\nint map[MAXM + MAXN], max;\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tSplay s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n\nMLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\nint map[MAXM + MAXN], max;\n\nstruct WeightSegmentTree {\n\tint l, r, mid;\n\tWeightSegmentTree *lc, *rc;\n\tint min, max, cnt;\n\n\tWeightSegmentTree(const int l, const int r)\n\t\t: l(l), r(r), mid(l + (r - l) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{}\n\n\tWeightSegmentTree(const int *a, const int n)\n\t\t: l(0), r(::max - 1), mid((max - 1) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~WeightSegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tvoid maintain() {\n\t\tmin = INT_MAX;\n\t\tif (lc) min = std::min(min, lc->min);\n\t\tif (rc) min = std::min(min, rc->min);\n\n\t\tmax = INT_MIN;\n\t\tif (lc) max = std::max(max, lc->max);\n\t\tif (rc) max = std::max(max, rc->max);\n\n\t\tcnt = 0;\n\t\tif (lc) cnt += lc->cnt;\n\t\tif (rc) cnt += rc->cnt;\n\t}\n\n\tvoid insert(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!cnt++) min = max = x;\n\t\t} else {\n\t\t\tif (x <= mid) {\n\t\t\t\tif (!lc) lc = new WeightSegmentTree(l, mid);\n\t\t\t\tlc->insert(x);\n\t\t\t} else {\n\t\t\t\tif (!rc) rc = new WeightSegmentTree(mid + 1, r);\n\t\t\t\trc->insert(x);\n\t\t\t}\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tvoid erase(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!--cnt) min = INT_MAX, max = INT_MIN;\n\t\t} else {\n\t\t\tif (x <= mid) lc->erase(x);\n\t\t\telse rc->erase(x);\n\t\t\tmaintain();\n\t\t\tif (x <= mid && lc->cnt == 0) delete lc, lc = NULL;\n\t\t\telse if (x > mid && rc->cnt == 0) delete rc, rc = NULL;\n\t\t}\n\t}\n\n\tint prec(const int x) {\n\t\treturn queryMax(0, x - 1);\n\t}\n\n\tint succ(const int x) {\n\t\treturn queryMin(x + 1, ::max);\n\t}\n\n\tint rank(const int x) {\n\t\treturn queryCnt(0, x - 1) + 1;\n\t}\n\n\tint select(const int k) {\n\t\tint x = k;\n\t\tWeightSegmentTree *v = this;\n\t\twhile (v->l != v->r) {\n\t\t\tif (!v->lc) v = v->rc;\n\t\t\telse if (x <= v->lc->cnt) v = v->lc;\n\t\t\telse x -= v->lc->cnt, v = v->rc;\n\t\t}\n\t\treturn v->mid;\n\t}\n\n\tint queryMin(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return min;\n\t\telse {\n\t\t\tint res = INT_MAX;\n\t\t\tif (lc) res = lc->queryMin(l, r);\n\t\t\tif (res == INT_MAX && rc) return rc->queryMin(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse {\n\t\t\tint res = INT_MIN;\n\t\t\tif (rc) res = rc->queryMax(l, r);\n\t\t\tif (res == INT_MIN && lc) return lc->queryMax(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryCnt(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tif (lc) res += lc->queryCnt(l, r);\n\t\t\tif (rc) res += rc->queryCnt(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tWeightSegmentTree s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3196.md","raw":"title: BZOJ 3196 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Splay\n  - \npermalink: bzoj-3196\ndate: 2016-06-19 09:37:00\n---\n\n\n\n1.  $ k $ \n2.  $ k $ \n3. \n4.  $ k $  $ x $\n5.  $ k $  $ x $\n\n<!-- more -->\n\n### \n[BZOJ 3196](http://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n### \n\n\n $ O(\\log n) $  $ O(n \\log n) $ $ O(n \\log ^ 2 n) $ \n\n#### \n $ O(\\log n) $ \n\n#### \n\n\n $ x $ $ x $  $ k $ $ x $\n\n\n\n#### \n\n\n#### \n $ O(\\log n) $ \n\n $ O(n \\log ^ 3 n) $ Splay  BZOJ \n\n $ O(n \\log ^ 2 n) $ 512M \n\n![](http://127.0.0.1/lemon.png)\n\n $ O(n \\sqrt n \\log n) $\n\n### \n SplayRP  TLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\n\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size, cnt, val;\n\n\t\tNode(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) {\n\t\t\tc[L] = c[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = cnt;\n\t\t\tif (c[L]) size += c[L]->size;\n\t\t\tif (c[R]) size += c[R]->size;\n\t\t}\n\n\t\tRelation relatain() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relatain();\n\t\t\tNode *o = p;\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relatain()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (p->relatain() == relatain()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prec() {\n\t\t\tsplay();\n\t\t\tNode *v = c[L];\n\t\t\twhile (v->c[R]) v = v->c[R];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = c[R];\n\t\t\twhile (v->c[L]) v = v->c[L];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tint left() const { return c[L] ? c[L]->size : 0; }\n\n#ifdef DBG\n\t\tvoid validate() {\n\t\t\tint size = 0;\n\t\t\tif (c[L]) c[L]->validate(), assert(this->val > c[L]->val), size += c[L]->size;\n\t\t\tif (c[R]) c[R]->validate(), assert(this->val < c[R]->val), size += c[R]->size;\n\t\t\tassert(this->size == size + cnt);\n\t\t}\n\n\t\tvoid print(const int depth = 0);\n#endif\n\t} *r;\n#ifdef DBG\n\tint id;\n#endif\n\n\tSplay(const int *a, const int n) : r(NULL) {\n\t\tinsert(INT_MAX), insert(INT_MIN);\n#ifdef DBG\n\t\tstatic int time = 0;\n\t\ttime++;\n\t\tid = time;\n\t\tprintf(\"build(%d): \", id);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~Splay() { delete r; }\n\n\tNode *find(const int x) {\n\t\tNode *v = r;\n\t\twhile (v && x != v->val) {\n\t\t\tif (x < v->val) v = v->c[L];\n\t\t\telse v = v->c[R];\n\t\t}\n\t\treturn v ? v->splay() : NULL;\n\t}\n\n\tNode *insert(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) {\n\t\t\tv->cnt++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &r, *p = NULL;\n\t\twhile (*target) {\n\t\t\tp = *target;\n\t\t\tp->size++;\n\t\t\tif (x< p->val) target = &p->c[L];\n\t\t\telse target = &p->c[R];\n\t\t}\n\n\t\treturn (*target = new Node(p, x, &r))->splay();\n\t}\n\n\tint rank(const int x) {\n\t\tNode *v = find(x);\n\t\tint res;\n\t\tif (v) res = v->left();\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tres = v->left();\n\t\t\terase(v);\n\t\t}\n#ifdef DBG\n\t\tprintf(\"rank(%d) in (%d) = %d\\n\", x, id, res);\n#endif\n\t\treturn res;\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (!(x >= v->left() + 1 && x <= v->left() + v->cnt)) {\n\t\t\tif (x < v->left() + 1) v = v->c[L];\n\t\t\telse x -= v->left() + v->cnt, v = v->c[R];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->cnt != 1) {\n\t\t\tv->cnt--, v->size--;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode *prec = v->prec(), *succ = v->succ();\n\n\t\tprec->splay();\n\t\tsucc->splay(prec);\n\n\t\tdelete succ->c[L];\n\t\tsucc->c[L] = NULL;\n\n\t\tsucc->maintain(), prec->maintain();\n\t}\n\n\tvoid erase(const int x) {\n\t\tNode *v = find(x);\n\t\terase(v);\n\t}\n\n\tint prec(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->prec()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->prec()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint succ(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->succ()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tr->validate();\n\t}\n#endif\n};\n\n#ifdef DBG\nvoid Splay::Node::print(const int depth) {\n\tif (c[L]) c[L]->print(depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' '), putchar(' ');\n\tprintf(\"%d\\n\", val);\n\tif (c[R]) c[R]->print(depth + 1);\n}\n#endif\n\nint map[MAXM + MAXN], max;\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tSplay s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n\nMLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\nint map[MAXM + MAXN], max;\n\nstruct WeightSegmentTree {\n\tint l, r, mid;\n\tWeightSegmentTree *lc, *rc;\n\tint min, max, cnt;\n\n\tWeightSegmentTree(const int l, const int r)\n\t\t: l(l), r(r), mid(l + (r - l) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{}\n\n\tWeightSegmentTree(const int *a, const int n)\n\t\t: l(0), r(::max - 1), mid((max - 1) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~WeightSegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tvoid maintain() {\n\t\tmin = INT_MAX;\n\t\tif (lc) min = std::min(min, lc->min);\n\t\tif (rc) min = std::min(min, rc->min);\n\n\t\tmax = INT_MIN;\n\t\tif (lc) max = std::max(max, lc->max);\n\t\tif (rc) max = std::max(max, rc->max);\n\n\t\tcnt = 0;\n\t\tif (lc) cnt += lc->cnt;\n\t\tif (rc) cnt += rc->cnt;\n\t}\n\n\tvoid insert(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!cnt++) min = max = x;\n\t\t} else {\n\t\t\tif (x <= mid) {\n\t\t\t\tif (!lc) lc = new WeightSegmentTree(l, mid);\n\t\t\t\tlc->insert(x);\n\t\t\t} else {\n\t\t\t\tif (!rc) rc = new WeightSegmentTree(mid + 1, r);\n\t\t\t\trc->insert(x);\n\t\t\t}\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tvoid erase(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!--cnt) min = INT_MAX, max = INT_MIN;\n\t\t} else {\n\t\t\tif (x <= mid) lc->erase(x);\n\t\t\telse rc->erase(x);\n\t\t\tmaintain();\n\t\t\tif (x <= mid && lc->cnt == 0) delete lc, lc = NULL;\n\t\t\telse if (x > mid && rc->cnt == 0) delete rc, rc = NULL;\n\t\t}\n\t}\n\n\tint prec(const int x) {\n\t\treturn queryMax(0, x - 1);\n\t}\n\n\tint succ(const int x) {\n\t\treturn queryMin(x + 1, ::max);\n\t}\n\n\tint rank(const int x) {\n\t\treturn queryCnt(0, x - 1) + 1;\n\t}\n\n\tint select(const int k) {\n\t\tint x = k;\n\t\tWeightSegmentTree *v = this;\n\t\twhile (v->l != v->r) {\n\t\t\tif (!v->lc) v = v->rc;\n\t\t\telse if (x <= v->lc->cnt) v = v->lc;\n\t\t\telse x -= v->lc->cnt, v = v->rc;\n\t\t}\n\t\treturn v->mid;\n\t}\n\n\tint queryMin(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return min;\n\t\telse {\n\t\t\tint res = INT_MAX;\n\t\t\tif (lc) res = lc->queryMin(l, r);\n\t\t\tif (res == INT_MAX && rc) return rc->queryMin(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse {\n\t\t\tint res = INT_MIN;\n\t\t\tif (rc) res = rc->queryMax(l, r);\n\t\t\tif (res == INT_MIN && lc) return lc->queryMax(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryCnt(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tif (lc) res += lc->queryCnt(l, r);\n\t\t\tif (rc) res += rc->queryCnt(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tWeightSegmentTree s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-3196","published":1,"updated":"2016-06-19T01:37:23.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jizk01dv0jxlgaus4s3u"},{"title":"BZOJ 3156 -  DP","date":"2016-05-19T03:58:00.000Z","_content":"\n $ n $  $ n $  $ 1 $  $ n $ $ i $  $ c(i) $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 3156](http://www.lydsy.com/JudgeOnline/problem.php?id=3156)\n\n### \n****\n\n $ f(i) $  $ i $  $ j $ $ j + 1 $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + \\frac{(i - j - 1)(i - j)}{2} \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + \\frac{(i - a - 1)(i - a)}{2} &< f(b) + c(b + 1) + \\frac{(i - b - 1)(i - b)}{2} \\\\\nf(a) + c(a + 1) + \\frac{i ^ 2}{2} + \\frac{a ^ 2}{2} - ia - \\frac{i}{2} + \\frac{a}{2} &< f(b) + c(b + 1) + \\frac{i ^ 2}{2} + \\frac{b ^ 2}{2} - ib - \\frac{i}{2} + \\frac{b}{2} \\\\\n{ (f(a) + c(a + 1) + \\frac{a ^ 2}{2} + \\frac{a}{2}) - (f(b) + c(b + 1) + \\frac{b ^ 2}{2} + \\frac{b}{2}) \\over a - b } &< i \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long c[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n\tstd::reverse(c + 1, c + n + 1);\n}\n\n/*\ninline void force() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _j = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (f[i] > f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) {\n\t\t\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t\t\t_j = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d --> %d\\n\", i, _j);\n\t}\n}\n*/\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast<long long>(i)) * 0.5 + i * 0.5; }\n\ninline double slope(const int a, const int b) {\n\treturn double(x(a) - x(b))\n\t\t / double(a - b);\n}\n\ninline void dp() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\n\tstatic int q[MAXN];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (l < r && slope(*(l + 1), *l) < i) l++;\n\n\t\tint &j = *l;\n\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t// printf(\"%d --> %d\\n\", i, j);\n\n\t\tif (i < n) {\n\t\t\twhile (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n\t\t\t*++r = i;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\n\tprepare();\n\n\t// force();\n\tdp();\n\tprintf(\"%lld\\n\", f[n]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3156.md","raw":"title: BZOJ 3156 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - \n  - \npermalink: bzoj-3156\ndate: 2016-05-19 11:58:00\n---\n\n $ n $  $ n $  $ 1 $  $ n $ $ i $  $ c(i) $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 3156](http://www.lydsy.com/JudgeOnline/problem.php?id=3156)\n\n### \n****\n\n $ f(i) $  $ i $  $ j $ $ j + 1 $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + \\frac{(i - j - 1)(i - j)}{2} \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + \\frac{(i - a - 1)(i - a)}{2} &< f(b) + c(b + 1) + \\frac{(i - b - 1)(i - b)}{2} \\\\\nf(a) + c(a + 1) + \\frac{i ^ 2}{2} + \\frac{a ^ 2}{2} - ia - \\frac{i}{2} + \\frac{a}{2} &< f(b) + c(b + 1) + \\frac{i ^ 2}{2} + \\frac{b ^ 2}{2} - ib - \\frac{i}{2} + \\frac{b}{2} \\\\\n{ (f(a) + c(a + 1) + \\frac{a ^ 2}{2} + \\frac{a}{2}) - (f(b) + c(b + 1) + \\frac{b ^ 2}{2} + \\frac{b}{2}) \\over a - b } &< i \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long c[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n\tstd::reverse(c + 1, c + n + 1);\n}\n\n/*\ninline void force() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _j = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (f[i] > f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) {\n\t\t\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t\t\t_j = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d --> %d\\n\", i, _j);\n\t}\n}\n*/\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast<long long>(i)) * 0.5 + i * 0.5; }\n\ninline double slope(const int a, const int b) {\n\treturn double(x(a) - x(b))\n\t\t / double(a - b);\n}\n\ninline void dp() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\n\tstatic int q[MAXN];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (l < r && slope(*(l + 1), *l) < i) l++;\n\n\t\tint &j = *l;\n\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t// printf(\"%d --> %d\\n\", i, j);\n\n\t\tif (i < n) {\n\t\t\twhile (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n\t\t\t*++r = i;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\n\tprepare();\n\n\t// force();\n\tdp();\n\tprintf(\"%lld\\n\", f[n]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3156","published":1,"updated":"2016-10-24T23:33:42.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jizy01e30jxlqymgfkh3"},{"title":"BZOJ 2820YYGCD - ","date":"2016-04-07T14:24:12.000Z","_content":"\n $ 1 \\leq x \\leq N $$ 1 \\leq y \\leq M $  $ \\gcd(x, y) $  $ (x, y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### \n $ N \\leq M $  $ M \\lt N $  $ N $  $ M $ \n\n $ N $  $ p_1, p_2, , p_n $\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n $ T = p_k \\times d $\t $ T $  $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n $ \\mu $  $ T' \\ {\\rm mod} \\ p_1 = 0 $ \n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n $ x_1 \\gt 1 $ \n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2820.md","raw":"title: BZOJ 2820YYGCD - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - \npermalink: bzoj-2820\ndate: 2016-04-07 22:24:12\n---\n\n $ 1 \\leq x \\leq N $$ 1 \\leq y \\leq M $  $ \\gcd(x, y) $  $ (x, y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### \n $ N \\leq M $  $ M \\lt N $  $ N $  $ M $ \n\n $ N $  $ p_1, p_2, , p_n $\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n $ T = p_k \\times d $\t $ T $  $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n $ \\mu $  $ T' \\ {\\rm mod} \\ p_1 = 0 $ \n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n $ x_1 \\gt 1 $ \n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2820","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj0501e90jxl4g7dt908"},{"title":"BZOJ 2716 - CDQ","date":"2016-06-25T03:08:00.000Z","_content":"\n\n\n1.  $ (x,\\ y) $\n2. **** $ (x,\\ y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2716](http://www.lydsy.com/JudgeOnline/problem.php?id=2716)\n\n### \n $ (x_1,\\ y_1) $$ (x_2,\\ y_2) $  $ | x_1 - x_2 | + | y_1 - y_2 | $\n\n $ (x_1,\\ y_1) $  $ (x_2,\\ y_2) $ \n\n$$\n\\begin{aligned}\n & | x_1 - x_2 | + | y_1 - y_2 | \\\\\n=& ( x_1 - x_2 ) + ( y_1 - y_2 ) \\\\\n=& ( x_1 + y_1 ) - (x_2 + y_2)\n\\end{aligned}\n$$\n\n $ (x_2 + y_2) $  CDQ  CDQ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 1000000;\n\nstruct Triple {\n\tint id, x, y, *ans;\n\n\tTriple() {}\n\n\tTriple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) {\n\t\tstatic int i = 0;\n\t\tid = i++;\n\t}\n} a[MAXN + MAXM];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.id < b.id;\n}\n\nint maxX, maxY;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int v) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v);\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, q->x + q->y);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) {\n\t\t\t\tint res = bit.query(q->y);\n\t\t\t\tif (res) *q->ans = std::min(*q->ans, q->x + q->y - res);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; p++, q++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\\n\", &x, &y), x += 2, y += 2;\n\t\ta[cnt++] = Triple(x, y);\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint qCnt = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d %d %d\", &t, &x, &y), x += 2, y += 2;\n\t\tif (t == 1) {\n\t\t\ta[cnt++] = Triple(x, y);\n\t\t} else {\n\t\t\ta[cnt++] = Triple(x, y, &ans[qCnt++]);\n\t\t}\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tfor (int i = 0; i < qCnt; i++) ans[i] = INT_MAX;\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].y = maxY - a[i].y + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qCnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2716.md","raw":"title: BZOJ 2716 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - \n  - CDQ\n  - \n  - \npermalink: bzoj-2716\ndate: 2016-06-25 11:08:00\n---\n\n\n\n1.  $ (x,\\ y) $\n2. **** $ (x,\\ y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2716](http://www.lydsy.com/JudgeOnline/problem.php?id=2716)\n\n### \n $ (x_1,\\ y_1) $$ (x_2,\\ y_2) $  $ | x_1 - x_2 | + | y_1 - y_2 | $\n\n $ (x_1,\\ y_1) $  $ (x_2,\\ y_2) $ \n\n$$\n\\begin{aligned}\n & | x_1 - x_2 | + | y_1 - y_2 | \\\\\n=& ( x_1 - x_2 ) + ( y_1 - y_2 ) \\\\\n=& ( x_1 + y_1 ) - (x_2 + y_2)\n\\end{aligned}\n$$\n\n $ (x_2 + y_2) $  CDQ  CDQ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 1000000;\n\nstruct Triple {\n\tint id, x, y, *ans;\n\n\tTriple() {}\n\n\tTriple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) {\n\t\tstatic int i = 0;\n\t\tid = i++;\n\t}\n} a[MAXN + MAXM];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.id < b.id;\n}\n\nint maxX, maxY;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int v) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v);\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, q->x + q->y);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) {\n\t\t\t\tint res = bit.query(q->y);\n\t\t\t\tif (res) *q->ans = std::min(*q->ans, q->x + q->y - res);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; p++, q++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\\n\", &x, &y), x += 2, y += 2;\n\t\ta[cnt++] = Triple(x, y);\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint qCnt = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d %d %d\", &t, &x, &y), x += 2, y += 2;\n\t\tif (t == 1) {\n\t\t\ta[cnt++] = Triple(x, y);\n\t\t} else {\n\t\t\ta[cnt++] = Triple(x, y, &ans[qCnt++]);\n\t\t}\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tfor (int i = 0; i < qCnt; i++) ans[i] = INT_MAX;\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].y = maxY - a[i].y + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qCnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2716","published":1,"updated":"2016-06-25T03:08:50.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj0g01eg0jxlmt1oziud"},{"title":"BZOJ 2683 - CDQ","id":"43","updated":"2016-02-05T14:46:27.000Z","date":"2016-02-05T14:42:35.000Z","_content":"\n$N*N$ 0\n\n1. $(x,y)$$A$\n2. $(x1,y1)(x2,y2)$\n\n<!-- more -->\n\n### \n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2683.md","raw":"title: BZOJ 2683 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-2683\nid: 43\nupdated: '2016-02-05 22:46:27'\ndate: 2016-02-05 22:42:35\n---\n\n$N*N$ 0\n\n1. $(x,y)$$A$\n2. $(x1,y1)(x2,y2)$\n\n<!-- more -->\n\n### \n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2683","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj0p01en0jxl4l3s7tlx"},{"title":"BZOJ 2580Video Game - AC ","date":"2016-09-17T23:16:00.000Z","_content":"\n $ n $  $ s_i $ $ k $  $ S $ $ S $  $ s_i $\n\n<!-- more -->\n\n### \n[BZOJ 2580](http://www.lydsy.com/JudgeOnline/problem.php?id=2580)\n\n### \n $ f(i, j) $  $ k - i $  AC  $ j $  $ i $ \n\n $ + $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 15;\nconst int MAXM = 20;\nconst int MAXK = 1000;\nconst int CHARSET_SIZE = 26;\nconst int BASE_CHAR = 'A';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint wordCnt, id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tv->id = vec.size();\n#ifdef DBG\n\t\t\tprintf(\"wordCnt(%d) = %d\\n\", v->id, v->wordCnt);\n#endif\n\t\t\tvec.push_back(v);\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tc->wordCnt = c->isWord + (c->next ? c->next->wordCnt : 0);\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\twhile (n--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tstd::vector<Trie::Node *> vec;\n\tt.build(vec);\n\n\tstatic int f[MAXN * MAXM + 1][MAXK + 1];\n#ifdef DBG\n\tstatic char g[MAXN * MAXM + 1][MAXK + 1];\n#endif\n\t// for (size_t i = 0; i < vec.size(); i++) f[i][0] = vec[i]->wordCnt;\n\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tint t = f[vec[j]->c[k]->id][i - 1] + vec[j]->c[k]->wordCnt;\n\t\t\t\tif (t >= f[j][i]) {\n\t\t\t\t\tf[j][i] = t;\n#ifdef DBG\n\t\t\t\t\tg[j][i] = k;\n#endif\n\t\t\t\t}\n\t\t\t}\n#ifdef DBG\n\t\t\tprintf(\"f(%lu, %d) = %d\\n\", j, i, f[j][i]);\n#endif\n\t\t}\n\t}\n\n#ifdef DBG\n\tint last = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tputchar(g[last][i] + 'A');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n\tputchar('\\n');\n\n\tlast = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tprintf(\"%d%c\", last, i == 1 ? '\\n' : ' ');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n#endif\n\n\tprintf(\"%d\\n\", f[0][k]);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2580.md","raw":"title: BZOJ 2580Video Game - AC \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - AC \n  - DP\npermalink: bzoj-2580\ndate: 2016-09-18 07:16:00\n---\n\n $ n $  $ s_i $ $ k $  $ S $ $ S $  $ s_i $\n\n<!-- more -->\n\n### \n[BZOJ 2580](http://www.lydsy.com/JudgeOnline/problem.php?id=2580)\n\n### \n $ f(i, j) $  $ k - i $  AC  $ j $  $ i $ \n\n $ + $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 15;\nconst int MAXM = 20;\nconst int MAXK = 1000;\nconst int CHARSET_SIZE = 26;\nconst int BASE_CHAR = 'A';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint wordCnt, id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tv->id = vec.size();\n#ifdef DBG\n\t\t\tprintf(\"wordCnt(%d) = %d\\n\", v->id, v->wordCnt);\n#endif\n\t\t\tvec.push_back(v);\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tc->wordCnt = c->isWord + (c->next ? c->next->wordCnt : 0);\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\twhile (n--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tstd::vector<Trie::Node *> vec;\n\tt.build(vec);\n\n\tstatic int f[MAXN * MAXM + 1][MAXK + 1];\n#ifdef DBG\n\tstatic char g[MAXN * MAXM + 1][MAXK + 1];\n#endif\n\t// for (size_t i = 0; i < vec.size(); i++) f[i][0] = vec[i]->wordCnt;\n\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tint t = f[vec[j]->c[k]->id][i - 1] + vec[j]->c[k]->wordCnt;\n\t\t\t\tif (t >= f[j][i]) {\n\t\t\t\t\tf[j][i] = t;\n#ifdef DBG\n\t\t\t\t\tg[j][i] = k;\n#endif\n\t\t\t\t}\n\t\t\t}\n#ifdef DBG\n\t\t\tprintf(\"f(%lu, %d) = %d\\n\", j, i, f[j][i]);\n#endif\n\t\t}\n\t}\n\n#ifdef DBG\n\tint last = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tputchar(g[last][i] + 'A');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n\tputchar('\\n');\n\n\tlast = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tprintf(\"%d%c\", last, i == 1 ? '\\n' : ' ');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n#endif\n\n\tprintf(\"%d\\n\", f[0][k]);\n\n\treturn 0;\n}\n```","slug":"bzoj-2580","published":1,"updated":"2016-09-17T23:25:45.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj0y01eu0jxlh7km3gl6"},{"title":"BeiJing2011 - AC ","date":"2016-09-13T23:32:00.000Z","_content":"\n $ M $  $ N $  01  $ Q $  $ A $  $ B $  01  $ Q $  \n\n<!-- more -->\n\n### \n[BZOJ 2462](http://www.lydsy.com/JudgeOnline/problem.php?id=2462)\n\n### \n AC  $ i $  $ j $  $ k $  $ (i - k, j - b + 1) $  $ 1 $ \n\n $ \\geq b $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint id;\n\n\t\tNode(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply(std::vector< std::pair<int, int> > &vec, const int pos) {\n\t\t\tassert(isWord);\n\t\t\tvec.push_back(std::make_pair(pos, id));\n\t\t\tif (next) next->apply(vec, pos);\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\ttemplate <typename T>\n\tvoid insert(const T *begin, const T *end, const int id) {\n\t\tNode **v = &root;\n\t\tfor (const T *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, id);\n\t\telse (*v)->id = id, (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const bool *begin, const bool *end, std::vector< std::pair<int, int> > &vec) {\n\t\tNode *v = root;\n\t\tfor (const bool *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply(vec, p - begin);\n\t\t\telse if (v->next) v->next->apply(vec, p - begin);\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\troot = NULL;\n\t}\n} t;\n\nint main() {\n\tint n, m, a, b;\n\tscanf(\"%d %d %d %d\", &n, &m, &a, &b);\n\n\tstatic bool matrix[MAXN][MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < m; j++) matrix[i][j] = s[j] - BASE_CHAR;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tt.clear();\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tstatic char s[MAXN + 1];\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor (int j = 0; j < b; j++) s[j] -= BASE_CHAR;\n\t\t\tt.insert(s, s + b, i);\n\t\t}\n\n\t\tt.build();\n\n\t\tstatic int matchCnt[MAXN][MAXN];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::vector< std::pair<int, int> > vec;\n\t\t\tt.exec(matrix[i], matrix[i] + m, vec);\n\t\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n \t\t\t\t// printf(\"%d matched %d\\n\", i, *it);\n\t\t\t\tif (i - it->second >= 0) matchCnt[i - it->second][it->first - b + 1]++;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// printf(\"match(%d) = %d\\n\", i, matchCnt[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (matchCnt[i][j] >= b) flag = true;\n\t\t\t\tmatchCnt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(flag ? \"1\" : \"0\");\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2462.md","raw":"title: BeiJing2011 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - AC \npermalink: bzoj-2462\ndate: 2016-09-14 07:32:00\n---\n\n $ M $  $ N $  01  $ Q $  $ A $  $ B $  01  $ Q $  \n\n<!-- more -->\n\n### \n[BZOJ 2462](http://www.lydsy.com/JudgeOnline/problem.php?id=2462)\n\n### \n AC  $ i $  $ j $  $ k $  $ (i - k, j - b + 1) $  $ 1 $ \n\n $ \\geq b $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint id;\n\n\t\tNode(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply(std::vector< std::pair<int, int> > &vec, const int pos) {\n\t\t\tassert(isWord);\n\t\t\tvec.push_back(std::make_pair(pos, id));\n\t\t\tif (next) next->apply(vec, pos);\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\ttemplate <typename T>\n\tvoid insert(const T *begin, const T *end, const int id) {\n\t\tNode **v = &root;\n\t\tfor (const T *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, id);\n\t\telse (*v)->id = id, (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const bool *begin, const bool *end, std::vector< std::pair<int, int> > &vec) {\n\t\tNode *v = root;\n\t\tfor (const bool *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply(vec, p - begin);\n\t\t\telse if (v->next) v->next->apply(vec, p - begin);\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\troot = NULL;\n\t}\n} t;\n\nint main() {\n\tint n, m, a, b;\n\tscanf(\"%d %d %d %d\", &n, &m, &a, &b);\n\n\tstatic bool matrix[MAXN][MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < m; j++) matrix[i][j] = s[j] - BASE_CHAR;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tt.clear();\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tstatic char s[MAXN + 1];\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor (int j = 0; j < b; j++) s[j] -= BASE_CHAR;\n\t\t\tt.insert(s, s + b, i);\n\t\t}\n\n\t\tt.build();\n\n\t\tstatic int matchCnt[MAXN][MAXN];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::vector< std::pair<int, int> > vec;\n\t\t\tt.exec(matrix[i], matrix[i] + m, vec);\n\t\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n \t\t\t\t// printf(\"%d matched %d\\n\", i, *it);\n\t\t\t\tif (i - it->second >= 0) matchCnt[i - it->second][it->first - b + 1]++;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// printf(\"match(%d) = %d\\n\", i, matchCnt[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (matchCnt[i][j] >= b) flag = true;\n\t\t\t\tmatchCnt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(flag ? \"1\" : \"0\");\n\t}\n\n\treturn 0;\n}\n```","slug":"bzoj-2462","published":1,"updated":"2016-09-13T23:41:03.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj1501f10jxl5z2srfqc"},{"title":"BZOJ 2456mode - ","date":"2016-06-17T14:07:00.000Z","_content":"\n $ n $  $ n \\over 2 $ \n\n<!-- more -->\n\n### \n[BZOJ 2456](http://www.lydsy.com/JudgeOnline/problem.php?id=2456)\n\n### \n$ 500,000 $ $ \\text {1M} $  $ O(1) $ \n\n $ n \\over 2 $ \n\n $ 0 $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 500000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = -1, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (cnt == 0) {\n\t\t\tans = x;\n\t\t\tcnt = 1;\n\t\t} else {\n\t\t\tif (ans == x) {\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2456.md","raw":"title: BZOJ 2456mode - \ncategories: OI\ntags: \n  - BZOJ\n  - \npermalink: bzoj-2456\ndate: 2016-06-17 22:07:00\n---\n\n $ n $  $ n \\over 2 $ \n\n<!-- more -->\n\n### \n[BZOJ 2456](http://www.lydsy.com/JudgeOnline/problem.php?id=2456)\n\n### \n$ 500,000 $ $ \\text {1M} $  $ O(1) $ \n\n $ n \\over 2 $ \n\n $ 0 $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 500000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = -1, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (cnt == 0) {\n\t\t\tans = x;\n\t\t\tcnt = 1;\n\t\t} else {\n\t\t\tif (ans == x) {\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2456","published":1,"updated":"2016-06-17T14:08:31.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj1b01f60jxl24qpn1l2"},{"title":"BZOJ 2442 -  DP + ","id":"24","updated":"2016-01-19T13:03:11.000Z","date":"2016-01-16T14:32:47.000Z","_content":"\nFJ  `N`$1  N  100,000$ `1`  `N` `i` $E_i$$0  E_i  1,000,000,000$\n\n FJ  `K`  FJ  FJ  `K` \n\n<!-- more -->\n\n### \n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### \n $O(n^2)$  DP $a[i]$  `i` $f[i]$  `i`  `j`$i-k  j < i$ `j` \n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n\n\n$$ f[1]=a[1] $$\n\n $O(n)$ \n\n `-1`\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n DP\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n $f[i-1]$\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n `k + 1`  $g(j)$ $O(1)$ \n\n\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n\n\n1. $E_i$ `int` `long long` \n2. \n\n~~~~\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2442.md","raw":"title: BZOJ 2442 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - USACO\n  - DP\n  - \n  -  DP\npermalink: bzoj-2442\nid: 24\nupdated: '2016-01-19 21:03:11'\ndate: 2016-01-16 22:32:47\n---\n\nFJ  `N`$1  N  100,000$ `1`  `N` `i` $E_i$$0  E_i  1,000,000,000$\n\n FJ  `K`  FJ  FJ  `K` \n\n<!-- more -->\n\n### \n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### \n $O(n^2)$  DP $a[i]$  `i` $f[i]$  `i`  `j`$i-k  j < i$ `j` \n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n\n\n$$ f[1]=a[1] $$\n\n $O(n)$ \n\n `-1`\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n DP\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n $f[i-1]$\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n `k + 1`  $g(j)$ $O(1)$ \n\n\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n\n\n1. $E_i$ `int` `long long` \n2. \n\n~~~~\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2442","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj1h01fa0jxlsxrvxs03"},{"title":"BZOJ 2438 - ","date":"2016-06-25T08:31:00.000Z","_content":"\n $ N $ \n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2438](http://www.lydsy.com/JudgeOnline/problem.php?id=2438)\n\n### \n\n\n\n\n\n\n $ 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *e, *in, *c;\n\tbool visited, pushed, inStack;\n\tint dfn, low, inDegree;\n\tSCC *scc;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint s;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, m;\n\ninline int tarjan() {\n\tint time = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->dfn = v->low = time++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tif (v->c->t->inStack) v->low = std::min(v->low, v->c->t->dfn);\n\t\t\t\telse if (v->c->t->pushed == false) s.push(v->c->t), v->c->t->pushed = true, v->c->t->in = v->c;\n\t\t\t\tv->c = v->c->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = scc;\n\t\t\t\t\t\tu->scc->s++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->in) v->in->s->low = std::min(v->in->s->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tif (e->s->scc != e->t->scc) {\n\t\t\t\te->s->scc->v.e = new Edge(&e->s->scc->v, &e->t->scc->v);\n\t\t\t\te->t->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t), s--, t--;\n\t\taddEdge(s, t);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint k = 0;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0) k++;\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0 && S[i].s == 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (Edge *e = S[i].v.e; e; e = e->next) {\n\t\t\t\tif (e->t->inDegree <= 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tk--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", static_cast<double>(n - k) / n);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2438.md","raw":"title: BZOJ 2438 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Tarjan\n  - \npermalink: bzoj-2438\ndate: 2016-06-25 16:31:00\n---\n\n $ N $ \n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2438](http://www.lydsy.com/JudgeOnline/problem.php?id=2438)\n\n### \n\n\n\n\n\n\n $ 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *e, *in, *c;\n\tbool visited, pushed, inStack;\n\tint dfn, low, inDegree;\n\tSCC *scc;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint s;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, m;\n\ninline int tarjan() {\n\tint time = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->dfn = v->low = time++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tif (v->c->t->inStack) v->low = std::min(v->low, v->c->t->dfn);\n\t\t\t\telse if (v->c->t->pushed == false) s.push(v->c->t), v->c->t->pushed = true, v->c->t->in = v->c;\n\t\t\t\tv->c = v->c->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = scc;\n\t\t\t\t\t\tu->scc->s++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->in) v->in->s->low = std::min(v->in->s->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tif (e->s->scc != e->t->scc) {\n\t\t\t\te->s->scc->v.e = new Edge(&e->s->scc->v, &e->t->scc->v);\n\t\t\t\te->t->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t), s--, t--;\n\t\taddEdge(s, t);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint k = 0;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0) k++;\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0 && S[i].s == 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (Edge *e = S[i].v.e; e; e = e->next) {\n\t\t\t\tif (e->t->inDegree <= 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tk--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", static_cast<double>(n - k) / n);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2438","published":1,"updated":"2016-06-25T08:31:49.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj1q01fi0jxlg06ly3qi"},{"title":"BZOJ 2296 - ","date":"2016-04-01T14:59:45.000Z","_content":"\n $ x $$ 0 \\leq x \\leq 10 ^ 6 $ $ n $ \n\n1. $ n $  0 ~ 9 \n2. $ n ~ {\\rm mod} ~ x = 0 $\n3. $ 0 \\leq n \\leq 10 ^ {16} $\n\n<!-- more -->\n\n### \n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### \n 1 n  10  $ 9876543210 $ 6 \n\n $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $ $ 9876543210 $  $ d $ $ n = 9876543210 \\times 10 ^ 6 + x - d $ \n\n 0 \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2296.md","raw":"title: BZOJ 2296 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-2296\ndate: 2016-04-01 22:59:45\n---\n\n $ x $$ 0 \\leq x \\leq 10 ^ 6 $ $ n $ \n\n1. $ n $  0 ~ 9 \n2. $ n ~ {\\rm mod} ~ x = 0 $\n3. $ 0 \\leq n \\leq 10 ^ {16} $\n\n<!-- more -->\n\n### \n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### \n 1 n  10  $ 9876543210 $ 6 \n\n $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $ $ 9876543210 $  $ d $ $ n = 9876543210 \\times 10 ^ 6 + x - d $ \n\n 0 \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2296","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj1x01fo0jxljb2rauke"},{"title":"BZOJ 2194 - FFT","date":"2016-06-10T01:32:00.000Z","_content":"\n $ n $  $ A $$ B $ $ n $  $ C $ $ C_k = \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} $\n\n<!-- more -->\n\n### \n[BZOJ 2194](http://www.lydsy.com/JudgeOnline/problem.php?id=2194)\n\n### \n $ A $  $ A' $\n\n$$\n\\begin{align*}\nC_k &= \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} \\\\\n&= \\sum\\limits_{i = k} ^ {n - 1} A'_{n - i - 1} \\times B_{i - k}\n\\end{align*}\n$$\n\n $ i $  $ 0 $ \n\n$$\nC_k = \\sum\\limits_{i = 0} ^ {n - k - 1} A'_{n - k - 1 - i} \\times B_{i}\n$$\n\n\n\n$$ c_t = \\sum\\limits_{i = 0} ^ {t} a_{t - i} b_{i} $$\n\n $ t = n - k - 1 $\n\n$$\nC_{n - t - 1} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ C $  $ C' $\n\n$$\nC'_{t} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ A' $  $ B $  $ C' $ $ n $  $ C $\n\n FFT $ O(n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n\nconst int MAXN = 131072 * 2;\nconst double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << (k - j - 1))) t |= (1 << j);\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid operator()(const int *a, const int n1, const int *b, const int n2, int *c) {\n\t\tfor (int k = 0; k < n1 + n2; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tc[k] += a[i] * b[k - i];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\n\t\tstatic std::complex<double> ca[MAXN], cb[MAXN];\n\n\t\tint n = 1;\n\t\twhile (n < (n1 + n2)) n *= 2;\n\n\t\tfor (int i = 0; i < n; i++) ca[i] = std::complex<double>(i < n1 ? a[i] : 0, 0);\n\t\tfor (int i = 0; i < n; i++) cb[i] = std::complex<double>(i < n2 ? b[i] : 0, 0);\n\n\t\tinit(n);\n\t\tdft(ca, n);\n\t\tdft(cb, n);\n\n\t\tfor (int i = 0; i < n; i++) ca[i] *= cb[i];\n\n\t\tidft(ca, n);\n\n\t\tfor (int i = 0; i < n; i++) c[i] = static_cast<int>(floor(ca[i].real() + 0.5));\n\t}\n} fft;\n\ninline void force(const int *a, const int *b, int *c, const int n) {\n\t/*\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tc[k] += a[n - i - 1] * b[i - k];\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n - k; i++) {\n\t\t\tc[k] += a[n - k - 1 - i] * b[i];\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN], c[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[n - i - 1], &b[i]);\n\n\t// force(a, b, c, n);\n\tfft(a, n, b, n, c);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", c[n - i - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2194.md","raw":"title: BZOJ 2194 - FFT\ncategories: OI\ntags: \n  - BZOJ\n  - \n  - FFT\npermalink: bzoj-2194\ndate: 2016-06-10 09:32:00\n---\n\n $ n $  $ A $$ B $ $ n $  $ C $ $ C_k = \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} $\n\n<!-- more -->\n\n### \n[BZOJ 2194](http://www.lydsy.com/JudgeOnline/problem.php?id=2194)\n\n### \n $ A $  $ A' $\n\n$$\n\\begin{align*}\nC_k &= \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} \\\\\n&= \\sum\\limits_{i = k} ^ {n - 1} A'_{n - i - 1} \\times B_{i - k}\n\\end{align*}\n$$\n\n $ i $  $ 0 $ \n\n$$\nC_k = \\sum\\limits_{i = 0} ^ {n - k - 1} A'_{n - k - 1 - i} \\times B_{i}\n$$\n\n\n\n$$ c_t = \\sum\\limits_{i = 0} ^ {t} a_{t - i} b_{i} $$\n\n $ t = n - k - 1 $\n\n$$\nC_{n - t - 1} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ C $  $ C' $\n\n$$\nC'_{t} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ A' $  $ B $  $ C' $ $ n $  $ C $\n\n FFT $ O(n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n\nconst int MAXN = 131072 * 2;\nconst double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << (k - j - 1))) t |= (1 << j);\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid operator()(const int *a, const int n1, const int *b, const int n2, int *c) {\n\t\tfor (int k = 0; k < n1 + n2; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tc[k] += a[i] * b[k - i];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\n\t\tstatic std::complex<double> ca[MAXN], cb[MAXN];\n\n\t\tint n = 1;\n\t\twhile (n < (n1 + n2)) n *= 2;\n\n\t\tfor (int i = 0; i < n; i++) ca[i] = std::complex<double>(i < n1 ? a[i] : 0, 0);\n\t\tfor (int i = 0; i < n; i++) cb[i] = std::complex<double>(i < n2 ? b[i] : 0, 0);\n\n\t\tinit(n);\n\t\tdft(ca, n);\n\t\tdft(cb, n);\n\n\t\tfor (int i = 0; i < n; i++) ca[i] *= cb[i];\n\n\t\tidft(ca, n);\n\n\t\tfor (int i = 0; i < n; i++) c[i] = static_cast<int>(floor(ca[i].real() + 0.5));\n\t}\n} fft;\n\ninline void force(const int *a, const int *b, int *c, const int n) {\n\t/*\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tc[k] += a[n - i - 1] * b[i - k];\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n - k; i++) {\n\t\t\tc[k] += a[n - k - 1 - i] * b[i];\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN], c[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[n - i - 1], &b[i]);\n\n\t// force(a, b, c, n);\n\tfft(a, n, b, n, c);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", c[n - i - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2194","published":1,"updated":"2016-06-11T13:32:41.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj2601ft0jxl0fyw485h"},{"title":"BZOJ 2152 - ","date":"2016-06-14T14:09:00.000Z","_content":"\n $ n $  $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2152](http://www.lydsy.com/JudgeOnline/problem.php?id=2152)\n\n### \n $ \\bmod 3 $  $ i $  $ f(i) $\n\n $ f(1) \\times f(2) \\times 2 $   \n $ f(0) $  $ \\frac{ f(0) \\times (f(0) - 1) }{2} $ $ 2 $ $ f ^ 2(0) $\n\n $ f ^ 2(0) + f(1) \\times f(2) \\times 2 $ \n\n $ n ^ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, dist, max;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(start->size - a[i]->max, a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->parent = NULL;\n\troot->dist = dist;\n\t\n\tint a[3] = { 0, 0, 0 }, cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt++;\n\t\ta[v->dist %= 3]++;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn a[0] * a[0] + a[1] * a[2] * 2;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint res = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\tres += calc(root);\n\t\troot->solved = true;\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tres -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--, w %= 3;\n\t\taddEdge(u, v, w);\n\t}\n\n\tint cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum);\n\tprintf(\"%d/%d\\n\", cnt / g, sum / g);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2152.md","raw":"title: BZOJ 2152 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-2152\ndate: 2016-06-14 22:09:00\n---\n\n $ n $  $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2152](http://www.lydsy.com/JudgeOnline/problem.php?id=2152)\n\n### \n $ \\bmod 3 $  $ i $  $ f(i) $\n\n $ f(1) \\times f(2) \\times 2 $   \n $ f(0) $  $ \\frac{ f(0) \\times (f(0) - 1) }{2} $ $ 2 $ $ f ^ 2(0) $\n\n $ f ^ 2(0) + f(1) \\times f(2) \\times 2 $ \n\n $ n ^ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, dist, max;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(start->size - a[i]->max, a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->parent = NULL;\n\troot->dist = dist;\n\t\n\tint a[3] = { 0, 0, 0 }, cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt++;\n\t\ta[v->dist %= 3]++;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn a[0] * a[0] + a[1] * a[2] * 2;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint res = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\tres += calc(root);\n\t\troot->solved = true;\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tres -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--, w %= 3;\n\t\taddEdge(u, v, w);\n\t}\n\n\tint cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum);\n\tprintf(\"%d/%d\\n\", cnt / g, sum / g);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2152","published":1,"updated":"2016-06-16T10:10:15.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj2c01fy0jxlhdv5t1lw"},{"title":"BZOJ 2143 - ","date":"2016-03-22T11:50:15.000Z","_content":"\n $ N * M $  $ i $  $ j $  $ A_{ij} $  $ B_{ij} $  $ 1 $ $ (i,j) $  $ A_{ij} $   $ B_{ij} $ \n\n XYZ $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2143](http://www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### \n 40% $ B_{ij} $ $ B_{ij} $  $ A_{ij} $  0 Dijkstra \n\n   Dijkstra \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2143.md","raw":"title: BZOJ 2143 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dijkstra\n  - \npermalink: bzoj-2143\ndate: 2016-03-22 19:50:15\n---\n\n $ N * M $  $ i $  $ j $  $ A_{ij} $  $ B_{ij} $  $ 1 $ $ (i,j) $  $ A_{ij} $   $ B_{ij} $ \n\n XYZ $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2143](http://www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### \n 40% $ B_{ij} $ $ B_{ij} $  $ A_{ij} $  0 Dijkstra \n\n   Dijkstra \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2143","published":1,"updated":"2016-06-14T07:16:00.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj2h01g30jxlhs4twjbt"},{"title":"BZOJ 2132 - ","date":"2016-06-23T08:56:00.000Z","_content":"\n $ i $  $ j $  $ A_{i,\\ j} $  $ B_{i,\\ j} $  $ (i,\\ j) $  $ K $  $ K $  $ 4 $ $ (i,\\ j) $  $ K \\times C_{i,\\ j} $ \n\n<!-- more -->\n\n### \n[BZOJ 2132](http://www.lydsy.com/JudgeOnline/problem.php?id=2132)\n\n### \n $ X $  $ A_{i,\\ j} $ $ Y $  $ B_{i,\\ j} $ $ X $  $ B_{i,\\ j} $ $ Y $  $ A_{i,\\ j} $\n\n $ C_{i_1,\\ j_1} + C_{i_2,\\ j_2} $ \n\n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\tconst int s = 0, t = n * m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\t\t\t\n\t\t\tif ((i + j) % 2 == 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\n\t\t\tif ((i + j) % 2 != 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x;\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x;\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2132.md","raw":"title: BZOJ 2132 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: bzoj-2132\ndate: 2016-06-23 16:56:00\n---\n\n $ i $  $ j $  $ A_{i,\\ j} $  $ B_{i,\\ j} $  $ (i,\\ j) $  $ K $  $ K $  $ 4 $ $ (i,\\ j) $  $ K \\times C_{i,\\ j} $ \n\n<!-- more -->\n\n### \n[BZOJ 2132](http://www.lydsy.com/JudgeOnline/problem.php?id=2132)\n\n### \n $ X $  $ A_{i,\\ j} $ $ Y $  $ B_{i,\\ j} $ $ X $  $ B_{i,\\ j} $ $ Y $  $ A_{i,\\ j} $\n\n $ C_{i_1,\\ j_1} + C_{i_2,\\ j_2} $ \n\n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\tconst int s = 0, t = n * m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\t\t\t\n\t\t\tif ((i + j) % 2 == 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\n\t\t\tif ((i + j) % 2 != 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x;\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x;\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2132","published":1,"updated":"2016-06-23T08:56:59.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj2u01ga0jxl62fut59c"},{"title":"BZOJ 2127happiness - ","date":"2016-06-21T09:41:00.000Z","_content":"\n $ n \\times m $ ********\n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2];\n\tconst int DOWN = 0, RIGHT = 1;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &aDown[i][j]), sum += aDown[i][j];\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &bDown[i][j]);\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &aRight[i][j]), sum += aRight[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &bRight[i][j]);\n\n\tint id = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) vID[i][j] = id++;\n\n\t// printf(\"eID starts from %d\\n\", id);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++;\n\t\t\tif (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++;\n\t\t}\n\t}\n\n\tconst int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1;\n\n\t// printf(\"%d %d\\n\", id, t);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, vID[i][j], x), sum += x;\n\t\t\telse addEdge(vID[i][j], t, -x);\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(eID[i][j][DOWN][0], t, aDown[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX);\n\t\t\t\taddEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(eID[i][j][RIGHT][0], t, aRight[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX);\n\t\t\t\taddEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2127.md","raw":"title: BZOJ 2127happiness - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-2127\ndate: 2016-06-21 17:41:00\n---\n\n $ n \\times m $ ********\n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2];\n\tconst int DOWN = 0, RIGHT = 1;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &aDown[i][j]), sum += aDown[i][j];\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &bDown[i][j]);\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &aRight[i][j]), sum += aRight[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &bRight[i][j]);\n\n\tint id = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) vID[i][j] = id++;\n\n\t// printf(\"eID starts from %d\\n\", id);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++;\n\t\t\tif (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++;\n\t\t}\n\t}\n\n\tconst int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1;\n\n\t// printf(\"%d %d\\n\", id, t);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, vID[i][j], x), sum += x;\n\t\t\telse addEdge(vID[i][j], t, -x);\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(eID[i][j][DOWN][0], t, aDown[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX);\n\t\t\t\taddEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(eID[i][j][RIGHT][0], t, aRight[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX);\n\t\t\t\taddEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2127","published":1,"updated":"2016-06-22T08:25:36.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj3201gg0jxldhxgs6vm"},{"title":"BZOJ 2038Z - ","date":"2016-04-01T14:15:45.000Z","_content":"\n $ x_1 $ ~ $ x_n $ $ m $  $ x_i $ ~ $ x_j $ \n\n<!-- more -->\n\n### \n $ \\sqrt n $ \n\n $ x_i $ ~ $ x_j $ \n\n $ x $  $ c_i $ \n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2038.md","raw":"title: BZOJ 2038Z - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \npermalink: bzoj-2038\ndate: 2016-04-01 22:15:45\n---\n\n $ x_1 $ ~ $ x_n $ $ m $  $ x_i $ ~ $ x_j $ \n\n<!-- more -->\n\n### \n $ \\sqrt n $ \n\n $ x_i $ ~ $ x_j $ \n\n $ x $  $ c_i $ \n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2038","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj3a01gn0jxlhxbnjmp9"},{"title":"BZOJ 1756 - ","id":"38","updated":"2016-01-24T15:24:35.000Z","date":"2016-01-24T15:19:48.000Z","_content":"\n `n`  `a`  `b`  `a``b` \n\n<!-- more -->\n\n### \n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### \n\n\n\n\n1. \n2. \n3. ****\n4. ****\n\n\n\n****\n\n\n\n `a``b`  `a`  `b` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1756.md","raw":"title: BZOJ 1756 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - DP\npermalink: bzoj-1756\nid: 38\nupdated: '2016-01-24 23:24:35'\ndate: 2016-01-24 23:19:48\n---\n\n `n`  `a`  `b`  `a``b` \n\n<!-- more -->\n\n### \n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### \n\n\n\n\n1. \n2. \n3. ****\n4. ****\n\n\n\n****\n\n\n\n `a``b`  `a`  `b` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1756","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj3g01gt0jxlkxdwd32p"},{"title":"BZOJ 1711Dining - ","date":"2016-06-21T14:17:00.000Z","_content":"\n $ F $$ 1 \\leq F \\leq 100 $ $ D $$ 1 \\leq D \\leq 100 $$ N $$ 1 \\leq N \\leq 100 $\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1711](http://www.lydsy.com/JudgeOnline/problem.php?id=1711)\n\n### \n $ A $  $ A' $ $ A $  $ A' $ \n\n\n\n $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m1, m2;\n\tscanf(\"%d %d %d\", &n, &m1, &m2);\n\n\tconst int s = 0, t = n * 2 + m1 + m2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\tfor (int i = n + n + 1; i <= n + n + m1; i++) addEdge(s, i, 1);\n\tfor (int i = n + n + m1 + 1; i <= n + n + m1 + m2; i++) addEdge(i, t, 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k1, k2;\n\t\tscanf(\"%d %d\", &k1, &k2);\n\n\t\tfor (int j = 0; j < k1; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(n + n + x, i, 1);\n\t\t}\n\n\t\tfor (int j = 0; j < k2; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i + n, n + n + m1 + x, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1711.md","raw":"title: BZOJ 1711Dining - \ndate: 2016-06-21 22:17:00\ncategories: OI\ntags:\n  - BZOJ\n  - USACO\n  - \n  - Dinic\npermalink: bzoj-1711\n---\n\n $ F $$ 1 \\leq F \\leq 100 $ $ D $$ 1 \\leq D \\leq 100 $$ N $$ 1 \\leq N \\leq 100 $\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1711](http://www.lydsy.com/JudgeOnline/problem.php?id=1711)\n\n### \n $ A $  $ A' $ $ A $  $ A' $ \n\n\n\n $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m1, m2;\n\tscanf(\"%d %d %d\", &n, &m1, &m2);\n\n\tconst int s = 0, t = n * 2 + m1 + m2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\tfor (int i = n + n + 1; i <= n + n + m1; i++) addEdge(s, i, 1);\n\tfor (int i = n + n + m1 + 1; i <= n + n + m1 + m2; i++) addEdge(i, t, 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k1, k2;\n\t\tscanf(\"%d %d\", &k1, &k2);\n\n\t\tfor (int j = 0; j < k1; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(n + n + x, i, 1);\n\t\t}\n\n\t\tfor (int j = 0; j < k2; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i + n, n + n + m1 + x, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1711","published":1,"updated":"2016-10-08T09:04:46.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj3n01h00jxl0k4v6l4e"},{"title":"BZOJ 1706 - ","date":"2016-10-07T23:11:00.000Z","_content":"\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1586](www.lydsy.com/JudgeOnline/problem.php?id=1586)  \n[COGS 1470](http://cogs.pro/cogs/problem/problem.php?pid=1470)\n\n### \n $ k $  $ k $ \n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 100;\nconst int MAXN_SMALL = 200;\nconst int MAXK = 1000000;\n\nstruct Matrix {\n\tint a[MAXN_SMALL][MAXN_SMALL];\n\n\tMatrix(const bool unit = false) {\n\t\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) a[i][j] = INT_MAX;\n\t\tif (unit) for (int i = 0; i < MAXN_SMALL; i++) a[i][i] = 0;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) for (int k = 0; k < MAXN_SMALL; k++) if (a(i, k) != INT_MAX && b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j));\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"relays.in\", \"r\", stdin);\n\tfreopen(\"relays.out\", \"w\", stdout);\n\n\tint n, m, s, t, cnt;\n\tstatic int set[MAXM * 2];\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n\tstatic struct {\n\t\tint u, v, w;\n\t} E[MAXM];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].w, &E[i].u, &E[i].v);\n\t\tset[i] = E[i].u;\n\t\tset[i + m] = E[i].v;\n\t}\n\n\tstd::sort(set, set + m * 2);\n\tint *end = std::unique(set, set + m * 2);\n\tcnt = end - set;\n\n\tMatrix g(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tE[i].u = std::lower_bound(set, end, E[i].u) - set;\n\t\tE[i].v = std::lower_bound(set, end, E[i].v) - set;\n\t\tg(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w;\n\t}\n\ts = std::lower_bound(set, end, s) - set;\n\tt = std::lower_bound(set, end, t) - set;\n\n\tMatrix res = pow(g, n);\n\t/*\n\tMatrix res(true);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = res * g;\n\t\tfor (int i = 0; i < cnt; i++) for (int j = 0; j < cnt; j++) printf(\"%d%c\", res(i, j), j == cnt - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------------\");\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", res(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1706.md","raw":"title: BZOJ 1706 - \ndate: 2016-10-08 07:11:00\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - USACO\n  - \npermalink: bzoj-1706\n---\n\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1586](www.lydsy.com/JudgeOnline/problem.php?id=1586)  \n[COGS 1470](http://cogs.pro/cogs/problem/problem.php?pid=1470)\n\n### \n $ k $  $ k $ \n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 100;\nconst int MAXN_SMALL = 200;\nconst int MAXK = 1000000;\n\nstruct Matrix {\n\tint a[MAXN_SMALL][MAXN_SMALL];\n\n\tMatrix(const bool unit = false) {\n\t\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) a[i][j] = INT_MAX;\n\t\tif (unit) for (int i = 0; i < MAXN_SMALL; i++) a[i][i] = 0;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) for (int k = 0; k < MAXN_SMALL; k++) if (a(i, k) != INT_MAX && b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j));\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"relays.in\", \"r\", stdin);\n\tfreopen(\"relays.out\", \"w\", stdout);\n\n\tint n, m, s, t, cnt;\n\tstatic int set[MAXM * 2];\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n\tstatic struct {\n\t\tint u, v, w;\n\t} E[MAXM];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].w, &E[i].u, &E[i].v);\n\t\tset[i] = E[i].u;\n\t\tset[i + m] = E[i].v;\n\t}\n\n\tstd::sort(set, set + m * 2);\n\tint *end = std::unique(set, set + m * 2);\n\tcnt = end - set;\n\n\tMatrix g(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tE[i].u = std::lower_bound(set, end, E[i].u) - set;\n\t\tE[i].v = std::lower_bound(set, end, E[i].v) - set;\n\t\tg(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w;\n\t}\n\ts = std::lower_bound(set, end, s) - set;\n\tt = std::lower_bound(set, end, t) - set;\n\n\tMatrix res = pow(g, n);\n\t/*\n\tMatrix res(true);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = res * g;\n\t\tfor (int i = 0; i < cnt; i++) for (int j = 0; j < cnt; j++) printf(\"%d%c\", res(i, j), j == cnt - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------------\");\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", res(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"bzoj-1706","published":1,"updated":"2016-10-07T23:18:48.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj3w01h60jxla7ocz91w"},{"title":"BZOJ 1692 -  + ","date":"2016-09-29T13:33:00.000Z","_content":"\n $ S $ $ T $  $ T $\n\n<!-- more -->\n\n### \n[BZOJ 1692](http://www.lydsy.com/JudgeOnline/problem.php?id=1692)\n\n### \n\n\n\n\n 80 \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1692.md","raw":"title: BZOJ 1692 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - \n  - \npermalink: bzoj-1692\ndate: 2016-09-29 21:33:00\n---\n\n $ S $ $ T $  $ T $\n\n<!-- more -->\n\n### \n[BZOJ 1692](http://www.lydsy.com/JudgeOnline/problem.php?id=1692)\n\n### \n\n\n\n\n 80 \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","slug":"bzoj-1692","published":1,"updated":"2016-09-29T13:45:54.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj4501hc0jxlirv62qyg"},{"title":"BZOJ 1597 -  DP","date":"2016-05-18T09:04:00.000Z","_content":"\n John  $ N $$ 1 \\leq N \\leq 50000 $$ 1 \\leq $  $ \\leq 1000000 $ FJ  FJ  $ 3 \\times 5 $  $ 5 \\times 3 $  $ 5 \\times 5 = 25 $FJ \n\n<!-- more -->\n\n### \n[BZOJ 1597](http://www.lydsy.com/JudgeOnline/problem.php?id=1597)\n\n### \n\n\n $ w(i) $  $ h(i) $  $ f(i) $  $ i $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + w(j + 1) \\times h(i) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + w(a + 1) \\times h(i) & < f(b) + w(b + 1) \\times h(i) \\\\\nf(a) + f(b) & < (w(b + 1) - w(a + 1)) \\times h(i) \\\\\nf(a) + f(b) \\over w(b + 1) - w(a + 1) & < h(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50000;\n\nstd::pair<int, int> A[MAXN];\nstd::vector< std::pair<int, int>* > vec;\n\nint n;\nlong long f[MAXN + 1];\n\ninline void prepare() {\n    std::sort(A, A + n, std::greater< std::pair<int, int> >());\n\n    std::pair<int, int> *last = NULL;\n    for (int i = 0; i < n; i++) {\n        if (!last || A[i].second > last->second) {\n            vec.push_back(&A[i]);\n            last = &A[i];\n        }\n    }\n\n    n = vec.size();\n}\n\ninline long long w(const int i) { return static_cast<long long>(vec[i - 1]->first); }\ninline long long h(const int i) { return static_cast<long long>(vec[i - 1]->second); }\n\ninline void force() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + w(j + 1) * h(i)) {\n                f[i] = f[j] + w(j + 1) * h(i);\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n\ninline double slope(const int a, const int b) {\n    return double(f[a] - f[b])\n         / double(w(b + 1) - w(a + 1));\n}\n\ninline void dp() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n\n    static int q[MAXN + 1];\n    int *l = &q[0], *r = &q[0];\n    *r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < h(i)) l++;\n\n        int tmp = *l;\n        f[i] = f[tmp] + w(tmp + 1) * h(i);\n        // printf(\"%d --> %d\\n\", i, tmp);\n\n        if (i != n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &A[i].first, &A[i].second);\n\n    prepare();\n    // for (int i = 0; i < n; i++) printf(\"%d %d\\n\", vec[i]->first, vec[i]->second);\n\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/bzoj-1597.md","raw":"title: BZOJ 1597 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - \n  - \npermalink: bzoj-1597\ndate: 2016-05-18 17:04:00\n---\n\n John  $ N $$ 1 \\leq N \\leq 50000 $$ 1 \\leq $  $ \\leq 1000000 $ FJ  FJ  $ 3 \\times 5 $  $ 5 \\times 3 $  $ 5 \\times 5 = 25 $FJ \n\n<!-- more -->\n\n### \n[BZOJ 1597](http://www.lydsy.com/JudgeOnline/problem.php?id=1597)\n\n### \n\n\n $ w(i) $  $ h(i) $  $ f(i) $  $ i $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + w(j + 1) \\times h(i) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + w(a + 1) \\times h(i) & < f(b) + w(b + 1) \\times h(i) \\\\\nf(a) + f(b) & < (w(b + 1) - w(a + 1)) \\times h(i) \\\\\nf(a) + f(b) \\over w(b + 1) - w(a + 1) & < h(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50000;\n\nstd::pair<int, int> A[MAXN];\nstd::vector< std::pair<int, int>* > vec;\n\nint n;\nlong long f[MAXN + 1];\n\ninline void prepare() {\n    std::sort(A, A + n, std::greater< std::pair<int, int> >());\n\n    std::pair<int, int> *last = NULL;\n    for (int i = 0; i < n; i++) {\n        if (!last || A[i].second > last->second) {\n            vec.push_back(&A[i]);\n            last = &A[i];\n        }\n    }\n\n    n = vec.size();\n}\n\ninline long long w(const int i) { return static_cast<long long>(vec[i - 1]->first); }\ninline long long h(const int i) { return static_cast<long long>(vec[i - 1]->second); }\n\ninline void force() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + w(j + 1) * h(i)) {\n                f[i] = f[j] + w(j + 1) * h(i);\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n\ninline double slope(const int a, const int b) {\n    return double(f[a] - f[b])\n         / double(w(b + 1) - w(a + 1));\n}\n\ninline void dp() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n\n    static int q[MAXN + 1];\n    int *l = &q[0], *r = &q[0];\n    *r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < h(i)) l++;\n\n        int tmp = *l;\n        f[i] = f[tmp] + w(tmp + 1) * h(i);\n        // printf(\"%d --> %d\\n\", i, tmp);\n\n        if (i != n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &A[i].first, &A[i].second);\n\n    prepare();\n    // for (int i = 0; i < n; i++) printf(\"%d %d\\n\", vec[i]->first, vec[i]->second);\n\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"bzoj-1597","published":1,"updated":"2016-10-24T23:38:54.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj4d01hj0jxlekqpkdy6"},{"title":"BZOJ 1585Earthquake Damage 2 - ","date":"2016-06-22T08:14:00.000Z","_content":"\n $ P $  $ C $  $ i $  $ A_i $  $ B_i $ $ A_i $ $ B_i $ $ A_i $  $ B_i $ Farmer John  $ 1 $ $ C $  $ N $  $ i $  $ R_i $ $ R_i $  $ R_i $  $ 1 $  Farmer John \n\n<!-- more -->\n\n### \n[BZOJ 1585](http://www.lydsy.com/JudgeOnline/problem.php?id=1585)\n\n### \n $ 1 $ $ R_i $ $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u + n, v, INT_MAX);\n\t\taddEdge(v + n, u, INT_MAX);\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\n\t\taddEdge(s, u + n, INT_MAX);\n\t}\n\n\taddEdge(1, t, INT_MAX);\n\n\tint maxFlow = dinic(s, t, n + n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1585.md","raw":"title: BZOJ 1585Earthquake Damage 2 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \n  - USACO\npermalink: bzoj-1585\ndate: 2016-06-22 16:14:00\n---\n\n $ P $  $ C $  $ i $  $ A_i $  $ B_i $ $ A_i $ $ B_i $ $ A_i $  $ B_i $ Farmer John  $ 1 $ $ C $  $ N $  $ i $  $ R_i $ $ R_i $  $ R_i $  $ 1 $  Farmer John \n\n<!-- more -->\n\n### \n[BZOJ 1585](http://www.lydsy.com/JudgeOnline/problem.php?id=1585)\n\n### \n $ 1 $ $ R_i $ $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u + n, v, INT_MAX);\n\t\taddEdge(v + n, u, INT_MAX);\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\n\t\taddEdge(s, u + n, INT_MAX);\n\t}\n\n\taddEdge(1, t, INT_MAX);\n\n\tint maxFlow = dinic(s, t, n + n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1585","published":1,"updated":"2016-06-22T08:14:52.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj4n01hp0jxllof8dkew"},{"title":"BZOJ 1477 - ","date":"2016-01-23T15:20:01.000Z","_content":"\n A  B 0  1  A  x B  y A  m  B  n  L \n\n<!-- more -->\n\n### \n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### \n $t$ \n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n $k=k_{1}-k_{2}$\n\n$$ (x+tm)-(y+tn)=kL $$\n\n\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n****\n\n\n\n### \n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1477.md","raw":"title: BZOJ 1477 - \ncategories: OI\ntags: \n  - BZOJ\n  - Tyvj\n  - EXGCD\n  - \npermalink: bzoj-1477\ndate: 2016-01-23 23:20:01\n---\n\n A  B 0  1  A  x B  y A  m  B  n  L \n\n<!-- more -->\n\n### \n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### \n $t$ \n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n $k=k_{1}-k_{2}$\n\n$$ (x+tm)-(y+tn)=kL $$\n\n\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n****\n\n\n\n### \n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1477","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj4v01hw0jxls0pz1a24"},{"title":"BZOJ 1468Tree - ","date":"2016-06-14T13:59:00.000Z","_content":"\n Tree Tree  $ K $\n\n<!-- more -->\n\n### \n[BZOJ 1468](http://www.lydsy.com/JudgeOnline/problem.php?id=1468)\n\n### \n****\n\n $ K $ \n\n $ a_i $ $ a_i + a_j \\leq K $  $ a_j $  $ i $ $ j $  $ i $  $ j $ $ a_i + a_j \\leq K $ $ [i + 1,\\ j] $  $ j - i $\n\n****\n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tprintf(\"%d\\n\", solve());\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1468.md","raw":"title: BZOJ 1468Tree - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-1468\ndate: 2016-06-14 21:59:00\n---\n\n Tree Tree  $ K $\n\n<!-- more -->\n\n### \n[BZOJ 1468](http://www.lydsy.com/JudgeOnline/problem.php?id=1468)\n\n### \n****\n\n $ K $ \n\n $ a_i $ $ a_i + a_j \\leq K $  $ a_j $  $ i $ $ j $  $ i $  $ j $ $ a_i + a_j \\leq K $ $ [i + 1,\\ j] $  $ j - i $\n\n****\n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tprintf(\"%d\\n\", solve());\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1468","published":1,"updated":"2016-06-16T10:09:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj5201i20jxlb9zeyzxs"},{"title":"BZOJ 1334Elect -  DP","date":"2016-07-11T14:50:00.000Z","_content":"\n$ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1334](http://www.lydsy.com/JudgeOnline/problem.php?id=1334)\n\n### \n\n\n $ f(i) $  $ i $ \n\n DP  $ i - f(i) \\leq \\frac{m}{2} $  $ i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tint m = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), m += a[i];\n\n\tstatic int f[MAXM + 1];\n\tf[0] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= a[i]; j--) {\n\t\t\tf[j] = std::max(f[j], std::min(f[j - a[i]], a[i]));\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (i - f[i] <= m / 2) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1334.md","raw":"title: BZOJ 1334Elect -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-1334\ndate: 2016-07-11 22:50:00\n---\n\n$ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1334](http://www.lydsy.com/JudgeOnline/problem.php?id=1334)\n\n### \n\n\n $ f(i) $  $ i $ \n\n DP  $ i - f(i) \\leq \\frac{m}{2} $  $ i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tint m = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), m += a[i];\n\n\tstatic int f[MAXM + 1];\n\tf[0] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= a[i]; j--) {\n\t\t\tf[j] = std::max(f[j], std::min(f[j - a[i]], a[i]));\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (i - f[i] <= m / 2) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1334","published":1,"updated":"2016-10-24T23:33:15.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj5701i70jxl47x9lp3g"},{"title":"BZOJ 1251 - Splay","id":"27","updated":"2016-01-19T13:02:18.000Z","date":"2016-01-18T13:44:15.000Z","_content":"\n `N` \n\n1.  `[L,R]`  `V`\n2.  `[L,R]`  `1 2 3 4`  `4 3 2 1`\n3.  `[L,R]`   `0`\n\n<!-- more -->\n\n### \n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### \nSplay \n\n `lazy-tag` `pushDown()` \n\n `maintain()` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1251.md","raw":"title: BZOJ 1251 - Splay\ncategories: OI\ntags: \n  - Splay\n  - BZOJ\n  - CodeVS\n  - \npermalink: bzoj-1251\nid: 27\nupdated: '2016-01-19 21:02:18'\ndate: 2016-01-18 21:44:15\n---\n\n `N` \n\n1.  `[L,R]`  `V`\n2.  `[L,R]`  `1 2 3 4`  `4 3 2 1`\n3.  `[L,R]`   `0`\n\n<!-- more -->\n\n### \n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### \nSplay \n\n `lazy-tag` `pushDown()` \n\n `maintain()` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","slug":"bzoj-1251","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj5e01ic0jxl76ncx0ym"},{"title":"BZOJ 1176Mokia - CDQ","date":"2016-06-20T11:48:00.000Z","_content":"\n $ N \\times N $$ N \\leq 2000000 $ $ S $\n\n $ \\leq 160000 $ $ \\leq 10000 $\n\n<!-- more -->\n\n### \n[BZOJ 1176](http://www.lydsy.com/JudgeOnline/problem.php?id=1176)\n\n### \n $ Q(x1,\\ y1,\\ x2,\\ y2) $  $ [x1,\\ y1] $  $ [x2,\\ y2] $ \n\n$$\n\\begin{aligned}\nQ(x1,\\ y1,\\ x2,\\ y2) = &  Q(0,\\ 0,\\ x2,\\ y2) \\\\\n& - Q(0,\\ 0,\\ x1 - 1,\\ y2) - Q(0,\\ 0,\\ x2,\\ y1 - 1) \\\\\n& + Q(0,\\ 0,\\ x1,\\ y1)\n\\end{aligned}\n$$\n\n$ x $$ y $ $ x $  $ y $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2000000 + 1;\nconst int MAXQ = 10000;\nconst int MAXM = 160000 + MAXQ * 4;\n\nstruct Triple {\n\tint id, x, y, d, delta, *ans;\n\n\tTriple() {}\n\tTriple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); }\n\tTriple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); }\n\n\tvoid setID() {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tbool isQuery() const { return d != 0; }\n} a[MAXM];\n\nint s, n, m, cnt, ans[MAXQ];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXM];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->x <= p2->x && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tif (!p->isQuery()) bit.update(p->y, p->delta);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tif (p->isQuery()) *p->ans += bit.query(p->y) * p->d;\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tif (q <= mid && !q->isQuery()) bit.clear(q->y);\n\t\t*q = *p;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &s, &n), n++;\n\t\n\tint qcnt = 0;\n\twhile (true) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 3) break;\n\t\telse if (t == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1++, y1++, x2++, y2++;\n\n\t\t\tint *p = &ans[qcnt++];\n\t\t\t*p = (y2 - y1 + 1) * (x2 - x1 + 1) * s;\n\t\t\ta[cnt++] = Triple(x2, y2, 1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y2, -1, p);\n\t\t\ta[cnt++] = Triple(x2, y1 - 1, -1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, 1, p);\n\t\t} else if (t == 1) {\n\t\t\tint x, y, delta;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &delta), x++, y++;\n\t\t\ta[cnt++] = Triple(x, y, delta);\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < cnt; i++) {\n\t\tprintf(\"Triple(x = %d, y = %d, d = %d, delta = %d)\\n\", a[i].x, a[i].y, a[i].d, a[i].delta);\n\t}\n\t*/\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qcnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1176.md","raw":"title: BZOJ 1176Mokia - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-1176\ndate: 2016-06-20 19:48:00\n---\n\n $ N \\times N $$ N \\leq 2000000 $ $ S $\n\n $ \\leq 160000 $ $ \\leq 10000 $\n\n<!-- more -->\n\n### \n[BZOJ 1176](http://www.lydsy.com/JudgeOnline/problem.php?id=1176)\n\n### \n $ Q(x1,\\ y1,\\ x2,\\ y2) $  $ [x1,\\ y1] $  $ [x2,\\ y2] $ \n\n$$\n\\begin{aligned}\nQ(x1,\\ y1,\\ x2,\\ y2) = &  Q(0,\\ 0,\\ x2,\\ y2) \\\\\n& - Q(0,\\ 0,\\ x1 - 1,\\ y2) - Q(0,\\ 0,\\ x2,\\ y1 - 1) \\\\\n& + Q(0,\\ 0,\\ x1,\\ y1)\n\\end{aligned}\n$$\n\n$ x $$ y $ $ x $  $ y $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2000000 + 1;\nconst int MAXQ = 10000;\nconst int MAXM = 160000 + MAXQ * 4;\n\nstruct Triple {\n\tint id, x, y, d, delta, *ans;\n\n\tTriple() {}\n\tTriple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); }\n\tTriple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); }\n\n\tvoid setID() {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tbool isQuery() const { return d != 0; }\n} a[MAXM];\n\nint s, n, m, cnt, ans[MAXQ];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXM];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->x <= p2->x && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tif (!p->isQuery()) bit.update(p->y, p->delta);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tif (p->isQuery()) *p->ans += bit.query(p->y) * p->d;\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tif (q <= mid && !q->isQuery()) bit.clear(q->y);\n\t\t*q = *p;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &s, &n), n++;\n\t\n\tint qcnt = 0;\n\twhile (true) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 3) break;\n\t\telse if (t == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1++, y1++, x2++, y2++;\n\n\t\t\tint *p = &ans[qcnt++];\n\t\t\t*p = (y2 - y1 + 1) * (x2 - x1 + 1) * s;\n\t\t\ta[cnt++] = Triple(x2, y2, 1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y2, -1, p);\n\t\t\ta[cnt++] = Triple(x2, y1 - 1, -1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, 1, p);\n\t\t} else if (t == 1) {\n\t\t\tint x, y, delta;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &delta), x++, y++;\n\t\t\ta[cnt++] = Triple(x, y, delta);\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < cnt; i++) {\n\t\tprintf(\"Triple(x = %d, y = %d, d = %d, delta = %d)\\n\", a[i].x, a[i].y, a[i].d, a[i].delta);\n\t}\n\t*/\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qcnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1176","published":1,"updated":"2016-06-20T14:11:06.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj5n01ii0jxlouqferis"},{"title":"HNOI2008 - ","date":"2016-04-06T13:04:45.000Z","_content":"\n $ 1  N $  $ N $ M\n\n<!-- more -->\n\n### \n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### \n\n\n $ N $  $ M $  $ M ^ N $\n\n $ M $  $ M - 1 $  $ M * (M - 1) ^ {N - 1} $\n\n $ M ^ N - M * (M - 1) ^ {N - 1} $\n\n### \n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1008.md","raw":"title: HNOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - \npermalink: bzoj-1008\ndate: 2016-04-06 21:04:45\n---\n\n $ 1  N $  $ N $ M\n\n<!-- more -->\n\n### \n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### \n\n\n $ N $  $ M $  $ M ^ N $\n\n $ M $  $ M - 1 $  $ M * (M - 1) ^ {N - 1} $\n\n $ M ^ N - M * (M - 1) ^ {N - 1} $\n\n### \n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1008","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj5v01ip0jxlz1c34o0f"},{"title":"BeiJing2006 - ","date":"2016-04-03T14:46:25.000Z","_content":"\n $ (1, 1) $ $ (N, M) $\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n $ (1, 1) $  $ (N, M) $  $ K $ $ K $ .\n\n<!-- more -->\n\n### \n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### \nDinic  \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1001.md","raw":"title: BeiJing2006 - \ncategories: OI\ntags: \n  - BZOJ\n  - Dinic\n  - \n  - \npermalink: bzoj-1001\ndate: 2016-04-03 22:46:25\n---\n\n $ (1, 1) $ $ (N, M) $\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n $ (1, 1) $  $ (N, M) $  $ K $ $ K $ .\n\n<!-- more -->\n\n### \n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### \nDinic  \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-1001","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj6301iv0jxl7r3j2apw"},{"title":" BSGS","date":"2016-06-13T03:52:00.000Z","_content":"\n $ a $$ b $$ p $  $ x $\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ x $  $ b $  $ p $  $ a $ ****\n\n<!-- more -->\n\n### \n\n\n$$\n\\begin{aligned}\n\\log_g x + \\log_g y &\\equiv \\log_g xy \\pmod p \\\\\n\\log_g x ^ y &\\equiv y \\log_g x \\pmod p\n\\end{aligned}\n$$\n\n### BSGS\n BSGSBaby-Step Giant-Step\n\n$ p $ \n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ m = \\lceil \\sqrt p \\rceil $  \n $ a ^ {p - 1} \\equiv 1 \\pmod p $ $ 0 \\leq x < p - 1 $\n\n $ x = im + j $ $ 0 \\leq i,\\ j \\leq m $\n\n\n\n$$\n\\begin{align*}\na ^ {x} &\\equiv b \\pmod p \\\\\na ^ {im + j} &\\equiv b \\pmod p \\\\\na ^ {j} &\\equiv b \\times a ^ {-im} \\pmod p \\\\\na ^ {j} &\\equiv b \\times (a ^ {-m}) ^ i \\pmod p\n\\end{align*}\n$$\n\n $ i $$ j $ \n\n $ j $ $ a ^ j \\bmod p $  $ (a ^ j \\bmod p) \\mapsto j $ \n\n $ a ^ m \\bmod p $  $ a ^ {-m} \\bmod p $ $ i $ $ b \\times (a ^ {-m}) ^ i $ $ j $$ x = im + j $ \n\n $ O(\\sqrt p) $\n\n#### \n```c++\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tstd::tr1::unordered_map<T, T> map;\n\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT k = inv(t, p), w = b;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(w)) return i * m + map[w];\n\t\tw = w * k % p;\n\t}\n\n\treturn -1;\n}\n```\n\n### EXBSGS\n BSGS  $ p $  $ a $  $ \\gcd(a,\\ p) = 1 $ \n\n\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n\n\n$$ a ^ x = b + kp $$\n\n $ d = \\gcd(a,\\ p) $ $ d \\mid b $\n\n$$ a ^ {x - 1} \\frac{a}{d} = \\frac{b}{d} + k \\frac{p}{d} $$\n\n\n\n$$ a ^ {x - 1} \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod { \\frac{p}{d} } $$\n\n $ \\gcd(\\frac{a}{d},\\ \\frac{p}{d}) = 1 $ $ \\frac{a}{d} $ \n\n$$ a ^ {x - 1} \\equiv \\frac{b}{d} \\times (\\frac{a}{d}) ^ {-1} \\pmod { \\frac{p}{d} } $$\n\n $ d = 1 $  BSGS  $ d \\not \\mid b $  $ b = 1 $  $ 0 $ $ 1 $\n\n#### \n```c++\ntemplate <typename T>\ninline T exbsgs(const T a, const T b, const T p) {\n\tT _b = b, _p = p, t, c = 0;\n\twhile ((t = std::__gcd(a, _p)) != 1) {\n\t\tif (_b == 1) return c;\n\t\tif (_b % t != 0) return -1;\n\t\t_p /= t;\n\t\t_b = _b / t * inv(a / t, _p) % _p;\n\t\tc++;\n\t}\n\n\tT r = bsgs(a, _b, _p);\n\tif (r == -1) return -1;\n\telse return r + c;\n}\n```\n","source":"_posts/bsgs-notes.md","raw":"title:  BSGS\ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - BSGS\npermalink: bsgs-notes\ndate: 2016-06-13 11:52:00\n---\n\n $ a $$ b $$ p $  $ x $\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ x $  $ b $  $ p $  $ a $ ****\n\n<!-- more -->\n\n### \n\n\n$$\n\\begin{aligned}\n\\log_g x + \\log_g y &\\equiv \\log_g xy \\pmod p \\\\\n\\log_g x ^ y &\\equiv y \\log_g x \\pmod p\n\\end{aligned}\n$$\n\n### BSGS\n BSGSBaby-Step Giant-Step\n\n$ p $ \n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ m = \\lceil \\sqrt p \\rceil $  \n $ a ^ {p - 1} \\equiv 1 \\pmod p $ $ 0 \\leq x < p - 1 $\n\n $ x = im + j $ $ 0 \\leq i,\\ j \\leq m $\n\n\n\n$$\n\\begin{align*}\na ^ {x} &\\equiv b \\pmod p \\\\\na ^ {im + j} &\\equiv b \\pmod p \\\\\na ^ {j} &\\equiv b \\times a ^ {-im} \\pmod p \\\\\na ^ {j} &\\equiv b \\times (a ^ {-m}) ^ i \\pmod p\n\\end{align*}\n$$\n\n $ i $$ j $ \n\n $ j $ $ a ^ j \\bmod p $  $ (a ^ j \\bmod p) \\mapsto j $ \n\n $ a ^ m \\bmod p $  $ a ^ {-m} \\bmod p $ $ i $ $ b \\times (a ^ {-m}) ^ i $ $ j $$ x = im + j $ \n\n $ O(\\sqrt p) $\n\n#### \n```c++\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tstd::tr1::unordered_map<T, T> map;\n\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT k = inv(t, p), w = b;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(w)) return i * m + map[w];\n\t\tw = w * k % p;\n\t}\n\n\treturn -1;\n}\n```\n\n### EXBSGS\n BSGS  $ p $  $ a $  $ \\gcd(a,\\ p) = 1 $ \n\n\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n\n\n$$ a ^ x = b + kp $$\n\n $ d = \\gcd(a,\\ p) $ $ d \\mid b $\n\n$$ a ^ {x - 1} \\frac{a}{d} = \\frac{b}{d} + k \\frac{p}{d} $$\n\n\n\n$$ a ^ {x - 1} \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod { \\frac{p}{d} } $$\n\n $ \\gcd(\\frac{a}{d},\\ \\frac{p}{d}) = 1 $ $ \\frac{a}{d} $ \n\n$$ a ^ {x - 1} \\equiv \\frac{b}{d} \\times (\\frac{a}{d}) ^ {-1} \\pmod { \\frac{p}{d} } $$\n\n $ d = 1 $  BSGS  $ d \\not \\mid b $  $ b = 1 $  $ 0 $ $ 1 $\n\n#### \n```c++\ntemplate <typename T>\ninline T exbsgs(const T a, const T b, const T p) {\n\tT _b = b, _p = p, t, c = 0;\n\twhile ((t = std::__gcd(a, _p)) != 1) {\n\t\tif (_b == 1) return c;\n\t\tif (_b % t != 0) return -1;\n\t\t_p /= t;\n\t\t_b = _b / t * inv(a / t, _p) % _p;\n\t\tc++;\n\t}\n\n\tT r = bsgs(a, _b, _p);\n\tif (r == -1) return -1;\n\telse return r + c;\n}\n```\n","slug":"bsgs-notes","published":1,"updated":"2016-09-10T05:55:06.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj6a01j10jxlxlsrqqz1"},{"title":"","date":"2016-03-14T13:34:42.000Z","_content":"\n \n \n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","source":"_posts/bigint-template.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \npermalink: bigint-template\ndate: 2016-03-14 21:34:42\n---\n\n \n \n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","slug":"bigint-template","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj6j01j90jxlv5jxgrxs"},{"title":"   NOI2016 ","date":"2016-08-30T18:42:00.000Z","_content":"\n<div style=\"width: 100%; text-align: center; \">\n<div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div>\n</div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: 'KOKIA',\n        url: 'https://dn-menci.qbox.me/music/mzr.ogg',\n        pic: 'https://dn-menci.qbox.me/music/mzr.jpg',\n        lrc: '/at-the-cross-of-time/mzr.lrc'\n    }\n});\n</script>\n\n OIer NOI \n\n<!-- more -->\n\nNOI   \n\n\n\n OIer     \n\n  \n    \n\n  \n\n\n    \n\n\n\n\n\n****\n\n OIer \n\n\n\n\n\n OI \n","source":"_posts/at-the-cross-of-time.md","raw":"title:    NOI2016 \ncategories: \n  - Diary\npermalink: at-the-cross-of-time\ndate: 2016-08-31 02:42:00\n---\n\n<div style=\"width: 100%; text-align: center; \">\n<div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div>\n</div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: 'KOKIA',\n        url: 'https://dn-menci.qbox.me/music/mzr.ogg',\n        pic: 'https://dn-menci.qbox.me/music/mzr.jpg',\n        lrc: '/at-the-cross-of-time/mzr.lrc'\n    }\n});\n</script>\n\n OIer NOI \n\n<!-- more -->\n\nNOI   \n\n\n\n OIer     \n\n  \n    \n\n  \n\n\n    \n\n\n\n\n\n****\n\n OIer \n\n\n\n\n\n OI \n","slug":"at-the-cross-of-time","published":1,"updated":"2016-11-20T15:48:58.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj6p01jd0jxlq9ejtz16"},{"title":"APIO2010 -  DP","date":"2016-05-13T12:16:00.000Z","_content":"\n $ n $  $ 1 $  $ n $ \n\n $ i $  $ x_i $  $ x $  $ x' = Ax ^ 2 + Bx + C $ $ A $$ B $$ C $ $ A < 0 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### \n $ f[i] $  $ i $ $ s_i $ \n\n $ j $ $ j + 1 $  $ i $ \n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n $ O(n ^ 2) $\n\n $ j = a $$ j = b $$ a > b $ $ a $  $ b $ \n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n\n\n $ 2 A s_i $\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","source":"_posts/apio2010-commando.md","raw":"title: APIO2010 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - DP\n  - \n  - \npermalink: apio2010-commando\ndate: 2016-05-13 20:16:00\n---\n\n $ n $  $ 1 $  $ n $ \n\n $ i $  $ x_i $  $ x $  $ x' = Ax ^ 2 + Bx + C $ $ A $$ B $$ C $ $ A < 0 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### \n $ f[i] $  $ i $ $ s_i $ \n\n $ j $ $ j + 1 $  $ i $ \n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n $ O(n ^ 2) $\n\n $ j = a $$ j = b $$ a > b $ $ a $  $ b $ \n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n\n\n $ 2 A s_i $\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","slug":"apio2010-commando","published":1,"updated":"2016-10-24T23:33:06.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj6u01jf0jxlwgane189"},{"title":"APIO2009 - ","date":"2016-03-10T11:57:45.000Z","_content":"\n ATM  ATM \n\n ATM  ATM  ATM \n\n<!-- more -->\n\n### \n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### \nTarjan  DAG DAG \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### \n Dijkstra   Dijkstra \n\n()  Dijkstra\n\n('-')  Bellman-Ford  WA  \n\n \n\n OvO \n\n### \n _\n\n|             | |  | |\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","source":"_posts/apio2009-atm.md","raw":"title: APIO2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - \n  - Tarjan\n  - \n  - DAG\n  - \n  - Bellman-Ford\npermalink: apio2009-atm\ndate: 2016-03-10 19:57:45\n---\n\n ATM  ATM \n\n ATM  ATM  ATM \n\n<!-- more -->\n\n### \n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### \nTarjan  DAG DAG \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### \n Dijkstra   Dijkstra \n\n()  Dijkstra\n\n('-')  Bellman-Ford  WA  \n\n \n\n OvO \n\n### \n _\n\n|             | |  | |\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","slug":"apio2009-atm","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj7301jn0jxlwoxv1dlw"},{"title":"AHOI2014 - ","date":"2016-04-08T09:57:21.000Z","_content":"\n $ N $  $ 1 $  $ N $  $ i $  $ K_i $  $ 0 $ $ i $ \n\n $ 1 $  $ 1 $  $ 1 $ \n\n<!-- more -->\n\n### \n DAG 1  1  DAG \n\n\n\n $ (u, v, w) $ $ (u, v, [1, \\infty], w) $  $ 1 $  $ u $ $ (u, 1, \\infty, 0) $  $ 1 $ \n\n $ (u, v, w) $ $ (S, v, 1, w) $ $ (u, T, 1, 0) $  $ v $ \n\n$ (u, T, 1, 0) $  $ (u, T, k_i, 0) $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2014-story.md","raw":"title: AHOI2014 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \n  - Edmonds-Karp\npermalink: ahoi2014-story\ndate: 2016-04-08 17:57:21\n---\n\n $ N $  $ 1 $  $ N $  $ i $  $ K_i $  $ 0 $ $ i $ \n\n $ 1 $  $ 1 $  $ 1 $ \n\n<!-- more -->\n\n### \n DAG 1  1  DAG \n\n\n\n $ (u, v, w) $ $ (u, v, [1, \\infty], w) $  $ 1 $  $ u $ $ (u, 1, \\infty, 0) $  $ 1 $ \n\n $ (u, v, w) $ $ (S, v, 1, w) $ $ (u, T, 1, 0) $  $ v $ \n\n$ (u, T, 1, 0) $  $ (u, T, k_i, 0) $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"ahoi2014-story","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj7h01k00jxlxqzdujm3"},{"title":"AHOI2013 - ","date":"2016-09-29T13:07:00.000Z","_content":"\n $ n $  $ T_i $  $ i $ \n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) - 2 \\times \\mathrm{lcp}(T_i, T_j) $$\n\n<!-- more -->\n\n### \n[BZOJ 3238](http://www.lydsy.com/JudgeOnline/problem.php?id=3238)\n\n### \n\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) = \\sum\\limits_{i = 2} ^ n \\frac{i(i - 1)}{2} + i(i - 1) $$\n\n\n\n$$ -2 \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{lcp}(T_i, T_j) $$\n\n LCP \n\n $ \\mathrm{height}[] $  $ a_i $ \n\n $ a_i $ ********$ a_i $ \n\n $ a_i $  $ l_i $  $ a_i $  $ r_i $  $ a_i $ \n\n$$ (l_i + 1) \\times (r_i + 1) \\times a_i $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 500000;\n\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\nunsigned long long l[MAXN], r[MAXN];\nchar s[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", &s[sa[i]]);\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n}\n\n/*\ninline int lcp(const int i, const int j) {\n\t/ *\n\tint a = rk[i], b = rk[j], ans = n;\n\tif (a > b) std::swap(a, b);\n\tfor (int i = a + 1; i <= b; i++) ans = std::min(ans, ht[i]);\n\t// printf(\"- %d %d => %d\\n\", a + 1, b, ans);\n\treturn ans;\n\t* /\n\n\tint ans = 0;\n\twhile (s[i + ans] == s[j + ans] && i + ans < n && j + ans < n) ans++;\n\treturn ans;\n}\n*/\n\ninline void prepare() {\n\tstd::stack<int> s;\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (!s.empty() && ht[s.top()] > ht[i]) s.pop();\n\t\tl[i] = s.empty() ? i - 1 : i - s.top() - 1;\n\t\ts.push(i);\n\t}\n\twhile (!s.empty()) s.pop();\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\twhile (!s.empty() && ht[s.top()] >= ht[i]) s.pop();\n\t\tr[i] = s.empty() ? n - i - 1 : s.top() - i - 1;\n\t\ts.push(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsuffixArray();\n\n\tunsigned long long sumLcp = 0;\n\t/*\n\tfor (int i = 1; i < n; i++) for (int j = i; j < n; j++) {\n\t\tint min = n;\n\t\tfor (int k = i; k <= j; k++) min = std::min(min, ht[k]);\n\t\tsumLcp += min;\n\t}\n\t*/\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tsumLcp += lcp(i, j);\n\t\t}\n\t}\n\t*/\n\n\tprepare();\n\t// /*\n\tfor (int i = 1; i < n; i++) {\n\t\t// printf(\"%d: %d %d\\n\", i, l[i], r[i]);\n\t\tsumLcp += static_cast<unsigned long long>(l[i] + 2) * (r[i] + 1) * ht[i];\n\t}\n\t// */\n\n\tunsigned long long sum = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tunsigned long long t = static_cast<unsigned long long>(1 + (i - 1)) * (i - 1) / 2 + static_cast<unsigned long long>(i) * (i - 1);\n\t\t// printf(\"- %lld\\n\", t);\n\t\tsum += t;\n\t\t// printf(\"sum = %llu\\n\", sum);\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t// printf(\"- %d %d\\n\", n - i, n - j);\n\t\t\tsum += n - i + n - j;\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%llu\\n\", sum - 2 * sumLcp);\n\n\treturn 0;\n}\n```","source":"_posts/ahoi2013-diff.md","raw":"title: AHOI2013 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \npermalink: ahoi2013-diff\ndate: 2016-09-29 21:07:00\n---\n\n $ n $  $ T_i $  $ i $ \n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) - 2 \\times \\mathrm{lcp}(T_i, T_j) $$\n\n<!-- more -->\n\n### \n[BZOJ 3238](http://www.lydsy.com/JudgeOnline/problem.php?id=3238)\n\n### \n\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) = \\sum\\limits_{i = 2} ^ n \\frac{i(i - 1)}{2} + i(i - 1) $$\n\n\n\n$$ -2 \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{lcp}(T_i, T_j) $$\n\n LCP \n\n $ \\mathrm{height}[] $  $ a_i $ \n\n $ a_i $ ********$ a_i $ \n\n $ a_i $  $ l_i $  $ a_i $  $ r_i $  $ a_i $ \n\n$$ (l_i + 1) \\times (r_i + 1) \\times a_i $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 500000;\n\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\nunsigned long long l[MAXN], r[MAXN];\nchar s[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", &s[sa[i]]);\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n}\n\n/*\ninline int lcp(const int i, const int j) {\n\t/ *\n\tint a = rk[i], b = rk[j], ans = n;\n\tif (a > b) std::swap(a, b);\n\tfor (int i = a + 1; i <= b; i++) ans = std::min(ans, ht[i]);\n\t// printf(\"- %d %d => %d\\n\", a + 1, b, ans);\n\treturn ans;\n\t* /\n\n\tint ans = 0;\n\twhile (s[i + ans] == s[j + ans] && i + ans < n && j + ans < n) ans++;\n\treturn ans;\n}\n*/\n\ninline void prepare() {\n\tstd::stack<int> s;\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (!s.empty() && ht[s.top()] > ht[i]) s.pop();\n\t\tl[i] = s.empty() ? i - 1 : i - s.top() - 1;\n\t\ts.push(i);\n\t}\n\twhile (!s.empty()) s.pop();\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\twhile (!s.empty() && ht[s.top()] >= ht[i]) s.pop();\n\t\tr[i] = s.empty() ? n - i - 1 : s.top() - i - 1;\n\t\ts.push(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsuffixArray();\n\n\tunsigned long long sumLcp = 0;\n\t/*\n\tfor (int i = 1; i < n; i++) for (int j = i; j < n; j++) {\n\t\tint min = n;\n\t\tfor (int k = i; k <= j; k++) min = std::min(min, ht[k]);\n\t\tsumLcp += min;\n\t}\n\t*/\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tsumLcp += lcp(i, j);\n\t\t}\n\t}\n\t*/\n\n\tprepare();\n\t// /*\n\tfor (int i = 1; i < n; i++) {\n\t\t// printf(\"%d: %d %d\\n\", i, l[i], r[i]);\n\t\tsumLcp += static_cast<unsigned long long>(l[i] + 2) * (r[i] + 1) * ht[i];\n\t}\n\t// */\n\n\tunsigned long long sum = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tunsigned long long t = static_cast<unsigned long long>(1 + (i - 1)) * (i - 1) / 2 + static_cast<unsigned long long>(i) * (i - 1);\n\t\t// printf(\"- %lld\\n\", t);\n\t\tsum += t;\n\t\t// printf(\"sum = %llu\\n\", sum);\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t// printf(\"- %d %d\\n\", n - i, n - j);\n\t\t\tsum += n - i + n - j;\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%llu\\n\", sum - 2 * sumLcp);\n\n\treturn 0;\n}\n```","slug":"ahoi2013-diff","published":1,"updated":"2016-09-29T13:25:07.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj7r01k90jxl3gt6aevw"},{"title":"AHOI2008 - ","date":"2016-03-07T12:36:46.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### \n LCA \n\n LCA  LCA   qwq\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2008-meet.md","raw":"title: AHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \npermalink: ahoi2008-meet\ndate: 2016-03-07 20:36:46\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### \n LCA \n\n LCA  LCA   qwq\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"ahoi2008-meet","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj8001kh0jxl4fgotskf"},{"title":"AC ","date":"2016-09-18T23:04:00.000Z","_content":"\nAC \n\n<!-- more -->\n\n### \n>  Trie  Trie \n\n Trie  KMP  $ O(n) $ \n\n### \n KMP  $ i $  $ j $ $ \\mathrm{fail}(i) = j $\n\n $ \\mathrm{fail}(i) = j $    $ j $  $ i $ ****\n\n Trie  $ j $ $ j $  $ i $ ****\n\n### \n![AC ](/home/Menci/Hexo/source/_posts/acam-notes/acam.svg?3)\n\n $ i $  $ i' $$ i $  $ c $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(i) $  \n $ \\mathrm{fail}(7) = 1, \\mathrm{fail}(8) = 2 $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(\\mathrm{fail}(i')) $   $ \\mathrm{fail}(i) $   \n $ \\mathrm{fail}(3) = 0 $\n\n### \n $ i $ $ c $ $ i $  $ c $ $ \\mathrm{fail}(i) $  $ c $ \n\n $ i $ $ \\mathrm{fail}(i) $ \n\n`a`  `bac`  AC \n![AC ](/home/Menci/Hexo/source/_posts/acam-notes/acam2.svg)\n\n 3  1 `ba`  3 1   $ \\mathrm{next}(i) $  $ i $  $ \\mathrm{next}(3) = 1 $\n\n\n\n   $ \\mathrm{fail}(i) $  $ \\mathrm{next}(i) = \\mathrm{fail}(i) $ $ \\mathrm{next}(i) = \\mathrm{next}(\\mathrm{fail}(i)) $\n\n### \n\n\n****\n\n $ i $ $ c $  $ c $  $ \\mathrm{fail}(i) $  Trie **Trie **\n\n### \n\n\n```c++\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst char BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n                    c = v->fail->c[i] ? v->fail->c[i] : root;\n                    continue;\n                }\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n};\n```","source":"_posts/acam-notes.md","raw":"title: AC \ncategories: OI\ntags: \n  - AC \n  - \n  - \n  - \npermalink: acam-notes\ndate: 2016-09-19 07:04:00\n---\n\nAC \n\n<!-- more -->\n\n### \n>  Trie  Trie \n\n Trie  KMP  $ O(n) $ \n\n### \n KMP  $ i $  $ j $ $ \\mathrm{fail}(i) = j $\n\n $ \\mathrm{fail}(i) = j $    $ j $  $ i $ ****\n\n Trie  $ j $ $ j $  $ i $ ****\n\n### \n![AC ](/home/Menci/Hexo/source/_posts/acam-notes/acam.svg?3)\n\n $ i $  $ i' $$ i $  $ c $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(i) $  \n $ \\mathrm{fail}(7) = 1, \\mathrm{fail}(8) = 2 $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(\\mathrm{fail}(i')) $   $ \\mathrm{fail}(i) $   \n $ \\mathrm{fail}(3) = 0 $\n\n### \n $ i $ $ c $ $ i $  $ c $ $ \\mathrm{fail}(i) $  $ c $ \n\n $ i $ $ \\mathrm{fail}(i) $ \n\n`a`  `bac`  AC \n![AC ](/home/Menci/Hexo/source/_posts/acam-notes/acam2.svg)\n\n 3  1 `ba`  3 1   $ \\mathrm{next}(i) $  $ i $  $ \\mathrm{next}(3) = 1 $\n\n\n\n   $ \\mathrm{fail}(i) $  $ \\mathrm{next}(i) = \\mathrm{fail}(i) $ $ \\mathrm{next}(i) = \\mathrm{next}(\\mathrm{fail}(i)) $\n\n### \n\n\n****\n\n $ i $ $ c $  $ c $  $ \\mathrm{fail}(i) $  Trie **Trie **\n\n### \n\n\n```c++\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst char BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n                    c = v->fail->c[i] ? v->fail->c[i] : root;\n                    continue;\n                }\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n};\n```","slug":"acam-notes","published":1,"updated":"2016-09-19T07:20:40.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj8801ko0jxl1j28j47t"},{"title":" 2016Play with array - ","date":"2016-05-27T15:55:00.000Z","_content":"\n $ n $ \n\n1.  $ a_r $  $ a_l $ \n2.  $ [l,\\ r] $  $ k $ \n\n<!-- more -->\n\n### \n $ O(\\sqrt n) $ \n\n $ [l,\\ r] $  $ [1,\\ r] $  $ [1,\\ l - 1] $ \n\n $ O(n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\n#define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__)\n\nconst int MAXN = 100000;\nconst int MAXN_SQRT = 316 + 1;\nconst int MAXM = 100000;\n\nint n, m, a[MAXN];\n\nstruct BlockList {\n\tstruct Block {\n\t\tstd::list<int> l;\n\t\tstd::vector<int> sum;\n\n\t\tBlock() : sum(n) {}\n\n\t\tinline int left(const int k, const int pos) {\n\t\t\tint res = 0;\n\t\t\tstd::list<int>::const_iterator it = l.begin();\n\t\t\tfor (int i = 0; i <= pos; i++) if (*it++ == k) res++;\n\t\t\treturn res;\n\t\t}\n\t};\n\tstd::list<Block> blocks;\n\tint blockCount, blockSize;\n\n\tinline void build(const int *a, const int n) {\n\t\tblockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast<double>(n) / blockCount);\n\t\t// dprintf(\"BlockList::build(): blockCount = %d, blockSize = %d\\n\", blockCount, blockSize);\n\t\tblocks.resize(blockCount);\n\t\tstd::list<Block>::iterator b = blocks.begin();\n\t\tfor (int i = 0, j = 0; i < blockCount; i++, b++) {\n\t\t\tfor (int k = 0; k <= blockSize && j < n; k++, j++) {\n\t\t\t\tb->sum[a[j]]++;\n\t\t\t\tb->l.push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int erase(int pos) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tconst int x = *it;\n\t\t\t\tb->sum[*it]--;\n\t\t\t\tb->l.erase(it);\n\t\t\t\treturn x;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline void insert(int pos, const int x) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tb->sum[x]++;\n\t\t\t\tb->l.insert(it, x);\n\t\t\t\treturn;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline int query(int pos, const int k) {\n\t\tint ans = 0;\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tans += b->left(k, pos);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpos -= b->l.size();\n\t\t\t\tans += b->sum[k];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline void mergeNext(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator next = b;\n\t\tnext++;\n\t\tif (next == blocks.end()) return;\n\t\tfor (std::list<int>::const_iterator it = next->l.begin(); it != next->l.end(); it++) {\n\t\t\tb->l.push_back(*it);\n\t\t\tb->sum[*it]++;\n\t\t}\n\t\tblocks.erase(next);\n\t}\n\n\tinline void split(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator newBlock = blocks.insert(b, Block());\n\t\tfor (int i = 0; i < b->l.size() / 2; i++) {\n\t\t\tconst int &x = b->l.front();\n\t\t\tnewBlock->l.push_back(x);\n\t\t\tnewBlock->sum[x]++;\n\t\t\tb->sum[x]--;\n\t\t\tb->l.pop_front();\n\t\t}\n\t}\n\n\tinline void maintain() {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (b->l.size() <= blockSize / 2) mergeNext(b);\n\t\t\telse if (b->l.size() >= blockSize * 2) split(b);\n\t\t}\n\t}\n\n\tinline void print() {\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tdprintf(\"blockSize = %d\\n\", b->l.size());\n\t\t}\n\n\t\treturn;\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tfor (std::list<int>::const_iterator it = b->l.begin(); it != b->l.end(); it++) {\n\t\t\t\tdprintf(\"%d \", *it + 1);\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%c\", '\\n');\n\t}\n} list;\n\nint main() {\n\t// freopen(\"array.in\", \"r\", stdin);\n\t// freopen(\"array.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]), a[i]--;\n\t}\n\n\tlist.build(a, n);\n\n\t// list.print();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r), l--, r--;\n\t\tif (t == 1) {\n\t\t\tint x = list.erase(r);\n\t\t\tlist.insert(l, x);\n\t\t\t// list.print();\n\t\t\tlist.maintain();\n\t\t\t// list.print();\n\t\t\t// dprintf(\"%c\", '\\n');\n\t\t} else {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k), k--;\n\t\t\tint R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k);\n\t\t\tprintf(\"%d\\n\", R - L);\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\t// list.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/20160527-array.md","raw":"title:  2016Play with array - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: 20160527-array\ndate: 2016-05-27 23:55:00\n---\n\n $ n $ \n\n1.  $ a_r $  $ a_l $ \n2.  $ [l,\\ r] $  $ k $ \n\n<!-- more -->\n\n### \n $ O(\\sqrt n) $ \n\n $ [l,\\ r] $  $ [1,\\ r] $  $ [1,\\ l - 1] $ \n\n $ O(n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\n#define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__)\n\nconst int MAXN = 100000;\nconst int MAXN_SQRT = 316 + 1;\nconst int MAXM = 100000;\n\nint n, m, a[MAXN];\n\nstruct BlockList {\n\tstruct Block {\n\t\tstd::list<int> l;\n\t\tstd::vector<int> sum;\n\n\t\tBlock() : sum(n) {}\n\n\t\tinline int left(const int k, const int pos) {\n\t\t\tint res = 0;\n\t\t\tstd::list<int>::const_iterator it = l.begin();\n\t\t\tfor (int i = 0; i <= pos; i++) if (*it++ == k) res++;\n\t\t\treturn res;\n\t\t}\n\t};\n\tstd::list<Block> blocks;\n\tint blockCount, blockSize;\n\n\tinline void build(const int *a, const int n) {\n\t\tblockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast<double>(n) / blockCount);\n\t\t// dprintf(\"BlockList::build(): blockCount = %d, blockSize = %d\\n\", blockCount, blockSize);\n\t\tblocks.resize(blockCount);\n\t\tstd::list<Block>::iterator b = blocks.begin();\n\t\tfor (int i = 0, j = 0; i < blockCount; i++, b++) {\n\t\t\tfor (int k = 0; k <= blockSize && j < n; k++, j++) {\n\t\t\t\tb->sum[a[j]]++;\n\t\t\t\tb->l.push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int erase(int pos) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tconst int x = *it;\n\t\t\t\tb->sum[*it]--;\n\t\t\t\tb->l.erase(it);\n\t\t\t\treturn x;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline void insert(int pos, const int x) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tb->sum[x]++;\n\t\t\t\tb->l.insert(it, x);\n\t\t\t\treturn;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline int query(int pos, const int k) {\n\t\tint ans = 0;\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tans += b->left(k, pos);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpos -= b->l.size();\n\t\t\t\tans += b->sum[k];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline void mergeNext(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator next = b;\n\t\tnext++;\n\t\tif (next == blocks.end()) return;\n\t\tfor (std::list<int>::const_iterator it = next->l.begin(); it != next->l.end(); it++) {\n\t\t\tb->l.push_back(*it);\n\t\t\tb->sum[*it]++;\n\t\t}\n\t\tblocks.erase(next);\n\t}\n\n\tinline void split(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator newBlock = blocks.insert(b, Block());\n\t\tfor (int i = 0; i < b->l.size() / 2; i++) {\n\t\t\tconst int &x = b->l.front();\n\t\t\tnewBlock->l.push_back(x);\n\t\t\tnewBlock->sum[x]++;\n\t\t\tb->sum[x]--;\n\t\t\tb->l.pop_front();\n\t\t}\n\t}\n\n\tinline void maintain() {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (b->l.size() <= blockSize / 2) mergeNext(b);\n\t\t\telse if (b->l.size() >= blockSize * 2) split(b);\n\t\t}\n\t}\n\n\tinline void print() {\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tdprintf(\"blockSize = %d\\n\", b->l.size());\n\t\t}\n\n\t\treturn;\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tfor (std::list<int>::const_iterator it = b->l.begin(); it != b->l.end(); it++) {\n\t\t\t\tdprintf(\"%d \", *it + 1);\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%c\", '\\n');\n\t}\n} list;\n\nint main() {\n\t// freopen(\"array.in\", \"r\", stdin);\n\t// freopen(\"array.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]), a[i]--;\n\t}\n\n\tlist.build(a, n);\n\n\t// list.print();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r), l--, r--;\n\t\tif (t == 1) {\n\t\t\tint x = list.erase(r);\n\t\t\tlist.insert(l, x);\n\t\t\t// list.print();\n\t\t\tlist.maintain();\n\t\t\t// list.print();\n\t\t\t// dprintf(\"%c\", '\\n');\n\t\t} else {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k), k--;\n\t\t\tint R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k);\n\t\t\tprintf(\"%d\\n\", R - L);\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\t// list.print();\n\n\treturn 0;\n}\n```\n","slug":"20160527-array","published":1,"updated":"2016-05-27T16:14:44.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj8j01ku0jxlp060q84c"},{"title":" - ","date":"2016-04-04T02:35:52.000Z","_content":"\n $ 1 \\to n $\n\n<!-- more -->\n\n### \n\n\n\n\n### 40 + DP\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160404-theory.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  -  DP\n  - \n  - \n  - Dinic\n  - \npermalink: 20160404-theory\ndate: 2016-04-04 10:35:52\n---\n\n $ 1 \\to n $\n\n<!-- more -->\n\n### \n\n\n\n\n### 40 + DP\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160404-theory","published":1,"updated":"2016-10-24T23:32:53.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj8s01l20jxlvvarnld5"},{"title":" - DP","date":"2016-04-01T13:24:45.000Z","_content":"\n $ N $  $ M $  $ K $  $ M $ \n\n<!-- more -->\n\n### \n $ f_{i, j} $  i  j \n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n $ 10 ^ 5 $  $ (N, K) $  $ f_K $  $ N $ \n\n $ K = 1, 2, 3 $ \n\n $ K = 1 $  $ N $  \n $ K = 2 $  $ x $\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n $ K = 3 $  1 ~ 3  $ f $  $ 2 \\times 10 ^ 6 $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/20160331-naive.md","raw":"title:  - DP\ncategories: OI\ntags: \n  - \n  - DP\n  - \npermalink: 20160331-naive\ndate: 2016-04-01 21:24:45\n---\n\n $ N $  $ M $  $ K $  $ M $ \n\n<!-- more -->\n\n### \n $ f_{i, j} $  i  j \n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n $ 10 ^ 5 $  $ (N, K) $  $ f_K $  $ N $ \n\n $ K = 1, 2, 3 $ \n\n $ K = 1 $  $ N $  \n $ K = 2 $  $ x $\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n $ K = 3 $  1 ~ 3  $ f $  $ 2 \\times 10 ^ 6 $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"20160331-naive","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj9501lb0jxlyjaha09p"},{"title":" - ","date":"2016-03-20T14:50:45.000Z","_content":"\n $ n $  $ S $ $ a + b $$ a $$ b $  $ S $ $ k $  $ S $ \n\n<!-- more -->\n\n### \n$ m1 $ $ m2 $ $ s $ \n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-set.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: 20160319-set\ndate: 2016-03-20 22:50:45\n---\n\n $ n $  $ S $ $ a + b $$ a $$ b $  $ S $ $ k $  $ S $ \n\n<!-- more -->\n\n### \n$ m1 $ $ m2 $ $ s $ \n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-set","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj9d01lh0jxlurhl3zas"},{"title":" -  + ","date":"2016-03-20T14:58:12.000Z","_content":"\n $ N $ \n\n<!-- more -->\n\n### \n\n\n\n\n\n\n\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-candy.md","raw":"title:  -  + \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: 20160319-candy\ndate: 2016-03-20 22:58:12\n---\n\n $ N $ \n\n<!-- more -->\n\n### \n\n\n\n\n\n\n\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-candy","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw63jj9k01ln0jxl610afd2a"}],"PostAsset":[{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","post":"ciw63jhqt002y0jxlpvxp6lah","slug":"hotkey.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/network.png","post":"ciw63jhqt002y0jxlpvxp6lah","slug":"network.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/port.png","post":"ciw63jhqt002y0jxlpvxp6lah","slug":"port.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","post":"ciw63jhqt002y0jxlpvxp6lah","slug":"screenfetch.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/share.png","post":"ciw63jhqt002y0jxlpvxp6lah","slug":"share.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","post":"ciw63jhqt002y0jxlpvxp6lah","slug":"terminal.png","modified":1},{"_id":"source/_posts/uva-11538/cells.png","post":"ciw63jhs6003v0jxlhah65gxj","slug":"cells.png","modified":1},{"_id":"source/_posts/splay-notes-1/splay.png","post":"ciw63jhuu008a0jxluy4x61qz","slug":"splay.png","modified":1},{"_id":"source/_posts/sdoi2016-game/line.png","post":"ciw63jhwj00be0jxlzu67kd1z","slug":"line.png","modified":1},{"_id":"source/_posts/sdoi2016-game/tree.png","post":"ciw63jhwj00be0jxlzu67kd1z","slug":"tree.png","modified":1},{"_id":"source/_posts/noip2016-running/linear-backward1.svg","post":"ciw63ji4v00jn0jxld7ik8eru","slug":"linear-backward1.svg","modified":1},{"_id":"source/_posts/noip2016-running/linear-forward1.svg","post":"ciw63ji4v00jn0jxld7ik8eru","slug":"linear-forward1.svg","modified":1},{"_id":"source/_posts/noip2016-running/linear-forward2.svg","post":"ciw63ji4v00jn0jxld7ik8eru","slug":"linear-forward2.svg","modified":1},{"_id":"source/_posts/node-devide-notes/tree1.svg","post":"ciw63jibs00rx0jxl9p8xsxbm","slug":"tree1.svg","modified":1},{"_id":"source/_posts/node-devide-notes/tree2.svg","post":"ciw63jibs00rx0jxl9p8xsxbm","slug":"tree2.svg","modified":1},{"_id":"source/_posts/lyoi-pingfan/pfzl.lrc","post":"ciw63jidi00t90jxl3iqz99wr","slug":"pfzl.lrc","modified":1},{"_id":"source/_posts/cut-tree-notes/cutTree.png","post":"ciw63jimo013v0jxlx7g6aw1h","slug":"cutTree.png","modified":1},{"_id":"source/_posts/cf-716e/example.svg","post":"ciw63jit201a50jxl7llyjv18","slug":"example.svg","modified":1},{"_id":"source/_posts/bzoj-2683/cdq.png","post":"ciw63jj0p01en0jxl4l3s7tlx","slug":"cdq.png","modified":1},{"_id":"source/_posts/at-the-cross-of-time/mzr.lrc","post":"ciw63jj6p01jd0jxlq9ejtz16","slug":"mzr.lrc","modified":1},{"_id":"source/_posts/acam-notes/acam.svg","post":"ciw63jj8801ko0jxl1j28j47t","slug":"acam.svg","modified":1},{"_id":"source/_posts/acam-notes/acam2.svg","post":"ciw63jj8801ko0jxl1j28j47t","slug":"acam2.svg","modified":1}],"PostCategory":[{"post_id":"ciw63jho800000jxl7vo5ctl0","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhoj00070jxloriytmp0"},{"post_id":"ciw63jhp1000g0jxl4ak61ggc","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhp3000h0jxlunn1f49n"},{"post_id":"ciw63jhp8000q0jxlpyetogzg","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhp9000r0jxlelo0k2j4"},{"post_id":"ciw63jhph00120jxlf8v4vtf6","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhpj00130jxl6pk82iw1"},{"post_id":"ciw63jhpo001a0jxlivjq2nyn","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhpp001b0jxlpu2ktli3"},{"post_id":"ciw63jhpv001g0jxlsw5fh7eh","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhpx001h0jxlmf99a0wz"},{"post_id":"ciw63jhq1001m0jxlba1hhfw0","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhq2001n0jxlep06b9a9"},{"post_id":"ciw63jhq7001x0jxl1ofxiq8g","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhq8001y0jxl3k2jd0ws"},{"post_id":"ciw63jhqc00270jxlzju38atf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhqe00280jxlspeoso6c"},{"post_id":"ciw63jhqi002i0jxlfvryob26","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhqk002j0jxlto9rbr8s"},{"post_id":"ciw63jhqn002q0jxlwblyl8l1","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhqo002r0jxljzo2wmsf"},{"post_id":"ciw63jhqt002y0jxlpvxp6lah","category_id":"ciw63jhqv002z0jxl3lcibvtr","_id":"ciw63jhqx00360jxl73fsij41"},{"post_id":"ciw63jhru003d0jxlspk5qhq1","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhrv003e0jxl2yvor0z7"},{"post_id":"ciw63jhrz003n0jxlw115yahf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhs1003o0jxl4pz1t9ig"},{"post_id":"ciw63jhs6003v0jxlhah65gxj","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhs8003w0jxlpjbsr5zi"},{"post_id":"ciw63jhsk00410jxl41s1ltan","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhsl00420jxl0ouyf23t"},{"post_id":"ciw63jhsn00490jxlfz88b4yy","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhsp004a0jxl499x9apc"},{"post_id":"ciw63jhsr004h0jxlv181n4al","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhss004i0jxlbrm921lg"},{"post_id":"ciw63jhsv004t0jxlhor559m8","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhsx004u0jxl7m8m7kqo"},{"post_id":"ciw63jht000510jxlofly25s2","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jht100520jxl9grgjenf"},{"post_id":"ciw63jht400590jxlt6p97yn7","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jht7005a0jxlfoks3367"},{"post_id":"ciw63jhtc005l0jxla7u7kf08","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhtd005m0jxlbcmcm4og"},{"post_id":"ciw63jhtg005u0jxl71xjxb76","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhth005v0jxlvsi5ef58"},{"post_id":"ciw63jhtj00620jxluowegsux","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhtm00630jxl4xc5tins"},{"post_id":"ciw63jhtq006a0jxlhucuqzzr","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhts006b0jxlmawgmugu"},{"post_id":"ciw63jhtv006k0jxln9wevpt5","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhtx006l0jxlhnndvp4b"},{"post_id":"ciw63jhu1006v0jxluod96ozu","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhu2006w0jxlc1y518fj"},{"post_id":"ciw63jhu700730jxlieacqas9","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhu700740jxl5sm9bd40"},{"post_id":"ciw63jhua007b0jxl75qjkacf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhub007c0jxlfg0qiwbp"},{"post_id":"ciw63jhud007k0jxljvfl81sy","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhue007l0jxls4eml1fz"},{"post_id":"ciw63jhug007q0jxle6nwr5o1","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhuh007r0jxlpoultirx"},{"post_id":"ciw63jhuk007w0jxl1g4zch8w","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhul007x0jxle3uvjj5w"},{"post_id":"ciw63jhuo00830jxlazg62izo","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhuq00840jxl0c9fakdp"},{"post_id":"ciw63jhuu008a0jxluy4x61qz","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhuw008b0jxlpduhtypo"},{"post_id":"ciw63jhv5008h0jxly9it3py0","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhv7008i0jxlsfuok4ro"},{"post_id":"ciw63jhva008n0jxlk725w5pb","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhvc008o0jxl0dz4i5k2"},{"post_id":"ciw63jhve008u0jxlin8rvina","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhvf008v0jxl2q7c4poq"},{"post_id":"ciw63jhvi008z0jxleh86b9be","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhvj00900jxl5tw5n9gb"},{"post_id":"ciw63jhvm00940jxli0hmhjcu","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhvo00950jxlw9404u2y"},{"post_id":"ciw63jhvr009c0jxl1nw5ofqt","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhvr009d0jxl0fdyrh2p"},{"post_id":"ciw63jhvt009j0jxl6h2c2f7x","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhvu009k0jxl17sfpmdy"},{"post_id":"ciw63jhvx009t0jxlw5x1kt86","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhvy009u0jxl0hkfkuj7"},{"post_id":"ciw63jhw200a50jxlsi0yt35o","category_id":"ciw63jhw300a60jxlabv54v9b","_id":"ciw63jhw300a70jxl8eqxfmns"},{"post_id":"ciw63jhw400a80jxlkkx4eymd","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhw500a90jxliuoekdy2"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhw900aj0jxlav53umuc"},{"post_id":"ciw63jhwd00ax0jxlvvusrna8","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhwe00ay0jxljc39dciq"},{"post_id":"ciw63jhwg00b50jxlrmn6lq89","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhwh00b60jxlsr6fgel9"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhwl00bf0jxlwvprk3rw"},{"post_id":"ciw63jhws00bp0jxlxm6c6ph5","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhwu00bq0jxlq7qp3pgz"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhwx00c00jxlgigzoot5"},{"post_id":"ciw63jhx700cd0jxlmwf8s7tz","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhx800ce0jxl2ye12gqo"},{"post_id":"ciw63jhxa00cj0jxlokn57yl1","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhxb00ck0jxlbrt1qrwh"},{"post_id":"ciw63jhxd00cu0jxl2mv4tj77","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhxf00cv0jxlvkmhfer4"},{"post_id":"ciw63jhxi00d40jxliobqdimd","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhxj00d50jxligbwwaf5"},{"post_id":"ciw63jhxm00dc0jxlgdx8kafy","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhxo00dd0jxldh0thsiv"},{"post_id":"ciw63jhxq00dh0jxlz0w3qc57","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhxx00di0jxlaqdal0yh"},{"post_id":"ciw63jhy300do0jxla3uosqkh","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhy400dp0jxl5j7mz0d7"},{"post_id":"ciw63jhy500du0jxldjgae5f4","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhy600dv0jxlcbdeheh8"},{"post_id":"ciw63jhyf00e50jxl2rkktiu2","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhyh00e60jxlwarkswg1"},{"post_id":"ciw63jhyk00ef0jxlfi3hum08","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhym00eg0jxlrpgsxir8"},{"post_id":"ciw63jhyt00eo0jxlffxopl90","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhyv00ep0jxlinsplo02"},{"post_id":"ciw63jhz100ey0jxlvk5y4o9j","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhz200ez0jxlz3fesg44"},{"post_id":"ciw63jhz600f60jxl1iyckm0a","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhz700f70jxlhfgll77e"},{"post_id":"ciw63jhza00fe0jxljp60eehn","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhze00ff0jxlegem686e"},{"post_id":"ciw63jhzg00fk0jxlepycwmee","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhzi00fl0jxli813d0o0"},{"post_id":"ciw63jhzl00fu0jxl20qrqjn2","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhzp00fv0jxlojxf6qb7"},{"post_id":"ciw63jhzx00g40jxlwokto70o","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jhzz00g50jxl2rnbr5bg"},{"post_id":"ciw63ji0100ga0jxl1rgx0bca","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji0400gb0jxlcscbxkk3"},{"post_id":"ciw63ji0e00gg0jxljymxdo1t","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji0g00gh0jxlqshrrezk"},{"post_id":"ciw63ji0p00gp0jxl2iwuxwuu","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji0t00gq0jxlw073y35p"},{"post_id":"ciw63ji0w00gx0jxlg21ghfiw","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji0x00gy0jxlk000fwt5"},{"post_id":"ciw63ji1300h60jxl3ql6zfy7","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji1700h70jxluu639wl1"},{"post_id":"ciw63ji1b00hc0jxlarebyb5m","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji1c00hd0jxl8ux16w19"},{"post_id":"ciw63ji1e00hi0jxl0rs675r1","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji1f00hj0jxlg2n6tjxy"},{"post_id":"ciw63ji1n00hq0jxlsglddarh","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji1r00hr0jxlg5esr01u"},{"post_id":"ciw63ji1w00i10jxlkv0xl6av","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji1z00i20jxlmkqcqy1i"},{"post_id":"ciw63ji2700i90jxl1qh44l65","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji2800ia0jxle8d98kxn"},{"post_id":"ciw63ji2b00ih0jxlx5jbyndt","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji2c00ii0jxl54skxkar"},{"post_id":"ciw63ji2l00io0jxl0mk62xlj","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji2p00ip0jxlx0g22yu6"},{"post_id":"ciw63ji2r00iv0jxl56teognz","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji2t00iw0jxly360o95s"},{"post_id":"ciw63ji3100j20jxlpbo9n3u5","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji3500j30jxld4ng5cy0"},{"post_id":"ciw63ji4a00j80jxl1gazm2mr","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji4g00j90jxla7eqqd6a"},{"post_id":"ciw63ji4l00jg0jxlvehtidf2","category_id":"ciw63jhw300a60jxlabv54v9b","_id":"ciw63ji4m00jh0jxl3s08vdwr"},{"post_id":"ciw63ji4n00ji0jxlmtc0obw5","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji4p00jj0jxlu82d9yis"},{"post_id":"ciw63ji4v00jn0jxld7ik8eru","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji5000jo0jxlqklhts9t"},{"post_id":"ciw63ji5i00jt0jxlhvrk8prx","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji5j00ju0jxlp6g2w9u9"},{"post_id":"ciw63ji5o00jz0jxlbbzi2bed","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji5t00k00jxlua8wvokj"},{"post_id":"ciw63ji5x00k40jxlr168hhms","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji5z00k50jxl6etion43"},{"post_id":"ciw63ji6100kb0jxl78v23ri9","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji6500kc0jxl2uizd9en"},{"post_id":"ciw63ji6e00kj0jxlpa2aval8","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji6f00kk0jxleieac0py"},{"post_id":"ciw63ji6h00kp0jxld0pde07f","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji6j00kq0jxlc0rj7pxt"},{"post_id":"ciw63ji6m00ku0jxlusw0v9u6","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji6p00kv0jxlx84gohjz"},{"post_id":"ciw63ji6s00l00jxl0ksb0u9r","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji6w00l10jxljc26u16d"},{"post_id":"ciw63ji7000l80jxl8rg8yhez","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji7200l90jxlv8ujr3s7"},{"post_id":"ciw63ji7500lf0jxl11ef297x","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji7700lg0jxlz4wkjsdd"},{"post_id":"ciw63ji7a00lo0jxl3as39urf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji7c00lp0jxlb0wfrak0"},{"post_id":"ciw63ji7f00lv0jxl2nct5vvp","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji7g00lw0jxladw05lr7"},{"post_id":"ciw63ji7i00m00jxlx7op7ycf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji7k00m10jxlrqe4l28l"},{"post_id":"ciw63ji7n00m80jxlb1jydej2","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji7p00m90jxll111v5ud"},{"post_id":"ciw63ji7r00md0jxlki46vz8z","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji7t00me0jxlvekob3cn"},{"post_id":"ciw63ji7x00mn0jxlfbcd3klw","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji7z00mo0jxljdfvhyxg"},{"post_id":"ciw63ji8300mu0jxln6hvfxr0","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji8400mv0jxl9qxvs6ft"},{"post_id":"ciw63ji8900n60jxl519665nt","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji8a00n70jxlh5ucczj0"},{"post_id":"ciw63ji8h00ne0jxlw6ja836i","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji8i00nf0jxl5ywk8eat"},{"post_id":"ciw63ji8l00nl0jxllush6kxt","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji8m00nm0jxl91zyzkjb"},{"post_id":"ciw63ji8q00nu0jxl91wqcyc7","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji8r00nv0jxl82n1akjq"},{"post_id":"ciw63ji8v00o20jxluffykmg8","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji8w00o30jxlrq71kiq2"},{"post_id":"ciw63ji9100o80jxlamv8t5n4","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji9300o90jxl6kok9wv4"},{"post_id":"ciw63ji9600oe0jxlrllepmdx","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji9b00of0jxlofx4cv2j"},{"post_id":"ciw63ji9e00ol0jxl22hg3d0r","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji9f00om0jxl3fi5k0nr"},{"post_id":"ciw63ji9h00or0jxljgkyge18","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji9j00os0jxlm3oz93w6"},{"post_id":"ciw63ji9l00oy0jxlkk7qscrm","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji9n00oz0jxl4jq4nlep"},{"post_id":"ciw63ji9u00pa0jxlt7vc9165","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63ji9w00pb0jxlg8j46pv4"},{"post_id":"ciw63ji9z00pi0jxlsroyq9l5","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jia100pj0jxl6i81uq9g"},{"post_id":"ciw63jia500pr0jxla8w03zeh","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jia700ps0jxl9o8n6ilw"},{"post_id":"ciw63jiab00q00jxlodj9h0wr","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiad00q10jxl0j27i68h"},{"post_id":"ciw63jiag00q70jxlfyvo3irb","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiai00q80jxl93828pw7"},{"post_id":"ciw63jiak00qd0jxln1g31rxu","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiam00qe0jxlcqnj9wwm"},{"post_id":"ciw63jiao00qj0jxl2dalvs1v","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiaq00qk0jxlrm92ypcn"},{"post_id":"ciw63jiat00qq0jxl2b1oaoql","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiav00qr0jxlmdrf7avr"},{"post_id":"ciw63jiax00qw0jxl0no0pyd0","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiay00qx0jxlhljrz2yp"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jib300r30jxlx3xd6ky4"},{"post_id":"ciw63jib800rd0jxlk9cqge99","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jibb00re0jxl36k2iems"},{"post_id":"ciw63jibj00rl0jxlc6dqbnkh","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jibk00rm0jxlhb2oq06c"},{"post_id":"ciw63jibp00rs0jxluhik0vjt","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jibq00rt0jxlazzghwf1"},{"post_id":"ciw63jibs00rx0jxl9p8xsxbm","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jibu00ry0jxlr0oszt85"},{"post_id":"ciw63jic200s40jxlprk119po","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jic400s50jxl5r2705jz"},{"post_id":"ciw63jic800sb0jxlkq5icu9z","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jicd00sc0jxl72kow166"},{"post_id":"ciw63jici00si0jxlec496in3","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jicl00sj0jxlrgtsiws9"},{"post_id":"ciw63jict00so0jxlneecr25r","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jicv00sp0jxleemytmnl"},{"post_id":"ciw63jid600t10jxl6w98ehvc","category_id":"ciw63jhqv002z0jxl3lcibvtr","_id":"ciw63jidc00t20jxlx9bvqhw0"},{"post_id":"ciw63jidi00t90jxl3iqz99wr","category_id":"ciw63jhw300a60jxlabv54v9b","_id":"ciw63jidq00ta0jxl7tybojui"},{"post_id":"ciw63jidw00tb0jxl6j1hhhvl","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jie000tc0jxl1vuopu7i"},{"post_id":"ciw63jie700tj0jxlonjcgtqk","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jie900tk0jxlyosp0upu"},{"post_id":"ciw63jiec00tq0jxlyv5j1pe6","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jief00tr0jxlqjwyowge"},{"post_id":"ciw63jiel00ty0jxlknqpsk0u","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jien00tz0jxl7f872tjd"},{"post_id":"ciw63jies00u50jxlrvegeixo","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jieu00u60jxlqj6729qv"},{"post_id":"ciw63jif000uf0jxlok0pj3h7","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jif200ug0jxlxwqv2brj"},{"post_id":"ciw63jif600uo0jxlmy88sxvg","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jif800up0jxl5b0m0i61"},{"post_id":"ciw63jifb00uu0jxl0bjautas","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jifc00uv0jxlb7m5v7z2"},{"post_id":"ciw63jifh00v10jxle8jg037f","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jifi00v20jxlvl8rt5vv"},{"post_id":"ciw63jifl00v80jxlr7o0iqza","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jifn00v90jxlqwnlak9s"},{"post_id":"ciw63jifq00ve0jxlcgb65afe","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jifs00vf0jxlio94twk0"},{"post_id":"ciw63jifu00vk0jxlkvuve8s3","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jifw00vl0jxl22y308ic"},{"post_id":"ciw63jify00vp0jxl6giayqp0","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jig000vq0jxl93x9fdl9"},{"post_id":"ciw63jig400vw0jxlpt3ytw0y","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jig600vx0jxlnrs1lf9d"},{"post_id":"ciw63jig900w30jxlz98i3xkd","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jigb00w40jxlkus1p05t"},{"post_id":"ciw63jige00w90jxlf66yobmu","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jigg00wa0jxly2fjreld"},{"post_id":"ciw63jigj00wg0jxldae5qjge","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jigl00wh0jxlrptgb8e8"},{"post_id":"ciw63jigp00wo0jxl3fwewg3w","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jigr00wp0jxl8u5nzrwj"},{"post_id":"ciw63jigw00wx0jxl452lpeuc","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jigy00wy0jxleqhnlr8m"},{"post_id":"ciw63jih100x30jxlxbbqo6lf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jih300x40jxlo87drorn"},{"post_id":"ciw63jih700xb0jxl4wjltdvj","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jih900xc0jxlbtyivolb"},{"post_id":"ciw63jihd00xj0jxlz6mr3pkn","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jihe00xk0jxlcuwyppyk"},{"post_id":"ciw63jihi00xq0jxl07wax2lb","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jihm00xr0jxl5cj31gpd"},{"post_id":"ciw63jihp00xw0jxlwc4w8tcf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jihr00xx0jxl66tqq61x"},{"post_id":"ciw63jihw00y40jxlric3k8wm","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jihy00y50jxl11c7ylz5"},{"post_id":"ciw63jii200yd0jxlf4yqvkk0","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jii400ye0jxlu56hrfwk"},{"post_id":"ciw63jii800yl0jxl713qdc6s","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiib00ym0jxltlqpi6nq"},{"post_id":"ciw63jiif00yu0jxliqykk6jq","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiih00yv0jxll6ysso2a"},{"post_id":"ciw63jiim00z20jxldskk9l7j","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiio00z30jxlbzsv4qre"},{"post_id":"ciw63jiir00z90jxl9v8t7bd3","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiit00za0jxlwziihglx"},{"post_id":"ciw63jiix00zg0jxlq7bo5lpd","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiiz00zh0jxlqukmzgr2"},{"post_id":"ciw63jij200zn0jxlt6gfu8a8","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jij400zo0jxll6pygyij"},{"post_id":"ciw63jijb00zy0jxl2zgfkp0i","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jije00zz0jxlcbxu6761"},{"post_id":"ciw63jijh01050jxlbkkxbn3k","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jijj01060jxlds1syfev"},{"post_id":"ciw63jijm010a0jxlka1aahon","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jijo010b0jxl6k435m27"},{"post_id":"ciw63jijq010f0jxl789rnlgs","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jijt010g0jxlw0drnr8j"},{"post_id":"ciw63jijx010n0jxl9r9a9qps","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jijz010o0jxlmn3p2e4i"},{"post_id":"ciw63jik2010u0jxlq257xkju","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jik4010v0jxlbpnn6jm9"},{"post_id":"ciw63jika01140jxl777wje9r","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jikc01150jxl7556vweo"},{"post_id":"ciw63jikf011a0jxl563rdiif","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jikh011b0jxl8xfzprz3"},{"post_id":"ciw63jikk011g0jxlux6trkbp","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jikm011h0jxlv9odvjij"},{"post_id":"ciw63jikq011o0jxl26gropca","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiks011p0jxlt4b57z79"},{"post_id":"ciw63jiku011t0jxle5dm87ui","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiky011u0jxlli35qnxm"},{"post_id":"ciw63jil1011y0jxlr4etq1fx","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jil3011z0jxlooq63uto"},{"post_id":"ciw63jil601240jxlrre2i061","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jil801250jxl4jg3dwd1"},{"post_id":"ciw63jilb012b0jxl65i0vqqg","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jild012c0jxlyhcnenkf"},{"post_id":"ciw63jilh012i0jxl1du4mz32","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jilj012j0jxl08yuj91p"},{"post_id":"ciw63jiln012o0jxlxvtoz74o","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jilp012p0jxl7lvltsn6"},{"post_id":"ciw63jilu012x0jxlco5jltml","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jilw012y0jxlwswqs2rq"},{"post_id":"ciw63jim001340jxlpt0wtodf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jim201350jxltkb7w6c4"},{"post_id":"ciw63jim6013b0jxlsevs3mok","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jim8013c0jxlgfqppr85"},{"post_id":"ciw63jimd013j0jxl73ghnjmo","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jimf013k0jxldoyvrlx2"},{"post_id":"ciw63jimj013q0jxlxjwyuv2u","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jimm013r0jxlc65nonrh"},{"post_id":"ciw63jimo013v0jxlx7g6aw1h","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jimr013w0jxljgizvn1m"},{"post_id":"ciw63jimx01430jxl3lbo3af1","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jin001440jxlsqpcw6u7"},{"post_id":"ciw63jin6014e0jxljjx5fs1o","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jin8014f0jxlj8lau42f"},{"post_id":"ciw63jinc014k0jxl8tpq7nnn","category_id":"ciw63jhw300a60jxlabv54v9b","_id":"ciw63jine014l0jxls72uberp"},{"post_id":"ciw63jine014m0jxlfh9g0v1f","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jing014n0jxld8904o0b"},{"post_id":"ciw63jinl014t0jxloqhl8u6s","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jinn014u0jxl6xi2hl7k"},{"post_id":"ciw63jinr01500jxlwkcl3q1i","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jint01510jxlr7bb351u"},{"post_id":"ciw63jiny01580jxlbnj0c86i","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jio001590jxllgvx5p47"},{"post_id":"ciw63jio3015e0jxlkp4xbrkn","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jio5015f0jxlm0ccaqao"},{"post_id":"ciw63jiod015n0jxln2742wi2","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiof015o0jxlik1gigns"},{"post_id":"ciw63jioj015v0jxlz2w6d909","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiom015w0jxldee8w8w6"},{"post_id":"ciw63jior01630jxlkgbskxg8","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiot01640jxlk2s63ljb"},{"post_id":"ciw63jip0016c0jxl889fn0z2","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jip3016d0jxlblvpahp3"},{"post_id":"ciw63jip8016k0jxlcfcwxwza","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jipa016l0jxlxjjxcbtn"},{"post_id":"ciw63jipf016s0jxlgk5hbfsl","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiph016t0jxle5znk1to"},{"post_id":"ciw63jipm01700jxlwjeh15ux","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jipo01710jxlpu5qqfmi"},{"post_id":"ciw63jips01770jxlizw4ni94","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jipu01780jxl4r1h59kh"},{"post_id":"ciw63jipy017e0jxlqqfyccci","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiq0017f0jxlla7oe62y"},{"post_id":"ciw63jiq5017m0jxlwrmwivq6","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiq8017n0jxlo7tfwzb7"},{"post_id":"ciw63jiqd017u0jxl35p7uqns","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiqf017v0jxlelx5cenk"},{"post_id":"ciw63jiql01830jxl8k0ly7ei","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiqo01840jxlt97z626f"},{"post_id":"ciw63jiqq01880jxlwqka11uv","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiqt01890jxliomq35vb"},{"post_id":"ciw63jiqy018g0jxln5w6qfzm","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jir0018h0jxlflq5pyzq"},{"post_id":"ciw63jir3018l0jxl6ef7lfzw","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jir6018m0jxlzdmw8gfx"},{"post_id":"ciw63jira018r0jxlngvllqkb","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jird018s0jxlh036o6p7"},{"post_id":"ciw63jiri018y0jxlcegvlc9d","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jirk018z0jxlkb0iid49"},{"post_id":"ciw63jirr01950jxl22kg9cfx","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jirt01960jxla5cuiwcm"},{"post_id":"ciw63jirx019b0jxlpre59c2m","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jis0019c0jxla6txacyv"},{"post_id":"ciw63jis5019j0jxlz1kng6of","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jis8019k0jxlp1v6xlvw"},{"post_id":"ciw63jisf019p0jxlrat500k9","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jisl019q0jxl4ruw6oyx"},{"post_id":"ciw63jisv019z0jxlfp30zchk","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jisz01a00jxlhajsx0d3"},{"post_id":"ciw63jit201a50jxl7llyjv18","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jit501a60jxlmmeiktl4"},{"post_id":"ciw63jiti01ae0jxlfa5r1yru","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jitk01af0jxlhgs3byvm"},{"post_id":"ciw63jitp01aj0jxlngy9sfgo","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jitu01ak0jxlkr8fqe4u"},{"post_id":"ciw63jity01ap0jxlnkaar0tr","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiu001aq0jxl3pc3nb9d"},{"post_id":"ciw63jiu701ax0jxlu9758zln","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiue01ay0jxll5uy789p"},{"post_id":"ciw63jium01b70jxltukfy57l","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiut01b80jxle2crljvj"},{"post_id":"ciw63jiuw01bd0jxl8aydlzrj","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiuz01be0jxlshcgrro3"},{"post_id":"ciw63jiv401bi0jxl44g6o5y8","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jivb01bj0jxlf4kamuum"},{"post_id":"ciw63jive01bn0jxlu624pw3g","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jivg01bo0jxlwx9cn32p"},{"post_id":"ciw63jivv01bx0jxlx0tblncd","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jivy01by0jxld10opemt"},{"post_id":"ciw63jiw901c40jxl6cg3y307","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiwc01c50jxlv9e73px9"},{"post_id":"ciw63jiwh01ca0jxlk0fksknq","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiwp01cb0jxlrjmqicpk"},{"post_id":"ciw63jiwv01cf0jxl66e57f5q","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jix001cg0jxlgnpoxwdk"},{"post_id":"ciw63jix901cm0jxl98w2oj35","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jixb01cn0jxlcilgtjgw"},{"post_id":"ciw63jixp01ct0jxl7il6ob6a","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jixt01cu0jxlrf5ahspp"},{"post_id":"ciw63jiy401cy0jxl6ggnbtmp","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiy801cz0jxlkb1wofj7"},{"post_id":"ciw63jiyg01d40jxl9wxatk99","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiym01d50jxlf7qi6ere"},{"post_id":"ciw63jiyt01dc0jxla5ey09jb","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiyz01dd0jxlkw5vs843"},{"post_id":"ciw63jiz401dj0jxlu6j1rktr","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jiz801dk0jxl77yzkr3r"},{"post_id":"ciw63jizd01dq0jxlld4l2j8g","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jizg01dr0jxl4eb6ccp9"},{"post_id":"ciw63jizk01dv0jxlgaus4s3u","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jizq01dw0jxlvvppbgxu"},{"post_id":"ciw63jizy01e30jxlqymgfkh3","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj0101e40jxl703flrrh"},{"post_id":"ciw63jj0501e90jxl4g7dt908","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj0901ea0jxltnoycwsc"},{"post_id":"ciw63jj0g01eg0jxlmt1oziud","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj0i01eh0jxlq1jda5o2"},{"post_id":"ciw63jj0p01en0jxl4l3s7tlx","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj0r01eo0jxlwuvmen25"},{"post_id":"ciw63jj0y01eu0jxlh7km3gl6","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj1101ev0jxlciieqejg"},{"post_id":"ciw63jj1501f10jxl5z2srfqc","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj1801f20jxlf35gtwnb"},{"post_id":"ciw63jj1b01f60jxl24qpn1l2","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj1e01f70jxlib7anyf9"},{"post_id":"ciw63jj1h01fa0jxlsxrvxs03","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj1j01fb0jxleb0awtsc"},{"post_id":"ciw63jj1q01fi0jxlg06ly3qi","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj1t01fj0jxlfkkdb2iq"},{"post_id":"ciw63jj1x01fo0jxljb2rauke","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj2001fp0jxltmss5n30"},{"post_id":"ciw63jj2601ft0jxl0fyw485h","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj2901fu0jxlv15kws23"},{"post_id":"ciw63jj2c01fy0jxlhdv5t1lw","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj2e01fz0jxlg2od1gta"},{"post_id":"ciw63jj2h01g30jxlhs4twjbt","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj2p01g40jxl1ypib0vc"},{"post_id":"ciw63jj2u01ga0jxl62fut59c","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj2y01gb0jxlaghphd8o"},{"post_id":"ciw63jj3201gg0jxldhxgs6vm","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj3501gh0jxl3dps0h7t"},{"post_id":"ciw63jj3a01gn0jxlhxbnjmp9","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj3c01go0jxl9cwigbe8"},{"post_id":"ciw63jj3g01gt0jxlkxdwd32p","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj3j01gu0jxlyfllezjx"},{"post_id":"ciw63jj3n01h00jxl0k4v6l4e","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj3q01h10jxlul6cgx7l"},{"post_id":"ciw63jj3w01h60jxla7ocz91w","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj4101h70jxlo0udiwwb"},{"post_id":"ciw63jj4501hc0jxlirv62qyg","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj4801hd0jxlpk9spf7v"},{"post_id":"ciw63jj4d01hj0jxlekqpkdy6","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj4j01hk0jxlwnh7djx4"},{"post_id":"ciw63jj4n01hp0jxllof8dkew","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj4p01hq0jxly369xsmz"},{"post_id":"ciw63jj4v01hw0jxls0pz1a24","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj4y01hx0jxlteet4qwc"},{"post_id":"ciw63jj5201i20jxlb9zeyzxs","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj5401i30jxlmefonpnt"},{"post_id":"ciw63jj5701i70jxl47x9lp3g","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj5a01i80jxldlylq5pk"},{"post_id":"ciw63jj5e01ic0jxl76ncx0ym","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj5g01id0jxluobnxwsj"},{"post_id":"ciw63jj5n01ii0jxlouqferis","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj5p01ij0jxlrlu5nu31"},{"post_id":"ciw63jj5v01ip0jxlz1c34o0f","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj5y01iq0jxl40670a48"},{"post_id":"ciw63jj6301iv0jxl7r3j2apw","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj6601iw0jxlx1f2hv83"},{"post_id":"ciw63jj6a01j10jxlxlsrqqz1","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj6c01j20jxl4yovv235"},{"post_id":"ciw63jj6j01j90jxlv5jxgrxs","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj6m01ja0jxlua1muqgo"},{"post_id":"ciw63jj6p01jd0jxlq9ejtz16","category_id":"ciw63jhw300a60jxlabv54v9b","_id":"ciw63jj6s01je0jxl8740d8in"},{"post_id":"ciw63jj6u01jf0jxlwgane189","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj6x01jg0jxl3rg546ow"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj7601jo0jxlt0bgpxkk"},{"post_id":"ciw63jj7h01k00jxlxqzdujm3","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj7k01k10jxl67e7o1tu"},{"post_id":"ciw63jj7r01k90jxl3gt6aevw","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj7u01ka0jxlz1id360e"},{"post_id":"ciw63jj8001kh0jxl4fgotskf","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj8201ki0jxl4khp5j89"},{"post_id":"ciw63jj8801ko0jxl1j28j47t","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj8a01kp0jxlet8awm12"},{"post_id":"ciw63jj8j01ku0jxlp060q84c","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj8l01kv0jxl95eyl4zr"},{"post_id":"ciw63jj8s01l20jxlvvarnld5","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj8w01l30jxlj95c664d"},{"post_id":"ciw63jj9501lb0jxlyjaha09p","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj9801lc0jxlpf9dv8tc"},{"post_id":"ciw63jj9d01lh0jxlurhl3zas","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj9g01li0jxlnfwysops"},{"post_id":"ciw63jj9k01ln0jxl610afd2a","category_id":"ciw63jhoe00010jxlqznpe3ld","_id":"ciw63jj9n01lo0jxlryq0hk1r"}],"PostTag":[{"post_id":"ciw63jho800000jxl7vo5ctl0","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jhoj00080jxlbg5oaq1o"},{"post_id":"ciw63jho800000jxl7vo5ctl0","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63jhok00090jxlvzxvhc07"},{"post_id":"ciw63jho800000jxl7vo5ctl0","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63jhok000a0jxl70eypu1x"},{"post_id":"ciw63jho800000jxl7vo5ctl0","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhok000b0jxlssslmrcq"},{"post_id":"ciw63jho800000jxl7vo5ctl0","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jhok000c0jxljs2sv1nu"},{"post_id":"ciw63jhp1000g0jxl4ak61ggc","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhp4000m0jxljd71q6an"},{"post_id":"ciw63jhp1000g0jxl4ak61ggc","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhp5000n0jxlanwu3wzh"},{"post_id":"ciw63jhp1000g0jxl4ak61ggc","tag_id":"ciw63jhp4000k0jxl6dxtsl10","_id":"ciw63jhp5000o0jxlawvj60fb"},{"post_id":"ciw63jhp1000g0jxl4ak61ggc","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhp5000p0jxl66u1no2j"},{"post_id":"ciw63jhp8000q0jxlpyetogzg","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhpc000w0jxlh8d5eor5"},{"post_id":"ciw63jhp8000q0jxlpyetogzg","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhpd000x0jxljl7eg9c5"},{"post_id":"ciw63jhp8000q0jxlpyetogzg","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jhpd000y0jxl19lha2fd"},{"post_id":"ciw63jhp8000q0jxlpyetogzg","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jhpe000z0jxlaeo4zwrm"},{"post_id":"ciw63jhp8000q0jxlpyetogzg","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jhpe00100jxlgta8kto5"},{"post_id":"ciw63jhp8000q0jxlpyetogzg","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jhpe00110jxl14reswq6"},{"post_id":"ciw63jhph00120jxlf8v4vtf6","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhpl00150jxl0ckgsr0i"},{"post_id":"ciw63jhph00120jxlf8v4vtf6","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhpl00160jxlmu7m5ja1"},{"post_id":"ciw63jhph00120jxlf8v4vtf6","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jhpl00170jxl2baesv9q"},{"post_id":"ciw63jhph00120jxlf8v4vtf6","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jhpl00180jxl97saqepx"},{"post_id":"ciw63jhph00120jxlf8v4vtf6","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jhpm00190jxlt8r49l1l"},{"post_id":"ciw63jhpo001a0jxlivjq2nyn","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhpq001d0jxlmnwzbrtx"},{"post_id":"ciw63jhpo001a0jxlivjq2nyn","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhpq001e0jxl15qqtqcx"},{"post_id":"ciw63jhpo001a0jxlivjq2nyn","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhpr001f0jxlk7qh9725"},{"post_id":"ciw63jhpv001g0jxlsw5fh7eh","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhpy001j0jxll2ois4rz"},{"post_id":"ciw63jhpv001g0jxlsw5fh7eh","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhpz001k0jxl3iqofvpi"},{"post_id":"ciw63jhpv001g0jxlsw5fh7eh","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jhpz001l0jxl0tz0n0w2"},{"post_id":"ciw63jhq1001m0jxlba1hhfw0","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhq3001r0jxl8nptz49u"},{"post_id":"ciw63jhq1001m0jxlba1hhfw0","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhq4001s0jxlxqlvsd6g"},{"post_id":"ciw63jhq1001m0jxlba1hhfw0","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhq4001t0jxlbwdgcj6l"},{"post_id":"ciw63jhq1001m0jxlba1hhfw0","tag_id":"ciw63jhq3001p0jxluez7uhi5","_id":"ciw63jhq5001u0jxl3fy3jtk4"},{"post_id":"ciw63jhq1001m0jxlba1hhfw0","tag_id":"ciw63jhq3001q0jxlvltin2kq","_id":"ciw63jhq5001v0jxln1uu8y3k"},{"post_id":"ciw63jhq1001m0jxlba1hhfw0","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhq5001w0jxltf6s4gql"},{"post_id":"ciw63jhq7001x0jxl1ofxiq8g","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhq900210jxl6tcec3xw"},{"post_id":"ciw63jhq7001x0jxl1ofxiq8g","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhqa00220jxlgidf9kuc"},{"post_id":"ciw63jhq7001x0jxl1ofxiq8g","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhqa00230jxlz6lzzj2m"},{"post_id":"ciw63jhq7001x0jxl1ofxiq8g","tag_id":"ciw63jhq9001z0jxls0zdq3cq","_id":"ciw63jhqa00240jxlcc115ruz"},{"post_id":"ciw63jhq7001x0jxl1ofxiq8g","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jhqa00250jxlmp1nv5nk"},{"post_id":"ciw63jhq7001x0jxl1ofxiq8g","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhqa00260jxlop9khqr3"},{"post_id":"ciw63jhqc00270jxlzju38atf","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhqg002c0jxlggeekie9"},{"post_id":"ciw63jhqc00270jxlzju38atf","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhqh002d0jxlo8aotssc"},{"post_id":"ciw63jhqc00270jxlzju38atf","tag_id":"ciw63jhqe00290jxll2p85zae","_id":"ciw63jhqh002e0jxlgsci06l8"},{"post_id":"ciw63jhqc00270jxlzju38atf","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jhqh002f0jxljrrj2pj6"},{"post_id":"ciw63jhqc00270jxlzju38atf","tag_id":"ciw63jhqg002b0jxl534swffv","_id":"ciw63jhqh002g0jxlajcm1or3"},{"post_id":"ciw63jhqc00270jxlzju38atf","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhqh002h0jxl5ewxw3ye"},{"post_id":"ciw63jhqi002i0jxlfvryob26","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhql002l0jxldaydp26e"},{"post_id":"ciw63jhqi002i0jxlfvryob26","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhql002m0jxlxq1xdv1u"},{"post_id":"ciw63jhqi002i0jxlfvryob26","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhqm002n0jxl1uk7245g"},{"post_id":"ciw63jhqi002i0jxlfvryob26","tag_id":"ciw63jhqk002k0jxliuhphaht","_id":"ciw63jhqm002o0jxlsrccxtc9"},{"post_id":"ciw63jhqi002i0jxlfvryob26","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhqm002p0jxlvx4dwa8k"},{"post_id":"ciw63jhqn002q0jxlwblyl8l1","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhqp002t0jxl16b2zlvy"},{"post_id":"ciw63jhqn002q0jxlwblyl8l1","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhqq002u0jxl3ctpr9fs"},{"post_id":"ciw63jhqn002q0jxlwblyl8l1","tag_id":"ciw63jhp4000j0jxl0i3smal8","_id":"ciw63jhqq002v0jxle53un61z"},{"post_id":"ciw63jhqn002q0jxlwblyl8l1","tag_id":"ciw63jhqo002s0jxl0vvekmbq","_id":"ciw63jhqq002w0jxl8vvivx67"},{"post_id":"ciw63jhqn002q0jxlwblyl8l1","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhqq002x0jxljpke8kaw"},{"post_id":"ciw63jhqt002y0jxlpvxp6lah","tag_id":"ciw63jhqv00300jxlf9goby9h","_id":"ciw63jhqx00370jxljjkkyaxo"},{"post_id":"ciw63jhqt002y0jxlpvxp6lah","tag_id":"ciw63jhqw00310jxliwkk7834","_id":"ciw63jhqy00380jxlvgw39y8s"},{"post_id":"ciw63jhqt002y0jxlpvxp6lah","tag_id":"ciw63jhqw00320jxl7qd0lj17","_id":"ciw63jhqy00390jxl8oqmds7w"},{"post_id":"ciw63jhqt002y0jxlpvxp6lah","tag_id":"ciw63jhqx00330jxl0gmba711","_id":"ciw63jhqy003a0jxle6fwywc8"},{"post_id":"ciw63jhqt002y0jxlpvxp6lah","tag_id":"ciw63jhqx00340jxljvf0s25b","_id":"ciw63jhqy003b0jxl5odmjyzy"},{"post_id":"ciw63jhqt002y0jxlpvxp6lah","tag_id":"ciw63jhqx00350jxlpwot7dr5","_id":"ciw63jhqy003c0jxle1py6fuh"},{"post_id":"ciw63jhru003d0jxlspk5qhq1","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jhrw003i0jxlzhe9bbf2"},{"post_id":"ciw63jhru003d0jxlspk5qhq1","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhrx003j0jxljk5mb9f8"},{"post_id":"ciw63jhru003d0jxlspk5qhq1","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhrx003k0jxl2a4iqkpw"},{"post_id":"ciw63jhru003d0jxlspk5qhq1","tag_id":"ciw63jhrw003g0jxlomcv3673","_id":"ciw63jhrx003l0jxl228khgli"},{"post_id":"ciw63jhru003d0jxlspk5qhq1","tag_id":"ciw63jhrw003h0jxldg4y0la6","_id":"ciw63jhrx003m0jxlciowdno2"},{"post_id":"ciw63jhrz003n0jxlw115yahf","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jhs2003r0jxltikfqq0y"},{"post_id":"ciw63jhrz003n0jxlw115yahf","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhs2003s0jxl5y9ps0yz"},{"post_id":"ciw63jhrz003n0jxlw115yahf","tag_id":"ciw63jhs1003p0jxlk7390dhu","_id":"ciw63jhs3003t0jxlr5o1vp3i"},{"post_id":"ciw63jhrz003n0jxlw115yahf","tag_id":"ciw63jhs2003q0jxl9xrufqxy","_id":"ciw63jhs3003u0jxlidwif8j7"},{"post_id":"ciw63jhs6003v0jxlhah65gxj","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jhs8003x0jxlz2ianobz"},{"post_id":"ciw63jhs6003v0jxlhah65gxj","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhs9003y0jxlnky58z1g"},{"post_id":"ciw63jhs6003v0jxlhah65gxj","tag_id":"ciw63jhs1003p0jxlk7390dhu","_id":"ciw63jhs9003z0jxlatmi4k1y"},{"post_id":"ciw63jhs6003v0jxlhah65gxj","tag_id":"ciw63jhrw003h0jxldg4y0la6","_id":"ciw63jhs900400jxl27kvelhh"},{"post_id":"ciw63jhsk00410jxl41s1ltan","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jhsm00450jxlv59l6b47"},{"post_id":"ciw63jhsk00410jxl41s1ltan","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhsn00460jxlwjc8ltnd"},{"post_id":"ciw63jhsk00410jxl41s1ltan","tag_id":"ciw63jhsm00430jxlz3455y0p","_id":"ciw63jhsn00470jxlkocgf2mu"},{"post_id":"ciw63jhsk00410jxl41s1ltan","tag_id":"ciw63jhsm00440jxlt4lia4dr","_id":"ciw63jhsn00480jxlrhd82hza"},{"post_id":"ciw63jhsn00490jxlfz88b4yy","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jhsq004c0jxlyebp38qx"},{"post_id":"ciw63jhsn00490jxlfz88b4yy","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhsq004d0jxlbvxh9k4n"},{"post_id":"ciw63jhsn00490jxlfz88b4yy","tag_id":"ciw63jhsm00430jxlz3455y0p","_id":"ciw63jhsq004e0jxluqye8qiz"},{"post_id":"ciw63jhsn00490jxlfz88b4yy","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhsq004f0jxlazlay4w1"},{"post_id":"ciw63jhsn00490jxlfz88b4yy","tag_id":"ciw63jhsp004b0jxl4h5p03lp","_id":"ciw63jhsq004g0jxle5m4kmr9"},{"post_id":"ciw63jhsr004h0jxlv181n4al","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jhsu004m0jxl841jmjcx"},{"post_id":"ciw63jhsr004h0jxlv181n4al","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhsu004n0jxl36jj4z02"},{"post_id":"ciw63jhsr004h0jxlv181n4al","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jhsu004o0jxlvzw1m1yl"},{"post_id":"ciw63jhsr004h0jxlv181n4al","tag_id":"ciw63jhsm00430jxlz3455y0p","_id":"ciw63jhsu004p0jxlb1m9y18s"},{"post_id":"ciw63jhsr004h0jxlv181n4al","tag_id":"ciw63jhrw003h0jxldg4y0la6","_id":"ciw63jhsu004q0jxlw74pyojs"},{"post_id":"ciw63jhsr004h0jxlv181n4al","tag_id":"ciw63jhst004k0jxl42nd9rzx","_id":"ciw63jhsu004r0jxla5moqx7z"},{"post_id":"ciw63jhsr004h0jxlv181n4al","tag_id":"ciw63jhst004l0jxlyuc95efx","_id":"ciw63jhsu004s0jxlwaasokp4"},{"post_id":"ciw63jhsv004t0jxlhor559m8","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jhsy004w0jxlz4bp7zx4"},{"post_id":"ciw63jhsv004t0jxlhor559m8","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhsz004x0jxlc96xajqa"},{"post_id":"ciw63jhsv004t0jxlhor559m8","tag_id":"ciw63jhsm00430jxlz3455y0p","_id":"ciw63jhsz004y0jxlk72q8i4x"},{"post_id":"ciw63jhsv004t0jxlhor559m8","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhsz004z0jxlz7hipmtm"},{"post_id":"ciw63jhsv004t0jxlhor559m8","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jhsz00500jxl3ut10kfg"},{"post_id":"ciw63jht000510jxlofly25s2","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jht200540jxlwlsybthu"},{"post_id":"ciw63jht000510jxlofly25s2","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jht300550jxlz0jj6m58"},{"post_id":"ciw63jht000510jxlofly25s2","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jht300560jxlj6omc36n"},{"post_id":"ciw63jht000510jxlofly25s2","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jht300570jxllvjavr2h"},{"post_id":"ciw63jht000510jxlofly25s2","tag_id":"ciw63jht200530jxl3bf9aj93","_id":"ciw63jht300580jxls2ao9pz2"},{"post_id":"ciw63jht400590jxlt6p97yn7","tag_id":"ciw63jhrv003f0jxl2fvzxu10","_id":"ciw63jht8005e0jxlvki9dsma"},{"post_id":"ciw63jht400590jxlt6p97yn7","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhta005f0jxlly4q8zym"},{"post_id":"ciw63jht400590jxlt6p97yn7","tag_id":"ciw63jhsm00430jxlz3455y0p","_id":"ciw63jhta005g0jxlyqkihpet"},{"post_id":"ciw63jht400590jxlt6p97yn7","tag_id":"ciw63jhrw003h0jxldg4y0la6","_id":"ciw63jhtb005h0jxlvjfrr5x9"},{"post_id":"ciw63jht400590jxlt6p97yn7","tag_id":"ciw63jht7005b0jxlj5mtp6jt","_id":"ciw63jhtb005i0jxll00a6o87"},{"post_id":"ciw63jht400590jxlt6p97yn7","tag_id":"ciw63jht8005c0jxlo598nf80","_id":"ciw63jhtb005j0jxl0obwjnuq"},{"post_id":"ciw63jht400590jxlt6p97yn7","tag_id":"ciw63jht8005d0jxl50oa1dhw","_id":"ciw63jhtb005k0jxlw127qlmj"},{"post_id":"ciw63jhtc005l0jxla7u7kf08","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jhte005q0jxlq2ns7sq5"},{"post_id":"ciw63jhtc005l0jxla7u7kf08","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhte005r0jxljo3vr684"},{"post_id":"ciw63jhtc005l0jxla7u7kf08","tag_id":"ciw63jhte005o0jxllyywhtlr","_id":"ciw63jhtf005s0jxlailabs8d"},{"post_id":"ciw63jhtc005l0jxla7u7kf08","tag_id":"ciw63jhte005p0jxlni7rbi2h","_id":"ciw63jhtf005t0jxlol3ki33h"},{"post_id":"ciw63jhtg005u0jxl71xjxb76","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhti005y0jxllp6ka5f5"},{"post_id":"ciw63jhtg005u0jxl71xjxb76","tag_id":"ciw63jhth005w0jxldiwq6tgd","_id":"ciw63jhtj005z0jxlt9yhhg97"},{"post_id":"ciw63jhtg005u0jxl71xjxb76","tag_id":"ciw63jhti005x0jxl1yljboft","_id":"ciw63jhtj00600jxlq785b0q1"},{"post_id":"ciw63jhtg005u0jxl71xjxb76","tag_id":"ciw63jhqo002s0jxl0vvekmbq","_id":"ciw63jhtj00610jxl43fwva9z"},{"post_id":"ciw63jhtj00620jxluowegsux","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhto00660jxl4w982z8c"},{"post_id":"ciw63jhtj00620jxluowegsux","tag_id":"ciw63jhth005w0jxldiwq6tgd","_id":"ciw63jhtp00670jxlrpe323h9"},{"post_id":"ciw63jhtj00620jxluowegsux","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jhtp00680jxloty093p6"},{"post_id":"ciw63jhtj00620jxluowegsux","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jhtp00690jxlwnkk11wl"},{"post_id":"ciw63jhtq006a0jxlhucuqzzr","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhtu006f0jxlok6p6hho"},{"post_id":"ciw63jhtq006a0jxlhucuqzzr","tag_id":"ciw63jhth005w0jxldiwq6tgd","_id":"ciw63jhtu006g0jxlg4wycs2l"},{"post_id":"ciw63jhtq006a0jxlhucuqzzr","tag_id":"ciw63jhts006c0jxlsgx0aj9d","_id":"ciw63jhtu006h0jxlqpd23nxp"},{"post_id":"ciw63jhtq006a0jxlhucuqzzr","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jhtu006i0jxl1rmkk6oo"},{"post_id":"ciw63jhtq006a0jxlhucuqzzr","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jhtu006j0jxliqasw90q"},{"post_id":"ciw63jhtv006k0jxln9wevpt5","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jhtz006q0jxlh2sdyuel"},{"post_id":"ciw63jhtv006k0jxln9wevpt5","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jhu0006r0jxlyccyfsz5"},{"post_id":"ciw63jhtv006k0jxln9wevpt5","tag_id":"ciw63jhty006o0jxlfk01cryd","_id":"ciw63jhu0006s0jxl47seakrg"},{"post_id":"ciw63jhtv006k0jxln9wevpt5","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jhu0006t0jxlqk486g8i"},{"post_id":"ciw63jhtv006k0jxln9wevpt5","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jhu0006u0jxl6z5npht0"},{"post_id":"ciw63jhu1006v0jxluod96ozu","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jhu4006y0jxlhanar97o"},{"post_id":"ciw63jhu1006v0jxluod96ozu","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jhu5006z0jxlk183og0m"},{"post_id":"ciw63jhu1006v0jxluod96ozu","tag_id":"ciw63jhu2006x0jxl0pyk2jka","_id":"ciw63jhu500700jxltyct5bla"},{"post_id":"ciw63jhu1006v0jxluod96ozu","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jhu500710jxl1lozrdd6"},{"post_id":"ciw63jhu1006v0jxluod96ozu","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jhu500720jxlohhmwbgz"},{"post_id":"ciw63jhu700730jxlieacqas9","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jhu800760jxlbmt01gnq"},{"post_id":"ciw63jhu700730jxlieacqas9","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jhu900770jxlbrntn85l"},{"post_id":"ciw63jhu700730jxlieacqas9","tag_id":"ciw63jhu800750jxltqzcqwj9","_id":"ciw63jhu900780jxlv3v801ki"},{"post_id":"ciw63jhu700730jxlieacqas9","tag_id":"ciw63jhqk002k0jxliuhphaht","_id":"ciw63jhu900790jxlghia3zdp"},{"post_id":"ciw63jhu700730jxlieacqas9","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jhu9007a0jxl0rch4fq4"},{"post_id":"ciw63jhua007b0jxl75qjkacf","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jhuc007f0jxlcw5hu1eb"},{"post_id":"ciw63jhua007b0jxl75qjkacf","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jhuc007g0jxlbil2zj5m"},{"post_id":"ciw63jhua007b0jxl75qjkacf","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jhuc007h0jxlh5aob7z1"},{"post_id":"ciw63jhua007b0jxl75qjkacf","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jhuc007i0jxlg2r596go"},{"post_id":"ciw63jhua007b0jxl75qjkacf","tag_id":"ciw63jhub007e0jxlajuc9pc9","_id":"ciw63jhuc007j0jxlb4yj7a53"},{"post_id":"ciw63jhud007k0jxljvfl81sy","tag_id":"ciw63jhue007m0jxlw9ocvwvc","_id":"ciw63jhuf007o0jxl0vjw10mf"},{"post_id":"ciw63jhud007k0jxljvfl81sy","tag_id":"ciw63jhuf007n0jxll83ky6ks","_id":"ciw63jhuf007p0jxleyzdct10"},{"post_id":"ciw63jhug007q0jxle6nwr5o1","tag_id":"ciw63jhuh007s0jxlsmej0d1s","_id":"ciw63jhui007t0jxlw90d29dv"},{"post_id":"ciw63jhug007q0jxle6nwr5o1","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jhui007u0jxl26qg8ef9"},{"post_id":"ciw63jhug007q0jxle6nwr5o1","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jhui007v0jxlnbdbmh8u"},{"post_id":"ciw63jhuk007w0jxl1g4zch8w","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jhul007y0jxld532dglz"},{"post_id":"ciw63jhuk007w0jxl1g4zch8w","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jhum007z0jxllmjt23dl"},{"post_id":"ciw63jhuk007w0jxl1g4zch8w","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jhum00800jxl7v2a9gbx"},{"post_id":"ciw63jhuk007w0jxl1g4zch8w","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhum00810jxl0rd659wk"},{"post_id":"ciw63jhuk007w0jxl1g4zch8w","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jhum00820jxlpz5fkhe9"},{"post_id":"ciw63jhuo00830jxlazg62izo","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhuq00850jxl7ei6hl53"},{"post_id":"ciw63jhuo00830jxlazg62izo","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jhur00860jxl8odbb7dc"},{"post_id":"ciw63jhuo00830jxlazg62izo","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jhur00870jxl1ojzbfxg"},{"post_id":"ciw63jhuo00830jxlazg62izo","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhur00880jxlk13pbk82"},{"post_id":"ciw63jhuo00830jxlazg62izo","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jhur00890jxlcgucnqr7"},{"post_id":"ciw63jhuu008a0jxluy4x61qz","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhuw008c0jxllmj17wmn"},{"post_id":"ciw63jhuu008a0jxluy4x61qz","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jhux008d0jxlbtvssu7m"},{"post_id":"ciw63jhuu008a0jxluy4x61qz","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jhux008e0jxlj53ngq3k"},{"post_id":"ciw63jhuu008a0jxluy4x61qz","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhux008f0jxlythnwtw1"},{"post_id":"ciw63jhuu008a0jxluy4x61qz","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jhux008g0jxlc4hh9tvv"},{"post_id":"ciw63jhv5008h0jxly9it3py0","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhv8008k0jxlnegi8ln0"},{"post_id":"ciw63jhv5008h0jxly9it3py0","tag_id":"ciw63jhv8008j0jxlcq3311hj","_id":"ciw63jhv9008l0jxlitdk1g9l"},{"post_id":"ciw63jhv5008h0jxly9it3py0","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63jhv9008m0jxla85ewc0o"},{"post_id":"ciw63jhva008n0jxlk725w5pb","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhvc008q0jxlrtdary16"},{"post_id":"ciw63jhva008n0jxlk725w5pb","tag_id":"ciw63jhv8008j0jxlcq3311hj","_id":"ciw63jhvd008r0jxlki64udie"},{"post_id":"ciw63jhva008n0jxlk725w5pb","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhvd008s0jxltknot6nb"},{"post_id":"ciw63jhva008n0jxlk725w5pb","tag_id":"ciw63jhvc008p0jxl4cnneztw","_id":"ciw63jhvd008t0jxloawygbaw"},{"post_id":"ciw63jhve008u0jxlin8rvina","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhvg008w0jxljnc51ee2"},{"post_id":"ciw63jhve008u0jxlin8rvina","tag_id":"ciw63jhv8008j0jxlcq3311hj","_id":"ciw63jhvg008x0jxlg4vbno6u"},{"post_id":"ciw63jhve008u0jxlin8rvina","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhvh008y0jxlzu2y2p2o"},{"post_id":"ciw63jhvi008z0jxleh86b9be","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhvk00910jxlcez9s4bj"},{"post_id":"ciw63jhvi008z0jxleh86b9be","tag_id":"ciw63jhv8008j0jxlcq3311hj","_id":"ciw63jhvl00920jxlryye470y"},{"post_id":"ciw63jhvi008z0jxleh86b9be","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhvl00930jxlpgfzgd6e"},{"post_id":"ciw63jhvm00940jxli0hmhjcu","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhvp00970jxl2ybd379t"},{"post_id":"ciw63jhvm00940jxli0hmhjcu","tag_id":"ciw63jhv8008j0jxlcq3311hj","_id":"ciw63jhvp00980jxlfwkqn1l2"},{"post_id":"ciw63jhvm00940jxli0hmhjcu","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhvp00990jxl35nhtj2q"},{"post_id":"ciw63jhvm00940jxli0hmhjcu","tag_id":"ciw63jhvo00960jxliuj224fd","_id":"ciw63jhvp009a0jxl183q0krf"},{"post_id":"ciw63jhvm00940jxli0hmhjcu","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jhvq009b0jxlffh7gr2f"},{"post_id":"ciw63jhvr009c0jxl1nw5ofqt","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhvs009e0jxlcbypcewj"},{"post_id":"ciw63jhvr009c0jxl1nw5ofqt","tag_id":"ciw63jhv8008j0jxlcq3311hj","_id":"ciw63jhvs009f0jxlf5yz4w3g"},{"post_id":"ciw63jhvr009c0jxl1nw5ofqt","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jhvs009g0jxlvrb230wn"},{"post_id":"ciw63jhvr009c0jxl1nw5ofqt","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jhvs009h0jxlsnpkl9u7"},{"post_id":"ciw63jhvr009c0jxl1nw5ofqt","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jhvs009i0jxl1emnw2zo"},{"post_id":"ciw63jhvt009j0jxl6h2c2f7x","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhvv009n0jxld3tgq78l"},{"post_id":"ciw63jhvt009j0jxl6h2c2f7x","tag_id":"ciw63jhv8008j0jxlcq3311hj","_id":"ciw63jhvw009o0jxlwoy9vxad"},{"post_id":"ciw63jhvt009j0jxl6h2c2f7x","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhvw009p0jxl5dlkmmw9"},{"post_id":"ciw63jhvt009j0jxl6h2c2f7x","tag_id":"ciw63jhvu009l0jxlrt41ik9x","_id":"ciw63jhvw009q0jxlo7azqox0"},{"post_id":"ciw63jhvt009j0jxl6h2c2f7x","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jhvw009r0jxlyp9syllw"},{"post_id":"ciw63jhvt009j0jxl6h2c2f7x","tag_id":"ciw63jhvv009m0jxl6qtqkgdq","_id":"ciw63jhvw009s0jxlter5x0h0"},{"post_id":"ciw63jhvx009t0jxlw5x1kt86","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhvz009z0jxlcx7t19p1"},{"post_id":"ciw63jhvx009t0jxlw5x1kt86","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhw000a00jxl75fn62zd"},{"post_id":"ciw63jhvx009t0jxlw5x1kt86","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhw000a10jxl53mkr61z"},{"post_id":"ciw63jhvx009t0jxlw5x1kt86","tag_id":"ciw63jhvz009w0jxlcriylz94","_id":"ciw63jhw000a20jxlnh317vuy"},{"post_id":"ciw63jhvx009t0jxlw5x1kt86","tag_id":"ciw63jhvz009x0jxlwq2vyumc","_id":"ciw63jhw000a30jxlow1xi138"},{"post_id":"ciw63jhvx009t0jxlw5x1kt86","tag_id":"ciw63jhvz009y0jxl5ah0p6x5","_id":"ciw63jhw000a40jxl51ya1o8q"},{"post_id":"ciw63jhw400a80jxlkkx4eymd","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhw600ab0jxlf7ezg275"},{"post_id":"ciw63jhw400a80jxlkkx4eymd","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhw700ac0jxlc87nv1hx"},{"post_id":"ciw63jhw400a80jxlkkx4eymd","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhw700ad0jxl6swm5q78"},{"post_id":"ciw63jhw400a80jxlkkx4eymd","tag_id":"ciw63jhs1003p0jxlk7390dhu","_id":"ciw63jhw700ae0jxlwe36sd5z"},{"post_id":"ciw63jhw400a80jxlkkx4eymd","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhw700af0jxlrcc3e6qd"},{"post_id":"ciw63jhw400a80jxlkkx4eymd","tag_id":"ciw63jhw500aa0jxlnvxx8tjo","_id":"ciw63jhw700ag0jxlb4uq7hvu"},{"post_id":"ciw63jhw400a80jxlkkx4eymd","tag_id":"ciw63jht7005b0jxlj5mtp6jt","_id":"ciw63jhw700ah0jxl4sflejlx"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhwb00an0jxltpbcidqg"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhwc00ao0jxlu06o6tbx"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhwc00ap0jxlxijh13fh"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jhwc00aq0jxla5caju7v"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jhwc00ar0jxler6f5woq"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhw900ak0jxlsrx72lu1","_id":"ciw63jhwc00as0jxlrk0qujji"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhwa00al0jxlcb3r95mn","_id":"ciw63jhwc00at0jxlhiimfgu3"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jhwc00au0jxltvuh34xm"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jhwc00av0jxljd4zj1av"},{"post_id":"ciw63jhw800ai0jxld3azfk3q","tag_id":"ciw63jhwa00am0jxl8d14vm7y","_id":"ciw63jhwc00aw0jxlttw2w5vp"},{"post_id":"ciw63jhwd00ax0jxlvvusrna8","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhwe00az0jxluurfyz00"},{"post_id":"ciw63jhwd00ax0jxlvvusrna8","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhwf00b00jxlsvwdtwwd"},{"post_id":"ciw63jhwd00ax0jxlvvusrna8","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhwf00b10jxl1xk4ugdg"},{"post_id":"ciw63jhwd00ax0jxlvvusrna8","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhwf00b20jxlo29hxljy"},{"post_id":"ciw63jhwd00ax0jxlvvusrna8","tag_id":"ciw63jhq9001z0jxls0zdq3cq","_id":"ciw63jhwf00b30jxl456xufdc"},{"post_id":"ciw63jhwd00ax0jxlvvusrna8","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jhwf00b40jxl4fspaubd"},{"post_id":"ciw63jhwg00b50jxlrmn6lq89","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhwi00b80jxlc33lizbe"},{"post_id":"ciw63jhwg00b50jxlrmn6lq89","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhwi00b90jxl3174gyn5"},{"post_id":"ciw63jhwg00b50jxlrmn6lq89","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhwi00ba0jxlrfcd56iv"},{"post_id":"ciw63jhwg00b50jxlrmn6lq89","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jhwi00bb0jxl7jascovi"},{"post_id":"ciw63jhwg00b50jxlrmn6lq89","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jhwi00bc0jxl3nn1q1z5"},{"post_id":"ciw63jhwg00b50jxlrmn6lq89","tag_id":"ciw63jhwh00b70jxl6btias08","_id":"ciw63jhwi00bd0jxlpr9ry6oy"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhwn00bh0jxlz0mc0utb"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jhwo00bi0jxlv7ajz4fn"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhwo00bj0jxl8i1ksebu"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63jhwo00bk0jxlv6shx3fi"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63jhwo00bl0jxlak5sn8wv"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhwo00bm0jxlxcggs77w"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhwo00bn0jxl916yyjdi"},{"post_id":"ciw63jhwj00be0jxlzu67kd1z","tag_id":"ciw63jhwm00bg0jxl2evdv197","_id":"ciw63jhwo00bo0jxl11yivtb5"},{"post_id":"ciw63jhws00bp0jxlxm6c6ph5","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhwv00bs0jxluyjebpvm"},{"post_id":"ciw63jhws00bp0jxlxm6c6ph5","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhww00bt0jxlwdoml8qp"},{"post_id":"ciw63jhws00bp0jxlxm6c6ph5","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jhww00bu0jxlr808i7vb"},{"post_id":"ciw63jhws00bp0jxlxm6c6ph5","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jhww00bv0jxlprebt943"},{"post_id":"ciw63jhws00bp0jxlxm6c6ph5","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jhww00bw0jxl5kat93en"},{"post_id":"ciw63jhws00bp0jxlxm6c6ph5","tag_id":"ciw63jhwa00am0jxl8d14vm7y","_id":"ciw63jhww00bx0jxlpl66ip6v"},{"post_id":"ciw63jhws00bp0jxlxm6c6ph5","tag_id":"ciw63jhwu00br0jxlh3va017i","_id":"ciw63jhww00by0jxl1h2xceau"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhwz00c50jxlx6hr058q"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhx000c60jxloe6o9de7"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","tag_id":"ciw63jhp4000k0jxl6dxtsl10","_id":"ciw63jhx000c70jxl12rml9j6"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","tag_id":"ciw63jhwy00c10jxllgrwg96g","_id":"ciw63jhx000c80jxlbh1gp5xp"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhx000c90jxlf4dweocx"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","tag_id":"ciw63jhwy00c20jxlph82yed2","_id":"ciw63jhx000ca0jxls1i7holg"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","tag_id":"ciw63jhwz00c30jxldi3x3lp8","_id":"ciw63jhx000cb0jxlovy3t31w"},{"post_id":"ciw63jhww00bz0jxl99fyirb0","tag_id":"ciw63jhwz00c40jxl3124jsej","_id":"ciw63jhx000cc0jxl11n1zdug"},{"post_id":"ciw63jhx700cd0jxlmwf8s7tz","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhx800cf0jxl8l61yqcm"},{"post_id":"ciw63jhx700cd0jxlmwf8s7tz","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhx900cg0jxlfs8jew6c"},{"post_id":"ciw63jhx700cd0jxlmwf8s7tz","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63jhx900ch0jxlvb7d5c48"},{"post_id":"ciw63jhx700cd0jxlmwf8s7tz","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhx900ci0jxld3snnf8f"},{"post_id":"ciw63jhxa00cj0jxlokn57yl1","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhxc00co0jxljblasb43"},{"post_id":"ciw63jhxa00cj0jxlokn57yl1","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhxd00cp0jxldfrc34w7"},{"post_id":"ciw63jhxa00cj0jxlokn57yl1","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63jhxd00cq0jxli9lg8ox4"},{"post_id":"ciw63jhxa00cj0jxlokn57yl1","tag_id":"ciw63jhxb00cm0jxlxvh8mi1m","_id":"ciw63jhxd00cr0jxlz721w6mw"},{"post_id":"ciw63jhxa00cj0jxlokn57yl1","tag_id":"ciw63jhxc00cn0jxlltgipqjc","_id":"ciw63jhxd00cs0jxlbreo8ro1"},{"post_id":"ciw63jhxa00cj0jxlokn57yl1","tag_id":"ciw63jhwm00bg0jxl2evdv197","_id":"ciw63jhxd00ct0jxlrx7upw7b"},{"post_id":"ciw63jhxd00cu0jxl2mv4tj77","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhxg00cy0jxlcv5kie5u"},{"post_id":"ciw63jhxd00cu0jxl2mv4tj77","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhxh00cz0jxly5h5766d"},{"post_id":"ciw63jhxd00cu0jxl2mv4tj77","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jhxh00d00jxl27h6l2ta"},{"post_id":"ciw63jhxd00cu0jxl2mv4tj77","tag_id":"ciw63jhxf00cw0jxl8w27xggy","_id":"ciw63jhxh00d10jxlglml1v2a"},{"post_id":"ciw63jhxd00cu0jxl2mv4tj77","tag_id":"ciw63jhwz00c30jxldi3x3lp8","_id":"ciw63jhxh00d20jxlwyg8tm67"},{"post_id":"ciw63jhxd00cu0jxl2mv4tj77","tag_id":"ciw63jhxf00cx0jxldycnzaqz","_id":"ciw63jhxh00d30jxlh8bbvlv6"},{"post_id":"ciw63jhxi00d40jxliobqdimd","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhxk00d60jxl8lc3pcjg"},{"post_id":"ciw63jhxi00d40jxliobqdimd","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhxl00d70jxld39ugn9c"},{"post_id":"ciw63jhxi00d40jxliobqdimd","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jhxl00d80jxlmtobr55m"},{"post_id":"ciw63jhxi00d40jxliobqdimd","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jhxl00d90jxl1rxtfa8h"},{"post_id":"ciw63jhxi00d40jxliobqdimd","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jhxl00da0jxlrq0awjbc"},{"post_id":"ciw63jhxi00d40jxliobqdimd","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jhxl00db0jxlos5ppngu"},{"post_id":"ciw63jhxm00dc0jxlgdx8kafy","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhxo00de0jxlfwczmaw3"},{"post_id":"ciw63jhxm00dc0jxlgdx8kafy","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhxp00df0jxl1qlgdrpj"},{"post_id":"ciw63jhxm00dc0jxlgdx8kafy","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhxp00dg0jxl2rk1bqzi"},{"post_id":"ciw63jhxq00dh0jxlz0w3qc57","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhxz00dj0jxlm63o000q"},{"post_id":"ciw63jhxq00dh0jxlz0w3qc57","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhy100dk0jxlkmukbsyt"},{"post_id":"ciw63jhxq00dh0jxlz0w3qc57","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jhy100dl0jxlqo01suke"},{"post_id":"ciw63jhxq00dh0jxlz0w3qc57","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jhy100dm0jxlelhdshg8"},{"post_id":"ciw63jhxq00dh0jxlz0w3qc57","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jhy200dn0jxlbuzuopi4"},{"post_id":"ciw63jhy300do0jxla3uosqkh","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhy400dq0jxlycwaolqg"},{"post_id":"ciw63jhy300do0jxla3uosqkh","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhy400dr0jxlqmzt322f"},{"post_id":"ciw63jhy300do0jxla3uosqkh","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhy500ds0jxle06ey27p"},{"post_id":"ciw63jhy300do0jxla3uosqkh","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63jhy500dt0jxl8s0wepda"},{"post_id":"ciw63jhy500du0jxldjgae5f4","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhya00dy0jxlkhh90w4o"},{"post_id":"ciw63jhy500du0jxldjgae5f4","tag_id":"ciw63jhvy009v0jxl60b960rt","_id":"ciw63jhyd00dz0jxl4irn7fhl"},{"post_id":"ciw63jhy500du0jxldjgae5f4","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jhyd00e00jxllsinhfc4"},{"post_id":"ciw63jhy500du0jxldjgae5f4","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhyd00e10jxlhsmvnjfz"},{"post_id":"ciw63jhy500du0jxldjgae5f4","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jhyd00e20jxlegiogor0"},{"post_id":"ciw63jhy500du0jxldjgae5f4","tag_id":"ciw63jhy700dw0jxl9jued065","_id":"ciw63jhyd00e30jxlnkh9418p"},{"post_id":"ciw63jhy500du0jxldjgae5f4","tag_id":"ciw63jhy900dx0jxl5sbqxle2","_id":"ciw63jhyd00e40jxlclsaieuy"},{"post_id":"ciw63jhyf00e50jxl2rkktiu2","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhyi00ea0jxlesf3vu4l"},{"post_id":"ciw63jhyf00e50jxl2rkktiu2","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63jhyj00eb0jxlxflz9w35"},{"post_id":"ciw63jhyf00e50jxl2rkktiu2","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jhyj00ec0jxli8lflsch"},{"post_id":"ciw63jhyf00e50jxl2rkktiu2","tag_id":"ciw63jhyh00e80jxlxyjsn7f8","_id":"ciw63jhyj00ed0jxl9w8yom5w"},{"post_id":"ciw63jhyf00e50jxl2rkktiu2","tag_id":"ciw63jhyi00e90jxlt54qj9zw","_id":"ciw63jhyj00ee0jxlujjm0pke"},{"post_id":"ciw63jhyk00ef0jxlfi3hum08","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhym00eh0jxlkdmps7qw"},{"post_id":"ciw63jhyk00ef0jxlfi3hum08","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63jhyo00ei0jxlz2n9sn50"},{"post_id":"ciw63jhyk00ef0jxlfi3hum08","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jhyo00ej0jxlw9bsv4g2"},{"post_id":"ciw63jhyk00ef0jxlfi3hum08","tag_id":"ciw63jhts006c0jxlsgx0aj9d","_id":"ciw63jhyo00ek0jxlgxvdyuxn"},{"post_id":"ciw63jhyk00ef0jxlfi3hum08","tag_id":"ciw63jhy900dx0jxl5sbqxle2","_id":"ciw63jhyo00el0jxl3yy10u2y"},{"post_id":"ciw63jhyk00ef0jxlfi3hum08","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jhyo00em0jxl8r9jvbvj"},{"post_id":"ciw63jhyk00ef0jxlfi3hum08","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jhyo00en0jxlh006clch"},{"post_id":"ciw63jhyt00eo0jxlffxopl90","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhyz00er0jxl6nr5n2qp"},{"post_id":"ciw63jhyt00eo0jxlffxopl90","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63jhz000es0jxlybg45w89"},{"post_id":"ciw63jhyt00eo0jxlffxopl90","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jhz000et0jxls6zcujjv"},{"post_id":"ciw63jhyt00eo0jxlffxopl90","tag_id":"ciw63jhwa00am0jxl8d14vm7y","_id":"ciw63jhz000eu0jxlp3eu94zh"},{"post_id":"ciw63jhyt00eo0jxlffxopl90","tag_id":"ciw63jhyx00eq0jxlr65pzvp5","_id":"ciw63jhz000ev0jxl01qg6fh7"},{"post_id":"ciw63jhyt00eo0jxlffxopl90","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jhz000ew0jxlcifw6gus"},{"post_id":"ciw63jhyt00eo0jxlffxopl90","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jhz000ex0jxlj8flh5qe"},{"post_id":"ciw63jhz100ey0jxlvk5y4o9j","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhz300f10jxl4doc218x"},{"post_id":"ciw63jhz100ey0jxlvk5y4o9j","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63jhz400f20jxlo1tmvmsp"},{"post_id":"ciw63jhz100ey0jxlvk5y4o9j","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jhz400f30jxl39041mgp"},{"post_id":"ciw63jhz100ey0jxlvk5y4o9j","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jhz400f40jxlx3tzhcb0"},{"post_id":"ciw63jhz100ey0jxlvk5y4o9j","tag_id":"ciw63jhz200f00jxlt3em0nmt","_id":"ciw63jhz400f50jxlawpvgv75"},{"post_id":"ciw63jhz600f60jxl1iyckm0a","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhz800f90jxl0e1exkxh"},{"post_id":"ciw63jhz600f60jxl1iyckm0a","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63jhz900fa0jxlmmkb6tev"},{"post_id":"ciw63jhz600f60jxl1iyckm0a","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jhz900fb0jxltdkayj9b"},{"post_id":"ciw63jhz600f60jxl1iyckm0a","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jhz900fc0jxltkmm4br0"},{"post_id":"ciw63jhz600f60jxl1iyckm0a","tag_id":"ciw63jhz800f80jxll7pca22r","_id":"ciw63jhz900fd0jxlhbf5irf6"},{"post_id":"ciw63jhza00fe0jxljp60eehn","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhzf00fg0jxld1e4u6wf"},{"post_id":"ciw63jhza00fe0jxljp60eehn","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63jhzg00fh0jxlvpzq5dzt"},{"post_id":"ciw63jhza00fe0jxljp60eehn","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jhzg00fi0jxlhtppb0w5"},{"post_id":"ciw63jhza00fe0jxljp60eehn","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jhzg00fj0jxlj1ntq9u4"},{"post_id":"ciw63jhzg00fk0jxlepycwmee","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhzj00fn0jxlz43cd757"},{"post_id":"ciw63jhzg00fk0jxlepycwmee","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63jhzk00fo0jxlh6zum8n1"},{"post_id":"ciw63jhzg00fk0jxlepycwmee","tag_id":"ciw63jhty006o0jxlfk01cryd","_id":"ciw63jhzk00fp0jxl3iflb2la"},{"post_id":"ciw63jhzg00fk0jxlepycwmee","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jhzk00fq0jxlr1w5mpry"},{"post_id":"ciw63jhzg00fk0jxlepycwmee","tag_id":"ciw63jhqg002b0jxl534swffv","_id":"ciw63jhzk00fr0jxl3r2hjpsw"},{"post_id":"ciw63jhzg00fk0jxlepycwmee","tag_id":"ciw63jhzi00fm0jxlcysuzkz1","_id":"ciw63jhzk00fs0jxlsde6n3cn"},{"post_id":"ciw63jhzg00fk0jxlepycwmee","tag_id":"ciw63jhu800750jxltqzcqwj9","_id":"ciw63jhzk00ft0jxlz8ncrysw"},{"post_id":"ciw63jhzl00fu0jxl20qrqjn2","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jhzt00fy0jxlc7oli3ki"},{"post_id":"ciw63jhzl00fu0jxl20qrqjn2","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63jhzv00fz0jxlfq07030r"},{"post_id":"ciw63jhzl00fu0jxl20qrqjn2","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jhzv00g00jxlue8cfnwf"},{"post_id":"ciw63jhzl00fu0jxl20qrqjn2","tag_id":"ciw63jhyx00eq0jxlr65pzvp5","_id":"ciw63jhzv00g10jxlbew5gpka"},{"post_id":"ciw63jhzl00fu0jxl20qrqjn2","tag_id":"ciw63jhzr00fw0jxl3ggztg0g","_id":"ciw63jhzv00g20jxlf9s34byk"},{"post_id":"ciw63jhzl00fu0jxl20qrqjn2","tag_id":"ciw63jhzs00fx0jxlpmw6c3oh","_id":"ciw63jhzv00g30jxl6y5f3gs0"},{"post_id":"ciw63jhzx00g40jxlwokto70o","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji0000g60jxl34gwhmxl"},{"post_id":"ciw63jhzx00g40jxlwokto70o","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63ji0000g70jxlqrrn1uxz"},{"post_id":"ciw63jhzx00g40jxlwokto70o","tag_id":"ciw63jhsp004b0jxl4h5p03lp","_id":"ciw63ji0000g80jxlaoruezy5"},{"post_id":"ciw63jhzx00g40jxlwokto70o","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji0000g90jxlmc1nos1l"},{"post_id":"ciw63ji0100ga0jxl1rgx0bca","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji0800gc0jxlrar0x1gu"},{"post_id":"ciw63ji0100ga0jxl1rgx0bca","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63ji0c00gd0jxl8071mozg"},{"post_id":"ciw63ji0100ga0jxl1rgx0bca","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji0c00ge0jxl80kohyth"},{"post_id":"ciw63ji0100ga0jxl1rgx0bca","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63ji0c00gf0jxl7te3beq5"},{"post_id":"ciw63ji0e00gg0jxljymxdo1t","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji0i00gj0jxl9zn16ayx"},{"post_id":"ciw63ji0e00gg0jxljymxdo1t","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63ji0l00gk0jxlkuspb9h4"},{"post_id":"ciw63ji0e00gg0jxljymxdo1t","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63ji0l00gl0jxlu5lfqmc4"},{"post_id":"ciw63ji0e00gg0jxljymxdo1t","tag_id":"ciw63ji0g00gi0jxlpojs1evd","_id":"ciw63ji0l00gm0jxlczwlcr9q"},{"post_id":"ciw63ji0e00gg0jxljymxdo1t","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63ji0m00gn0jxll1tcw8rw"},{"post_id":"ciw63ji0e00gg0jxljymxdo1t","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji0m00go0jxlz1hnswoq"},{"post_id":"ciw63ji0p00gp0jxl2iwuxwuu","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji0v00gt0jxlm8xx0z6m"},{"post_id":"ciw63ji0p00gp0jxl2iwuxwuu","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63ji0w00gu0jxlc6lss2z5"},{"post_id":"ciw63ji0p00gp0jxl2iwuxwuu","tag_id":"ciw63ji0u00gr0jxlxmy6hu0g","_id":"ciw63ji0w00gv0jxlbdqlegix"},{"post_id":"ciw63ji0p00gp0jxl2iwuxwuu","tag_id":"ciw63ji0u00gs0jxliwb5oeoh","_id":"ciw63ji0w00gw0jxl17rfep94"},{"post_id":"ciw63ji0w00gx0jxlg21ghfiw","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji0y00gz0jxl6hlyowfk"},{"post_id":"ciw63ji0w00gx0jxlg21ghfiw","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji1100h00jxl21md73zz"},{"post_id":"ciw63ji0w00gx0jxlg21ghfiw","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63ji1100h10jxl6pwl7n5f"},{"post_id":"ciw63ji0w00gx0jxlg21ghfiw","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63ji1100h20jxlii51ch86"},{"post_id":"ciw63ji0w00gx0jxlg21ghfiw","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63ji1100h30jxlorqhg6c5"},{"post_id":"ciw63ji0w00gx0jxlg21ghfiw","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63ji1100h40jxlqhwwpkdm"},{"post_id":"ciw63ji0w00gx0jxlg21ghfiw","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63ji1100h50jxlrepijoah"},{"post_id":"ciw63ji1300h60jxl3ql6zfy7","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji1800h80jxl7a7bfq07"},{"post_id":"ciw63ji1300h60jxl3ql6zfy7","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63ji1900h90jxlpb6y11td"},{"post_id":"ciw63ji1300h60jxl3ql6zfy7","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63ji1900ha0jxlrdf4dbv6"},{"post_id":"ciw63ji1300h60jxl3ql6zfy7","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63ji1900hb0jxla7p5jqml"},{"post_id":"ciw63ji1b00hc0jxlarebyb5m","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji1c00he0jxlkv78v1xo"},{"post_id":"ciw63ji1b00hc0jxlarebyb5m","tag_id":"ciw63jhyh00e70jxlk5oole8c","_id":"ciw63ji1d00hf0jxl72ahwnzu"},{"post_id":"ciw63ji1b00hc0jxlarebyb5m","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji1d00hg0jxl2j9z3w9h"},{"post_id":"ciw63ji1b00hc0jxlarebyb5m","tag_id":"ciw63jhrw003g0jxlomcv3673","_id":"ciw63ji1d00hh0jxla29dgq4h"},{"post_id":"ciw63ji1e00hi0jxl0rs675r1","tag_id":"ciw63ji1f00hk0jxllq5njkuk","_id":"ciw63ji1j00hm0jxl1npzv4is"},{"post_id":"ciw63ji1e00hi0jxl0rs675r1","tag_id":"ciw63ji1h00hl0jxln71pjqxi","_id":"ciw63ji1m00hn0jxltmxa1whw"},{"post_id":"ciw63ji1e00hi0jxl0rs675r1","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63ji1m00ho0jxltj5gn76j"},{"post_id":"ciw63ji1e00hi0jxl0rs675r1","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63ji1m00hp0jxle0xaggv9"},{"post_id":"ciw63ji1n00hq0jxlsglddarh","tag_id":"ciw63ji1f00hk0jxllq5njkuk","_id":"ciw63ji1u00hv0jxlu437xr1n"},{"post_id":"ciw63ji1n00hq0jxlsglddarh","tag_id":"ciw63ji1s00hs0jxlql3by84v","_id":"ciw63ji1v00hw0jxlffbd7mue"},{"post_id":"ciw63ji1n00hq0jxlsglddarh","tag_id":"ciw63ji1t00ht0jxllabpkffe","_id":"ciw63ji1v00hx0jxl59u262f6"},{"post_id":"ciw63ji1n00hq0jxlsglddarh","tag_id":"ciw63jhwa00am0jxl8d14vm7y","_id":"ciw63ji1v00hy0jxlzj2fuegk"},{"post_id":"ciw63ji1n00hq0jxlsglddarh","tag_id":"ciw63jhwu00br0jxlh3va017i","_id":"ciw63ji1v00hz0jxl7t0gita6"},{"post_id":"ciw63ji1n00hq0jxlsglddarh","tag_id":"ciw63ji1t00hu0jxldz7l04cg","_id":"ciw63ji1v00i00jxlrz2z710r"},{"post_id":"ciw63ji1w00i10jxlkv0xl6av","tag_id":"ciw63ji1f00hk0jxllq5njkuk","_id":"ciw63ji2000i30jxlqirjipkb"},{"post_id":"ciw63ji1w00i10jxlkv0xl6av","tag_id":"ciw63jhsm00430jxlz3455y0p","_id":"ciw63ji2400i40jxlkam7sexa"},{"post_id":"ciw63ji1w00i10jxlkv0xl6av","tag_id":"ciw63jhsm00440jxlt4lia4dr","_id":"ciw63ji2400i50jxl6zog0dkb"},{"post_id":"ciw63ji1w00i10jxlkv0xl6av","tag_id":"ciw63jht7005b0jxlj5mtp6jt","_id":"ciw63ji2400i60jxlmqatbg5l"},{"post_id":"ciw63ji1w00i10jxlkv0xl6av","tag_id":"ciw63jhrw003h0jxldg4y0la6","_id":"ciw63ji2400i70jxl8eicv17b"},{"post_id":"ciw63ji1w00i10jxlkv0xl6av","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63ji2400i80jxlxab4tsra"},{"post_id":"ciw63ji2700i90jxl1qh44l65","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji2a00ic0jxll2shyvxw"},{"post_id":"ciw63ji2700i90jxl1qh44l65","tag_id":"ciw63ji2900ib0jxlxbmquwbo","_id":"ciw63ji2a00id0jxlhhc6wg4r"},{"post_id":"ciw63ji2700i90jxl1qh44l65","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63ji2a00ie0jxl76bn5pwi"},{"post_id":"ciw63ji2700i90jxl1qh44l65","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63ji2b00if0jxlxslzkdm5"},{"post_id":"ciw63ji2700i90jxl1qh44l65","tag_id":"ciw63jhu2006x0jxl0pyk2jka","_id":"ciw63ji2b00ig0jxlajzk4dbe"},{"post_id":"ciw63ji2b00ih0jxlx5jbyndt","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji2e00ij0jxljb5ipnp0"},{"post_id":"ciw63ji2b00ih0jxlx5jbyndt","tag_id":"ciw63ji2900ib0jxlxbmquwbo","_id":"ciw63ji2h00ik0jxl2pue4nme"},{"post_id":"ciw63ji2b00ih0jxlx5jbyndt","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63ji2h00il0jxly9s4c5b4"},{"post_id":"ciw63ji2b00ih0jxlx5jbyndt","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63ji2h00im0jxl9l39wkmm"},{"post_id":"ciw63ji2b00ih0jxlx5jbyndt","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63ji2h00in0jxl0cgj6uxj"},{"post_id":"ciw63ji2l00io0jxl0mk62xlj","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji2q00iq0jxl74iifcwq"},{"post_id":"ciw63ji2l00io0jxl0mk62xlj","tag_id":"ciw63ji2900ib0jxlxbmquwbo","_id":"ciw63ji2r00ir0jxl57ppguuo"},{"post_id":"ciw63ji2l00io0jxl0mk62xlj","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63ji2r00is0jxlzum9q4ol"},{"post_id":"ciw63ji2l00io0jxl0mk62xlj","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63ji2r00it0jxlplx94n54"},{"post_id":"ciw63ji2l00io0jxl0mk62xlj","tag_id":"ciw63jhwa00am0jxl8d14vm7y","_id":"ciw63ji2r00iu0jxlo8xzz9ap"},{"post_id":"ciw63ji2r00iv0jxl56teognz","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji2u00ix0jxlfe954mgh"},{"post_id":"ciw63ji2r00iv0jxl56teognz","tag_id":"ciw63ji2900ib0jxlxbmquwbo","_id":"ciw63ji2x00iy0jxlwok210j1"},{"post_id":"ciw63ji2r00iv0jxl56teognz","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63ji2x00iz0jxlduf1qz7a"},{"post_id":"ciw63ji2r00iv0jxl56teognz","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63ji2x00j00jxl16w38bgv"},{"post_id":"ciw63ji2r00iv0jxl56teognz","tag_id":"ciw63jhzi00fm0jxlcysuzkz1","_id":"ciw63ji2x00j10jxlpcv44vz8"},{"post_id":"ciw63ji3100j20jxlpbo9n3u5","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63ji3600j40jxlq56ljp1z"},{"post_id":"ciw63ji3100j20jxlpbo9n3u5","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63ji3700j50jxldzirbhzj"},{"post_id":"ciw63ji3100j20jxlpbo9n3u5","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63ji3700j60jxlybjowmjd"},{"post_id":"ciw63ji3100j20jxlpbo9n3u5","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63ji3700j70jxlxzw1u8vr"},{"post_id":"ciw63ji4a00j80jxl1gazm2mr","tag_id":"ciw63jhuf007n0jxll83ky6ks","_id":"ciw63ji4i00ja0jxl7m3rpfph"},{"post_id":"ciw63ji4a00j80jxl1gazm2mr","tag_id":"ciw63ji0u00gs0jxliwb5oeoh","_id":"ciw63ji4k00jb0jxl6gfzvltk"},{"post_id":"ciw63ji4a00j80jxl1gazm2mr","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63ji4k00jc0jxl5c8yhqob"},{"post_id":"ciw63ji4a00j80jxl1gazm2mr","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63ji4k00jd0jxl9futswyx"},{"post_id":"ciw63ji4a00j80jxl1gazm2mr","tag_id":"ciw63jhty006o0jxlfk01cryd","_id":"ciw63ji4k00je0jxlf6nx699z"},{"post_id":"ciw63ji4a00j80jxl1gazm2mr","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63ji4k00jf0jxlz5oowlji"},{"post_id":"ciw63ji4n00ji0jxlmtc0obw5","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji4s00jl0jxlsfwkxso0"},{"post_id":"ciw63ji4n00ji0jxlmtc0obw5","tag_id":"ciw63jhq3001p0jxluez7uhi5","_id":"ciw63ji4t00jm0jxlpdal391j"},{"post_id":"ciw63ji4v00jn0jxld7ik8eru","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji5100jq0jxlfrhtpsyt"},{"post_id":"ciw63ji4v00jn0jxld7ik8eru","tag_id":"ciw63ji5000jp0jxlxobkecs3","_id":"ciw63ji5100jr0jxlamwmvf1i"},{"post_id":"ciw63ji4v00jn0jxld7ik8eru","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63ji5100js0jxltmjquhhr"},{"post_id":"ciw63ji5i00jt0jxlhvrk8prx","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji5k00jv0jxlnduvlfd1"},{"post_id":"ciw63ji5i00jt0jxlhvrk8prx","tag_id":"ciw63ji5000jp0jxlxobkecs3","_id":"ciw63ji5m00jw0jxlyqfg62xn"},{"post_id":"ciw63ji5i00jt0jxlhvrk8prx","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63ji5m00jx0jxlbtrd9og3"},{"post_id":"ciw63ji5i00jt0jxlhvrk8prx","tag_id":"ciw63jht7005b0jxlj5mtp6jt","_id":"ciw63ji5m00jy0jxlysg031fn"},{"post_id":"ciw63ji5o00jz0jxlbbzi2bed","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji5w00k20jxl4f4g8bqi"},{"post_id":"ciw63ji5o00jz0jxlbbzi2bed","tag_id":"ciw63ji5u00k10jxl5uu29u23","_id":"ciw63ji5x00k30jxlwwmckv7c"},{"post_id":"ciw63ji5x00k40jxlr168hhms","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji6000k70jxl7dqkvckz"},{"post_id":"ciw63ji5x00k40jxlr168hhms","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji6100k80jxl17psp8ud"},{"post_id":"ciw63ji5x00k40jxlr168hhms","tag_id":"ciw63ji5z00k60jxlrjezqo7f","_id":"ciw63ji6100k90jxlfufk51sd"},{"post_id":"ciw63ji5x00k40jxlr168hhms","tag_id":"ciw63jht200530jxl3bf9aj93","_id":"ciw63ji6100ka0jxlypbbq0pi"},{"post_id":"ciw63ji6100kb0jxl78v23ri9","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji6b00kf0jxl3g7j2b32"},{"post_id":"ciw63ji6100kb0jxl78v23ri9","tag_id":"ciw63ji6600kd0jxlvnzxded6","_id":"ciw63ji6c00kg0jxl4k6cirvb"},{"post_id":"ciw63ji6100kb0jxl78v23ri9","tag_id":"ciw63ji0u00gr0jxlxmy6hu0g","_id":"ciw63ji6c00kh0jxllgi1vfl5"},{"post_id":"ciw63ji6100kb0jxl78v23ri9","tag_id":"ciw63ji6900ke0jxla7jxzo29","_id":"ciw63ji6c00ki0jxlcysglro4"},{"post_id":"ciw63ji6e00kj0jxlpa2aval8","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji6g00kl0jxlywwou2mu"},{"post_id":"ciw63ji6e00kj0jxlpa2aval8","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji6h00km0jxln7busre1"},{"post_id":"ciw63ji6e00kj0jxlpa2aval8","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji6h00kn0jxlklovmjbb"},{"post_id":"ciw63ji6e00kj0jxlpa2aval8","tag_id":"ciw63jhwm00bg0jxl2evdv197","_id":"ciw63ji6h00ko0jxl674b6ndb"},{"post_id":"ciw63ji6h00kp0jxld0pde07f","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji6l00kr0jxl6lmsye5v"},{"post_id":"ciw63ji6h00kp0jxld0pde07f","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji6l00ks0jxlgiprm7hv"},{"post_id":"ciw63ji6h00kp0jxld0pde07f","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji6l00kt0jxlp6sceg1j"},{"post_id":"ciw63ji6m00ku0jxlusw0v9u6","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji6q00kw0jxlgfiy0lnb"},{"post_id":"ciw63ji6m00ku0jxlusw0v9u6","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji6r00kx0jxl0w4v1u7w"},{"post_id":"ciw63ji6m00ku0jxlusw0v9u6","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji6r00ky0jxlhoj62r6b"},{"post_id":"ciw63ji6m00ku0jxlusw0v9u6","tag_id":"ciw63ji0u00gr0jxlxmy6hu0g","_id":"ciw63ji6r00kz0jxlspsi1b95"},{"post_id":"ciw63ji6s00l00jxl0ksb0u9r","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji6x00l30jxl9tmenk8r"},{"post_id":"ciw63ji6s00l00jxl0ksb0u9r","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji6z00l40jxl421wp12f"},{"post_id":"ciw63ji6s00l00jxl0ksb0u9r","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji6z00l50jxlv130a5jv"},{"post_id":"ciw63ji6s00l00jxl0ksb0u9r","tag_id":"ciw63ji6w00l20jxlzspld2po","_id":"ciw63ji6z00l60jxl1f0pfqq0"},{"post_id":"ciw63ji6s00l00jxl0ksb0u9r","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63ji6z00l70jxlo02jjb50"},{"post_id":"ciw63ji7000l80jxl8rg8yhez","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji7300la0jxl0cmyv5gy"},{"post_id":"ciw63ji7000l80jxl8rg8yhez","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji7400lb0jxlvo3ip89l"},{"post_id":"ciw63ji7000l80jxl8rg8yhez","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63ji7400lc0jxlgf6fth50"},{"post_id":"ciw63ji7000l80jxl8rg8yhez","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji7400ld0jxljzqqtnhz"},{"post_id":"ciw63ji7000l80jxl8rg8yhez","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63ji7400le0jxlymk15ai8"},{"post_id":"ciw63ji7500lf0jxl11ef297x","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji7800li0jxlvchllcn5"},{"post_id":"ciw63ji7500lf0jxl11ef297x","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji7900lj0jxltlbabmcy"},{"post_id":"ciw63ji7500lf0jxl11ef297x","tag_id":"ciw63ji0u00gr0jxlxmy6hu0g","_id":"ciw63ji7900lk0jxl3gbnx7jz"},{"post_id":"ciw63ji7500lf0jxl11ef297x","tag_id":"ciw63jhqk002k0jxliuhphaht","_id":"ciw63ji7900ll0jxlbbxjyk1u"},{"post_id":"ciw63ji7500lf0jxl11ef297x","tag_id":"ciw63ji7700lh0jxlq8uctxec","_id":"ciw63ji7900lm0jxlpqf8foi2"},{"post_id":"ciw63ji7500lf0jxl11ef297x","tag_id":"ciw63ji6900ke0jxla7jxzo29","_id":"ciw63ji7900ln0jxle5evjukg"},{"post_id":"ciw63ji7a00lo0jxl3as39urf","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji7d00lr0jxl9xlhqsh2"},{"post_id":"ciw63ji7a00lo0jxl3as39urf","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji7e00ls0jxlvn9oftvg"},{"post_id":"ciw63ji7a00lo0jxl3as39urf","tag_id":"ciw63ji7c00lq0jxl7tnit143","_id":"ciw63ji7e00lt0jxlgy219taa"},{"post_id":"ciw63ji7a00lo0jxl3as39urf","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63ji7e00lu0jxl2sek10ei"},{"post_id":"ciw63ji7f00lv0jxl2nct5vvp","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji7h00lx0jxlrz75beez"},{"post_id":"ciw63ji7f00lv0jxl2nct5vvp","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji7h00ly0jxl2p8xhex5"},{"post_id":"ciw63ji7f00lv0jxl2nct5vvp","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63ji7i00lz0jxlia3qua2o"},{"post_id":"ciw63ji7i00m00jxlx7op7ycf","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji7l00m20jxlhcryfuhx"},{"post_id":"ciw63ji7i00m00jxlx7op7ycf","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji7m00m30jxlwq8648ib"},{"post_id":"ciw63ji7i00m00jxlx7op7ycf","tag_id":"ciw63jhte005o0jxllyywhtlr","_id":"ciw63ji7m00m40jxl4b557y02"},{"post_id":"ciw63ji7i00m00jxlx7op7ycf","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63ji7m00m50jxlsppoj7dd"},{"post_id":"ciw63ji7i00m00jxlx7op7ycf","tag_id":"ciw63jhxf00cw0jxl8w27xggy","_id":"ciw63ji7m00m60jxlgdhbqc6q"},{"post_id":"ciw63ji7i00m00jxlx7op7ycf","tag_id":"ciw63jhst004k0jxl42nd9rzx","_id":"ciw63ji7m00m70jxloqwam832"},{"post_id":"ciw63ji7n00m80jxlb1jydej2","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji7p00ma0jxlal9kbkyx"},{"post_id":"ciw63ji7n00m80jxlb1jydej2","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji7q00mb0jxl8daeei00"},{"post_id":"ciw63ji7n00m80jxlb1jydej2","tag_id":"ciw63jhz800f80jxll7pca22r","_id":"ciw63ji7q00mc0jxlh9n94wuk"},{"post_id":"ciw63ji7r00md0jxlki46vz8z","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji7v00mh0jxleke4f75v"},{"post_id":"ciw63ji7r00md0jxlki46vz8z","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji7x00mi0jxlhwz6f810"},{"post_id":"ciw63ji7r00md0jxlki46vz8z","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63ji7x00mj0jxl3lk4naa6"},{"post_id":"ciw63ji7r00md0jxlki46vz8z","tag_id":"ciw63ji7t00mf0jxllk4ai0oq","_id":"ciw63ji7x00mk0jxlu8qr7qc8"},{"post_id":"ciw63ji7r00md0jxlki46vz8z","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63ji7x00ml0jxlvvkxsd91"},{"post_id":"ciw63ji7r00md0jxlki46vz8z","tag_id":"ciw63ji7u00mg0jxlsokmflc4","_id":"ciw63ji7x00mm0jxlal5ushvl"},{"post_id":"ciw63ji7x00mn0jxlfbcd3klw","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji8000mp0jxlm4gc3046"},{"post_id":"ciw63ji7x00mn0jxlfbcd3klw","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji8100mq0jxl1hmtcdpz"},{"post_id":"ciw63ji7x00mn0jxlfbcd3klw","tag_id":"ciw63ji7t00mf0jxllk4ai0oq","_id":"ciw63ji8100mr0jxlsmfbd0u4"},{"post_id":"ciw63ji7x00mn0jxlfbcd3klw","tag_id":"ciw63jhz800f80jxll7pca22r","_id":"ciw63ji8100ms0jxlih0q4bqt"},{"post_id":"ciw63ji7x00mn0jxlfbcd3klw","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63ji8100mt0jxlpldzta12"},{"post_id":"ciw63ji8300mu0jxln6hvfxr0","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji8600mz0jxl68aavegt"},{"post_id":"ciw63ji8300mu0jxln6hvfxr0","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji8800n00jxl1g1xxztg"},{"post_id":"ciw63ji8300mu0jxln6hvfxr0","tag_id":"ciw63ji8400mw0jxlupnspxrk","_id":"ciw63ji8800n10jxlfdjldqkj"},{"post_id":"ciw63ji8300mu0jxln6hvfxr0","tag_id":"ciw63ji8500mx0jxly8x04au4","_id":"ciw63ji8800n20jxlk2cyxyjw"},{"post_id":"ciw63ji8300mu0jxln6hvfxr0","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63ji8800n30jxle9zo9hsm"},{"post_id":"ciw63ji8300mu0jxln6hvfxr0","tag_id":"ciw63jhwa00am0jxl8d14vm7y","_id":"ciw63ji8800n40jxlk1jnwbtg"},{"post_id":"ciw63ji8300mu0jxln6hvfxr0","tag_id":"ciw63ji8600my0jxlof6ie4v3","_id":"ciw63ji8800n50jxlv6od40qb"},{"post_id":"ciw63ji8900n60jxl519665nt","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji8e00n90jxltb17i0y0"},{"post_id":"ciw63ji8900n60jxl519665nt","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji8g00na0jxlqm1i0fw2"},{"post_id":"ciw63ji8900n60jxl519665nt","tag_id":"ciw63ji6900ke0jxla7jxzo29","_id":"ciw63ji8g00nb0jxlh9z2lgmj"},{"post_id":"ciw63ji8900n60jxl519665nt","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji8g00nc0jxl0pksjdu9"},{"post_id":"ciw63ji8900n60jxl519665nt","tag_id":"ciw63ji8b00n80jxllu45i47s","_id":"ciw63ji8g00nd0jxldpobez8l"},{"post_id":"ciw63ji8h00ne0jxlw6ja836i","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji8j00ng0jxlxxfuoesk"},{"post_id":"ciw63ji8h00ne0jxlw6ja836i","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji8k00nh0jxle9pjf92g"},{"post_id":"ciw63ji8h00ne0jxlw6ja836i","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji8k00ni0jxlkt92lyhy"},{"post_id":"ciw63ji8h00ne0jxlw6ja836i","tag_id":"ciw63jhte005o0jxllyywhtlr","_id":"ciw63ji8k00nj0jxlmdz5woam"},{"post_id":"ciw63ji8h00ne0jxlw6ja836i","tag_id":"ciw63jhrw003g0jxlomcv3673","_id":"ciw63ji8k00nk0jxl6ec8r3wx"},{"post_id":"ciw63ji8l00nl0jxllush6kxt","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji8n00nn0jxlf08obdiv"},{"post_id":"ciw63ji8l00nl0jxllush6kxt","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji8p00no0jxl4g248rce"},{"post_id":"ciw63ji8l00nl0jxllush6kxt","tag_id":"ciw63jhte005o0jxllyywhtlr","_id":"ciw63ji8p00np0jxlthwkl4vh"},{"post_id":"ciw63ji8l00nl0jxllush6kxt","tag_id":"ciw63ji8400mw0jxlupnspxrk","_id":"ciw63ji8p00nq0jxl3eqltlyt"},{"post_id":"ciw63ji8l00nl0jxllush6kxt","tag_id":"ciw63jhz200f00jxlt3em0nmt","_id":"ciw63ji8p00nr0jxlvyl9umje"},{"post_id":"ciw63ji8l00nl0jxllush6kxt","tag_id":"ciw63ji8500mx0jxly8x04au4","_id":"ciw63ji8p00ns0jxlz80th5to"},{"post_id":"ciw63ji8l00nl0jxllush6kxt","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63ji8p00nt0jxl8zihk0jx"},{"post_id":"ciw63ji8q00nu0jxl91wqcyc7","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji8s00nw0jxllfda5w3q"},{"post_id":"ciw63ji8q00nu0jxl91wqcyc7","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji8u00nx0jxl4q88dy60"},{"post_id":"ciw63ji8q00nu0jxl91wqcyc7","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji8u00ny0jxlgyh2xtc4"},{"post_id":"ciw63ji8q00nu0jxl91wqcyc7","tag_id":"ciw63jhte005p0jxlni7rbi2h","_id":"ciw63ji8u00nz0jxlewvo3zkq"},{"post_id":"ciw63ji8q00nu0jxl91wqcyc7","tag_id":"ciw63ji8500mx0jxly8x04au4","_id":"ciw63ji8u00o00jxlt65565vd"},{"post_id":"ciw63ji8q00nu0jxl91wqcyc7","tag_id":"ciw63jhte005o0jxllyywhtlr","_id":"ciw63ji8u00o10jxlpsf4tl9z"},{"post_id":"ciw63ji8v00o20jxluffykmg8","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji8x00o40jxl1a6xo5nv"},{"post_id":"ciw63ji8v00o20jxluffykmg8","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63ji8y00o50jxl0bhsyxqt"},{"post_id":"ciw63ji8v00o20jxluffykmg8","tag_id":"ciw63ji4q00jk0jxliceqg0s2","_id":"ciw63ji8y00o60jxlvsp2hyep"},{"post_id":"ciw63ji8v00o20jxluffykmg8","tag_id":"ciw63jhte005p0jxlni7rbi2h","_id":"ciw63ji8y00o70jxlhr4xw2jh"},{"post_id":"ciw63ji9100o80jxlamv8t5n4","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63ji9400ob0jxlpr0slddq"},{"post_id":"ciw63ji9100o80jxlamv8t5n4","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji9500oc0jxlr6krr84h"},{"post_id":"ciw63ji9100o80jxlamv8t5n4","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63ji9500od0jxle8di6aee"},{"post_id":"ciw63ji9600oe0jxlrllepmdx","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji9b00og0jxlthuznki4"},{"post_id":"ciw63ji9600oe0jxlrllepmdx","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63ji9d00oh0jxltawama8s"},{"post_id":"ciw63ji9600oe0jxlrllepmdx","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63ji9d00oi0jxlc5z1wrz7"},{"post_id":"ciw63ji9600oe0jxlrllepmdx","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63ji9d00oj0jxl6gu16mu0"},{"post_id":"ciw63ji9600oe0jxlrllepmdx","tag_id":"ciw63jhu2006x0jxl0pyk2jka","_id":"ciw63ji9d00ok0jxlvax06dht"},{"post_id":"ciw63ji9e00ol0jxl22hg3d0r","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63ji9g00on0jxlgpuyv6rq"},{"post_id":"ciw63ji9e00ol0jxl22hg3d0r","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji9h00oo0jxlma5z5gt6"},{"post_id":"ciw63ji9e00ol0jxl22hg3d0r","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63ji9h00op0jxlkydu4xo0"},{"post_id":"ciw63ji9e00ol0jxl22hg3d0r","tag_id":"ciw63ji6w00l20jxlzspld2po","_id":"ciw63ji9h00oq0jxldu6c3y2p"},{"post_id":"ciw63ji9h00or0jxljgkyge18","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63ji9j00ot0jxlg04seeb7"},{"post_id":"ciw63ji9h00or0jxljgkyge18","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji9l00ou0jxldfm2r7ea"},{"post_id":"ciw63ji9h00or0jxljgkyge18","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63ji9l00ov0jxlwpqq99e7"},{"post_id":"ciw63ji9h00or0jxljgkyge18","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63ji9l00ow0jxlj5rzui4c"},{"post_id":"ciw63ji9h00or0jxljgkyge18","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63ji9l00ox0jxlm2lvhrvf"},{"post_id":"ciw63ji9l00oy0jxlkk7qscrm","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63ji9r00p30jxlvk862ws1"},{"post_id":"ciw63ji9l00oy0jxlkk7qscrm","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji9t00p40jxlxfhvd1p5"},{"post_id":"ciw63ji9l00oy0jxlkk7qscrm","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji9t00p50jxl3bvdbn61"},{"post_id":"ciw63ji9l00oy0jxlkk7qscrm","tag_id":"ciw63ji9n00p00jxl8j5hpo8r","_id":"ciw63ji9u00p60jxl7e5gril7"},{"post_id":"ciw63ji9l00oy0jxlkk7qscrm","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63ji9u00p70jxl1g973xqw"},{"post_id":"ciw63ji9l00oy0jxlkk7qscrm","tag_id":"ciw63ji9o00p10jxlgas15ww1","_id":"ciw63ji9u00p80jxldqc92lcs"},{"post_id":"ciw63ji9l00oy0jxlkk7qscrm","tag_id":"ciw63ji9q00p20jxlt1i1lzay","_id":"ciw63ji9u00p90jxlord3nt6i"},{"post_id":"ciw63ji9u00pa0jxlt7vc9165","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63ji9x00pc0jxlxvotbwqk"},{"post_id":"ciw63ji9u00pa0jxlt7vc9165","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63ji9y00pd0jxl0j1t7v3u"},{"post_id":"ciw63ji9u00pa0jxlt7vc9165","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63ji9y00pe0jxlyg5shiws"},{"post_id":"ciw63ji9u00pa0jxlt7vc9165","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63ji9y00pf0jxldnstb8b6"},{"post_id":"ciw63ji9u00pa0jxlt7vc9165","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63ji9y00pg0jxlise2n3h9"},{"post_id":"ciw63ji9u00pa0jxlt7vc9165","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63ji9y00ph0jxl8tnzd2lg"},{"post_id":"ciw63ji9z00pi0jxlsroyq9l5","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jia200pl0jxloeojigl4"},{"post_id":"ciw63ji9z00pi0jxlsroyq9l5","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jia300pm0jxlqpow121i"},{"post_id":"ciw63ji9z00pi0jxlsroyq9l5","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jia300pn0jxljf5cce5x"},{"post_id":"ciw63ji9z00pi0jxlsroyq9l5","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jia400po0jxlbjc99us6"},{"post_id":"ciw63ji9z00pi0jxlsroyq9l5","tag_id":"ciw63jia100pk0jxlktye1yxo","_id":"ciw63jia400pp0jxlo7a1xhmf"},{"post_id":"ciw63ji9z00pi0jxlsroyq9l5","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jia400pq0jxl09m8ah1h"},{"post_id":"ciw63jia500pr0jxla8w03zeh","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jia900pv0jxljqolk77q"},{"post_id":"ciw63jia500pr0jxla8w03zeh","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiaa00pw0jxl4qa7un25"},{"post_id":"ciw63jia500pr0jxla8w03zeh","tag_id":"ciw63jia700pt0jxlqqbgkwv1","_id":"ciw63jiaa00px0jxl6r4naksk"},{"post_id":"ciw63jia500pr0jxla8w03zeh","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jiaa00py0jxlv8bxxtfv"},{"post_id":"ciw63jia500pr0jxla8w03zeh","tag_id":"ciw63jia800pu0jxl7woznesy","_id":"ciw63jiaa00pz0jxlaid1hotf"},{"post_id":"ciw63jiab00q00jxlodj9h0wr","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jiad00q20jxl5e48mzmt"},{"post_id":"ciw63jiab00q00jxlodj9h0wr","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiaf00q30jxlc4k6wl69"},{"post_id":"ciw63jiab00q00jxlodj9h0wr","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jiaf00q40jxlq1cu9qdy"},{"post_id":"ciw63jiab00q00jxlodj9h0wr","tag_id":"ciw63jhti005x0jxl1yljboft","_id":"ciw63jiaf00q50jxl8llfqrig"},{"post_id":"ciw63jiab00q00jxlodj9h0wr","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jiaf00q60jxlib9onfz3"},{"post_id":"ciw63jiag00q70jxlfyvo3irb","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jiai00q90jxls2h4hm1l"},{"post_id":"ciw63jiag00q70jxlfyvo3irb","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiaj00qa0jxl8z8c92m1"},{"post_id":"ciw63jiag00q70jxlfyvo3irb","tag_id":"ciw63ji1h00hl0jxln71pjqxi","_id":"ciw63jiaj00qb0jxl24i7g10d"},{"post_id":"ciw63jiag00q70jxlfyvo3irb","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jiaj00qc0jxlzy48w4kk"},{"post_id":"ciw63jiak00qd0jxln1g31rxu","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jian00qf0jxl8s68yhtk"},{"post_id":"ciw63jiak00qd0jxln1g31rxu","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiao00qg0jxl7x3wv64d"},{"post_id":"ciw63jiak00qd0jxln1g31rxu","tag_id":"ciw63jhvz009y0jxl5ah0p6x5","_id":"ciw63jiao00qh0jxlh6or352j"},{"post_id":"ciw63jiak00qd0jxln1g31rxu","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jiao00qi0jxloixiyhk6"},{"post_id":"ciw63jiao00qj0jxl2dalvs1v","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jiar00qm0jxlzks21o0f"},{"post_id":"ciw63jiao00qj0jxl2dalvs1v","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jias00qn0jxld26wkx18"},{"post_id":"ciw63jiao00qj0jxl2dalvs1v","tag_id":"ciw63jiaq00ql0jxly8oj7y4t","_id":"ciw63jias00qo0jxllv9a8bad"},{"post_id":"ciw63jiao00qj0jxl2dalvs1v","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jias00qp0jxl2pb97s22"},{"post_id":"ciw63jiat00qq0jxl2b1oaoql","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jiav00qs0jxlm1cu99qs"},{"post_id":"ciw63jiat00qq0jxl2b1oaoql","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiaw00qt0jxl0ysqoe9v"},{"post_id":"ciw63jiat00qq0jxl2b1oaoql","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiaw00qu0jxl3fgv78zt"},{"post_id":"ciw63jiat00qq0jxl2b1oaoql","tag_id":"ciw63jhqo002s0jxl0vvekmbq","_id":"ciw63jiaw00qv0jxlvsemcrlb"},{"post_id":"ciw63jiax00qw0jxl0no0pyd0","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jiaz00qy0jxlfa3megwj"},{"post_id":"ciw63jiax00qw0jxl0no0pyd0","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jib000qz0jxlnz2k78en"},{"post_id":"ciw63jiax00qw0jxl0no0pyd0","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jib000r00jxlcweywlpp"},{"post_id":"ciw63jiax00qw0jxl0no0pyd0","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jib000r10jxl9oud98q9"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jib400r50jxlsloq9101"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jib600r60jxlvtg6q0zk"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jib600r70jxldbcynfxk"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jib600r80jxlsh9302sz"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jib600r90jxl0mcdd0zq"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jib600ra0jxlq8rh323q"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","tag_id":"ciw63jib300r40jxlp8bezx1h","_id":"ciw63jib600rb0jxlt1in7zl3"},{"post_id":"ciw63jib100r20jxlqtbqzxgl","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jib600rc0jxlhoroo5w8"},{"post_id":"ciw63jib800rd0jxlk9cqge99","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jibd00rf0jxlgbmz6qda"},{"post_id":"ciw63jib800rd0jxlk9cqge99","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jibg00rg0jxlmzm7z2ft"},{"post_id":"ciw63jib800rd0jxlk9cqge99","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jibh00rh0jxl7lfma6hv"},{"post_id":"ciw63jib800rd0jxlk9cqge99","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jibh00ri0jxl7drxlc4f"},{"post_id":"ciw63jib800rd0jxlk9cqge99","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jibh00rj0jxl33drwhuz"},{"post_id":"ciw63jib800rd0jxlk9cqge99","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jibh00rk0jxlx1j16zjo"},{"post_id":"ciw63jibj00rl0jxlc6dqbnkh","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jibl00rn0jxlrr0lmpgt"},{"post_id":"ciw63jibj00rl0jxlc6dqbnkh","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jibo00ro0jxlwwxk8awl"},{"post_id":"ciw63jibj00rl0jxlc6dqbnkh","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jibo00rp0jxlbb98rjs7"},{"post_id":"ciw63jibj00rl0jxlc6dqbnkh","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jibo00rq0jxl6dzzu6lf"},{"post_id":"ciw63jibj00rl0jxlc6dqbnkh","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jibo00rr0jxl0uph0gvk"},{"post_id":"ciw63jibp00rs0jxluhik0vjt","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jibr00ru0jxlyrwdfufy"},{"post_id":"ciw63jibp00rs0jxluhik0vjt","tag_id":"ciw63ji9300oa0jxl2rzilnef","_id":"ciw63jibs00rv0jxla2qd6g3s"},{"post_id":"ciw63jibp00rs0jxluhik0vjt","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63jibs00rw0jxldlr4iqki"},{"post_id":"ciw63jibs00rx0jxl9p8xsxbm","tag_id":"ciw63jibu00rz0jxl3n33qhuq","_id":"ciw63jibw00s00jxl3fzmog14"},{"post_id":"ciw63jibs00rx0jxl9p8xsxbm","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jibx00s10jxlyk10ehzp"},{"post_id":"ciw63jibs00rx0jxl9p8xsxbm","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jibx00s20jxluhoh4x0q"},{"post_id":"ciw63jibs00rx0jxl9p8xsxbm","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jibx00s30jxl5ytmw0mt"},{"post_id":"ciw63jic200s40jxlprk119po","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jic500s60jxlukzcpe23"},{"post_id":"ciw63jic200s40jxlprk119po","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jic600s70jxlbo6ybjq7"},{"post_id":"ciw63jic200s40jxlprk119po","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jic600s80jxlrx8yl9i9"},{"post_id":"ciw63jic200s40jxlprk119po","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jic600s90jxlr80ea0vb"},{"post_id":"ciw63jic200s40jxlprk119po","tag_id":"ciw63jhst004k0jxl42nd9rzx","_id":"ciw63jic600sa0jxlwr7hc1ed"},{"post_id":"ciw63jic800sb0jxlkq5icu9z","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jicf00sd0jxl71ir6alo"},{"post_id":"ciw63jic800sb0jxlkq5icu9z","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jich00se0jxlxih4krlf"},{"post_id":"ciw63jic800sb0jxlkq5icu9z","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jich00sf0jxlhs1x77iv"},{"post_id":"ciw63jic800sb0jxlkq5icu9z","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jich00sg0jxl339tes6n"},{"post_id":"ciw63jic800sb0jxlkq5icu9z","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jich00sh0jxlxl75ham1"},{"post_id":"ciw63jici00si0jxlec496in3","tag_id":"ciw63jicm00sk0jxlbe3dhlkf","_id":"ciw63jicp00sl0jxlt76hwtbx"},{"post_id":"ciw63jici00si0jxlec496in3","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jicr00sm0jxlzu0pep2m"},{"post_id":"ciw63jici00si0jxlec496in3","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jicr00sn0jxlq88wp851"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63jicv00sq0jxlg1m6zcnw","_id":"ciw63jicz00ss0jxl5e9gxz7q"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63ji1f00hk0jxllq5njkuk","_id":"ciw63jid400st0jxlm02y5w87"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63ji1s00hs0jxlql3by84v","_id":"ciw63jid400su0jxlecxz52yv"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63jhz800f80jxll7pca22r","_id":"ciw63jid400sv0jxlebtnjgka"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jid400sw0jxlpu9qb7lu"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jid400sx0jxl9pgnuqln"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63jid400sy0jxl9m8yrr09"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63jicx00sr0jxlgli6xmsp","_id":"ciw63jid400sz0jxlrchuy2ar"},{"post_id":"ciw63jict00so0jxlneecr25r","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jid400t00jxl6g470k5u"},{"post_id":"ciw63jid600t10jxl6w98ehvc","tag_id":"ciw63jidc00t30jxl9cqnsgf4","_id":"ciw63jidg00t60jxlqvm7zkn4"},{"post_id":"ciw63jid600t10jxl6w98ehvc","tag_id":"ciw63jide00t40jxl4fo316ru","_id":"ciw63jidh00t70jxlwjo2c8vg"},{"post_id":"ciw63jid600t10jxl6w98ehvc","tag_id":"ciw63jidf00t50jxl9rntdghy","_id":"ciw63jidh00t80jxlh3ag1di7"},{"post_id":"ciw63jidw00tb0jxl6j1hhhvl","tag_id":"ciw63jhy900dx0jxl5sbqxle2","_id":"ciw63jie100td0jxlw0x1s7gd"},{"post_id":"ciw63jidw00tb0jxl6j1hhhvl","tag_id":"ciw63jhy700dw0jxl9jued065","_id":"ciw63jie600te0jxlqve6j73p"},{"post_id":"ciw63jidw00tb0jxl6j1hhhvl","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jie600tf0jxl8fw6jm4b"},{"post_id":"ciw63jidw00tb0jxl6j1hhhvl","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jie600tg0jxlwv0l7v37"},{"post_id":"ciw63jidw00tb0jxl6j1hhhvl","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jie600th0jxljpyp3yiq"},{"post_id":"ciw63jidw00tb0jxl6j1hhhvl","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jie600ti0jxl5mlghyqw"},{"post_id":"ciw63jie700tj0jxlonjcgtqk","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jiea00tl0jxlo1ij3fl3"},{"post_id":"ciw63jie700tj0jxlonjcgtqk","tag_id":"ciw63ji1h00hl0jxln71pjqxi","_id":"ciw63jiec00tm0jxlsbdoc877"},{"post_id":"ciw63jie700tj0jxlonjcgtqk","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jiec00tn0jxlmv3cqqgt"},{"post_id":"ciw63jie700tj0jxlonjcgtqk","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jiec00to0jxlfjn3f9nt"},{"post_id":"ciw63jie700tj0jxlonjcgtqk","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jiec00tp0jxljdshlpzm"},{"post_id":"ciw63jiec00tq0jxlyv5j1pe6","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jiej00tu0jxlm51px6uz"},{"post_id":"ciw63jiec00tq0jxlyv5j1pe6","tag_id":"ciw63jieh00tt0jxl1u35xk15","_id":"ciw63jiek00tv0jxlqz7dgz9a"},{"post_id":"ciw63jiec00tq0jxlyv5j1pe6","tag_id":"ciw63jhyi00e90jxlt54qj9zw","_id":"ciw63jiek00tw0jxltym02baa"},{"post_id":"ciw63jiec00tq0jxlyv5j1pe6","tag_id":"ciw63jhwh00b70jxl6btias08","_id":"ciw63jiel00tx0jxli5adbnlv"},{"post_id":"ciw63jiel00ty0jxlknqpsk0u","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jieo00u00jxl4rwyew18"},{"post_id":"ciw63jiel00ty0jxlknqpsk0u","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jier00u10jxl7550kv9n"},{"post_id":"ciw63jiel00ty0jxlknqpsk0u","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jier00u20jxlf87u5o6z"},{"post_id":"ciw63jiel00ty0jxlknqpsk0u","tag_id":"ciw63jhqk002k0jxliuhphaht","_id":"ciw63jier00u30jxl2upfdf0v"},{"post_id":"ciw63jiel00ty0jxlknqpsk0u","tag_id":"ciw63ji5z00k60jxlrjezqo7f","_id":"ciw63jies00u40jxlgk15d5yw"},{"post_id":"ciw63jies00u50jxlrvegeixo","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiex00u80jxlqm6pnp5d"},{"post_id":"ciw63jies00u50jxlrvegeixo","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jif000u90jxlvtpvpp64"},{"post_id":"ciw63jies00u50jxlrvegeixo","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jif000ua0jxl7yc1xpfl"},{"post_id":"ciw63jies00u50jxlrvegeixo","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jif000ub0jxluegzkw6k"},{"post_id":"ciw63jies00u50jxlrvegeixo","tag_id":"ciw63jht200530jxl3bf9aj93","_id":"ciw63jif000uc0jxlccu3wtwj"},{"post_id":"ciw63jies00u50jxlrvegeixo","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jif000ud0jxlmxn0cnf4"},{"post_id":"ciw63jies00u50jxlrvegeixo","tag_id":"ciw63jiew00u70jxl6crivbgk","_id":"ciw63jif000ue0jxl2k4mehgo"},{"post_id":"ciw63jif000uf0jxlok0pj3h7","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jif400ui0jxlb0lmnuc6"},{"post_id":"ciw63jif000uf0jxlok0pj3h7","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jif500uj0jxlyqzw02ex"},{"post_id":"ciw63jif000uf0jxlok0pj3h7","tag_id":"ciw63jif200uh0jxljey7r33n","_id":"ciw63jif500uk0jxlkm166gdc"},{"post_id":"ciw63jif000uf0jxlok0pj3h7","tag_id":"ciw63jhyx00eq0jxlr65pzvp5","_id":"ciw63jif500ul0jxlj4djkgxw"},{"post_id":"ciw63jif000uf0jxlok0pj3h7","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jif500um0jxldgrkf5pl"},{"post_id":"ciw63jif000uf0jxlok0pj3h7","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jif600un0jxlqvjoeccv"},{"post_id":"ciw63jif600uo0jxlmy88sxvg","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jif900uq0jxllg37mfwt"},{"post_id":"ciw63jif600uo0jxlmy88sxvg","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jifa00ur0jxldekuse1w"},{"post_id":"ciw63jif600uo0jxlmy88sxvg","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63jifa00us0jxlclw36z0p"},{"post_id":"ciw63jif600uo0jxlmy88sxvg","tag_id":"ciw63jhts006c0jxlsgx0aj9d","_id":"ciw63jifa00ut0jxlzjsu65za"},{"post_id":"ciw63jifb00uu0jxl0bjautas","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jifd00uw0jxlnczklypi"},{"post_id":"ciw63jifb00uu0jxl0bjautas","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jiff00ux0jxl409jak4w"},{"post_id":"ciw63jifb00uu0jxl0bjautas","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jiff00uy0jxlt27g1wju"},{"post_id":"ciw63jifb00uu0jxl0bjautas","tag_id":"ciw63ji6w00l20jxlzspld2po","_id":"ciw63jiff00uz0jxlj78leqm5"},{"post_id":"ciw63jifb00uu0jxl0bjautas","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jiff00v00jxlu8n32yyu"},{"post_id":"ciw63jifh00v10jxle8jg037f","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jifj00v30jxlag8m2ig2"},{"post_id":"ciw63jifh00v10jxle8jg037f","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jifl00v40jxl9lnt6jb5"},{"post_id":"ciw63jifh00v10jxle8jg037f","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jifl00v50jxlm8z411if"},{"post_id":"ciw63jifh00v10jxle8jg037f","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jifl00v60jxl3ypkt0nh"},{"post_id":"ciw63jifh00v10jxle8jg037f","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jifl00v70jxlepssrbht"},{"post_id":"ciw63jifl00v80jxlr7o0iqza","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jifo00va0jxllc31tedz"},{"post_id":"ciw63jifl00v80jxlr7o0iqza","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jifp00vb0jxlz9g27zlp"},{"post_id":"ciw63jifl00v80jxlr7o0iqza","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jifp00vc0jxlq6qb2ioz"},{"post_id":"ciw63jifl00v80jxlr7o0iqza","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jifp00vd0jxlk813gzwh"},{"post_id":"ciw63jifq00ve0jxlcgb65afe","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jifs00vg0jxldy6j6i4b"},{"post_id":"ciw63jifq00ve0jxlcgb65afe","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jifu00vh0jxlt3tp3urj"},{"post_id":"ciw63jifq00ve0jxlcgb65afe","tag_id":"ciw63jicx00sr0jxlgli6xmsp","_id":"ciw63jifu00vi0jxl1911nh7e"},{"post_id":"ciw63jifq00ve0jxlcgb65afe","tag_id":"ciw63ji0u00gr0jxlxmy6hu0g","_id":"ciw63jifu00vj0jxl931rkl56"},{"post_id":"ciw63jifu00vk0jxlkvuve8s3","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jifx00vm0jxl5v6ftczs"},{"post_id":"ciw63jifu00vk0jxlkvuve8s3","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jify00vn0jxlgdnv0eor"},{"post_id":"ciw63jifu00vk0jxlkvuve8s3","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jify00vo0jxlekm1ocrw"},{"post_id":"ciw63jify00vp0jxl6giayqp0","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jig200vs0jxlcqmiwpis"},{"post_id":"ciw63jify00vp0jxl6giayqp0","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jig300vt0jxl6lep4imy"},{"post_id":"ciw63jify00vp0jxl6giayqp0","tag_id":"ciw63jig100vr0jxlf0nxsyqy","_id":"ciw63jig300vu0jxlv6osnpak"},{"post_id":"ciw63jify00vp0jxl6giayqp0","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jig300vv0jxliioufsk4"},{"post_id":"ciw63jig400vw0jxlpt3ytw0y","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jig700vy0jxlcfomvf5s"},{"post_id":"ciw63jig400vw0jxlpt3ytw0y","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jig800vz0jxl7ieg3r65"},{"post_id":"ciw63jig400vw0jxlpt3ytw0y","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jig800w00jxlicwfmuds"},{"post_id":"ciw63jig400vw0jxlpt3ytw0y","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jig800w10jxlc0gudehy"},{"post_id":"ciw63jig400vw0jxlpt3ytw0y","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jig800w20jxlcjkpoct3"},{"post_id":"ciw63jig900w30jxlz98i3xkd","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jigc00w50jxl3mu4jfbq"},{"post_id":"ciw63jig900w30jxlz98i3xkd","tag_id":"ciw63jieg00ts0jxlmmbzycbr","_id":"ciw63jigd00w60jxlnw1hn7ap"},{"post_id":"ciw63jig900w30jxlz98i3xkd","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jigd00w70jxlkp5abm02"},{"post_id":"ciw63jig900w30jxlz98i3xkd","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jigd00w80jxlt82yphy3"},{"post_id":"ciw63jige00w90jxlf66yobmu","tag_id":"ciw63jigg00wb0jxl83njhx6l","_id":"ciw63jigh00wc0jxlc2o55zrp"},{"post_id":"ciw63jige00w90jxlf66yobmu","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jigi00wd0jxlly4mfy9t"},{"post_id":"ciw63jige00w90jxlf66yobmu","tag_id":"ciw63jibu00rz0jxl3n33qhuq","_id":"ciw63jigi00we0jxl3c0nn1s6"},{"post_id":"ciw63jige00w90jxlf66yobmu","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jigi00wf0jxlrtawjpqo"},{"post_id":"ciw63jigj00wg0jxldae5qjge","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jign00wj0jxl9znhopj8"},{"post_id":"ciw63jigj00wg0jxldae5qjge","tag_id":"ciw63jhv8008j0jxlcq3311hj","_id":"ciw63jigo00wk0jxlq12kly63"},{"post_id":"ciw63jigj00wg0jxldae5qjge","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jigo00wl0jxl9dr2676c"},{"post_id":"ciw63jigj00wg0jxldae5qjge","tag_id":"ciw63jigl00wi0jxlj1zi81ux","_id":"ciw63jigo00wm0jxl2fyhi9pi"},{"post_id":"ciw63jigj00wg0jxldae5qjge","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jigo00wn0jxlbpky9jig"},{"post_id":"ciw63jigp00wo0jxl3fwewg3w","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jigt00wr0jxl80itplpf"},{"post_id":"ciw63jigp00wo0jxl3fwewg3w","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jigv00ws0jxl8spgpcte"},{"post_id":"ciw63jigp00wo0jxl3fwewg3w","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jigv00wt0jxlreuqvf50"},{"post_id":"ciw63jigp00wo0jxl3fwewg3w","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63jigv00wu0jxl0pgotgbx"},{"post_id":"ciw63jigp00wo0jxl3fwewg3w","tag_id":"ciw63jhxb00cm0jxlxvh8mi1m","_id":"ciw63jigv00wv0jxlzhehcw81"},{"post_id":"ciw63jigp00wo0jxl3fwewg3w","tag_id":"ciw63jhwm00bg0jxl2evdv197","_id":"ciw63jigv00ww0jxlw0n33a34"},{"post_id":"ciw63jigw00wx0jxl452lpeuc","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jigz00wz0jxld4gszxsx"},{"post_id":"ciw63jigw00wx0jxl452lpeuc","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jih000x00jxliynpm9ng"},{"post_id":"ciw63jigw00wx0jxl452lpeuc","tag_id":"ciw63jicm00sk0jxlbe3dhlkf","_id":"ciw63jih000x10jxlnhsrtscl"},{"post_id":"ciw63jigw00wx0jxl452lpeuc","tag_id":"ciw63jhwh00b70jxl6btias08","_id":"ciw63jih000x20jxl8aluq74n"},{"post_id":"ciw63jih100x30jxlxbbqo6lf","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jih400x60jxllb91jefi"},{"post_id":"ciw63jih100x30jxlxbbqo6lf","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jih600x70jxlo8lf694y"},{"post_id":"ciw63jih100x30jxlxbbqo6lf","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jih600x80jxlyyqqpfjo"},{"post_id":"ciw63jih100x30jxlxbbqo6lf","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63jih600x90jxl53r1libo"},{"post_id":"ciw63jih100x30jxlxbbqo6lf","tag_id":"ciw63jih300x50jxlh7mkinw3","_id":"ciw63jih600xa0jxlrxbdb6i4"},{"post_id":"ciw63jih700xb0jxl4wjltdvj","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiha00xd0jxlzm2mkf4e"},{"post_id":"ciw63jih700xb0jxl4wjltdvj","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jihc00xe0jxlw9iae0pu"},{"post_id":"ciw63jih700xb0jxl4wjltdvj","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jihc00xf0jxlatou09v1"},{"post_id":"ciw63jih700xb0jxl4wjltdvj","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jihc00xg0jxlptwciiiw"},{"post_id":"ciw63jih700xb0jxl4wjltdvj","tag_id":"ciw63jieh00tt0jxl1u35xk15","_id":"ciw63jihc00xh0jxler1jozae"},{"post_id":"ciw63jih700xb0jxl4wjltdvj","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63jihc00xi0jxlh2t6dlwn"},{"post_id":"ciw63jihd00xj0jxlz6mr3pkn","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jihf00xl0jxlt3xv0yt3"},{"post_id":"ciw63jihd00xj0jxlz6mr3pkn","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jihh00xm0jxloj8ccive"},{"post_id":"ciw63jihd00xj0jxlz6mr3pkn","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jihh00xn0jxlhwi86p3d"},{"post_id":"ciw63jihd00xj0jxlz6mr3pkn","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jihh00xo0jxl1g9ln8z8"},{"post_id":"ciw63jihd00xj0jxlz6mr3pkn","tag_id":"ciw63jhu2006x0jxl0pyk2jka","_id":"ciw63jihh00xp0jxlk558b9vd"},{"post_id":"ciw63jihi00xq0jxl07wax2lb","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jihm00xs0jxlb4zf2wl6"},{"post_id":"ciw63jihi00xq0jxl07wax2lb","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jiho00xt0jxljt77i1ru"},{"post_id":"ciw63jihi00xq0jxl07wax2lb","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jiho00xu0jxlgs4tj09v"},{"post_id":"ciw63jihi00xq0jxl07wax2lb","tag_id":"ciw63jhrw003g0jxlomcv3673","_id":"ciw63jiho00xv0jxlop7yc2au"},{"post_id":"ciw63jihp00xw0jxlwc4w8tcf","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiht00xz0jxlciuieaq7"},{"post_id":"ciw63jihp00xw0jxlwc4w8tcf","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jihv00y00jxl14g6wljv"},{"post_id":"ciw63jihp00xw0jxlwc4w8tcf","tag_id":"ciw63jihr00xy0jxlg79ndqno","_id":"ciw63jihv00y10jxlipdgizj2"},{"post_id":"ciw63jihp00xw0jxlwc4w8tcf","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jihv00y20jxl3saiqptu"},{"post_id":"ciw63jihp00xw0jxlwc4w8tcf","tag_id":"ciw63jhsm00440jxlt4lia4dr","_id":"ciw63jihv00y30jxlvupdvt47"},{"post_id":"ciw63jihw00y40jxlric3k8wm","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jihz00y60jxl4e6zqttl"},{"post_id":"ciw63jihw00y40jxlric3k8wm","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jii100y70jxliw1gm80y"},{"post_id":"ciw63jihw00y40jxlric3k8wm","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jii100y80jxlh9epq3fj"},{"post_id":"ciw63jihw00y40jxlric3k8wm","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jii100y90jxled4jh5g6"},{"post_id":"ciw63jihw00y40jxlric3k8wm","tag_id":"ciw63jhq9001z0jxls0zdq3cq","_id":"ciw63jii100ya0jxl4i0rn0se"},{"post_id":"ciw63jihw00y40jxlric3k8wm","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jii100yb0jxlxa5u844c"},{"post_id":"ciw63jihw00y40jxlric3k8wm","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jii100yc0jxlcfte78k8"},{"post_id":"ciw63jii200yd0jxlf4yqvkk0","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jii600yh0jxlryni83it"},{"post_id":"ciw63jii200yd0jxlf4yqvkk0","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jii700yi0jxlgf87hwm8"},{"post_id":"ciw63jii200yd0jxlf4yqvkk0","tag_id":"ciw63jii400yf0jxlrfnode9m","_id":"ciw63jii700yj0jxlx00255v4"},{"post_id":"ciw63jii200yd0jxlf4yqvkk0","tag_id":"ciw63jii500yg0jxl6984yrny","_id":"ciw63jii800yk0jxl07s7wm4t"},{"post_id":"ciw63jii800yl0jxl713qdc6s","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiic00yn0jxlrht5gkbv"},{"post_id":"ciw63jii800yl0jxl713qdc6s","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jiie00yo0jxlu7vvlxwg"},{"post_id":"ciw63jii800yl0jxl713qdc6s","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jiif00yp0jxlyas0pn7k"},{"post_id":"ciw63jii800yl0jxl713qdc6s","tag_id":"ciw63ji1h00hl0jxln71pjqxi","_id":"ciw63jiif00yq0jxlpw6r9j5t"},{"post_id":"ciw63jii800yl0jxl713qdc6s","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jiif00yr0jxl9kx36pbt"},{"post_id":"ciw63jii800yl0jxl713qdc6s","tag_id":"ciw63jhqo002s0jxl0vvekmbq","_id":"ciw63jiif00ys0jxlbbjrv71g"},{"post_id":"ciw63jii800yl0jxl713qdc6s","tag_id":"ciw63jhwz00c30jxldi3x3lp8","_id":"ciw63jiif00yt0jxlp64r3bud"},{"post_id":"ciw63jiif00yu0jxliqykk6jq","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiij00yx0jxl14sq8nbt"},{"post_id":"ciw63jiif00yu0jxliqykk6jq","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jiil00yy0jxltp2v58n7"},{"post_id":"ciw63jiif00yu0jxliqykk6jq","tag_id":"ciw63jiih00yw0jxl1jz9zv97","_id":"ciw63jiil00yz0jxlaznkbadw"},{"post_id":"ciw63jiif00yu0jxliqykk6jq","tag_id":"ciw63ji0g00gi0jxlpojs1evd","_id":"ciw63jiil00z00jxl4kl5uzcg"},{"post_id":"ciw63jiif00yu0jxliqykk6jq","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jiil00z10jxlxwrqi6xz"},{"post_id":"ciw63jiim00z20jxldskk9l7j","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiip00z40jxlv5j7i5dl"},{"post_id":"ciw63jiim00z20jxldskk9l7j","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jiir00z50jxlqc1zxacz"},{"post_id":"ciw63jiim00z20jxldskk9l7j","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jiir00z60jxloj3mh9ea"},{"post_id":"ciw63jiim00z20jxldskk9l7j","tag_id":"ciw63jhyh00e80jxlxyjsn7f8","_id":"ciw63jiir00z70jxl85h5v65p"},{"post_id":"ciw63jiim00z20jxldskk9l7j","tag_id":"ciw63jhuf007n0jxll83ky6ks","_id":"ciw63jiir00z80jxle1865czp"},{"post_id":"ciw63jiir00z90jxl9v8t7bd3","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiiv00zc0jxlqsza1rw7"},{"post_id":"ciw63jiir00z90jxl9v8t7bd3","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jiiw00zd0jxlcdv5l56x"},{"post_id":"ciw63jiir00z90jxl9v8t7bd3","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jiiw00ze0jxl0tdwdadm"},{"post_id":"ciw63jiir00z90jxl9v8t7bd3","tag_id":"ciw63jiiu00zb0jxl1ue6bgq7","_id":"ciw63jiiw00zf0jxlst2b01y3"},{"post_id":"ciw63jiix00zg0jxlq7bo5lpd","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jij000zj0jxl1uvv00lw"},{"post_id":"ciw63jiix00zg0jxlq7bo5lpd","tag_id":"ciw63jiiz00zi0jxlqotjh1rh","_id":"ciw63jij200zk0jxlh4fs73i6"},{"post_id":"ciw63jiix00zg0jxlq7bo5lpd","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jij200zl0jxll11d0mzx"},{"post_id":"ciw63jiix00zg0jxlq7bo5lpd","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jij200zm0jxljw6cd1fz"},{"post_id":"ciw63jij200zn0jxlt6gfu8a8","tag_id":"ciw63jij500zp0jxl4vbyq3c9","_id":"ciw63jij700zr0jxl9j9h3q3s"},{"post_id":"ciw63jij200zn0jxlt6gfu8a8","tag_id":"ciw63jij600zq0jxlycdqj844","_id":"ciw63jija00zs0jxl07r9pivq"},{"post_id":"ciw63jij200zn0jxlt6gfu8a8","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jija00zt0jxlzwudbs7i"},{"post_id":"ciw63jij200zn0jxlt6gfu8a8","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jija00zu0jxlpw73pyaz"},{"post_id":"ciw63jij200zn0jxlt6gfu8a8","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63jija00zv0jxlwnklci0j"},{"post_id":"ciw63jij200zn0jxlt6gfu8a8","tag_id":"ciw63jhts006c0jxlsgx0aj9d","_id":"ciw63jija00zw0jxln35laoea"},{"post_id":"ciw63jij200zn0jxlt6gfu8a8","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jija00zx0jxlaqqm4kkd"},{"post_id":"ciw63jijb00zy0jxl2zgfkp0i","tag_id":"ciw63jij500zp0jxl4vbyq3c9","_id":"ciw63jijf01010jxls8vclite"},{"post_id":"ciw63jijb00zy0jxl2zgfkp0i","tag_id":"ciw63jije01000jxlzinm3bcu","_id":"ciw63jijh01020jxl22f2rpgf"},{"post_id":"ciw63jijb00zy0jxl2zgfkp0i","tag_id":"ciw63jhsp004b0jxl4h5p03lp","_id":"ciw63jijh01030jxlf0sy49j1"},{"post_id":"ciw63jijb00zy0jxl2zgfkp0i","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jijh01040jxls3tp1l4f"},{"post_id":"ciw63jijh01050jxlbkkxbn3k","tag_id":"ciw63jij500zp0jxl4vbyq3c9","_id":"ciw63jijk01070jxlhklp2f1d"},{"post_id":"ciw63jijh01050jxlbkkxbn3k","tag_id":"ciw63jhsp004b0jxl4h5p03lp","_id":"ciw63jijl01080jxl7etrurtq"},{"post_id":"ciw63jijh01050jxlbkkxbn3k","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jijl01090jxlcekgnjya"},{"post_id":"ciw63jijm010a0jxlka1aahon","tag_id":"ciw63jij500zp0jxl4vbyq3c9","_id":"ciw63jijo010c0jxlfvuviy9v"},{"post_id":"ciw63jijm010a0jxlka1aahon","tag_id":"ciw63jhsp004b0jxl4h5p03lp","_id":"ciw63jijp010d0jxlv4r04per"},{"post_id":"ciw63jijm010a0jxlka1aahon","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jijp010e0jxloi9d1x50"},{"post_id":"ciw63jijq010f0jxl789rnlgs","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiju010i0jxllj7dkmzp"},{"post_id":"ciw63jijq010f0jxl789rnlgs","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jijw010j0jxlfan2u6rq"},{"post_id":"ciw63jijq010f0jxl789rnlgs","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jijw010k0jxl8qflkzep"},{"post_id":"ciw63jijq010f0jxl789rnlgs","tag_id":"ciw63jhzi00fm0jxlcysuzkz1","_id":"ciw63jijw010l0jxl26uj7xtq"},{"post_id":"ciw63jijq010f0jxl789rnlgs","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jijw010m0jxldhrohjwp"},{"post_id":"ciw63jijx010n0jxl9r9a9qps","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jik0010p0jxle21cblh8"},{"post_id":"ciw63jijx010n0jxl9r9a9qps","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jik2010q0jxldg5uzb3y"},{"post_id":"ciw63jijx010n0jxl9r9a9qps","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63jik2010r0jxlutdmf9kg"},{"post_id":"ciw63jijx010n0jxl9r9a9qps","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63jik2010s0jxlysqm4u8e"},{"post_id":"ciw63jijx010n0jxl9r9a9qps","tag_id":"ciw63jih300x50jxlh7mkinw3","_id":"ciw63jik2010t0jxlfrcz9n3b"},{"post_id":"ciw63jik2010u0jxlq257xkju","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jik6010x0jxluzx3tymx"},{"post_id":"ciw63jik2010u0jxlq257xkju","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jik9010y0jxljmfrkt7q"},{"post_id":"ciw63jik2010u0jxlq257xkju","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jik9010z0jxlahdxzp3y"},{"post_id":"ciw63jik2010u0jxlq257xkju","tag_id":"ciw63jik5010w0jxly6w4c73a","_id":"ciw63jik901100jxlctzcgsvq"},{"post_id":"ciw63jik2010u0jxlq257xkju","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jik901110jxlhgb4kpcm"},{"post_id":"ciw63jik2010u0jxlq257xkju","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jik901120jxliue2mrud"},{"post_id":"ciw63jik2010u0jxlq257xkju","tag_id":"ciw63jhwa00al0jxlcb3r95mn","_id":"ciw63jik901130jxlba8z3pcv"},{"post_id":"ciw63jika01140jxl777wje9r","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jikc01160jxlyiniqi3e"},{"post_id":"ciw63jika01140jxl777wje9r","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jike01170jxldnfrt0m9"},{"post_id":"ciw63jika01140jxl777wje9r","tag_id":"ciw63ji7t00mf0jxllk4ai0oq","_id":"ciw63jike01180jxlwd4gl571"},{"post_id":"ciw63jika01140jxl777wje9r","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jike01190jxll4tt9smc"},{"post_id":"ciw63jikf011a0jxl563rdiif","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jikh011c0jxlelr3641b"},{"post_id":"ciw63jikf011a0jxl563rdiif","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jikj011d0jxlnr43ponu"},{"post_id":"ciw63jikf011a0jxl563rdiif","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jikj011e0jxlna8be7na"},{"post_id":"ciw63jikf011a0jxl563rdiif","tag_id":"ciw63jhrw003g0jxlomcv3673","_id":"ciw63jikj011f0jxl7vkmg264"},{"post_id":"ciw63jikk011g0jxlux6trkbp","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jikn011i0jxlvulplj3e"},{"post_id":"ciw63jikk011g0jxlux6trkbp","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jikp011j0jxl8oim3hw9"},{"post_id":"ciw63jikk011g0jxlux6trkbp","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jikp011k0jxlkg0bb6qn"},{"post_id":"ciw63jikk011g0jxlux6trkbp","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jikp011l0jxlx66b01sm"},{"post_id":"ciw63jikk011g0jxlux6trkbp","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jikp011m0jxlhetrlobb"},{"post_id":"ciw63jikk011g0jxlux6trkbp","tag_id":"ciw63jhs2003q0jxl9xrufqxy","_id":"ciw63jikp011n0jxlzb1dy03j"},{"post_id":"ciw63jikq011o0jxl26gropca","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jikt011q0jxl4d5je6cw"},{"post_id":"ciw63jikq011o0jxl26gropca","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jiku011r0jxlyob7panj"},{"post_id":"ciw63jikq011o0jxl26gropca","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jiku011s0jxlwokgbrby"},{"post_id":"ciw63jiku011t0jxle5dm87ui","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jikz011v0jxlj0stgmqn"},{"post_id":"ciw63jiku011t0jxle5dm87ui","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jil0011w0jxlfojjuu5d"},{"post_id":"ciw63jiku011t0jxle5dm87ui","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jil0011x0jxl5d1xrf2b"},{"post_id":"ciw63jil1011y0jxlr4etq1fx","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jil301200jxlldks89gf"},{"post_id":"ciw63jil1011y0jxlr4etq1fx","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jil501210jxlyrui3dbe"},{"post_id":"ciw63jil1011y0jxlr4etq1fx","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jil501220jxlmpkao014"},{"post_id":"ciw63jil1011y0jxlr4etq1fx","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jil501230jxl929v0tx7"},{"post_id":"ciw63jil601240jxlrre2i061","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jil801260jxlx0p9fuam"},{"post_id":"ciw63jil601240jxlrre2i061","tag_id":"ciw63jijt010h0jxl8sqws4x9","_id":"ciw63jila01270jxlwy1zh8on"},{"post_id":"ciw63jil601240jxlrre2i061","tag_id":"ciw63jhty006o0jxlfk01cryd","_id":"ciw63jilb01280jxl6406wbk0"},{"post_id":"ciw63jil601240jxlrre2i061","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jilb01290jxlqua6jkpw"},{"post_id":"ciw63jil601240jxlrre2i061","tag_id":"ciw63jhqg002b0jxl534swffv","_id":"ciw63jilb012a0jxlgd7b1zdr"},{"post_id":"ciw63jilb012b0jxl65i0vqqg","tag_id":"ciw63jild012d0jxl5mspw641","_id":"ciw63jilg012f0jxlecka4ehy"},{"post_id":"ciw63jilb012b0jxl65i0vqqg","tag_id":"ciw63jile012e0jxlwjj9kqvz","_id":"ciw63jilh012g0jxlemrv1w5z"},{"post_id":"ciw63jilb012b0jxl65i0vqqg","tag_id":"ciw63jhue007m0jxlw9ocvwvc","_id":"ciw63jilh012h0jxl7ro6ipc2"},{"post_id":"ciw63jilh012i0jxl1du4mz32","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jill012l0jxlch2xmi8j"},{"post_id":"ciw63jilh012i0jxl1du4mz32","tag_id":"ciw63jilk012k0jxlvh2pb5v2","_id":"ciw63jilm012m0jxl07v564ng"},{"post_id":"ciw63jilh012i0jxl1du4mz32","tag_id":"ciw63jhsm00440jxlt4lia4dr","_id":"ciw63jilm012n0jxlsw3yesj5"},{"post_id":"ciw63jiln012o0jxlxvtoz74o","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jilq012r0jxljc1xm1l8"},{"post_id":"ciw63jiln012o0jxlxvtoz74o","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jilt012s0jxlwafrze0m"},{"post_id":"ciw63jiln012o0jxlxvtoz74o","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jilt012t0jxlcadjnw0b"},{"post_id":"ciw63jiln012o0jxlxvtoz74o","tag_id":"ciw63jilp012q0jxl2mkl92ik","_id":"ciw63jilt012u0jxl64pa2sml"},{"post_id":"ciw63jiln012o0jxlxvtoz74o","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jilt012v0jxldklas4k7"},{"post_id":"ciw63jiln012o0jxlxvtoz74o","tag_id":"ciw63jhwz00c40jxl3124jsej","_id":"ciw63jilt012w0jxl2gdk3k0a"},{"post_id":"ciw63jilu012x0jxlco5jltml","tag_id":"ciw63jhp4000k0jxl6dxtsl10","_id":"ciw63jilx012z0jxl2fvbpwxc"},{"post_id":"ciw63jilu012x0jxlco5jltml","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jilz01300jxleqd2vse4"},{"post_id":"ciw63jilu012x0jxlco5jltml","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jilz01310jxlmqiqvvym"},{"post_id":"ciw63jilu012x0jxlco5jltml","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jilz01320jxlfbjd7l4n"},{"post_id":"ciw63jilu012x0jxlco5jltml","tag_id":"ciw63jilp012q0jxl2mkl92ik","_id":"ciw63jilz01330jxl7c6eyikw"},{"post_id":"ciw63jim001340jxlpt0wtodf","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jim301360jxlnjob51ul"},{"post_id":"ciw63jim001340jxlpt0wtodf","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jim501370jxl95i14gxo"},{"post_id":"ciw63jim001340jxlpt0wtodf","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jim501380jxl974roz7v"},{"post_id":"ciw63jim001340jxlpt0wtodf","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jim501390jxlqy4yevcx"},{"post_id":"ciw63jim001340jxlpt0wtodf","tag_id":"ciw63jhwa00al0jxlcb3r95mn","_id":"ciw63jim5013a0jxlnv308g42"},{"post_id":"ciw63jim6013b0jxlsevs3mok","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jim9013d0jxl792bemrb"},{"post_id":"ciw63jim6013b0jxlsevs3mok","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jimc013e0jxli2ogzixo"},{"post_id":"ciw63jim6013b0jxlsevs3mok","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jimc013f0jxlqdwebbe6"},{"post_id":"ciw63jim6013b0jxlsevs3mok","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jimc013g0jxloulofxs9"},{"post_id":"ciw63jim6013b0jxlsevs3mok","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jimc013h0jxlntle2ekm"},{"post_id":"ciw63jim6013b0jxlsevs3mok","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jimc013i0jxlyi86h7pa"},{"post_id":"ciw63jimd013j0jxl73ghnjmo","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jimg013l0jxlm7ch1h3j"},{"post_id":"ciw63jimd013j0jxl73ghnjmo","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jimi013m0jxl5ozkd54d"},{"post_id":"ciw63jimd013j0jxl73ghnjmo","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jimi013n0jxlu68nil85"},{"post_id":"ciw63jimd013j0jxl73ghnjmo","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jimi013o0jxl4lloc1jq"},{"post_id":"ciw63jimd013j0jxl73ghnjmo","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jimi013p0jxlaiyescng"},{"post_id":"ciw63jimj013q0jxlxjwyuv2u","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jimm013s0jxl8sv3rvww"},{"post_id":"ciw63jimj013q0jxlxjwyuv2u","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jimo013t0jxlztlwvope"},{"post_id":"ciw63jimj013q0jxlxjwyuv2u","tag_id":"ciw63jhw500aa0jxlnvxx8tjo","_id":"ciw63jimo013u0jxlapohse1i"},{"post_id":"ciw63jimo013v0jxlx7g6aw1h","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jims013x0jxlr4x8afhn"},{"post_id":"ciw63jimo013v0jxlx7g6aw1h","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jimu013y0jxl57cbp05f"},{"post_id":"ciw63jimo013v0jxlx7g6aw1h","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jimu013z0jxlrcqq7tkj"},{"post_id":"ciw63jimo013v0jxlx7g6aw1h","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63jimu01400jxldsvlerfd"},{"post_id":"ciw63jimo013v0jxlx7g6aw1h","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jimu01410jxlfueig89s"},{"post_id":"ciw63jimo013v0jxlx7g6aw1h","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jimu01420jxlya7jkdjo"},{"post_id":"ciw63jimx01430jxl3lbo3af1","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jin201470jxl67pqykxj"},{"post_id":"ciw63jimx01430jxl3lbo3af1","tag_id":"ciw63jin001450jxlgvvvhxx3","_id":"ciw63jin501480jxlihn2by5d"},{"post_id":"ciw63jimx01430jxl3lbo3af1","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jin501490jxlb1nvg54f"},{"post_id":"ciw63jimx01430jxl3lbo3af1","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jin5014a0jxl0p6ynz05"},{"post_id":"ciw63jimx01430jxl3lbo3af1","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jin6014b0jxloxgxzcut"},{"post_id":"ciw63jimx01430jxl3lbo3af1","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jin6014c0jxl2csp6luq"},{"post_id":"ciw63jimx01430jxl3lbo3af1","tag_id":"ciw63jhzs00fx0jxlpmw6c3oh","_id":"ciw63jin6014d0jxlnlt0uhuj"},{"post_id":"ciw63jin6014e0jxljjx5fs1o","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jin9014g0jxlms7wk9cd"},{"post_id":"ciw63jin6014e0jxljjx5fs1o","tag_id":"ciw63jin001450jxlgvvvhxx3","_id":"ciw63jinb014h0jxlcp6j79kn"},{"post_id":"ciw63jin6014e0jxljjx5fs1o","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jinb014i0jxljjqdp15e"},{"post_id":"ciw63jin6014e0jxljjx5fs1o","tag_id":"ciw63jhz200f00jxlt3em0nmt","_id":"ciw63jinb014j0jxlhyrlhkpd"},{"post_id":"ciw63jine014m0jxlfh9g0v1f","tag_id":"ciw63jinh014o0jxlkxya95i9","_id":"ciw63jini014p0jxlr85kxvpq"},{"post_id":"ciw63jine014m0jxlfh9g0v1f","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jink014q0jxlsdc3papr"},{"post_id":"ciw63jine014m0jxlfh9g0v1f","tag_id":"ciw63jhsp004b0jxl4h5p03lp","_id":"ciw63jink014r0jxl2xfljx1n"},{"post_id":"ciw63jine014m0jxlfh9g0v1f","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jink014s0jxl0awe78lt"},{"post_id":"ciw63jinl014t0jxloqhl8u6s","tag_id":"ciw63jinh014o0jxlkxya95i9","_id":"ciw63jino014v0jxlqds62l7k"},{"post_id":"ciw63jinl014t0jxloqhl8u6s","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jinq014w0jxlhz3c7ujm"},{"post_id":"ciw63jinl014t0jxloqhl8u6s","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jinq014x0jxlj0fn343p"},{"post_id":"ciw63jinl014t0jxloqhl8u6s","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jinq014y0jxl0gihhreu"},{"post_id":"ciw63jinl014t0jxloqhl8u6s","tag_id":"ciw63jhvv009m0jxl6qtqkgdq","_id":"ciw63jinq014z0jxlohqoadaw"},{"post_id":"ciw63jinr01500jxlwkcl3q1i","tag_id":"ciw63jinh014o0jxlkxya95i9","_id":"ciw63jinu01520jxlibt3pwwn"},{"post_id":"ciw63jinr01500jxlwkcl3q1i","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jinx01530jxld2tvl6nl"},{"post_id":"ciw63jinr01500jxlwkcl3q1i","tag_id":"ciw63jhvu009l0jxlrt41ik9x","_id":"ciw63jinx01540jxl8h96op2v"},{"post_id":"ciw63jinr01500jxlwkcl3q1i","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jinx01550jxlcticlexd"},{"post_id":"ciw63jinr01500jxlwkcl3q1i","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jinx01560jxllooa5g3q"},{"post_id":"ciw63jinr01500jxlwkcl3q1i","tag_id":"ciw63jhvv009m0jxl6qtqkgdq","_id":"ciw63jinx01570jxllfwa6pwq"},{"post_id":"ciw63jiny01580jxlbnj0c86i","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jio0015a0jxlic33b6al"},{"post_id":"ciw63jiny01580jxlbnj0c86i","tag_id":"ciw63jhs1003p0jxlk7390dhu","_id":"ciw63jio2015b0jxltyse5nx1"},{"post_id":"ciw63jiny01580jxlbnj0c86i","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jio2015c0jxld53gqj2k"},{"post_id":"ciw63jiny01580jxlbnj0c86i","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jio2015d0jxl16p0v3p6"},{"post_id":"ciw63jio3015e0jxlkp4xbrkn","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jio7015h0jxlaf71yrh5"},{"post_id":"ciw63jio3015e0jxlkp4xbrkn","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jioc015i0jxl00h0ybgs"},{"post_id":"ciw63jio3015e0jxlkp4xbrkn","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jioc015j0jxlw82froq7"},{"post_id":"ciw63jio3015e0jxlkp4xbrkn","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jioc015k0jxlt1ghifo9"},{"post_id":"ciw63jio3015e0jxlkp4xbrkn","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jioc015l0jxlh3r0x28l"},{"post_id":"ciw63jio3015e0jxlkp4xbrkn","tag_id":"ciw63jio5015g0jxlcsu3twdl","_id":"ciw63jioc015m0jxlnfsxkwz1"},{"post_id":"ciw63jiod015n0jxln2742wi2","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiog015p0jxlol9tg56a"},{"post_id":"ciw63jiod015n0jxln2742wi2","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jioi015q0jxl3u6oir9w"},{"post_id":"ciw63jiod015n0jxln2742wi2","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jioi015r0jxl9oz178pm"},{"post_id":"ciw63jiod015n0jxln2742wi2","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jioi015s0jxlmwqfokpd"},{"post_id":"ciw63jiod015n0jxln2742wi2","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jioi015t0jxlv88cy6dt"},{"post_id":"ciw63jiod015n0jxln2742wi2","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jioj015u0jxlc62un09o"},{"post_id":"ciw63jioj015v0jxlz2w6d909","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jion015x0jxllbnveugs"},{"post_id":"ciw63jioj015v0jxlz2w6d909","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jioq015y0jxlvbo4zntp"},{"post_id":"ciw63jioj015v0jxlz2w6d909","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jioq015z0jxlwb77zcy5"},{"post_id":"ciw63jioj015v0jxlz2w6d909","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jioq01600jxlo8fe20zd"},{"post_id":"ciw63jioj015v0jxlz2w6d909","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jioq01610jxlft45cjaa"},{"post_id":"ciw63jioj015v0jxlz2w6d909","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jioq01620jxl7jxszye9"},{"post_id":"ciw63jior01630jxlkgbskxg8","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiou01650jxl4a6z0gnw"},{"post_id":"ciw63jior01630jxlkgbskxg8","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jioy01660jxldgu3i71b"},{"post_id":"ciw63jior01630jxlkgbskxg8","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jioz01670jxlcrhxtkgb"},{"post_id":"ciw63jior01630jxlkgbskxg8","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jioz01680jxl1usg4n54"},{"post_id":"ciw63jior01630jxlkgbskxg8","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jioz01690jxlvsq8vsn6"},{"post_id":"ciw63jior01630jxlkgbskxg8","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jioz016a0jxlwz4fnz2m"},{"post_id":"ciw63jior01630jxlkgbskxg8","tag_id":"ciw63jhyx00eq0jxlr65pzvp5","_id":"ciw63jioz016b0jxlqbq2adcg"},{"post_id":"ciw63jip0016c0jxl889fn0z2","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jip4016e0jxl0oi3ysim"},{"post_id":"ciw63jip0016c0jxl889fn0z2","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jip7016f0jxlzls1sqfa"},{"post_id":"ciw63jip0016c0jxl889fn0z2","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jip7016g0jxlio0n9is7"},{"post_id":"ciw63jip0016c0jxl889fn0z2","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jip7016h0jxlr59zpub8"},{"post_id":"ciw63jip0016c0jxl889fn0z2","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jip7016i0jxl88xs0fm1"},{"post_id":"ciw63jip0016c0jxl889fn0z2","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jip7016j0jxlf2xnfpu8"},{"post_id":"ciw63jip8016k0jxlcfcwxwza","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jipb016m0jxlzsvjtgpd"},{"post_id":"ciw63jip8016k0jxlcfcwxwza","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jipe016n0jxln3v3eh07"},{"post_id":"ciw63jip8016k0jxlcfcwxwza","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jipe016o0jxl11fpz8qq"},{"post_id":"ciw63jip8016k0jxlcfcwxwza","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jipe016p0jxli8fl8ez8"},{"post_id":"ciw63jip8016k0jxlcfcwxwza","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jipe016q0jxlul0hvuha"},{"post_id":"ciw63jip8016k0jxlcfcwxwza","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jipe016r0jxlnrtcvutc"},{"post_id":"ciw63jipf016s0jxlgk5hbfsl","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jipi016u0jxlbjm7mgsw"},{"post_id":"ciw63jipf016s0jxlgk5hbfsl","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jipl016v0jxl7tocgpzu"},{"post_id":"ciw63jipf016s0jxlgk5hbfsl","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jipl016w0jxlu839vtdp"},{"post_id":"ciw63jipf016s0jxlgk5hbfsl","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jipl016x0jxlrgnfrmay"},{"post_id":"ciw63jipf016s0jxlgk5hbfsl","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jipl016y0jxlurhhq1bm"},{"post_id":"ciw63jipf016s0jxlgk5hbfsl","tag_id":"ciw63jio5015g0jxlcsu3twdl","_id":"ciw63jipl016z0jxlc3p77pqz"},{"post_id":"ciw63jipm01700jxlwjeh15ux","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jipp01720jxlbz7mo8c0"},{"post_id":"ciw63jipm01700jxlwjeh15ux","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jipr01730jxlmgemgl97"},{"post_id":"ciw63jipm01700jxlwjeh15ux","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jipr01740jxlwvcm0vzh"},{"post_id":"ciw63jipm01700jxlwjeh15ux","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jipr01750jxld9lvcghb"},{"post_id":"ciw63jipm01700jxlwjeh15ux","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jipr01760jxlmuiximdl"},{"post_id":"ciw63jips01770jxlizw4ni94","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jipv01790jxl02jate9t"},{"post_id":"ciw63jips01770jxlizw4ni94","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jipx017a0jxl0na25n3w"},{"post_id":"ciw63jips01770jxlizw4ni94","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jipx017b0jxlaea9c8rr"},{"post_id":"ciw63jips01770jxlizw4ni94","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jipx017c0jxlz3c8rn6o"},{"post_id":"ciw63jips01770jxlizw4ni94","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jipx017d0jxlck2hexm3"},{"post_id":"ciw63jipy017e0jxlqqfyccci","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiq1017g0jxly84igkkh"},{"post_id":"ciw63jipy017e0jxlqqfyccci","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jiq4017h0jxlzx801dbn"},{"post_id":"ciw63jipy017e0jxlqqfyccci","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jiq5017i0jxl8qx4rua7"},{"post_id":"ciw63jipy017e0jxlqqfyccci","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jiq5017j0jxltx9lr8uy"},{"post_id":"ciw63jipy017e0jxlqqfyccci","tag_id":"ciw63jhyx00eq0jxlr65pzvp5","_id":"ciw63jiq5017k0jxlbsxt2qld"},{"post_id":"ciw63jipy017e0jxlqqfyccci","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jiq5017l0jxliykqeewx"},{"post_id":"ciw63jiq5017m0jxlwrmwivq6","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiq9017o0jxl5ztgdd94"},{"post_id":"ciw63jiq5017m0jxlwrmwivq6","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jiqc017p0jxlyddmllhl"},{"post_id":"ciw63jiq5017m0jxlwrmwivq6","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jiqc017q0jxlrde07ten"},{"post_id":"ciw63jiq5017m0jxlwrmwivq6","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jiqc017r0jxl88gu2wmr"},{"post_id":"ciw63jiq5017m0jxlwrmwivq6","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jiqc017s0jxlbsztm1qc"},{"post_id":"ciw63jiq5017m0jxlwrmwivq6","tag_id":"ciw63jib300r40jxlp8bezx1h","_id":"ciw63jiqc017t0jxliyg58n06"},{"post_id":"ciw63jiqd017u0jxl35p7uqns","tag_id":"ciw63ji0u00gr0jxlxmy6hu0g","_id":"ciw63jiqh017x0jxl67kuytsp"},{"post_id":"ciw63jiqd017u0jxl35p7uqns","tag_id":"ciw63jiqg017w0jxlkcyvyyjq","_id":"ciw63jiqk017y0jxlf9a84m5f"},{"post_id":"ciw63jiqd017u0jxl35p7uqns","tag_id":"ciw63jhvz009y0jxl5ah0p6x5","_id":"ciw63jiql017z0jxlh7ewi7ur"},{"post_id":"ciw63jiqd017u0jxl35p7uqns","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiql01800jxlctogh2nx"},{"post_id":"ciw63jiqd017u0jxl35p7uqns","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jiql01810jxlbjp0j7f8"},{"post_id":"ciw63jiqd017u0jxl35p7uqns","tag_id":"ciw63ji9q00p20jxlt1i1lzay","_id":"ciw63jiql01820jxll89zj6ri"},{"post_id":"ciw63jiql01830jxl8k0ly7ei","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiqo01850jxlxr1pmwi7"},{"post_id":"ciw63jiql01830jxl8k0ly7ei","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jiqq01860jxl0bqrle4z"},{"post_id":"ciw63jiql01830jxl8k0ly7ei","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jiqq01870jxlk6ospck1"},{"post_id":"ciw63jiqq01880jxlwqka11uv","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiqt018a0jxlls52hlgg"},{"post_id":"ciw63jiqq01880jxlwqka11uv","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jiqx018b0jxllmx2dw7y"},{"post_id":"ciw63jiqq01880jxlwqka11uv","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jiqx018c0jxlhkhrbc8b"},{"post_id":"ciw63jiqq01880jxlwqka11uv","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jiqx018d0jxlp5l5pof7"},{"post_id":"ciw63jiqq01880jxlwqka11uv","tag_id":"ciw63jhyx00eq0jxlr65pzvp5","_id":"ciw63jiqx018e0jxltwnnq5dm"},{"post_id":"ciw63jiqq01880jxlwqka11uv","tag_id":"ciw63jin101460jxlg21f9yab","_id":"ciw63jiqx018f0jxl5l5r7z4d"},{"post_id":"ciw63jiqy018g0jxln5w6qfzm","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jir1018i0jxl8g71wyvh"},{"post_id":"ciw63jiqy018g0jxln5w6qfzm","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jir2018j0jxlfsgnlrrm"},{"post_id":"ciw63jiqy018g0jxln5w6qfzm","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jir2018k0jxlvs9o9rvk"},{"post_id":"ciw63jir3018l0jxl6ef7lfzw","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jir7018n0jxlt3bl7u9q"},{"post_id":"ciw63jir3018l0jxl6ef7lfzw","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jir9018o0jxlxt92mn68"},{"post_id":"ciw63jir3018l0jxl6ef7lfzw","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jir9018p0jxly9rfmzao"},{"post_id":"ciw63jir3018l0jxl6ef7lfzw","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jir9018q0jxltfn04y4k"},{"post_id":"ciw63jira018r0jxlngvllqkb","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jire018t0jxld7pzsunu"},{"post_id":"ciw63jira018r0jxlngvllqkb","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jirh018u0jxlqxb8qgxn"},{"post_id":"ciw63jira018r0jxlngvllqkb","tag_id":"ciw63jhwa00am0jxl8d14vm7y","_id":"ciw63jirh018v0jxl4oscmzqs"},{"post_id":"ciw63jira018r0jxlngvllqkb","tag_id":"ciw63jhte005p0jxlni7rbi2h","_id":"ciw63jirh018w0jxl54ko53fc"},{"post_id":"ciw63jira018r0jxlngvllqkb","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jirh018x0jxl3cqcsomy"},{"post_id":"ciw63jiri018y0jxlcegvlc9d","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jirl01900jxlbs9m6wdb"},{"post_id":"ciw63jiri018y0jxlcegvlc9d","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jiro01910jxl7mlmhrf0"},{"post_id":"ciw63jiri018y0jxlcegvlc9d","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jiro01920jxli66awj4p"},{"post_id":"ciw63jiri018y0jxlcegvlc9d","tag_id":"ciw63jhty006o0jxlfk01cryd","_id":"ciw63jiro01930jxl6g98hitt"},{"post_id":"ciw63jiri018y0jxlcegvlc9d","tag_id":"ciw63jhqg002b0jxl534swffv","_id":"ciw63jiro01940jxlh2z81p8v"},{"post_id":"ciw63jirr01950jxl22kg9cfx","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jiru01970jxlvattns5f"},{"post_id":"ciw63jirr01950jxl22kg9cfx","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jirw01980jxldidwxx72"},{"post_id":"ciw63jirr01950jxl22kg9cfx","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jirw01990jxlgqe2vveq"},{"post_id":"ciw63jirr01950jxl22kg9cfx","tag_id":"ciw63ji8b00n80jxllu45i47s","_id":"ciw63jirw019a0jxl2xazmkcg"},{"post_id":"ciw63jirx019b0jxlpre59c2m","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jis2019e0jxlais9129y"},{"post_id":"ciw63jirx019b0jxlpre59c2m","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jis4019f0jxlfca2q3vl"},{"post_id":"ciw63jirx019b0jxlpre59c2m","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jis4019g0jxlc48sr0wf"},{"post_id":"ciw63jirx019b0jxlpre59c2m","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jis4019h0jxl70y7n49i"},{"post_id":"ciw63jirx019b0jxlpre59c2m","tag_id":"ciw63jhty006n0jxli0p4ox3v","_id":"ciw63jis4019i0jxllwhzimn9"},{"post_id":"ciw63jis5019j0jxlz1kng6of","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jis9019l0jxlvplixv12"},{"post_id":"ciw63jis5019j0jxlz1kng6of","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jisc019m0jxlebe5tguj"},{"post_id":"ciw63jis5019j0jxlz1kng6of","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jisc019n0jxlnj3oiz95"},{"post_id":"ciw63jis5019j0jxlz1kng6of","tag_id":"ciw63ji8b00n80jxllu45i47s","_id":"ciw63jisc019o0jxly74gkhsk"},{"post_id":"ciw63jisf019p0jxlrat500k9","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiso019t0jxlug4vca84"},{"post_id":"ciw63jisf019p0jxlrat500k9","tag_id":"ciw63jisl019r0jxld3h86f7p","_id":"ciw63jiss019u0jxl60cq802r"},{"post_id":"ciw63jisf019p0jxlrat500k9","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jiss019v0jxlv68vly17"},{"post_id":"ciw63jisf019p0jxlrat500k9","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jiss019w0jxlegybewq0"},{"post_id":"ciw63jisf019p0jxlrat500k9","tag_id":"ciw63jhoi00030jxlfiukh6ia","_id":"ciw63jiss019x0jxltj6gu7o6"},{"post_id":"ciw63jisf019p0jxlrat500k9","tag_id":"ciw63jism019s0jxliyq67tzd","_id":"ciw63jiss019y0jxlx8zqzhwm"},{"post_id":"ciw63jisv019z0jxlfp30zchk","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jisz01a10jxlfksj2hhg"},{"post_id":"ciw63jisv019z0jxlfp30zchk","tag_id":"ciw63jhxb00cm0jxlxvh8mi1m","_id":"ciw63jit101a20jxl6oen0eso"},{"post_id":"ciw63jisv019z0jxlfp30zchk","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jit101a30jxlob951jyd"},{"post_id":"ciw63jisv019z0jxlfp30zchk","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jit101a40jxl8aqx9ye6"},{"post_id":"ciw63jit201a50jxl7llyjv18","tag_id":"ciw63jit501a70jxlu083841e","_id":"ciw63jit701a80jxlrnc05rux"},{"post_id":"ciw63jit201a50jxl7llyjv18","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jitd01a90jxlm7e0oifp"},{"post_id":"ciw63jit201a50jxl7llyjv18","tag_id":"ciw63jibu00rz0jxl3n33qhuq","_id":"ciw63jitd01aa0jxl53yn2htf"},{"post_id":"ciw63jit201a50jxl7llyjv18","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jitd01ab0jxlc6ywj5fq"},{"post_id":"ciw63jit201a50jxl7llyjv18","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jitd01ac0jxlgfnt2f14"},{"post_id":"ciw63jit201a50jxl7llyjv18","tag_id":"ciw63jhst004k0jxl42nd9rzx","_id":"ciw63jite01ad0jxl0jn1t7zd"},{"post_id":"ciw63jiti01ae0jxlfa5r1yru","tag_id":"ciw63jit501a70jxlu083841e","_id":"ciw63jitl01ag0jxlwisx7cg2"},{"post_id":"ciw63jiti01ae0jxlfa5r1yru","tag_id":"ciw63jhsp004b0jxl4h5p03lp","_id":"ciw63jitn01ah0jxl8uxjuyoy"},{"post_id":"ciw63jiti01ae0jxlfa5r1yru","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jitn01ai0jxl0jnoc8xa"},{"post_id":"ciw63jitp01aj0jxlngy9sfgo","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jitv01al0jxl1zs1wqha"},{"post_id":"ciw63jitp01aj0jxlngy9sfgo","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jitx01am0jxld1ukr18b"},{"post_id":"ciw63jitp01aj0jxlngy9sfgo","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jitx01an0jxlq924qds5"},{"post_id":"ciw63jitp01aj0jxlngy9sfgo","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jitx01ao0jxlexa098ln"},{"post_id":"ciw63jity01ap0jxlnkaar0tr","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jiu201as0jxlvyoc2nvf"},{"post_id":"ciw63jity01ap0jxlnkaar0tr","tag_id":"ciw63jiu101ar0jxldp405pkj","_id":"ciw63jiu501at0jxl4dau2h4f"},{"post_id":"ciw63jity01ap0jxlnkaar0tr","tag_id":"ciw63jhq9001z0jxls0zdq3cq","_id":"ciw63jiu501au0jxlcgzm756d"},{"post_id":"ciw63jity01ap0jxlnkaar0tr","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jiu501av0jxll9rwam4c"},{"post_id":"ciw63jity01ap0jxlnkaar0tr","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jiu501aw0jxl2k7klti8"},{"post_id":"ciw63jiu701ax0jxlu9758zln","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiug01b00jxlvrovn9a3"},{"post_id":"ciw63jiu701ax0jxlu9758zln","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jiuk01b10jxl2sv79qdr"},{"post_id":"ciw63jiu701ax0jxlu9758zln","tag_id":"ciw63jhs1003p0jxlk7390dhu","_id":"ciw63jiuk01b20jxlgb6jxq8z"},{"post_id":"ciw63jiu701ax0jxlu9758zln","tag_id":"ciw63jht7005b0jxlj5mtp6jt","_id":"ciw63jiuk01b30jxlmms2fp6k"},{"post_id":"ciw63jiu701ax0jxlu9758zln","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jiuk01b40jxlbu6a4sv1"},{"post_id":"ciw63jiu701ax0jxlu9758zln","tag_id":"ciw63jiue01az0jxlcf8cgiaw","_id":"ciw63jiuk01b50jxljbtyfbs8"},{"post_id":"ciw63jiu701ax0jxlu9758zln","tag_id":"ciw63jhst004k0jxl42nd9rzx","_id":"ciw63jiuk01b60jxl5wydtlgh"},{"post_id":"ciw63jium01b70jxltukfy57l","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiut01b90jxl932z1gaw"},{"post_id":"ciw63jium01b70jxltukfy57l","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jiuv01ba0jxlfylgs7ev"},{"post_id":"ciw63jium01b70jxltukfy57l","tag_id":"ciw63jht200530jxl3bf9aj93","_id":"ciw63jiuv01bb0jxlwkitcdyu"},{"post_id":"ciw63jium01b70jxltukfy57l","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jiuv01bc0jxlmic8o7uj"},{"post_id":"ciw63jiuw01bd0jxl8aydlzrj","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiv001bf0jxl1uj0yjv6"},{"post_id":"ciw63jiuw01bd0jxl8aydlzrj","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jiv201bg0jxlioswj72o"},{"post_id":"ciw63jiuw01bd0jxl8aydlzrj","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jiv201bh0jxlyzwe1ajq"},{"post_id":"ciw63jiv401bi0jxl44g6o5y8","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jivc01bk0jxl27cb07bu"},{"post_id":"ciw63jiv401bi0jxl44g6o5y8","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jivd01bl0jxl6f2ume96"},{"post_id":"ciw63jiv401bi0jxl44g6o5y8","tag_id":"ciw63jhti005x0jxl1yljboft","_id":"ciw63jivd01bm0jxltpulrhwk"},{"post_id":"ciw63jive01bn0jxlu624pw3g","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jivo01br0jxlw4t0785x"},{"post_id":"ciw63jive01bn0jxlu624pw3g","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jivu01bs0jxlz3qvqmgx"},{"post_id":"ciw63jive01bn0jxlu624pw3g","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jivu01bt0jxl9so5s6fw"},{"post_id":"ciw63jive01bn0jxlu624pw3g","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jivu01bu0jxl9h4yszsc"},{"post_id":"ciw63jive01bn0jxlu624pw3g","tag_id":"ciw63jivh01bp0jxlend2xfkv","_id":"ciw63jivu01bv0jxl9tog0gen"},{"post_id":"ciw63jive01bn0jxlu624pw3g","tag_id":"ciw63jivj01bq0jxlogd7pwxn","_id":"ciw63jivu01bw0jxl1xg4aiga"},{"post_id":"ciw63jivv01bx0jxlx0tblncd","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiw001bz0jxlzjgbh4u2"},{"post_id":"ciw63jivv01bx0jxlx0tblncd","tag_id":"ciw63jib300r40jxlp8bezx1h","_id":"ciw63jiw701c00jxlkhaxvfa6"},{"post_id":"ciw63jivv01bx0jxlx0tblncd","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jiw701c10jxlxnvw1h78"},{"post_id":"ciw63jivv01bx0jxlx0tblncd","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jiw701c20jxlgcfw6xsg"},{"post_id":"ciw63jivv01bx0jxlx0tblncd","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jiw701c30jxldlxob0q9"},{"post_id":"ciw63jiw901c40jxl6cg3y307","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiwd01c60jxlvlp21mze"},{"post_id":"ciw63jiw901c40jxl6cg3y307","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jiwf01c70jxlcvvcgmgx"},{"post_id":"ciw63jiw901c40jxl6cg3y307","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jiwf01c80jxlw1qkoyex"},{"post_id":"ciw63jiw901c40jxl6cg3y307","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jiwf01c90jxlkvwlp455"},{"post_id":"ciw63jiwh01ca0jxlk0fksknq","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiwr01cc0jxl9vnntw2e"},{"post_id":"ciw63jiwh01ca0jxlk0fksknq","tag_id":"ciw63jibu00rz0jxl3n33qhuq","_id":"ciw63jiws01cd0jxlqy9w69ot"},{"post_id":"ciw63jiwh01ca0jxlk0fksknq","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jiwt01ce0jxlp5q3vaub"},{"post_id":"ciw63jiwv01cf0jxl66e57f5q","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jix301ch0jxl0tgo71kb"},{"post_id":"ciw63jiwv01cf0jxl66e57f5q","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jix801ci0jxl4t53jwea"},{"post_id":"ciw63jiwv01cf0jxl66e57f5q","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jix801cj0jxlg5blvpwi"},{"post_id":"ciw63jiwv01cf0jxl66e57f5q","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jix801ck0jxlcm2cvulg"},{"post_id":"ciw63jiwv01cf0jxl66e57f5q","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jix801cl0jxldcaot1vz"},{"post_id":"ciw63jix901cm0jxl98w2oj35","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jixc01co0jxlbqr9hyxn"},{"post_id":"ciw63jix901cm0jxl98w2oj35","tag_id":"ciw63jib300r40jxlp8bezx1h","_id":"ciw63jixi01cp0jxlmmccoaut"},{"post_id":"ciw63jix901cm0jxl98w2oj35","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jixi01cq0jxlmi56f03t"},{"post_id":"ciw63jix901cm0jxl98w2oj35","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jixj01cr0jxlv925agf3"},{"post_id":"ciw63jix901cm0jxl98w2oj35","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jixj01cs0jxlq3d3ddke"},{"post_id":"ciw63jixp01ct0jxl7il6ob6a","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jixv01cv0jxlvxpy63z5"},{"post_id":"ciw63jixp01ct0jxl7il6ob6a","tag_id":"ciw63jibu00rz0jxl3n33qhuq","_id":"ciw63jiy001cw0jxl3f7helns"},{"post_id":"ciw63jixp01ct0jxl7il6ob6a","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jiy001cx0jxlqvnm5dmk"},{"post_id":"ciw63jiy401cy0jxl6ggnbtmp","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiy901d00jxl4ink3043"},{"post_id":"ciw63jiy401cy0jxl6ggnbtmp","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jiyd01d10jxlznn2fp1p"},{"post_id":"ciw63jiy401cy0jxl6ggnbtmp","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jiye01d20jxl50svrvdu"},{"post_id":"ciw63jiy401cy0jxl6ggnbtmp","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jiye01d30jxl3qnln8k1"},{"post_id":"ciw63jiyg01d40jxl9wxatk99","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiyn01d60jxliv19disx"},{"post_id":"ciw63jiyg01d40jxl9wxatk99","tag_id":"ciw63jit501a70jxlu083841e","_id":"ciw63jiys01d70jxlbi59basv"},{"post_id":"ciw63jiyg01d40jxl9wxatk99","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jiys01d80jxlcamos42d"},{"post_id":"ciw63jiyg01d40jxl9wxatk99","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jiys01d90jxlw1vefxai"},{"post_id":"ciw63jiyg01d40jxl9wxatk99","tag_id":"ciw63jhxb00cl0jxlml0trzh4","_id":"ciw63jiys01da0jxlqc665k67"},{"post_id":"ciw63jiyg01d40jxl9wxatk99","tag_id":"ciw63jhxc00cn0jxlltgipqjc","_id":"ciw63jiys01db0jxlbp2sik2a"},{"post_id":"ciw63jiyt01dc0jxla5ey09jb","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiz101de0jxlrsss3u91"},{"post_id":"ciw63jiyt01dc0jxla5ey09jb","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jiz401df0jxl0ez8b6ma"},{"post_id":"ciw63jiyt01dc0jxla5ey09jb","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jiz401dg0jxlg0gnc7hf"},{"post_id":"ciw63jiyt01dc0jxla5ey09jb","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jiz401dh0jxl6gbkorbq"},{"post_id":"ciw63jiyt01dc0jxla5ey09jb","tag_id":"ciw63ji8600my0jxlof6ie4v3","_id":"ciw63jiz401di0jxl7lq8ud24"},{"post_id":"ciw63jiz401dj0jxlu6j1rktr","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jiz901dl0jxlg4ym48rr"},{"post_id":"ciw63jiz401dj0jxlu6j1rktr","tag_id":"ciw63jhvu009l0jxlrt41ik9x","_id":"ciw63jizd01dm0jxlxtfwkftl"},{"post_id":"ciw63jiz401dj0jxlu6j1rktr","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jizd01dn0jxlsq5jc582"},{"post_id":"ciw63jiz401dj0jxlu6j1rktr","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jizd01do0jxlgn2m6eeu"},{"post_id":"ciw63jiz401dj0jxlu6j1rktr","tag_id":"ciw63jhvv009m0jxl6qtqkgdq","_id":"ciw63jizd01dp0jxl1onwydxf"},{"post_id":"ciw63jizd01dq0jxlld4l2j8g","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jizh01ds0jxlr017n2eb"},{"post_id":"ciw63jizd01dq0jxlld4l2j8g","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jizj01dt0jxl45l5vguc"},{"post_id":"ciw63jizd01dq0jxlld4l2j8g","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jizj01du0jxlgkvcsn3l"},{"post_id":"ciw63jizk01dv0jxlgaus4s3u","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jizv01dy0jxl5cip4xgk"},{"post_id":"ciw63jizk01dv0jxlgaus4s3u","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63jizx01dz0jxlrcywsfk6"},{"post_id":"ciw63jizk01dv0jxlgaus4s3u","tag_id":"ciw63jizs01dx0jxlxpi4rut5","_id":"ciw63jizx01e00jxl14d5tu5m"},{"post_id":"ciw63jizk01dv0jxlgaus4s3u","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jizx01e10jxld8ll6xt4"},{"post_id":"ciw63jizk01dv0jxlgaus4s3u","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jizx01e20jxlieljdkec"},{"post_id":"ciw63jizy01e30jxlqymgfkh3","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj0201e50jxlecr0klzr"},{"post_id":"ciw63jizy01e30jxlqymgfkh3","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jj0401e60jxlu4ecg3m8"},{"post_id":"ciw63jizy01e30jxlqymgfkh3","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jj0401e70jxlmj365eyf"},{"post_id":"ciw63jizy01e30jxlqymgfkh3","tag_id":"ciw63jhq9001z0jxls0zdq3cq","_id":"ciw63jj0401e80jxl4v2s2x0p"},{"post_id":"ciw63jj0501e90jxl4g7dt908","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj0b01eb0jxls2y1uzqx"},{"post_id":"ciw63jj0501e90jxl4g7dt908","tag_id":"ciw63jik5010w0jxly6w4c73a","_id":"ciw63jj0f01ec0jxlkya3d1ft"},{"post_id":"ciw63jj0501e90jxl4g7dt908","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jj0f01ed0jxlweiid9yu"},{"post_id":"ciw63jj0501e90jxl4g7dt908","tag_id":"ciw63jhwa00al0jxlcb3r95mn","_id":"ciw63jj0f01ee0jxlgrsuadr2"},{"post_id":"ciw63jj0501e90jxl4g7dt908","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jj0f01ef0jxlrqqnzqwk"},{"post_id":"ciw63jj0g01eg0jxlmt1oziud","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj0k01ei0jxlvj8jicxc"},{"post_id":"ciw63jj0g01eg0jxlmt1oziud","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jj0o01ej0jxlrnh21gd8"},{"post_id":"ciw63jj0g01eg0jxlmt1oziud","tag_id":"ciw63jhvu009l0jxlrt41ik9x","_id":"ciw63jj0o01ek0jxl00plc1c4"},{"post_id":"ciw63jj0g01eg0jxlmt1oziud","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jj0o01el0jxlpb2iwywo"},{"post_id":"ciw63jj0g01eg0jxlmt1oziud","tag_id":"ciw63jhvv009m0jxl6qtqkgdq","_id":"ciw63jj0o01em0jxleflezfdh"},{"post_id":"ciw63jj0p01en0jxl4l3s7tlx","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj0s01ep0jxl13lqouwl"},{"post_id":"ciw63jj0p01en0jxl4l3s7tlx","tag_id":"ciw63jhvu009l0jxlrt41ik9x","_id":"ciw63jj0v01eq0jxlf1s84xsj"},{"post_id":"ciw63jj0p01en0jxl4l3s7tlx","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jj0v01er0jxly3wjq3md"},{"post_id":"ciw63jj0p01en0jxl4l3s7tlx","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jj0v01es0jxlubdisost"},{"post_id":"ciw63jj0p01en0jxl4l3s7tlx","tag_id":"ciw63jhvv009m0jxl6qtqkgdq","_id":"ciw63jj0v01et0jxlgdwz0ijc"},{"post_id":"ciw63jj0y01eu0jxlh7km3gl6","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj1201ew0jxl94mkhs27"},{"post_id":"ciw63jj0y01eu0jxlh7km3gl6","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jj1401ex0jxladw9yqf0"},{"post_id":"ciw63jj0y01eu0jxlh7km3gl6","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jj1501ey0jxl6g300oiw"},{"post_id":"ciw63jj0y01eu0jxlh7km3gl6","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jj1501ez0jxl27qc2ub2"},{"post_id":"ciw63jj0y01eu0jxlh7km3gl6","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jj1501f00jxlklhquql4"},{"post_id":"ciw63jj1501f10jxl5z2srfqc","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj1901f30jxlem2v4jhg"},{"post_id":"ciw63jj1501f10jxl5z2srfqc","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jj1a01f40jxlee8r350q"},{"post_id":"ciw63jj1501f10jxl5z2srfqc","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jj1a01f50jxlaguortbf"},{"post_id":"ciw63jj1b01f60jxl24qpn1l2","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj1f01f80jxlfzq9p6g3"},{"post_id":"ciw63jj1b01f60jxl24qpn1l2","tag_id":"ciw63jhyi00e90jxlt54qj9zw","_id":"ciw63jj1g01f90jxl0lzqs609"},{"post_id":"ciw63jj1h01fa0jxlsxrvxs03","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj1k01fc0jxlaipplzpd"},{"post_id":"ciw63jj1h01fa0jxlsxrvxs03","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jj1n01fd0jxlwgnhv3uh"},{"post_id":"ciw63jj1h01fa0jxlsxrvxs03","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jj1o01fe0jxlz03jin42"},{"post_id":"ciw63jj1h01fa0jxlsxrvxs03","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jj1o01ff0jxli4l4fhha"},{"post_id":"ciw63jj1h01fa0jxlsxrvxs03","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jj1o01fg0jxlg8m5zrdg"},{"post_id":"ciw63jj1h01fa0jxlsxrvxs03","tag_id":"ciw63ji8b00n80jxllu45i47s","_id":"ciw63jj1o01fh0jxlakuz9xst"},{"post_id":"ciw63jj1q01fi0jxlg06ly3qi","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj1t01fk0jxl5pt2lzvx"},{"post_id":"ciw63jj1q01fi0jxlg06ly3qi","tag_id":"ciw63jhty006o0jxlfk01cryd","_id":"ciw63jj1w01fl0jxl3bdt57ep"},{"post_id":"ciw63jj1q01fi0jxlg06ly3qi","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jj1w01fm0jxl5pgmvq4i"},{"post_id":"ciw63jj1q01fi0jxlg06ly3qi","tag_id":"ciw63jhqg002b0jxl534swffv","_id":"ciw63jj1w01fn0jxlib2lqto8"},{"post_id":"ciw63jj1x01fo0jxljb2rauke","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj2301fq0jxl5nqex1h8"},{"post_id":"ciw63jj1x01fo0jxljb2rauke","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jj2501fr0jxli2khlfuk"},{"post_id":"ciw63jj1x01fo0jxljb2rauke","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jj2501fs0jxlvkaw5vj5"},{"post_id":"ciw63jj2601ft0jxl0fyw485h","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj2901fv0jxlp2qrtuso"},{"post_id":"ciw63jj2601ft0jxl0fyw485h","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jj2b01fw0jxlzlkhkzk9"},{"post_id":"ciw63jj2601ft0jxl0fyw485h","tag_id":"ciw63jhp4000k0jxl6dxtsl10","_id":"ciw63jj2b01fx0jxl0ae5sfnu"},{"post_id":"ciw63jj2c01fy0jxlhdv5t1lw","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj2f01g00jxlk70fgue3"},{"post_id":"ciw63jj2c01fy0jxlhdv5t1lw","tag_id":"ciw63jibu00rz0jxl3n33qhuq","_id":"ciw63jj2h01g10jxl90i2dn1k"},{"post_id":"ciw63jj2c01fy0jxlhdv5t1lw","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jj2h01g20jxlg6e5kn0g"},{"post_id":"ciw63jj2h01g30jxlhs4twjbt","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj2r01g60jxl9ys6ytuc"},{"post_id":"ciw63jj2h01g30jxlhs4twjbt","tag_id":"ciw63jhqk002k0jxliuhphaht","_id":"ciw63jj2u01g70jxlhcdm851c"},{"post_id":"ciw63jj2h01g30jxlhs4twjbt","tag_id":"ciw63jj2p01g50jxl0so56vbv","_id":"ciw63jj2u01g80jxlvek8ai2a"},{"post_id":"ciw63jj2h01g30jxlhs4twjbt","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jj2u01g90jxlya6a93yg"},{"post_id":"ciw63jj2u01ga0jxl62fut59c","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj2z01gc0jxlip3m21e5"},{"post_id":"ciw63jj2u01ga0jxl62fut59c","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jj3201gd0jxlb4uirfaw"},{"post_id":"ciw63jj2u01ga0jxl62fut59c","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jj3201ge0jxlx9onv8wd"},{"post_id":"ciw63jj2u01ga0jxl62fut59c","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jj3201gf0jxlnrmy11v4"},{"post_id":"ciw63jj3201gg0jxldhxgs6vm","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj3601gi0jxlvfhpbb2j"},{"post_id":"ciw63jj3201gg0jxldhxgs6vm","tag_id":"ciw63jib300r40jxlp8bezx1h","_id":"ciw63jj3901gj0jxlxlslv38m"},{"post_id":"ciw63jj3201gg0jxldhxgs6vm","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jj3901gk0jxl0v27b4m9"},{"post_id":"ciw63jj3201gg0jxldhxgs6vm","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jj3901gl0jxlif5yr252"},{"post_id":"ciw63jj3201gg0jxldhxgs6vm","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jj3901gm0jxl0fsfz6i1"},{"post_id":"ciw63jj3a01gn0jxlhxbnjmp9","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj3d01gp0jxleq21s8y0"},{"post_id":"ciw63jj3a01gn0jxlhxbnjmp9","tag_id":"ciw63jicm00sk0jxlbe3dhlkf","_id":"ciw63jj3g01gq0jxlsvypdhcp"},{"post_id":"ciw63jj3a01gn0jxlhxbnjmp9","tag_id":"ciw63jieh00tt0jxl1u35xk15","_id":"ciw63jj3g01gr0jxl2qy21kjl"},{"post_id":"ciw63jj3a01gn0jxlhxbnjmp9","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jj3g01gs0jxli6k6wi78"},{"post_id":"ciw63jj3g01gt0jxlkxdwd32p","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj3k01gv0jxlqelhdw5n"},{"post_id":"ciw63jj3g01gt0jxlkxdwd32p","tag_id":"ciw63jhoi00040jxlq9c11mdx","_id":"ciw63jj3n01gw0jxlpx1fz88v"},{"post_id":"ciw63jj3g01gt0jxlkxdwd32p","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jj3n01gx0jxlsszwqeh8"},{"post_id":"ciw63jj3g01gt0jxlkxdwd32p","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jj3n01gy0jxlx6wppdu4"},{"post_id":"ciw63jj3g01gt0jxlkxdwd32p","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jj3n01gz0jxl8948rl3p"},{"post_id":"ciw63jj3n01h00jxl0k4v6l4e","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj3s01h20jxlegs5gw7a"},{"post_id":"ciw63jj3n01h00jxl0k4v6l4e","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jj3u01h30jxl5jw1eof5"},{"post_id":"ciw63jj3n01h00jxl0k4v6l4e","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jj3u01h40jxlo6iervin"},{"post_id":"ciw63jj3n01h00jxl0k4v6l4e","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jj3u01h50jxlis373ct3"},{"post_id":"ciw63jj3w01h60jxla7ocz91w","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj4201h80jxl7jg8vb1r"},{"post_id":"ciw63jj3w01h60jxla7ocz91w","tag_id":"ciw63jhq2001o0jxl02qsq8w1","_id":"ciw63jj4401h90jxlhjbuacp4"},{"post_id":"ciw63jj3w01h60jxla7ocz91w","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jj4401ha0jxl19wt2qhy"},{"post_id":"ciw63jj3w01h60jxla7ocz91w","tag_id":"ciw63jhqo002s0jxl0vvekmbq","_id":"ciw63jj4401hb0jxl08nw2862"},{"post_id":"ciw63jj4501hc0jxlirv62qyg","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj4901he0jxlox45bs6h"},{"post_id":"ciw63jj4501hc0jxlirv62qyg","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jj4c01hf0jxl88ixxd7t"},{"post_id":"ciw63jj4501hc0jxlirv62qyg","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jj4c01hg0jxlgcv2u96f"},{"post_id":"ciw63jj4501hc0jxlirv62qyg","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jj4c01hh0jxlqrn3jjg3"},{"post_id":"ciw63jj4501hc0jxlirv62qyg","tag_id":"ciw63jhpx001i0jxl91nj8060","_id":"ciw63jj4c01hi0jxl6y0ul2fc"},{"post_id":"ciw63jj4d01hj0jxlekqpkdy6","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj4k01hl0jxl0ccln3ch"},{"post_id":"ciw63jj4d01hj0jxlekqpkdy6","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jj4m01hm0jxlherjhge8"},{"post_id":"ciw63jj4d01hj0jxlekqpkdy6","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jj4m01hn0jxljs603bzx"},{"post_id":"ciw63jj4d01hj0jxlekqpkdy6","tag_id":"ciw63jhq9001z0jxls0zdq3cq","_id":"ciw63jj4m01ho0jxl1l83wxkt"},{"post_id":"ciw63jj4n01hp0jxllof8dkew","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj4q01hr0jxlpksznqd7"},{"post_id":"ciw63jj4n01hp0jxllof8dkew","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jj4u01hs0jxl4itkc6gd"},{"post_id":"ciw63jj4n01hp0jxllof8dkew","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jj4u01ht0jxlha2ctxe6"},{"post_id":"ciw63jj4n01hp0jxllof8dkew","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jj4u01hu0jxlfk1s6i4v"},{"post_id":"ciw63jj4n01hp0jxllof8dkew","tag_id":"ciw63jis0019d0jxl2xnbg13b","_id":"ciw63jj4u01hv0jxlj46kf2dp"},{"post_id":"ciw63jj4v01hw0jxls0pz1a24","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj4z01hy0jxlb17y9dcq"},{"post_id":"ciw63jj4v01hw0jxls0pz1a24","tag_id":"ciw63jhte005o0jxllyywhtlr","_id":"ciw63jj5101hz0jxlxfmr8azr"},{"post_id":"ciw63jj4v01hw0jxls0pz1a24","tag_id":"ciw63jhxf00cw0jxl8w27xggy","_id":"ciw63jj5101i00jxldja6fcj8"},{"post_id":"ciw63jj4v01hw0jxls0pz1a24","tag_id":"ciw63jhst004j0jxl3axcaggd","_id":"ciw63jj5101i10jxl3ovja2yp"},{"post_id":"ciw63jj5201i20jxlb9zeyzxs","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj5501i40jxlw5z47oq6"},{"post_id":"ciw63jj5201i20jxlb9zeyzxs","tag_id":"ciw63jibu00rz0jxl3n33qhuq","_id":"ciw63jj5701i50jxlq29xqbca"},{"post_id":"ciw63jj5201i20jxlb9zeyzxs","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jj5701i60jxlyiv3dn12"},{"post_id":"ciw63jj5701i70jxl47x9lp3g","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj5b01i90jxl9g75sumx"},{"post_id":"ciw63jj5701i70jxl47x9lp3g","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jj5d01ia0jxlir1haisd"},{"post_id":"ciw63jj5701i70jxl47x9lp3g","tag_id":"ciw63jhsx004v0jxld0xyla0o","_id":"ciw63jj5d01ib0jxlccjpk9n6"},{"post_id":"ciw63jj5e01ic0jxl76ncx0ym","tag_id":"ciw63jhts006d0jxlz4z9x564","_id":"ciw63jj5h01ie0jxlm6g8ievm"},{"post_id":"ciw63jj5e01ic0jxl76ncx0ym","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj5l01if0jxlau4d0oji"},{"post_id":"ciw63jj5e01ic0jxl76ncx0ym","tag_id":"ciw63jhtd005n0jxlf8u9127l","_id":"ciw63jj5m01ig0jxl8ighfx2a"},{"post_id":"ciw63jj5e01ic0jxl76ncx0ym","tag_id":"ciw63jhoj00060jxlxiut5i63","_id":"ciw63jj5m01ih0jxl58f5dxz0"},{"post_id":"ciw63jj5n01ii0jxlouqferis","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj5r01ik0jxl0fz9bypc"},{"post_id":"ciw63jj5n01ii0jxlouqferis","tag_id":"ciw63jhvu009l0jxlrt41ik9x","_id":"ciw63jj5u01il0jxlju1sbpht"},{"post_id":"ciw63jj5n01ii0jxlouqferis","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jj5u01im0jxlconf55ia"},{"post_id":"ciw63jj5n01ii0jxlouqferis","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jj5u01in0jxl1ic4u11w"},{"post_id":"ciw63jj5n01ii0jxlouqferis","tag_id":"ciw63jhvv009m0jxl6qtqkgdq","_id":"ciw63jj5u01io0jxlmxkao113"},{"post_id":"ciw63jj5v01ip0jxlz1c34o0f","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj5z01ir0jxlip2syrtl"},{"post_id":"ciw63jj5v01ip0jxlz1c34o0f","tag_id":"ciw63jigr00wq0jxl0s44hagj","_id":"ciw63jj6201is0jxlh4ih07kz"},{"post_id":"ciw63jj5v01ip0jxlz1c34o0f","tag_id":"ciw63jhrw003h0jxldg4y0la6","_id":"ciw63jj6201it0jxl81y147q8"},{"post_id":"ciw63jj5v01ip0jxlz1c34o0f","tag_id":"ciw63jhwz00c30jxldi3x3lp8","_id":"ciw63jj6201iu0jxlnws9qank"},{"post_id":"ciw63jj6301iv0jxl7r3j2apw","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj6701ix0jxl00pwpo8w"},{"post_id":"ciw63jj6301iv0jxl7r3j2apw","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jj6901iy0jxlub99rv7s"},{"post_id":"ciw63jj6301iv0jxl7r3j2apw","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jj6901iz0jxl9tu7hh3u"},{"post_id":"ciw63jj6301iv0jxl7r3j2apw","tag_id":"ciw63jhpj00140jxleukd6jkz","_id":"ciw63jj6901j00jxll8kiobxy"},{"post_id":"ciw63jj6a01j10jxlxlsrqqz1","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jj6f01j40jxlrbszgkzz"},{"post_id":"ciw63jj6a01j10jxlxlsrqqz1","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jj6i01j50jxlhw4d1ig7"},{"post_id":"ciw63jj6a01j10jxlxlsrqqz1","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jj6i01j60jxltj0yh0ii"},{"post_id":"ciw63jj6a01j10jxlxlsrqqz1","tag_id":"ciw63jj6d01j30jxlgrfgfw56","_id":"ciw63jj6i01j70jxl2jogb30m"},{"post_id":"ciw63jj6a01j10jxlxlsrqqz1","tag_id":"ciw63jhxf00cx0jxldycnzaqz","_id":"ciw63jj6i01j80jxlsekufx3v"},{"post_id":"ciw63jj6j01j90jxlv5jxgrxs","tag_id":"ciw63jhsm00440jxlt4lia4dr","_id":"ciw63jj6n01jb0jxl9zsvvwam"},{"post_id":"ciw63jj6j01j90jxlv5jxgrxs","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jj6o01jc0jxlld9pz5w9"},{"post_id":"ciw63jj6u01jf0jxlwgane189","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj7001ji0jxl4cp3ew4a"},{"post_id":"ciw63jj6u01jf0jxlwgane189","tag_id":"ciw63jj6x01jh0jxl00pki56o","_id":"ciw63jj7301jj0jxl96qthq7z"},{"post_id":"ciw63jj6u01jf0jxlwgane189","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jj7301jk0jxl5km42tqc"},{"post_id":"ciw63jj6u01jf0jxlwgane189","tag_id":"ciw63jhq900200jxlvz7dqehn","_id":"ciw63jj7301jl0jxljcfq7w5i"},{"post_id":"ciw63jj6u01jf0jxlwgane189","tag_id":"ciw63jhq9001z0jxls0zdq3cq","_id":"ciw63jj7301jm0jxly18vms16"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj7b01js0jxlh6s3133y"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","tag_id":"ciw63jj6x01jh0jxl00pki56o","_id":"ciw63jj7g01jt0jxl0mrgrmpn"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","tag_id":"ciw63jhty006o0jxlfk01cryd","_id":"ciw63jj7g01ju0jxlqirh61wc"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","tag_id":"ciw63jhqg002a0jxlqdm5cubb","_id":"ciw63jj7g01jv0jxlu5v78ro8"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","tag_id":"ciw63jhqg002b0jxl534swffv","_id":"ciw63jj7g01jw0jxlo7jczoej"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","tag_id":"ciw63jj7701jp0jxli9z3y2xk","_id":"ciw63jj7g01jx0jxl4eudzkut"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","tag_id":"ciw63jj7801jq0jxlzcjwb46t","_id":"ciw63jj7g01jy0jxlvs9xdboy"},{"post_id":"ciw63jj7301jn0jxlwoxv1dlw","tag_id":"ciw63jj7901jr0jxlccsaumxj","_id":"ciw63jj7g01jz0jxlfih6ri7v"},{"post_id":"ciw63jj7h01k00jxlxqzdujm3","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj7m01k30jxl6y09u3aa"},{"post_id":"ciw63jj7h01k00jxlxqzdujm3","tag_id":"ciw63jj7k01k20jxljjx64if6","_id":"ciw63jj7q01k40jxl7rqxxs51"},{"post_id":"ciw63jj7h01k00jxlxqzdujm3","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jj7q01k50jxldzm7bz1x"},{"post_id":"ciw63jj7h01k00jxlxqzdujm3","tag_id":"ciw63jhpb000u0jxll03kxb4f","_id":"ciw63jj7q01k60jxln49xoo0u"},{"post_id":"ciw63jj7h01k00jxlxqzdujm3","tag_id":"ciw63jia100pk0jxlktye1yxo","_id":"ciw63jj7q01k70jxlzggy6pzo"},{"post_id":"ciw63jj7h01k00jxlxqzdujm3","tag_id":"ciw63jhpc000v0jxlbabpmonf","_id":"ciw63jj7q01k80jxleybxiwel"},{"post_id":"ciw63jj7r01k90jxl3gt6aevw","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj7w01kc0jxlkkdvubcz"},{"post_id":"ciw63jj7r01k90jxl3gt6aevw","tag_id":"ciw63jj7k01k20jxljjx64if6","_id":"ciw63jj7z01kd0jxlidrwlhei"},{"post_id":"ciw63jj7r01k90jxl3gt6aevw","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jj7z01ke0jxlxrrixbvm"},{"post_id":"ciw63jj7r01k90jxl3gt6aevw","tag_id":"ciw63jhub007d0jxl3anjvnqu","_id":"ciw63jj7z01kf0jxlxzszlnrl"},{"post_id":"ciw63jj7r01k90jxl3gt6aevw","tag_id":"ciw63jj7u01kb0jxlxhweubgr","_id":"ciw63jj7z01kg0jxlenvwxs0z"},{"post_id":"ciw63jj8001kh0jxl4fgotskf","tag_id":"ciw63jhp3000i0jxltoz7uh24","_id":"ciw63jj8401kj0jxl51rqi9hi"},{"post_id":"ciw63jj8001kh0jxl4fgotskf","tag_id":"ciw63jj7k01k20jxljjx64if6","_id":"ciw63jj8701kk0jxlafqb4cde"},{"post_id":"ciw63jj8001kh0jxl4fgotskf","tag_id":"ciw63jhwm00bg0jxl2evdv197","_id":"ciw63jj8701kl0jxle41a1wsx"},{"post_id":"ciw63jj8001kh0jxl4fgotskf","tag_id":"ciw63jhyi00e90jxlt54qj9zw","_id":"ciw63jj8701km0jxlo47pepfm"},{"post_id":"ciw63jj8001kh0jxl4fgotskf","tag_id":"ciw63jhz800f80jxll7pca22r","_id":"ciw63jj8701kn0jxlt4l5u4bc"},{"post_id":"ciw63jj8801ko0jxl1j28j47t","tag_id":"ciw63jhtn00650jxlonr5466y","_id":"ciw63jj8b01kq0jxlnnyqnmx8"},{"post_id":"ciw63jj8801ko0jxl1j28j47t","tag_id":"ciw63jhtn00640jxlsk9k6czx","_id":"ciw63jj8e01kr0jxlelwwbaal"},{"post_id":"ciw63jj8801ko0jxl1j28j47t","tag_id":"ciw63jhtx006m0jxluzj0jf4j","_id":"ciw63jj8e01ks0jxlz4qu4jtn"},{"post_id":"ciw63jj8801ko0jxl1j28j47t","tag_id":"ciw63jhtz006p0jxlzb045m36","_id":"ciw63jj8e01kt0jxl43qspob8"},{"post_id":"ciw63jj8j01ku0jxlp060q84c","tag_id":"ciw63jj8l01kw0jxl165awphv","_id":"ciw63jj8p01ky0jxlsq6011ml"},{"post_id":"ciw63jj8j01ku0jxlp060q84c","tag_id":"ciw63jieh00tt0jxl1u35xk15","_id":"ciw63jj8r01kz0jxlh1rtqtup"},{"post_id":"ciw63jj8j01ku0jxlp060q84c","tag_id":"ciw63jj8n01kx0jxlwp14uqg7","_id":"ciw63jj8r01l00jxlar36baps"},{"post_id":"ciw63jj8j01ku0jxlp060q84c","tag_id":"ciw63jhoi00050jxl9fk4hj50","_id":"ciw63jj8r01l10jxl05989141"},{"post_id":"ciw63jj8s01l20jxlvvarnld5","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jj9001l50jxlq1qj0svr"},{"post_id":"ciw63jj8s01l20jxlvvarnld5","tag_id":"ciw63jhz200f00jxlt3em0nmt","_id":"ciw63jj9401l60jxlzxvj11ml"},{"post_id":"ciw63jj8s01l20jxlvvarnld5","tag_id":"ciw63jj8w01l40jxlpnr8qun9","_id":"ciw63jj9401l70jxl2hhxnshz"},{"post_id":"ciw63jj8s01l20jxlvvarnld5","tag_id":"ciw63jhpa000s0jxllupxqnqt","_id":"ciw63jj9401l80jxl137eiivb"},{"post_id":"ciw63jj8s01l20jxlvvarnld5","tag_id":"ciw63jhpb000t0jxldwjgc5f6","_id":"ciw63jj9401l90jxlbws9ebdv"},{"post_id":"ciw63jj8s01l20jxlvvarnld5","tag_id":"ciw63jib300r40jxlp8bezx1h","_id":"ciw63jj9401la0jxl73e86mw0"},{"post_id":"ciw63jj9501lb0jxlyjaha09p","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jj9a01le0jxl8h3fhmh2"},{"post_id":"ciw63jj9501lb0jxlyjaha09p","tag_id":"ciw63jhpp001c0jxlc97i72kz","_id":"ciw63jj9c01lf0jxlg0akju7f"},{"post_id":"ciw63jj9501lb0jxlyjaha09p","tag_id":"ciw63jj9801ld0jxlljkeet6s","_id":"ciw63jj9c01lg0jxl22twxfq5"},{"post_id":"ciw63jj9d01lh0jxlurhl3zas","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jj9h01lj0jxlww0b0hqy"},{"post_id":"ciw63jj9d01lh0jxlurhl3zas","tag_id":"ciw63jhqo002s0jxl0vvekmbq","_id":"ciw63jj9j01lk0jxlx3lpu0rs"},{"post_id":"ciw63jj9d01lh0jxlurhl3zas","tag_id":"ciw63jhwz00c30jxldi3x3lp8","_id":"ciw63jj9j01ll0jxlnxggkwgy"},{"post_id":"ciw63jj9d01lh0jxlurhl3zas","tag_id":"ciw63jhp4000l0jxl03f4ayeq","_id":"ciw63jj9j01lm0jxl2dhif2gk"},{"post_id":"ciw63jj9k01ln0jxl610afd2a","tag_id":"ciw63jhoe00020jxlofclzqgh","_id":"ciw63jj9p01lq0jxlbjamn4wy"},{"post_id":"ciw63jj9k01ln0jxl610afd2a","tag_id":"ciw63jj9n01lp0jxlq0ox5k2c","_id":"ciw63jj9t01lr0jxldl0jgyfm"},{"post_id":"ciw63jj9k01ln0jxl610afd2a","tag_id":"ciw63jivh01bp0jxlend2xfkv","_id":"ciw63jj9t01ls0jxlajc9ctco"},{"post_id":"ciw63jj9k01ln0jxl610afd2a","tag_id":"ciw63jhtt006e0jxlhakhmffy","_id":"ciw63jj9t01lt0jxlcmhmv123"},{"post_id":"ciw63jj9k01ln0jxl610afd2a","tag_id":"ciw63ji9n00p00jxl8j5hpo8r","_id":"ciw63jj9t01lu0jxl3d8i3khy"}],"Tag":[{"name":"","_id":"ciw63jhoe00020jxlofclzqgh"},{"name":"","_id":"ciw63jhoi00030jxlfiukh6ia"},{"name":"","_id":"ciw63jhoi00040jxlq9c11mdx"},{"name":"","_id":"ciw63jhoi00050jxl9fk4hj50"},{"name":"","_id":"ciw63jhoj00060jxlxiut5i63"},{"name":"BZOJ","_id":"ciw63jhp3000i0jxltoz7uh24"},{"name":"ZJOI","_id":"ciw63jhp4000j0jxl0i3smal8"},{"name":"FFT","_id":"ciw63jhp4000k0jxl6dxtsl10"},{"name":"","_id":"ciw63jhp4000l0jxl03f4ayeq"},{"name":"","_id":"ciw63jhpa000s0jxllupxqnqt"},{"name":"Dinic","_id":"ciw63jhpb000t0jxldwjgc5f6"},{"name":"","_id":"ciw63jhpb000u0jxll03kxb4f"},{"name":"Edmonds-Karp","_id":"ciw63jhpc000v0jxlbabpmonf"},{"name":"","_id":"ciw63jhpj00140jxleukd6jkz"},{"name":"DP","_id":"ciw63jhpp001c0jxlc97i72kz"},{"name":"","_id":"ciw63jhpx001i0jxl91nj8060"},{"name":"COGS","_id":"ciw63jhq2001o0jxl02qsq8w1"},{"name":"","_id":"ciw63jhq3001p0jxluez7uhi5"},{"name":"","_id":"ciw63jhq3001q0jxlvltin2kq"},{"name":"","_id":"ciw63jhq9001z0jxls0zdq3cq"},{"name":"","_id":"ciw63jhq900200jxlvz7dqehn"},{"name":"","_id":"ciw63jhqe00290jxll2p85zae"},{"name":"Tarjan","_id":"ciw63jhqg002a0jxlqdm5cubb"},{"name":"","_id":"ciw63jhqg002b0jxl534swffv"},{"name":"","_id":"ciw63jhqk002k0jxliuhphaht"},{"name":"","_id":"ciw63jhqo002s0jxl0vvekmbq"},{"name":"OS X","_id":"ciw63jhqv00300jxlf9goby9h"},{"name":"Linux","_id":"ciw63jhqw00310jxliwkk7834"},{"name":"Archlinux","_id":"ciw63jhqw00320jxl7qd0lj17"},{"name":"VirtualBox","_id":"ciw63jhqx00330jxl0gmba711"},{"name":"","_id":"ciw63jhqx00340jxljvf0s25b"},{"name":"SSH","_id":"ciw63jhqx00350jxlpwot7dr5"},{"name":"UVa","_id":"ciw63jhrv003f0jxl2fvzxu10"},{"name":" DP","_id":"ciw63jhrw003g0jxlomcv3673"},{"name":"","_id":"ciw63jhrw003h0jxldg4y0la6"},{"name":"","_id":"ciw63jhs1003p0jxlk7390dhu"},{"name":"","_id":"ciw63jhs2003q0jxl9xrufqxy"},{"name":"","_id":"ciw63jhsm00430jxlz3455y0p"},{"name":"","_id":"ciw63jhsm00440jxlt4lia4dr"},{"name":" DP","_id":"ciw63jhsp004b0jxl4h5p03lp"},{"name":"","_id":"ciw63jhst004j0jxl3axcaggd"},{"name":"","_id":"ciw63jhst004k0jxl42nd9rzx"},{"name":"","_id":"ciw63jhst004l0jxlyuc95efx"},{"name":" DP","_id":"ciw63jhsx004v0jxld0xyla0o"},{"name":"","_id":"ciw63jht200530jxl3bf9aj93"},{"name":"","_id":"ciw63jht7005b0jxlj5mtp6jt"},{"name":"","_id":"ciw63jht8005c0jxlo598nf80"},{"name":"","_id":"ciw63jht8005d0jxl50oa1dhw"},{"name":"CodeVS","_id":"ciw63jhtd005n0jxlf8u9127l"},{"name":"Tyvj","_id":"ciw63jhte005o0jxllyywhtlr"},{"name":" DP","_id":"ciw63jhte005p0jxlni7rbi2h"},{"name":"TJOI","_id":"ciw63jhth005w0jxldiwq6tgd"},{"name":" DP","_id":"ciw63jhti005x0jxl1yljboft"},{"name":"","_id":"ciw63jhtn00640jxlsk9k6czx"},{"name":"AC ","_id":"ciw63jhtn00650jxlonr5466y"},{"name":"","_id":"ciw63jhts006c0jxlsgx0aj9d"},{"name":"Splay","_id":"ciw63jhts006d0jxlz4z9x564"},{"name":"","_id":"ciw63jhtt006e0jxlhakhmffy"},{"name":"","_id":"ciw63jhtx006m0jxluzj0jf4j"},{"name":"","_id":"ciw63jhty006n0jxli0p4ox3v"},{"name":"","_id":"ciw63jhty006o0jxlfk01cryd"},{"name":"","_id":"ciw63jhtz006p0jxlzb045m36"},{"name":"","_id":"ciw63jhu2006x0jxl0pyk2jka"},{"name":"","_id":"ciw63jhu800750jxltqzcqwj9"},{"name":"","_id":"ciw63jhub007d0jxl3anjvnqu"},{"name":"","_id":"ciw63jhub007e0jxlajuc9pc9"},{"name":"C++","_id":"ciw63jhue007m0jxlw9ocvwvc"},{"name":"STL","_id":"ciw63jhuf007n0jxll83ky6ks"},{"name":"SPOJ","_id":"ciw63jhuh007s0jxlsmej0d1s"},{"name":"SHOI","_id":"ciw63jhv8008j0jxlcq3311hj"},{"name":"","_id":"ciw63jhvc008p0jxl4cnneztw"},{"name":"","_id":"ciw63jhvo00960jxliuj224fd"},{"name":"CDQ","_id":"ciw63jhvu009l0jxlrt41ik9x"},{"name":"","_id":"ciw63jhvv009m0jxl6qtqkgdq"},{"name":"SDOI","_id":"ciw63jhvy009v0jxl60b960rt"},{"name":"","_id":"ciw63jhvz009w0jxlcriylz94"},{"name":"","_id":"ciw63jhvz009x0jxlwq2vyumc"},{"name":"","_id":"ciw63jhvz009y0jxl5ah0p6x5"},{"name":"","_id":"ciw63jhw500aa0jxlnvxx8tjo"},{"name":"","_id":"ciw63jhw900ak0jxlsrx72lu1"},{"name":"","_id":"ciw63jhwa00al0jxlcb3r95mn"},{"name":"","_id":"ciw63jhwa00am0jxl8d14vm7y"},{"name":"RMQ","_id":"ciw63jhwh00b70jxl6btias08"},{"name":"","_id":"ciw63jhwm00bg0jxl2evdv197"},{"name":"","_id":"ciw63jhwu00br0jxlh3va017i"},{"name":"NTT","_id":"ciw63jhwy00c10jxllgrwg96g"},{"name":"","_id":"ciw63jhwy00c20jxlph82yed2"},{"name":"","_id":"ciw63jhwz00c30jxldi3x3lp8"},{"name":"","_id":"ciw63jhwz00c40jxl3124jsej"},{"name":"","_id":"ciw63jhxb00cl0jxlml0trzh4"},{"name":"","_id":"ciw63jhxb00cm0jxlxvh8mi1m"},{"name":"","_id":"ciw63jhxc00cn0jxlltgipqjc"},{"name":"EXGCD","_id":"ciw63jhxf00cw0jxl8w27xggy"},{"name":"BSGS","_id":"ciw63jhxf00cx0jxldycnzaqz"},{"name":"","_id":"ciw63jhy700dw0jxl9jued065"},{"name":"Link-Cut Tree","_id":"ciw63jhy900dx0jxl5sbqxle2"},{"name":"SCOI","_id":"ciw63jhyh00e70jxlk5oole8c"},{"name":"set","_id":"ciw63jhyh00e80jxlxyjsn7f8"},{"name":"","_id":"ciw63jhyi00e90jxlt54qj9zw"},{"name":"","_id":"ciw63jhyx00eq0jxlr65pzvp5"},{"name":" DP","_id":"ciw63jhz200f00jxlt3em0nmt"},{"name":"","_id":"ciw63jhz800f80jxll7pca22r"},{"name":"","_id":"ciw63jhzi00fm0jxlcysuzkz1"},{"name":"","_id":"ciw63jhzr00fw0jxl3ggztg0g"},{"name":"","_id":"ciw63jhzs00fx0jxlpmw6c3oh"},{"name":"","_id":"ciw63ji0g00gi0jxlpojs1evd"},{"name":"","_id":"ciw63ji0u00gr0jxlxmy6hu0g"},{"name":"DFS","_id":"ciw63ji0u00gs0jxliwb5oeoh"},{"name":"POJ","_id":"ciw63ji1f00hk0jxllq5njkuk"},{"name":"KMP","_id":"ciw63ji1h00hl0jxln71pjqxi"},{"name":"Prim","_id":"ciw63ji1s00hs0jxlql3by84v"},{"name":"","_id":"ciw63ji1t00ht0jxllabpkffe"},{"name":"","_id":"ciw63ji1t00hu0jxldz7l04cg"},{"name":"POI","_id":"ciw63ji2900ib0jxlxbmquwbo"},{"name":"NOIP","_id":"ciw63ji4q00jk0jxliceqg0s2"},{"name":"","_id":"ciw63ji5000jp0jxlxobkecs3"},{"name":"","_id":"ciw63ji5u00k10jxl5uu29u23"},{"name":"Floyd","_id":"ciw63ji5z00k60jxlrjezqo7f"},{"name":"","_id":"ciw63ji6600kd0jxlvnzxded6"},{"name":"BFS","_id":"ciw63ji6900ke0jxla7jxzo29"},{"name":"Hash","_id":"ciw63ji6w00l20jxlzspld2po"},{"name":"SPFA","_id":"ciw63ji7700lh0jxlq8uctxec"},{"name":"","_id":"ciw63ji7c00lq0jxl7tnit143"},{"name":"","_id":"ciw63ji7t00mf0jxllk4ai0oq"},{"name":"","_id":"ciw63ji7u00mg0jxlsokmflc4"},{"name":"Vijos","_id":"ciw63ji8400mw0jxlupnspxrk"},{"name":"","_id":"ciw63ji8500mx0jxly8x04au4"},{"name":"","_id":"ciw63ji8600my0jxlof6ie4v3"},{"name":" DP","_id":"ciw63ji8b00n80jxllu45i47s"},{"name":"NOI","_id":"ciw63ji9300oa0jxl2rzilnef"},{"name":"","_id":"ciw63ji9n00p00jxl8j5hpo8r"},{"name":"","_id":"ciw63ji9o00p10jxlgas15ww1"},{"name":"map","_id":"ciw63ji9q00p20jxlt1i1lzay"},{"name":"","_id":"ciw63jia100pk0jxlktye1yxo"},{"name":"","_id":"ciw63jia700pt0jxlqqbgkwv1"},{"name":"","_id":"ciw63jia800pu0jxl7woznesy"},{"name":"LCT","_id":"ciw63jiaq00ql0jxly8oj7y4t"},{"name":"","_id":"ciw63jib300r40jxlp8bezx1h"},{"name":"","_id":"ciw63jibu00rz0jxl3n33qhuq"},{"name":"","_id":"ciw63jicm00sk0jxlbe3dhlkf"},{"name":"Kruskal","_id":"ciw63jicv00sq0jxlg1m6zcnw"},{"name":"","_id":"ciw63jicx00sr0jxlgli6xmsp"},{"name":"Markdown","_id":"ciw63jidc00t30jxl9cqnsgf4"},{"name":"LaTex","_id":"ciw63jide00t40jxl4fo316ru"},{"name":"GitHub","_id":"ciw63jidf00t50jxl9rntdghy"},{"name":"JSOI","_id":"ciw63jieg00ts0jxlmmbzycbr"},{"name":"","_id":"ciw63jieh00tt0jxl1u35xk15"},{"name":"","_id":"ciw63jiew00u70jxl6crivbgk"},{"name":"","_id":"ciw63jif200uh0jxljey7r33n"},{"name":"","_id":"ciw63jig100vr0jxlf0nxsyqy"},{"name":"IOI","_id":"ciw63jigg00wb0jxl83njhx6l"},{"name":"","_id":"ciw63jigl00wi0jxlj1zi81ux"},{"name":"HNOI","_id":"ciw63jigr00wq0jxl0s44hagj"},{"name":"DFS ","_id":"ciw63jih300x50jxlh7mkinw3"},{"name":"Prfer ","_id":"ciw63jihr00xy0jxlg79ndqno"},{"name":"","_id":"ciw63jii400yf0jxlrfnode9m"},{"name":"","_id":"ciw63jii500yg0jxl6984yrny"},{"name":"Burnside ","_id":"ciw63jiih00yw0jxl1jz9zv97"},{"name":"Trie","_id":"ciw63jiiu00zb0jxl1ue6bgq7"},{"name":"HEOI","_id":"ciw63jiiz00zi0jxlqotjh1rh"},{"name":"HDU","_id":"ciw63jij500zp0jxl4vbyq3c9"},{"name":"Bestcoder","_id":"ciw63jij600zq0jxlycdqj844"},{"name":"BestCoder","_id":"ciw63jije01000jxlzinm3bcu"},{"name":"HAOI","_id":"ciw63jijt010h0jxl8sqws4x9"},{"name":"","_id":"ciw63jik5010w0jxly6w4c73a"},{"name":"GDB","_id":"ciw63jild012d0jxl5mspw641"},{"name":"","_id":"ciw63jile012e0jxlwjj9kqvz"},{"name":"FJOI","_id":"ciw63jilk012k0jxlvh2pb5v2"},{"name":"","_id":"ciw63jilp012q0jxl2mkl92ik"},{"name":"CTSC","_id":"ciw63jin001450jxlgvvvhxx3"},{"name":" 24 ","_id":"ciw63jin101460jxlg21f9yab"},{"name":"CQOI","_id":"ciw63jinh014o0jxlkxya95i9"},{"name":"","_id":"ciw63jio5015g0jxlcsu3twdl"},{"name":"","_id":"ciw63jiqg017w0jxlkcyvyyjq"},{"name":"USACO","_id":"ciw63jis0019d0jxl2xnbg13b"},{"name":"COCI","_id":"ciw63jisl019r0jxld3h86f7p"},{"name":"","_id":"ciw63jism019s0jxliyq67tzd"},{"name":"Codeforces","_id":"ciw63jit501a70jxlu083841e"},{"name":"CEOI","_id":"ciw63jiu101ar0jxldp405pkj"},{"name":"Lucas ","_id":"ciw63jiue01az0jxlcf8cgiaw"},{"name":"","_id":"ciw63jivh01bp0jxlend2xfkv"},{"name":"","_id":"ciw63jivj01bq0jxlogd7pwxn"},{"name":"","_id":"ciw63jizs01dx0jxlxpi4rut5"},{"name":"Dijkstra","_id":"ciw63jj2p01g50jxl0so56vbv"},{"name":"","_id":"ciw63jj6d01j30jxlgrfgfw56"},{"name":"APIO","_id":"ciw63jj6x01jh0jxl00pki56o"},{"name":"DAG","_id":"ciw63jj7701jp0jxli9z3y2xk"},{"name":"","_id":"ciw63jj7801jq0jxlzcjwb46t"},{"name":"Bellman-Ford","_id":"ciw63jj7901jr0jxlccsaumxj"},{"name":"AHOI","_id":"ciw63jj7k01k20jxljjx64if6"},{"name":"","_id":"ciw63jj7u01kb0jxlxhweubgr"},{"name":"","_id":"ciw63jj8l01kw0jxl165awphv"},{"name":"","_id":"ciw63jj8n01kx0jxlwp14uqg7"},{"name":"","_id":"ciw63jj8w01l40jxlpnr8qun9"},{"name":"","_id":"ciw63jj9801ld0jxlljkeet6s"},{"name":"","_id":"ciw63jj9n01lp0jxlq0ox5k2c"}]}}