{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":0},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":0},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":0},{"_id":"themes/yelee/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":0},{"_id":"themes/yelee/source/js/clipboard.min.js","path":"js/clipboard.min.js","modified":0},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":0},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":0},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":0},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":0},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":0},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":0},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":0},{"_id":"themes/yelee/source/img/twitter.png","path":"img/twitter.png","modified":0},{"_id":"themes/yelee/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0},{"_id":"themes/yelee/source/img/rss.png","path":"img/rss.png","modified":0},{"_id":"themes/yelee/source/img/pinterest.png","path":"img/pinterest.png","modified":0},{"_id":"themes/yelee/source/img/pinboard.png","path":"img/pinboard.png","modified":0},{"_id":"themes/yelee/source/img/mail.png","path":"img/mail.png","modified":0},{"_id":"themes/yelee/source/img/linkedin.png","path":"img/linkedin.png","modified":0},{"_id":"themes/yelee/source/img/img-loading.png","path":"img/img-loading.png","modified":0},{"_id":"themes/yelee/source/img/img-err.png","path":"img/img-err.png","modified":0},{"_id":"themes/yelee/source/img/google.png","path":"img/google.png","modified":0},{"_id":"themes/yelee/source/img/favicon.png","path":"img/favicon.png","modified":0},{"_id":"themes/yelee/source/img/facebook.png","path":"img/facebook.png","modified":0},{"_id":"themes/yelee/source/img/delicious.png","path":"img/delicious.png","modified":0},{"_id":"themes/yelee/source/img/coderwall.png","path":"img/coderwall.png","modified":0},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":0},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":0},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":0},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":0},{"_id":"themes/yelee/source/img/GitHub.png","path":"img/GitHub.png","modified":0},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.woff2","path":"font-awesome/fonts/fontawesome-webfont.woff2","modified":0},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.woff","path":"font-awesome/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.ttf","path":"font-awesome/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.svg","path":"font-awesome/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.eot","path":"font-awesome/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/yelee/source/font-awesome/fonts/FontAwesome.otf","path":"font-awesome/fonts/FontAwesome.otf","modified":0},{"_id":"themes/yelee/source/font-awesome/css/font-awesome.min.css","path":"font-awesome/css/font-awesome.min.css","modified":0},{"_id":"themes/yelee/source/font-awesome/css/font-awesome.css","path":"font-awesome/css/font-awesome.css","modified":0},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/yelee/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/yelee/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/yelee/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/yelee/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/yelee/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/yelee/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/yelee/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"themes/yelee/source/background/bg-528.jpg","path":"background/bg-528.jpg","modified":0},{"_id":"themes/yelee/source/background/bg-0.jpg","path":"background/bg-0.jpg","modified":0},{"_id":"themes/yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0}],"Cache":[{"_id":"source/_posts/20160318-color.md","shasum":"4ba75ba58df47c2827d754b7cd1403c2e5a4fe5f","modified":1462023308000},{"_id":"source/_posts/20160319-candy.md","shasum":"f13122a5162f37bd168bbe581916353a80bf96ce","modified":1462023308000},{"_id":"source/_posts/20160319-set.md","shasum":"e7eb9c83dfd79c39fa6ab6288487d7451fd8be9f","modified":1462023308000},{"_id":"source/_posts/20160331-naive.md","shasum":"3ff152e74585ff685591863055fd944851352fd7","modified":1462023308000},{"_id":"source/_posts/20160404-theory.md","shasum":"bcb3547e1e9c26d25dbc84bd21c7c6990296c707","modified":1462023308000},{"_id":"source/_posts/20160423-tsc-season-2.md","shasum":"8f38fe10ad1e26c272edaed9721e600e28912095","modified":1462023308000},{"_id":"source/_posts/20160410-tsc-season.md","shasum":"c4dcb352d4c37033ee9c33ea3d7fa298a80d4798","modified":1462023308000},{"_id":"source/_posts/after-ah-studying.md","shasum":"ddfbb0b0cc7fc2f1f02d14557655ac858d208338","modified":1462023308000},{"_id":"source/_posts/ahoi2014-story.md","shasum":"30fcca23d94ffd5808db8a76c0670a12de0b1332","modified":1462023308000},{"_id":"source/_posts/ahoi2008-meet.md","shasum":"e0b091db3a703654300269a5e26b61cc9b345c43","modified":1462023308000},{"_id":"source/_posts/apio2009-atm.md","shasum":"4c8b22e60777afe7205ce9a900eb1a02256c28e8","modified":1462023308000},{"_id":"source/_posts/bzoj-1001.md","shasum":"72d9592ee87d155d313e7f628a8cebfae4aea2da","modified":1462023308000},{"_id":"source/_posts/bzoj-1008.md","shasum":"9e33d15285f7e920f9c945333df08bcb7bcc2c21","modified":1462023308000},{"_id":"source/_posts/bigint-template.md","shasum":"934fda5bea22b36e0606b10d33bc5df2f37d2487","modified":1462023308000},{"_id":"source/_posts/apio2010-commando.md","shasum":"782d0c784adc4329f6fb557eb3191e687ce6885f","modified":1463141856000},{"_id":"source/_posts/bzoj-1251.md","shasum":"c08cd8320d570bccf0d3bc1be414e62b28b8a4da","modified":1462023308000},{"_id":"source/_posts/bzoj-1756.md","shasum":"60bf2403886143b533d0a969f90c410a8550b425","modified":1462023308000},{"_id":"source/_posts/bzoj-2038.md","shasum":"f2168817f10ce4efdc4e11ddb87533de4e0ba411","modified":1462023308000},{"_id":"source/_posts/bzoj-1477.md","shasum":"c595afe04efabe234f97173104721f64efdbd233","modified":1462023308000},{"_id":"source/_posts/bzoj-2143.md","shasum":"c8a1dc5695486f5dd077602a786e1c24a614d87d","modified":1462023308000},{"_id":"source/_posts/bzoj-2296.md","shasum":"23212b789066f8b9bd854f2cb7b3ddea6585ec9e","modified":1462023308000},{"_id":"source/_posts/bzoj-2442.md","shasum":"07bbad31a0e1a252c2a3b7ab351d91ed7436bfba","modified":1462023308000},{"_id":"source/_posts/bzoj-2683.md","shasum":"204c34c005f762dbc66b06bb1c2eda64df31cecb","modified":1462023308000},{"_id":"source/_posts/bzoj-2683/cdq.png","shasum":"a95d0b02b915f092df6656298add0f0fc9662341","modified":1458003954000},{"_id":"source/_posts/bzoj-2820.md","shasum":"b893e9bbcea214b41bef4c502d833a930d123fdb","modified":1462023308000},{"_id":"source/_posts/cf-628d.md","shasum":"42123d6172257256443b00d77669e03ae2202e43","modified":1463137970000},{"_id":"source/_posts/chairman-tree-notes.md","shasum":"8be4f4b6d283778a78c6dc87d141029f34f57d51","modified":1463137970000},{"_id":"source/_posts/bzoj-3511.md","shasum":"a69c5a7b074d933e3eb29d1b2c8a24645520728d","modified":1462023308000},{"_id":"source/_posts/bzoj-4403.md","shasum":"0e503e9c28ace534c15b2b47576add9bd4027af5","modified":1462023308000},{"_id":"source/_posts/codevs-2598.md","shasum":"57489f276b5099ec012397bab14867350537242c","modified":1462023308000},{"_id":"source/_posts/codevs-1345.md","shasum":"4a66985b7a2fecf250efb1f07ce7e6924f61543b","modified":1462023308000},{"_id":"source/_posts/codevs-1563.md","shasum":"5e4631d0fe247656d0a1f8d3d2b27577330a77dc","modified":1462023308000},{"_id":"source/_posts/codevs-2822.md","shasum":"a5f2981e80882ae575f7c28d9552bddbe717915a","modified":1462023308000},{"_id":"source/_posts/codevs-3168-3162.md","shasum":"c048aed02c43807eeea2eba8a44ddb71e7aa88ac","modified":1462023308000},{"_id":"source/_posts/codevs-3269-monotone-queue.md","shasum":"a1931da11b900b7191818a9ea56f1b03744f4561","modified":1462023308000},{"_id":"source/_posts/cogs-14.md","shasum":"df074c69b9f8cacedba8ccea146ac644e8201397","modified":1463137970000},{"_id":"source/_posts/cogs-439.md","shasum":"2426244914406bd35b753d445bb5fcd3e01a5c30","modified":1463137970000},{"_id":"source/_posts/cogs-396.md","shasum":"fbfd2fc22b9c83aa16792fa61d51d702b53461f7","modified":1463137970000},{"_id":"source/_posts/codevs-3269.md","shasum":"d3ddbd5df33b0381145d2df5eb1e289024c7bb72","modified":1463137970000},{"_id":"source/_posts/cogs-727.md","shasum":"d3f3d51ba288685a52479e3847f4e84885fcdb3e","modified":1463137970000},{"_id":"source/_posts/cogs-728.md","shasum":"c7fa068adf3bf1f5f5b4add16374b265ef21ca11","modified":1463137970000},{"_id":"source/_posts/cogs-731.md","shasum":"21f2ea36358f089340c0603b489e2ec962c81b11","modified":1463137970000},{"_id":"source/_posts/cogs-734.md","shasum":"4a748f8ae51d4d1990b89ac8081e53d74fbc183c","modified":1463137970000},{"_id":"source/_posts/cogs-729.md","shasum":"bb45c57f781ff5c8eb0e87b3edadf7b206b81c01","modified":1463137970000},{"_id":"source/_posts/cogs-738.md","shasum":"01a88085f9e1823b8fc63e04a617b85fc1551ade","modified":1463137970000},{"_id":"source/_posts/cogs-741.md","shasum":"91a8b62bd42e7be33d94ae1a9624d5a0d7c2c9a3","modified":1463137970000},{"_id":"source/_posts/cogs-740.md","shasum":"e90060c6feb6273cd400258627f141214574dd8f","modified":1463137970000},{"_id":"source/_posts/cogs-739.md","shasum":"4eb4f215432d85cc7bd93a357ee70d326f314504","modified":1463137970000},{"_id":"source/_posts/cogs-742.md","shasum":"dc5b03c9e8b857ea345e0f906692847cc7c2508b","modified":1463137970000},{"_id":"source/_posts/cogs-746.md","shasum":"aa46c716f60453fdbbfa4ff4ccdca515e90e25ae","modified":1463137970000},{"_id":"source/_posts/combinatorics-notes.md","shasum":"f3e5e1bf1d06c126032426103df6f1990368ad07","modified":1462023308000},{"_id":"source/_posts/cqoi2016-cuts.md","shasum":"96b727a740bc374fefd4b8ca7d1c09b5f20648c4","modified":1462023308000},{"_id":"source/_posts/cqoi2016-number.md","shasum":"c68021501e12e953832b6ddd4c3f07c84d50af72","modified":1462023308000},{"_id":"source/_posts/ctsc-apio-2016.md","shasum":"511e92056cc7bee562650d47f79538e4c09f8614","modified":1462869248000},{"_id":"source/_posts/ctsc1997-course.md","shasum":"40293d82e3028e4a77d6ca087262cef1779be6a6","modified":1462023308000},{"_id":"source/_posts/ctsc1999-home.md","shasum":"978baaae9dd654467febabfa562eea00beb02859","modified":1463137970000},{"_id":"source/_posts/cut-tree-notes/cutTree.png","shasum":"12de28c1f402f876a3826dcd7bfc8525d555ce1e","modified":1458003954000},{"_id":"source/_posts/derangement-number.md","shasum":"1d85fe52fcf017157eeffc96e660b029b83cb31f","modified":1462023308000},{"_id":"source/_posts/cut-tree-notes.md","shasum":"e16fa699ed487724d2d7aa58d90088af35c1770a","modified":1462023308000},{"_id":"source/_posts/dinic-notes.md","shasum":"0378294542c3e68fff50acce4071552b870f0468","modified":1462023308000},{"_id":"source/_posts/edmonds-karp-notes.md","shasum":"6c145828e387d262d0b9fd5cb1c529201815e265","modified":1462023308000},{"_id":"source/_posts/euler-sieve.md","shasum":"bdd661e2b3f1d99f802c6179a97c7c31dd4f883d","modified":1462023308000},{"_id":"source/_posts/gnu-debugger.md","shasum":"a39a3556d1965b8fc4ce3404e23c4aa5587ceca1","modified":1462023308000},{"_id":"source/_posts/haoi2006-cow.md","shasum":"de4e6dcca3e29acdc131063a61ca1f8fd1ee3be1","modified":1462023308000},{"_id":"source/_posts/haoi2011-problemb.md","shasum":"80f9d8191d53d49067ee4e5c654cdc60a8a53384","modified":1462023308000},{"_id":"source/_posts/haoi2015-t2.md","shasum":"5a8c1176a708c9f72c29b173e0e9cb78d4a4f23b","modified":1462023308000},{"_id":"source/_posts/haoi2016-chain.md","shasum":"b722f46a179a7fd0fd2293235b225a75c3343ef2","modified":1462023308000},{"_id":"source/_posts/hdu-2089.md","shasum":"bd3eb90b1e46b12f539378ad07d9df08ee33e3dc","modified":1463137970000},{"_id":"source/_posts/hdu-5632.md","shasum":"79bb7f287472a588c54caefc962814f8990cf698","modified":1463137970000},{"_id":"source/_posts/hnoi2004-pet.md","shasum":"b2bda3d66ff145436b7eab827120e72edbae6c57","modified":1463137970000},{"_id":"source/_posts/hdu-5642.md","shasum":"d2ef96703b69f5ed3c316c5d741df941a96327da","modified":1463137970000},{"_id":"source/_posts/hnoi2008-toy.md","shasum":"247a5e4dfb636799a12dbf18d6afb827535f3c8e","modified":1462023308000},{"_id":"source/_posts/hnoi2016-multiple.md","shasum":"5f8819ca3130cd4e04f7c49a5ff3c52b50fe67a9","modified":1463137970000},{"_id":"source/_posts/hnoi2016-network.md","shasum":"701e1dfb9e177e0b4857e359cc2b2e32392fd4cd","modified":1463137970000},{"_id":"source/_posts/hnoi2016-sequence.md","shasum":"584e140ef6c2aefe78304fcedce69218d3c90d55","modified":1462082383000},{"_id":"source/_posts/hnoi2016-tree.md","shasum":"6ac9191618774abe21d6e19d2d6c874cb4f24ed1","modified":1463137970000},{"_id":"source/_posts/jsoi2008-maxnumber.md","shasum":"973b88d1287688eef3d8f99363a1db35399213db","modified":1462023308000},{"_id":"source/_posts/jsoi2009-game.md","shasum":"7e3bcdfbc619bd881e671216285cd1649f62b87a","modified":1462023308000},{"_id":"source/_posts/jsoi2016-flight.md","shasum":"9f52be4f9cddedb2ab7e6737ce2f387faa9147e6","modified":1463137970000},{"_id":"source/_posts/jsoi2016-light.md","shasum":"58533f261da20e6409234f6aee1ea40049a1f35f","modified":1462023461000},{"_id":"source/_posts/kmp-notes.md","shasum":"716f23d1fb6ac763134dfd9a570a9ce7cc88f3f5","modified":1462023308000},{"_id":"source/_posts/link-cut-tree-notes.md","shasum":"d0dd589310e783f3cc72f2d4a558396dde355f78","modified":1462023308000},{"_id":"source/_posts/minimum-spanning-tree-notes.md","shasum":"5e376a19420ba0d04fbfc86ffb85254f8f33b464","modified":1462023308000},{"_id":"source/_posts/mo-algorithm-notes.md","shasum":"04963d986f2cbd596dfc9d92c1efdbb209e3afb7","modified":1462061712000},{"_id":"source/_posts/markdown-latex-helper.md","shasum":"9646c40f411c104088af99b554ea34af8fb61e3d","modified":1462023308000},{"_id":"source/_posts/monotone-queue-notes.md","shasum":"fc7a11f33c6b9f425dde2c3b3c901e7018aca151","modified":1462023308000},{"_id":"source/_posts/mul-inverse.md","shasum":"88b06571986b29765bc702445e03c7db387ed3b1","modified":1462023308000},{"_id":"source/_posts/noi2003-editor.md","shasum":"6d6ccf7f089180de540cb75879f4589b5c1e8ee4","modified":1462023308000},{"_id":"source/_posts/noi2002-galaxy.md","shasum":"0b62ae091bdecd684968bd8eb0707890d71eeac1","modified":1463137970000},{"_id":"source/_posts/noi2004-cashier.md","shasum":"0504fdf9c3754c9f1fa1b1be8befc3dcf0852794","modified":1463137970000},{"_id":"source/_posts/noi2006-profit.md","shasum":"cdf389673d9a8babd630e8c5bc247670b695bff4","modified":1462023308000},{"_id":"source/_posts/noi2014-sleep.md","shasum":"32c222899af7ba614509f0b5cb66bc0867154960","modified":1462023308000},{"_id":"source/_posts/noi2015-manager.md","shasum":"b718da5118bf865669f6505c4ac9acdba8339316","modified":1462023308000},{"_id":"source/_posts/noi2015-prog.md","shasum":"c48b2df9f1a929593c37d4d625bdd2a5dc293f58","modified":1462023308000},{"_id":"source/_posts/noip2000-cheng-ji-zui-da.md","shasum":"c01126a57a4d55ede4244275242edd8bf58001ca","modified":1462023308000},{"_id":"source/_posts/noip2003-game.md","shasum":"3267324d4b5a6a6a97ee4d4b0b26db2c4da60790","modified":1462023308000},{"_id":"source/_posts/noip2006-budget.md","shasum":"2196977ffc4bcd04e14fce82a9ec2838c4f3992e","modified":1462023308000},{"_id":"source/_posts/noip2006-energy.md","shasum":"95c6a9110f50c8e31813a1147d51a5069519aeb4","modified":1462023308000},{"_id":"source/_posts/noip2010-prison.md","shasum":"1c89f4fba3f01bec85a06ce8e5309a7e6d50f733","modified":1462023308000},{"_id":"source/_posts/noip2012-mod.md","shasum":"0fb6c0ef73a261e10a1b23b235c0492a247c1362","modified":1462023308000},{"_id":"source/_posts/non-recursion-dfs-with-stack.md","shasum":"77777eea132ddbbc8f0201f6438267a80a414656","modified":1462023308000},{"_id":"source/_posts/number-theory-notes-1.md","shasum":"06a1c30f28a21e76f65bc5afc0d9766231d8af32","modified":1462023308000},{"_id":"source/_posts/osx-enable-retina.md","shasum":"ce107893ed50fd33bad30317e10e2237a8ea118d","modified":1462023308000},{"_id":"source/_posts/osx-softwares.md","shasum":"1889f0fdb89578e89f6c34a0a16dfbdd7a2e9c23","modified":1462023308000},{"_id":"source/_posts/poj-1737.md","shasum":"09c4fec6b5a83f1b9b7b8161b0aab0ac1b24cbc3","modified":1462023308000},{"_id":"source/_posts/poj-2728.md","shasum":"732694ea57c6eef6f36cb28708d0072913ef8f1e","modified":1462023308000},{"_id":"source/_posts/poj-3461.md","shasum":"226bd4eac18f3439dc754c946c995894cb74d640","modified":1462023308000},{"_id":"source/_posts/scoi2009-windy.md","shasum":"f3f12713e3ca559f45a27eba5a296039599ac87a","modified":1463137970000},{"_id":"source/_posts/scoi2007-repair.md","shasum":"e5cd2d95c22fd64d8f4362732d747292a4e17240","modified":1462023308000},{"_id":"source/_posts/scoi2010-game.md","shasum":"81be4ae0bb7c1120e220a5177bea4877d19780f3","modified":1462023308000},{"_id":"source/_posts/scoi2011-candy.md","shasum":"3037949e9f52b0faac3b2ca5b4d7f40e64147dad","modified":1462023308000},{"_id":"source/_posts/scoi2015-light.md","shasum":"e1413f85c6d20489f1e1668877d323f8f319fb58","modified":1462023308000},{"_id":"source/_posts/scoi2015-matrix.md","shasum":"81f28e7cad4caf2a53201684e2eebc1961e7e42e","modified":1462023308000},{"_id":"source/_posts/scoi2015-flag.md","shasum":"d2273c0aa7434ce104123d934eed5ebc76ce7874","modified":1462023308000},{"_id":"source/_posts/scoi2015-password.md","shasum":"ba24fd5191837df620e52e49246f6481006b0610","modified":1462023308000},{"_id":"source/_posts/sdoi2008-cave.md","shasum":"0665e52de3f255cafac2bdc5b5c8f9ee23deee5c","modified":1462023308000},{"_id":"source/_posts/sdoi2010-starrace.md","shasum":"7cdfa2fbc6b5703175d491f81869e84382baf68c","modified":1462023308000},{"_id":"source/_posts/scoi2015-message.md","shasum":"eaba94296389b994b29a45744ad81674723c1e31","modified":1462023308000},{"_id":"source/_posts/sdoi2015-war.md","shasum":"4a6a234666ff45ea7c5069e6630519b646dac882","modified":1462023308000},{"_id":"source/_posts/sdoi2016-game.md","shasum":"f4688c431daa3a3b77b8ac3ec53c43f27ffb63de","modified":1462023308000},{"_id":"source/_posts/sdoi2016-game/tree.png","shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86","modified":1460731351000},{"_id":"source/_posts/sdoi2016-incantation.md","shasum":"1152f86db800b686d790898d6b9193c7d8712bbe","modified":1462023433000},{"_id":"source/_posts/sdoi2016-game/line.png","shasum":"30c24e553938d2c27b55779527825b2577088a7c","modified":1460731739000},{"_id":"source/_posts/sdoi2016-permutation.md","shasum":"ac94de60fa9ed03ece26c466ef20698e935d6752","modified":1462023308000},{"_id":"source/_posts/sdoi2016-journey.md","shasum":"fe911a4f8198650d1c95995bf0498fba9939f9f4","modified":1462023308000},{"_id":"source/_posts/sdoi2016-pair.md","shasum":"9a707c8f327534044dac4b013a285184edd7d349","modified":1462023308000},{"_id":"source/_posts/sdoi2016-round1.md","shasum":"65f72f67260cb13659195e6ada774e2eed313408","modified":1462023308000},{"_id":"source/_posts/sdoi2016-table.md","shasum":"7e94fe9a98fea6513d3c3a3de32f61a6de059089","modified":1462023308000},{"_id":"source/_posts/splay-notes-1.md","shasum":"74b118e9cca1b32c32298fcabf90192aa194e1a8","modified":1462023308000},{"_id":"source/_posts/splay-notes-3.md","shasum":"77f025b32786a71ce628095d27642fbe230e764a","modified":1462023308000},{"_id":"source/_posts/splay-notes-2.md","shasum":"b7c1615a96dfff66ea8c6337d06c966a9223f69e","modified":1462023308000},{"_id":"source/_posts/spoj-694.md","shasum":"4c02dff2a042a9c83e811f5f8536a361d53d798e","modified":1462023308000},{"_id":"source/_posts/stl-in-oi.md","shasum":"c3e0ecfbc635868a47b686a6ea7a992183fa9d96","modified":1462023308000},{"_id":"source/_posts/suffix-array-notes.md","shasum":"a14a772250ef5d85308f76c1d08deb2199a705a1","modified":1462023308000},{"_id":"source/_posts/system-of-difference-constraints-notes.md","shasum":"cda796649d3175c93146609b99ba4e753d04c995","modified":1462023308000},{"_id":"source/_posts/tarjan-scc-notes.md","shasum":"78f4744865c553f80815c07f1de3e94270e45733","modified":1462023308000},{"_id":"source/_posts/tjoi2013-lis.md","shasum":"2e2ed050fce7be80cfebcfb4d378030cfd7519c4","modified":1462023308000},{"_id":"source/_posts/tyvj-3317.md","shasum":"e6479510ff185839aa626f5b409dde29dd6b7dd6","modified":1462023308000},{"_id":"source/_posts/uva-10253.md","shasum":"af4062ce79c9b4f080fe3c35d3be71ef13d0b36d","modified":1462023308000},{"_id":"source/_posts/uva-11137.md","shasum":"e0888805e520092bad07b296abee4273a30d04b4","modified":1462023308000},{"_id":"source/_posts/uva-11174.md","shasum":"343cb90133d9be62c263c27db889c0bf2945b918","modified":1462023308000},{"_id":"source/_posts/uva-11361.md","shasum":"4c9cfae6b501b6b5661edb204cc600ba4bfbdf30","modified":1462023308000},{"_id":"source/_posts/uva-11375.md","shasum":"3ca8e6535aab2844777ae95ec8b8e10b2864f8f4","modified":1462023308000},{"_id":"source/_posts/uva-11538/cells.png","shasum":"3a162829c312a17639950c3620cd70799ed94a49","modified":1458003954000},{"_id":"source/_posts/uva-11538.md","shasum":"030938457fbe7ab2d5aec2148b7c03acfdf9513b","modified":1462023308000},{"_id":"source/_posts/uva-11806.md","shasum":"e7fe9a9f6f7bb8d32286243d4238f189b9d70734","modified":1462023308000},{"_id":"source/_posts/uva-1362.md","shasum":"5a40d60d22a3718a7583ebf1941a5536d7473aa8","modified":1462023308000},{"_id":"source/about-me.md","shasum":"b7044084ee719baa66574b4d1291a322c60973fc","modified":1458571589000},{"_id":"source/_posts/virtualbox-archlinux.md","shasum":"920b51fe7f50d524a368c55db06a84cba0f3df1e","modified":1462023308000},{"_id":"source/friends.md","shasum":"23fb6e1101c562c4df5696ab6d35aada35fd123e","modified":1461770557000},{"_id":"source/_posts/osx-enable-retina/plist-edit.png","shasum":"94dd75a8fba5775cd97fcc5cc9f917f5bba40061","modified":1458095214000},{"_id":"source/_posts/osx-softwares/dropbox.png","shasum":"c57885f99a5af62b94eb53a510edbc2faab47e7b","modified":1458003954000},{"_id":"source/_posts/osx-softwares/go2shell.png","shasum":"538be85641e7b95ec18bf577ac1353d757637817","modified":1458003954000},{"_id":"source/_posts/osx-softwares/shadowsocksx.png","shasum":"e4d6e7dac5744d19d5303ba13b3f8411953a0427","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/port.png","shasum":"bb684dd8b616413e3e0e27c5efce118249a54113","modified":1458003954000},{"_id":"source/_posts/osx-softwares/vlc.png","shasum":"395a973310d204c78cdefb9da9929c3892479b73","modified":1458003954000},{"_id":"source/_posts/osx-softwares/fileroller.png","shasum":"9bf831aec4309e525791f286c346a447c6605acd","modified":1458003954000},{"_id":"source/_posts/osx-softwares/karabiner.png","shasum":"0b24e2252a00f402e681a6dd84a679a4be9706be","modified":1458003954000},{"_id":"source/_posts/osx-softwares/teamviewer.png","shasum":"c9c00c296ccdc4c234cc945bc6b3653e9742797f","modified":1458003954000},{"_id":"source/_posts/osx-softwares/virtualbox.png","shasum":"7401b6a6f6543356234d9ecbaa5fd8026455ead4","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/share.png","shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8","modified":1458003954000},{"_id":"source/_posts/osx-softwares/flashlight.png","shasum":"c251a90415340d44655c18461ed5b186167cd03a","modified":1458003954000},{"_id":"source/_posts/splay-notes-1/splay.png","shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/network.png","shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426","modified":1458003954000},{"_id":"source/_posts/osx-softwares/feeluown.png","shasum":"70c4a0b923c3d8688d64f0036ec09d34d214a7eb","modified":1458003954000},{"_id":"source/_posts/osx-softwares/libreoffice-writer.png","shasum":"f0e740eef5a31433f798a9ab689bca320b3ec05f","modified":1458003954000},{"_id":"source/_posts/osx-softwares/macdown.png","shasum":"f655bf9258ec412c856078653aadac847f69bd08","modified":1458003954000},{"_id":"source/_posts/after-ah-studying/one-day.png","shasum":"824cb9e48257574a779122dfe9825fc94944bef8","modified":1460088020000},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d","modified":1458003954000},{"_id":"source/_posts/osx-softwares/gimp.png","shasum":"8d1f18af30cbe2639375bc13d993d81894d916ab","modified":1458003954000},{"_id":"source/_posts/osx-softwares/macvim.png","shasum":"550e044c4af938acbd373649bacff7dd4f020f8c","modified":1458003954000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/modules/ignore.txt","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/test/modules/ignore.txt","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1441988248000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir1/root_dir1_file1.ext1","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir1/root_dir1_file2.ext2","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir1/root_dir1_file3.ext3","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir1/root_dir1_subdir1/root1_dir1_subdir1_file1.ext1","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir2/root_dir2_file1.ext1","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir2/root_dir2_file2.ext2","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_file1.ext1","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_file2.ext2","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_file3.ext3","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/README.md","shasum":"099145f13a1b5bc6c05c1191d97c5f3141a0d065","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","shasum":"a7ba4b9bb4705c3ac9a6bb5ff5ed2f3051e47bc2","modified":1459517539000},{"_id":"themes/yelee/_config.yml","shasum":"75eba090a32ad17108844c8b449e7c4c454c4678","modified":1459954098000},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","shasum":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/archive.ejs","shasum":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/article.ejs","shasum":"f74f702b5c52abb75b443d39a8584a276335f79f","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/background.ejs","shasum":"f28a2ddf873bfae6410103b5c04ebc791c92b092","modified":1456632368000},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","shasum":"2e5cad68bc59190b4158f4ab1879a222ca49a0d2","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","shasum":"1f9ac8182fe0b867a8f1988888336c40c25894cd","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","shasum":"a6853b59ee60e775de1ed90b242084f83774d195","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/footer.ejs","shasum":"9b82f9df1c362d9f753471a1b762ae9dec541a41","modified":1456473992000},{"_id":"themes/yelee/layout/_partial/header.ejs","shasum":"b69855e07b65117769adc515cb64b803932068c9","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","shasum":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/head.ejs","shasum":"bcd9776a7db6811524d6a45834cc23a7d5161195","modified":1460086726000},{"_id":"themes/yelee/layout/_partial/hide-labels.ejs","shasum":"85efb11ec87453274e9fcec1aba9fe0ff943e40c","modified":1456636113000},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","shasum":"23bb102f7eea9b0919c82b6372750a034b88d071","modified":1456484747000},{"_id":"themes/yelee/layout/_partial/left-col.ejs","shasum":"eef030e8c70f17cbeec5257610ddca533af74814","modified":1456631866000},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","shasum":"3965642143865e07e83a886480d03a77135bf830","modified":1456633591000},{"_id":"themes/yelee/layout/_partial/page.ejs","shasum":"1744af0843e6805ca7140327c6a9be2301204221","modified":1456636152000},{"_id":"themes/yelee/layout/_partial/post/date.ejs","shasum":"a9fc6bac9e1b90c1c17c0d0ffd97f9b108072fbe","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/category.ejs","shasum":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","shasum":"e1b8d9bf1951aa621d6dffc1a4944da42571d064","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","shasum":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/share.ejs","shasum":"bfac451ed8d632dbba84673691cc5ea3315c1469","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/title.ejs","shasum":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","shasum":"1c233f308a35b3aaca0f4a4158cc3dd24a9dc3f8","modified":1456636126000},{"_id":"themes/yelee/layout/_partial/toc.ejs","shasum":"2dd741fc718c67e9dfe8e7c7e04bb18dfe04416a","modified":1456636136000},{"_id":"themes/yelee/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1456461572000},{"_id":"themes/yelee/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1456461572000},{"_id":"themes/yelee/layout/layout.ejs","shasum":"0dc82852411f536d87580a56c427c2b1ee2d82f8","modified":1457932096000},{"_id":"themes/yelee/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1456461572000},{"_id":"themes/yelee/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1456461572000},{"_id":"themes/yelee/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1456461572000},{"_id":"themes/yelee/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1456461572000},{"_id":"themes/yelee/node_modules/ansi-regex/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/ansi-regex/index.js","shasum":"03d6a4cc534cbb9a855b01b372a17bfa2b830442","modified":1435679868000},{"_id":"themes/yelee/node_modules/ansi-regex/package.json","shasum":"348b89f9ce5248f9551751fa61fab43ed217fbe7","modified":1456469176000},{"_id":"themes/yelee/node_modules/ansi-regex/readme.md","shasum":"76c119f1cf0605a0409f9c2756de3e55a1398fc2","modified":1435679915000},{"_id":"themes/yelee/node_modules/ansi-styles/index.js","shasum":"87fbeeb30899102acf006a96eb12dfc24bcc01b5","modified":1456056918000},{"_id":"themes/yelee/node_modules/ansi-styles/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1405288555000},{"_id":"themes/yelee/node_modules/ansi-styles/package.json","shasum":"451cd978d9d63d9579e37266d42baeb1c492869f","modified":1456469176000},{"_id":"themes/yelee/node_modules/ansi-styles/readme.md","shasum":"8613831018b4ce9805fadf6de8bcbf6ef16bcae3","modified":1456056918000},{"_id":"themes/yelee/node_modules/anymatch/LICENSE","shasum":"2faff6eb900a1f252dd5628fa007d8df033d9717","modified":1426989009000},{"_id":"themes/yelee/node_modules/anymatch/README.md","shasum":"6abfe77bff90bcf1c9adde01eab4a5eb609eda7b","modified":1429740109000},{"_id":"themes/yelee/node_modules/anymatch/index.js","shasum":"21e942db79cdd8c863a7c1d4c619de728a3f4277","modified":1429713941000},{"_id":"themes/yelee/node_modules/anymatch/package.json","shasum":"75ca62b32f5233a01233b0558a30008c5f5a17c2","modified":1456469176000},{"_id":"themes/yelee/node_modules/arr-diff/README.md","shasum":"aea1c9d09e3e4836b20459900490582a913ba318","modified":1449375940000},{"_id":"themes/yelee/node_modules/arr-diff/index.js","shasum":"b0af4d581bd0e4f370526dfaee3d2a8daf45880c","modified":1449375115000},{"_id":"themes/yelee/node_modules/arr-diff/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1440300569000},{"_id":"themes/yelee/node_modules/arr-diff/package.json","shasum":"6fd028ead99b9a701052735f165a0862f7f4e044","modified":1456469176000},{"_id":"themes/yelee/node_modules/arr-flatten/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1426048064000},{"_id":"themes/yelee/node_modules/arr-flatten/README.md","shasum":"3f5ac995fae4c1ac9372779114b7b683e3b21a85","modified":1426048068000},{"_id":"themes/yelee/node_modules/arr-flatten/index.js","shasum":"f520001d7bfbf978f6b90448fc2dc51f5bdf6ca4","modified":1426048064000},{"_id":"themes/yelee/node_modules/arr-flatten/package.json","shasum":"b4a87c85dd069d2d5bf2506934588fb1401466ce","modified":1456469176000},{"_id":"themes/yelee/node_modules/array-unique/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1427255160000},{"_id":"themes/yelee/node_modules/array-unique/README.md","shasum":"c469edac074366095833e9e37da13d111df44bd7","modified":1427255211000},{"_id":"themes/yelee/node_modules/array-unique/index.js","shasum":"1826adc4c19e8d8bcf421d342ae7e2db52f69bb6","modified":1427255160000},{"_id":"themes/yelee/node_modules/array-unique/package.json","shasum":"faad20d4985d2579ca067318a51b60730fb18268","modified":1456469176000},{"_id":"themes/yelee/node_modules/arrify/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/arrify/index.js","shasum":"d91a789bdf6d6e7ea9014b0b1bacfef0d7621f47","modified":1449683153000},{"_id":"themes/yelee/node_modules/arrify/package.json","shasum":"0f7f5368f5c6bb47e84dd23c59d9050a2c73c82b","modified":1456469176000},{"_id":"themes/yelee/node_modules/arrify/readme.md","shasum":"6354f6960ff472c330f75421ac9a81d3709599ad","modified":1449683163000},{"_id":"themes/yelee/node_modules/asn1/LICENSE","shasum":"724e48cfc739674999ff82b4e49d76d5376818e9","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/errors.js","shasum":"556bbb1b810ede9292493a70ad9a8644e5c4fb7a","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/README.md","shasum":"71e6a47944ebaefe5d5357a7b6f46df9c389316f","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/index.js","shasum":"1ab39535ed24903d0f9e2a4bf74333702842080b","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/reader.js","shasum":"3cfcdc9225bb43dd8413dc3f1f05d4fcd32d0b30","modified":1443646115000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/types.js","shasum":"8a41886747dc1f7cde7e4e5cb60e1a3b8a4c813c","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/writer.js","shasum":"bdad4a0bb12fb5f91b789329fc4e4a45ecf87e64","modified":1443646115000},{"_id":"themes/yelee/node_modules/asn1/lib/index.js","shasum":"cbff145d47fb41eb1262f012a7024e7b0e527d6c","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/package.json","shasum":"d8a5922f5468e54ed1547dbf87460f454bd00e41","modified":1456469177000},{"_id":"themes/yelee/node_modules/asn1/tst/ber/reader.test.js","shasum":"de84b2d7317393c6e6a0cdef04bfbff82ba78237","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/tst/ber/writer.test.js","shasum":"59892680384339812688163b346d12cc05e979fd","modified":1401981220000},{"_id":"themes/yelee/node_modules/assert-plus/AUTHORS","shasum":"d1d14de8fc8c21f9f86c2231df2531381f6a9194","modified":1446952976000},{"_id":"themes/yelee/node_modules/assert-plus/CHANGES.md","shasum":"b64b8d16f3858a1c3d55538c5bfee934437af75b","modified":1447141659000},{"_id":"themes/yelee/node_modules/assert-plus/README.md","shasum":"79988e7cb3bb80b7cc20dc420ee2a7f86ab3d3e0","modified":1446952976000},{"_id":"themes/yelee/node_modules/assert-plus/assert.js","shasum":"8f3f85bae8edd30db24882766a5c8c4df8357462","modified":1447140668000},{"_id":"themes/yelee/node_modules/async/CHANGELOG.md","shasum":"f6dbdbec1d4babb8661eae69a9d35700ca89bfb1","modified":1452211409000},{"_id":"themes/yelee/node_modules/async/LICENSE","shasum":"e452de6c5360ba269a3bda17cca33f0bf51035f5","modified":1432069407000},{"_id":"themes/yelee/node_modules/assert-plus/package.json","shasum":"7f2b96a2e7aef656e776ba30a8e37c44f8111364","modified":1456469176000},{"_id":"themes/yelee/node_modules/async/README.md","shasum":"1e5c0380861222c007090d0c0a1d8ca4f5272dc5","modified":1452208687000},{"_id":"themes/yelee/node_modules/async/dist/async.js","shasum":"a410bed1e8c6a19be68101c293ff66c4961076ae","modified":1452211451000},{"_id":"themes/yelee/node_modules/async/dist/async.min.js","shasum":"487f1a1adb0bf6b00233edb64e64f2fb305ce5a3","modified":1452211452000},{"_id":"themes/yelee/node_modules/async/package.json","shasum":"b9680461f372a533849ffb06ab7e158f4cb32d89","modified":1456469177000},{"_id":"themes/yelee/node_modules/async-each/CHANGELOG.md","shasum":"1102ca4765f9168b80496cefa91817ac39bb30a1","modified":1415225746000},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","shasum":"aad58483a5d6d4627fce9bbc367784d57e93c544","modified":1456461572000},{"_id":"themes/yelee/node_modules/async-each/README.md","shasum":"dfc8f7a521e3b419521df634fd9ea5f9932104c7","modified":1414004479000},{"_id":"themes/yelee/node_modules/async/lib/async.js","shasum":"a410bed1e8c6a19be68101c293ff66c4961076ae","modified":1452207555000},{"_id":"themes/yelee/node_modules/async-each/bower.json","shasum":"36d0d507aa0d7aa6d06170dd73969b17c1dfaa2f","modified":1415225763000},{"_id":"themes/yelee/node_modules/async-each/component.json","shasum":"1da329193224221f15946abc68712721acd9040a","modified":1415225758000},{"_id":"themes/yelee/node_modules/async-each/index.js","shasum":"c329e80e544646b7f83d52d3428687b19e6d7119","modified":1414004479000},{"_id":"themes/yelee/node_modules/async-each/package.json","shasum":"3f272365a8b531881ef2e9de609cf8673bad5726","modified":1456469176000},{"_id":"themes/yelee/node_modules/aws-sign2/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1366607619000},{"_id":"themes/yelee/node_modules/aws-sign2/README.md","shasum":"5e8e0e7c811b1f319c0e94ff08f38ecf4896e3c9","modified":1366607619000},{"_id":"themes/yelee/node_modules/aws4/LICENSE","shasum":"9ba903f14c37d0ab0250a8e6920e7269bdc5b294","modified":1384232184000},{"_id":"themes/yelee/node_modules/aws-sign2/package.json","shasum":"d06c8cde76acc2e86f3ace0fbf412d07e9ca37e0","modified":1456469176000},{"_id":"themes/yelee/node_modules/aws-sign2/index.js","shasum":"b380be041c204108febb8f32b19431a54aaed4a6","modified":1444584231000},{"_id":"themes/yelee/node_modules/aws4/README.md","shasum":"8b02542186fe300b27acd3aba5c65b77a3d822e3","modified":1426551080000},{"_id":"themes/yelee/node_modules/aws4/aws4.js","shasum":"4155d86150b56a456a7b90fb55a82b8e9e3fc666","modified":1451426937000},{"_id":"themes/yelee/node_modules/aws4/package.json","shasum":"16a640a56c5f9f9ac310df89189e49c33290aebc","modified":1456469177000},{"_id":"themes/yelee/node_modules/aws4/example.js","shasum":"4da6b34b39625ad7b9c788f6c2ebac1f80531520","modified":1426551098000},{"_id":"themes/yelee/node_modules/balanced-match/LICENSE.md","shasum":"09013c002fbdd686da2ec13c5a6d014f0a294ba9","modified":1445519600000},{"_id":"themes/yelee/node_modules/balanced-match/Makefile","shasum":"98cb6ef36a74f052f3bad15c72f01d78e2d0ba8e","modified":1445519548000},{"_id":"themes/yelee/node_modules/balanced-match/README.md","shasum":"261a929745508f56c655d4ec306123bbfabdaa16","modified":1448714230000},{"_id":"themes/yelee/node_modules/balanced-match/example.js","shasum":"27792bf4ffe9ce453c5d6896611d7647fd8f0e6b","modified":1445519548000},{"_id":"themes/yelee/node_modules/balanced-match/index.js","shasum":"8c1cf0e709f8668e14b11c9086a50c70a0b0434e","modified":1448714230000},{"_id":"themes/yelee/node_modules/balanced-match/test/balanced.js","shasum":"706b6e79b2c13f0fed4d25706b63bbeec17c3600","modified":1448714230000},{"_id":"themes/yelee/node_modules/balanced-match/package.json","shasum":"08939dbde000855efbadc72e6d987378748e24dc","modified":1456469177000},{"_id":"themes/yelee/node_modules/binary-extensions/binary-extensions.json","shasum":"02c5fbd9d5f15c24536fac478a79dca0eecfcc0f","modified":1447865992000},{"_id":"themes/yelee/node_modules/binary-extensions/readme.md","shasum":"df2c147fdca66c819adb5e7e7709ba1d4167a37b","modified":1431905669000},{"_id":"themes/yelee/node_modules/binary-extensions/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/binary-extensions/package.json","shasum":"ab77bfd76d4ec25eede9b5bc4c7c5641c3761a97","modified":1456469176000},{"_id":"themes/yelee/node_modules/bl/LICENSE.md","shasum":"d068ae801f9277b4b248f0c2aad7f50181dacaad","modified":1453181857000},{"_id":"themes/yelee/node_modules/bl/README.md","shasum":"4308d9ba8f28872911d3e4f8b3de6b56b47be042","modified":1453181864000},{"_id":"themes/yelee/node_modules/bl/package.json","shasum":"da25e044a1f9844c8be0cced38c56a31b08b3710","modified":1456469177000},{"_id":"themes/yelee/node_modules/bl/bl.js","shasum":"4ff984b4b3c546295b51e71787ff8a99b159007d","modified":1455187025000},{"_id":"themes/yelee/node_modules/bluebird/LICENSE","shasum":"914158dfad0452ceb55ea5e1822605ca05984bd9","modified":1441756221000},{"_id":"themes/yelee/node_modules/bl/test/test.js","shasum":"94102bab86dc65abd7f8a762fd2b03489527ab77","modified":1455187143000},{"_id":"themes/yelee/node_modules/bluebird/README.md","shasum":"7301370c8dcfec15e81690573e67cec9098722b6","modified":1443731831000},{"_id":"themes/yelee/node_modules/bluebird/changelog.md","shasum":"379c89dae1fe9a27f88326e51bee47a69d6d166f","modified":1443731919000},{"_id":"themes/yelee/node_modules/bluebird/js/main/any.js","shasum":"424dfe2a1afeaad729ca2be5ccfd443311716c41","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/assert.js","shasum":"913ec7a809e56b5958cbcec9636261ef8678f039","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/async.js","shasum":"59886110bb7c636f009738204e1b741e5a392901","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/call_get.js","shasum":"58d857432929fcec4290920561d078ae14b37fd3","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/bluebird.js","shasum":"ff935d6b554c445b4a1ff63828a883a922e8adfe","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/bind.js","shasum":"33588c68d7f07021a8bc39e9aa0d152c9b8bb36c","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/cancel.js","shasum":"5af48d3225ea7d186307b5e40068df50029fb51d","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/catch_filter.js","shasum":"a82102f6dda6254edc559e3f0fca18386cbf7704","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/debuggability.js","shasum":"cd4e51109686fa6ef6393580e4ce1b2fb8857708","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/captured_trace.js","shasum":"c2366ef310186f3c0f724d609ab5182430bda350","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/context.js","shasum":"00f52d27fe05ad386ebc5a0c3145055a8239b717","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/direct_resolve.js","shasum":"09460167ef03306534e2a5b4955aaf6cd2928816","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/each.js","shasum":"22c435d2bf35fa9d4e49845b051a19ed915ae033","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/errors.js","shasum":"12a0cb75135f2e21233e7a86ba75a87d2bcaae90","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/es5.js","shasum":"019c4e8b62031ea49aedc86dedd20318c6122698","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/finally.js","shasum":"b965777471de69b0dd8d4954ea4eadda259b47da","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/filter.js","shasum":"a5f3aee4afbc67d372e5b4fbaeac047d0d9c779b","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/generators.js","shasum":"a1dd036d2ba0b8e5fa5f1c9eeb782e40e6e1d446","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/join.js","shasum":"3343313085a4c70419b9480fbe3aadc8999f2c61","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/map.js","shasum":"a31b919a76b2e49cbe2b9af6a55d895a15721361","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/method.js","shasum":"241c83511b11611db4f93379ecb52cc956524f08","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/nodeify.js","shasum":"bed107c219728c53f8b2ca98fbf152cf17f38b37","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/progress.js","shasum":"520f17a7b4a9e60cc9c81c97432a0cca8d95bec6","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/promise_resolver.js","shasum":"0724c0b49798dd9e052a0b647a0f8eca2eee2085","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/promise.js","shasum":"8e4ad2c061036b6076e93ca161aef773aad638c5","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/promise_array.js","shasum":"20440af825405966bf371340b28f71050e511356","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/promisify.js","shasum":"76a80de1f074b815af8d0c5eb7b00c77ec776ccf","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/props.js","shasum":"c0cefcfd25e02e258867fd6b04e05c703dc32848","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/queue.js","shasum":"6c24c68f716db1a6c18b5cad2a951f0df6ee76ec","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/race.js","shasum":"3fdee03445a36d1ba8c1c25c7f1cbd2048dcf8c8","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/reduce.js","shasum":"ae62bdfa766e869d635dae6907a2ae7661248770","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/schedule.js","shasum":"fc5702823d7db29090fc00782e4830be98f5d868","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/settle.js","shasum":"5c2b5afa5c58f73d7d180aea5f4aac740d592fb4","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/some.js","shasum":"9520efd87fd7e846435bdd30be5599f22936c923","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/synchronous_inspection.js","shasum":"9585e3b56fb8b0fab358782dea3310b640853ecf","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/thenables.js","shasum":"d1b36cd6d1e1e8db91e7f947a6434bb5197cce98","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/timers.js","shasum":"b7462244ff2349386d8c9319d7b795fe0fe57c13","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/using.js","shasum":"6691ef4555e191df6369224449d15919ba98fc4f","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/package.json","shasum":"4fbf358f772f23bc9d0257b6034dbdf70d84f072","modified":1456469177000},{"_id":"themes/yelee/node_modules/boom/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1411478104000},{"_id":"themes/yelee/node_modules/bluebird/js/main/util.js","shasum":"1b59d56271df184c21ff649a5cf63b7881bb6249","modified":1443731942000},{"_id":"themes/yelee/node_modules/boom/LICENSE","shasum":"53ded9fedb90236c92321a45d1ab00fa35f282d8","modified":1407506005000},{"_id":"themes/yelee/node_modules/boom/README.md","shasum":"2d7368cd181df38d42b300f04f7323cc16f9b7d2","modified":1446232305000},{"_id":"themes/yelee/node_modules/boom/lib/index.js","shasum":"a894f6f39fc0bf0f8a82a420d8a2a5018e9dcdbe","modified":1446232305000},{"_id":"themes/yelee/node_modules/boom/images/boom.png","shasum":"126fe71d237c4939338507417d5f5e172773be3e","modified":1407506005000},{"_id":"themes/yelee/node_modules/boom/package.json","shasum":"b1f86f88ecbaf27e12e63cfb972694c7b3dc1a36","modified":1456469177000},{"_id":"themes/yelee/node_modules/boom/test/index.js","shasum":"62d76a920212e160acf6894f1ee3e981e6aaa8b1","modified":1446232305000},{"_id":"themes/yelee/node_modules/brace-expansion/example.js","shasum":"8a259435e31e75ac76d3abcbefd225af7f41c185","modified":1446204351000},{"_id":"themes/yelee/node_modules/brace-expansion/index.js","shasum":"acd1637cc605d2aff5f9da27ff9f7df5a9f79840","modified":1455216657000},{"_id":"themes/yelee/node_modules/brace-expansion/package.json","shasum":"4061400587900da9701d3365d7b37e2ca9675097","modified":1456469176000},{"_id":"themes/yelee/node_modules/brace-expansion/README.md","shasum":"3ed262742cc9e8e0db93c5f1d729127af1ffbe82","modified":1446204351000},{"_id":"themes/yelee/node_modules/braces/LICENSE","shasum":"d99d5158898474f25efb4c8790f9fcc4cf55b350","modified":1450565981000},{"_id":"themes/yelee/node_modules/braces/index.js","shasum":"e13bca7cef9140534c7726fbf78b74796b41c949","modified":1450566164000},{"_id":"themes/yelee/node_modules/braces/README.md","shasum":"cba67f4f8b1b30f75187913d8817c80af6755b7b","modified":1450565981000},{"_id":"themes/yelee/node_modules/braces/package.json","shasum":"239eccd5df7cc847bda3adcacd588e995b79e324","modified":1456469176000},{"_id":"themes/yelee/node_modules/caseless/LICENSE","shasum":"48f9e0a4c07f36c07d47962212fe022d0417c90f","modified":1435268329000},{"_id":"themes/yelee/node_modules/caseless/README.md","shasum":"5770b9496fb480f7c403b6c38759a27d6170e882","modified":1414608769000},{"_id":"themes/yelee/node_modules/caseless/package.json","shasum":"7e72c84e774921b717928812f61d6ba4adf18305","modified":1456469176000},{"_id":"themes/yelee/node_modules/caseless/index.js","shasum":"326fc25f6edec25f7d239314ed6e75259147088a","modified":1424972076000},{"_id":"themes/yelee/node_modules/chalk/index.js","shasum":"08315806beaa18a4eb58052e8e7182b2d8bddf8f","modified":1440014707000},{"_id":"themes/yelee/node_modules/caseless/test.js","shasum":"73948ff77c144352fb9d9615079ee35cab781912","modified":1414609010000},{"_id":"themes/yelee/node_modules/chalk/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/chalk/package.json","shasum":"2810cf074114281d965ca3698a09d62092a284e2","modified":1456469176000},{"_id":"themes/yelee/node_modules/chalk/readme.md","shasum":"a10251893e1a61957a4c7238001e682d20d46d47","modified":1440014506000},{"_id":"themes/yelee/node_modules/chokidar/CHANGELOG.md","shasum":"85f505f3e1a49969effaa5aeecf4589ed9e6cbfe","modified":1451487551000},{"_id":"themes/yelee/node_modules/chokidar/README.md","shasum":"548672a8bfbaa03a8f667ddf23540e55b6b2cf4d","modified":1451487515000},{"_id":"themes/yelee/node_modules/chokidar/lib/fsevents-handler.js","shasum":"34dbf4382b9abe8557225200f67d14ce4acecce4","modified":1447810431000},{"_id":"themes/yelee/node_modules/chokidar/index.js","shasum":"73d55f784b04a68118142e3990545076c088d5c9","modified":1451487515000},{"_id":"themes/yelee/node_modules/chokidar/lib/nodefs-handler.js","shasum":"2bb20459d65f97b270774f64af9ec021bed83222","modified":1449237717000},{"_id":"themes/yelee/node_modules/chokidar/package.json","shasum":"42dfd6857b527de60e8423355d7aedde0f1d8ef8","modified":1456469176000},{"_id":"themes/yelee/node_modules/color-convert/CHANGELOG.md","shasum":"888f63060f1f4e78696f49f97d2c7bbe59f6a1bd","modified":1452208038000},{"_id":"themes/yelee/node_modules/color-convert/LICENSE","shasum":"213184abbe8fc3ea5e46b468252a8169976ec023","modified":1452140295000},{"_id":"themes/yelee/node_modules/color-convert/README.md","shasum":"bc54b7505917008b59fb44c1c1510496b7e10c64","modified":1452208022000},{"_id":"themes/yelee/node_modules/color-convert/conversions.js","shasum":"50fbbafede5e11cbf00f774274d82d7c642ae4ee","modified":1452208022000},{"_id":"themes/yelee/node_modules/color-convert/css-keywords.js","shasum":"1cc46ce6700efa9f1e28658f7711f66be4d05849","modified":1452208022000},{"_id":"themes/yelee/node_modules/color-convert/index.js","shasum":"21aa2caa71a73a374ee8eb218a384bacc5c1a60c","modified":1452208022000},{"_id":"themes/yelee/node_modules/color-convert/package.json","shasum":"e30a256ecee34136cda2e3d0fe4bddfa3ebe59ea","modified":1456469177000},{"_id":"themes/yelee/node_modules/color-convert/route.js","shasum":"9b51ec58ff46f37687d76e7e77139c7567ed1483","modified":1452208022000},{"_id":"themes/yelee/node_modules/colors/LICENSE","shasum":"341480159e4c6e291a492a441fe69081d671e85d","modified":1430290937000},{"_id":"themes/yelee/node_modules/colors/ReadMe.md","shasum":"3e22ae665134396b6dcd45ec5c2c750ad98c00d9","modified":1434545826000},{"_id":"themes/yelee/node_modules/colors/examples/normal-usage.js","shasum":"8da0b32e0ce469a8fbadf4d3fe93c259447368e4","modified":1434545263000},{"_id":"themes/yelee/node_modules/colors/examples/safe-string.js","shasum":"60552d817643905fde3839ae9d93f7c933f8af89","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/colors.js","shasum":"856e1a49d90ba1d9a53bbff307e27ecb677ecff9","modified":1434545520000},{"_id":"themes/yelee/node_modules/colors/lib/custom/trap.js","shasum":"391f769b8dd1a77b7c8ea1a76817b4e265cc6f38","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/custom/zalgo.js","shasum":"73b50e3646fb82e15b321067d3e0353529fbcc6c","modified":1434545520000},{"_id":"themes/yelee/node_modules/colors/lib/extendStringPrototype.js","shasum":"cbb6181b5cbccd38a97457cf58716781fa9f32d8","modified":1434545843000},{"_id":"themes/yelee/node_modules/colors/lib/maps/america.js","shasum":"45f3d39d744cc14040d4d62757b412b169cf2efc","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/index.js","shasum":"55f38c877985406790f063965cb600ae2a6f1492","modified":1434545520000},{"_id":"themes/yelee/node_modules/colors/lib/maps/rainbow.js","shasum":"014697741d559ea1dce3a5a27b9ba27b7241355c","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/maps/random.js","shasum":"50ac05ea88379162110f19cf3c441fa282956e73","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/styles.js","shasum":"a06697bab0a191e7961b855e767bbafacb25737a","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/maps/zebra.js","shasum":"5f6caffb4012ae13e8f36302a03cf27a7e593d89","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/system/supports-colors.js","shasum":"65ce27a33eccf3e698c49de9c94b6ffef349ca97","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/package.json","shasum":"00254d8912edcc7ec9322204c2e68b6e326cebf8","modified":1456469177000},{"_id":"themes/yelee/node_modules/colors/safe.js","shasum":"65698ffe95c229962bb1c212eb971401eaeb0b62","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/themes/generic-logging.js","shasum":"ea9fb8f704581e751d85767563a3dcd826ead0e6","modified":1416873262000},{"_id":"themes/yelee/node_modules/combined-stream/License","shasum":"04e7b761eee5270ea8914303516852faf990394b","modified":1403594961000},{"_id":"themes/yelee/node_modules/combined-stream/Readme.md","shasum":"9a4115c7973388087b21e93e1c538371e5f94ce9","modified":1434294512000},{"_id":"themes/yelee/node_modules/combined-stream/lib/combined_stream.js","shasum":"5d3a85a28a463dc2949fbb974919598e00183d24","modified":1434294512000},{"_id":"themes/yelee/node_modules/combined-stream/package.json","shasum":"30db86ea52fc01a0307759304df880cb92b88cb5","modified":1456469176000},{"_id":"themes/yelee/node_modules/commander/History.md","shasum":"386cc2f8d7b3b54307b7056a57fc4516402aa894","modified":1444749720000},{"_id":"themes/yelee/node_modules/commander/LICENSE","shasum":"63513188251d15fcdc716703fbee89be4a3a20e6","modified":1444531073000},{"_id":"themes/yelee/node_modules/commander/Readme.md","shasum":"af810334e87894faf80bd73d9e207c9d5f2b3c90","modified":1444531073000},{"_id":"themes/yelee/node_modules/commander/package.json","shasum":"400fe91af9ab6c100c8a5b3e50fea3dfe7b28953","modified":1456469176000},{"_id":"themes/yelee/node_modules/commander/index.js","shasum":"5adc820ea125a479f7fa597cfe2083eeede0dd2b","modified":1444748408000},{"_id":"themes/yelee/node_modules/concat-map/README.markdown","shasum":"132e6e8fd1d19ec2422fdcde00840d8237e44094","modified":1354099276000},{"_id":"themes/yelee/node_modules/concat-map/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1391050985000},{"_id":"themes/yelee/node_modules/concat-map/index.js","shasum":"a3063f014cc693b320dbd64de3243a79247c1e05","modified":1354939769000},{"_id":"themes/yelee/node_modules/concat-map/example/map.js","shasum":"022a614b8d9f5ccb67b6ce1f478b1efd7aff298e","modified":1339124034000},{"_id":"themes/yelee/node_modules/concat-map/test/map.js","shasum":"162cce32c23628192cef64924a1ce768af399a4b","modified":1354099176000},{"_id":"themes/yelee/node_modules/core-util-is/LICENSE","shasum":"a95471326a84657b0e164f84e1285685f63011e0","modified":1447979068000},{"_id":"themes/yelee/node_modules/concat-map/package.json","shasum":"ddb8574b39d495063d244adc399cf16b768662d5","modified":1456469176000},{"_id":"themes/yelee/node_modules/core-util-is/README.md","shasum":"d4987293f1078d937454a14a5ca6f386d227679d","modified":1447978999000},{"_id":"themes/yelee/node_modules/core-util-is/float.patch","shasum":"d7f073ceb05c6f6dd1bb852fc00f5379a3e41301","modified":1447978999000},{"_id":"themes/yelee/node_modules/core-util-is/lib/util.js","shasum":"7d34435928ee9228995c04eaa7bdcef875c41e65","modified":1447979840000},{"_id":"themes/yelee/node_modules/core-util-is/package.json","shasum":"1606eb5e25b8f94ceaf82b5deaeb4fcbe8a4d6bd","modified":1456469176000},{"_id":"themes/yelee/node_modules/core-util-is/test.js","shasum":"2837ee1d57f385943ba5ccc7fd0ec4ed1cb8cfdd","modified":1447979358000},{"_id":"themes/yelee/node_modules/cryptiles/LICENSE","shasum":"2d1840f1b4088e3a370317c82e7b443321f2b2eb","modified":1441778892000},{"_id":"themes/yelee/node_modules/cryptiles/README.md","shasum":"52c9561e75f66870d194d12ac07c05bc0484df18","modified":1441778892000},{"_id":"themes/yelee/node_modules/cryptiles/package.json","shasum":"49a3fbd3e688fdf5519bbfa0da492444718ff742","modified":1456469176000},{"_id":"themes/yelee/node_modules/cryptiles/lib/index.js","shasum":"e5c479d1d0966b82298d86669aaa5ed4bcee4fb7","modified":1441778892000},{"_id":"themes/yelee/node_modules/cryptiles/test/index.js","shasum":"c4d4151097d486ade0ee21bfd91297dafda16e88","modified":1441778892000},{"_id":"themes/yelee/node_modules/dashdash/README.md","shasum":"e40739349732594d5d96438bd27aa444915d3f79","modified":1453144686000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/AUTHORS","shasum":"d1d14de8fc8c21f9f86c2231df2531381f6a9194","modified":1453918488000},{"_id":"themes/yelee/node_modules/dashdash/etc/dashdash.bash_completion.in","shasum":"cbb2d2c1c856735b5555384080853f896aac9c61","modified":1453144686000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/CHANGES.md","shasum":"b27cef2253f8ff8a83584bf1a55cec9d4dfbf517","modified":1453920717000},{"_id":"themes/yelee/node_modules/dashdash/lib/dashdash.js","shasum":"0398a1a799416107c41d667c3d397a60e740fada","modified":1455248872000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/assert.js","shasum":"8103ced007b61b3e45a420607de576faf7e1e0e4","modified":1453920717000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/README.md","shasum":"d6771de291034391f0ec79175fff3428ed6d82b8","modified":1453920717000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/package.json","shasum":"950532164194e2d5255d0db67bdbdf79e6933dc8","modified":1456469176000},{"_id":"themes/yelee/node_modules/dashdash/package.json","shasum":"2d642c650936610061d0c171c56047732c23d802","modified":1456469176000},{"_id":"themes/yelee/node_modules/delayed-stream/License","shasum":"04e7b761eee5270ea8914303516852faf990394b","modified":1430160212000},{"_id":"themes/yelee/node_modules/delayed-stream/Makefile","shasum":"1d88cf18c0fef56e91425a086590e31271a7c4d5","modified":1430160212000},{"_id":"themes/yelee/node_modules/delayed-stream/Readme.md","shasum":"21db9b7ec97b7028a031a18867aab00575b09850","modified":1430160212000},{"_id":"themes/yelee/node_modules/delayed-stream/lib/delayed_stream.js","shasum":"097ab12e3837896d11d3f1d2c7a891d177b493c4","modified":1430160544000},{"_id":"themes/yelee/node_modules/delayed-stream/package.json","shasum":"bd88f3d64fc3f22960faa7e0519c99af96631a08","modified":1456469176000},{"_id":"themes/yelee/node_modules/ecc-jsbn/LICENSE","shasum":"d9dddd103d636dbaa178cd222de612fd923f62da","modified":1393978405000},{"_id":"themes/yelee/node_modules/ecc-jsbn/index.js","shasum":"13c052ad0b0507a4203d5d1274fdfa049a6c1339","modified":1448288282000},{"_id":"themes/yelee/node_modules/ecc-jsbn/README.md","shasum":"97cb1bdec48ebb5e46e64fc5441c79d3d38a3c82","modified":1408853444000},{"_id":"themes/yelee/node_modules/ecc-jsbn/lib/LICENSE-jsbn","shasum":"4f94910918b5e57f3e55c7387f43b0d6293a4319","modified":1394075812000},{"_id":"themes/yelee/node_modules/ecc-jsbn/lib/ec.js","shasum":"d9a60c831fe91bd2c62ff3e3c9675b0379ef504c","modified":1448288163000},{"_id":"themes/yelee/node_modules/ecc-jsbn/lib/sec.js","shasum":"b1632526290dfddc063f05ac6ed29cc40bd9e221","modified":1448288300000},{"_id":"themes/yelee/node_modules/ecc-jsbn/package.json","shasum":"ce1de4515ffd719e5fa24a30ad1324f7d643482a","modified":1456469177000},{"_id":"themes/yelee/node_modules/ecc-jsbn/test.js","shasum":"9709f584f556ceb8acaa0fd746029dcb58390eb4","modified":1408853485000},{"_id":"themes/yelee/node_modules/ent/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1420933654000},{"_id":"themes/yelee/node_modules/ent/encode.js","shasum":"e325db89d085cb99dc98cf35dd539b3dfd9476e8","modified":1421374712000},{"_id":"themes/yelee/node_modules/ent/decode.js","shasum":"c5f610c056660b0219923f8389bd7527e4207c2e","modified":1421263455000},{"_id":"themes/yelee/node_modules/ent/examples/simple.js","shasum":"4b87242731b0e84c67602f3c0d029039018e4065","modified":1420933654000},{"_id":"themes/yelee/node_modules/ent/index.js","shasum":"84ae412e9c6729bf7b397740ca981037cd80258f","modified":1420933988000},{"_id":"themes/yelee/node_modules/ent/entities.json","shasum":"9d9bd43412b55eaf2eb9126d77f9a5c8aec62ee1","modified":1421443100000},{"_id":"themes/yelee/node_modules/ent/package.json","shasum":"5fe5b02303562ff6a44e688e6ae13afac428dcfe","modified":1456469177000},{"_id":"themes/yelee/node_modules/ent/readme.markdown","shasum":"a9bf022f1841c566e8ec8a17e3e324ae41038612","modified":1421374877000},{"_id":"themes/yelee/node_modules/ent/test/codes.js","shasum":"969271fbb8fc79b57e0543cc7663cc98cf4618d2","modified":1421374306000},{"_id":"themes/yelee/node_modules/ent/reversed.json","shasum":"55ad9b99021eef02691e15bb0bb78f0969a86ca9","modified":1421443100000},{"_id":"themes/yelee/node_modules/ent/test/hex.js","shasum":"af471bdcc663c60e1d010428f9c525893d48ed82","modified":1420933654000},{"_id":"themes/yelee/node_modules/escape-string-regexp/index.js","shasum":"17b40cc4dc8a455277994ab351c0650215394042","modified":1456057032000},{"_id":"themes/yelee/node_modules/ent/test/num.js","shasum":"65311e12e302cae8b891727701f7709adc6a0745","modified":1420933654000},{"_id":"themes/yelee/node_modules/escape-string-regexp/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1403645654000},{"_id":"themes/yelee/node_modules/escape-string-regexp/package.json","shasum":"4340bee90cbc410b6ce7a5d18434210f0cc48e52","modified":1456469176000},{"_id":"themes/yelee/node_modules/escape-string-regexp/readme.md","shasum":"b693d3ddaf0a2edac02f8dc9b60382f7a818083e","modified":1456057032000},{"_id":"themes/yelee/node_modules/expand-brackets/README.md","shasum":"6480b9a4aea618ca0008d55c604c8747db80589b","modified":1438464589000},{"_id":"themes/yelee/node_modules/expand-brackets/LICENSE","shasum":"7e21c9f5aa0a1be61e943a935506095ea40bbafc","modified":1423173787000},{"_id":"themes/yelee/node_modules/expand-brackets/package.json","shasum":"c7959e77e754fe6af212768bdfc72352f466b462","modified":1456469176000},{"_id":"themes/yelee/node_modules/expand-brackets/index.js","shasum":"d30cf1aa96d67d4b1d52a9234e04cdc7b2718980","modified":1440148604000},{"_id":"themes/yelee/node_modules/expand-range/LICENSE","shasum":"d99d5158898474f25efb4c8790f9fcc4cf55b350","modified":1421022684000},{"_id":"themes/yelee/node_modules/expand-range/README.md","shasum":"ca34ffedbd376b5fa552f6e1778f357e073779f9","modified":1422624444000},{"_id":"themes/yelee/node_modules/expand-range/index.js","shasum":"c1b5fe07de2d7fbc35440eccba98d542eea988e1","modified":1424034813000},{"_id":"themes/yelee/node_modules/expand-range/package.json","shasum":"005bcab4cb0ef8198273f6120e4e2637dacec750","modified":1456469176000},{"_id":"themes/yelee/node_modules/extend/LICENSE","shasum":"bed93ae1abcd71e5d1c9c363595dd24bb1b9016c","modified":1435780828000},{"_id":"themes/yelee/node_modules/extend/CHANGELOG.md","shasum":"782aabec0278f6500fbedf61e29a5a0d748c78fb","modified":1435783518000},{"_id":"themes/yelee/node_modules/extend/component.json","shasum":"07af5d609ee23647ce3238a0e1322c35b385fc45","modified":1435783532000},{"_id":"themes/yelee/node_modules/extend/README.md","shasum":"4bce70a4b2e7dda8a760418301a4622c0557bae9","modified":1435780828000},{"_id":"themes/yelee/node_modules/extend/package.json","shasum":"8e2f886a2b4b751deeebc1f99bb63257160731e9","modified":1456469177000},{"_id":"themes/yelee/node_modules/extend/index.js","shasum":"9154a195afa931672ff49f30d5fdf0c5a10614bc","modified":1435780828000},{"_id":"themes/yelee/node_modules/extglob/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1429345875000},{"_id":"themes/yelee/node_modules/extglob/README.md","shasum":"ac4514f62a9bbf39090ca79839a0cc9a95d8e810","modified":1438459882000},{"_id":"themes/yelee/node_modules/extsprintf/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1360175237000},{"_id":"themes/yelee/node_modules/extglob/index.js","shasum":"c330dc0091d0f58e6a22455c1dc1ad5796013bbd","modified":1453279404000},{"_id":"themes/yelee/node_modules/extglob/package.json","shasum":"f56a678bfb92ff0177dc866c312d975fd89d9eb0","modified":1456469176000},{"_id":"themes/yelee/node_modules/extsprintf/Makefile","shasum":"88eff1bf9d8152cf847e0720e384a4a84418082f","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/Makefile.deps","shasum":"f27b6650501f14e21f8ce186476537d0e2f3e026","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/README.md","shasum":"e06a0c86165e03cf3170be3f4e5b7dfd5c7eca5f","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/Makefile.targ","shasum":"f66e38899fc918aac830c478ae402c66d8793bc7","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/examples/simple.js","shasum":"5e7b4892b3625f689d9dcb5fd2e43140f21d66a4","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/jsl.node.conf","shasum":"7197578b829d6c93d8356bf114c7f3d26722ec0b","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/lib/extsprintf.js","shasum":"cfe80b99a5d428a0f357ae11e0a067c46ebdbb2c","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/package.json","shasum":"db62245d197bd87344c951442fcb70ba5a765298","modified":1456469177000},{"_id":"themes/yelee/node_modules/filename-regex/README.md","shasum":"6f7b2600f371413b90ac67824993d73f8e209664","modified":1422107084000},{"_id":"themes/yelee/node_modules/filename-regex/index.js","shasum":"0c901dd7fd6cedfd15f2c1fea2cbf3efb3837aaf","modified":1422106871000},{"_id":"themes/yelee/node_modules/filename-regex/package.json","shasum":"596e9c72d78eaffc1408a728196e7d3016d62420","modified":1456469176000},{"_id":"themes/yelee/node_modules/fill-range/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1428396142000},{"_id":"themes/yelee/node_modules/fill-range/README.md","shasum":"846adfe3de4ed18174b00fd079e3704daab075e9","modified":1428396632000},{"_id":"themes/yelee/node_modules/fill-range/package.json","shasum":"cca77ad2c3d70614d529cc9af6ff1cbbb9b31570","modified":1456469176000},{"_id":"themes/yelee/node_modules/fill-range/index.js","shasum":"5ddcbe607a51a43d05eecfc9fe333a96005e91e1","modified":1449439890000},{"_id":"themes/yelee/node_modules/for-in/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1427178221000},{"_id":"themes/yelee/node_modules/for-in/README.md","shasum":"12359b5563a9d991e3b8a6a379cbba30a23a37fb","modified":1427178003000},{"_id":"themes/yelee/node_modules/for-in/index.js","shasum":"691db06522e53f8d10f7c2c147bebe4addd16f32","modified":1427178221000},{"_id":"themes/yelee/node_modules/for-in/package.json","shasum":"4a7534e3f366d3226aef81234697146dca403cad","modified":1456469176000},{"_id":"themes/yelee/node_modules/for-own/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1427178102000},{"_id":"themes/yelee/node_modules/for-own/index.js","shasum":"a015403a1ef9e5270327e876f852930b66c25ac3","modified":1427178102000},{"_id":"themes/yelee/node_modules/for-own/package.json","shasum":"ad2a88e6e9af65fba7215e05985ff0932723ecbc","modified":1456469176000},{"_id":"themes/yelee/node_modules/for-own/README.md","shasum":"7f75457c2e068515e4f3f46458fb490333f27568","modified":1427178013000},{"_id":"themes/yelee/node_modules/forever-agent/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1426938522000},{"_id":"themes/yelee/node_modules/forever-agent/README.md","shasum":"fd2b1d08b55284aa2abc72d199e3c487744a0c31","modified":1426938522000},{"_id":"themes/yelee/node_modules/forever-agent/index.js","shasum":"a96917d5912eef5a8ed12a4b1f3a41400eac80d1","modified":1428426146000},{"_id":"themes/yelee/node_modules/forever-agent/package.json","shasum":"b1a47ec08823dc7a71451992aaa69e6a114522a8","modified":1456469176000},{"_id":"themes/yelee/node_modules/form-data/License","shasum":"1d11381521bdc7e7df9bb1d7bf85341ffca266d9","modified":1438228280000},{"_id":"themes/yelee/node_modules/form-data/Readme.md","shasum":"6af9e2006617a38c1f5ce1186ca9069cacbe2bf1","modified":1438228280000},{"_id":"themes/yelee/node_modules/form-data/lib/browser.js","shasum":"79f01a7616f6247aa3e55a73602e477cbe15a7a5","modified":1438228280000},{"_id":"themes/yelee/node_modules/form-data/lib/form_data.js","shasum":"a7aca54a95311cd44da040f8c5429fd649c06b2a","modified":1438228280000},{"_id":"themes/yelee/node_modules/form-data/package.json","shasum":"1712d72478bde15199f65b56577a6bb008a6d3e5","modified":1456469176000},{"_id":"themes/yelee/node_modules/fsevents/LICENSE","shasum":"aff99c3b222af6dc2cc4d713ee6f46de6febcb4e","modified":1426989723000},{"_id":"themes/yelee/node_modules/fsevents/Readme.md","shasum":"58a6326efbb8b6403f97e535abff0c305d8a2bbb","modified":1449701320000},{"_id":"themes/yelee/node_modules/fsevents/binding.gyp","shasum":"f1bf70a0822fc2b333fc4b9202dd1c3bbb7052b8","modified":1441767349000},{"_id":"themes/yelee/node_modules/fsevents/fsevents.cc","shasum":"50afb7dd154c23daefef0b5432d85c90e0bc75fd","modified":1441032660000},{"_id":"themes/yelee/node_modules/fsevents/fsevents.js","shasum":"db803a36632d843d8cc5dc5a73f19df73d5d4b17","modified":1446645410000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/History.md","shasum":"e08a586cfeff13f78415131ab12dc59047625b8f","modified":1452816446000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/LICENSE","shasum":"29e2ec2d24a38c009dfb6f3c1b8d1b57e3ec492b","modified":1452816251000},{"_id":"themes/yelee/node_modules/fsevents/lib/binding/Release/node-v47-darwin-x64/fse.node","shasum":"e225f2763b760583692ccfdfc87788af7b334b65","modified":1456188282000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/README.md","shasum":"95d1873583f32730c8ffa1ff463b2cadf08f2667","modified":1442006415000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/examples/clear/index.js","shasum":"7b00443efe706b7ac20e843515087b4b379d5e16","modified":1426184022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/examples/cursorPosition.js","shasum":"e4d4c5f329672a2b8e58047f56765a59502699c4","modified":1442006415000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/examples/beep/index.js","shasum":"aab8b4f5c513d02b3be10dfc4c73c93e16c042e3","modified":1426184022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/examples/progress/index.js","shasum":"24cdce431211efc73ae6cc61aba05a6c3e8c29f7","modified":1426184022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/lib/ansi.js","shasum":"eac25e4f75b684ce56d7091d60fe4fb7bf26e8b2","modified":1442006415000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/lib/newlines.js","shasum":"9bfaff398370f329734fb275c5f0d7733d76918b","modified":1426184022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/package.json","shasum":"1c3a2ead959a5437de677020b072bcc2ef05c112","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-regex/package.json","shasum":"e37a019fd02f5c738100e01ccc319c8dc068efe4","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-regex/index.js","shasum":"03d6a4cc534cbb9a855b01b372a17bfa2b830442","modified":1435679868000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-regex/readme.md","shasum":"76c119f1cf0605a0409f9c2756de3e55a1398fc2","modified":1435679915000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-styles/index.js","shasum":"7e89eee4c6711e897597268d129348b685cc6548","modified":1435756896000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-styles/package.json","shasum":"92995f73cfd26108fa2a01fbc78ddb71529e6630","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-styles/readme.md","shasum":"b12348b9ea14a18112719b1aad4cdf7e52f4b35f","modified":1435756896000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/LICENSE","shasum":"13b22b5c5f89edc3f31e092b7298cd65687e7250","modified":1449362748000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/README.md","shasum":"904b624ad7c2b8695b03e06701437b8913081c8b","modified":1449362911000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/package.json","shasum":"c322dcdf2d099577a77acd772485cb60d26dfd97","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/index.js","shasum":"06a843e3f97d2de36d147082ef3b5a1fdc7b741a","modified":1453935680000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/test/tracker.js","shasum":"6c1682be5b99645e4910a304a048b4ca1b783f01","modified":1417811068000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/test/trackergroup.js","shasum":"487907a04231f9792f01fa576421e3a8819e9b36","modified":1418025000000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/test/trackerstream.js","shasum":"687a590ad8880527b812df27430542c5cdd8a64b","modified":1428037437000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/LICENSE","shasum":"724e48cfc739674999ff82b4e49d76d5376818e9","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/README.md","shasum":"71e6a47944ebaefe5d5357a7b6f46df9c389316f","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/errors.js","shasum":"556bbb1b810ede9292493a70ad9a8644e5c4fb7a","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/index.js","shasum":"1ab39535ed24903d0f9e2a4bf74333702842080b","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/reader.js","shasum":"3cfcdc9225bb43dd8413dc3f1f05d4fcd32d0b30","modified":1443646115000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/types.js","shasum":"8a41886747dc1f7cde7e4e5cb60e1a3b8a4c813c","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/index.js","shasum":"cbff145d47fb41eb1262f012a7024e7b0e527d6c","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/writer.js","shasum":"bdad4a0bb12fb5f91b789329fc4e4a45ecf87e64","modified":1443646115000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/package.json","shasum":"fcde168b164423805f164103716f7f1469f8a601","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/tst/ber/reader.test.js","shasum":"de84b2d7317393c6e6a0cdef04bfbff82ba78237","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/AUTHORS","shasum":"d1d14de8fc8c21f9f86c2231df2531381f6a9194","modified":1446952976000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/CHANGES.md","shasum":"b64b8d16f3858a1c3d55538c5bfee934437af75b","modified":1447141659000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/README.md","shasum":"79988e7cb3bb80b7cc20dc420ee2a7f86ab3d3e0","modified":1446952976000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/tst/ber/writer.test.js","shasum":"59892680384339812688163b346d12cc05e979fd","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/assert.js","shasum":"8f3f85bae8edd30db24882766a5c8c4df8357462","modified":1447140668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/package.json","shasum":"db88399340e0921559c2b2ce1c055da38f49bef5","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/README.md","shasum":"1e5c0380861222c007090d0c0a1d8ca4f5272dc5","modified":1452208687000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/dist/async.js","shasum":"a410bed1e8c6a19be68101c293ff66c4961076ae","modified":1452211451000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/dist/async.min.js","shasum":"487f1a1adb0bf6b00233edb64e64f2fb305ce5a3","modified":1452211452000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/package.json","shasum":"0b83cf81e68d8e876a12c0fe95f538e4a1b18461","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/lib/async.js","shasum":"a410bed1e8c6a19be68101c293ff66c4961076ae","modified":1452207555000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws-sign2/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1366607619000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws-sign2/README.md","shasum":"5e8e0e7c811b1f319c0e94ff08f38ecf4896e3c9","modified":1366607619000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws-sign2/index.js","shasum":"b380be041c204108febb8f32b19431a54aaed4a6","modified":1444584231000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws-sign2/package.json","shasum":"db83c21a1138b3d557a0213d11b0f3b1e61aadf1","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/LICENSE","shasum":"9ba903f14c37d0ab0250a8e6920e7269bdc5b294","modified":1384232184000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/README.md","shasum":"8b02542186fe300b27acd3aba5c65b77a3d822e3","modified":1426551080000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/example.js","shasum":"4da6b34b39625ad7b9c788f6c2ebac1f80531520","modified":1426551098000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/CONTRIBUTORS","shasum":"6a6e5148568ff15b4756ee478f0da581ea97fc01","modified":1385053079000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999527000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/aws4.js","shasum":"4155d86150b56a456a7b90fb55a82b8e9e3fc666","modified":1451426937000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/README.md","shasum":"129fd032ba2ac7580e57e0d9988a4d06f1b344fd","modified":1448474798000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/lib/lru-cache.js","shasum":"d4091806568fef3089f4522f09d5976d91912dd4","modified":1448475000000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/package.json","shasum":"05bfe76c8a7f6ec3ac09a087013436dac514a32e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/test/foreach.js","shasum":"5493ce987892f9c740837c36acd5240d9cf93644","modified":1448413217000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/test/basic.js","shasum":"caffd5539b398fb1f369ed259c14dc4d00eda244","modified":1448474452000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/test/memory-leak.js","shasum":"5b5690f4e32c4d2fc501e7f408fdcfd25f8b4e3a","modified":1435688444000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/test/serialize.js","shasum":"6383a06c3f56cce6eb364b66f2301eea00db5828","modified":1448474452000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/package.json","shasum":"b1935d934d7f07bc6757ad70c477060c3673004c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/LICENSE.md","shasum":"d068ae801f9277b4b248f0c2aad7f50181dacaad","modified":1453181857000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/package.json","shasum":"11622a3a326df275982b0e19b2f8b4a216c623e1","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/README.md","shasum":"4308d9ba8f28872911d3e4f8b3de6b56b47be042","modified":1453181864000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/bl.js","shasum":"640a8dd3791d6962ef2d968a5f89fb06adf01314","modified":1453181857000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/test/test.js","shasum":"809ed5ce6857e95b00d1247de5d98d2fc31e9da6","modified":1453182317000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1432105388000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/README.md","shasum":"165520dbb78c0d401c0cbc3efc33753b9737d2f0","modified":1317956974000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/LICENCE","shasum":"fbc159c463d7717ec1acff3d8b6524d0ce74f2a7","modified":1331939706000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/bench/block-stream-pause.js","shasum":"67df5f7f0f8ad86ee6fdddbe6bea1aa28c6ac6eb","modified":1318903909000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/bench/block-stream.js","shasum":"42821f2fe9db3e4d0f9c51f5a9f7b20423a418fd","modified":1318896987000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/bench/dropper-pause.js","shasum":"982774d6076efbbd7b20cd8ae1adbe84223da254","modified":1318903105000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/bench/dropper.js","shasum":"dd1925e4c2ace4e86d1d1f2c9bff66b425b7e0b7","modified":1318897004000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/block-stream.js","shasum":"60770fccf771c6d03441efebf62fb257473c163a","modified":1366232220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/basic.js","shasum":"278c9b462db9ef2c6f9815ffc97764cf3be7ab48","modified":1317959661000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/nopad-thorough.js","shasum":"ff5f326b21707010825647d3ff6f0f28efbaa308","modified":1320791299000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/package.json","shasum":"50530cbb5162ec6d06ff5f0c6c05f5767dc6db42","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/nopad.js","shasum":"353fea96f0c506e06114d9480a4feb5d5b397d07","modified":1318891657000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/pause-resume.js","shasum":"dc1f099b749cf4c0e93b55ea6f378d8d89012977","modified":1320791299000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/thorough.js","shasum":"e1b1f164bcdb11255e32d11a8a80cc7f60d27edf","modified":1320791299000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/two-stream.js","shasum":"2d8e79865c92715133159a698d36b57176d6eb2b","modified":1340227457000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1411478104000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/LICENSE","shasum":"53ded9fedb90236c92321a45d1ab00fa35f282d8","modified":1407506005000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/images/boom.png","shasum":"126fe71d237c4939338507417d5f5e172773be3e","modified":1407506005000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/README.md","shasum":"2d7368cd181df38d42b300f04f7323cc16f9b7d2","modified":1446232305000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/lib/index.js","shasum":"a894f6f39fc0bf0f8a82a420d8a2a5018e9dcdbe","modified":1446232305000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/package.json","shasum":"388f74028d643724aea014611f94543163009684","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/test/index.js","shasum":"62d76a920212e160acf6894f1ee3e981e6aaa8b1","modified":1446232305000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/LICENSE","shasum":"48f9e0a4c07f36c07d47962212fe022d0417c90f","modified":1435268329000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/README.md","shasum":"5770b9496fb480f7c403b6c38759a27d6170e882","modified":1414608769000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/index.js","shasum":"326fc25f6edec25f7d239314ed6e75259147088a","modified":1424972076000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/package.json","shasum":"164a637829712e1e9db74fc3ef2a6fd1e389f304","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/chalk/package.json","shasum":"c799d83da65131ce275f4fa4812fae791c1d26da","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/test.js","shasum":"73948ff77c144352fb9d9615079ee35cab781912","modified":1414609010000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/chalk/index.js","shasum":"08315806beaa18a4eb58052e8e7182b2d8bddf8f","modified":1440014707000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/chalk/readme.md","shasum":"a10251893e1a61957a4c7238001e682d20d46d47","modified":1440014506000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/combined-stream/License","shasum":"04e7b761eee5270ea8914303516852faf990394b","modified":1403594961000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/combined-stream/lib/combined_stream.js","shasum":"5d3a85a28a463dc2949fbb974919598e00183d24","modified":1434294512000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/combined-stream/package.json","shasum":"7f1aeae32ba6f1686a2309d30c54fe15827d203d","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/combined-stream/Readme.md","shasum":"9a4115c7973388087b21e93e1c538371e5f94ce9","modified":1434294512000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/commander/Readme.md","shasum":"af810334e87894faf80bd73d9e207c9d5f2b3c90","modified":1444531073000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/commander/package.json","shasum":"f5f6f74806957cad71b97fc05868ceab32b058eb","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/commander/index.js","shasum":"5adc820ea125a479f7fa597cfe2083eeede0dd2b","modified":1444748408000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/LICENSE","shasum":"a95471326a84657b0e164f84e1285685f63011e0","modified":1447979068000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/README.md","shasum":"d4987293f1078d937454a14a5ca6f386d227679d","modified":1447978999000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/float.patch","shasum":"d7f073ceb05c6f6dd1bb852fc00f5379a3e41301","modified":1447978999000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/package.json","shasum":"134308c1ab5eef494b32a215bf6465211e44bb9a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/lib/util.js","shasum":"7d34435928ee9228995c04eaa7bdcef875c41e65","modified":1447979840000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/test.js","shasum":"2837ee1d57f385943ba5ccc7fd0ec4ed1cb8cfdd","modified":1447979358000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/LICENSE","shasum":"2d1840f1b4088e3a370317c82e7b443321f2b2eb","modified":1441778892000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/README.md","shasum":"52c9561e75f66870d194d12ac07c05bc0484df18","modified":1441778892000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/lib/index.js","shasum":"e5c479d1d0966b82298d86669aaa5ed4bcee4fb7","modified":1441778892000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/package.json","shasum":"039277bac5be9d7a8b335d77f74e185fc437ca10","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/test/index.js","shasum":"c4d4151097d486ade0ee21bfd91297dafda16e88","modified":1441778892000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/dashdash/README.md","shasum":"e40739349732594d5d96438bd27aa444915d3f79","modified":1453144686000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/dashdash/etc/dashdash.bash_completion.in","shasum":"cbb2d2c1c856735b5555384080853f896aac9c61","modified":1453144686000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/dashdash/lib/dashdash.js","shasum":"ee9836b6bb5625fd29fb95483214d7e679f96c8c","modified":1453144686000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/dashdash/package.json","shasum":"96d3541187b96ec4a1352fc22881bd893b576deb","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/History.md","shasum":"b468a2f1d58147ab41c4b817d4aa627ad13c7018","modified":1431199973000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/Makefile","shasum":"6521581191ac9a04ee418c5f2e3b05042421eed7","modified":1431199632000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/Readme.md","shasum":"a5c1b396924aa2101e501543bfe9750bdf2f9480","modified":1431199632000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/browser.js","shasum":"36202f55a9cbc03b8d10bc9b14748eb00a79a419","modified":1431199632000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/bower.json","shasum":"d66ecb3b7d22df8fcc8936a18f1e3b9261808cb8","modified":1431242465000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/component.json","shasum":"b31ef70de11fdd63030cb49b2c8e50bbf54f1ae2","modified":1431242465000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/debug.js","shasum":"bb692db9f1b4e06986755b168fa71c1bd360edb8","modified":1408510177000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/node.js","shasum":"30354b578cac8fc83d13d2f8b42f19c579255e3d","modified":1426272474000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/package.json","shasum":"7c00c1413992981e9bef2576de1259a44239b221","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/deep-extend/README.md","shasum":"eac1c3118d5a56e9145539d97cb87403b6a98844","modified":1452985878000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/deep-extend/lib/deep-extend.js","shasum":"204a94059923c358d83e93aa2c76a41b39de2cc0","modified":1452973894000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/deep-extend/index.js","shasum":"b88a0d6a70660e804a88f0cf89b6bfd978f900f5","modified":1452973894000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/deep-extend/package.json","shasum":"2cad90311832d6109eb8d6fc09014e521b9c3e0a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/License","shasum":"04e7b761eee5270ea8914303516852faf990394b","modified":1430160212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/Makefile","shasum":"1d88cf18c0fef56e91425a086590e31271a7c4d5","modified":1430160212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/Readme.md","shasum":"21db9b7ec97b7028a031a18867aab00575b09850","modified":1430160212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/package.json","shasum":"ffe71c0e5c4f995792df4ae3cf65958e82e5c379","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/lib/delayed_stream.js","shasum":"097ab12e3837896d11d3f1d2c7a891d177b493c4","modified":1430160544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/History.md","shasum":"37e8641729544115b9d3a566ead3480e47d44a9b","modified":1450122948000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/License","shasum":"9d414bd96ce8326fadc2f959781154de49af5b00","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/Makefile","shasum":"abd4a7cd4a519df349900dd853a307f58a5cd4a5","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/Readme.md","shasum":"b0afdd75170fd52fc87f9d0bbaa713054fdf42c7","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/index.js","shasum":"694697be68fb102fb7e9f70d9f35a8827c6d6943","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/package.json","shasum":"41e8eb97cd53ffe0fe97625f438434a81171554b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/LICENSE","shasum":"d9dddd103d636dbaa178cd222de612fd923f62da","modified":1393978405000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/test/index.js","shasum":"f1c8ec4cfea947c03d8dd7c2ce43e7e878794284","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/README.md","shasum":"97cb1bdec48ebb5e46e64fc5441c79d3d38a3c82","modified":1408853444000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/index.js","shasum":"13c052ad0b0507a4203d5d1274fdfa049a6c1339","modified":1448288282000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/lib/LICENSE-jsbn","shasum":"4f94910918b5e57f3e55c7387f43b0d6293a4319","modified":1394075812000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/lib/ec.js","shasum":"d9a60c831fe91bd2c62ff3e3c9675b0379ef504c","modified":1448288163000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/lib/sec.js","shasum":"b1632526290dfddc063f05ac6ed29cc40bd9e221","modified":1448288300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/test.js","shasum":"9709f584f556ceb8acaa0fd746029dcb58390eb4","modified":1408853485000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/package.json","shasum":"0211eedff85b26c72e3751f14ee3f9c9d4f421cd","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/escape-string-regexp/index.js","shasum":"17b40cc4dc8a455277994ab351c0650215394042","modified":1450563101000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/escape-string-regexp/package.json","shasum":"b3e030d5d5a781ba125c170de34aaac319fee165","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/escape-string-regexp/readme.md","shasum":"b693d3ddaf0a2edac02f8dc9b60382f7a818083e","modified":1444058838000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/CHANGELOG.md","shasum":"782aabec0278f6500fbedf61e29a5a0d748c78fb","modified":1435783518000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/LICENSE","shasum":"bed93ae1abcd71e5d1c9c363595dd24bb1b9016c","modified":1435780828000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/README.md","shasum":"4bce70a4b2e7dda8a760418301a4622c0557bae9","modified":1435780828000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/component.json","shasum":"07af5d609ee23647ce3238a0e1322c35b385fc45","modified":1435783532000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/index.js","shasum":"9154a195afa931672ff49f30d5fdf0c5a10614bc","modified":1435780828000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/package.json","shasum":"86c05639729e15106cb7c820771e7a0c127ead75","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/Makefile","shasum":"88eff1bf9d8152cf847e0720e384a4a84418082f","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/Makefile.deps","shasum":"f27b6650501f14e21f8ce186476537d0e2f3e026","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/Makefile.targ","shasum":"f66e38899fc918aac830c478ae402c66d8793bc7","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/README.md","shasum":"e06a0c86165e03cf3170be3f4e5b7dfd5c7eca5f","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/examples/simple.js","shasum":"5e7b4892b3625f689d9dcb5fd2e43140f21d66a4","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/jsl.node.conf","shasum":"7197578b829d6c93d8356bf114c7f3d26722ec0b","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/lib/extsprintf.js","shasum":"cfe80b99a5d428a0f357ae11e0a067c46ebdbb2c","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/package.json","shasum":"457e74665edd417492d9e9b437146d749180be75","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/forever-agent/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1426938522000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/forever-agent/README.md","shasum":"fd2b1d08b55284aa2abc72d199e3c487744a0c31","modified":1426938522000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/forever-agent/index.js","shasum":"a96917d5912eef5a8ed12a4b1f3a41400eac80d1","modified":1428426146000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/forever-agent/package.json","shasum":"0c946ced2200f0d59b072ff02ec5a71d58040e72","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/License","shasum":"1d11381521bdc7e7df9bb1d7bf85341ffca266d9","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/Readme.md","shasum":"6af9e2006617a38c1f5ce1186ca9069cacbe2bf1","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/lib/browser.js","shasum":"79f01a7616f6247aa3e55a73602e477cbe15a7a5","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/lib/form_data.js","shasum":"a7aca54a95311cd44da040f8c5429fd649c06b2a","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/package.json","shasum":"7bd310625b6c5fbc920bcc850eacaac4dfd78ae0","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/README.md","shasum":"ed7e0a5f1120d22e425ac6c5f08c3ed611f93baa","modified":1441842040000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/examples/filter-pipe.js","shasum":"a5b494a4fe5738f5b2c7a3df3d3e7c9685e8cafb","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/examples/pipe.js","shasum":"ff0ea1e9b09953cd0e96420f419e65a9fe3f598b","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/examples/reader.js","shasum":"9d828670e866e34dc8212c564403f78c98558c80","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/examples/symlink-write.js","shasum":"a795df07387ef7c89d4d5afb33722f11b68dcdfd","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/fstream.js","shasum":"cde00245f823e368a96b0bf0aa7749fbf94021bd","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/abstract.js","shasum":"237e8d46b8a6087e7b9b46fd14537cf6f26b79ce","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/collect.js","shasum":"c0841dcb15eb7f67ad9699e8db89e5241e892bcb","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/dir-reader.js","shasum":"72161bd3e3576549f5f9dc7970aaaa09bc764737","modified":1441845533000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/file-reader.js","shasum":"2b6f5039d467b080fb92abb57a673ec97877e9c7","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/dir-writer.js","shasum":"3746846974dbbdf325f8d15ea8ca0d012fa5dcc2","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/file-writer.js","shasum":"f4e66be6242777e3c38564125ab626edbca1f3a3","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/get-type.js","shasum":"ef95fa07f3c5af2226d74feb0f66fb87df5e288c","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/link-reader.js","shasum":"e9f6cc283c032c5c21768d76ff48651f8169b530","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/proxy-reader.js","shasum":"1b24a353bd457db6a84dfde4feecf0a9367f15d9","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/link-writer.js","shasum":"74b0816529379a9ffa93c1ab866d7399c63eb136","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/proxy-writer.js","shasum":"ba51acb8e3b5277c510cf9f97fb3d07f0567f3a4","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/reader.js","shasum":"323979daecbf47fba50278e908c2f77c3eef52bc","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/socket-reader.js","shasum":"11296e436392e54d4b2018c524c580f794b00486","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/writer.js","shasum":"580eff911f66640c7caed30bcfa224ac91c9496d","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/package.json","shasum":"c7d5c78973b2c12c18f4dcd44df9b65fad7340b3","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/README.md","shasum":"ba3ea6ed0e20d4e115bc428bdb3c6ac46db73fd5","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/example/basic.js","shasum":"d7a8e1617b33ee936f4976922269b0608309f678","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/ignore.js","shasum":"050a85cd5ce874c41c1e5bd510c2208bcbc0f85b","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/README.md","shasum":"fb5bec4ab02467cdb76cdb552613ff0547402439","modified":1407793656000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/README.md","shasum":"3ed262742cc9e8e0db93c5f1d729127af1ffbe82","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/minimatch.js","shasum":"16b28bcabd1eca778c2176d6c49330396907411e","modified":1437616284000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/example.js","shasum":"8a259435e31e75ac76d3abcbefd225af7f41c185","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/index.js","shasum":"6d8c3796c04fb513fd0a1d1d66e59ef73f075f76","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/LICENSE.md","shasum":"09013c002fbdd686da2ec13c5a6d014f0a294ba9","modified":1445519600000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/Makefile","shasum":"98cb6ef36a74f052f3bad15c72f01d78e2d0ba8e","modified":1445519548000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/README.md","shasum":"261a929745508f56c655d4ec306123bbfabdaa16","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/example.js","shasum":"27792bf4ffe9ce453c5d6896611d7647fd8f0e6b","modified":1445519548000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/index.js","shasum":"8c1cf0e709f8668e14b11c9086a50c70a0b0434e","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/test/balanced.js","shasum":"706b6e79b2c13f0fed4d25706b63bbeec17c3600","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/README.markdown","shasum":"132e6e8fd1d19ec2422fdcde00840d8237e44094","modified":1354099276000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/package.json","shasum":"4247d02ff3eba0a962adf44734d0b574e9aff1bf","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1391050985000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/example/map.js","shasum":"022a614b8d9f5ccb67b6ce1f478b1efd7aff298e","modified":1339124034000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/index.js","shasum":"a3063f014cc693b320dbd64de3243a79247c1e05","modified":1354939769000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/package.json","shasum":"ffa4caf6c5ea7bef6c191b9f12f7fc76aeb90db6","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/test/map.js","shasum":"162cce32c23628192cef64924a1ce768af399a4b","modified":1354099176000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/package.json","shasum":"fd1eef529b6782424aa5c44b819c6faaa24d63df","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/package.json","shasum":"8b6dc33ca4310ac9867632043a5911e72ce0f6ee","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/package.json","shasum":"498de8f3b3816bd44805f66037cc62d2788d62ba","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/00-setup.js","shasum":"f0fd8188b27143153d0c519bc034fbb3639f4312","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/basic.js","shasum":"71bb54d431a1121dc08f2b212cb89dd3e42e5713","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/ignore-most.js","shasum":"9c1519c559e5f71283269ce38ebd76489d7e5b8d","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/common.js","shasum":"0668403c695d97759db32f06b59a5e35934f7e37","modified":1433889073000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/nested-ignores.js","shasum":"77038e94e3b6b72a935df479d113d3f5f5397e1d","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/unignore-child.js","shasum":"96da57e0eda3ca25ded1989b98ffca651860c6a3","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/read-file-order.js","shasum":"918110c9f5222640bf4abd7024c5cb117ff5664a","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/zz-cleanup.js","shasum":"36805caeb3799434bb3c2d0f94e75dda54840d73","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/LICENSE","shasum":"ce0c4782bdbd720baf4d2484e5b71728d3a943af","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/package.json","shasum":"767141cd2873bafc2b6ade420ccd15e827e915c1","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/example.png","shasum":"7fb19a54b7521b6a7b08c52ef70f311751fa800f","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/README.md","shasum":"698270efddb3f6ce884112d51b9d813d9c06f52f","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/progress-bar.js","shasum":"35f4f50c6e852f6d5dd38c8741c434496172512c","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/README.md","shasum":"d9255d9f65aeed364e61715ce43392b237dd10a7","modified":1406741356000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/test/progress-bar.js","shasum":"a1feb803ea2772dd73d37aaf3f1cf0432eac0447","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/index.js","shasum":"2942e1c63f5a2013a70196110b4859029d09c48d","modified":1408639884000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/example.js","shasum":"677d763dc7b82f9d69585388ff04094107481e4d","modified":1406741329000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/test.js","shasum":"9bb3d8f4f20a97f1af0ef033d8dbe32693f9fb3a","modified":1406740670000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/package.json","shasum":"8179b5abf0baa5b2837444bc62c4cb9f267c6829","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/LICENSE","shasum":"a95ab3a4b0e4bd978897f09b3b430a449da20a08","modified":1427465395000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/README.md","shasum":"e300730218d5bbf519653e5d19cfbd5857b78796","modified":1427465395000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/index.js","shasum":"47eacac5534f58609e9f3ccc3a1c5879c20f9add","modified":1431893671000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/package.json","shasum":"3d6bcf30a482e537c2de52af3f329fca7d74e885","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/test.js","shasum":"b738cbfd474028baa30f5b003e228356d61c6a58","modified":1427465395000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/README.md","shasum":"3ca4000bd861d5d95e8f861fc35d30a31b48677d","modified":1435601369000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/fs.js","shasum":"8b8116f2fc0e6393cfed3b1076810ce5d02e0f01","modified":1435436586000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/graceful-fs.js","shasum":"48c86f6a8c193aa2ee2969f4b8fbf3c722ab97d8","modified":1454449073000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/legacy-streams.js","shasum":"f4a3583d4c3e8b0c407ab8406bdafb02b4055b7f","modified":1435436586000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/package.json","shasum":"3b001b25dcf3146afa98b080dc1de4cd24c839bf","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-readlink/LICENSE","shasum":"e9f4a5c36ecaa401588e457af96e7a85d53a98f0","modified":1423665419000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-readlink/README.md","shasum":"a3e9fe045614e9dc2473a75cd9a7e9a6315043c9","modified":1423714083000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-readlink/index.js","shasum":"3ecfe7f28912aa64161b8a6e4129c2b4fbcf50a0","modified":1423714095000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/polyfills.js","shasum":"57619610164625aeff0f6bbefc4008ac2d909b43","modified":1435436586000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-readlink/package.json","shasum":"2e7fa57502651c40a8d2a0f8893ca9a4240af5da","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/bin/har-validator","shasum":"702b45900cba1bd2ee74c4df1a5b51db0aeab0d7","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/README.md","shasum":"43ef10fa75b3eb5369012ac32654ab907a79fb14","modified":1453244556000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/async.js","shasum":"864f1787c6e6521d6495d337d7894d844dba24b6","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/error.js","shasum":"e08730fe6ce867fea7b32e8e7c6f9266b7fce592","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/index.js","shasum":"099021ac86914964d97afb35a9594e29c136bd0e","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/runner.js","shasum":"c0c49bddac013682d52bfff6065cceae67474fb2","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/cache.json","shasum":"24dd76d544e1c3c4be343e1a88e9ffad19705021","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/cacheEntry.json","shasum":"abb6d0b052b7f624f2e9efd5508c0614c4831b36","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/content.json","shasum":"896c9f34e3f38c5687255edcec798bedc98221a0","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/creator.json","shasum":"b0096cca448769435a9a1dfc8835bc560957fa97","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/cookie.json","shasum":"fc6b61b7f65667ebd270e2daadfc21e6b6aec452","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/entry.json","shasum":"161d6c3ab62b4fc423c5aa1d3ee1f67d98c008ca","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/har.json","shasum":"9b5debe33b9aa8c6055bb950ca5f19b1a1d82a42","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/index.js","shasum":"1bab9e9eb0c54be915c5303ee23cba4faaff0194","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/log.json","shasum":"9c72f7600e6fad2818459e76de0140ed9cb67422","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/page.json","shasum":"d3ca0cf8dbcc30f33b91b8e8db85982b01cc5986","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/postData.json","shasum":"123d9c6853b0e1a33147e2c04404aa33cf53a1ff","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/pageTimings.json","shasum":"2661f2488c8bfaec68b30b4e9dee25089277e448","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/record.json","shasum":"23a2f8245bfef93b6b87696af51c1e9d4a0302df","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/request.json","shasum":"ecdaba295ca01aeaa9f3f9779d1c94a051af5578","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/response.json","shasum":"e01a380eeb0b3c87c37f936ebf4888eae55dc3b1","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/timings.json","shasum":"4879ffeb448af68307aa46910bd2d3ac2fde9246","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/package.json","shasum":"bccf834aaa4187f1c61ce1153716f15042e0c11f","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-ansi/index.js","shasum":"e7305f641b51be9dc463cdfc1e6b7afb8d03576e","modified":1402774137000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-ansi/package.json","shasum":"b22270a86ae1c29b45db05cd37168668f058ac39","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/README.md","shasum":"ace56f38c5b7a359fa99a9338a7d93a85a1d24ab","modified":1448499284000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/package.json","shasum":"8789309532231c5042924549121a4eeace5aa584","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/index.js","shasum":"35b9e9a4011608fd14ea1d7f158654d7eda8fd0b","modified":1448499183000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/LICENSE","shasum":"0478d8708f5ff5e49c150412201cb066a9b2006d","modified":1419955664000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-ansi/readme.md","shasum":"8f5dd99e33b07d2f4abaff2410728acca335ebfc","modified":1435680789000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/test/index.js","shasum":"454a09bb55fe15de1bc72daa3bd91d5e13a169ce","modified":1448499521000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/LICENSE","shasum":"23dc309f4a3614d359884bbc4a64d0ca20e41d68","modified":1453233148000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/bower.json","shasum":"0394736479292c80f177ca8d29263d9162d489b3","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/README.md","shasum":"332080064c5f554a1ad68a43ab48a68d2b49a1a4","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/component.json","shasum":"004be58031f7d1cbdbff8ca684b464df449cde8c","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/dist/client.js","shasum":"78e967c19bffde7606b06c595c41e83cde6c0d53","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/example/usage.js","shasum":"9c61ce5a46828c4c26b93e06141dbee8679c33a2","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/browser.js","shasum":"d4f08ffcfa0012fdb1a304d0fdda5586cf959af3","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/images/hawk.png","shasum":"756c85c7133e66dc5c119c47081f7f890d046f77","modified":1447968927000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/client.js","shasum":"781eb260241b46515df2f2f009969a772aa9dbcc","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/index.js","shasum":"64f1cfdf834d8d679d020071124865b83a6cae72","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/crypto.js","shasum":"06d65d9f325d49f11a0bf223dc683648f6fac977","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/server.js","shasum":"ecde371bb849aa221cd138ba993f5fb19fff160e","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/utils.js","shasum":"befb760ea6a14654fcce187b2b790f8292b404b2","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/package.json","shasum":"e904bd9a77e7f3e29eaabda2f839db58821cf129","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/browser.js","shasum":"fda1c8242cc48078540c30464da1d36a64d223a6","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/crypto.js","shasum":"222fe636eb910e343a0dd0db76224fac92a47647","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/client.js","shasum":"fabb1388ee6f94ffe25870f2152d1a46c480dde3","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/index.js","shasum":"9e790c1104e148298687c0ed87fd48ee14a943a4","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/readme.js","shasum":"e8743507f0a6c8d261e1d037e8aadc11cda3ac82","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/server.js","shasum":"45a0a16ecee59114ad2765a73af25443125278ba","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/uri.js","shasum":"a7037450a234ee97c7bce23dc5c2f295fcddbd47","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/utils.js","shasum":"042ec97613b298b257e409d54eeca7a84ef3f84b","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/LICENSE","shasum":"8798f9342afed7351f4aa459b96e4d1062c1dd89","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/README.md","shasum":"fa10590d10b5c14546e9124bf634621583235285","modified":1442428161000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/lib/escape.js","shasum":"5ccf43b55ca0fbbc307a91235127af5601bd1187","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/images/hoek.png","shasum":"61fce871b635b32957b3c8c4e3c523eb2b2ac58f","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/package.json","shasum":"da1d39cc6474b93a303b3226c66a32aeb14df821","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/lib/index.js","shasum":"cfd3b556015082fc786d83c3e85ade81f448aafb","modified":1442857232000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/escaper.js","shasum":"206886beb62a1d9d907b3838b20eb2037826167a","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/modules/test1.js","shasum":"32aceae0ba03e9116b108f41d74bea7d163bb56f","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/modules/test3.js","shasum":"4b695a807655475e7d89966828af28b7dee15ec5","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/modules/test2.js","shasum":"31071671a8bdb854825c1cd90e29c30e9203b9fc","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/LICENSE","shasum":"10b8ac49ffb8f7cc8bdca9303209a1b3b2f3587d","modified":1442600921000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/README.md","shasum":"5847fa2ec86a2ca744776acd5528fdfd6c3377fc","modified":1444857627000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/CHANGES.md","shasum":"59a2ab5cc1ac7f7691560038beb2349e628eeacc","modified":1453759387000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/http_signing.md","shasum":"945eb22661d1c43e547371ac8d354a4b761eab09","modified":1453759268000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/index.js","shasum":"996c8efa1d7896034c980e498bec866824662d52","modified":1444858648000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/parser.js","shasum":"c47fbe5cb6f1be3c5a5d62f9085273f3403ff401","modified":1444858648000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/utils.js","shasum":"dce96d033869c424854178ae71991fe39b7c58b5","modified":1444858648000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/signer.js","shasum":"5e312acbe0c57117dad754fa369a36dca4569bbd","modified":1453759272000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/verify.js","shasum":"f0603457d003b72d484d608b266566e771644438","modified":1447890069000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/package.json","shasum":"f30349078562246c05bbd21814aba1f5ef9b9d48","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/README.md","shasum":"f2f8d26f1cf5fb1e3a68aa225221b064f999fefb","modified":1368714278000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/inherits.js","shasum":"3146ed5f0e6053ad30398afdbd5a0d6a4133a4cb","modified":1368714177000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/LICENSE","shasum":"3b0e8d58a362b1787ef3504fba4f593b22f3cee4","modified":1376950172000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/inherits_browser.js","shasum":"7c13eacf36e79e5e7dd257d80ec25846e4df7eb3","modified":1368715198000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/package.json","shasum":"a53398e37716ea017f5b6bb1e43fe24ac801c638","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/test.js","shasum":"ba3f458c9b47c1bcd3fdf5dd9289b7aa0ae90b1c","modified":1368715388000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ini/README.md","shasum":"1997c778eb616617ba9d369f6a27828bf83af8b8","modified":1410851261000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ini/ini.js","shasum":"361f1811be8059fe1e009db0b8805fb17046d4fb","modified":1423612669000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ini/package.json","shasum":"7788edf20b3012169c84ce86eda534d0fc3e961b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/LICENSE","shasum":"a95ab3a4b0e4bd978897f09b3b430a449da20a08","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/README.md","shasum":"7579af584be527b613516d1b4146bb23e45c17a6","modified":1440789245000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/example.js","shasum":"cee9de4194e0c4ba372b5678983d6d701385d355","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/formats.js","shasum":"2d511859d3d654f3bf604a47e13f98e9b1bc305c","modified":1453067668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/package.json","shasum":"efc83f85c6bfc6e139cf43ca8d8225d66a2ddbd7","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/index.js","shasum":"bb2c1a15eb553a2dd948ebfe09b3b95312df173f","modified":1446823818000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/fixtures/cosmic.js","shasum":"94a2af635cae7d0491fce9767a67d06f651e0244","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/require.js","shasum":"24081d202d91cdd0b4910b57dfd434ab41543b07","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/additionalItems.json","shasum":"75644b309367675ce21d8b35b9baee049a58e159","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/additionalProperties.json","shasum":"34478026a586b1ff8b96dbe54efdf7515099da7d","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/anyOf.json","shasum":"8081feb305d328878b37a7cc3b296eb5544c239d","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/bignum.json","shasum":"32b70fb2c2156c979702eec5c18a86c1fe6d0bd7","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/allOf.json","shasum":"e98aea1d36d932870561f0c32c32fc5858f251f9","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/default.json","shasum":"17c051cc94a9fb40ad627b04a41d7dce9150e3b5","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/definitions.json","shasum":"0963ac4f014a0faf6ad37554c9af03f63dad9b02","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/dependencies.json","shasum":"d239f1bb8cfffb7487335c73e02c6cda10d4ef5b","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/enum.json","shasum":"4b96cc24245950f9fad0916113a5056d9f51c2e5","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/format.json","shasum":"3d60bdb3fbb2d47da991e99e51bb9ab241703c44","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/items.json","shasum":"873828cf8ad5d2701022650e99367cb0a89624b0","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/maxItems.json","shasum":"580cdb7c89cd07b45f3fdadb2279bb13108b79b4","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/maxLength.json","shasum":"3f6273e86c31605607384559df5ee9c92201c5bc","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/maxProperties.json","shasum":"1703d6ef976a74eae8ea6cd21c131853c6ca5f6c","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/maximum.json","shasum":"c205edb4c5bd171c9e1f4955f5cc3b94ca78cb0c","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/minItems.json","shasum":"176fedc074768c6ec5c7ceb979f23a6a4bd0be58","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/minLength.json","shasum":"99eb79755bf43df641900a01e8ac9ff5becec8d5","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/minProperties.json","shasum":"b61b2829899d8a5f6bbc8bde2b694b69bb35d38a","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/minimum.json","shasum":"1a849968c80db05a9ad0a92481edd93dee567804","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/multipleOf.json","shasum":"9e70c593b1cc3a3572a0d389b5b7a171bf292ddd","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/not.json","shasum":"5b9567e8409e28b256f3704ca83447f0d0abb707","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/nullAndFormat.json","shasum":"8682b818844ecab9f69642d3f121eea59877f6e0","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/nullAndObject.json","shasum":"dc0ff1a9b5740271c3e92436a697a50ee8168046","modified":1437940209000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/pattern.json","shasum":"5b09d287b8d5170ba4442429bf5309eae1f3cec8","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/oneOf.json","shasum":"6772cacb066e5458a7fca9a47cfee27b56110d6b","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/patternProperties.json","shasum":"e0080348b213f1d004af7d5c43c2f3f29375224b","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/ref.json","shasum":"a9dd881b0a9d5272897be0cc8550c5a64841fc8c","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/properties.json","shasum":"1aacdf890a9b844c7275f6ad2f3acc2f9100219c","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/refRemote.json","shasum":"ef0c43623cad9a3ceb7b407272062ca55c1c9c7e","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/required.json","shasum":"35b980ec46ea56c7c7c38afc63c84a863d4b3132","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/uniqueItems.json","shasum":"8c9909ffd2abf8f625f81c18a43c789efa369e34","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/type.json","shasum":"e2e4371fb68d01ecbc7a5022348c0ffd05d1fd9b","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema.js","shasum":"c5ef8e3da495a6ca1c7cc9dd0cb8d8c415dcc245","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/misc.js","shasum":"748b6ed6ae2678830339a94e6b0291fa2563545e","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-property/LICENSE","shasum":"50fe55ab192fa4860c14bd57bcec5d090904eb97","modified":1374156563000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-property/README.md","shasum":"dc4d53b5d6c1d1387fd41fb6bf3597d9642540a4","modified":1374156267000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-property/package.json","shasum":"49eee5e4b84a24ede4b71f24d62d41eb405b4a88","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-property/is-property.js","shasum":"d09cd64e2bcead412c4d3be1d95f76fe1e315794","modified":1419518893000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/LICENSE.md","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1401649683000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/README.md","shasum":"8f33b0dd445cfa2ab6712dee34df082f480a5a76","modified":1401649785000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/index.js","shasum":"b7ff45ac41fdcb4bb75dd771d6cb9bfbd129e56d","modified":1431824601000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/package.json","shasum":"894c25e54ecabf49ad72b06c641707f6e6c5726e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/test.js","shasum":"c3aa563061f8d086aaf066b389b0e811444e3913","modified":1401649839000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/README.md","shasum":"34470c173ddf6ddfbf9683cf343e83cea1629049","modified":1369676403000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/build/build.js","shasum":"711567b86256a86ed22bd637c35786d13e0f73b3","modified":1369676297000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/component.json","shasum":"88615028e91d7872104932a02b78a75f04df8465","modified":1369676355000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/index.js","shasum":"eec5f3c0d16211678cfc7c2d9c18bc4718adf700","modified":1369249661000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/package.json","shasum":"153f08e27474c7213ec22be16a4b8635a7fccfab","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/LICENSE.md","shasum":"3fc5bd6825a9d8fd53c0cd8de0bd16d1c1a7f37a","modified":1425687271000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/README.md","shasum":"0563c8dd8178c335de8d882a14c0408ba179789b","modified":1425687291000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/isstream.js","shasum":"db3d8708d100bdb66fd33e1eeb6d2b232016934b","modified":1396827239000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/package.json","shasum":"49a832abdc377a43f99030aad18f20d76b7f2cb0","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/test.js","shasum":"3c3c171729a3738bd73b12d311265c7fcfb2a9fa","modified":1396831146000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/LICENSE","shasum":"4fe6ded38ad123523792104dcf60f28badd905f2","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/AUTHORS.md","shasum":"cc3f12565134b1da757450b40b5f3fa80c7fc132","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/almond.0","shasum":"216d893df0f002babc23e63d4c98005db5e8104e","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/README.md","shasum":"3a28ce7b2aa6b6343508cfe28eadec9733fd14e7","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/jsdoc.json","shasum":"5a3782a2b7072783e0e5aa3b74d9c87c423818dc","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/index.js","shasum":"29e0b96fa095b35ecac9be6c2afde6c9b769e73b","modified":1445885964000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/almond.1","shasum":"157b7bc54f90865debe5b1f817a8c1155b580dd8","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/core.js","shasum":"55894ff0a71a08de470029f7689b3967c2ce9233","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/curve255.js","shasum":"fdc3f9501dbda3945b6478cecaab0b0e1ecd2d63","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/dh.js","shasum":"e9a0561e419e956f953570d7121e65c84fa72488","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/eddsa.js","shasum":"bacec5f12e7d5303cee9b0493e22b3743a19ef1e","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/package.json","shasum":"57fef6e07ebedf58b42179d9645dbb7d6ddb8ce0","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/utils.js","shasum":"5b4e9a60c9f4758bf714e52f9064df0d33fd019a","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/LICENSE","shasum":"d9b1b910dfea689402ffdb75f5467ec263f8480d","modified":1446141666000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/README.md","shasum":"6db673c03e15b4e75f95e25ba87177799511ad0c","modified":1446141602000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/example.js","shasum":"ba7f33b1196eca41a007177372fe237ac7a85c1b","modified":1446141602000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/example.html","shasum":"ec1f94b093e0f1457642f8647294be35d4af033f","modified":1446141602000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/package.json","shasum":"c38816f871f1a7d5b17d7918f9b0682d7b50c582","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/index.js","shasum":"f53a89111c54f03ab39eab110c924b560b877051","modified":1446141602000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/README.md","shasum":"9065e9ab354ce910706716a42584222674fe1470","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-00/hyper-schema","shasum":"a5972bcc99abc4936ff350f116a69390f8ac99e8","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-00/links","shasum":"490c91fb104a16a76290377797a5411d21379614","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-00/schema","shasum":"253c4fcfccaf49023c10a1a92d81cc3d21344e8a","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-00/json-ref","shasum":"b5f7e93c3edc2eb501e913441ddfdeef0c04386a","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-01/hyper-schema","shasum":"51802f7884c813fe2a002776aa97a440c7442d9a","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-01/json-ref","shasum":"2132a5a9319f8bf190040b49150e005e0916ed22","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-02/hyper-schema","shasum":"117eb70efaa120edeb97caa6ca7e53eae8f761e2","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-01/links","shasum":"09b2131c15d754a61a1baf1158a8e6c73644287f","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-01/schema","shasum":"10942d74811e1e16425e6219b0ba808b493321ab","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-02/links","shasum":"f8a835ea08959ceca9682cf1c30df6d5cf9ff033","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-02/json-ref","shasum":"31b76b211e24e56b0ff5ae3ba739835039cd96b8","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-02/schema","shasum":"ba84a3e7e9332328db986a1123084f2a6dba57f7","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/address","shasum":"b6e70440f5faf725b978da4e92f6f39100377674","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/calendar","shasum":"3e53cb296ba1799f39c5a00bc4627fa10e26e165","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/geo","shasum":"74d8c66f1ba74c6cd330b8acd5948efb5f2879e4","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/card","shasum":"c1405e471f81bbb4eea94c2ef85fa07195a8ad80","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/interfaces","shasum":"9666b12a3d05e526886aa2650f0439d32b25f0dd","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/hyper-schema","shasum":"552aaa9921cbeb19c2c9b485e64965f7a98e22fc","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/json-ref","shasum":"9f121cedcda14cbdd55e2fd80a96e289d9a1f2f9","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/links","shasum":"5f1601142843a6028beb35cef8b851413a4dfa91","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/schema","shasum":"4b500e66b7c4a36bc4d3ff6da089d6228c54f94c","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-04/hyper-schema","shasum":"362194bf4c6690db17b848c1a796ef747bf7a6c1","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-04/links","shasum":"92cd269ccdfe3f3bc673205133cb9940afa465c4","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-04/schema","shasum":"7a6839ef21cf49fd6bdc687be7dbfbb92c97ac7c","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-zyp-json-schema-03.xml","shasum":"da15453583b019a448fae4b857fe29a583bc1a38","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/lib/links.js","shasum":"9d0d0289e4dd2840778b88834f17bad854b013b5","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-zyp-json-schema-04.xml","shasum":"02845f4b0406bffb06ff5cb01eca43f492db6901","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/lib/validate.js","shasum":"97195ad80d4a217293a8bc240ee44c0c89a7fe79","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/package.json","shasum":"fa5f2db6ced4bc174783e16af4599c2607be9a08","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/test/tests.js","shasum":"f3f322d2cec777f57df41b071818a05e97d35f2a","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/CHANGELOG.md","shasum":"d9b3407ce2eef8d2dadc6b2839a8b16b783eef47","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999719000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/Makefile","shasum":"589819e00a30573f50fa4a11ddb22fb45b372a65","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/README.md","shasum":"a2972dd72d8ec7c8b1f229f7732f911ed721dbca","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/package.json","shasum":"6883e12536091d528a074ee3cec552237a651c0f","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/stringify.js","shasum":"b36a3a8d0f794fae13dc8e1c93bd4a8cae311bf2","modified":1431999708000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/test/mocha.opts","shasum":"98216b4fbc2e0c1c17ee946b02272a26fcc1f4c1","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/test/stringify_test.js","shasum":"4760401b04513ae7eb79fff0e1239a9947a8af78","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsonpointer/README.md","shasum":"7b05e3bfb84beb3a5e7607912fc47ccc8d2b1e33","modified":1430458330000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsonpointer/jsonpointer.js","shasum":"cd510cab1d95a07efc733965dd2533a3fad50e51","modified":1432622187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsonpointer/package.json","shasum":"e27c7cf73b0405cc138b8f74cfc582d727783434","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsonpointer/test.js","shasum":"ac5befd353f47b170e2efececbf1ef6d82bc6ade","modified":1432622760000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1416249172000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/CHANGES.md","shasum":"56da97f41e22a449194235ad13ee30a2f4758956","modified":1444953672000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/README.md","shasum":"78fa58f9e0acaee38db00e4ff234394308cef93d","modified":1444856653000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/lib/jsprim.js","shasum":"b6fb3f70d3ba7ce276c625e0dd5cb7dfb0af67d1","modified":1444953536000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/package.json","shasum":"02f389d4c4058d297e1e5fc305ef9f646c0b184f","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._basetostring/LICENSE","shasum":"36c3ff463d0890f895498124f6ef3295fbb4a616","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._basetostring/README.md","shasum":"e075950489d6d73eeeacb4906e37b09e4f6cfe78","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._basetostring/index.js","shasum":"835c23c6a3642d720f0ee0618c0e8861d8cb3134","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._basetostring/package.json","shasum":"2a653805082aeccbb39e207b5c53372006d9a141","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._createpadding/README.md","shasum":"bda43e247ff533c8eaf26c45e47736e58fe1d373","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._createpadding/LICENSE","shasum":"36c3ff463d0890f895498124f6ef3295fbb4a616","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._createpadding/index.js","shasum":"b19e0107063ae114288a10dbbe839af1ab3e9a5b","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._createpadding/package.json","shasum":"d5d6dc9c8f33ac9b9ad8e1b5dba7833d6629bd30","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._root/README.md","shasum":"91c4c36c5a2bf927c710d573732f55a0c0ad6095","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._root/index.js","shasum":"545616dd71d349344faab75f29b340e7ce77b361","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._root/LICENSE","shasum":"3a1d08be6b4b07a0ec877adc0a9d2e238ff711f5","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._root/package.json","shasum":"f5dcf3bd6fdac87986d40eca82de2af6e710c59c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.pad/LICENSE","shasum":"3a1d08be6b4b07a0ec877adc0a9d2e238ff711f5","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.pad/README.md","shasum":"4c459dabb74826d06acce0c922929bceef5c5513","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.pad/index.js","shasum":"4871fb052f40df95397e45de54174cca6ed4099a","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padleft/LICENSE.txt","shasum":"36c3ff463d0890f895498124f6ef3295fbb4a616","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.pad/package.json","shasum":"1f5d2b3215963a04bfb91e71f0b6fd142f6bc3c4","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padleft/README.md","shasum":"0e6843f638d533a73ef1b21caacf96d571bd8ef0","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padleft/index.js","shasum":"4faeb94e9ffaa3b1b30636bb8dfe6e45e0e02cdb","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padleft/package.json","shasum":"e93bcd1bb99cc1f9246a1dc16eed71d03e3b2b8d","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padright/LICENSE.txt","shasum":"36c3ff463d0890f895498124f6ef3295fbb4a616","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padright/README.md","shasum":"c9ed091410ba5c18a1e0d504a8cce14546b2b2c5","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padright/index.js","shasum":"f212732a54455ce07d042150faef7a0229d04a1b","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padright/package.json","shasum":"b47d855f23933c96e403a1f1cb93a39fca121a9b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.repeat/LICENSE","shasum":"3a1d08be6b4b07a0ec877adc0a9d2e238ff711f5","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.repeat/package.json","shasum":"716e39bc2503a38e3ee7e27a9f1c091241539355","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.repeat/README.md","shasum":"536792bb622d08ea03919eb41037b1a5c70a42f7","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.repeat/index.js","shasum":"5d3846daaed514f752445f94632c96aac6338f83","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/HISTORY.md","shasum":"118acc07d6743b47568717a7fcb42f5a4e1aaf59","modified":1452100935000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/LICENSE","shasum":"b559c45c8d07f2679620d9771e68696ee3d5964b","modified":1423439849000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/README.md","shasum":"1018078c0d9fd0331ca23ac5d97ace15596bf46c","modified":1452022838000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/index.js","shasum":"31180f8d0ae079b1bee7ee03e77ea5323583eb06","modified":1423439849000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/package.json","shasum":"40c77135b96e22a603ee46554053a2d409e83cf2","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/HISTORY.md","shasum":"d2ab51246e8865a74bc6f27b8b4182ea72bab920","modified":1452102507000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/LICENSE","shasum":"f027af3e61af3880fd7f7b8ba9452a85dd215738","modified":1433741526000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/README.md","shasum":"904567c440d9be49c0e52cbff36fb16d08e624ea","modified":1433741526000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/index.js","shasum":"d1983bb9d10cc678f693be62ef05e1b8c2638ef0","modified":1439520766000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1372145420000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/package.json","shasum":"df8866b598e35c1d8d3f9eb78ebad84baf803ff8","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/example/parse.js","shasum":"7684d952ceaa32a8c9e3cd21ba26a62e7ee14387","modified":1372147306000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/index.js","shasum":"c69b3860fa8b40337db188fdfb201077df93ef5b","modified":1392957961000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/readme.markdown","shasum":"b037b8453fa008383cf7495b3736aa7cc217deb1","modified":1372148196000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/package.json","shasum":"6d2e0eef3859ccf658d63c5dca30c202446c734a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/default_bool.js","shasum":"ecdb759c4275fb23bd5d072c3c6a7baa74b407c7","modified":1372147071000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/dash.js","shasum":"27fa6e19e26916edd7fd46ccc2d0b2301b3042a3","modified":1389378397000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/dotted.js","shasum":"51664f4efb36d519b2e439f1156e05e917c08bda","modified":1377730679000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/long.js","shasum":"f0ccd5d55358f78efbc928753264e4a32f7724fc","modified":1372143145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/parse.js","shasum":"e240ae50a049d7b4b4b625467df34bcfaef7dceb","modified":1392957961000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/parse_modified.js","shasum":"5c3cf170e2a2476e0f5bfee9af78556a1958d503","modified":1372145355000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/short.js","shasum":"2ce00fdfe4906fc504286974c143c4ced6a11b12","modified":1391917546000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/whitespace.js","shasum":"ea3a87137fa34c00a7d84a4d0350770e8d85ed9c","modified":1372148159000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/LICENSE","shasum":"35d8442a9599f876c805b2c7d31178ecfa18c829","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/bin/cmd.js","shasum":"0dbed17e23d62e8dc9893f9459768531b300c95c","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/examples/pow.js","shasum":"6d34dfc0f5f17a971dee0f5ba40eba5219bdd803","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/bin/usage.txt","shasum":"682ca66d4def0ba4af814be4e6363eff5fcede0d","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/index.js","shasum":"e4aca996fb54ff20c3dad61f1fa7807fcb44409f","modified":1431570694000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/package.json","shasum":"c76b7c6d2681fef5e5ae3ec6855c1401f40afc68","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/readme.markdown","shasum":"e4ffd1099773d1e612dc9ecea76dbb791ef355f5","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/chmod.js","shasum":"ee02690748279a5bad6179dd3feeb66a48d330c8","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/mkdirp.js","shasum":"628f2dbd4137f64e69454708ba513870b85af4c8","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/clobber.js","shasum":"4d00dc55c23f21600adbceb6760587b3ca861626","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/opts_fs.js","shasum":"8dd756971f7443eb340b846acee0c17cbadbcb87","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/opts_fs_sync.js","shasum":"0f949a29099c6206e617d6e9e39cb3a41d0daab4","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/perm.js","shasum":"11382491d90f70fce17e9d183765c343c7870c3c","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/perm_sync.js","shasum":"1759536f89220a608a3987a3038cbaaa0e7458ac","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/rel.js","shasum":"2488c0b77bc0419a4646c7d0bcfaaef5651995a5","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/race.js","shasum":"237f49a5262bc2c668653897e8cc1af8eaa5bd89","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/return.js","shasum":"dc2bf5dd5eff2e6a914fc1f731f50ac887ef9d31","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/return_sync.js","shasum":"ef9a789aeb65bafbbb7bceb048dc33ec24a41e3b","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/root.js","shasum":"b034b5fdf0da3932263437d9d52b53642a2b40ad","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/umask.js","shasum":"d08a2f100ddc37e563e548fd9f7730599009824c","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/umask_sync.js","shasum":"917a95e95427eecd9a0cb7807e0ab6ab3c653fcc","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/sync.js","shasum":"22a3775a59d8994c368e5574ba8ffbe19c8b8648","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ms/LICENSE","shasum":"06c5a8e25add90a402138ff3d78eb6524f2cc710","modified":1429572836000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ms/index.js","shasum":"21867f756553abdaede5397a39c6d55931b353e3","modified":1429572968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ms/README.md","shasum":"5c2f58a77f80869b968e1450639fb2ae64439f1b","modified":1429572836000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ms/package.json","shasum":"6f30a5162512053713203f6f69590c0babf69102","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/CHANGELOG.md","shasum":"19b9c208f46e999b40deb66f012f8836db6c5c33","modified":1455047528000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/LICENSE","shasum":"0917a1370f9878d391966436c6029f7b84b0cefb","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/appveyor.yml","shasum":"a16195eb4558ed7290fe5bee741369584d69d362","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/README.md","shasum":"04ffce5c71fbe6c8a0a7528e81d4032b4f8e55fe","modified":1446679217000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp","shasum":"14a04775e8c6a8ad81d809331b3e9a205f7a6295","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp.cmd","shasum":"b12c5e56438c650e4062bea15e6d00a07435b4ca","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/clean.js","shasum":"64d4a2e0d250775aaa813da7aecd336af0ec357b","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/build.js","shasum":"60da785242154a5d4edf83b36b2286a3072df265","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/configure.js","shasum":"4800e9525f634d866a57ed87aa016b921c1e3e55","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/info.js","shasum":"5d625595e04cf4547122def865fa775c0dd646ba","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/node-pre-gyp.js","shasum":"e73bb230546414362ab58e30bda731dd7fe256aa","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/install.js","shasum":"de6d5234d2430b27ee7edf4526d7ab35b37c6979","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/package.js","shasum":"e39486542432242ce871526629c41075f0952098","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/pre-binding.js","shasum":"71f81e4b2714e28b98709279bb5474dd1ee3f851","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/publish.js","shasum":"a55ba3f801cf8b754f8a0cc20585ae1c2012ffaf","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/rebuild.js","shasum":"301048bf08e2b839733e4f47c18a5c17387ea84e","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/reveal.js","shasum":"f70ca7275048686ba9dccf0d5d5a1a89ebec75bf","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/reinstall.js","shasum":"b3cd9833e14d5d61705cbce047d6a29f09916581","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/testbinary.js","shasum":"7f9e8c6f0ed523df0a489bd71164f27fa2bb674b","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/testpackage.js","shasum":"ca02a24f4c522b836402ee263792c89fb461844f","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/unpublish.js","shasum":"b5ca72ed97ce1e7958551f1d0f6817699682b0e0","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/abi_crosswalk.json","shasum":"c64438026ddde7678ceab2c56922422d4b28e374","modified":1455047528000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js","shasum":"aa761ce14eac57b0526247fc941f9c0d68df5ebf","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/compile.js","shasum":"7088bb5462fb2cc4ad9b026f879bb288414e0537","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/nw-pre-gyp/index.html","shasum":"a98470c7571d877e59dab48204848ea87b2f0d8a","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/nw-pre-gyp/package.json","shasum":"3a785cd04b35cc9a5fb36ad1a97561e7d3c3cf53","modified":1394928774000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/s3_setup.js","shasum":"967f7f5dae61a38a86c3c7a4ffebb7df13eb1740","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1447359143000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/versioning.js","shasum":"442a5db3101b773ba810f4b0e39c89a4a5a6d862","modified":1446679217000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/bin/nopt.js","shasum":"f2a561712df0e004c712bfd6c9b0fdc70cc26e8e","modified":1447359143000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/README.md","shasum":"dd491d80a00af3ba8c01730825f011eaf91c001b","modified":1447363130000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/examples/my-program.js","shasum":"de3d4a6a7f350fd6846d3ae06334d1fafffc7054","modified":1447359143000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/lib/nopt.js","shasum":"d3dcdbce19312c5473deb7e38672a2d5e034af79","modified":1447364058000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1432169859000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/CONTRIBUTING.md","shasum":"12ce7abccdd3aeebd1d093a30bb1768f120fb8cb","modified":1360631762000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/README.md","shasum":"c520bc857ec612ed88e13d794c47882d5aed3286","modified":1286218346000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/abbrev.js","shasum":"b75c6b10bbfac1092ef493079ae044cc89824dc0","modified":1397765081000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/package.json","shasum":"c373268f789711af182e2728d1a52aa780827010","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/test.js","shasum":"4af3fea0290e02e4d82225ce75721b423c212483","modified":1433026583000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/package.json","shasum":"6f10a92650c46043ccff0db996e96549861d0170","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/test/basic.js","shasum":"83220640df8cb4211523fca22cdbf9d1094d07ee","modified":1447364293000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/package.json","shasum":"031eb29685eff5e8f21c4e3a9cbc2e433712b93c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/LICENSE.md","shasum":"09bedf3eb387e2883ded96ee501d16262350c9cd","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/README.md","shasum":"7ca0c673b27c3c4c50167b5077bb421711c2518b","modified":1447445668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/README.md","shasum":"783d814c48583b086ffd8b701a53844f799e7d0d","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/bench.gnu","shasum":"26bd5d465f2588f4ebda09b9aa28f3fecffb9f4a","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/bench.sh","shasum":"3f8daeb462ad5609c63fb8915efc4fa870a8fde5","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/benchmark-native.c","shasum":"8d999ba3178ae2683a7ed30b9ff115fe9d9f41bd","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/benchmark.js","shasum":"82dfd78c7f35bd52a84259e9afc36018f41bf58e","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/bower.json","shasum":"6d521f86833c6d9a6a75af623529479fcf89f917","modified":1447446668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/bin/uuid","shasum":"cc4874ec4258ffff8b743227a3619f895941b563","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/component.json","shasum":"7e1d6df157d7075438267019c90f5cb158b26983","modified":1447446668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/package.json","shasum":"ed86c0486730fef07e4a85e53ad1c626b1b75c4a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/test/compare_v1.js","shasum":"ac9c80da67f4b232b0aff05c4160deda00dda2e6","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/test/test.html","shasum":"287decf793ae25e5cffda0f5a118a41ccf54fca0","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/test/test.js","shasum":"bd765f9091cfd101f0679e45330ce04a62266453","modified":1447291212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/uuid.js","shasum":"91f473812e7748b91d6adb32ac704c4f8cdea13a","modified":1447446491000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/README.md","shasum":"8bc40cfe4367b91fb624febb536fd4c81bf81e7b","modified":1425164767000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/example.js","shasum":"a6f0d0a2735b42bab3b36afcdacea47000a9aa57","modified":1414722499000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1444275719000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/log.js","shasum":"6d281a81e21d694795aa7c58df849a8c686b0a39","modified":1452645460000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/package.json","shasum":"1179729b4ba68bf013130f35f5d496fcb9734126","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/test/basic.js","shasum":"8499ebd31b6852088e74c54d19ecfb915ed51db5","modified":1452645460000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/test/progress.js","shasum":"e097be13d02499514d9448156f7b401277fa31ef","modified":1420650960000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/README.md","shasum":"9f943ef5e4c1e530314bee287c8fd5b8addbc808","modified":1432536000000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1432536000000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/index.js","shasum":"fb3d1f2193e77b18089fad077d3133143811f554","modified":1454224562000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/package.json","shasum":"e64c96ebb3144df58c27d7977b1197fcb4e42bb7","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/test.js","shasum":"972d35362f1eb47ba9e12409a6d49ecc23e8a968","modified":1432809220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/once/README.md","shasum":"f980f2811a57fb0732e9fa9bc43c9e8a2d6b0011","modified":1382596021000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/once/package.json","shasum":"3a436d1d7e725ba7f1ebfa5f0cf5b39c2302f8fe","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie/index.js","shasum":"4ed6d8988b13d2c29cfa99c99cedb43fa6b51ee7","modified":1454324862000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/once/once.js","shasum":"67e1e2cfe1a08a3cc9636382beab2e3cba80d9b6","modified":1448055900000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie/package.json","shasum":"ea31c8d6471c4b9d1d4fc4bdcf373d07f9677c6a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie/readme.md","shasum":"1673aa52b8f81f6ebf1c2e5ca0184a6f63522f78","modified":1454322504000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie-promise/index.js","shasum":"cc84d8fc33cad091d8dc7bc65c0481a8a915769b","modified":1447318268000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie-promise/package.json","shasum":"42b492ac5b0355e04b4afabb8aa58c2a4f1d4f70","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie-promise/readme.md","shasum":"450859283a97df6ee0918789a485d26786329eb1","modified":1447318268000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/license.md","shasum":"9def7167175d2ac68505dd2ae0c7b8dd63bc4c3d","modified":1449008551000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/index.js","shasum":"066a18ff5757235dbe5ea1a2c632946293dcff6f","modified":1449104960000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/readme.md","shasum":"3eba0a30f0a115fd767a0c8c9761d60d1dc768c0","modified":1437048205000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/package.json","shasum":"9f9b49fa355f269c5c73fdbaacc8fd6bbb315d9c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/CHANGELOG.md","shasum":"a8c66d98d8c1501b5a506709fc7f4285b59c7f82","modified":1453069331000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/test.js","shasum":"279a062028d86a4ee0ab2ab800ecf7ca29f4905e","modified":1449008551000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1450856430000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/README.md","shasum":"9d57cdff65ba49f961ad3805df133c282c4672e0","modified":1453069466000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/LICENSE","shasum":"ddf13f1b7345d730677237125bc2e46fbbfbbf32","modified":1450856430000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/bower.json","shasum":"d278db3097c39d4df650b04bbc42d03021b87409","modified":1453070078000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/component.json","shasum":"affe28b8b20dde94e6cdc469ce5b11bcd87bcb9a","modified":1453070078000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/lib/index.js","shasum":"227523195233e42a48c20f75a1ae350c6bcc5b47","modified":1453052046000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/dist/qs.js","shasum":"4999c7f95ac28c994fc5f4772e51d9288ea8b6cd","modified":1453071516000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/lib/parse.js","shasum":"f85546c13d4cae0f65b3bb3693cc92e18636abe3","modified":1453052057000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/lib/utils.js","shasum":"b4614510e0a35009a95de16f2f7a19dc8bbf9265","modified":1453052057000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/lib/stringify.js","shasum":"910b15fb61e39f8c3fcb5eaf522f5f6daf1f3e77","modified":1453052046000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/package.json","shasum":"3288a7e1f9e15142388b25e1aadbc61d18b2ba30","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/test/index.js","shasum":"3d9a66ca5549d2dd32f6a56c4ba0472498fb68a8","modified":1450861863000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/test/parse.js","shasum":"b7041aee47eca551b475d405957a019e61296bf5","modified":1452717606000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/test/stringify.js","shasum":"38ca94758266fbd37217faad5fc7bff6d3ef1e0a","modified":1452717606000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/test/utils.js","shasum":"5f25e2ef762a18cff8719d88a1748840c1626d89","modified":1452717606000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/LICENSE.APACHE2","shasum":"e66a2c506febaaf8c744908ec3e5be148ffd1d86","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/LICENSE.BSD","shasum":"a93b16b3298b9ed28337b75b382b10ef616d404b","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/README.md","shasum":"3d04a532c78dd3c9bd7efd1b49fc1f68bfcd3a37","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/LICENSE.MIT","shasum":"6a911843ccabdd6bbdffaffc0083a03435ceb2b3","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/browser.js","shasum":"7981b353221fdc9c2c9d92dc1f5ba0620d4c6280","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/index.js","shasum":"2183e906b3d9ce1a867d9dcffe8f85a235b742be","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/lib/utils.js","shasum":"d67bfe3ea746f485caa0cb2743a4dedb2ba8264f","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/index.js","shasum":"cfede1ccd2ee41f74022c002b5c6d05e65c482c0","modified":1440424576000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/example/parse.js","shasum":"7684d952ceaa32a8c9e3cd21ba26a62e7ee14387","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/package.json","shasum":"c72bf224669c9af6c154d408dc2d029e7a41b6bf","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/readme.markdown","shasum":"067b8f01bd1fcf09a6418e3db4b323c8eb9ad479","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/all_bool.js","shasum":"d5f1721995050d6d9de35c56222e578d6a2a8b5e","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/bool.js","shasum":"a0ef26a085e4d5530ea59880049cf7aeeaf9bead","modified":1438902415000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/dash.js","shasum":"0fe20783b683b525cb3ff6872474ac6fd89a8b63","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/dotted.js","shasum":"edbda6ea34cff9e7dc3fe1953b72eca2f955cda9","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/kv_short.js","shasum":"e87208f3f2695b7de0c27e234bc4810cd6d49b8e","modified":1440424577000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/default_bool.js","shasum":"71da47b49e90b77c88caccb077c1bcfb555399f1","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/long.js","shasum":"f0ccd5d55358f78efbc928753264e4a32f7724fc","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/num.js","shasum":"6a52983a855113284f2aa9633876c1adf3710463","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/parse.js","shasum":"a9672d89e1623b05aed85a4b4afcfec7fbaa359c","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/short.js","shasum":"2ce00fdfe4906fc504286974c143c4ced6a11b12","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/parse_modified.js","shasum":"310215056f588e8c04e92f0cf6337ca28a8e0d78","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/stop_early.js","shasum":"dc728f383a53ce9e44c9c1c21360bb7ad71d6205","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/unknown.js","shasum":"b55d1e1d6ff269730e4578a108f4c340e70da262","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/whitespace.js","shasum":"ea3a87137fa34c00a7d84a4d0350770e8d85ed9c","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/package.json","shasum":"d602f1af0b859e06edb520d231080693a99e02ce","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/test/ini.js","shasum":"aa73cff807f34a5c00d03064a4748e6936163b42","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/test/nested-env-vars.js","shasum":"6acf3954a61aca10fe42d316abe08e26ee520be6","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/test/test.js","shasum":"81b87bc710c4d0b8c0360a247ecb3817d71f3ffb","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/LICENSE","shasum":"73efe5bda3791d234730ab0dcc48eb619a2e0ec6","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/README.md","shasum":"113fddeaf3174b63954f81670dce9772fc252ad1","modified":1434936371000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/doc/wg-meetings/2015-01-30.md","shasum":"1fafe6e2e28a4404db90ae6dc867199b74468ca4","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/doc/stream.markdown","shasum":"34bb6baba8a25fd40136c519215124cbce7ec78b","modified":1450290518000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_duplex.js","shasum":"d4e2c0dbe893e97638262fb598f00472aa121cf0","modified":1448548407000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/duplex.js","shasum":"5ff8b0af1efbb8ed54ac1b3f57167447cb902344","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_passthrough.js","shasum":"51d9ab73b4265e9c011537e957c8f578bcf50d1e","modified":1448548407000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_transform.js","shasum":"fbeb8123c9557d11283543efd471e659a80a1f1e","modified":1448548407000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_readable.js","shasum":"71fec1e21d268617a18c91742d57f3f43ed7a14b","modified":1450290518000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_writable.js","shasum":"e6b7ebcfcbf1648eeda0b5060f388028b5eabf97","modified":1450290518000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/package.json","shasum":"dbca445196c2aabaf73ce38ffe03e01f64aa003a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/readable.js","shasum":"f68ae09e1cfcd9f75f8d43cb82724b3dee5d9251","modified":1434936362000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/transform.js","shasum":"2d31b50e657e5b03ce5abc5ce6b77187e8e876c2","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/passthrough.js","shasum":"ff1590a9a778dc9d8ed51064670d82426782ee6e","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/writable.js","shasum":"8a7bd86d1803614b9381a924ab9ef0a19fd70e6c","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/CONTRIBUTING.md","shasum":"a9fc87e51d92d75e09e391fed0b41d0916da1499","modified":1421769158000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/CHANGELOG.md","shasum":"142acbcd6d56904d1caa8775f56379738cb142b3","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1413995097000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/index.js","shasum":"6b96d838b3fae1c1d3fd963613b6465cd788e8c4","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/README.md","shasum":"612f6c04bd0aceb60c1d22dcf1a5de5a5cf91698","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/auth.js","shasum":"56bdda40a7df68f69c68cd256258017783e70d12","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/cookies.js","shasum":"0b2a641d706209af1f92176a507f382e06b44379","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/getProxyFromURI.js","shasum":"2e7c16e357f885401208174ad1f341b084965253","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/har.js","shasum":"a4b894d836e3bd947a5d8afffec04128bf934fe5","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/helpers.js","shasum":"c636e050b67bc00533adc7721e750f9520902917","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/multipart.js","shasum":"66acc47cab8b774688502be7752501e4a44d3cda","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/oauth.js","shasum":"8663a55221a216cc32d655f83086979ae9e666a9","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/querystring.js","shasum":"b78be4d88327f11499fbf86610d0612d803b1ff4","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/redirect.js","shasum":"08b710fe22cf8e28b2fecdcaaadb76923361299b","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/tunnel.js","shasum":"97336f00dd29c7fdad5550e9ae4daf57d587d034","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/package.json","shasum":"16dd8f8fe64ff97129a8ce1eb4fb49c67b6a8708","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999446000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/README.md","shasum":"fec5cb034f99088fb8ceec58b6de8ac5f5fc04e7","modified":1450896185000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/request.js","shasum":"baa695ff90bacd0d7e7b56fc0f83bac22360fd99","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/bin.js","shasum":"366b465d5a8637f94cea9366f505a25fc78c8a83","modified":1447980323000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/common.js","shasum":"2216c2b406550fa30ce86669313721bc5a72fbf8","modified":1452292176000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/README.md","shasum":"11402eb3ef9b4c244d19d3176a3c5bb8beb0898f","modified":1451528302000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/LICENSE","shasum":"515ec4469197395143dd4bfe9b1bc4e0d9b6b12a","modified":1412207810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/glob.js","shasum":"950021530921858aef80eefcf3296971350359d0","modified":1452292213000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/README.md","shasum":"cabcd4da1794331188da1f8f864ea1aa0ca68657","modified":1412207810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/inflight.js","shasum":"be7331b58b1433b0fa179d7a99ad9aca50f9d573","modified":1412318830000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1411081212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/package.json","shasum":"3a67744519b96b3f4b723f61123e1e651d1ebc98","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/README.md","shasum":"582d7139d169b0fc0b1014f2372a0aa26a52cfb8","modified":1411080623000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/test/basic.js","shasum":"be9621bb5c8a73660c26c049805cfdfd8adb5b3c","modified":1411082093000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/wrappy.js","shasum":"7d5c1c908664b3df4a9b72400a126652ba0dd905","modified":1411082022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/package.json","shasum":"7e94479f720ef8e13932ed5f05f7a2495556679c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/test.js","shasum":"b063404038229fb650d55794be860bd5f74ca1f3","modified":1412318795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/LICENSE","shasum":"3b0e8d58a362b1787ef3504fba4f593b22f3cee4","modified":1376950172000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/README.md","shasum":"f2f8d26f1cf5fb1e3a68aa225221b064f999fefb","modified":1368714278000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/inherits.js","shasum":"3146ed5f0e6053ad30398afdbd5a0d6a4133a4cb","modified":1368714177000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/inherits_browser.js","shasum":"7c13eacf36e79e5e7dd257d80ec25846e4df7eb3","modified":1368715198000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/package.json","shasum":"c3b5b5cb15b417c3fe558d6d5fdb42c27f5b1c7e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/test.js","shasum":"ba3f458c9b47c1bcd3fdf5dd9289b7aa0ae90b1c","modified":1368715388000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/README.md","shasum":"fb5bec4ab02467cdb76cdb552613ff0547402439","modified":1407793656000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/minimatch.js","shasum":"16b28bcabd1eca778c2176d6c49330396907411e","modified":1437616284000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/README.md","shasum":"3ed262742cc9e8e0db93c5f1d729127af1ffbe82","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/example.js","shasum":"8a259435e31e75ac76d3abcbefd225af7f41c185","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/index.js","shasum":"6d8c3796c04fb513fd0a1d1d66e59ef73f075f76","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/LICENSE.md","shasum":"09013c002fbdd686da2ec13c5a6d014f0a294ba9","modified":1445519600000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/index.js","shasum":"8c1cf0e709f8668e14b11c9086a50c70a0b0434e","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/README.md","shasum":"261a929745508f56c655d4ec306123bbfabdaa16","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/example.js","shasum":"27792bf4ffe9ce453c5d6896611d7647fd8f0e6b","modified":1445519548000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/Makefile","shasum":"98cb6ef36a74f052f3bad15c72f01d78e2d0ba8e","modified":1445519548000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/test/balanced.js","shasum":"706b6e79b2c13f0fed4d25706b63bbeec17c3600","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/package.json","shasum":"76bbc9bf9873f027deacfb2009568327b490958b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1391050985000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/README.markdown","shasum":"132e6e8fd1d19ec2422fdcde00840d8237e44094","modified":1354099276000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/example/map.js","shasum":"022a614b8d9f5ccb67b6ce1f478b1efd7aff298e","modified":1339124034000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/index.js","shasum":"a3063f014cc693b320dbd64de3243a79247c1e05","modified":1354939769000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/test/map.js","shasum":"162cce32c23628192cef64924a1ce768af399a4b","modified":1354099176000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/package.json","shasum":"a41434fcea8bb5fd17a8f84ea6270614f7cf1395","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/package.json","shasum":"94969ecccc823c5ce1a3b3dbc60b72334869039d","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/package.json","shasum":"d5f39bdfd9fb0125f920467adb1f9789f342c0e8","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/README.md","shasum":"f980f2811a57fb0732e9fa9bc43c9e8a2d6b0011","modified":1382596021000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1411081212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/README.md","shasum":"582d7139d169b0fc0b1014f2372a0aa26a52cfb8","modified":1411080623000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/package.json","shasum":"3882f0a070d5cfc4e42f2f14471afdc6c2fa8165","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/test/basic.js","shasum":"be9621bb5c8a73660c26c049805cfdfd8adb5b3c","modified":1411082093000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/wrappy.js","shasum":"7d5c1c908664b3df4a9b72400a126652ba0dd905","modified":1411082022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/once.js","shasum":"67e1e2cfe1a08a3cc9636382beab2e3cba80d9b6","modified":1448055900000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/package.json","shasum":"9be018eaeac9b9cdd84bf7086b334777fcb272f1","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/path-is-absolute/index.js","shasum":"71259da8cc05832088437dd2d385b7eee54eab71","modified":1424141850000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/path-is-absolute/package.json","shasum":"1aaa7c5d8a2b2a9fc1cd25b01297f92193b2ad43","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/path-is-absolute/readme.md","shasum":"bbe564e38bd40bd0f8c6f503d3064ebce4e6e87c","modified":1424141985000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/package.json","shasum":"d7d55326a725fd71ec8c3041b13c7e7fe49be01e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/sync.js","shasum":"6585718061bdd1f27bec952486252c6ee46ea35e","modified":1447632932000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/package.json","shasum":"1dbc68d383b1fcee00a3117009eb2c9916f026a6","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/rimraf.js","shasum":"89cc0eff35f036fb58f37f3dc629a653c7828545","modified":1450812580000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1430799955000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/README.md","shasum":"5ddc6177be9c6ba045bf2b9aec8f9ec6fa0f412d","modified":1447888625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/bin/semver","shasum":"95e0a5fdac7ea5824aff144c4416ca4a31b2ea6f","modified":1413420141000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/package.json","shasum":"c162bc8d0b07367e00ecb8de62aa27e35dc847cb","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/range.bnf","shasum":"f6b2d9d1f2da93eead6d53fe1e26719fb628aa53","modified":1447888625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/big-numbers.js","shasum":"872ac0774f3f343ccfd02ca284c07fa075cdce62","modified":1427475356000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/clean.js","shasum":"7a88bbd0388d1e2eede4a8dd9a9ba6210d7a39e9","modified":1412103158000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/semver.js","shasum":"f4dd45619f51cc8f7e60a3ba57c79c7b0bb87f48","modified":1447888625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/gtr.js","shasum":"7359784e6c5e19855b9e32a2ef93f4df3a6d9d17","modified":1412119384000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/index.js","shasum":"92ee3c5a9daaaff9be1033c9f25dd25600009db8","modified":1441991317000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/major-minor-patch.js","shasum":"c0f36d7d593f43792b7e0bea967ee138168300e6","modified":1423771405000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/ltr.js","shasum":"69d7e8e5a76df2dd0928837fb929093bafe2fd1f","modified":1432937866000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/LICENSE","shasum":"1583807686100eb3d8287b4e4627818f002aabaf","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/Makefile","shasum":"23079c0b043b0fd2f037fa6272e36d2562425c6d","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/README.md","shasum":"5b5b1348b73a5ba7293f5924937015c6b6350b6d","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/examples/offset.js","shasum":"5b78885677fd2f0eae4c2fb6c04c2d6e2f39bf49","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/examples/time.js","shasum":"9a7e69f5ee15afc381ce433cfa867bff405ca81d","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/index.js","shasum":"fbc929bb3b85e76c25fc52743d325d9f36fb3643","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/lib/index.js","shasum":"eeed7222493e633069fe267f915f7d13b12df094","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/package.json","shasum":"2aea6183b5c6cb9c65a56f7b05900a2af9fe00bb","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/test/index.js","shasum":"bc5aae767cff3fcd90a9a4b2d6ec0e6fea66988f","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/LICENSE","shasum":"10b8ac49ffb8f7cc8bdca9303209a1b3b2f3587d","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/README.md","shasum":"7c00acdc8e5bf0eca47a16aa33c8fa17202fa4bb","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/bin/sshpk-sign","shasum":"e187df199ed0e1c1d782f679b4742df047919854","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/bin/sshpk-conv","shasum":"fea08967162027695aed134d117056a5b789d188","modified":1452039039000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/bin/sshpk-verify","shasum":"a74dd8749820e0a9e9d334bd09665d6e3e4885f2","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/algs.js","shasum":"95cac832aaaa1d70d2a18bd42559a147dafbf11b","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/ed-compat.js","shasum":"a05999a5907f0027ba834b8ee4e819380a5108ea","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/errors.js","shasum":"94532c1445e72de790269b42a85741ac597c37e4","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/dhe.js","shasum":"de6f67e80ebce95a5272c75afcf05ea84ac45b3b","modified":1449005123000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/fingerprint.js","shasum":"1d34b04f4b70508da86cbc87a4a4c16206189930","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/auto.js","shasum":"ef4cc1499a3c7c3d96343b8edb2965c9630830a6","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/pem.js","shasum":"8288839f3bc23aa06ff4be127a0c7099511668b1","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/pkcs1.js","shasum":"155a8e28b24cb78b4d2a9cc88acdbd24f8296e97","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/pkcs8.js","shasum":"c9f73599e6447ef8cd55d670335b710bf9eb666e","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/ssh-private.js","shasum":"cba9761409b07d0d383aa58185d968613edbd5ff","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/rfc4253.js","shasum":"d268965c5c90a6da158ccc2f1dbd512e8868830c","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/ssh.js","shasum":"e05ce4d9981b2d0ccbbc6c5b28f1c4497adffe56","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/index.js","shasum":"1e6da7fba9b778c1791755723fb286b3d72d8b97","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/key.js","shasum":"fa8bce41330b09c7cda81be71b15772a57590eab","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/signature.js","shasum":"9ca03d95eded537101b3b7e9f0537f3cb5e0217b","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/ssh-buffer.js","shasum":"e0a58a30c41e44e08e098467384b56a33f7c3213","modified":1452039039000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/private-key.js","shasum":"a2d90ebfebf92206b78fba754ea43af97ac80841","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/utils.js","shasum":"9dcea6ff1a1026a57b235f4608fc08480efa05fb","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/man/man1/sshpk-conv.1","shasum":"a64a4769ca648e2047d255bf5237ce051f6af15a","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/man/man1/sshpk-sign.1","shasum":"742f5bb2986ad635eb081bad695573cd6826c96b","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/man/man1/sshpk-verify.1","shasum":"a5c70f82de5313ee103ba9bf3cfb9774465de370","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/string_decoder/LICENSE","shasum":"8344f8cf34d06153cd7ffc797c070e00d69eb442","modified":1390012773000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/package.json","shasum":"82ac0f1ce4c39c34eab979e2cd9bf61b0971ded6","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/string_decoder/README.md","shasum":"c8dac065c0a3043936a7c07ea1d698234c3ad159","modified":1390012773000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/string_decoder/index.js","shasum":"91f40da3177881cf70b87520444b755e1d9592ec","modified":1408767880000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/string_decoder/package.json","shasum":"673714ecd74d9412a84fedd3389ced2c08c78d2b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/LICENSE.txt","shasum":"e957fbece098eddf6df809165d5e73c2c1b2e10a","modified":1445815621000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/example.js","shasum":"17a98e07a319edf8fbeeea49d83515304922b1b4","modified":1361939998000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/README.md","shasum":"33c7843dec1919a17daad5a5ae2fb06d54018b38","modified":1358765250000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/package.json","shasum":"5b7749e3bb2edd54001ba4ea5f3d4df4da935e7c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/stringstream.js","shasum":"400fe756da898736fe0642a709c7f88e21fda352","modified":1363491475000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-ansi/index.js","shasum":"fa7b64a04c5989a1c9b78e83768b90384ac9abcc","modified":1403638286000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-ansi/package.json","shasum":"32aed466a4ee4061e6347a643eb18f59a73f433f","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-ansi/readme.md","shasum":"d3331d7da69d44abf7d6f3de7bcc279bb543a4f2","modified":1435683084000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-json-comments/cli.js","shasum":"e53037afc5bd51da35bcb99ffc711e740f741231","modified":1438391694000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-json-comments/package.json","shasum":"9bdcadd6252e3b73618e9033fab1b954f2ef9f1a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-json-comments/strip-json-comments.js","shasum":"bead8ba3eccaccb6dc64a76f3ff4552f4863ff50","modified":1438475808000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/supports-color/index.js","shasum":"669e4e82e32796eacb16a314bb3db270fb1d8572","modified":1435362323000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-json-comments/readme.md","shasum":"20404a3e5d9188c0e75354cb6600d82899458922","modified":1438391694000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/supports-color/package.json","shasum":"fd3efaf248a2e6dc1e2716a626de6c0311f027ec","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/supports-color/readme.md","shasum":"a0227e37af9ebe9e998782cf0a1eb75338d68f8e","modified":1435704929000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/README.md","shasum":"195deb7aea0e3da7c225cfad650c8bfb533e9d83","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/LICENSE","shasum":"c9f8d7fc9275e87bc85f85317ff575f5e0080cfa","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/examples/extracter.js","shasum":"5d8e2fc93644c2ca104784eeaf20ace3beaefbe2","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/examples/reader.js","shasum":"cfad58596007c29f55e81c3f2ef0cbeb36fe405d","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/examples/packer.js","shasum":"0ac22b0e315bab4f3f2868dfb042284f1e2ddcbe","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/buffer-entry.js","shasum":"b35d31f896a337c570f9c190eeb47ec9856363e5","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/entry-writer.js","shasum":"f9b75bb753e430b2230368ed08eb72593974cb01","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/entry.js","shasum":"c2bd4992c618912cd4f97a24ad2a08abb3cb1c2b","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/extended-header-writer.js","shasum":"b0de18dcef271e4155ce5ea54fe338d2ea30454f","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/extract.js","shasum":"e129e091bf774bd55306c83b236fc6a88439bad5","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/extended-header.js","shasum":"2c7ddebe2574be81d74108f93eeb82bba51b6ce5","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/global-header-writer.js","shasum":"290abcd884f307f01b5976f64513ada8123d369e","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/header.js","shasum":"df2b7d40396b1196c12ac98f5edd71dfc82f0784","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/pack.js","shasum":"a947d14daaeb9da1200effbbae8e1dd546bcafbb","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/parse.js","shasum":"2b111ca0c4d1cc9b3774de8b173c780992f06481","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/package.json","shasum":"e850e3af5598e0cc9ddfa7b0a73b587e738585b5","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/tar.js","shasum":"9c3fa4f5bbdad4447d71b65858c8a4fda101a04f","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/00-setup-fixtures.js","shasum":"478d75b7e2f9f7e1ff2f67de28bc200dfec2f954","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/cb-never-called-1.0.1.tgz","shasum":"905212798798b872f044c27b121a89f9dc6acc36","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/dir-normalization.js","shasum":"69f737fb6122594c3ece01ed496bf1993b8bb1aa","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/dir-normalization.tar","shasum":"a639e5983c0f19acf71640690805db289c615f0a","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/error-on-broken.js","shasum":"f25a0ce92dae3c121813eeb92c030a89f4c7ac25","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/extract-move.js","shasum":"671800188ee6ae088149cf3d397baba1ac7922bf","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/extract.js","shasum":"17def7f8737eb5c57e01c216cd8e0dca06ce5d7e","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/fixtures.tgz","shasum":"da2704914886317b2cb3d72f320ce260d9cab255","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/header.js","shasum":"12629717346691f14ad95ac6eee7e6ce77b54f12","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/pack-no-proprietary.js","shasum":"c36cb44365b2464abf06e7544e1c8c24aca83165","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/parse-discard.js","shasum":"8a179a875af81c7591861cdb84421fad4a4bbf8b","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/pack.js","shasum":"88dcf40d91cde99fd8fff61da7afa64bddca0125","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/parse.js","shasum":"6308611e1f2a1c0e5861e880a6933e3df3a166b5","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/zz-cleanup.js","shasum":"1974a7ab552f18e6b80a0b49e54d11ce79c48793","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/README.md","shasum":"30dd9eda71bb41dec335c4e13d4c48f65f53fbf5","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/LICENSE","shasum":"6efc4d4fea00a6f4372fb1fa47bad354ec89a2db","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/index.js","shasum":"f722f1ca905f54dbf17ac5f16ad8f8106613e1c6","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/packed.tar","shasum":"bd7369cf91552cf6f86bcec43cb21a2947711073","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/packed-file.txt","shasum":"62cdb7020ff920e5aa642c3d4066950dd1f01f4d","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/package.json","shasum":"6f8eda07c649e45a227ebf99f8b4013ac3926f1c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/packed.tar.gz","shasum":"c71cee8d77fefb1802845b3ef8c20aee21d200eb","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/to-pack/bar.txt","shasum":"bbe960a25ea311d21d40669e93df2003ba9b90a2","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/to-pack/foo.txt","shasum":"62cdb7020ff920e5aa642c3d4066950dd1f01f4d","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/index.js","shasum":"9848b6dd7f13f501ab720ebbcea70b9babd1466c","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/README.md","shasum":"72dd4e35da08b98d01237a80b788ae1aa189de87","modified":1444173105000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/memstore.js","shasum":"ecd6269063fe718d5b46d4127ff9d12065660a90","modified":1433972674000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/pathMatch.js","shasum":"3d403b8aad536db9e97eef4915eb01ef53405323","modified":1432572908000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/cookie.js","shasum":"30167425a77bef21e5eb390567ebef0f7532ca13","modified":1447378366000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/permuteDomain.js","shasum":"700be205b7d0d3b4c4f442b7dc1b3299d47bf55d","modified":1432572908000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/store.js","shasum":"bcce2205e56bb588b4e6cfcd48a34610a5eccf82","modified":1433972674000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/package.json","shasum":"9de2e085a4f4d0a7f9cf0c81c9e8bccfc184126c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tunnel-agent/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1446013763000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tunnel-agent/README.md","shasum":"fab5bff0eba532373f36d827d9775105d64ff719","modified":1446013763000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tunnel-agent/index.js","shasum":"e9320bd906e55558d9ba2569f76e92899da8744f","modified":1449585048000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tunnel-agent/package.json","shasum":"f0a5bbdee306f28655231099a02e30b558cc90d0","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/CHANGELOG.md","shasum":"068180ca96e0a5bf6807d8db5a8297b838b9a293","modified":1442499725000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/README.md","shasum":"040dc46c908d08a230dd2aec8c5dd876b3ef94af","modified":1452121326000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/nacl-fast.js","shasum":"687e1899d1b4c2d5fbf28469f8ddef1901fd6457","modified":1442499237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/nacl-fast.min.js","shasum":"f0a5e4246de9ad373cbbc7f74264603856debc68","modified":1442499742000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/nacl.js","shasum":"23a049b84d01bd8e938ac0daca4cfd38e5e48a0a","modified":1442503875000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/nacl.min.js","shasum":"e6984ca5a8a67f259e440598e21e98ab088dd2be","modified":1442499737000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/package.json","shasum":"89257022f715004265d4c9d3948bb021aa726905","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/LICENSE","shasum":"515ec4469197395143dd4bfe9b1bc4e0d9b6b12a","modified":1392662379000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/README.md","shasum":"01146a7d333f05da63e9341243280743fdf67dfd","modified":1330396426000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/get-uid-gid.js","shasum":"5a4786dc076636cab9a0741a162b7e02cdce52c6","modified":1374791681000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/package.json","shasum":"8ffaa1ea4693dcdc0fe3545cf32f6aa2942b4331","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/uid-number.js","shasum":"1b2adf78b8206f73ab665422f12a070b45b04803","modified":1392913385000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/History.md","shasum":"1fc5b9cf603a0b6abeb852b35bec607a411e5b9b","modified":1444243047000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/LICENSE","shasum":"cbde92577cb69b3b45dd33f8dc600732cf9e14cb","modified":1416945941000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/README.md","shasum":"8e590b24df7b037031e571b7b2b9600217b83ae0","modified":1416945941000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/browser.js","shasum":"335965112d6117af8926dce4497a1fb9fca022eb","modified":1444242970000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/package.json","shasum":"3af7e812f43db0165a06d139fff3388ef47f229e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/Makefile","shasum":"89b6506d72bcdd045b63921d0b754227f824c4f1","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/node.js","shasum":"26bb9fcabaf57f0bb50e5e026c13de394bc0c478","modified":1416945941000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/Makefile.targ","shasum":"f66e38899fc918aac830c478ae402c66d8793bc7","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/README.md","shasum":"94a2a13d3e722a3950176fa8ed55a1e7a7fd9d14","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/levels-werror.js","shasum":"e6d95f8c3af86fe246ef883197c28df6b4884eb6","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/levels-verror.js","shasum":"f8e7f3d3dbce6e61b53ea2a49a63111d156cf18e","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/varargs.js","shasum":"67c7570a5aa82ca71690b558a3f3d1d321a7508c","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/verror.js","shasum":"8513abb6a724947494c7513adfa27d76931488d6","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/jsl.node.conf","shasum":"c9a618ebefdabda69fcf47f17406c254f7f07f9f","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/werror.js","shasum":"10e842ef7ad2e6901398304c963c6ef1f44efcca","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/lib/verror.js","shasum":"def5538e73a39e2d14388970751c55e55f9b06fd","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/package.json","shasum":"e1247f2c86a2825ca65955ebc0e2977fe097f235","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/tests/tst.inherit.js","shasum":"298dabcdd9eff7081ee06a2b87e1118651190c9c","modified":1360175394000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/tests/tst.verror.js","shasum":"947c77e0a31ea025d156d9323d8a7283bf87871a","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/tests/tst.werror.js","shasum":"6b4007d450a8dfb9311ad86f44e3a7817fdeca53","modified":1360175420000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1411081212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/README.md","shasum":"582d7139d169b0fc0b1014f2372a0aa26a52cfb8","modified":1411080623000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/package.json","shasum":"554e6aaab4cbefe64798a253fd0f9dd183f7806e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/test/basic.js","shasum":"be9621bb5c8a73660c26c049805cfdfd8adb5b3c","modified":1411082093000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/wrappy.js","shasum":"7d5c1c908664b3df4a9b72400a126652ba0dd905","modified":1411082022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/LICENCE","shasum":"c563ca2a6d330b98c2ca9473a0299c4a689bf6b8","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/Makefile","shasum":"bf249732a0985e13f60552c8a9d6c3894c8fbb44","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/README.md","shasum":"d7d6f2f31071911d99fef109646867a0b325c8a3","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/immutable.js","shasum":"3c1de57f8d038e3ebc9e1ab278fe2f683866079c","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/mutable.js","shasum":"0b00bff9bc925c6c258ef4afb77e7f50640e6555","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/package.json","shasum":"4bde8092f527988c0be99a4795259f6049d8e642","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/test.js","shasum":"3b51ee9fb4c95c82be0bdde62dddb31f4c18e648","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/package.json","shasum":"9faf90ad349f139251acea54ab68df1d2b218c8e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/src/async.cc","shasum":"90f044c6bdc340273fabbc4aadcb00b9104f625a","modified":1438709307000},{"_id":"themes/yelee/node_modules/fsevents/src/locking.cc","shasum":"3e7b5e357f7ef32d3acf05b6a4cc22464c3f2d6f","modified":1426989724000},{"_id":"themes/yelee/node_modules/fsevents/src/methods.cc","shasum":"2ef3634f231b6f58b16274fdc440955e900df2a2","modified":1441032660000},{"_id":"themes/yelee/node_modules/fsevents/src/constants.cc","shasum":"294d4d3825481686170a948bd4e1bbb72871b2c3","modified":1441032660000},{"_id":"themes/yelee/node_modules/fsevents/src/storage.cc","shasum":"b12de056e310d86f344274d29fe180c0a7b24057","modified":1438709307000},{"_id":"themes/yelee/node_modules/fsevents/test/fsevents.js","shasum":"748cf86b247c2b6ed01e12fa4d168514d39c8ec9","modified":1426989724000},{"_id":"themes/yelee/node_modules/fsevents/src/thread.cc","shasum":"1ec0b3f3a05b464738bd093b5830081f3ed4349c","modified":1438709307000},{"_id":"themes/yelee/node_modules/fsevents/test/function.js","shasum":"3a20d642bcd6b9fa73f5ab538d1231f2141c2d2a","modified":1426989724000},{"_id":"themes/yelee/node_modules/generate-function/README.md","shasum":"d9255d9f65aeed364e61715ce43392b237dd10a7","modified":1406741356000},{"_id":"themes/yelee/node_modules/generate-function/example.js","shasum":"677d763dc7b82f9d69585388ff04094107481e4d","modified":1406741329000},{"_id":"themes/yelee/node_modules/generate-function/index.js","shasum":"2942e1c63f5a2013a70196110b4859029d09c48d","modified":1408639884000},{"_id":"themes/yelee/node_modules/generate-function/package.json","shasum":"94e03b6a1e1ad15021787f99cdf9e8d52f361d73","modified":1456469176000},{"_id":"themes/yelee/node_modules/generate-object-property/LICENSE","shasum":"a95ab3a4b0e4bd978897f09b3b430a449da20a08","modified":1427465395000},{"_id":"themes/yelee/node_modules/generate-function/test.js","shasum":"9bb3d8f4f20a97f1af0ef033d8dbe32693f9fb3a","modified":1406740670000},{"_id":"themes/yelee/node_modules/generate-object-property/index.js","shasum":"47eacac5534f58609e9f3ccc3a1c5879c20f9add","modified":1431893671000},{"_id":"themes/yelee/node_modules/generate-object-property/README.md","shasum":"e300730218d5bbf519653e5d19cfbd5857b78796","modified":1427465395000},{"_id":"themes/yelee/node_modules/generate-object-property/package.json","shasum":"6de1b1018217fa9bca2157ca45751e43a2e4100f","modified":1456469176000},{"_id":"themes/yelee/node_modules/generate-object-property/test.js","shasum":"b738cbfd474028baa30f5b003e228356d61c6a58","modified":1427465395000},{"_id":"themes/yelee/node_modules/glob-base/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1442599168000},{"_id":"themes/yelee/node_modules/glob-base/README.md","shasum":"83e0e13e0f9d9bed8b85f401fd22e6fd146fbc49","modified":1442599168000},{"_id":"themes/yelee/node_modules/glob-base/index.js","shasum":"2f15588ede319f3f78ecb5b8be65c80f8c1570cf","modified":1442930224000},{"_id":"themes/yelee/node_modules/glob-base/package.json","shasum":"1d39c9ca1bba71c6e15b3d2d44bf88aeefca4861","modified":1456469176000},{"_id":"themes/yelee/node_modules/glob-parent/LICENSE","shasum":"0f5ecc10b17b4e9208f2eee02966ad7b02d7ebf6","modified":1426989797000},{"_id":"themes/yelee/node_modules/glob-parent/README.md","shasum":"741eed87e0324d39712974e26c15ab63d819589c","modified":1442588290000},{"_id":"themes/yelee/node_modules/glob-parent/index.js","shasum":"bc23a7b46fa7a53ce69d21ea1eaaed6cee918e66","modified":1442588290000},{"_id":"themes/yelee/node_modules/glob-parent/package.json","shasum":"e8b68480cfb1ef8f56039be6b5e3a84ebcc395c2","modified":1456469176000},{"_id":"themes/yelee/node_modules/graceful-fs/README.md","shasum":"3ca4000bd861d5d95e8f861fc35d30a31b48677d","modified":1435601369000},{"_id":"themes/yelee/node_modules/graceful-fs/LICENSE","shasum":"6560c016f1644ce652d83d039d8ba9e64795fd49","modified":1435431095000},{"_id":"themes/yelee/node_modules/graceful-fs/fs.js","shasum":"8b8116f2fc0e6393cfed3b1076810ce5d02e0f01","modified":1435436586000},{"_id":"themes/yelee/node_modules/glob-parent/test.js","shasum":"b839f9516685893bc7b6229577e403f19ab6804f","modified":1442588290000},{"_id":"themes/yelee/node_modules/graceful-fs/graceful-fs.js","shasum":"48c86f6a8c193aa2ee2969f4b8fbf3c722ab97d8","modified":1454449073000},{"_id":"themes/yelee/node_modules/graceful-fs/legacy-streams.js","shasum":"f4a3583d4c3e8b0c407ab8406bdafb02b4055b7f","modified":1435436586000},{"_id":"themes/yelee/node_modules/graceful-fs/package.json","shasum":"f0a4f42d34e9b7dc344b0b0c10d152b70bab411c","modified":1456469176000},{"_id":"themes/yelee/node_modules/graceful-fs/polyfills.js","shasum":"57619610164625aeff0f6bbefc4008ac2d909b43","modified":1435436586000},{"_id":"themes/yelee/node_modules/graceful-readlink/LICENSE","shasum":"e9f4a5c36ecaa401588e457af96e7a85d53a98f0","modified":1423665419000},{"_id":"themes/yelee/node_modules/graceful-readlink/README.md","shasum":"a3e9fe045614e9dc2473a75cd9a7e9a6315043c9","modified":1423714083000},{"_id":"themes/yelee/node_modules/graceful-readlink/index.js","shasum":"3ecfe7f28912aa64161b8a6e4129c2b4fbcf50a0","modified":1423714095000},{"_id":"themes/yelee/node_modules/graceful-readlink/package.json","shasum":"7282ac602b37b8eaab3a5197930128dcc6da284a","modified":1456469176000},{"_id":"themes/yelee/node_modules/har-validator/LICENSE","shasum":"57fc502455231f1d10c4d2e67c261f0fc56bb17d","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/README.md","shasum":"43ef10fa75b3eb5369012ac32654ab907a79fb14","modified":1453244556000},{"_id":"themes/yelee/node_modules/har-validator/bin/har-validator","shasum":"702b45900cba1bd2ee74c4df1a5b51db0aeab0d7","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/async.js","shasum":"864f1787c6e6521d6495d337d7894d844dba24b6","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/error.js","shasum":"e08730fe6ce867fea7b32e8e7c6f9266b7fce592","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/index.js","shasum":"099021ac86914964d97afb35a9594e29c136bd0e","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/runner.js","shasum":"c0c49bddac013682d52bfff6065cceae67474fb2","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/cache.json","shasum":"24dd76d544e1c3c4be343e1a88e9ffad19705021","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/cacheEntry.json","shasum":"abb6d0b052b7f624f2e9efd5508c0614c4831b36","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/content.json","shasum":"896c9f34e3f38c5687255edcec798bedc98221a0","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/creator.json","shasum":"b0096cca448769435a9a1dfc8835bc560957fa97","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/cookie.json","shasum":"fc6b61b7f65667ebd270e2daadfc21e6b6aec452","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/entry.json","shasum":"161d6c3ab62b4fc423c5aa1d3ee1f67d98c008ca","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/har.json","shasum":"9b5debe33b9aa8c6055bb950ca5f19b1a1d82a42","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/index.js","shasum":"1bab9e9eb0c54be915c5303ee23cba4faaff0194","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/page.json","shasum":"d3ca0cf8dbcc30f33b91b8e8db85982b01cc5986","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/log.json","shasum":"9c72f7600e6fad2818459e76de0140ed9cb67422","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/pageTimings.json","shasum":"2661f2488c8bfaec68b30b4e9dee25089277e448","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/record.json","shasum":"23a2f8245bfef93b6b87696af51c1e9d4a0302df","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/postData.json","shasum":"123d9c6853b0e1a33147e2c04404aa33cf53a1ff","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/request.json","shasum":"ecdaba295ca01aeaa9f3f9779d1c94a051af5578","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/response.json","shasum":"e01a380eeb0b3c87c37f936ebf4888eae55dc3b1","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/timings.json","shasum":"4879ffeb448af68307aa46910bd2d3ac2fde9246","modified":1448373288000},{"_id":"themes/yelee/node_modules/has-ansi/index.js","shasum":"e7305f641b51be9dc463cdfc1e6b7afb8d03576e","modified":1402774137000},{"_id":"themes/yelee/node_modules/har-validator/package.json","shasum":"15261aa7ee9cf80fc21ae80710a80abf8403293a","modified":1456469177000},{"_id":"themes/yelee/node_modules/has-ansi/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/has-ansi/package.json","shasum":"9d2063153c889c1e37c13d2450accb41b7b0749d","modified":1456469176000},{"_id":"themes/yelee/node_modules/hawk/LICENSE","shasum":"23dc309f4a3614d359884bbc4a64d0ca20e41d68","modified":1453233148000},{"_id":"themes/yelee/node_modules/has-ansi/readme.md","shasum":"8f5dd99e33b07d2f4abaff2410728acca335ebfc","modified":1435680789000},{"_id":"themes/yelee/node_modules/hawk/bower.json","shasum":"0394736479292c80f177ca8d29263d9162d489b3","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/README.md","shasum":"332080064c5f554a1ad68a43ab48a68d2b49a1a4","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/component.json","shasum":"004be58031f7d1cbdbff8ca684b464df449cde8c","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/dist/client.js","shasum":"78e967c19bffde7606b06c595c41e83cde6c0d53","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/example/usage.js","shasum":"9c61ce5a46828c4c26b93e06141dbee8679c33a2","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/images/hawk.png","shasum":"756c85c7133e66dc5c119c47081f7f890d046f77","modified":1447968927000},{"_id":"themes/yelee/node_modules/hawk/lib/browser.js","shasum":"d4f08ffcfa0012fdb1a304d0fdda5586cf959af3","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/client.js","shasum":"781eb260241b46515df2f2f009969a772aa9dbcc","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/crypto.js","shasum":"06d65d9f325d49f11a0bf223dc683648f6fac977","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/index.js","shasum":"64f1cfdf834d8d679d020071124865b83a6cae72","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/package.json","shasum":"c7c6d3915a24909992014d08ca31094b2f10619a","modified":1456469177000},{"_id":"themes/yelee/node_modules/hawk/lib/server.js","shasum":"ecde371bb849aa221cd138ba993f5fb19fff160e","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/utils.js","shasum":"befb760ea6a14654fcce187b2b790f8292b404b2","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/browser.js","shasum":"fda1c8242cc48078540c30464da1d36a64d223a6","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/client.js","shasum":"fabb1388ee6f94ffe25870f2152d1a46c480dde3","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/index.js","shasum":"9e790c1104e148298687c0ed87fd48ee14a943a4","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/crypto.js","shasum":"222fe636eb910e343a0dd0db76224fac92a47647","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/readme.js","shasum":"e8743507f0a6c8d261e1d037e8aadc11cda3ac82","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/utils.js","shasum":"042ec97613b298b257e409d54eeca7a84ef3f84b","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/server.js","shasum":"45a0a16ecee59114ad2765a73af25443125278ba","modified":1453400406000},{"_id":"themes/yelee/node_modules/hexo-fs/LICENSE","shasum":"fecd013bdadc9ead2732027f06bf8fc19761efcb","modified":1417874762000},{"_id":"themes/yelee/node_modules/hawk/test/uri.js","shasum":"a7037450a234ee97c7bce23dc5c2f295fcddbd47","modified":1453400406000},{"_id":"themes/yelee/node_modules/hexo-fs/README.md","shasum":"e7b7392751106ec7779a4b46a3c073d6857f2058","modified":1423636479000},{"_id":"themes/yelee/node_modules/hexo-fs/lib/fs.js","shasum":"7c8223301082331d297ab9ea7d04e5dc3cd4667e","modified":1447232887000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/LICENSE","shasum":"914158dfad0452ceb55ea5e1822605ca05984bd9","modified":1455316199000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/README.md","shasum":"c61dc638bacfcdcd29172fff3c5d5c1f21431805","modified":1456437388000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/changelog.md","shasum":"bc6df7caea3b83fa361fa0a96c9b34c09465a93a","modified":1455316199000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/browser/bluebird.core.min.js","shasum":"754aa8aa94dcddb47048cb34e077e36de6c60a8e","modified":1456440962000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/any.js","shasum":"424dfe2a1afeaad729ca2be5ccfd443311716c41","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/async.js","shasum":"d41fd87ef2f5be6a2f8e09773a2029444a6c629f","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/assert.js","shasum":"429a0325a101244b087bf4e6c9df81220aac49d5","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/bind.js","shasum":"6ba64f83e985a1cb7dcf945490e4c280460ccb25","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/bluebird.js","shasum":"f68f4e491f49be5a5a3c5d04fafcd8abaf02fc2a","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/call_get.js","shasum":"5a2648cc4117f5ee47900e20bd533fb7e2fae1aa","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/cancel.js","shasum":"307b92b9575bc60d4f2c809b39690384cc324fa8","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/catch_filter.js","shasum":"cbdedec0db19fe2af76d5594ed8bf819000d7c79","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/context.js","shasum":"ea7eb1ab2c8231fa6bfa8446cf730736735396e0","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/direct_resolve.js","shasum":"470ca4d9a7e387ceceb383bc2640202f5fa6bda2","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/debuggability.js","shasum":"e1755c5125e759c7dc8f76027a5b667da3d3a257","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/each.js","shasum":"5118806b7208aa64317717392af157db042293c1","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/errors.js","shasum":"98deaaee17f36851937108257e028a7e237b3f5e","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/es5.js","shasum":"019c4e8b62031ea49aedc86dedd20318c6122698","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/filter.js","shasum":"a5f3aee4afbc67d372e5b4fbaeac047d0d9c779b","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/finally.js","shasum":"4b0cea33e6afb07456cd370ce0e9519314ff0c88","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/generators.js","shasum":"95307bef68bbb63ff93250e91c1588d40346a43d","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/join.js","shasum":"669e0cb20fbd709fad37ccd05c5d68594135113c","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/map.js","shasum":"b11d74d7802c0f2c5fa9684a3b511b90b69fd6bc","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/method.js","shasum":"02a5a493c2cf2045fbb20b2751381e4b4e29dbe8","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/nodeify.js","shasum":"ebd75c010fcf1c4f709f4b444e62b80cfcde2a0f","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/nodeback.js","shasum":"813463c70c195eec056cf2456a6fcf84929b3fd1","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/promise.js","shasum":"0027b108ee12a4ff04904733c2a993b0795e3712","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/promise_array.js","shasum":"0712bdda0498dfa8641c19c80c22b9472878f169","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/props.js","shasum":"af5fc480eacd6cce94f3239729689e0899f6cd5c","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/promisify.js","shasum":"3831be99120a57a3c07406f7012467f02346e92c","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/queue.js","shasum":"6c24c68f716db1a6c18b5cad2a951f0df6ee76ec","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/reduce.js","shasum":"5c1ef0e38b20065851c1784ed4f8a4c9699574cc","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/race.js","shasum":"5f5b5403be19793dec5658af27fe996173eb4990","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/schedule.js","shasum":"e293eabeddf9c8918cfe665cba59087425cf8d67","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/settle.js","shasum":"36f97c3732ae907af622fd4c859d29da1255fdfa","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/some.js","shasum":"b548ddd7eb6b35ae6e97d931e0a8ef6dd512b3b5","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/synchronous_inspection.js","shasum":"e9dc1fa033797719d2f4227d86f02806e0574755","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/thenables.js","shasum":"bd86eeab8746684e570f6522e9a2cf6b6f51fe52","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/timers.js","shasum":"6b92ddefb82954c53019788ed1489fb3c39e9e9f","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/using.js","shasum":"07e405aa38b78a94790baee548cc0adecc251431","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/package.json","shasum":"c48e97ba4a229a3ec5397ba67556f22b2ee6d09a","modified":1456469177000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/util.js","shasum":"e2c30b2ebac9f97f97cff01043b6c4bc59c0ddb8","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/package.json","shasum":"35955780d8afe3ffd2ece6db58de458d65744ccb","modified":1456469177000},{"_id":"themes/yelee/node_modules/hexo-math/Cakefile","shasum":"3f879c8fcf7467252d76418dcc24a79efd1db556","modified":1394135122000},{"_id":"themes/yelee/node_modules/hexo-math/README.md","shasum":"8950fbe3f80e91ac9fc7389f47df3613598b1c5b","modified":1440427872000},{"_id":"themes/yelee/node_modules/hexo-math/LICENSE","shasum":"f0c7cd0dcb6f00b98393878068ff3e6bf5f321f1","modified":1394135122000},{"_id":"themes/yelee/node_modules/hexo-math/asset/math-jax.ejs","shasum":"4444910acf318e60c3b8e26dcea5c0dc7f0f9b90","modified":1433148240000},{"_id":"themes/yelee/node_modules/hexo-math/bin/Layout.js","shasum":"45d2f065c3b8cff5140457fceaa313e7190f7748","modified":1440429286000},{"_id":"themes/yelee/node_modules/hexo-math/bin/Log.js","shasum":"787903bd188b271238a1d85883a2b14b36450097","modified":1440429286000},{"_id":"themes/yelee/node_modules/hexo-math/bin/index.js","shasum":"e9a3c9234e8303e884c6bf2b7c4a64c06a3b2559","modified":1440429286000},{"_id":"themes/yelee/node_modules/hexo-math/src/Layout.coffee","shasum":"559a8b94329bcadee5a6415fe6349873767a98ba","modified":1439971056000},{"_id":"themes/yelee/node_modules/hexo-math/package.json","shasum":"f4c0b5e9349c1f947b353c0381568436fc81f258","modified":1456469177000},{"_id":"themes/yelee/node_modules/hexo-math/src/index.coffee","shasum":"d4ca1a39613a431b285fbb76d27488c9e49bf826","modified":1440429156000},{"_id":"themes/yelee/node_modules/hexo-math/src/Log.coffee","shasum":"aa8bf17d420445dbc43de99cc4a2b4d0adead17b","modified":1430922677000},{"_id":"themes/yelee/node_modules/hexo-math/test-runner.js","shasum":"ff91e02d3bff4d87ebf66b7f1795b11fa30beb26","modified":1440426760000},{"_id":"themes/yelee/node_modules/hexo-math/tests/post.spec.coffee","shasum":"a198c8a2381ac138fbd24f9694f59b9de046e1b1","modified":1440428159000},{"_id":"themes/yelee/node_modules/hexo-util/LICENSE","shasum":"fecd013bdadc9ead2732027f06bf8fc19761efcb","modified":1417874762000},{"_id":"themes/yelee/node_modules/hexo-util/benchmark/fixtures/q3.js","shasum":"cf86d7a1ef538a16ab1820c73989ad9dca610ffd","modified":1423585554000},{"_id":"themes/yelee/node_modules/hexo-util/README.md","shasum":"505d7f1c0cb16d8fa29bc113113144b444e43ea3","modified":1432119513000},{"_id":"themes/yelee/node_modules/hexo-util/benchmark/highlight.js","shasum":"b4b315e793e28e8097c9d0c2dcc25d90f7fea54a","modified":1423904011000},{"_id":"themes/yelee/node_modules/hexo-util/lib/escape_diacritic.js","shasum":"77d53b732b1ce386d83796699b9c1a195e529bc2","modified":1423549044000},{"_id":"themes/yelee/node_modules/hexo-util/lib/escape_html.js","shasum":"b377e22a4cd4bc8275f3000436c1adcc37240c19","modified":1423549049000},{"_id":"themes/yelee/node_modules/hexo-util/lib/escape_regexp.js","shasum":"d4d9c2e8c8e44c1e3845d3ca1883417c242ec1d9","modified":1423549051000},{"_id":"themes/yelee/node_modules/hexo-util/lib/highlight.js","shasum":"91d4d979ad4a25064b1ccac38af6d45c61a906ee","modified":1432119401000},{"_id":"themes/yelee/node_modules/hexo-util/lib/index.js","shasum":"f856198dc384a34682848952ab2a061ee37b753c","modified":1423549059000},{"_id":"themes/yelee/node_modules/hexo-util/lib/pattern.js","shasum":"6419b61151392dd74792ca407b7b6e854a7148a2","modified":1423549062000},{"_id":"themes/yelee/node_modules/hexo-util/lib/html_tag.js","shasum":"72bec783fb4388baae36ab83f0e6f1b7739b88d1","modified":1423549056000},{"_id":"themes/yelee/node_modules/hexo-util/lib/permalink.js","shasum":"51a6d22296d90be2a220fec69af04e9a6dea63d0","modified":1423549065000},{"_id":"themes/yelee/node_modules/hexo-util/lib/slugize.js","shasum":"5ba8f5d602fe905f05d65fbdf061eb35f1af230c","modified":1423549067000},{"_id":"themes/yelee/node_modules/hexo-util/lib/spawn.js","shasum":"665bc5378078d6a9df6d9c17064b8e4e24eba0fc","modified":1423549071000},{"_id":"themes/yelee/node_modules/hexo-util/lib/strip_html.js","shasum":"242044008bd8843aabcf5dba3403973556bf98b4","modified":1423549074000},{"_id":"themes/yelee/node_modules/hexo-util/lib/truncate.js","shasum":"37670ea4ae572e7ea778f109bb99c834fcb6e956","modified":1423549077000},{"_id":"themes/yelee/node_modules/hexo-util/package.json","shasum":"e71f68b1ba0c35ada2050e9b19f85637ebff4e06","modified":1456469177000},{"_id":"themes/yelee/node_modules/hexo-util/lib/word_wrap.js","shasum":"07740bd92985955d803fd57d7a8f5ca0785cb08e","modified":1423549085000},{"_id":"themes/yelee/node_modules/highlight.js/LICENSE","shasum":"cd25196630fe891662ad77810f0f6dee5bc85ddc","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/README.md","shasum":"a21a3ba34192a449bb31bbe5d980772862781461","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/building-testing.rst","shasum":"435f8700ad54ebdc199fea29bd5709cb50c16356","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/api.rst","shasum":"7ea61691713b45ca2bba06ccd64d382d05296ccd","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/css-classes-reference.rst","shasum":"48e28ebc13f1a6e8133b639702d7db9b82f9a2e2","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/index.rst","shasum":"2634f417a4667f011707ac08978673d16fb542a0","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/language-guide.rst","shasum":"2b57bea2a18d717ec85be5d13f1a06bd1b015017","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/language-contribution.rst","shasum":"755e23f46a3ff5d2f59ebef2a6c6d7a5317bcc40","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/language-requests.rst","shasum":"d5de8f9936fa7450384696c4d2454e28c5102a6f","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/line-numbers.rst","shasum":"fb2b891ec631ba4e18214d467114bfb026e42c5c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/release-process.rst","shasum":"f33baf124c0d5fc87b00ba4d6a391ee8eff0900e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/reference.rst","shasum":"26601a5495ed9b60b51c3cb6f61f2c446ec2baf6","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/style-contribution.rst","shasum":"2ab5b5efd88e5a21ca2c0ded58cf0b08bfb5bf6c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/style-guide.rst","shasum":"5dca4c99eb8e3d8cc3f432ceb61a8753fa1816d0","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/lib/highlight.js","shasum":"56b2416a000b4696806d7fd0667f6de5745e8959","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/index.js","shasum":"d904c9ca4f10864333e0b982c8c8d0fb14fddec8","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/1c.js","shasum":"61ed1b122cb4b66e99860202228bbcecf86688d7","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/accesslog.js","shasum":"348d234c7253b8b308b74376fd92824d7788e745","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/apache.js","shasum":"e9a7f6d93f6df393afc765b13c0b79f7eb2fc510","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/actionscript.js","shasum":"110c1d6e8cd8923ecd88143573000e69458733e5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/applescript.js","shasum":"97602a06ab12d21be430434f1b7f5250044c4b77","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/armasm.js","shasum":"298a03e22aba431d02779773c83a71557ba98abc","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/asciidoc.js","shasum":"cb0ff2842460b98ba57cbfd74dd42f59a399e8c0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/aspectj.js","shasum":"fccca663ff2c4319aa293d27a4556ba58ee80dfa","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/autohotkey.js","shasum":"e2792bae0850add4bd0a791c51dfdb29893cf87c","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/avrasm.js","shasum":"c497417ec9e6e93bee385214459f1d685f053908","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/axapta.js","shasum":"33865e7e36e25f7f1f16fde557a7339a414fb8a4","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/bash.js","shasum":"c1192048ddaf6b0978e978ea61cf02aff0a728dc","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/brainfuck.js","shasum":"b6d4f266923cc946678a9060be5ad4a02a358db8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/cal.js","shasum":"7dcd3c1d4d54cc47af2bbe47dbdf37aff80c05a5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ceylon.js","shasum":"559a928a3f7d2035d5b0f1d202410cdb0c12902f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/capnproto.js","shasum":"ce268c5b7a8b2debd7098b42e3c6cb0cd2f8ff54","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/clojure-repl.js","shasum":"bbc6ed46a75eac8686e6a579f1c9f1591a1b5421","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/clojure.js","shasum":"4bcf48dd668a16921ad35595f3fd3f5f1a77c47f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/cmake.js","shasum":"deb21a64ead6c7a0a36c7223a8b53f2fa0098cc7","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/coffeescript.js","shasum":"bd4d69cd7e54c22fe436e9830eb9234714d99793","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/crmsh.js","shasum":"59ba1fc83bbf3ecda19c370c898876c95e241328","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/cpp.js","shasum":"dc653c01797481efa22544de479c183041857832","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/crystal.js","shasum":"859021318ae2178647d9f6d854b0d9d5f49a3049","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/cs.js","shasum":"f64640d2676e6fc9ae30a1f27cf6ae2a71c54240","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/css.js","shasum":"38b3998d0c7c4795909bee6243ef9c65291eae66","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/d.js","shasum":"2c5a4d98aec0b07d887c28840e513827ef5028a8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dart.js","shasum":"b35a466e43c9af8b9fbffad715b9fc87629e7772","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/delphi.js","shasum":"ac9c176dd6fe47fd2503ce5f2a9140fb2c29c68c","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/diff.js","shasum":"a07c33f6b720027207c6c6bf9415be4f1d8b3734","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/django.js","shasum":"4a06e057204142d6f4d15d9c1de68b7e4e2d5f1b","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dns.js","shasum":"8abb28525182765379c9bc5e23cad54aacee8ab1","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dockerfile.js","shasum":"84de7113a71f65d64542fb7ac87d7fd10575ab8a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dos.js","shasum":"e077531e84b108d337717cd5229875babd8d9179","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/elixir.js","shasum":"b3b87d8e1f58d63a5d370015bfde97128dd6376e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dust.js","shasum":"3aa6b1926630e7b1dae64d6eb4335dec33b6623d","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/elm.js","shasum":"a10e0d6325f971a3211c1ecf49cfb27c1b5a16e5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/erb.js","shasum":"3e67ebd4a54e38f7c4352facbb0114b914df773d","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/erlang-repl.js","shasum":"79351b773436b5d88df7d44c6b40dbd719b3dfc1","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/erlang.js","shasum":"390b9bb4f16f51c82590136e7daabfd11edfa719","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/fix.js","shasum":"daf48ba346f1a2c6c0142b657012d693c9049cf9","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/fortran.js","shasum":"bdc04f702c69d42e9a4eae0f7921121e5d89df80","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/fsharp.js","shasum":"c3867683caa6260630b1b9b1a0efbfde70105623","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/gcode.js","shasum":"493eef264eccfac19029018a977a6292bddf6b4a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/gams.js","shasum":"ff0e9a2b4d5a71068815f552d71fc6cf3c76cb3e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/gherkin.js","shasum":"8d7a8fdf59e3b84bea705e7d32a0ee5a17964bb7","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/glsl.js","shasum":"36eaed94ae9d5528d4f2465640631ba51f03f3b0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/golo.js","shasum":"5cfe2f157698bc3aef14a971a2ec5d6c358a2152","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/go.js","shasum":"53c4d96ed684d0be2c96b0e1fcd8ee5333a3c849","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/gradle.js","shasum":"3c7ba57616e77ac59b59810515bb6d2bebd6b6f2","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/groovy.js","shasum":"ececcffca70b607fa655c5eaf0a325bf41557415","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/haml.js","shasum":"ca0ca111914fd3367868f18c01584c45fb5080fe","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/haskell.js","shasum":"19f391daddbf9df034e37d794e99c2aed5b73d50","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/handlebars.js","shasum":"a52bb63a442431ea0f64dfabd8cab68b410bd418","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/haxe.js","shasum":"84c476ac55414cf65bba0e3a721656165cd9bf19","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/http.js","shasum":"15a54cce4dfa66b2349bd1a567ce1182bb640f1f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/inform7.js","shasum":"b444ec5da41d23677cbbcc7a0e0bba8928648d7a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ini.js","shasum":"47d65b98340583ad92a22223c0ce5996bb79abfd","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/irpf90.js","shasum":"dd659158f3bf4b0e03abe31c664510250c86c2c8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/javascript.js","shasum":"7aa13c3d6dadd71ec99ce7dd0085abd961fd622e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/java.js","shasum":"65b3369ffdf5c0a074e94e490ffc1457bdd667cb","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/json.js","shasum":"62840f0827d6fea20131011a4584ea6b2fa87dea","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/julia.js","shasum":"6bb9988c1305cca4556d929b29b0d01e63e6f434","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/kotlin.js","shasum":"8b8e5d05f33d8efec059d7f4ccd967b89a8cb3f2","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/lasso.js","shasum":"f98c0315b7faec99ec0f407afd5679d7248ec821","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/less.js","shasum":"79e6c082568d6ba68a81037a97c6c0fa9ecc5800","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/lisp.js","shasum":"bb2824da20ec714f51871423275272de8f1cabe1","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/livecodeserver.js","shasum":"aae639ae0dec89eac37a39bf9efefb82d0b8460e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/livescript.js","shasum":"4319c4b7b89395e3a5d60f3688516cb0cf6d2df4","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/lua.js","shasum":"be1579ced5e9cc73c3121d254fc8ef6632ab6f70","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/markdown.js","shasum":"dd48057b9379a0aa58db9d1d9e0cc584c089b073","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/makefile.js","shasum":"e2f27cb356b2f156671a97833b07743e9b73fad8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/matlab.js","shasum":"5dd585f626ef96d8cbd3880de1566e9ae365f504","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mercury.js","shasum":"ba475e04e5130742d71ab68d84664ead15ad70d2","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mel.js","shasum":"27451a7f902745f0e00e1d04b01e4001b33cd370","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mizar.js","shasum":"009acb028481b4f3ad95bec4d0386bb2184e7acf","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mojolicious.js","shasum":"50b50206e149b48884243aee3fdc076b2609e095","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/nginx.js","shasum":"51763551247a1739aebf870c966a4e60f2350529","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/monkey.js","shasum":"a751400f07f0e32cae87b4bb950be8b0583b9f82","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/nimrod.js","shasum":"18c05d58ad3e4c9646039f3be47d39df303e7525","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/nix.js","shasum":"871988dff9dc4141699e45e83e99e0a50b4cb645","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/nsis.js","shasum":"6f4f9e7f1de4fe7363ff1f1590ba1b7f5e68cc76","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/objectivec.js","shasum":"88e27614c98ad0252612395f6e205900dd4a796a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ocaml.js","shasum":"9978a9ccf4917ca17e6e184d18b4357c073c7516","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/openscad.js","shasum":"152775f97933e6285e698a91f1b5f40eebfb5a32","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/oxygene.js","shasum":"8dc402a5f274062c54eb76d1ee2d0ee0a3f4ba6e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/parser3.js","shasum":"6c38ffb148c96f192ff0313bdfa19ce7013ab819","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/perl.js","shasum":"bc50e37a87065629b75f24e3e571f274590b10b5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/pf.js","shasum":"244281f22d31b13c0c155565e9fcc0d9eec2428a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/php.js","shasum":"74c17503116bd6d4e8c2fe51fbd5bde8550a3676","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/powershell.js","shasum":"2173046b66c5755c5bda0bbdaa22e6a7f8b435f0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/processing.js","shasum":"6bd347bf6486e0337684462988bf5addb6e2bd6f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/profile.js","shasum":"685922148fc932ec49f8433a0d767def37701791","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/prolog.js","shasum":"69823127471c48ed600f73e0ba95f92222a802f0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/protobuf.js","shasum":"ab7e40c2f5b0b04f88fd5feceef1285684d24ff3","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/puppet.js","shasum":"7b0bb7da0f65611f5396fff63b0608ba82d2c33e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/python.js","shasum":"a884224794f97e69d62a0b6db6f0678e591cb197","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/r.js","shasum":"d4e0224fa019df6fbfdf32173aa6667748e9ea11","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/q.js","shasum":"116a650c0c30b52141693a208097e147bd9d1378","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/rib.js","shasum":"6ac4095f443d77730802603b2b9161a9bcf72100","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/roboconf.js","shasum":"a1ec38aedf65a53abfce1b04e0bbd54fda03c2e6","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/rsl.js","shasum":"68f867e17a901b743af1a624680ef26fdb8e9e93","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ruby.js","shasum":"570806e9162d6394fc6885c82f5c27bb11311799","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ruleslanguage.js","shasum":"ace3153b01664dc4b8a51f62c02018e73e2f2db4","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/rust.js","shasum":"1d6ad910ec4dcd1d27a86df7a41b80aecc86a6d5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/scala.js","shasum":"936f51637c364721051fc827927d95066878dad7","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/scheme.js","shasum":"68f01b2d3de0300cb28d4020ec8f6fd7df18d84b","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/scilab.js","shasum":"81221b510c6272236592413a235d9adee342ac1e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/scss.js","shasum":"fad120e03a9e8183392b60a9b56f0d3860cb47c0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/smali.js","shasum":"e3a841dfdb71cd73d08bc45e7959ef94166ed591","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/smalltalk.js","shasum":"9b24b75f9f8a17c11921fbcb7470d7149bc29db3","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/sml.js","shasum":"96dacca1adac072a435fa4e261a412b3ff2399e8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/sql.js","shasum":"d777cb844d1c5ed6663dd273dc1c99860ada750c","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/step21.js","shasum":"62b3588474ca51e89654c57d89284863998a209f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/sqf.js","shasum":"32517e6e810f6393b501143b88b55e5528c1efe6","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/stata.js","shasum":"b386d678ab5fd53248f031a073f8208987ac6101","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/swift.js","shasum":"c1b0ced507c0160443086e536100f47154260402","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/tcl.js","shasum":"6713527feb82802794d99a720db8c8df9bca6bb1","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/stylus.js","shasum":"b8b9e7fc5fca0db652d478014a1a115ee7df5aba","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/tex.js","shasum":"ff02877d2c34038a3653aaa1a713365a133e20b2","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/thrift.js","shasum":"47c807c1cc33a57f6f2ecb9e609f56ae74d5ef77","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/twig.js","shasum":"568c30ad66bd5b12e4b0bf1501e7ab06978c3861","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/tp.js","shasum":"6ce686b52e9b7584593272458b62f98e37656c82","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/typescript.js","shasum":"3fc36d7a97a6d6ead113554a8b00423aa0963240","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vala.js","shasum":"8611195b4bb27192592a459bfbd165de91e42c4b","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vbnet.js","shasum":"d7da8c3103102fe6ff90944fa0cfaea9d0fd9583","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vbscript-html.js","shasum":"af6c349a4ce7cabf9e94168aa75dfa350664a021","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vbscript.js","shasum":"29df599716e626e26b384e259f052c9a68fd29f0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/verilog.js","shasum":"3c41b6191d6cfa51106bbe26f4882136d64e2f0a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vhdl.js","shasum":"f0f69611e81cccb5b43fa96cf32ddb8641ea1382","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vim.js","shasum":"94df96a30f542f96941ca68461c8f6a1b0131153","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/xl.js","shasum":"6f756582e5a2e6d09bc604daf71b8982c4a3bd32","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/x86asm.js","shasum":"f3cd86bb639bcf19d6d2fbf35632255079ca9b97","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/xml.js","shasum":"ff60e90a9fe5a24b1e55e40d32412c0e238dd662","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/xquery.js","shasum":"8966fab0692d542b4a72da5e36d5b1705d650fad","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/zephir.js","shasum":"04302b6372d311ec54039b774f3cf2d207048141","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/package.json","shasum":"f675e3d6dd159d3ea83afc6fa68ddaa5d6539c16","modified":1456469177000},{"_id":"themes/yelee/node_modules/highlight.js/styles/agate.css","shasum":"0fbb15c9b6ad15cef60cfdf420e4df927a7ecab6","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/androidstudio.css","shasum":"7975515dd4054ab242d2bfc7a5930104aad176f2","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/arta.css","shasum":"df88af40b83fd852221e98c13fbb691a3a242fb5","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/ascetic.css","shasum":"382055a60d38dc255f78309365c6939cac024c05","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-cave.dark.css","shasum":"3e9337c582a6bbb5e9f8dbfaad38fb5052b91e76","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-cave.light.css","shasum":"d3a6bcbabb52e428ebfc4eb3e6c6f7af01010af1","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-dune.dark.css","shasum":"85c4c34762de07402969170bea730e93f5fbe430","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-dune.light.css","shasum":"b20449228e2b8e4722d7a915caa3a5c2a47de6bb","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-estuary.dark.css","shasum":"1313f34214c0a2ccf4cc0e3a5c1f180dd5682395","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-estuary.light.css","shasum":"0eaedb3476ae9f4666a1bfa88b5f3c961264dfe9","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-forest.dark.css","shasum":"03fa294773c1d23ffd3e46a3bd4f72710c874f9f","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-forest.light.css","shasum":"3f1119c02679eb5255a6d602cea509accb20bc73","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-heath.dark.css","shasum":"32f01466ea6ba09c12b313339d6422ccaf5f2d66","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-heath.light.css","shasum":"fd878219c09b2abc4ba5a1d860a5c2931885e8cc","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-lakeside.dark.css","shasum":"6fdba8847238f7ebeb691f389ce4820d01826ae4","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-lakeside.light.css","shasum":"40e617deac0510adc7244ece8fa5027a9ae07e85","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-plateau.dark.css","shasum":"53aaeb480a7cb6f66dd1854f2903f76ea192faae","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-plateau.light.css","shasum":"623a20e55598f0e4b2e3d7097fda8f2425d6e789","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-savanna.dark.css","shasum":"3a389804a3c012a0fb0861dd53a976399e2ca13a","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-savanna.light.css","shasum":"72b67963ff9f6e408de9649a06ff5d7c5ba1f86e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-seaside.dark.css","shasum":"f4caafcfc8f13a23c178db3a98aca49d08de2e17","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-seaside.light.css","shasum":"673e4c94b36edc212d35c922e5528f0e04b2b227","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-sulphurpool.dark.css","shasum":"e91ddfb4c112913210d8a4416bb38bc9d8ff131e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-sulphurpool.light.css","shasum":"357faf52514bc8a195b7a84f53b68c370e1e331b","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/brown_paper.css","shasum":"583d09e7059b84fe72d02b18a9023b46218500d9","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/codepen-embed.css","shasum":"c9e340a2e6a8c062722e1e33e7e841ed349f798c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/brown_papersq.png","shasum":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/color-brewer.css","shasum":"66b81f39fcb69febe03d3018d729efc6a2cbbcf1","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/dark.css","shasum":"0f893c1f0a37af0cac6f075a357e5de84747695e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/darkula.css","shasum":"db07929ea9403200c45532af9852aab061fbfb56","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/default.css","shasum":"fc74c98fbdb179d75e150b9cf0432f258285dc2e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/docco.css","shasum":"8db030f528692f94936e3ac710e08f521a49a0ec","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/far.css","shasum":"6f154bc013488a9deb4f4717bfa8e6b16bc93b41","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/foundation.css","shasum":"1545f3d63ada40db75b1b71f7ed3f90e57e1749c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/github-gist.css","shasum":"2800b036956e2e72d5f15c412de0a2537831e358","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/github.css","shasum":"d8b1aaf953f8e2052922c814eb4dcbbaa64e52e6","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/googlecode.css","shasum":"d0f57be2df19ff76a2e5c21ac0094b61fd643cc8","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/grayscale.css","shasum":"167d783f4875abfde4a8aaafa623f0529df62416","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/hopscotch.css","shasum":"52d16e503f2640e90aeae8ab80cc9c4163300bb8","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/hybrid.css","shasum":"17e57397682f2886905776366e771197076bb631","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/idea.css","shasum":"5fd4d8b1e0e3f8331fa55474f1c71eb2facdd51d","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/ir_black.css","shasum":"d38e60030d8e2b7a57b2ae815c956fc7bc0884d3","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/kimbie.dark.css","shasum":"1d9657ec0423d7814e59b66eafa831ac3b542750","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/kimbie.light.css","shasum":"8f16189114599e7a8eba8239d7fa4f013a3e519d","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/magula.css","shasum":"6e073517a27a7b7976105444f4070df047711b9b","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/mono-blue.css","shasum":"cf79468d71e4aa85e09eebaac95df9217d2e1d17","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/monokai.css","shasum":"2ec82c30dc528fbfadbe7183592c96818fb8f414","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/obsidian.css","shasum":"ec9ab28a0a3c759cec98fd5ceec4dd7a9e94e65b","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/monokai_sublime.css","shasum":"b9942180dc9885f97332380f7393301b9f831e5c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/paraiso.dark.css","shasum":"9fe2f1ce4a4ce18e7911af3479e38a54a4d83470","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/paraiso.light.css","shasum":"4b8898be4e40eeea6848c5a5b543466123f1a1d4","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/pojoaque.css","shasum":"ed3bc0de4cfa705cea98f4f07f277c4810a75527","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/pojoaque.jpg","shasum":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/railscasts.css","shasum":"0a5019aef66510fa5c158ec6d3003a92240d4424","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/rainbow.css","shasum":"e1bef38c83e64617b7d7b0badaab2f364e877dfa","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/school_book.css","shasum":"716c7c5eb4d2529cfe4ef4e74177dbfb21f1cc9b","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/school_book.png","shasum":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/solarized_dark.css","shasum":"a9d1a0974dd5e30303b788f5963ef99906676aa4","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/solarized_light.css","shasum":"d116ab023b13147b8a4a65fa794ddf5a751c1e6d","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/sunburst.css","shasum":"17fa1331860966d3c0cf0b4ba843e1f08ff72151","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow-night-blue.css","shasum":"75fb844eb5067597913e5bc70f7eb0549c3743bd","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow-night-bright.css","shasum":"1693875456b84c7181adf57ee7801b7605e757ce","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow-night-eighties.css","shasum":"a5f10d6219d89529e14b693096bff207bd571345","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow-night.css","shasum":"8da392d6043506f726a7b9e336f08230f3d039f9","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow.css","shasum":"6506530a73d3ca424b00f0abd8d906a39b87acb6","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/vs.css","shasum":"8bda9de8667c5a3c54283b9f9dcfbcd6984844c5","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/xcode.css","shasum":"8f6bd0eb192b17346eaca292776c61148e48a56f","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/zenburn.css","shasum":"8ceec984b4ac7cd39ec17ba6ee38cc3be04b06db","modified":1445295323000},{"_id":"themes/yelee/node_modules/hoek/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/LICENSE","shasum":"8798f9342afed7351f4aa459b96e4d1062c1dd89","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/README.md","shasum":"fa10590d10b5c14546e9124bf634621583235285","modified":1442428161000},{"_id":"themes/yelee/node_modules/hoek/lib/escape.js","shasum":"5ccf43b55ca0fbbc307a91235127af5601bd1187","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/images/hoek.png","shasum":"61fce871b635b32957b3c8c4e3c523eb2b2ac58f","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/package.json","shasum":"959e30c5f468cc3ec0aafb9aad717022cf02338e","modified":1456469177000},{"_id":"themes/yelee/node_modules/hoek/lib/index.js","shasum":"cfd3b556015082fc786d83c3e85ade81f448aafb","modified":1442857232000},{"_id":"themes/yelee/node_modules/hoek/test/escaper.js","shasum":"206886beb62a1d9d907b3838b20eb2037826167a","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/test/modules/test1.js","shasum":"32aceae0ba03e9116b108f41d74bea7d163bb56f","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/test/modules/test2.js","shasum":"31071671a8bdb854825c1cd90e29c30e9203b9fc","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/test/modules/test3.js","shasum":"4b695a807655475e7d89966828af28b7dee15ec5","modified":1441988248000},{"_id":"themes/yelee/node_modules/html-entities/index.js","shasum":"eb15b4fed782c7736a02ad14c97901080ab85f44","modified":1421057245000},{"_id":"themes/yelee/node_modules/html-entities/LICENSE","shasum":"f10f3a5e9b16a526fbf6abc4be406e6f07ecad93","modified":1408403203000},{"_id":"themes/yelee/node_modules/html-entities/README.md","shasum":"c7fac7bcffcb689b87be76cbd84c784b680eee76","modified":1440607446000},{"_id":"themes/yelee/node_modules/html-entities/lib/xml-entities.js","shasum":"f7a40c06be6bdb504476f1c864db0fb49898e8ee","modified":1444335075000},{"_id":"themes/yelee/node_modules/html-entities/package.json","shasum":"2b24d87aa482d9ade5a350b98270d37fb74d76f7","modified":1456469177000},{"_id":"themes/yelee/node_modules/html-entities/lib/html4-entities.js","shasum":"eb793b1708bd3305c33b0db77a15d04d330a6d95","modified":1444335075000},{"_id":"themes/yelee/node_modules/html-entities/lib/html5-entities.js","shasum":"ec6bfa76b6e8f84c13b96f7af392d212abe71e59","modified":1444335075000},{"_id":"themes/yelee/node_modules/http-signature/CHANGES.md","shasum":"59a2ab5cc1ac7f7691560038beb2349e628eeacc","modified":1453759387000},{"_id":"themes/yelee/node_modules/http-signature/LICENSE","shasum":"10b8ac49ffb8f7cc8bdca9303209a1b3b2f3587d","modified":1442600921000},{"_id":"themes/yelee/node_modules/http-signature/README.md","shasum":"5847fa2ec86a2ca744776acd5528fdfd6c3377fc","modified":1444857627000},{"_id":"themes/yelee/node_modules/http-signature/lib/index.js","shasum":"996c8efa1d7896034c980e498bec866824662d52","modified":1444858648000},{"_id":"themes/yelee/node_modules/http-signature/http_signing.md","shasum":"945eb22661d1c43e547371ac8d354a4b761eab09","modified":1453759268000},{"_id":"themes/yelee/node_modules/http-signature/lib/parser.js","shasum":"c47fbe5cb6f1be3c5a5d62f9085273f3403ff401","modified":1444858648000},{"_id":"themes/yelee/node_modules/http-signature/lib/signer.js","shasum":"5e312acbe0c57117dad754fa369a36dca4569bbd","modified":1453759272000},{"_id":"themes/yelee/node_modules/http-signature/lib/utils.js","shasum":"dce96d033869c424854178ae71991fe39b7c58b5","modified":1444858648000},{"_id":"themes/yelee/node_modules/http-signature/lib/verify.js","shasum":"f0603457d003b72d484d608b266566e771644438","modified":1447890069000},{"_id":"themes/yelee/node_modules/inherits/LICENSE","shasum":"3b0e8d58a362b1787ef3504fba4f593b22f3cee4","modified":1376950172000},{"_id":"themes/yelee/node_modules/http-signature/package.json","shasum":"90b8224f9f0f66686e13317e0b54cbffc692d1d3","modified":1456469177000},{"_id":"themes/yelee/node_modules/inherits/README.md","shasum":"f2f8d26f1cf5fb1e3a68aa225221b064f999fefb","modified":1368714278000},{"_id":"themes/yelee/node_modules/inherits/inherits.js","shasum":"3146ed5f0e6053ad30398afdbd5a0d6a4133a4cb","modified":1368714177000},{"_id":"themes/yelee/node_modules/inherits/package.json","shasum":"d54a3e589cf048c1d2ac452fc77ac7c1bb744ef6","modified":1456469176000},{"_id":"themes/yelee/node_modules/inherits/test.js","shasum":"ba3f458c9b47c1bcd3fdf5dd9289b7aa0ae90b1c","modified":1368715388000},{"_id":"themes/yelee/node_modules/inherits/inherits_browser.js","shasum":"7c13eacf36e79e5e7dd257d80ec25846e4df7eb3","modified":1368715198000},{"_id":"themes/yelee/node_modules/is-binary-path/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/is-binary-path/index.js","shasum":"575833c2dfcc83b547352b7432bac1e82bcbee35","modified":1432553532000},{"_id":"themes/yelee/node_modules/is-binary-path/package.json","shasum":"8769aeee92d4ef57cd415b696448cb8e962a9123","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-binary-path/readme.md","shasum":"1f6cadc94e211099cf21ef60f65fa27c4d765c26","modified":1428394458000},{"_id":"themes/yelee/node_modules/is-buffer/README.md","shasum":"911a274167f1829e07fa8486b876a8530b77613b","modified":1452660628000},{"_id":"themes/yelee/node_modules/is-buffer/LICENSE","shasum":"07d9563f6153658de124707787ff43f0458ab24a","modified":1442461838000},{"_id":"themes/yelee/node_modules/is-buffer/index.js","shasum":"a86311f370aef9487822f239d639daf0bad8ca1c","modified":1442462053000},{"_id":"themes/yelee/node_modules/is-buffer/package.json","shasum":"eb1809041904bdbbeda117f1cd79e4775e26eeee","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-buffer/test/basic.js","shasum":"350e8942b46982704e563ceb0583f7b253cfc849","modified":1442461838000},{"_id":"themes/yelee/node_modules/is-dotfile/LICENSE","shasum":"7e21c9f5aa0a1be61e943a935506095ea40bbafc","modified":1421900238000},{"_id":"themes/yelee/node_modules/is-dotfile/README.md","shasum":"a339a6cc02297687e3420dc751b47b9ae7d400a4","modified":1445317061000},{"_id":"themes/yelee/node_modules/is-dotfile/index.js","shasum":"c1a0fc16e3b10c1dbdfc77cb46097575bf7293e0","modified":1445316868000},{"_id":"themes/yelee/node_modules/is-dotfile/package.json","shasum":"e0d1280948b5cf1d9cc45ef90b14b2e4c462cb55","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-equal-shallow/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1424905916000},{"_id":"themes/yelee/node_modules/is-equal-shallow/README.md","shasum":"d3ec7e25f88751d4aa7536c376f32d97816038ec","modified":1435030788000},{"_id":"themes/yelee/node_modules/is-equal-shallow/index.js","shasum":"8ad23aff08c366907d80bf6f3d24a6c6a13d6a89","modified":1435030513000},{"_id":"themes/yelee/node_modules/is-equal-shallow/package.json","shasum":"bd1c3e27178353ac668602ee02809f3810911605","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-extendable/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1435545738000},{"_id":"themes/yelee/node_modules/is-extendable/README.md","shasum":"e47f712e0969fbe6cda9f18339d0fc7ad37cb62c","modified":1436050202000},{"_id":"themes/yelee/node_modules/is-extendable/index.js","shasum":"c38e98e8a299a93debd6e95bdcb56da06580a884","modified":1436049745000},{"_id":"themes/yelee/node_modules/is-extendable/package.json","shasum":"529193b5df16a77f0841f7b2fe1119b3635c0bad","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-extglob/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1424431146000},{"_id":"themes/yelee/node_modules/is-extglob/README.md","shasum":"70fccdf58f29062dbed00016f2790ae604a83d54","modified":1425675606000},{"_id":"themes/yelee/node_modules/is-extglob/index.js","shasum":"f2caa8e7efa77712cf91d0f349830dc563f1c9fa","modified":1425675072000},{"_id":"themes/yelee/node_modules/is-extglob/package.json","shasum":"83dc18b3488d15cac2fd358f58e99ee66ce0a506","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-glob/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1424431146000},{"_id":"themes/yelee/node_modules/is-glob/README.md","shasum":"c63677aa8188743e55fa3988d143b031e08ade12","modified":1443760455000},{"_id":"themes/yelee/node_modules/is-glob/index.js","shasum":"b3dcfb08edc51fa11b2f6a028e432f7f81c67ca8","modified":1443759204000},{"_id":"themes/yelee/node_modules/is-glob/package.json","shasum":"dd1de889eacf686009f7a93cdcbf1295c320b6a5","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-my-json-valid/LICENSE","shasum":"a95ab3a4b0e4bd978897f09b3b430a449da20a08","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/README.md","shasum":"f2703730d556b550b13e00597a8ccb2f43eb1941","modified":1456180252000},{"_id":"themes/yelee/node_modules/is-my-json-valid/formats.js","shasum":"2d511859d3d654f3bf604a47e13f98e9b1bc305c","modified":1453067668000},{"_id":"themes/yelee/node_modules/is-my-json-valid/example.js","shasum":"cee9de4194e0c4ba372b5678983d6d701385d355","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/index.js","shasum":"6c62fa78f5375a9db47f9006b883e049ebe700bb","modified":1456180252000},{"_id":"themes/yelee/node_modules/is-my-json-valid/package.json","shasum":"4ce9e0fe4100b3fe3956f8391ef3e7b271e2b382","modified":1456469177000},{"_id":"themes/yelee/node_modules/is-my-json-valid/require.js","shasum":"24081d202d91cdd0b4910b57dfd434ab41543b07","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/fixtures/cosmic.js","shasum":"94a2af635cae7d0491fce9767a67d06f651e0244","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/additionalItems.json","shasum":"75644b309367675ce21d8b35b9baee049a58e159","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/additionalProperties.json","shasum":"34478026a586b1ff8b96dbe54efdf7515099da7d","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/allOf.json","shasum":"e98aea1d36d932870561f0c32c32fc5858f251f9","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/bignum.json","shasum":"32b70fb2c2156c979702eec5c18a86c1fe6d0bd7","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/anyOf.json","shasum":"8081feb305d328878b37a7cc3b296eb5544c239d","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/default.json","shasum":"17c051cc94a9fb40ad627b04a41d7dce9150e3b5","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/definitions.json","shasum":"0963ac4f014a0faf6ad37554c9af03f63dad9b02","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/dependencies.json","shasum":"d239f1bb8cfffb7487335c73e02c6cda10d4ef5b","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/enum.json","shasum":"4b96cc24245950f9fad0916113a5056d9f51c2e5","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/format.json","shasum":"3d60bdb3fbb2d47da991e99e51bb9ab241703c44","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/items.json","shasum":"873828cf8ad5d2701022650e99367cb0a89624b0","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/maxItems.json","shasum":"580cdb7c89cd07b45f3fdadb2279bb13108b79b4","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/maxProperties.json","shasum":"1703d6ef976a74eae8ea6cd21c131853c6ca5f6c","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/maximum.json","shasum":"c205edb4c5bd171c9e1f4955f5cc3b94ca78cb0c","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/minItems.json","shasum":"176fedc074768c6ec5c7ceb979f23a6a4bd0be58","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/maxLength.json","shasum":"3f6273e86c31605607384559df5ee9c92201c5bc","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/minLength.json","shasum":"99eb79755bf43df641900a01e8ac9ff5becec8d5","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/minimum.json","shasum":"1a849968c80db05a9ad0a92481edd93dee567804","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/minProperties.json","shasum":"b61b2829899d8a5f6bbc8bde2b694b69bb35d38a","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/multipleOf.json","shasum":"e8c9555c09db80f5398d2d73840358a0aec80529","modified":1456180252000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/not.json","shasum":"5b9567e8409e28b256f3704ca83447f0d0abb707","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/nullAndFormat.json","shasum":"8682b818844ecab9f69642d3f121eea59877f6e0","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/nullAndObject.json","shasum":"dc0ff1a9b5740271c3e92436a697a50ee8168046","modified":1437940209000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/oneOf.json","shasum":"6772cacb066e5458a7fca9a47cfee27b56110d6b","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/pattern.json","shasum":"5b09d287b8d5170ba4442429bf5309eae1f3cec8","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/patternProperties.json","shasum":"e0080348b213f1d004af7d5c43c2f3f29375224b","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/properties.json","shasum":"1aacdf890a9b844c7275f6ad2f3acc2f9100219c","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/ref.json","shasum":"a9dd881b0a9d5272897be0cc8550c5a64841fc8c","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/refRemote.json","shasum":"ef0c43623cad9a3ceb7b407272062ca55c1c9c7e","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/required.json","shasum":"35b980ec46ea56c7c7c38afc63c84a863d4b3132","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/type.json","shasum":"e2e4371fb68d01ecbc7a5022348c0ffd05d1fd9b","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/uniqueItems.json","shasum":"8c9909ffd2abf8f625f81c18a43c789efa369e34","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema.js","shasum":"c5ef8e3da495a6ca1c7cc9dd0cb8d8c415dcc245","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/misc.js","shasum":"b87118a5e1a59dad1e6c7cc97d3f21f1791affcc","modified":1455779973000},{"_id":"themes/yelee/node_modules/is-number/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1425580476000},{"_id":"themes/yelee/node_modules/is-number/README.md","shasum":"6a27818480a55a97b4c590b0ddd1827b6ff836d9","modified":1430553159000},{"_id":"themes/yelee/node_modules/is-number/index.js","shasum":"be43df441aa52b7b5827318a5bb9e17601c1f616","modified":1436588444000},{"_id":"themes/yelee/node_modules/is-number/package.json","shasum":"21ff748dd46e233faf49b1f9d135f6b4754bdb89","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-primitive/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1426564547000},{"_id":"themes/yelee/node_modules/is-primitive/index.js","shasum":"4d12a2283734792d84b1b92555671f52adc55a99","modified":1426564547000},{"_id":"themes/yelee/node_modules/is-primitive/README.md","shasum":"13fde70833e452345cce4c999e73872f5ce83d49","modified":1426564595000},{"_id":"themes/yelee/node_modules/is-primitive/package.json","shasum":"46d6b0e59785382c96ebb57e288333f179c176eb","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-property/LICENSE","shasum":"50fe55ab192fa4860c14bd57bcec5d090904eb97","modified":1374156563000},{"_id":"themes/yelee/node_modules/is-property/package.json","shasum":"136bea02edca4fc85fd82c2b5fede58e322a8023","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-property/is-property.js","shasum":"d09cd64e2bcead412c4d3be1d95f76fe1e315794","modified":1419518893000},{"_id":"themes/yelee/node_modules/is-property/README.md","shasum":"dc4d53b5d6c1d1387fd41fb6bf3597d9642540a4","modified":1374156267000},{"_id":"themes/yelee/node_modules/is-typedarray/LICENSE.md","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1401649683000},{"_id":"themes/yelee/node_modules/is-typedarray/index.js","shasum":"b7ff45ac41fdcb4bb75dd771d6cb9bfbd129e56d","modified":1431824601000},{"_id":"themes/yelee/node_modules/is-typedarray/README.md","shasum":"8f33b0dd445cfa2ab6712dee34df082f480a5a76","modified":1401649785000},{"_id":"themes/yelee/node_modules/is-typedarray/package.json","shasum":"e97ade9544af40c12a83bbb7a8ed61bad8a75789","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-typedarray/test.js","shasum":"c3aa563061f8d086aaf066b389b0e811444e3913","modified":1401649839000},{"_id":"themes/yelee/node_modules/isarray/README.md","shasum":"34470c173ddf6ddfbf9683cf343e83cea1629049","modified":1369676403000},{"_id":"themes/yelee/node_modules/isarray/build/build.js","shasum":"711567b86256a86ed22bd637c35786d13e0f73b3","modified":1369676297000},{"_id":"themes/yelee/node_modules/isarray/component.json","shasum":"88615028e91d7872104932a02b78a75f04df8465","modified":1369676355000},{"_id":"themes/yelee/node_modules/isarray/index.js","shasum":"eec5f3c0d16211678cfc7c2d9c18bc4718adf700","modified":1369249661000},{"_id":"themes/yelee/node_modules/isarray/package.json","shasum":"eb073ddbdb53a73077ca541219c9f9420e5c1b32","modified":1456469176000},{"_id":"themes/yelee/node_modules/isobject/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1429583250000},{"_id":"themes/yelee/node_modules/isobject/README.md","shasum":"f61432497d224c56a4c6fc84705e0cdedd3a3622","modified":1437438290000},{"_id":"themes/yelee/node_modules/isobject/index.js","shasum":"1ed5712a3b7e14f4074e28fe1d668626324ad069","modified":1437437998000},{"_id":"themes/yelee/node_modules/isobject/package.json","shasum":"09447aceec3b0aa4fbedba297815e21751ea18eb","modified":1456469176000},{"_id":"themes/yelee/node_modules/isstream/LICENSE.md","shasum":"3fc5bd6825a9d8fd53c0cd8de0bd16d1c1a7f37a","modified":1425687271000},{"_id":"themes/yelee/node_modules/isstream/README.md","shasum":"0563c8dd8178c335de8d882a14c0408ba179789b","modified":1425687291000},{"_id":"themes/yelee/node_modules/isstream/isstream.js","shasum":"db3d8708d100bdb66fd33e1eeb6d2b232016934b","modified":1396827239000},{"_id":"themes/yelee/node_modules/isstream/package.json","shasum":"0a0ca694ab7d4bf99721587a6a5021a435860936","modified":1456469177000},{"_id":"themes/yelee/node_modules/isstream/test.js","shasum":"3c3c171729a3738bd73b12d311265c7fcfb2a9fa","modified":1396831146000},{"_id":"themes/yelee/node_modules/jodid25519/AUTHORS.md","shasum":"cc3f12565134b1da757450b40b5f3fa80c7fc132","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/LICENSE","shasum":"4fe6ded38ad123523792104dcf60f28badd905f2","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/README.md","shasum":"3a28ce7b2aa6b6343508cfe28eadec9733fd14e7","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/almond.0","shasum":"216d893df0f002babc23e63d4c98005db5e8104e","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/almond.1","shasum":"157b7bc54f90865debe5b1f817a8c1155b580dd8","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/index.js","shasum":"29e0b96fa095b35ecac9be6c2afde6c9b769e73b","modified":1445885964000},{"_id":"themes/yelee/node_modules/jodid25519/jsdoc.json","shasum":"5a3782a2b7072783e0e5aa3b74d9c87c423818dc","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/lib/core.js","shasum":"55894ff0a71a08de470029f7689b3967c2ce9233","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/lib/dh.js","shasum":"e9a0561e419e956f953570d7121e65c84fa72488","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/lib/curve255.js","shasum":"fdc3f9501dbda3945b6478cecaab0b0e1ecd2d63","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/lib/eddsa.js","shasum":"bacec5f12e7d5303cee9b0493e22b3743a19ef1e","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/lib/utils.js","shasum":"5b4e9a60c9f4758bf714e52f9064df0d33fd019a","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/package.json","shasum":"6986102cbfeeed407e556c6c0ec47ab869524057","modified":1456469177000},{"_id":"themes/yelee/node_modules/jsbn/LICENSE","shasum":"d9b1b910dfea689402ffdb75f5467ec263f8480d","modified":1446141666000},{"_id":"themes/yelee/node_modules/jsbn/README.md","shasum":"6db673c03e15b4e75f95e25ba87177799511ad0c","modified":1446141602000},{"_id":"themes/yelee/node_modules/jsbn/example.html","shasum":"ec1f94b093e0f1457642f8647294be35d4af033f","modified":1446141602000},{"_id":"themes/yelee/node_modules/jsbn/example.js","shasum":"ba7f33b1196eca41a007177372fe237ac7a85c1b","modified":1446141602000},{"_id":"themes/yelee/node_modules/jsbn/package.json","shasum":"c532faec2be1f993411334173fb67ade2707d1f7","modified":1456469176000},{"_id":"themes/yelee/node_modules/jsbn/index.js","shasum":"f53a89111c54f03ab39eab110c924b560b877051","modified":1446141602000},{"_id":"themes/yelee/node_modules/json-schema/README.md","shasum":"9065e9ab354ce910706716a42584222674fe1470","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-00/hyper-schema","shasum":"a5972bcc99abc4936ff350f116a69390f8ac99e8","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-00/json-ref","shasum":"b5f7e93c3edc2eb501e913441ddfdeef0c04386a","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-00/links","shasum":"490c91fb104a16a76290377797a5411d21379614","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-00/schema","shasum":"253c4fcfccaf49023c10a1a92d81cc3d21344e8a","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-01/hyper-schema","shasum":"51802f7884c813fe2a002776aa97a440c7442d9a","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-01/links","shasum":"09b2131c15d754a61a1baf1158a8e6c73644287f","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-01/json-ref","shasum":"2132a5a9319f8bf190040b49150e005e0916ed22","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-01/schema","shasum":"10942d74811e1e16425e6219b0ba808b493321ab","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-02/hyper-schema","shasum":"117eb70efaa120edeb97caa6ca7e53eae8f761e2","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-02/json-ref","shasum":"31b76b211e24e56b0ff5ae3ba739835039cd96b8","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-02/links","shasum":"f8a835ea08959ceca9682cf1c30df6d5cf9ff033","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-02/schema","shasum":"ba84a3e7e9332328db986a1123084f2a6dba57f7","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/address","shasum":"b6e70440f5faf725b978da4e92f6f39100377674","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/card","shasum":"c1405e471f81bbb4eea94c2ef85fa07195a8ad80","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/calendar","shasum":"3e53cb296ba1799f39c5a00bc4627fa10e26e165","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/interfaces","shasum":"9666b12a3d05e526886aa2650f0439d32b25f0dd","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/geo","shasum":"74d8c66f1ba74c6cd330b8acd5948efb5f2879e4","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/hyper-schema","shasum":"552aaa9921cbeb19c2c9b485e64965f7a98e22fc","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/json-ref","shasum":"9f121cedcda14cbdd55e2fd80a96e289d9a1f2f9","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/schema","shasum":"4b500e66b7c4a36bc4d3ff6da089d6228c54f94c","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/links","shasum":"5f1601142843a6028beb35cef8b851413a4dfa91","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-04/hyper-schema","shasum":"362194bf4c6690db17b848c1a796ef747bf7a6c1","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-04/links","shasum":"92cd269ccdfe3f3bc673205133cb9940afa465c4","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-04/schema","shasum":"7a6839ef21cf49fd6bdc687be7dbfbb92c97ac7c","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-zyp-json-schema-03.xml","shasum":"da15453583b019a448fae4b857fe29a583bc1a38","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/lib/links.js","shasum":"9d0d0289e4dd2840778b88834f17bad854b013b5","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-zyp-json-schema-04.xml","shasum":"02845f4b0406bffb06ff5cb01eca43f492db6901","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/package.json","shasum":"71e736deec85d05928a37b20010f47a53534eec8","modified":1456469177000},{"_id":"themes/yelee/node_modules/json-schema/lib/validate.js","shasum":"97195ad80d4a217293a8bc240ee44c0c89a7fe79","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/test/tests.js","shasum":"f3f322d2cec777f57df41b071818a05e97d35f2a","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-stringify-safe/CHANGELOG.md","shasum":"d9b3407ce2eef8d2dadc6b2839a8b16b783eef47","modified":1431999690000},{"_id":"themes/yelee/node_modules/json-stringify-safe/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999719000},{"_id":"themes/yelee/node_modules/json-stringify-safe/Makefile","shasum":"589819e00a30573f50fa4a11ddb22fb45b372a65","modified":1431999690000},{"_id":"themes/yelee/node_modules/json-stringify-safe/README.md","shasum":"a2972dd72d8ec7c8b1f229f7732f911ed721dbca","modified":1431999690000},{"_id":"themes/yelee/node_modules/json-stringify-safe/package.json","shasum":"b7e784286baf1313c09f85a8f8fe44faab8adc40","modified":1456469177000},{"_id":"themes/yelee/node_modules/json-stringify-safe/test/mocha.opts","shasum":"98216b4fbc2e0c1c17ee946b02272a26fcc1f4c1","modified":1431999690000},{"_id":"themes/yelee/node_modules/json-stringify-safe/stringify.js","shasum":"b36a3a8d0f794fae13dc8e1c93bd4a8cae311bf2","modified":1431999708000},{"_id":"themes/yelee/node_modules/json-stringify-safe/test/stringify_test.js","shasum":"4760401b04513ae7eb79fff0e1239a9947a8af78","modified":1431999690000},{"_id":"themes/yelee/node_modules/jsonpointer/README.md","shasum":"7b05e3bfb84beb3a5e7607912fc47ccc8d2b1e33","modified":1430458330000},{"_id":"themes/yelee/node_modules/jsonpointer/jsonpointer.js","shasum":"cd510cab1d95a07efc733965dd2533a3fad50e51","modified":1432622187000},{"_id":"themes/yelee/node_modules/jsonpointer/package.json","shasum":"6627fd6465be544b3847d344d3383564f1e672db","modified":1456469176000},{"_id":"themes/yelee/node_modules/jsonpointer/test.js","shasum":"ac5befd353f47b170e2efececbf1ef6d82bc6ade","modified":1432622760000},{"_id":"themes/yelee/node_modules/jsprim/CHANGES.md","shasum":"56da97f41e22a449194235ad13ee30a2f4758956","modified":1444953672000},{"_id":"themes/yelee/node_modules/jsprim/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1416249172000},{"_id":"themes/yelee/node_modules/jsprim/README.md","shasum":"78fa58f9e0acaee38db00e4ff234394308cef93d","modified":1444856653000},{"_id":"themes/yelee/node_modules/jsprim/lib/jsprim.js","shasum":"b6fb3f70d3ba7ce276c625e0dd5cb7dfb0af67d1","modified":1444953536000},{"_id":"themes/yelee/node_modules/jsprim/package.json","shasum":"51dd29119df6d8279e7b048f2e55c0ab2ae84870","modified":1456469176000},{"_id":"themes/yelee/node_modules/kind-of/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1447758397000},{"_id":"themes/yelee/node_modules/kind-of/README.md","shasum":"869daa808413a39c57575817281556cf63495c58","modified":1447759311000},{"_id":"themes/yelee/node_modules/kind-of/package.json","shasum":"719473690b527f8408cb021be97cbe48d30c0203","modified":1456469176000},{"_id":"themes/yelee/node_modules/lru-cache/CONTRIBUTORS","shasum":"6a6e5148568ff15b4756ee478f0da581ea97fc01","modified":1385053079000},{"_id":"themes/yelee/node_modules/kind-of/index.js","shasum":"ad67453f6b331b33d38b5b0e5c7c8516bc57b5da","modified":1447158387000},{"_id":"themes/yelee/node_modules/lru-cache/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999527000},{"_id":"themes/yelee/node_modules/lru-cache/README.md","shasum":"129fd032ba2ac7580e57e0d9988a4d06f1b344fd","modified":1448474798000},{"_id":"themes/yelee/node_modules/lru-cache/package.json","shasum":"f90819e195b947edc30d93c5be440d8309afe8d2","modified":1456469177000},{"_id":"themes/yelee/node_modules/lru-cache/lib/lru-cache.js","shasum":"d4091806568fef3089f4522f09d5976d91912dd4","modified":1448475000000},{"_id":"themes/yelee/node_modules/lru-cache/test/basic.js","shasum":"caffd5539b398fb1f369ed259c14dc4d00eda244","modified":1448474452000},{"_id":"themes/yelee/node_modules/lru-cache/test/foreach.js","shasum":"5493ce987892f9c740837c36acd5240d9cf93644","modified":1448413217000},{"_id":"themes/yelee/node_modules/lru-cache/test/memory-leak.js","shasum":"5b5690f4e32c4d2fc501e7f408fdcfd25f8b4e3a","modified":1435688444000},{"_id":"themes/yelee/node_modules/lru-cache/test/serialize.js","shasum":"6383a06c3f56cce6eb364b66f2301eea00db5828","modified":1448474452000},{"_id":"themes/yelee/node_modules/micromatch/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1450565572000},{"_id":"themes/yelee/node_modules/micromatch/README.md","shasum":"eba0e0ae3e48e963ccee0076042885ffb4c03197","modified":1450565572000},{"_id":"themes/yelee/node_modules/micromatch/index.js","shasum":"20605ff35f61f5d56ba1224cd19b65e1f8faed6c","modified":1450565705000},{"_id":"themes/yelee/node_modules/micromatch/lib/chars.js","shasum":"10dede99931a8786b6c738b202ac8bda153ea112","modified":1450565572000},{"_id":"themes/yelee/node_modules/micromatch/lib/expand.js","shasum":"d94dec073a967959a17f4896e50943b2cb50ffa8","modified":1450565705000},{"_id":"themes/yelee/node_modules/micromatch/lib/glob.js","shasum":"100291bc1b0e543fa2d491f9d157aa06c11aa496","modified":1450565705000},{"_id":"themes/yelee/node_modules/micromatch/lib/utils.js","shasum":"6d5a578a0f53305d62c502f4d88091a272952619","modified":1450565725000},{"_id":"themes/yelee/node_modules/micromatch/package.json","shasum":"98768c6a1ac41b5c6ed96f7e3ea6de5b189b997b","modified":1456469177000},{"_id":"themes/yelee/node_modules/mime-db/LICENSE","shasum":"b559c45c8d07f2679620d9771e68696ee3d5964b","modified":1411631388000},{"_id":"themes/yelee/node_modules/mime-db/HISTORY.md","shasum":"d1bb492efb205450ad3430dfb072c2aea37dc0fb","modified":1455558628000},{"_id":"themes/yelee/node_modules/mime-db/README.md","shasum":"1018078c0d9fd0331ca23ac5d97ace15596bf46c","modified":1449721722000},{"_id":"themes/yelee/node_modules/mime-db/index.js","shasum":"31180f8d0ae079b1bee7ee03e77ea5323583eb06","modified":1411631388000},{"_id":"themes/yelee/node_modules/mime-types/HISTORY.md","shasum":"e99031ef66245a8b0473c1a4cd56e7eb640af2e1","modified":1455574470000},{"_id":"themes/yelee/node_modules/mime-db/package.json","shasum":"3cd2a360049e623f008454b940e6f832e8b3c5fd","modified":1456469177000},{"_id":"themes/yelee/node_modules/mime-types/LICENSE","shasum":"f027af3e61af3880fd7f7b8ba9452a85dd215738","modified":1455569104000},{"_id":"themes/yelee/node_modules/mime-types/index.js","shasum":"d1983bb9d10cc678f693be62ef05e1b8c2638ef0","modified":1455569104000},{"_id":"themes/yelee/node_modules/mime-types/package.json","shasum":"2cc0e046b56ab2af1a0be3f2821a8aeb05ad6f4f","modified":1456469176000},{"_id":"themes/yelee/node_modules/mime-types/README.md","shasum":"bdc1c75e9234d1d6fc56c819cec51f568be5c68b","modified":1455572366000},{"_id":"themes/yelee/node_modules/minimatch/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999466000},{"_id":"themes/yelee/node_modules/minimatch/browser.js","shasum":"04c30625df185494a153c238296f5859aed9c963","modified":1437616294000},{"_id":"themes/yelee/node_modules/minimatch/README.md","shasum":"fb5bec4ab02467cdb76cdb552613ff0547402439","modified":1407793656000},{"_id":"themes/yelee/node_modules/minimatch/minimatch.js","shasum":"16b28bcabd1eca778c2176d6c49330396907411e","modified":1437616284000},{"_id":"themes/yelee/node_modules/minimatch/package.json","shasum":"4179a906ca529c03a8348d8d76f2983f8894abb0","modified":1456469176000},{"_id":"themes/yelee/node_modules/nan/CHANGELOG.md","shasum":"e221674e5a8b9fa810c3da81bdc918f82bf093c9","modified":1452351065000},{"_id":"themes/yelee/node_modules/nan/LICENSE.md","shasum":"efb645e33e8b96f7fc3bf62f083d1d8f2d78fc79","modified":1452350917000},{"_id":"themes/yelee/node_modules/nan/appveyor.yml","shasum":"fec84487904d69e902d98260d1b0bb93ddf59e10","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/README.md","shasum":"8546788add06c939f21cb3fa4f1cb019a5b235de","modified":1452351065000},{"_id":"themes/yelee/node_modules/nan/doc/asyncworker.md","shasum":"d08c62b641082ffdd635f7048201f975730a3223","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/buffers.md","shasum":"379d606e2e03de0cbe5ca3f28d6267b59da7986e","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/converters.md","shasum":"87a44ab8436a0a2c5ca5878fb0e3b40d067c3d9c","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/callback.md","shasum":"ffe38c04228985bece1442a891793cd3b438e625","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/errors.md","shasum":"1eacf4e82465545bdc5b7def1cf0ab27b003b03d","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/maybe_types.md","shasum":"545e51098bce1a351784d1f9cca9f19f93302929","modified":1452349062000},{"_id":"themes/yelee/node_modules/nan/doc/methods.md","shasum":"450accc8b6aacc34146c4021a1edcddd6c5faefb","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/doc/new.md","shasum":"342778da9fdf2393a7de91a922e8d89d1baf7568","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/node_misc.md","shasum":"a6e668fb8cb18a5a2d2f32b6b2db2a7284d614f7","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/doc/object_wrappers.md","shasum":"562c6b37edc2d16c36f231aedce4d5ea427c074e","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/doc/scopes.md","shasum":"1ec6947eaa9b7cd384129c826e4048ab8920b2a6","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/script.md","shasum":"5b150c97506b154aa270e8ba2fd4c01a8f631236","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/persistent.md","shasum":"43a25f5b31914f9fc6e8ecaa15b8064790f96e9f","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/string_bytes.md","shasum":"f2d9b8259c38fc4fe88f1f1324273481ac0d328e","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/v8_internals.md","shasum":"0d417bca198f1700d7b3d866c23355dd0eb328ed","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/include_dirs.js","shasum":"cd38e47a4ea58e4b7b31355a1af480ccd04b568f","modified":1444241269000},{"_id":"themes/yelee/node_modules/nan/doc/v8_misc.md","shasum":"a31716bd78f1fac323a714e3108ddf6be1a32d44","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/nan_callbacks.h","shasum":"f589a9eec7ce1f1dd49c634e4e8e865a9d74b0e6","modified":1452350395000},{"_id":"themes/yelee/node_modules/nan/nan_callbacks_12_inl.h","shasum":"ac058de8fd74c712fd465c4096486c8f7290ec24","modified":1452350388000},{"_id":"themes/yelee/node_modules/nan/nan_converters.h","shasum":"34b76a47cc52016e84011ea44544f535564a20ea","modified":1452350406000},{"_id":"themes/yelee/node_modules/nan/nan_callbacks_pre_12_inl.h","shasum":"ba39b9a944d9aaddc379236b68a79ee548e998c4","modified":1452350398000},{"_id":"themes/yelee/node_modules/nan/nan_converters_43_inl.h","shasum":"315acfe32ba9e812a85c5f09e9a5d42f4acf8ca6","modified":1452350402000},{"_id":"themes/yelee/node_modules/nan/nan_converters_pre_43_inl.h","shasum":"7989a21608e3aa16ac75f57cfc266270133075a3","modified":1452350410000},{"_id":"themes/yelee/node_modules/nan/nan_implementation_12_inl.h","shasum":"1da7e4b17c52b332eb416dcee9cbfe25a666fb9f","modified":1452350422000},{"_id":"themes/yelee/node_modules/nan/nan_implementation_pre_12_inl.h","shasum":"28b3eb83a8c89fe05e76e2d54be313465c37d286","modified":1452350426000},{"_id":"themes/yelee/node_modules/nan/nan_maybe_43_inl.h","shasum":"5c01c487730707e70cc9110d8f29658b22d0c3ff","modified":1452350430000},{"_id":"themes/yelee/node_modules/nan/nan_maybe_pre_43_inl.h","shasum":"d754702112c40fe7a0a7e6f817df162685e28e18","modified":1452350434000},{"_id":"themes/yelee/node_modules/nan/nan_new.h","shasum":"fbb57235690d81756e70414710fc92aaa8dbaedb","modified":1452350437000},{"_id":"themes/yelee/node_modules/nan/nan_object_wrap.h","shasum":"95518fbd2d92d8b81f10b304515b7f60015b886d","modified":1452350441000},{"_id":"themes/yelee/node_modules/nan/nan_persistent_12_inl.h","shasum":"2725049d9bda7b9d8dc1690c8dc72641cb0a5f70","modified":1452350445000},{"_id":"themes/yelee/node_modules/nan/nan_persistent_pre_12_inl.h","shasum":"e25a3c8e5ec7983ea397080c2ed87eb894cfc3d1","modified":1452350452000},{"_id":"themes/yelee/node_modules/nan/nan_string_bytes.h","shasum":"bdf8bfb9e779171768a04ec6e9d1e074c10874e1","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/nan_typedarray_contents.h","shasum":"78b55f04c9f1969425b209271ad1869129c3973c","modified":1452350469000},{"_id":"themes/yelee/node_modules/nan/nan_weak.h","shasum":"50feae1dc8a5531acb17bcd8399485f819dfef07","modified":1452350474000},{"_id":"themes/yelee/node_modules/nan/package.json","shasum":"368ab63065900b1d723ae408e76cb39fc462f8c6","modified":1456469177000},{"_id":"themes/yelee/node_modules/nan/tools/1to2.js","shasum":"e37a19a2f75556de8756befc2a3fc5a3d5bbd3fe","modified":1452350885000},{"_id":"themes/yelee/node_modules/nan/tools/README.md","shasum":"a5103d8b2150ba5fd2736fbb6fd2a2a819596244","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/tools/package.json","shasum":"c8b6de0212f33be85f01aea1581791bd14aa2a73","modified":1444243260000},{"_id":"themes/yelee/node_modules/node-uuid/LICENSE.md","shasum":"09bedf3eb387e2883ded96ee501d16262350c9cd","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/README.md","shasum":"783d814c48583b086ffd8b701a53844f799e7d0d","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/README.md","shasum":"7ca0c673b27c3c4c50167b5077bb421711c2518b","modified":1447445668000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/bench.gnu","shasum":"26bd5d465f2588f4ebda09b9aa28f3fecffb9f4a","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/bench.sh","shasum":"3f8daeb462ad5609c63fb8915efc4fa870a8fde5","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/benchmark-native.c","shasum":"8d999ba3178ae2683a7ed30b9ff115fe9d9f41bd","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/benchmark.js","shasum":"82dfd78c7f35bd52a84259e9afc36018f41bf58e","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/bin/uuid","shasum":"cc4874ec4258ffff8b743227a3619f895941b563","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/bower.json","shasum":"6d521f86833c6d9a6a75af623529479fcf89f917","modified":1447446668000},{"_id":"themes/yelee/node_modules/node-uuid/component.json","shasum":"7e1d6df157d7075438267019c90f5cb158b26983","modified":1447446668000},{"_id":"themes/yelee/node_modules/node-uuid/test/compare_v1.js","shasum":"ac9c80da67f4b232b0aff05c4160deda00dda2e6","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/package.json","shasum":"bc5df34022c2262faa38983f6b9802c5899027b3","modified":1456469177000},{"_id":"themes/yelee/node_modules/node-uuid/test/test.html","shasum":"287decf793ae25e5cffda0f5a118a41ccf54fca0","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/test/test.js","shasum":"bd765f9091cfd101f0679e45330ce04a62266453","modified":1447291212000},{"_id":"themes/yelee/node_modules/node-uuid/uuid.js","shasum":"91f473812e7748b91d6adb32ac704c4f8cdea13a","modified":1447446491000},{"_id":"themes/yelee/node_modules/normalize-path/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1422062974000},{"_id":"themes/yelee/node_modules/normalize-path/README.md","shasum":"83f0d8c7ef174ff6b375a48765494088ba5c93a6","modified":1443938634000},{"_id":"themes/yelee/node_modules/normalize-path/index.js","shasum":"1fa7549f17a96f788cb935c242c33d122f5bb005","modified":1447763472000},{"_id":"themes/yelee/node_modules/oauth-sign/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1432536000000},{"_id":"themes/yelee/node_modules/normalize-path/package.json","shasum":"e36f551fa669b3002cf2e9026a5b8dc041d89e2a","modified":1456469176000},{"_id":"themes/yelee/node_modules/oauth-sign/README.md","shasum":"9f943ef5e4c1e530314bee287c8fd5b8addbc808","modified":1432536000000},{"_id":"themes/yelee/node_modules/oauth-sign/index.js","shasum":"fb3d1f2193e77b18089fad077d3133143811f554","modified":1454224562000},{"_id":"themes/yelee/node_modules/oauth-sign/package.json","shasum":"c4b14ac8600dcd29102cd6991376a2d023abd10b","modified":1456469176000},{"_id":"themes/yelee/node_modules/object.omit/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1428554275000},{"_id":"themes/yelee/node_modules/oauth-sign/test.js","shasum":"972d35362f1eb47ba9e12409a6d49ecc23e8a968","modified":1432809220000},{"_id":"themes/yelee/node_modules/object.omit/README.md","shasum":"1b8bcc9834b67c3a49946e23a44a1edb4bd92833","modified":1437545968000},{"_id":"themes/yelee/node_modules/object.omit/index.js","shasum":"859e8fa5823e361cf0b34ec07263765a36923ebf","modified":1437545718000},{"_id":"themes/yelee/node_modules/parse-glob/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1442931829000},{"_id":"themes/yelee/node_modules/parse-glob/README.md","shasum":"b08c9fd27a7da80a2e0afb00003498384f3aabbb","modified":1442934996000},{"_id":"themes/yelee/node_modules/object.omit/package.json","shasum":"03b6a81a68ce699379e89824e9ae1a8bc806794b","modified":1456469176000},{"_id":"themes/yelee/node_modules/parse-glob/index.js","shasum":"80de4342abc02723990d3849ef8f5710a3bfc2a0","modified":1442931829000},{"_id":"themes/yelee/node_modules/parse-glob/package.json","shasum":"baced47d22a65939522c005491275fee9a7fdb82","modified":1456469176000},{"_id":"themes/yelee/node_modules/path/LICENSE","shasum":"469a9940ed48958c0d900e24f72c06a2b1529a27","modified":1442156078000},{"_id":"themes/yelee/node_modules/path/README.md","shasum":"c36a59ad8daa1c74f181053251ebdb5f0c8b036c","modified":1442156078000},{"_id":"themes/yelee/node_modules/path/package.json","shasum":"f2934441bd731269a8d8ae4358261429b0ead497","modified":1456469176000},{"_id":"themes/yelee/node_modules/path/path.js","shasum":"e1c52aaaa3eeb1673305f174539d878343aec379","modified":1442157112000},{"_id":"themes/yelee/node_modules/path-is-absolute/index.js","shasum":"71259da8cc05832088437dd2d385b7eee54eab71","modified":1424141850000},{"_id":"themes/yelee/node_modules/path-is-absolute/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/path-is-absolute/package.json","shasum":"8d4180416ef4755411eefd6f611867d8e1298829","modified":1456469176000},{"_id":"themes/yelee/node_modules/path-is-absolute/readme.md","shasum":"bbe564e38bd40bd0f8c6f503d3064ebce4e6e87c","modified":1424141985000},{"_id":"themes/yelee/node_modules/pinkie/index.js","shasum":"4ed6d8988b13d2c29cfa99c99cedb43fa6b51ee7","modified":1454324862000},{"_id":"themes/yelee/node_modules/pinkie/license","shasum":"91c700b5dac5967632cf497f1f3316352b1b45ce","modified":1454217969000},{"_id":"themes/yelee/node_modules/pinkie/package.json","shasum":"9d9ed0667de0d9a182c55dba2eec7944fd0d9051","modified":1456469176000},{"_id":"themes/yelee/node_modules/pinkie/readme.md","shasum":"1673aa52b8f81f6ebf1c2e5ca0184a6f63522f78","modified":1454322504000},{"_id":"themes/yelee/node_modules/pinkie-promise/index.js","shasum":"cc84d8fc33cad091d8dc7bc65c0481a8a915769b","modified":1447318268000},{"_id":"themes/yelee/node_modules/pinkie-promise/license","shasum":"91c700b5dac5967632cf497f1f3316352b1b45ce","modified":1447318268000},{"_id":"themes/yelee/node_modules/pinkie-promise/package.json","shasum":"d681066c77894ddca7f03ea6885e527323ec4c18","modified":1456469176000},{"_id":"themes/yelee/node_modules/pinkie-promise/readme.md","shasum":"450859283a97df6ee0918789a485d26786329eb1","modified":1447318268000},{"_id":"themes/yelee/node_modules/preserve/LICENSE","shasum":"d99d5158898474f25efb4c8790f9fcc4cf55b350","modified":1420928487000},{"_id":"themes/yelee/node_modules/preserve/README.md","shasum":"daedd5d9696a86795f63b002cfd4537033d639ec","modified":1420928487000},{"_id":"themes/yelee/node_modules/preserve/index.js","shasum":"1d37d615f1ea0e2469a6e1a8a64eb7c1c7b6f110","modified":1420928487000},{"_id":"themes/yelee/node_modules/preserve/test.js","shasum":"3baac5a1e812bcc42443c2dc6a401c0a55d01f4c","modified":1420928674000},{"_id":"themes/yelee/node_modules/preserve/package.json","shasum":"acaf8ded9e888b6dcfdd80b65e8e7c021007abc0","modified":1456469177000},{"_id":"themes/yelee/node_modules/process/LICENSE","shasum":"1433c1355cae4a748820ba1862b32bb231ac04b6","modified":1386516960000},{"_id":"themes/yelee/node_modules/process/README.md","shasum":"6bc187da95fd0394e3b87b2a58d9303e2ba1aae3","modified":1441759726000},{"_id":"themes/yelee/node_modules/process/browser.js","shasum":"48c5490fa029e282317f5e10c4cbdc56a8f00cb5","modified":1441759817000},{"_id":"themes/yelee/node_modules/process/index.js","shasum":"0eb7b4e67705373adef4a706b1380f680d263c0b","modified":1386516960000},{"_id":"themes/yelee/node_modules/process/package.json","shasum":"f677200b9f4137d19e853b7563d2939f7fe2e2d0","modified":1456469176000},{"_id":"themes/yelee/node_modules/process-nextick-args/index.js","shasum":"066a18ff5757235dbe5ea1a2c632946293dcff6f","modified":1449104960000},{"_id":"themes/yelee/node_modules/process/test.js","shasum":"ed6fe488903ec725d0ee9defdc784e05f081432e","modified":1429902052000},{"_id":"themes/yelee/node_modules/process-nextick-args/license.md","shasum":"9def7167175d2ac68505dd2ae0c7b8dd63bc4c3d","modified":1449008551000},{"_id":"themes/yelee/node_modules/process-nextick-args/package.json","shasum":"098a9e97b5730b76cd2b3de314704e7acbec3b37","modified":1456469176000},{"_id":"themes/yelee/node_modules/process-nextick-args/test.js","shasum":"279a062028d86a4ee0ab2ab800ecf7ca29f4905e","modified":1449008551000},{"_id":"themes/yelee/node_modules/process-nextick-args/readme.md","shasum":"3eba0a30f0a115fd767a0c8c9761d60d1dc768c0","modified":1437048205000},{"_id":"themes/yelee/node_modules/punycode/LICENSE-MIT.txt","shasum":"d7384cd3ed0c9614f87dde0f86568017f369814c","modified":1408532732000},{"_id":"themes/yelee/node_modules/punycode/README.md","shasum":"9854b804b32cc0191af177cd8fea432b1e25875c","modified":1409501399000},{"_id":"themes/yelee/node_modules/punycode/package.json","shasum":"f96c9b9b3429ea0f751545c8922e26c7077d2130","modified":1456469176000},{"_id":"themes/yelee/node_modules/qs/CHANGELOG.md","shasum":"a8c66d98d8c1501b5a506709fc7f4285b59c7f82","modified":1453069331000},{"_id":"themes/yelee/node_modules/qs/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1450856430000},{"_id":"themes/yelee/node_modules/punycode/punycode.js","shasum":"4e703e940e4620f1c8ac328496167287f19b322f","modified":1413979177000},{"_id":"themes/yelee/node_modules/qs/LICENSE","shasum":"ddf13f1b7345d730677237125bc2e46fbbfbbf32","modified":1450856430000},{"_id":"themes/yelee/node_modules/qs/bower.json","shasum":"d278db3097c39d4df650b04bbc42d03021b87409","modified":1453070078000},{"_id":"themes/yelee/node_modules/qs/README.md","shasum":"9d57cdff65ba49f961ad3805df133c282c4672e0","modified":1453069466000},{"_id":"themes/yelee/node_modules/qs/dist/qs.js","shasum":"4999c7f95ac28c994fc5f4772e51d9288ea8b6cd","modified":1453071516000},{"_id":"themes/yelee/node_modules/qs/component.json","shasum":"affe28b8b20dde94e6cdc469ce5b11bcd87bcb9a","modified":1453070078000},{"_id":"themes/yelee/node_modules/qs/lib/index.js","shasum":"227523195233e42a48c20f75a1ae350c6bcc5b47","modified":1453052046000},{"_id":"themes/yelee/node_modules/qs/lib/parse.js","shasum":"f85546c13d4cae0f65b3bb3693cc92e18636abe3","modified":1453052057000},{"_id":"themes/yelee/node_modules/qs/lib/stringify.js","shasum":"910b15fb61e39f8c3fcb5eaf522f5f6daf1f3e77","modified":1453052046000},{"_id":"themes/yelee/node_modules/qs/lib/utils.js","shasum":"b4614510e0a35009a95de16f2f7a19dc8bbf9265","modified":1453052057000},{"_id":"themes/yelee/node_modules/qs/package.json","shasum":"312f074c9b9234b321b0ceb1e5134a9c43d7817f","modified":1456469177000},{"_id":"themes/yelee/node_modules/qs/test/index.js","shasum":"3d9a66ca5549d2dd32f6a56c4ba0472498fb68a8","modified":1450861863000},{"_id":"themes/yelee/node_modules/qs/test/parse.js","shasum":"b7041aee47eca551b475d405957a019e61296bf5","modified":1452717606000},{"_id":"themes/yelee/node_modules/qs/test/stringify.js","shasum":"38ca94758266fbd37217faad5fc7bff6d3ef1e0a","modified":1452717606000},{"_id":"themes/yelee/node_modules/querystring/History.md","shasum":"b19d8f7359a49c49c4171389181a92b20dd0ade8","modified":1362519151000},{"_id":"themes/yelee/node_modules/qs/test/utils.js","shasum":"5f25e2ef762a18cff8719d88a1748840c1626d89","modified":1452717606000},{"_id":"themes/yelee/node_modules/querystring/License.md","shasum":"4051887547e070bbe1e1d2dcab3a46f44beeacb2","modified":1351024476000},{"_id":"themes/yelee/node_modules/querystring/Readme.md","shasum":"9d3abbe245c90a38c365e89e8cbe94f07d1a6b1e","modified":1362519108000},{"_id":"themes/yelee/node_modules/querystring/encode.js","shasum":"bc42441192cea9de787398850f1d308980421017","modified":1362518500000},{"_id":"themes/yelee/node_modules/querystring/decode.js","shasum":"78c13537ae65852bb6b1df4563ced3a27f848376","modified":1362518500000},{"_id":"themes/yelee/node_modules/querystring/index.js","shasum":"cb7fd2835f652938cfe501f3f0c225e2646eb801","modified":1362518500000},{"_id":"themes/yelee/node_modules/querystring/package.json","shasum":"8980605354ec112ab95dbb66c1473618c250b963","modified":1456469177000},{"_id":"themes/yelee/node_modules/querystring/test/common-index.js","shasum":"639fc036bb30ff8541f4c2bddfb70ddbc626def8","modified":1358665842000},{"_id":"themes/yelee/node_modules/querystring/test/index.js","shasum":"babf2311efbb9456ba96c404507d80ba403a8dde","modified":1362518989000},{"_id":"themes/yelee/node_modules/querystring/test/tap-index.js","shasum":"f1741495b86e7e359c13b5b7cdc772fb32aab99a","modified":1358668762000},{"_id":"themes/yelee/node_modules/randomatic/LICENSE","shasum":"2fc7036acf8dab2c91ea48a293a2a52f37662c34","modified":1420215893000},{"_id":"themes/yelee/node_modules/randomatic/README.md","shasum":"1cfbcf24eeeba70bd12cd724052a67e50c71c2a8","modified":1449768911000},{"_id":"themes/yelee/node_modules/randomatic/index.js","shasum":"b3eab954771903c20e51724faafa84685dca1ccc","modified":1447157175000},{"_id":"themes/yelee/node_modules/randomatic/package.json","shasum":"7899e8780d6721cc6bb8d02d4ce41525e98d0a0b","modified":1456469176000},{"_id":"themes/yelee/node_modules/readable-stream/LICENSE","shasum":"73efe5bda3791d234730ab0dcc48eb619a2e0ec6","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/README.md","shasum":"113fddeaf3174b63954f81670dce9772fc252ad1","modified":1434936371000},{"_id":"themes/yelee/node_modules/readable-stream/doc/wg-meetings/2015-01-30.md","shasum":"1fafe6e2e28a4404db90ae6dc867199b74468ca4","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/duplex.js","shasum":"5ff8b0af1efbb8ed54ac1b3f57167447cb902344","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/doc/stream.markdown","shasum":"34bb6baba8a25fd40136c519215124cbce7ec78b","modified":1450290518000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_duplex.js","shasum":"d4e2c0dbe893e97638262fb598f00472aa121cf0","modified":1448548407000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_passthrough.js","shasum":"51d9ab73b4265e9c011537e957c8f578bcf50d1e","modified":1448548407000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_readable.js","shasum":"71fec1e21d268617a18c91742d57f3f43ed7a14b","modified":1450290518000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_writable.js","shasum":"e6b7ebcfcbf1648eeda0b5060f388028b5eabf97","modified":1450290518000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_transform.js","shasum":"fbeb8123c9557d11283543efd471e659a80a1f1e","modified":1448548407000},{"_id":"themes/yelee/node_modules/readable-stream/package.json","shasum":"a7cd37c9aad10c2032ac43b9ed13a2f4bf8a289b","modified":1456469177000},{"_id":"themes/yelee/node_modules/readable-stream/readable.js","shasum":"f68ae09e1cfcd9f75f8d43cb82724b3dee5d9251","modified":1434936362000},{"_id":"themes/yelee/node_modules/readable-stream/transform.js","shasum":"2d31b50e657e5b03ce5abc5ce6b77187e8e876c2","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/passthrough.js","shasum":"ff1590a9a778dc9d8ed51064670d82426782ee6e","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/writable.js","shasum":"8a7bd86d1803614b9381a924ab9ef0a19fd70e6c","modified":1433891361000},{"_id":"themes/yelee/node_modules/readdirp/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/README.md","shasum":"caf3972fc843ec620aad623e672a8536469c443a","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/Readme.md","shasum":"b019e9ebb387f5ddfb2313b7cb79e62cad77f83d","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/callback-api.js","shasum":"bc8172824ff3c01eed53b563f95f99f1d90c2435","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/grep.js","shasum":"03dd42417a46ccac5adcb5d3cf4ae328b20cb90b","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/stream-api-pipe.js","shasum":"3bed4d356d63f329ed4c3d6745b41215c2b2ffad","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/package.json","shasum":"63aecfe08596ce3954da36160fd30e4c15fe0bb9","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/stream-api.js","shasum":"56ebe5e04e674c190e9d9e14363475672922edd2","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/package.json","shasum":"467ae8e48b7cb680b48ae0412d5f1e29ff013066","modified":1456469177000},{"_id":"themes/yelee/node_modules/readdirp/stream-api.js","shasum":"9c81fcea57ab4bfccad3e3d6c0e431802cc194a2","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/readdirp.js","shasum":"d2b155e274f6d22bdddabbdf2bc85e7d1bb30ccb","modified":1418419176000},{"_id":"themes/yelee/node_modules/readdirp/test/readdirp-stream.js","shasum":"afbceb4eb293e5f454e79185f4ec9039079ddb12","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/readdirp.js","shasum":"04bb5ac265a4f6e10f05c7f6311366eb2d6dfda8","modified":1418419137000},{"_id":"themes/yelee/node_modules/regex-cache/LICENSE","shasum":"7e21c9f5aa0a1be61e943a935506095ea40bbafc","modified":1423430290000},{"_id":"themes/yelee/node_modules/regex-cache/README.md","shasum":"45aa40e5f1a33b680e01a62ccc6a6795917ebfa0","modified":1427322479000},{"_id":"themes/yelee/node_modules/regex-cache/package.json","shasum":"a0389fc6d2bdf23a04c5a27c2b34d3b3dd3170db","modified":1456469176000},{"_id":"themes/yelee/node_modules/regex-cache/index.js","shasum":"ada9405a781d2cf3953394ecaa0580429c4f06fe","modified":1424169012000},{"_id":"themes/yelee/node_modules/repeat-element/LICENSE","shasum":"7e21c9f5aa0a1be61e943a935506095ea40bbafc","modified":1421019371000},{"_id":"themes/yelee/node_modules/repeat-element/README.md","shasum":"230540131df8177d53f6ee1a57eec5d9413992ec","modified":1430968550000},{"_id":"themes/yelee/node_modules/repeat-element/package.json","shasum":"cab414a8ab826ca48cea6f249871db943b2651d5","modified":1456469176000},{"_id":"themes/yelee/node_modules/repeat-element/index.js","shasum":"33ee2f6ac8638233b7d7eb0a35b43249f05ee5c5","modified":1430968437000},{"_id":"themes/yelee/node_modules/repeat-string/LICENSE","shasum":"d99d5158898474f25efb4c8790f9fcc4cf55b350","modified":1427925999000},{"_id":"themes/yelee/node_modules/repeat-string/README.md","shasum":"1dbcc50870b2e1d3338d4a22ece1790e499c50be","modified":1427933810000},{"_id":"themes/yelee/node_modules/repeat-string/index.js","shasum":"eb06cff804ee286c2bba2833ebf293dbca3914bf","modified":1427925999000},{"_id":"themes/yelee/node_modules/repeat-string/package.json","shasum":"ffda2de6c5f4ef7eaae01326701023abf36809ab","modified":1456469176000},{"_id":"themes/yelee/node_modules/request/CONTRIBUTING.md","shasum":"a9fc87e51d92d75e09e391fed0b41d0916da1499","modified":1421769158000},{"_id":"themes/yelee/node_modules/request/CHANGELOG.md","shasum":"142acbcd6d56904d1caa8775f56379738cb142b3","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1413995097000},{"_id":"themes/yelee/node_modules/request/index.js","shasum":"6b96d838b3fae1c1d3fd963613b6465cd788e8c4","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/README.md","shasum":"612f6c04bd0aceb60c1d22dcf1a5de5a5cf91698","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/auth.js","shasum":"56bdda40a7df68f69c68cd256258017783e70d12","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/cookies.js","shasum":"0b2a641d706209af1f92176a507f382e06b44379","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/getProxyFromURI.js","shasum":"2e7c16e357f885401208174ad1f341b084965253","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/lib/helpers.js","shasum":"c636e050b67bc00533adc7721e750f9520902917","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/lib/multipart.js","shasum":"66acc47cab8b774688502be7752501e4a44d3cda","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/har.js","shasum":"a4b894d836e3bd947a5d8afffec04128bf934fe5","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/oauth.js","shasum":"8663a55221a216cc32d655f83086979ae9e666a9","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/lib/querystring.js","shasum":"b78be4d88327f11499fbf86610d0612d803b1ff4","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/lib/redirect.js","shasum":"08b710fe22cf8e28b2fecdcaaadb76923361299b","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/tunnel.js","shasum":"97336f00dd29c7fdad5550e9ae4daf57d587d034","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/package.json","shasum":"93cc2fdef537935d82c9ec6e6969a63450a19952","modified":1456469177000},{"_id":"themes/yelee/node_modules/sntp/LICENSE","shasum":"1583807686100eb3d8287b4e4627818f002aabaf","modified":1409946595000},{"_id":"themes/yelee/node_modules/request/request.js","shasum":"baa695ff90bacd0d7e7b56fc0f83bac22360fd99","modified":1453921187000},{"_id":"themes/yelee/node_modules/sntp/Makefile","shasum":"23079c0b043b0fd2f037fa6272e36d2562425c6d","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/README.md","shasum":"5b5b1348b73a5ba7293f5924937015c6b6350b6d","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/examples/offset.js","shasum":"5b78885677fd2f0eae4c2fb6c04c2d6e2f39bf49","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/examples/time.js","shasum":"9a7e69f5ee15afc381ce433cfa867bff405ca81d","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/index.js","shasum":"fbc929bb3b85e76c25fc52743d325d9f36fb3643","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/lib/index.js","shasum":"eeed7222493e633069fe267f915f7d13b12df094","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/package.json","shasum":"943f244a6ffcef539293a58cd1ddec29e4a87db6","modified":1456469177000},{"_id":"themes/yelee/node_modules/sntp/test/index.js","shasum":"bc5aae767cff3fcd90a9a4b2d6ec0e6fea66988f","modified":1409946595000},{"_id":"themes/yelee/node_modules/sshpk/LICENSE","shasum":"10b8ac49ffb8f7cc8bdca9303209a1b3b2f3587d","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/README.md","shasum":"7c00acdc8e5bf0eca47a16aa33c8fa17202fa4bb","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/bin/sshpk-conv","shasum":"fea08967162027695aed134d117056a5b789d188","modified":1452039039000},{"_id":"themes/yelee/node_modules/sshpk/bin/sshpk-sign","shasum":"e187df199ed0e1c1d782f679b4742df047919854","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/bin/sshpk-verify","shasum":"a74dd8749820e0a9e9d334bd09665d6e3e4885f2","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/lib/algs.js","shasum":"95cac832aaaa1d70d2a18bd42559a147dafbf11b","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/lib/dhe.js","shasum":"de6f67e80ebce95a5272c75afcf05ea84ac45b3b","modified":1449005123000},{"_id":"themes/yelee/node_modules/sshpk/lib/ed-compat.js","shasum":"a05999a5907f0027ba834b8ee4e819380a5108ea","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/lib/errors.js","shasum":"94532c1445e72de790269b42a85741ac597c37e4","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/lib/fingerprint.js","shasum":"1d34b04f4b70508da86cbc87a4a4c16206189930","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/auto.js","shasum":"ef4cc1499a3c7c3d96343b8edb2965c9630830a6","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/pem.js","shasum":"8288839f3bc23aa06ff4be127a0c7099511668b1","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/pkcs1.js","shasum":"155a8e28b24cb78b4d2a9cc88acdbd24f8296e97","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/pkcs8.js","shasum":"c9f73599e6447ef8cd55d670335b710bf9eb666e","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/rfc4253.js","shasum":"31768dec67a622cb3a29e665467a2c6506923da2","modified":1455236041000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/ssh.js","shasum":"e05ce4d9981b2d0ccbbc6c5b28f1c4497adffe56","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/ssh-private.js","shasum":"cba9761409b07d0d383aa58185d968613edbd5ff","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/index.js","shasum":"1e6da7fba9b778c1791755723fb286b3d72d8b97","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/lib/key.js","shasum":"fa8bce41330b09c7cda81be71b15772a57590eab","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/lib/private-key.js","shasum":"a2d90ebfebf92206b78fba754ea43af97ac80841","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/signature.js","shasum":"9ca03d95eded537101b3b7e9f0537f3cb5e0217b","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/ssh-buffer.js","shasum":"e0a58a30c41e44e08e098467384b56a33f7c3213","modified":1452039039000},{"_id":"themes/yelee/node_modules/sshpk/lib/utils.js","shasum":"9dcea6ff1a1026a57b235f4608fc08480efa05fb","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/man/man1/sshpk-conv.1","shasum":"a64a4769ca648e2047d255bf5237ce051f6af15a","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/man/man1/sshpk-verify.1","shasum":"a5c70f82de5313ee103ba9bf3cfb9774465de370","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/man/man1/sshpk-sign.1","shasum":"742f5bb2986ad635eb081bad695573cd6826c96b","modified":1452565517000},{"_id":"themes/yelee/node_modules/string_decoder/LICENSE","shasum":"8344f8cf34d06153cd7ffc797c070e00d69eb442","modified":1390012773000},{"_id":"themes/yelee/node_modules/sshpk/package.json","shasum":"406c4301061c7dc76e05b2e31ae669007270bd22","modified":1456469177000},{"_id":"themes/yelee/node_modules/string_decoder/README.md","shasum":"c8dac065c0a3043936a7c07ea1d698234c3ad159","modified":1390012773000},{"_id":"themes/yelee/node_modules/string_decoder/index.js","shasum":"91f40da3177881cf70b87520444b755e1d9592ec","modified":1408767880000},{"_id":"themes/yelee/node_modules/stringstream/LICENSE.txt","shasum":"e957fbece098eddf6df809165d5e73c2c1b2e10a","modified":1445815621000},{"_id":"themes/yelee/node_modules/string_decoder/package.json","shasum":"b83e37447e6dd0ffa68dd7fae5a71135b1acfded","modified":1456469176000},{"_id":"themes/yelee/node_modules/stringstream/README.md","shasum":"33c7843dec1919a17daad5a5ae2fb06d54018b38","modified":1358765250000},{"_id":"themes/yelee/node_modules/stringstream/example.js","shasum":"17a98e07a319edf8fbeeea49d83515304922b1b4","modified":1361939998000},{"_id":"themes/yelee/node_modules/stringstream/package.json","shasum":"a76650259d3fcf70cd85a0607771b80ea615e8d7","modified":1456469176000},{"_id":"themes/yelee/node_modules/stringstream/stringstream.js","shasum":"400fe756da898736fe0642a709c7f88e21fda352","modified":1363491475000},{"_id":"themes/yelee/node_modules/strip-ansi/index.js","shasum":"fa7b64a04c5989a1c9b78e83768b90384ac9abcc","modified":1424597013000},{"_id":"themes/yelee/node_modules/strip-ansi/package.json","shasum":"c40a95761487d77f9b4efc95c3e7ce5276c0fe11","modified":1456469176000},{"_id":"themes/yelee/node_modules/strip-ansi/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1424597013000},{"_id":"themes/yelee/node_modules/strip-ansi/readme.md","shasum":"ee19204de1797a46e3101e8b064a3cfd4741fd6c","modified":1456056884000},{"_id":"themes/yelee/node_modules/supports-color/package.json","shasum":"aece41eeb7cdec35059d5665fb4a3015bcca3bf2","modified":1456469176000},{"_id":"themes/yelee/node_modules/supports-color/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/supports-color/index.js","shasum":"669e4e82e32796eacb16a314bb3db270fb1d8572","modified":1435362323000},{"_id":"themes/yelee/node_modules/supports-color/readme.md","shasum":"a0227e37af9ebe9e998782cf0a1eb75338d68f8e","modified":1435704929000},{"_id":"themes/yelee/node_modules/tough-cookie/LICENSE","shasum":"d453b8d6be98bbb6cff7074794f5776ff3a17115","modified":1443808008000},{"_id":"themes/yelee/node_modules/tough-cookie/README.md","shasum":"72dd4e35da08b98d01237a80b788ae1aa189de87","modified":1444173105000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/pathMatch.js","shasum":"3d403b8aad536db9e97eef4915eb01ef53405323","modified":1432572908000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/cookie.js","shasum":"30167425a77bef21e5eb390567ebef0f7532ca13","modified":1447378366000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/memstore.js","shasum":"ecd6269063fe718d5b46d4127ff9d12065660a90","modified":1433972674000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/permuteDomain.js","shasum":"700be205b7d0d3b4c4f442b7dc1b3299d47bf55d","modified":1432572908000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/store.js","shasum":"bcce2205e56bb588b4e6cfcd48a34610a5eccf82","modified":1433972674000},{"_id":"themes/yelee/node_modules/tough-cookie/package.json","shasum":"8e0c8f676e68a6e9663bfcbf1085d9a9e30edac2","modified":1456469177000},{"_id":"themes/yelee/node_modules/tunnel-agent/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1446013763000},{"_id":"themes/yelee/node_modules/tunnel-agent/README.md","shasum":"fab5bff0eba532373f36d827d9775105d64ff719","modified":1446013763000},{"_id":"themes/yelee/node_modules/tunnel-agent/index.js","shasum":"e9320bd906e55558d9ba2569f76e92899da8744f","modified":1449585048000},{"_id":"themes/yelee/node_modules/tunnel-agent/package.json","shasum":"be7b4047c86fb7e127b17cd47288d6bd739db170","modified":1456469176000},{"_id":"themes/yelee/node_modules/tweetnacl/CHANGELOG.md","shasum":"1d5290965ca2f4b840087ff8ad622c8a16f9c051","modified":1456360460000},{"_id":"themes/yelee/node_modules/tweetnacl/COPYING.txt","shasum":"92d8cef4ad2ad4c50c8741cad9dfd4a3f1ecb14d","modified":1456349123000},{"_id":"themes/yelee/node_modules/tweetnacl/README.md","shasum":"1cd9e0ee76559125884f4c4c73fcb16430c24235","modified":1455974941000},{"_id":"themes/yelee/node_modules/tweetnacl/nacl-fast.js","shasum":"b13f5e9c2d99a866bc1c5d66e58071cc8d4ae293","modified":1456360360000},{"_id":"themes/yelee/node_modules/tweetnacl/nacl-fast.min.js","shasum":"afded67e9b12156534d384d4b10f0c2384d418fd","modified":1455984388000},{"_id":"themes/yelee/node_modules/tweetnacl/nacl.js","shasum":"523fe36259524a0f35d056416a18de5ae96027a3","modified":1455960849000},{"_id":"themes/yelee/node_modules/tweetnacl/nacl.min.js","shasum":"807244ced1f262b7ffcf43d5ce8e9c3d17d96ba2","modified":1455984386000},{"_id":"themes/yelee/node_modules/tweetnacl/package.json","shasum":"060790ecb054aa76a8ea7ef9f7ea3f86d4d9edcc","modified":1456469177000},{"_id":"themes/yelee/node_modules/url/LICENSE","shasum":"6e02c7c9d5befe1c0407466d8377a0475ddd2d40","modified":1420169637000},{"_id":"themes/yelee/node_modules/url/README.md","shasum":"a57875ddbe6d06e86164eddce5a724f5f7534ebc","modified":1440689784000},{"_id":"themes/yelee/node_modules/url/package.json","shasum":"6f3d346fbe6a4c75c0b03cc65ed8c67fc2d8b77a","modified":1456469177000},{"_id":"themes/yelee/node_modules/url/test.js","shasum":"218082759e538553cb66e6956acbafe83201aa97","modified":1440689626000},{"_id":"themes/yelee/node_modules/url/util.js","shasum":"b83cee072b6381001e94414862d934d65004d92b","modified":1440689626000},{"_id":"themes/yelee/node_modules/url/url.js","shasum":"78d0ac233252dbbecf7afc93c2c3ad56965f53e2","modified":1440689626000},{"_id":"themes/yelee/node_modules/util/LICENSE","shasum":"73efe5bda3791d234730ab0dcc48eb619a2e0ec6","modified":1391793275000},{"_id":"themes/yelee/node_modules/util/README.md","shasum":"800a5b9b844394d482310cd82f5dd0c5e5b9f313","modified":1385144346000},{"_id":"themes/yelee/node_modules/util/package.json","shasum":"eff382719c54b788611e4e354b06131eff5c0a89","modified":1456469177000},{"_id":"themes/yelee/node_modules/util/support/isBuffer.js","shasum":"ab526fa0e6a7e7f560d2126a632cc8342158334d","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/support/isBufferBrowser.js","shasum":"b8367e5d8c922ba31fef26a3bfdde03fa6549394","modified":1387550223000},{"_id":"themes/yelee/node_modules/util/test/browser/inspect.js","shasum":"85c46df14faf4a9fc53decee72df962cb1fed6e3","modified":1387552267000},{"_id":"themes/yelee/node_modules/util/test/node/debug.js","shasum":"7d875f76046f15f766af9f269120580da0321d18","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/test/browser/is.js","shasum":"aed2e812c0eb4fc431b76dad123ea6328fa1287f","modified":1387550223000},{"_id":"themes/yelee/node_modules/util/test/node/util.js","shasum":"1105a294af7c2569317193d577b979abd55cc9d6","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/test/node/format.js","shasum":"45c0e3d208a550cdaeac56e19ea80f15cd7372d4","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/test/node/inspect.js","shasum":"45495c8dac3274dd814d62480bc768f08e3d386d","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/test/node/log.js","shasum":"4ef8a0d8a1354361f90e7b8a91cf5070b47a297a","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/util.js","shasum":"cda85059c26c964651c093b8a78bbe5a0dea0ab4","modified":1387552736000},{"_id":"themes/yelee/node_modules/util-deprecate/LICENSE","shasum":"cbde92577cb69b3b45dd33f8dc600732cf9e14cb","modified":1416945941000},{"_id":"themes/yelee/node_modules/util-deprecate/History.md","shasum":"1fc5b9cf603a0b6abeb852b35bec607a411e5b9b","modified":1444243047000},{"_id":"themes/yelee/node_modules/util-deprecate/README.md","shasum":"8e590b24df7b037031e571b7b2b9600217b83ae0","modified":1416945941000},{"_id":"themes/yelee/node_modules/util-deprecate/node.js","shasum":"26bb9fcabaf57f0bb50e5e026c13de394bc0c478","modified":1416945941000},{"_id":"themes/yelee/node_modules/util-deprecate/package.json","shasum":"f02ac425c5573315ebeb8295eb8dfd30175460a8","modified":1456469176000},{"_id":"themes/yelee/node_modules/verror/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1360175300000},{"_id":"themes/yelee/node_modules/util-deprecate/browser.js","shasum":"335965112d6117af8926dce4497a1fb9fca022eb","modified":1444242970000},{"_id":"themes/yelee/node_modules/verror/Makefile","shasum":"89b6506d72bcdd045b63921d0b754227f824c4f1","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/Makefile.targ","shasum":"f66e38899fc918aac830c478ae402c66d8793bc7","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/README.md","shasum":"94a2a13d3e722a3950176fa8ed55a1e7a7fd9d14","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/levels-verror.js","shasum":"f8e7f3d3dbce6e61b53ea2a49a63111d156cf18e","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/levels-werror.js","shasum":"e6d95f8c3af86fe246ef883197c28df6b4884eb6","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/varargs.js","shasum":"67c7570a5aa82ca71690b558a3f3d1d321a7508c","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/verror.js","shasum":"8513abb6a724947494c7513adfa27d76931488d6","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/werror.js","shasum":"10e842ef7ad2e6901398304c963c6ef1f44efcca","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/jsl.node.conf","shasum":"c9a618ebefdabda69fcf47f17406c254f7f07f9f","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/lib/verror.js","shasum":"def5538e73a39e2d14388970751c55e55f9b06fd","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/package.json","shasum":"8d6625aacdaaae976f5e0cd41753cadae4cce384","modified":1456469177000},{"_id":"themes/yelee/node_modules/verror/tests/tst.inherit.js","shasum":"298dabcdd9eff7081ee06a2b87e1118651190c9c","modified":1360175394000},{"_id":"themes/yelee/node_modules/verror/tests/tst.verror.js","shasum":"947c77e0a31ea025d156d9323d8a7283bf87871a","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/tests/tst.werror.js","shasum":"6b4007d450a8dfb9311ad86f44e3a7817fdeca53","modified":1360175420000},{"_id":"themes/yelee/node_modules/xtend/LICENCE","shasum":"c563ca2a6d330b98c2ca9473a0299c4a689bf6b8","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/Makefile","shasum":"bf249732a0985e13f60552c8a9d6c3894c8fbb44","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/README.md","shasum":"d7d6f2f31071911d99fef109646867a0b325c8a3","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/immutable.js","shasum":"3c1de57f8d038e3ebc9e1ab278fe2f683866079c","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/mutable.js","shasum":"0b00bff9bc925c6c258ef4afb77e7f50640e6555","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/package.json","shasum":"24993ffa5427ac6d9dd5ba1bb045283595aceda5","modified":1456469177000},{"_id":"themes/yelee/node_modules/xtend/test.js","shasum":"3b51ee9fb4c95c82be0bdde62dddb31f4c18e648","modified":1446502746000},{"_id":"themes/yelee/package.json","shasum":"8f03c577fc6e599142cb619f955180cbdc3a7f6c","modified":1456469185000},{"_id":"themes/yelee/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/archive.styl","shasum":"053c1684b6edaca7fa0c94a7f9fca637ccece2c2","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/article.styl","shasum":"174ccc6f83b81504f7e54d986196aa24f1d79eb8","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","shasum":"7e0853ec8a7767ca87ca54df62cc706de5f21553","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","shasum":"44f8a723085bcd4e7f8ae4851e4ecc46fd5a122d","modified":1459954303000},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","shasum":"d77c885024e48a20302e6b5066367e75f5b6fc5e","modified":1459954293000},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","shasum":"55cf30c47f0a124eb78d52f12b4ddb6aca9499a5","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/footer.styl","shasum":"2277125ef35f96a1ba76a1b84fc570526826453d","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/highlight.styl","shasum":"48f409828549190efedb9067dae0c6828a4d22b0","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/instagram.styl","shasum":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/main.styl","shasum":"65e18e08e6ce1db19d741d4094842131929a7e1b","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","shasum":"211a4286f60751c372090fa96f384521e2ce352c","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/mobile.styl","shasum":"6f2f78d5d5ba7e4e035f7ea3948b9e196b0b7136","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/page.styl","shasum":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/scroll.styl","shasum":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/post/youyan.styl","shasum":"ac2869e2e0fb3a1ee0df4b0c0a233a2b1923ea20","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/share.styl","shasum":"3cfc59278c21b504f8f633e08767a449e03af8d0","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","shasum":"ec9053b3b2ae962cb44b6f915701927e400e1dfe","modified":1456461572000},{"_id":"themes/yelee/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1456461572000},{"_id":"themes/yelee/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","shasum":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1456461572000},{"_id":"themes/yelee/source/css/_variables.styl","shasum":"16fdc983c47cdca385edbb5dc0da68f3d7d0f2e6","modified":1460086930000},{"_id":"themes/yelee/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1456461572000},{"_id":"themes/yelee/source/css/style.styl","shasum":"909c2aa1ce08cb891420852210c5c51a661339aa","modified":1460466296000},{"_id":"themes/yelee/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.css","shasum":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.pack.js","shasum":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.js","shasum":"004bb0812414554ab48067792f09e978603253b6","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/css/font-awesome.css","shasum":"b488600451227b445414796e9b8550e7c1bd6d29","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/css/font-awesome.min.css","shasum":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1456461572000},{"_id":"themes/yelee/source/img/GitHub.png","shasum":"08c955a91b6733bd51913b54c69fe742d546d0ec","modified":1456461572000},{"_id":"themes/yelee/source/img/SegmentFault.png","shasum":"52bd4ddf6df129b6958398b21fa370f17cadb428","modified":1456461572000},{"_id":"themes/yelee/source/img/TiddlyWiki.png","shasum":"58be3c981c6d25b47ddaab2f254838f9baa01d59","modified":1456461572000},{"_id":"themes/yelee/source/img/V2EX.png","shasum":"9adab6af95db9318e980c01cadbc5de800b4c816","modified":1456461572000},{"_id":"themes/yelee/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1456461572000},{"_id":"themes/yelee/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1456461572000},{"_id":"themes/yelee/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1456461572000},{"_id":"themes/yelee/source/img/favicon.png","shasum":"d939d7d97f2de43d8bd6bc28a97adf81eeac10c2","modified":1454763894000},{"_id":"themes/yelee/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1456461572000},{"_id":"themes/yelee/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1456461572000},{"_id":"themes/yelee/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1456461572000},{"_id":"themes/yelee/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1456461572000},{"_id":"themes/yelee/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1456461572000},{"_id":"themes/yelee/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1456461573000},{"_id":"themes/yelee/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1456461572000},{"_id":"themes/yelee/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1456461573000},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1456461573000},{"_id":"themes/yelee/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1456461573000},{"_id":"themes/yelee/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1456461573000},{"_id":"themes/yelee/source/img/新浪微博.png","shasum":"c9fb558158f491104fd8dbafc92c30591ad0299e","modified":1456461573000},{"_id":"themes/yelee/source/img/知乎.png","shasum":"50e43bad8fefb3950b13dc86aaa86de8a79432ae","modified":1456461573000},{"_id":"themes/yelee/source/img/简书.png","shasum":"bfe5e7b6146de19d180f36fa5a2b074c2bc23406","modified":1456461573000},{"_id":"themes/yelee/source/img/网易云音乐.png","shasum":"8bc2a2e2c4312ee9d4879b24f9e2bd51e6436840","modified":1456461573000},{"_id":"themes/yelee/source/img/虾米音乐.png","shasum":"d3ff836d5d58e10fb30fac1bae0aae34cfe2038f","modified":1456461573000},{"_id":"themes/yelee/source/img/豆瓣.png","shasum":"9f4798298548727052fa6ae809933c9e8ac42571","modified":1456461573000},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","shasum":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1456461573000},{"_id":"themes/yelee/source/js/clipboard.min.js","shasum":"c13b4bb8fee46447284590d2afc0efca0ea3cb7b","modified":1456461573000},{"_id":"themes/yelee/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1456461573000},{"_id":"themes/yelee/source/js/jquery.lazyload.js","shasum":"9c34c37b4dca82386648d364da913153d1db902e","modified":1456461573000},{"_id":"themes/yelee/source/js/main.js","shasum":"b626dd0c971c4e7bb725511c591a54fffff6b191","modified":1456634620000},{"_id":"themes/yelee/source/js/mobile.js","shasum":"baed8d560883c842c2b8c3e0fadcf359f97140d0","modified":1456461573000},{"_id":"themes/yelee/source/js/pc.js","shasum":"188915f13cec49c2bdca9ffdc377adbc5bed24e8","modified":1456461573000},{"_id":"themes/yelee/node_modules/bluebird/js/browser/bluebird.min.js","shasum":"7983e7650a5be5d5636815f8477c685d966e0c3a","modified":1443731946000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/images/logo.png","shasum":"7b9844914960e180d2f243d74a50f2b4fa23fbdb","modified":1447968927000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/index.js","shasum":"f9112be27168572ac86d62b7abfdfbf94661c8b6","modified":1442857555000},{"_id":"themes/yelee/node_modules/hawk/images/logo.png","shasum":"7b9844914960e180d2f243d74a50f2b4fa23fbdb","modified":1447968927000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/browser/bluebird.core.js","shasum":"89a00d6c3140f573a30dae5f71348ebf6749f1bf","modified":1456440962000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/browser/bluebird.min.js","shasum":"44e4280b7ed053e20d71beb1ce1ec5efe0ff644d","modified":1456440966000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mathematica.js","shasum":"aa8237d4cfb20b0aa38860dd9d3d8dc2f2755089","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/autoit.js","shasum":"b5a7f4bc8fe5166e547b8178d8b036bb4e24c0a4","modified":1445295322000},{"_id":"themes/yelee/node_modules/hoek/test/index.js","shasum":"f9112be27168572ac86d62b7abfdfbf94661c8b6","modified":1442857555000},{"_id":"themes/yelee/node_modules/nan/nan.h","shasum":"6658ef10fe1b0f3d6cf3b31221f3c7bb4eb05899","modified":1452351065000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.eot","shasum":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/fonts/FontAwesome.otf","shasum":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.woff","shasum":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"638c652d623280a58144f93e7b552c66d1667a11","modified":1456461572000},{"_id":"themes/yelee/node_modules/bluebird/js/browser/bluebird.js","shasum":"2659d8978645301ec08c0e379bdd68ac2b0d008f","modified":1443731946000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/db.json","shasum":"79ce354a3bd34e49cea2d742e789d154d3c446e7","modified":1452093795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/pubsuffix.js","shasum":"56aac14d8b2dcacfe05e3447a6e4bf9dff2fa0d9","modified":1443808008000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/browser/bluebird.js","shasum":"3cc9f4a20a63f6544b2199df43aba1f233c449b1","modified":1456440966000},{"_id":"themes/yelee/node_modules/mime-db/db.json","shasum":"e939c0dbc4ece9e04a3a36bcab40a544d32d7ad5","modified":1455558380000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/pubsuffix.js","shasum":"56aac14d8b2dcacfe05e3447a6e4bf9dff2fa0d9","modified":1443808008000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1456461572000},{"_id":"themes/yelee/source/background/bg-528.jpg","shasum":"d0441d582f601fd5cdeb0212c2f8245866f623d7","modified":1456746793000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.svg","shasum":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1456461572000},{"_id":"themes/yelee/source/background/bg-0.jpg","shasum":"5b3de75c262333f42c064d391fb659d3d08c3294","modified":1456475869000},{"_id":"themes/yelee/source/apple-touch-icon.png","shasum":"34d23362b3cacda441e45bf43f0ca2ad2fbe39d4","modified":1457741932000},{"_id":"themes/yelee/source/img/avatar.png","shasum":"34d23362b3cacda441e45bf43f0ca2ad2fbe39d4","modified":1456461838000},{"_id":"public/js/pc.js","modified":1463142681175,"shasum":"b87be014e501a14329bac4f443dfb47375205e19"},{"_id":"public/js/mobile.js","modified":1463142681185,"shasum":"d3847e5bcaf39108931724ecb02770c62b10889f"},{"_id":"public/js/main.js","modified":1463142681188,"shasum":"6d7f1c932c58f0bd17e393a2c4c9a18d48af1b50"},{"_id":"public/js/jquery.lazyload.js","modified":1463142681190,"shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799"},{"_id":"public/js/instagram.js","modified":1463142681191,"shasum":"f19adbcc0dac33536bc6660598059048ec901882"},{"_id":"public/js/clipboard.min.js","modified":1463142681193,"shasum":"c13b4bb8fee46447284590d2afc0efca0ea3cb7b"},{"_id":"public/js/GithubRepoWidget.js","modified":1463142681195,"shasum":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df"},{"_id":"public/img/豆瓣.png","modified":1463142681200,"shasum":"9f4798298548727052fa6ae809933c9e8ac42571"},{"_id":"public/img/虾米音乐.png","modified":1463142681203,"shasum":"d3ff836d5d58e10fb30fac1bae0aae34cfe2038f"},{"_id":"public/img/网易云音乐.png","modified":1463142681206,"shasum":"8bc2a2e2c4312ee9d4879b24f9e2bd51e6436840"},{"_id":"public/img/简书.png","modified":1463142681208,"shasum":"bfe5e7b6146de19d180f36fa5a2b074c2bc23406"},{"_id":"public/img/知乎.png","modified":1463142681210,"shasum":"50e43bad8fefb3950b13dc86aaa86de8a79432ae"},{"_id":"public/img/新浪微博.png","modified":1463142681213,"shasum":"c9fb558158f491104fd8dbafc92c30591ad0299e"},{"_id":"public/img/twitter.png","modified":1463142681215,"shasum":"14dbb8e62d056525253bc0de13acd1723da7a934"},{"_id":"public/img/stackoverflow.png","modified":1463142681218,"shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2"},{"_id":"public/img/scrollbar_arrow.png","modified":1463142681220,"shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0"},{"_id":"public/img/rss.png","modified":1463142681223,"shasum":"430fd47340e75214c081abd05cd7410cf7c71b86"},{"_id":"public/img/pinterest.png","modified":1463142681225,"shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630"},{"_id":"public/img/pinboard.png","modified":1463142681226,"shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0"},{"_id":"public/img/mail.png","modified":1463142681228,"shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7"},{"_id":"public/img/linkedin.png","modified":1463142681232,"shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c"},{"_id":"public/img/img-loading.png","modified":1463142681236,"shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031"},{"_id":"public/img/img-err.png","modified":1463142681238,"shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b"},{"_id":"public/img/google.png","modified":1463142681242,"shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d"},{"_id":"public/img/favicon.png","modified":1463142681245,"shasum":"d939d7d97f2de43d8bd6bc28a97adf81eeac10c2"},{"_id":"public/img/facebook.png","modified":1463142681251,"shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54"},{"_id":"public/img/delicious.png","modified":1463142681255,"shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd"},{"_id":"public/img/coderwall.png","modified":1463142681262,"shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331"},{"_id":"public/img/avatar.png","modified":1463142681279,"shasum":"34d23362b3cacda441e45bf43f0ca2ad2fbe39d4"},{"_id":"public/img/V2EX.png","modified":1463142681292,"shasum":"9adab6af95db9318e980c01cadbc5de800b4c816"},{"_id":"public/img/TiddlyWiki.png","modified":1463142681297,"shasum":"58be3c981c6d25b47ddaab2f254838f9baa01d59"},{"_id":"public/img/SegmentFault.png","modified":1463142681301,"shasum":"52bd4ddf6df129b6958398b21fa370f17cadb428"},{"_id":"public/img/GitHub.png","modified":1463142681303,"shasum":"08c955a91b6733bd51913b54c69fe742d546d0ec"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff2","modified":1463142681309,"shasum":"638c652d623280a58144f93e7b552c66d1667a11"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff","modified":1463142681312,"shasum":"4a313eb93b959cc4154c684b915b0a31ddb68d84"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.ttf","modified":1463142681316,"shasum":"6484f1af6b485d5096b71b344e67f4164c33dd1f"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.svg","modified":1463142681321,"shasum":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.eot","modified":1463142681331,"shasum":"986eed8dca049714e43eeebcb3932741a4bec76d"},{"_id":"public/font-awesome/fonts/FontAwesome.otf","modified":1463142681334,"shasum":"42c179eef588854b5ec151bcf6a3f58aa8b79b11"},{"_id":"public/font-awesome/css/font-awesome.min.css","modified":1463142681338,"shasum":"12d6861075de8e293265ff6ff03b1f3adcb44c76"},{"_id":"public/font-awesome/css/font-awesome.css","modified":1463142681342,"shasum":"b488600451227b445414796e9b8550e7c1bd6d29"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1463142681344,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1463142681347,"shasum":"a82597493d75ea989ca586e09173cff332efe41e"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1463142681349,"shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1463142681350,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1463142681352,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1463142681354,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1463142681355,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1463142681357,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1463142681358,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1463142681360,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1463142681364,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1463142681366,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1463142681370,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1463142681375,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1463142681380,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1463142682462,"shasum":"d6e1491e34f371ba09cde6ecf0d8b451a01ea596"},{"_id":"public/background/bg-528.jpg","modified":1463142682769,"shasum":"d0441d582f601fd5cdeb0212c2f8245866f623d7"},{"_id":"public/background/bg-0.jpg","modified":1463142682772,"shasum":"5b3de75c262333f42c064d391fb659d3d08c3294"},{"_id":"public/apple-touch-icon.png","modified":1463142682790,"shasum":"34d23362b3cacda441e45bf43f0ca2ad2fbe39d4"},{"_id":"public/virtualbox-archlinux/hotkey.png","modified":1463142682797,"shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426"},{"_id":"public/virtualbox-archlinux/network.png","modified":1463142682801,"shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2"},{"_id":"public/virtualbox-archlinux/port.png","modified":1463142682806,"shasum":"bb684dd8b616413e3e0e27c5efce118249a54113"},{"_id":"public/virtualbox-archlinux/screenfetch.png","modified":1463142682812,"shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d"},{"_id":"public/virtualbox-archlinux/share.png","modified":1463142682817,"shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8"},{"_id":"public/virtualbox-archlinux/terminal.png","modified":1463142682822,"shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426"},{"_id":"public/uva-11538/cells.png","modified":1463142682833,"shasum":"3a162829c312a17639950c3620cd70799ed94a49"},{"_id":"public/splay-notes-1/splay.png","modified":1463142682837,"shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13"},{"_id":"public/sdoi2016-game/line.png","modified":1463142682844,"shasum":"30c24e553938d2c27b55779527825b2577088a7c"},{"_id":"public/sdoi2016-game/tree.png","modified":1463142682846,"shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86"},{"_id":"public/osx-softwares/dropbox.png","modified":1463142682849,"shasum":"c57885f99a5af62b94eb53a510edbc2faab47e7b"},{"_id":"public/osx-softwares/feeluown.png","modified":1463142682852,"shasum":"70c4a0b923c3d8688d64f0036ec09d34d214a7eb"},{"_id":"public/osx-softwares/fileroller.png","modified":1463142682857,"shasum":"9bf831aec4309e525791f286c346a447c6605acd"},{"_id":"public/osx-softwares/flashlight.png","modified":1463142682862,"shasum":"c251a90415340d44655c18461ed5b186167cd03a"},{"_id":"public/osx-softwares/gimp.png","modified":1463142682880,"shasum":"8d1f18af30cbe2639375bc13d993d81894d916ab"},{"_id":"public/osx-softwares/go2shell.png","modified":1463142682886,"shasum":"538be85641e7b95ec18bf577ac1353d757637817"},{"_id":"public/osx-softwares/karabiner.png","modified":1463142682891,"shasum":"0b24e2252a00f402e681a6dd84a679a4be9706be"},{"_id":"public/osx-softwares/libreoffice-writer.png","modified":1463142682897,"shasum":"f0e740eef5a31433f798a9ab689bca320b3ec05f"},{"_id":"public/osx-softwares/macdown.png","modified":1463142682905,"shasum":"f655bf9258ec412c856078653aadac847f69bd08"},{"_id":"public/osx-softwares/macvim.png","modified":1463142682914,"shasum":"550e044c4af938acbd373649bacff7dd4f020f8c"},{"_id":"public/osx-softwares/shadowsocksx.png","modified":1463142682919,"shasum":"e4d6e7dac5744d19d5303ba13b3f8411953a0427"},{"_id":"public/osx-softwares/teamviewer.png","modified":1463142682922,"shasum":"c9c00c296ccdc4c234cc945bc6b3653e9742797f"},{"_id":"public/osx-softwares/virtualbox.png","modified":1463142682927,"shasum":"7401b6a6f6543356234d9ecbaa5fd8026455ead4"},{"_id":"public/osx-softwares/vlc.png","modified":1463142682931,"shasum":"395a973310d204c78cdefb9da9929c3892479b73"},{"_id":"public/osx-enable-retina/plist-edit.png","modified":1463142682942,"shasum":"94dd75a8fba5775cd97fcc5cc9f917f5bba40061"},{"_id":"public/cut-tree-notes/cutTree.png","modified":1463142682946,"shasum":"12de28c1f402f876a3826dcd7bfc8525d555ce1e"},{"_id":"public/bzoj-2683/cdq.png","modified":1463142682949,"shasum":"a95d0b02b915f092df6656298add0f0fc9662341"},{"_id":"public/after-ah-studying/one-day.png","modified":1463142682954,"shasum":"824cb9e48257574a779122dfe9825fc94944bef8"},{"_id":"public/friends/index.html","modified":1463543938921,"shasum":"77e0b776203acb0a801cf6bcbeca8ecb753c92bf"},{"_id":"public/about-me/index.html","modified":1463543938954,"shasum":"51d9cb1909300672d6d13079f14abd39ddf24e19"},{"_id":"public/apio2010-commando/index.html","modified":1463543939031,"shasum":"302584c6b702228b8a6f56035ca425e09ea60786"},{"_id":"public/hdu-5632/index.html","modified":1463543939081,"shasum":"144eb5963ee8d9769245d689c42f68fc69db8e79"},{"_id":"public/scoi2009-windy/index.html","modified":1463543939102,"shasum":"b9bde6943258c568906029b074fdb9479ccec782"},{"_id":"public/cf-628d/index.html","modified":1463543939140,"shasum":"30e7f7c9509c19274860dc938eceeebd7442035c"},{"_id":"public/hdu-2089/index.html","modified":1463543939164,"shasum":"5741b1726fc45b4af672c3ed715cdb411e32e3b1"},{"_id":"public/hdu-5642/index.html","modified":1463543939186,"shasum":"0f13c7f33425622a1a0a29e644616e07fd5375a3"},{"_id":"public/chairman-tree-notes/index.html","modified":1463543939211,"shasum":"3a1b0966d320cd39dff447771ebedab94833c087"},{"_id":"public/hnoi2016-tree/index.html","modified":1463543939259,"shasum":"326e7e8e7b5e6f6549ed7e7d38cabee9d0d5e2ee"},{"_id":"public/hnoi2016-network/index.html","modified":1463543939289,"shasum":"e53096dfe4e2943c9cd37096d636dd6e5b38e5c9"},{"_id":"public/hnoi2016-multiple/index.html","modified":1463543939334,"shasum":"2b8f993b7e3d850689d8cd6859e63d631fe2831f"},{"_id":"public/ctsc-apio-2016/index.html","modified":1463543939372,"shasum":"04f9ac492b8e8fc750631210c928c556ee851e63"},{"_id":"public/mo-algorithm-notes/index.html","modified":1463543939418,"shasum":"fb5d54b6b728f3744ba5198d854d1b450ed57f0b"},{"_id":"public/hnoi2016-sequence/index.html","modified":1463543939467,"shasum":"14a4bfd3f3230618fcc43f3371e856db4f8dfbd0"},{"_id":"public/haoi2016-chain/index.html","modified":1463543939499,"shasum":"21acabeede193a758915d35c13791c6cd6772077"},{"_id":"public/jsoi2009-game/index.html","modified":1463543939541,"shasum":"bd2d29bda4a159c33d686c5eec5f877ee9490ddb"},{"_id":"public/hnoi2008-toy/index.html","modified":1463543939582,"shasum":"4952fc9a4122be9d5f4f6e2adfa7f5cd1286bdf4"},{"_id":"public/jsoi2016-flight/index.html","modified":1463543939617,"shasum":"191009beb754dc418c66fc2b23261cac12dfe6e9"},{"_id":"public/20160423-tsc-season-2/index.html","modified":1463543939639,"shasum":"b262e408f94495952b4ab1666245484a8ffdef68"},{"_id":"public/cqoi2016-number/index.html","modified":1463543939673,"shasum":"badb9efb21be6ee44e468d9f28e3d7d8a01e221d"},{"_id":"public/cqoi2016-cuts/index.html","modified":1463543939713,"shasum":"bf96be59b15ece9b71e4344b3b27606271057396"},{"_id":"public/jsoi2016-light/index.html","modified":1463543939757,"shasum":"93c36481bc82db59bf6eb6095ad0bea34964f0c8"},{"_id":"public/sdoi2016-table/index.html","modified":1463543939794,"shasum":"d6e5b5808d9c812c6d7d7f8bc00779e1d3ad95e9"},{"_id":"public/sdoi2016-journey/index.html","modified":1463543939828,"shasum":"3ce785d38d5e1de803e084a6f4628f554206468c"},{"_id":"public/sdoi2016-game/index.html","modified":1463543939879,"shasum":"fd080a2408f2f8ad8fc67c4bf1b3e7f7ec558a79"},{"_id":"public/derangement-number/index.html","modified":1463543939914,"shasum":"2896248016a24b177999d7cdfcd25064bf0a6872"},{"_id":"public/mul-inverse/index.html","modified":1463543939951,"shasum":"13072bc00d66560cc152e7d8818c15e8ae33fb05"},{"_id":"public/sdoi2016-permutation/index.html","modified":1463543939992,"shasum":"dfa9486b1d4d25c97fe0c4ba472ac6dfc12ff0b5"},{"_id":"public/sdoi2016-incantation/index.html","modified":1463543940058,"shasum":"352b7af598879b86f5e556a3ab7533bc6b78d193"},{"_id":"public/spoj-694/index.html","modified":1463543940084,"shasum":"bce23b689500f0c4e0bdf39a2b69db996acb766a"},{"_id":"public/suffix-array-notes/index.html","modified":1463543940135,"shasum":"4803b3b095c78ae3490541e7c6936996609d3b23"},{"_id":"public/20160410-tsc-season/index.html","modified":1463543940154,"shasum":"c2901966f44de453b8fd1eaf278c258958bfec68"},{"_id":"public/sdoi2016-round1/index.html","modified":1463543940180,"shasum":"8a00c9d3db2cce33f7dedc39e97e25b7a3a50c23"},{"_id":"public/poj-3461/index.html","modified":1463543940202,"shasum":"8a878d1a697d99b368f4a24124c9da23ecf50bbe"},{"_id":"public/sdoi2016-pair/index.html","modified":1463543940252,"shasum":"98efbc8c448e08f91a78534b61d2a6e04886d0b1"},{"_id":"public/bzoj-4403/index.html","modified":1463543940297,"shasum":"f1a29ab91868d8447679bd4657993c671fed4a8c"},{"_id":"public/ahoi2014-story/index.html","modified":1463543940341,"shasum":"4f5d5ff858dfab216a46872680426fa4a1e48f5b"},{"_id":"public/non-recursion-dfs-with-stack/index.html","modified":1463543940400,"shasum":"03bc2114490bd4acaf6d6a70e8f69f998d4de850"},{"_id":"public/euler-sieve/index.html","modified":1463543940465,"shasum":"dfa50f26bfbc47d4eadf197ec8fa08cf5e02fe89"},{"_id":"public/haoi2011-problemb/index.html","modified":1463543940552,"shasum":"491439ab7803282820ebab43f37c58a4f4a2f1c4"},{"_id":"public/bzoj-2820/index.html","modified":1463543940603,"shasum":"24ceeed02c65a383045cebefa539fdfed2b1b9a2"},{"_id":"public/after-ah-studying/index.html","modified":1463543940659,"shasum":"d1c6e503c647d82aaffe16bf84c8656d19e1b9a0"},{"_id":"public/bzoj-3511/index.html","modified":1463543940697,"shasum":"cd15ae4db6796c129a9eba3bbd6514caee3a342e"},{"_id":"public/bzoj-1008/index.html","modified":1463543940718,"shasum":"4d9a4476057c2557218dcb0cc2cca37a929700ae"},{"_id":"public/20160404-theory/index.html","modified":1463543940762,"shasum":"c1d1b8f06cc62e88f5c83c9b658b90354ef808df"},{"_id":"public/tjoi2015-lis/index.html","modified":1463543940790,"shasum":"40a4ee10c035745ce6275447279b6e25bc182426"},{"_id":"public/bzoj-1001/index.html","modified":1463543940822,"shasum":"dc896ecc935e32a23fd1150d888f6c8eb377f53f"},{"_id":"public/noi2014-sleep/index.html","modified":1463543940845,"shasum":"1880c3170c1014e64338910986e4d594a271aaac"},{"_id":"public/haoi2015-t2/index.html","modified":1463543940871,"shasum":"d1e8a41cd827f92b59d62b7a08a33d1820c75ef2"},{"_id":"public/bzoj-2296/index.html","modified":1463543940893,"shasum":"e20ea040a6b71d44995a482018974bc314bae5e2"},{"_id":"public/bzoj-2038/index.html","modified":1463543940916,"shasum":"981630466c0727aaacc3f8b41329e4329e760486"},{"_id":"public/20160331-naive/index.html","modified":1463543940954,"shasum":"1864ce11aae144fa4da24761fe3b6970c28697c4"},{"_id":"public/scoi2015-password/index.html","modified":1463543941010,"shasum":"32f9034784e7223d99243e608c0d65408b24f4bd"},{"_id":"public/scoi2015-light/index.html","modified":1463543941053,"shasum":"9dd124e8ead59b13b747c35d7303ce0fa5633f1f"},{"_id":"public/bzoj-2143/index.html","modified":1463543941084,"shasum":"ee964cfcdb1eaf9fd25f427fc93f3df4810dfc10"},{"_id":"public/scoi2015-flag/index.html","modified":1463543941120,"shasum":"b04ba512df8399f5940fc49f994c78d602f2eb41"},{"_id":"public/scoi2015-message/index.html","modified":1463543941154,"shasum":"5fa2d5ca1bb8466c0a04cf9cf0df853d799148d6"},{"_id":"public/scoi2015-matrix/index.html","modified":1463543941186,"shasum":"bef36b908c4400eb24cc71cf5850f4059eb37e9b"},{"_id":"public/20160318-color/index.html","modified":1463543941220,"shasum":"79f1d9bedfd6ca502a8abb7035c9fd06cb0e7255"},{"_id":"public/20160319-candy/index.html","modified":1463543941263,"shasum":"32171676d33d677eb3d1693c813af557afb01d24"},{"_id":"public/20160319-set/index.html","modified":1463543941293,"shasum":"b555080ba63f091a65c7c045063353b581ba9fd7"},{"_id":"public/osx-enable-retina/index.html","modified":1463543941325,"shasum":"bd80ced0da7a691dc05c5d97ac5f86961ee118da"},{"_id":"public/sdoi2008-cave/index.html","modified":1463543941355,"shasum":"8ce1f137e0992500549d17efc8cb5cabc02a6acb"},{"_id":"public/combinatorics-notes/index.html","modified":1463543941385,"shasum":"072cb26a2a8f9242c4fe76965e3afbe4c9f9a210"},{"_id":"public/uva-10253/index.html","modified":1463543941419,"shasum":"fe8da60dac86a049ca2d4fc6470f8fec40b543ed"},{"_id":"public/uva-11361/index.html","modified":1463543941449,"shasum":"92b668a5ed6df922b1e20886caa83911cd5cb2ad"},{"_id":"public/bigint-template/index.html","modified":1463543941471,"shasum":"3294f4aaafbdec5dff3f1a75357dd923bf655aac"},{"_id":"public/uva-1362/index.html","modified":1463543941499,"shasum":"55f9bf5b6197dc8e6341a3c35cb440245d0ba346"},{"_id":"public/poj-1737/index.html","modified":1463543941531,"shasum":"ac60e402d615ace8d345664151bae5390e2d51e5"},{"_id":"public/osx-softwares/index.html","modified":1463543941562,"shasum":"adb4bbbd11dc33c6746189a0acd12e26457f4fe8"},{"_id":"public/uva-11174/index.html","modified":1463543941588,"shasum":"9b89d88eaf4399ab19addab8db93b9e14bf43161"},{"_id":"public/uva-11137/index.html","modified":1463543941618,"shasum":"a3486213b8c7d315833ef8301c67308afc01d9e3"},{"_id":"public/uva-11375/index.html","modified":1463543941640,"shasum":"3c956edd87e1f3eb0f532d4ea0a77886388299a0"},{"_id":"public/uva-11538/index.html","modified":1463543941664,"shasum":"4315556e1cd4280a6c386251f7cc2482167e383d"},{"_id":"public/uva-11806/index.html","modified":1463543941698,"shasum":"916515c4f4e95598a13cec92a541d2d8f9a1dc85"},{"_id":"public/poj-2728/index.html","modified":1463543941729,"shasum":"007cfc44e0eb07ddd567638e7beb4b21c016c67b"},{"_id":"public/apio2009-atm/index.html","modified":1463543941762,"shasum":"6f427044292b899b36435930e49cd71e49ec7c3a"},{"_id":"public/noi2006-profit/index.html","modified":1463543941796,"shasum":"0ae384d51c2f577f30c3a6a7c05ffdd26254d58d"},{"_id":"public/scoi2007-repair/index.html","modified":1463543941824,"shasum":"9f67a409fffd0733119675db9965b17f84232907"},{"_id":"public/ahoi2008-meet/index.html","modified":1463543941866,"shasum":"836a5cc14f347f1002eba4e3773ef9b6462e0e2e"},{"_id":"public/scoi2010-game/index.html","modified":1463543941895,"shasum":"898689b6c8ae30b0708601df1e037ed99c932772"},{"_id":"public/virtualbox-archlinux/index.html","modified":1463543941919,"shasum":"956c8d16b994297d452106796f5c04cc5fe181c1"},{"_id":"public/noi2003-editor/index.html","modified":1463543941955,"shasum":"a1375aa79faf2565f1dc03d9e4f9b18e9035e112"},{"_id":"public/scoi2011-candy/index.html","modified":1463543941997,"shasum":"bd3a006a62656f7f6e28dc2ed5f81ab9da095def"},{"_id":"public/haoi2006-cow/index.html","modified":1463543942032,"shasum":"81116ade1a1f5e9c0af9a71e5fc35243c259cb31"},{"_id":"public/codevs-2822/index.html","modified":1463543942064,"shasum":"7981b7efc34362308a36e4c2e578f82ba55a5332"},{"_id":"public/tarjan-scc-notes/index.html","modified":1463543942086,"shasum":"8f7fd09adaab83075554f6d820dace52646c41cb"},{"_id":"public/sdoi2010-starrace/index.html","modified":1463543942122,"shasum":"c6ca24a07c5f847f42e0e09e749dc2716f224b47"},{"_id":"public/sdoi2015-war/index.html","modified":1463543942150,"shasum":"42235a20be6e864fb4729d10b8db105aceaf80d3"},{"_id":"public/cogs-741/index.html","modified":1463543942180,"shasum":"2a90e5a4c7d8a884102ea8240390520cb52a7a06"},{"_id":"public/cogs-740/index.html","modified":1463543942207,"shasum":"e3fe4cd20aee6f9cd2e2d5ef82b30f537885ef3c"},{"_id":"public/ctsc1999-home/index.html","modified":1463543942252,"shasum":"23ee9ac04b5866b1bd18b29809f8589235fab5b2"},{"_id":"public/cogs-742/index.html","modified":1463543942283,"shasum":"fd61b127278e3c8efc0cd2f91244dadf521aa788"},{"_id":"public/cogs-739/index.html","modified":1463543942325,"shasum":"4b99a98ab80f1e926ab1734798dafabc6df9437a"},{"_id":"public/jsoi2008-maxnumber/index.html","modified":1463543942373,"shasum":"9bd8d50b3954ceb551f5e8d97b85e891df918688"},{"_id":"public/edmonds-karp-notes/index.html","modified":1463543942416,"shasum":"7345662ebd0d5be0d7e75ce8b0f4ea17c03a0ff1"},{"_id":"public/noip2010-prison/index.html","modified":1463543942471,"shasum":"52add6d6b0884f463697ea32ea86295d3fe15517"},{"_id":"public/cogs-746/index.html","modified":1463543942524,"shasum":"65181fc84b884f39bb404b2a6007ba95b0deb391"},{"_id":"public/cogs-738/index.html","modified":1463543942561,"shasum":"4ac388601faacee53b6af16e6efc4e699eecf3d9"},{"_id":"public/cogs-734/index.html","modified":1463543942595,"shasum":"2fde6144c9c52d632b41025a131a76fb0df9d7b8"},{"_id":"public/cogs-439/index.html","modified":1463543942634,"shasum":"a258372a05e6a1b00d2c5a2e8f6e31f2f3b3c418"},{"_id":"public/cogs-727/index.html","modified":1463543942670,"shasum":"08e62a3370fc0916b3620295be624dba9156e553"},{"_id":"public/cogs-731/index.html","modified":1463543942703,"shasum":"023129d9d971088b00a56c367e75908da703b0db"},{"_id":"public/cogs-729/index.html","modified":1463543942734,"shasum":"112b17226799ae6c8c88a3161788e9b8c0cf462c"},{"_id":"public/cogs-396/index.html","modified":1463543942765,"shasum":"a235566e65435553657adf49c1c891a06c181681"},{"_id":"public/cogs-728/index.html","modified":1463543942797,"shasum":"04e97a73eb2d80ba96ac4e3a25827a38b90f4c0a"},{"_id":"public/cogs-14/index.html","modified":1463543942828,"shasum":"63d4a2ed37514a44deaf906a977d7c28df4bdebf"},{"_id":"public/bzoj-2683/index.html","modified":1463543942857,"shasum":"2e61fa12723b2039b8447bd39ecb27394aec2a15"},{"_id":"public/codevs-1563/index.html","modified":1463543942890,"shasum":"9216e2ed102a0d11002c26fe835b4cd607329922"},{"_id":"public/gnu-debugger/index.html","modified":1463543942932,"shasum":"766236ed8713cb3edf562e24b636836bdbd93505"},{"_id":"public/dinic-notes/index.html","modified":1463543942964,"shasum":"7592c7d5cdaf78f61daeebd41226684fb980a996"},{"_id":"public/markdown-latex-helper/index.html","modified":1463543942985,"shasum":"ac63809a8d6e7de52647ea5574b5188dd98fbe0c"},{"_id":"public/bzoj-1756/index.html","modified":1463543943015,"shasum":"d7e2aea1ab379ec918d7898963bcd05b08586af9"},{"_id":"public/noi2004-cashier/index.html","modified":1463543943067,"shasum":"37835cacd6e10bf05f55727ca0ffeb027ab0d23c"},{"_id":"public/bzoj-1477/index.html","modified":1463543943091,"shasum":"69475e54e0ea4d0251aa90c078d3d4dff60d8e5b"},{"_id":"public/noi2015-manager/index.html","modified":1463543943135,"shasum":"d12097dc9cab05a3bd2b4c05369192a765eb8f64"},{"_id":"public/noi2015-prog/index.html","modified":1463543943168,"shasum":"5517438500c5507a1fe5b713284e574ff61a8533"},{"_id":"public/number-theory-notes-1/index.html","modified":1463543943203,"shasum":"3c8ff34d0cbbd61f1443c25f445bcd98169a1b13"},{"_id":"public/noip2012-mod/index.html","modified":1463543943223,"shasum":"1646fda3e2565d7058c9ef9bf1059afb2a4b33c7"},{"_id":"public/link-cut-tree-notes/index.html","modified":1463543943267,"shasum":"2570ac01c016ef7710ecbe1c18235237c890c34a"},{"_id":"public/splay-notes-3/index.html","modified":1463543943313,"shasum":"030e20e30d577891b0711153accf269bd9b0947a"},{"_id":"public/bzoj-1251/index.html","modified":1463543943343,"shasum":"082e9c6e579a87554686e1c3fe0252d5887bddaf"},{"_id":"public/noip2006-budget/index.html","modified":1463543943366,"shasum":"745eeb42802395996b00c825f6a36419632e8707"},{"_id":"public/bzoj-2442/index.html","modified":1463543943394,"shasum":"ce6c7eaa96c057fc7dcdb137246f3bafdc7edb10"},{"_id":"public/codevs-3269-monotone-queue/index.html","modified":1463543943424,"shasum":"5b060852705285c42fb12b8ea9b80bb9fd0a0e91"},{"_id":"public/monotone-queue-notes/index.html","modified":1463543943458,"shasum":"6d8f29b11a07b09a5c6467b08741cf45a35e3371"},{"_id":"public/codevs-1345/index.html","modified":1463543943491,"shasum":"dd6df9011b476418f3a75dd18b95c312438f37e7"},{"_id":"public/noip2003-game/index.html","modified":1463543943548,"shasum":"3f25aa1386da19f0fbdc78e94afde1ca84d31596"},{"_id":"public/noip2006-energy/index.html","modified":1463543943598,"shasum":"4a213fc005400ce1d85d2a0b561a7f3acd806716"},{"_id":"public/tyvj-3317/index.html","modified":1463543943662,"shasum":"cc95e83374523f52fe4e23f0f4db4ecf90888d93"},{"_id":"public/codevs-2598/index.html","modified":1463543943704,"shasum":"d36a8dfe426b6a846671314896b643bb63b8b204"},{"_id":"public/noip2000-cheng-ji-zui-da/index.html","modified":1463543943747,"shasum":"b0e5a16bc0a91413abe8b08b27170c77bdfac109"},{"_id":"public/ctsc1997-course/index.html","modified":1463543943774,"shasum":"f9b9be2fe04ab60c06fe4ed55fb408dd1a2be1e8"},{"_id":"public/codevs-3168-3162/index.html","modified":1463543943818,"shasum":"0f97a4f0f65f7558e8d2756e7ac4ef3b0e5daffe"},{"_id":"public/minimum-spanning-tree-notes/index.html","modified":1463543943872,"shasum":"fe938682290f928aeab154a6b7285d792db81e75"},{"_id":"public/system-of-difference-constraints-notes/index.html","modified":1463543943892,"shasum":"6693042dede59a5e9fc5a391ff4c49e808f0e0cc"},{"_id":"public/kmp-notes/index.html","modified":1463543943932,"shasum":"f2e898d1b1be27224a23784dfedcff1226b6f066"},{"_id":"public/cut-tree-notes/index.html","modified":1463543943983,"shasum":"e2dff6d23ca86bc7215450cbb038bb1c640e4ff2"},{"_id":"public/stl-in-oi/index.html","modified":1463543944039,"shasum":"1044767e687ecc3d58394e6192314fd4d08739bb"},{"_id":"public/splay-notes-2/index.html","modified":1463543944090,"shasum":"dfce4e43482f000b502538699ca11f494127797a"},{"_id":"public/splay-notes-1/index.html","modified":1463543944167,"shasum":"03820aa59c68edaaa20025138e0990e6ff8c117b"},{"_id":"public/hnoi2004-pet/index.html","modified":1463543944196,"shasum":"bdfe0ec4396c453313a3d52becca06b070838cd4"},{"_id":"public/codevs-3269/index.html","modified":1463543944232,"shasum":"215ef4c3ffa69a7ffcea119ae419471e9c85081e"},{"_id":"public/noi2002-galaxy/index.html","modified":1463543944263,"shasum":"b65e55c8e6735d37edfbdde2c63d82eae8867596"},{"_id":"public/archives/index.html","modified":1463543944316,"shasum":"2590b67d4106d597022cd7bc068a9dfe40107b6a"},{"_id":"public/archives/page/2/index.html","modified":1463543944359,"shasum":"185e21ec369bf06da29275412d33a3d888f9975b"},{"_id":"public/archives/page/3/index.html","modified":1463543944419,"shasum":"f30aa073308b0b1dd888ddb1bcf3fb4bbef7ddd1"},{"_id":"public/archives/page/4/index.html","modified":1463543944480,"shasum":"3fab17321a648374460b30af6812cc05d3aa9082"},{"_id":"public/archives/page/5/index.html","modified":1463543944534,"shasum":"17a884c8aba6ccc306ed6b39aaafc708cbe678e3"},{"_id":"public/archives/page/6/index.html","modified":1463543944565,"shasum":"6471cf96a158c3ea7ec43e8869110d6583ec98d7"},{"_id":"public/archives/page/7/index.html","modified":1463543944594,"shasum":"ade12a7ee614a0dd0b0647f66e5604126bd5a4de"},{"_id":"public/archives/page/8/index.html","modified":1463543944616,"shasum":"ffd03008bb4c3bc4e8367393b9de89a549bfcd87"},{"_id":"public/archives/page/9/index.html","modified":1463543944640,"shasum":"93b2d1c7dd08cf6110b6ca0a30cff00360f1b84d"},{"_id":"public/archives/page/10/index.html","modified":1463543944664,"shasum":"787956fa16a3248b51119dc1c3cedef78a39f3fc"},{"_id":"public/archives/page/11/index.html","modified":1463543944698,"shasum":"ed09ecefc0c570e3c699b40009fca53359ac4605"},{"_id":"public/archives/page/12/index.html","modified":1463543944724,"shasum":"14c98e8fe28cd51c4da798c3d1a004e4496d1ba2"},{"_id":"public/archives/page/13/index.html","modified":1463543944749,"shasum":"9ced86bbcf2202af2d13ecb2fca12ed641c2fa0a"},{"_id":"public/archives/page/14/index.html","modified":1463543944773,"shasum":"1e4a363293c4d12317ce696d30ad64b55dcb6fc8"},{"_id":"public/archives/page/15/index.html","modified":1463543944787,"shasum":"99a38ac08557559dc49199cc182597d3dec104f7"},{"_id":"public/archives/2015/index.html","modified":1463543944811,"shasum":"ef47830acf6a2bf594fa97d6371066f2cb179e93"},{"_id":"public/archives/2015/11/index.html","modified":1463543944819,"shasum":"ef6cbad775afe7d556d6d7260c6d9a5217d8a0eb"},{"_id":"public/archives/2015/12/index.html","modified":1463543944835,"shasum":"845ed37f3371501d4d5035b8591ad99c0856d224"},{"_id":"public/archives/2016/index.html","modified":1463543944859,"shasum":"102b0e6f42a2838f8cba1229f7bddc1ff90eba9e"},{"_id":"public/archives/2016/page/2/index.html","modified":1463543944879,"shasum":"872639b67e6c04da3b7a684cb6a692eaa2bf5d84"},{"_id":"public/archives/2016/page/3/index.html","modified":1463543944901,"shasum":"68ae2e35c05aba818534a0be1055491340e97b32"},{"_id":"public/archives/2016/page/4/index.html","modified":1463543944923,"shasum":"202e5004932ec1178f25351a6cae4b468ec4376a"},{"_id":"public/archives/2016/page/5/index.html","modified":1463543944947,"shasum":"7a79105a7474b8d36d24aed1e68ee111d49758a3"},{"_id":"public/archives/2016/page/6/index.html","modified":1463543944975,"shasum":"ac49655e4f9efb97acc5673ce68352cb8bc4388d"},{"_id":"public/archives/2016/page/7/index.html","modified":1463543944996,"shasum":"4169c6ddb0241f99756d3cda6e63db0b86da37fa"},{"_id":"public/archives/2016/page/8/index.html","modified":1463543945017,"shasum":"351651fe989e4290e6069f88753f068010b5aad9"},{"_id":"public/archives/2016/page/9/index.html","modified":1463543945046,"shasum":"252895004bd230fe451b5cf0e790eecb80e421a6"},{"_id":"public/archives/2016/page/10/index.html","modified":1463543945065,"shasum":"a63f6f00768de7f0b4e49ec6bf6b8996babfb4fa"},{"_id":"public/archives/2016/page/11/index.html","modified":1463543945087,"shasum":"f61e6187f642b3e98c114ad9a8f20619f51e5d4c"},{"_id":"public/archives/2016/page/12/index.html","modified":1463543945108,"shasum":"2b30775364dda1e6ad7faf784726d10c428e04c4"},{"_id":"public/archives/2016/page/13/index.html","modified":1463543945128,"shasum":"76880f7d8ea89bc93433aa60841c5cda034a7c47"},{"_id":"public/archives/2016/page/14/index.html","modified":1463543945142,"shasum":"569e03dc52a25bdaf8fc40dd2f862ffc526e17ce"},{"_id":"public/archives/2016/01/index.html","modified":1463543945164,"shasum":"ff21bd5bcec1b4aa038723c76671e95812dbfd88"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1463543945188,"shasum":"e2a599116b3078fea69134b2f8fe8d7e571ef528"},{"_id":"public/archives/2016/01/page/3/index.html","modified":1463543945199,"shasum":"9f14a0bb7240aacd4385912beef96e67de0544ab"},{"_id":"public/archives/2016/02/index.html","modified":1463543945222,"shasum":"495a0b224d1c6f61813e54c25e852b3e297ae983"},{"_id":"public/archives/2016/02/page/2/index.html","modified":1463543945242,"shasum":"79152e990f682bdde96914d164d21257c678893f"},{"_id":"public/archives/2016/02/page/3/index.html","modified":1463543945251,"shasum":"225196207d3288a1bc6bb762d899e1228b7b8999"},{"_id":"public/archives/2016/03/index.html","modified":1463543945276,"shasum":"68ab6150c84ad6e17be1cf61bc211afe37f5fcbf"},{"_id":"public/archives/2016/03/page/2/index.html","modified":1463543945298,"shasum":"7e6f73e306a97677ac49d2cf02e9dabbdf00263e"},{"_id":"public/archives/2016/03/page/3/index.html","modified":1463543945320,"shasum":"d0ec848f2ce0bda73ad2b0e93a6e4a1e7a50f1a0"},{"_id":"public/archives/2016/03/page/4/index.html","modified":1463543945331,"shasum":"c2d38a574f78ecd0e61dc665c41b53253e5cd319"},{"_id":"public/archives/2016/04/index.html","modified":1463543945352,"shasum":"9dff1a155524e736daafbacf2c63ce593f204018"},{"_id":"public/archives/2016/04/page/2/index.html","modified":1463543945374,"shasum":"360565070cbea99bd554fdede74e41d441cb5f8a"},{"_id":"public/archives/2016/04/page/3/index.html","modified":1463543945393,"shasum":"36d9e49b53eb38abd759223facf37dd47e675819"},{"_id":"public/archives/2016/04/page/4/index.html","modified":1463543945412,"shasum":"c8efcf1371fd6d2903aac67f14bfef7590c1e57a"},{"_id":"public/archives/2016/05/index.html","modified":1463543945433,"shasum":"3fde908cde4eff8795b8f8614a2c3e67c9a7487f"},{"_id":"public/archives/2016/05/page/2/index.html","modified":1463543945444,"shasum":"ca630c02c65aa11f0b11dc7574ae07c3e88d9872"},{"_id":"public/categories/oi/index.html","modified":1463543945469,"shasum":"49284198e6262c94601d3aa64c4c9badf586e90e"},{"_id":"public/categories/oi/page/2/index.html","modified":1463543945491,"shasum":"527db285ea2c790e03b6c0f235d87256b3a4c5ef"},{"_id":"public/categories/oi/page/3/index.html","modified":1463543945514,"shasum":"2658d6a7db43726fcd5bd249031eab389b7565fe"},{"_id":"public/categories/oi/page/4/index.html","modified":1463543945538,"shasum":"680a1bcc43a7f98a7eff7f7c0dfa11594cd2af91"},{"_id":"public/categories/oi/page/5/index.html","modified":1463543945563,"shasum":"a319661968fcc4c165ea3d918e165ab85cdf955d"},{"_id":"public/categories/oi/page/6/index.html","modified":1463543945583,"shasum":"cf89ccf180e6ba441765280647585f0dd5fc7ad0"},{"_id":"public/categories/oi/page/7/index.html","modified":1463543945608,"shasum":"016dca0f7d832e2fc707a1ae41c91834d5380b88"},{"_id":"public/categories/oi/page/8/index.html","modified":1463543945627,"shasum":"11d0b1fb780901cc52a9d37f165ab46e66610f85"},{"_id":"public/categories/oi/page/9/index.html","modified":1463543945649,"shasum":"0672dbaa04374f910f68e403a1ba6f8325b75f77"},{"_id":"public/categories/oi/page/10/index.html","modified":1463543945677,"shasum":"0f249c26e8143e9bbf95caee83c978b10ec36a35"},{"_id":"public/categories/oi/page/11/index.html","modified":1463543945700,"shasum":"a25e33a0741e2696a3e8c490920a951fd918e302"},{"_id":"public/categories/oi/page/12/index.html","modified":1463543945726,"shasum":"bbdae3c2a87004c4452c187120ee5fd6b16e583a"},{"_id":"public/categories/oi/page/13/index.html","modified":1463543945758,"shasum":"bdd519f1c90b7889228fc34590e67d56d9febc00"},{"_id":"public/categories/oi/page/14/index.html","modified":1463543945774,"shasum":"37a3e8da9b176f7fe7dcc79031656c3ba6d39f38"},{"_id":"public/categories/geek/index.html","modified":1463543945789,"shasum":"fd41ec9341842eda9b06cb53d0f569f0b927d3c9"},{"_id":"public/categories/diary/index.html","modified":1463543945809,"shasum":"9e4da980261236839d95c0704ad44579375e4e65"},{"_id":"public/categories/diary/oi/index.html","modified":1463543945825,"shasum":"ab0bd7a4b96b1b05920971088715d3698dbfd14f"},{"_id":"public/atom.xml","modified":1463543946248,"shasum":"39d7de29f080b953b0eb9625f7431e415358396c"},{"_id":"public/sitemap.xml","modified":1463543945828,"shasum":"947b459f7fac6e42d40ce4a6ae890ca845316839"},{"_id":"public/tag/安徽集训/index.html","modified":1463543946273,"shasum":"51cfd75b3fb36986fd32f47f630f7757125d553c"},{"_id":"public/tag/安徽集训/page/2/index.html","modified":1463543946283,"shasum":"004e676ce67d6a5d5f8f1aa2a62fb02fdd246e7b"},{"_id":"public/tag/树链剖分/index.html","modified":1463543946311,"shasum":"2954e5abd243fad87bedd847cc447a41b99ad822"},{"_id":"public/tag/线段树/index.html","modified":1463543946324,"shasum":"3e5513bc647e28d64516338a07d293a46c117555"},{"_id":"public/tag/数据结构/index.html","modified":1463543946343,"shasum":"11eec2842e5d8d67c5fa466c6f7ebf7b77432075"},{"_id":"public/tag/数据结构/page/2/index.html","modified":1463543946361,"shasum":"d15902294e2ec27a84df8e92106bdc39b09ae7a1"},{"_id":"public/tag/高级数据结构/index.html","modified":1463543946379,"shasum":"49f5265b1845074759237392d20c12d3a31b7ada"},{"_id":"public/tag/高级数据结构/page/2/index.html","modified":1463543946393,"shasum":"db23fb46530f3a12532a77f84705f4a0ddff78da"},{"_id":"public/tag/os-x/index.html","modified":1463543946402,"shasum":"b27c341996dace308b2704f8208c84c4277744bd"},{"_id":"public/tag/linux/index.html","modified":1463543946410,"shasum":"d7a6b90d09111078a6cdd3ff867b5905b2709276"},{"_id":"public/tag/archlinux/index.html","modified":1463543946416,"shasum":"deb884104bcb9886be1ec5b7f0e125c418e4e6cf"},{"_id":"public/tag/virtualbox/index.html","modified":1463543946422,"shasum":"b57aefb1378c3cfd85f572ce8951d3de664c95d2"},{"_id":"public/tag/虚拟机/index.html","modified":1463543946429,"shasum":"b775709cb342fa9960ab9dcfc1a93b883cea6823"},{"_id":"public/tag/ssh/index.html","modified":1463543946439,"shasum":"e0c0096bf4a830ad156bcff4e44c19e5dd03b78f"},{"_id":"public/tag/uva/index.html","modified":1463543946458,"shasum":"7fef73007e4eec6ca14801beffbe828d2a6b17f2"},{"_id":"public/tag/数学/index.html","modified":1463543946479,"shasum":"980e605d590ad0bb6e87aca932548dc7c4ce1590"},{"_id":"public/tag/数学/page/2/index.html","modified":1463543946502,"shasum":"5192583b6ddeabe64a96cca8e1f2ac48229b2c3a"},{"_id":"public/tag/dp/index.html","modified":1463543946524,"shasum":"d1872aa3d49f0233ae03ec355a4bf1730ecafd04"},{"_id":"public/tag/dp/page/2/index.html","modified":1463543946544,"shasum":"ac3ea80f6a51cecc67d4c251c9eccc3f78276c4a"},{"_id":"public/tag/dp/page/3/index.html","modified":1463543946563,"shasum":"2ad7b291068994e336dfefc49a777fc7e84db002"},{"_id":"public/tag/区间dp/index.html","modified":1463543946570,"shasum":"35470e272ed5b68f10e96b93baebea64a2dd5967"},{"_id":"public/tag/计数原理/index.html","modified":1463543946590,"shasum":"f95ad4d7088e88f682737e2a9f0a66fbe0e6cf3f"},{"_id":"public/tag/组合数学/index.html","modified":1463543946603,"shasum":"1b9f2e430e4183bc0d11e5df556b1eb7e98e94ec"},{"_id":"public/tag/容斥原理/index.html","modified":1463543946610,"shasum":"0bc9021a777928e48b5ed71cdd9e7faacff11ac6"},{"_id":"public/tag/递推/index.html","modified":1463543946625,"shasum":"3815a8e2b178c4a24fc85cbc2a795665308b18a7"},{"_id":"public/tag/高精度/index.html","modified":1463543946638,"shasum":"c00051461bfd9dbb20daf78c8cb98c0875715edf"},{"_id":"public/tag/数位dp/index.html","modified":1463543946656,"shasum":"67d1a24a21cd6392cb1403b6c60019291245c2e8"},{"_id":"public/tag/数论/index.html","modified":1463543946675,"shasum":"e3f4b26fcc91bc08abfcfa78efa1d56dc8836d62"},{"_id":"public/tag/数论/page/2/index.html","modified":1463543946682,"shasum":"cd10e28c40d396af1f200ee9ccae7fb9031147ce"},{"_id":"public/tag/乘法逆元/index.html","modified":1463543946695,"shasum":"116a2dcb43f9bb94c67328ab63e000d3ce04bb47"},{"_id":"public/tag/全排列/index.html","modified":1463543946705,"shasum":"4fd85c84a8a3f425b11e9bd6ec45f3cce6efa4b5"},{"_id":"public/tag/背包dp/index.html","modified":1463543946715,"shasum":"929de4e3dd0f16a42fe5fea3ccd85042fff94437"},{"_id":"public/tag/组合数/index.html","modified":1463543946728,"shasum":"eb863f37ae9ffc2ab4ff2f6a9ade672c4287b654"},{"_id":"public/tag/整数划分/index.html","modified":1463543946735,"shasum":"f340ba95bf918d5198a771b187ae1b8f4be1824e"},{"_id":"public/tag/回溯/index.html","modified":1463543946743,"shasum":"08f1358f60552c4fa9ce0c1518defb3e368ad0ed"},{"_id":"public/tag/codevs/index.html","modified":1463543946761,"shasum":"f0ee2ef69ab91d5d910bb717bd29ae974da58556"},{"_id":"public/tag/codevs/page/2/index.html","modified":1463543946782,"shasum":"ac56243484a0483555085db10d1f49362f723462"},{"_id":"public/tag/codevs/page/3/index.html","modified":1463543946797,"shasum":"0dfe7c2ae464aa7c3aa68c802f394454a7e2fe5d"},{"_id":"public/tag/tyvj/index.html","modified":1463543946809,"shasum":"c46ed1ec65e186f33e469723cb2febf00e69efcd"},{"_id":"public/tag/划分dp/index.html","modified":1463543946824,"shasum":"589e3516386b7251464288192a6d9bcbec6ae393"},{"_id":"public/tag/bzoj/index.html","modified":1463543946845,"shasum":"595b03f64a3ad330a5cd1f513adc600dbc13de1e"},{"_id":"public/tag/bzoj/page/2/index.html","modified":1463543946865,"shasum":"94f901eeef56f1dc9e3220635dbb01677068b8b8"},{"_id":"public/tag/bzoj/page/3/index.html","modified":1463543946883,"shasum":"2541c0a2a7f68b77075d6b6ab500d958a13f79d6"},{"_id":"public/tag/bzoj/page/4/index.html","modified":1463543946901,"shasum":"ee18744cfe94c8f5ee2cbd3c904c59cc8f370154"},{"_id":"public/tag/bzoj/page/5/index.html","modified":1463543946922,"shasum":"c77645fff266a72204f254dfc3c5a20a471f9120"},{"_id":"public/tag/bzoj/page/6/index.html","modified":1463543946941,"shasum":"5264beeb649249dcce2794e28ad23fd1745eab1d"},{"_id":"public/tag/tjoi/index.html","modified":1463543946946,"shasum":"b35ea2bd6dfaa1c1cdd46ffea9283e813674e75b"},{"_id":"public/tag/离线/index.html","modified":1463543946953,"shasum":"9aeebc0badc3e04ed39dc37318ec8c7961456a03"},{"_id":"public/tag/splay/index.html","modified":1463543946974,"shasum":"be607864fea9047777b9c7bf6c188878b07b749c"},{"_id":"public/tag/树状数组/index.html","modified":1463543946984,"shasum":"4d3f6791cdcdb520392f65af9a28890956a08cb4"},{"_id":"public/tag/学习笔记/index.html","modified":1463543947005,"shasum":"7772c4eb2e9989d579321d2b1d7ed2bd470f0878"},{"_id":"public/tag/学习笔记/page/2/index.html","modified":1463543947029,"shasum":"ba7c14723cf1e1064d1c4f765c543018fb6e2c0b"},{"_id":"public/tag/图论/index.html","modified":1463543947049,"shasum":"18edda45d3a586dcb40ab6dafab3882010d28678"},{"_id":"public/tag/图论/page/2/index.html","modified":1463543947075,"shasum":"e6d8acd9f6a367ecaf0936651ca78a12a1e44ab8"},{"_id":"public/tag/图论/page/3/index.html","modified":1463543947089,"shasum":"d1b4caa3d56f39b6f9ff40dffcf02d64c96ce3bd"},{"_id":"public/tag/强联通分量/index.html","modified":1463543947101,"shasum":"708637db431990ae41c6f95c78c3d23f0c470969"},{"_id":"public/tag/tarjan/index.html","modified":1463543947121,"shasum":"e28b2a8c1ecdf5366cdc33d47b9545f43bf62df0"},{"_id":"public/tag/算法模板/index.html","modified":1463543947139,"shasum":"bb15ebce04c69b4fce95b84e714e949233d63d35"},{"_id":"public/tag/算法模板/page/2/index.html","modified":1463543947158,"shasum":"474a950d2dcf8d2b63cfe9ac2f799f70af95a017"},{"_id":"public/tag/差分约束系统/index.html","modified":1463543947167,"shasum":"f3bc50935dc9428ffcd3f801033530f3ded18a27"},{"_id":"public/tag/最短路/index.html","modified":1463543947178,"shasum":"f96e8f136eeed183bc3b4acb2d04f0347a7e7851"},{"_id":"public/tag/后缀数组/index.html","modified":1463543947188,"shasum":"2ae091ce804cecd80c242e19ffdbc5b7fb6e0faa"},{"_id":"public/tag/字符串/index.html","modified":1463543947207,"shasum":"9f381732dcf55332ff9a0b41d54a879a0493907f"},{"_id":"public/tag/稀疏表/index.html","modified":1463543947213,"shasum":"c9143aa87ee1a0ebd6ab03eb1a9aa2968b9a27ef"},{"_id":"public/tag/c/index.html","modified":1463543947221,"shasum":"7b156cc9f1bff9fa6bf09bbd7d7e5ebadd574f9d"},{"_id":"public/tag/stl/index.html","modified":1463543947230,"shasum":"bb12b9c9cdce013e78095073dbcb38599504e5ce"},{"_id":"public/tag/spoj/index.html","modified":1463543947236,"shasum":"6965c382e063cfab94495da2fe7a86a757afbe9e"},{"_id":"public/tag/sdoi/index.html","modified":1463543947261,"shasum":"b841e5aed5072e1fdd0f7f49ad559826b2552b43"},{"_id":"public/tag/cogs/index.html","modified":1463543947280,"shasum":"f569fc679a718773fa00b6ba821f5d8c5bb5b5fb"},{"_id":"public/tag/cogs/page/2/index.html","modified":1463543947301,"shasum":"1a36a4f309a695cd7967442a8e4a2441a1d6195f"},{"_id":"public/tag/cogs/page/3/index.html","modified":1463543947319,"shasum":"2ea250df04cb50709051c4aaece0bba1bbc5cd21"},{"_id":"public/tag/二进制/index.html","modified":1463543947327,"shasum":"9991db1190408d170550e7e206db5c0fe4e7e170"},{"_id":"public/tag/异或/index.html","modified":1463543947333,"shasum":"edac88386ce80d999354cbf85f28e2a018f339d3"},{"_id":"public/tag/位运算/index.html","modified":1463543947343,"shasum":"fc0cd3174c5a0c296dff9fa492f4645a43755117"},{"_id":"public/tag/游记/index.html","modified":1463543947357,"shasum":"3c701addd968f8c3333f0314704741ba93b847b9"},{"_id":"public/tag/省选/index.html","modified":1463543947364,"shasum":"5a9dcedb36ec7aac6e8a0aa8dcfde48620145e75"},{"_id":"public/tag/错位排列/index.html","modified":1463543947374,"shasum":"b7a89f3da81708ae6e71b800756e79e997f260e3"},{"_id":"public/tag/edmonds-karp/index.html","modified":1463543947395,"shasum":"91659bf8104a019ac80a131d047b78980fb5503f"},{"_id":"public/tag/素数判定/index.html","modified":1463543947401,"shasum":"f2da06f7e088b88371e8f3fd43809e9d5fda470a"},{"_id":"public/tag/线性筛/index.html","modified":1463543947414,"shasum":"d4032910b1919cbe864a9b9d2bacc5f56c509007"},{"_id":"public/tag/网络流/index.html","modified":1463543947433,"shasum":"231e0cd05f42aeb30bfeaf6f72caf5259cae284c"},{"_id":"public/tag/网络流/page/2/index.html","modified":1463543947456,"shasum":"6d8a5d4286b3744c463e5cf30d34bc2b70b0b72b"},{"_id":"public/tag/网络流/page/3/index.html","modified":1463543947473,"shasum":"3823153ac2688f0379ffbf750046d5e82a796337"},{"_id":"public/tag/费用流/index.html","modified":1463543947496,"shasum":"1f239dbbafc29de029d38feba39910493b6780fc"},{"_id":"public/tag/二分答案/index.html","modified":1463543947510,"shasum":"3d4381a94527e02c9032b1738fc86989012b8ea6"},{"_id":"public/tag/斜率优化/index.html","modified":1463543947521,"shasum":"9f8e8114028e49c96b6fb5455ab82222c1fb5348"},{"_id":"public/tag/单调队列/index.html","modified":1463543947538,"shasum":"e335481cdb40b9a9243ee2f61183daf4ba1acc51"},{"_id":"public/tag/rmq/index.html","modified":1463543947547,"shasum":"38213952eb2c4efd06767fe41d62bb3762b025c7"},{"_id":"public/tag/最近公共祖先/index.html","modified":1463543947558,"shasum":"a4d86e876e6977366f815e03c75e6e4985c34b31"},{"_id":"public/tag/dinic/index.html","modified":1463543947578,"shasum":"b5efd82c45ceb24d159c6d46f40facc87fdae970"},{"_id":"public/tag/dinic/page/2/index.html","modified":1463543947597,"shasum":"9c1fbe61e5324b25476537f30e835d5d05d58666"},{"_id":"public/tag/实数二分/index.html","modified":1463543947605,"shasum":"4a3d9e07b0fc3d4fbea6cd45577ab2de37403f0a"},{"_id":"public/tag/动态树/index.html","modified":1463543947614,"shasum":"2454e68d0c3cd861d13a27106592595857902906"},{"_id":"public/tag/link-cut-tree/index.html","modified":1463543947622,"shasum":"8e675cca6db3b28ce179ccf0a04532a5782bc7f4"},{"_id":"public/tag/scoi/index.html","modified":1463543947643,"shasum":"a23ffae5ed3001fe69872efa8020f4231b491558"},{"_id":"public/tag/set/index.html","modified":1463543947650,"shasum":"c3a247c442d1cb0608056fd87ba99b4f4a990fb8"},{"_id":"public/tag/乱搞/index.html","modified":1463543947661,"shasum":"b38a593dd7af5b1c01250155b446007ef49b7b2f"},{"_id":"public/tag/二分图匹配/index.html","modified":1463543947677,"shasum":"d26f33ba01ed12306b87ab76e7422628270af304"},{"_id":"public/tag/树形dp/index.html","modified":1463543947690,"shasum":"13a64e128af4fe9a52b0931f1d922c41abcbfd5c"},{"_id":"public/tag/贪心/index.html","modified":1463543947699,"shasum":"f256d40eae8500ad07239c04591694e2f3907ec6"},{"_id":"public/tag/倍增/index.html","modified":1463543947711,"shasum":"0dc760c49893e616ebe392bbee142debe39b5639"},{"_id":"public/tag/缩点/index.html","modified":1463543947726,"shasum":"80f4d3a024fa003f9f3d82e7dbb9342e0c2e594e"},{"_id":"public/tag/拓扑排序/index.html","modified":1463543947733,"shasum":"a83040042b3897cacc591057f72da647b4030960"},{"_id":"public/tag/匈牙利算法/index.html","modified":1463543947740,"shasum":"fe4146cfa587565130ba08860dc744d93d7aa2fe"},{"_id":"public/tag/枚举答案/index.html","modified":1463543947748,"shasum":"dd827fdedab606dea9d95cc22b4e8d34fe56ab72"},{"_id":"public/tag/poj/index.html","modified":1463543947760,"shasum":"5044788bd97df5ce43673eac4962601c88bc84a6"},{"_id":"public/tag/kmp/index.html","modified":1463543947769,"shasum":"95f7e824c04823f99a0b432cd89b4a200555a49e"},{"_id":"public/tag/prim/index.html","modified":1463543947778,"shasum":"f9aaf411a5bd3d9ce4e43e0e7617a590649a695f"},{"_id":"public/tag/生成树/index.html","modified":1463543947784,"shasum":"cc3380aee05eda50fee29d7d071e96b5c3397de2"},{"_id":"public/tag/分数规划/index.html","modified":1463543947791,"shasum":"c1f424c2148722cb40af067f1dfdba91035e09dc"},{"_id":"public/tag/软件/index.html","modified":1463543947797,"shasum":"08ec527536b5bdf2c9d260bae099a5d4e4687f11"},{"_id":"public/tag/hidpi/index.html","modified":1463543947804,"shasum":"01fffecbdd1faa2d14b2d5ece4e400c0c87462b1"},{"_id":"public/tag/dfs/index.html","modified":1463543947810,"shasum":"1e8ec86bbb4f9e2a74aa67f3d465ba7f0782146f"},{"_id":"public/tag/noip/index.html","modified":1463543947826,"shasum":"335ad107cb696f033a984d73ed39bf4a63ed1d3a"},{"_id":"public/tag/exgcd/index.html","modified":1463543947833,"shasum":"03d517a7b7fa03df5ce8c89c98bf83ce35ff6cfe"},{"_id":"public/tag/vijos/index.html","modified":1463543947842,"shasum":"fe351f8405f188476f28e8c5f52f1b39fb083ad1"},{"_id":"public/tag/洛谷/index.html","modified":1463543947850,"shasum":"9eff6e687e001873c37fc7575f37dc66d0c67273"},{"_id":"public/tag/二分图染色/index.html","modified":1463543947861,"shasum":"c725e53acbe2b14209cf27a1edb5cfb1de84b0b1"},{"_id":"public/tag/noi/index.html","modified":1463543947879,"shasum":"3d14c5c6c49a3fb80629c50cb702ad8362d5f17b"},{"_id":"public/tag/离散化/index.html","modified":1463543947886,"shasum":"f580699b817fec0d29d770ca3253b4042b8a7a50"},{"_id":"public/tag/并查集/index.html","modified":1463543947898,"shasum":"50cf3f59ea2d43501ab10fce0ad7a9d332d8971c"},{"_id":"public/tag/哈希/index.html","modified":1463543947906,"shasum":"89159233fc9f86281aa3715d88804ce12bbb42cb"},{"_id":"public/tag/map/index.html","modified":1463543947916,"shasum":"621e8a09ee83ed17917ea7f809f80ed3813ef2b4"},{"_id":"public/tag/最小割/index.html","modified":1463543947925,"shasum":"9aa88dd8ae078c2a312f17d5045eefbb49b853ee"},{"_id":"public/tag/最大权闭合图/index.html","modified":1463543947935,"shasum":"e24c3d663238bfd6c6ba6328832595513acf86fe"},{"_id":"public/tag/莫队/index.html","modified":1463543947943,"shasum":"3ba7ca17f482f23078f735b4bbf169f577ecba47"},{"_id":"public/tag/kruskal/index.html","modified":1463543947951,"shasum":"727b3f2d018ed6de1028938cd84a1d7aa705682b"},{"_id":"public/tag/最小生成树/index.html","modified":1463543947959,"shasum":"4354485a761f2110f6656592bb76ccedc5cc42d1"},{"_id":"public/tag/markdown/index.html","modified":1463543947966,"shasum":"79e1fc45d6c35a9724b8db99aa8523d1ec1a80bb"},{"_id":"public/tag/latex/index.html","modified":1463543947973,"shasum":"755f5eb56a098c8bdafd47d43dcf45bb19685f17"},{"_id":"public/tag/github/index.html","modified":1463543947979,"shasum":"9a6d37aeb5a0982707d22a8f17ef77aa5eeb6865"},{"_id":"public/tag/jsoi/index.html","modified":1463543947990,"shasum":"3fd677a0e13d74e17e06b409c60c4db543a29183"},{"_id":"public/tag/分块/index.html","modified":1463543948006,"shasum":"d7647a1fc7548b2eafcc48ea71c0f5481bfebcbe"},{"_id":"public/tag/floyd/index.html","modified":1463543948012,"shasum":"09cf0e2aba9029c094d32086501f55a149050ec4"},{"_id":"public/tag/博弈/index.html","modified":1463543948017,"shasum":"f92678ce4604f9099de1b65f4b4083ee0bc7526d"},{"_id":"public/tag/hnoi/index.html","modified":1463543948039,"shasum":"279d32414ec9dd8e875cdad21f17ddf51d2013f2"},{"_id":"public/tag/主席树/index.html","modified":1463543948050,"shasum":"01eeb356ac50ecfc268790806c9f83259720c80a"},{"_id":"public/tag/dfs-序/index.html","modified":1463543948060,"shasum":"ba6cfdf4c4824db4112a9110f1a0befe8ac8ce7e"},{"_id":"public/tag/hdu/index.html","modified":1463543948076,"shasum":"a9172b4f7e403a181fe69147bbda85698c4732e9"},{"_id":"public/tag/bestcoder/index.html","modified":1463543948082,"shasum":"c98a2be043f10785d4fd126593e00d2164b2bcc6"},{"_id":"public/tag/haoi/index.html","modified":1463543948095,"shasum":"414d9bb02d5f6662ef3b44a891335386a9af0a41"},{"_id":"public/tag/dfs序/index.html","modified":1463543948100,"shasum":"04a5822c4fd68d412be7999979e699b080fe266b"},{"_id":"public/tag/莫比乌斯反演/index.html","modified":1463543948110,"shasum":"0e8a658d8e81eb435d6e9ba030981ce517ab9a1d"},{"_id":"public/tag/gdb/index.html","modified":1463543948119,"shasum":"edc3f4ac0675098872786caea6195f79f9299f46"},{"_id":"public/tag/调试/index.html","modified":1463543948127,"shasum":"369b33b4cf5e9b62685383df494d4095af41b585"},{"_id":"public/tag/ctsc/index.html","modified":1463543948135,"shasum":"3d48940041ed371f1c857f4b509ac7ccc7d77e81"},{"_id":"public/tag/网络流-24-题/index.html","modified":1463543948163,"shasum":"3cebb3a3a0f4a590ac3c76e4271f1ff83b915e0e"},{"_id":"public/tag/网络流-24-题/page/2/index.html","modified":1463543948178,"shasum":"5f32aab8b30ddb3d7920e53e3ea58c377b6fb6d0"},{"_id":"public/tag/apio/index.html","modified":1463543948187,"shasum":"c76abbc1d534b4d18bf3c4f447d99acde49ffb04"},{"_id":"public/tag/cqoi/index.html","modified":1463543948197,"shasum":"f0bc2e6aa9ca840d8c8eaca7899c3cc824fb44fb"},{"_id":"public/tag/分治/index.html","modified":1463543948208,"shasum":"0c3208351654869ce09292085dada28249fbfc9e"},{"_id":"public/tag/最大独立集/index.html","modified":1463543948219,"shasum":"fa4c7ac71097cedf55eec24484deb2790a824e05"},{"_id":"public/tag/搜索/index.html","modified":1463543948226,"shasum":"9d72728dd62c98b730072fe58fa34f33a63182e7"},{"_id":"public/tag/记忆化搜索/index.html","modified":1463543948236,"shasum":"7701ccc576f9da8c7fd32b242a2bf65e94059106"},{"_id":"public/tag/线性dp/index.html","modified":1463543948246,"shasum":"5d9c5c2584d9b0b86c6d03a6bfb1842485a03f25"},{"_id":"public/tag/codeforces/index.html","modified":1463543948257,"shasum":"c629fb1ac061f887db7ed2b2a52546b67d640056"},{"_id":"public/tag/lucas-定理/index.html","modified":1463543948266,"shasum":"b284bed4e1da9d139978dec250c964961079a30e"},{"_id":"public/tag/cdq/index.html","modified":1463543948276,"shasum":"616efb3a264d12cb6f587d0ddd036ca77e16ba48"},{"_id":"public/tag/dijkstra/index.html","modified":1463543948282,"shasum":"9cbb0e0a28b0dfa4358d8f939fd9ee37f08ed217"},{"_id":"public/tag/快速幂/index.html","modified":1463543948293,"shasum":"f2c8f90f0b02637cc41ded0a1e83c9d7adcbd4f8"},{"_id":"public/tag/dag/index.html","modified":1463543948306,"shasum":"9ddb152d6064779ced54a095194dbaad5480d4a3"},{"_id":"public/tag/最长路/index.html","modified":1463543948314,"shasum":"746298a651e8ecb2581bcdb8dbce17cf81cd5786"},{"_id":"public/tag/bellman-ford/index.html","modified":1463543948324,"shasum":"be1a6c6d9d8f095fd2333806b759e25ea741c20b"},{"_id":"public/tag/ahoi/index.html","modified":1463543948339,"shasum":"15fe4ddffa6ee1d12f5cce17635496457e4ee993"},{"_id":"public/tag/上下界网络流/index.html","modified":1463543948354,"shasum":"06f68419beaead8eb62c17a93f9ed72434fbbafa"},{"_id":"public/tag/碎碎念/index.html","modified":1463543948372,"shasum":"e19bd0c2a65afdb2e5b65339c25550d789943231"},{"_id":"public/tag/暴力/index.html","modified":1463543948385,"shasum":"ab29ae1907de8a6bfd5d6d5eb3e4205d74172d66"},{"_id":"public/tag/二分查找/index.html","modified":1463543948397,"shasum":"20f36f70563a5d9bd90e7f2ca2576ce55905d9fc"},{"_id":"public/tag/矩阵乘法/index.html","modified":1463543948410,"shasum":"96187ef8c721b962b3e0054f04a2bd236a047d2c"},{"_id":"public/tag/扫描线/index.html","modified":1463543948420,"shasum":"8368c02debc0ced318fc8a5e5f83185942cbea19"},{"_id":"public/tag/链表/index.html","modified":1463543948429,"shasum":"ae8a956214749b1466d7c46202701e5a766ed05a"},{"_id":"public/index.html","modified":1463543945861,"shasum":"71a9636faa0fd913b5606881f0fd1bf42aef0237"},{"_id":"public/page/2/index.html","modified":1463543945889,"shasum":"6e91a7e69cbc7dd34f265af85cfa60a80f115bea"},{"_id":"public/page/3/index.html","modified":1463543945920,"shasum":"3c590ac84f780f4a7214518015ddf13d6ca21bca"},{"_id":"public/page/4/index.html","modified":1463543945950,"shasum":"40b84766664fea89cb451de962c0e8cd451b5575"},{"_id":"public/page/5/index.html","modified":1463543945982,"shasum":"d49e44e3663bbf99c4ba0888ecb11e2b5782c2f8"},{"_id":"public/page/6/index.html","modified":1463543946011,"shasum":"08af664b05a9fc10703abf79aea5adbe26a07481"},{"_id":"public/page/7/index.html","modified":1463543946046,"shasum":"9059886b4e335535d71ea3b242e93296f3d2e596"},{"_id":"public/page/8/index.html","modified":1463543946074,"shasum":"1eb2be78b29f7ea62ab833c621c5f69f62bee5c0"},{"_id":"public/page/9/index.html","modified":1463543946102,"shasum":"b8949b609fd13d4a4e1faff0a658e7bc261405d6"},{"_id":"public/page/10/index.html","modified":1463543946128,"shasum":"17657a8ac7ae2a2c60976adf2180118d69d53896"},{"_id":"public/page/11/index.html","modified":1463543946154,"shasum":"ea019fa9fc5e403c8aadb6dc9a69412e69c2e4a5"},{"_id":"public/page/12/index.html","modified":1463543946178,"shasum":"21ff841ef98e2e3b8304c301c5544387679a8688"},{"_id":"public/page/13/index.html","modified":1463543946203,"shasum":"130e372736c0f73d989a0384acfe2a585c9f862f"},{"_id":"public/page/14/index.html","modified":1463543946227,"shasum":"9e1d3a0a77b7c332e7357d0fdf62a1603d1f75cc"},{"_id":"public/page/15/index.html","modified":1463543946236,"shasum":"9585ab2d745261230f28c78b855f084d396e3dde"},{"_id":"source/_posts/zjoi2007-storage.md","shasum":"367a2f0816c7b25b0db9ed3d9e4e26e719d75109","modified":1463543922000},{"_id":"public/zjoi2007-storage/index.html","modified":1463543938997,"shasum":"b3ffa0c95d8c7e0c23ee5db3e68fc35d8b90bfce"},{"_id":"public/tag/zjoi/index.html","modified":1463543948439,"shasum":"2d23875c1d308f42bde058d4d5f86dfe02dca406"}],"Category":[{"name":"OI","_id":"cio5pdbsn00017gxl1xcox7g4"},{"name":"Geek","_id":"cio5pdbtv000g7gxlxtf2p5x5"},{"name":"Diary","_id":"cio5pdbzy005n7gxlxhsa1xqi"},{"name":"OI","parent":"cio5pdbzy005n7gxlxhsa1xqi","_id":"cio5pdc00005q7gxllu61z44o"}],"Data":[],"Page":[{"title":"Friends","date":"2016-01-18T13:08:05.000Z","_content":"\n<style>\n#oier {\n\tline-height: 1em;\n}\n\n#oier tr:nth-child(2n) {\n\tbackground: none !important;\n}\n\n#oier tr:nth-child(2n) td:not([rowspan]) {\n\tbackground: rgba(158,188,226,0.12);\t\n}\n\n#oier td {\n\ttext-align: center;\n\tvertical-align: middle;\n}\n\n#oier a, #oier span {\n\tdisplay: block;\n}\n\n#oier tr:hover {\n\tbackground: inherit;\n}\n\n#oier tbody tr:not(:nth-child(2n)):hover td:not([rowspan]) {\n\tbackground: #efefef;\n}\n</style>\n\n<table width=\"100%\" id=\"oier\">\n<thead>\n<tr class=\"header\">\n<th><span>From</span></th>\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td rowspan=\"8\"><span>QQ群「SDOI 2016」</span></td>\n<td>[Ofsxb](http://www.cnblogs.com/ofsxb/)</td>\n<td><span>齐河一中</span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span>青岛二中</span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span>东营一中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"2\"><span>QQ群「CodeVS交流群」</span></td>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>QQ群「在路上，同梦行」</span></td>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"2\"><span>QQ群「COGS交流群」</span></td>\n<td>[Rapiz](http://www.cnblogs.com/rapiz/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span>安阳一中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>2016安徽师大附中集训</span></td>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"2\"><span>WC2016</span></td>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span>武汉二中</span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span>武汉二中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"7\"><span>其它</span></td>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span>成都七中</span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[凌风仙鸡](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# 其它\n\n[盒子の自留地](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n","source":"friends.md","raw":"title: Friends\npermalink: friends/\ndate: 2016-01-18 21:08:05\n---\n\n<style>\n#oier {\n\tline-height: 1em;\n}\n\n#oier tr:nth-child(2n) {\n\tbackground: none !important;\n}\n\n#oier tr:nth-child(2n) td:not([rowspan]) {\n\tbackground: rgba(158,188,226,0.12);\t\n}\n\n#oier td {\n\ttext-align: center;\n\tvertical-align: middle;\n}\n\n#oier a, #oier span {\n\tdisplay: block;\n}\n\n#oier tr:hover {\n\tbackground: inherit;\n}\n\n#oier tbody tr:not(:nth-child(2n)):hover td:not([rowspan]) {\n\tbackground: #efefef;\n}\n</style>\n\n<table width=\"100%\" id=\"oier\">\n<thead>\n<tr class=\"header\">\n<th><span>From</span></th>\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td rowspan=\"8\"><span>QQ群「SDOI 2016」</span></td>\n<td>[Ofsxb](http://www.cnblogs.com/ofsxb/)</td>\n<td><span>齐河一中</span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span>青岛二中</span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span>东营一中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"2\"><span>QQ群「CodeVS交流群」</span></td>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>QQ群「在路上，同梦行」</span></td>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"2\"><span>QQ群「COGS交流群」</span></td>\n<td>[Rapiz](http://www.cnblogs.com/rapiz/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span>安阳一中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>2016安徽师大附中集训</span></td>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"2\"><span>WC2016</span></td>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span>武汉二中</span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span>武汉二中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"7\"><span>其它</span></td>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span>成都七中</span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[凌风仙鸡](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span>胜利一中</span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# 其它\n\n[盒子の自留地](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n","updated":"2016-04-27T15:22:37.000Z","path":"friends/index.html","comments":1,"layout":"page","_id":"cio5pdbtn000d7gxlip1kfruq"},{"title":"About Me","date":"2015-11-22T21:36:32.000Z","_content":"\n一只学 OI 的~~可爱的~~男孩子，~~大家可以叫我黄学弟~~。\n\n来自山东省临沂一中，目前高一，从 2015 年 8 月开始学 OI，正在为省选而努力。\n\n<!-- 想要拿 NOI 金牌。 -->\n\n> 用这灿烂时光，绽放不一样的光。\n","source":"about-me.md","raw":"title: About Me\npermalink: about-me/\ndate: 2015-11-23 05:36:32\n---\n\n一只学 OI 的~~可爱的~~男孩子，~~大家可以叫我黄学弟~~。\n\n来自山东省临沂一中，目前高一，从 2015 年 8 月开始学 OI，正在为省选而努力。\n\n<!-- 想要拿 NOI 金牌。 -->\n\n> 用这灿烂时光，绽放不一样的光。\n","updated":"2016-03-21T14:46:29.000Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"cio5pdbts000e7gxl3itwft9s"}],"Post":[{"title":"「省选模拟赛」染色 - 树链剖分","date":"2016-03-20T15:07:32.000Z","_content":"\n给定一棵 $ n $ 个节点的树，树的节点标号从 $ 0 $ 开始。每个节点可以是白色或黑色，初始时每个节点的颜色为白色。要求支持以下两种操作：\n\n1. 将节点 $ x $ 涂黑；\n2. 查询节点 $ x $ 到所有黑点距离之和。\n\n<!-- more -->\n\n### 题解\n先预处理出所有点到根的距离之和，维护当前所有黑点到根的距离之和 $ sum $ 和黑点总数 $ count $。\n\n考虑询问由根节点的向它的某个子节点 u 移动，则答案为：\n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n即\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n树链剖分，用线段树维护 $ count(u) * d_i $ 在链上的总和，每次 $ O(log ^ 2 n) $ 计算。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","source":"_posts/20160318-color.md","raw":"title: 「省选模拟赛」染色 - 树链剖分\ncategories: OI\ntags: \n  - 安徽集训\n  - 树链剖分\n  - 线段树\n  - 数据结构\n  - 高级数据结构\npermalink: 20160318-color\ndate: 2016-03-20 23:07:32\n---\n\n给定一棵 $ n $ 个节点的树，树的节点标号从 $ 0 $ 开始。每个节点可以是白色或黑色，初始时每个节点的颜色为白色。要求支持以下两种操作：\n\n1. 将节点 $ x $ 涂黑；\n2. 查询节点 $ x $ 到所有黑点距离之和。\n\n<!-- more -->\n\n### 题解\n先预处理出所有点到根的距离之和，维护当前所有黑点到根的距离之和 $ sum $ 和黑点总数 $ count $。\n\n考虑询问由根节点的向它的某个子节点 u 移动，则答案为：\n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n即\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n树链剖分，用线段树维护 $ count(u) * d_i $ 在链上的总和，每次 $ O(log ^ 2 n) $ 计算。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","slug":"20160318-color","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbs700007gxl9hz0bvcf"},{"title":"OS X 与虚拟机中 Linux 无缝整合","date":"2016-03-07T01:04:27.000Z","_content":"\nOS X 中有很多与 GNU/Linux 相似的地方，但也有很大的差异，很多时候 GNU/Linux 系统比 OS X 好用一些，而 OS X 的图形界面比 GNU/Linux 不知要高到哪里去了 …… 二者兼得的方法，就是使用虚拟机。\n\n下面以最好用的虚拟机软件 `VirtualBox` 为例，演示配置 Archlinux 虚拟机与 OS X 主机无缝整合的步骤。\n\n<!-- more -->\n\n## 安装 OpenSSH\n首先，在虚拟机中安装好 Arch Linux 系统，并安装好增强工具。\n\n安装 OpenSSH：\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## 配置端口转发\n打开「设置」→「网络」，选择「网络地址转换「NAT」连接方式。\n\n![网络设置](virtualbox-archlinux/network.png)\n\n点击「端口转发」。\n\n![端口转发](virtualbox-archlinux/port.png)\n\n子系统端口填写 `22`，主机端口填一个大于 `1000` 的值，因为在 OS X 下，非 `root` 用户的进程是无法绑定 `1000` 以下的端口的。\n\n确定后，在主机的 Terminal 中尝试连接。\n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## 共享文件夹\n在 Virtualbox 的「设置」→「共享文件夹」中设置共享根目录。\n\n![共享文件夹](virtualbox-archlinux/share.png)\n\n为了解决权限问题，不要选择「自动挂载」，而是手动配置自动挂载。\n\n### `rc.local` 服务\n\nArchlinux 的 systemd 原生不支持开机自动执行 `rc.local` 文件，所以我们需要先添加一个服务。\n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n输入以下内容：\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n保存后启用服务，并创建 `rc.local` 文件：\n\n```bash\nsudo systemctl enable rc-local\n```\n\n### 自动挂载脚本\n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n重启后，虚拟机中的主目录就和主机上的主目录共享啦。\n\n## SSH 免密码登录\n进行完以上步骤后，已经可以在主机通过 SSH 连接到虚拟机了，但需要输入密码。我们可以使用私钥认证的方式免去输入密码。\n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n一路回车后，会在 `~/.ssh` 目录下生成私钥和公钥。\n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n因为主机和虚拟机的主目录是共享的，所以在主机里设置后，虚拟机里也会生效。\n\n现在试试 SSH 连接到虚拟机，应该不需要密码了。\n\n## 配置 Terminal 快捷键\n众所周知，Terminal 中以默认设置打开新窗口的快捷键是 `Command + N`。我们也可以设置打开新窗口并 SSH 连接到虚拟机的快捷键。\n\n### 添加描述文件\n在 Terminal 的偏好设置中，选择「描述文件」，把「Basic」配置复制一份，命名为「Basic Linux」，并在 `Shell` 一栏中填写「运行命令」为 SSH，不勾选下方的「在 Shell 中运行」。\n\n![共享文件夹](virtualbox-archlinux/terminal.png)\n\n这样就已经可以在菜单中打开连接虚拟机的新窗口了。\n\n### 添加快捷键\n在系统偏好设置中添加快捷键：\n\n「系统偏好设置」→「键盘」→「快捷键」→「应用程序快捷键」→「添加」\n\n![共享文件夹](virtualbox-archlinux/hotkey.png)\n\n点击「添加」后，就可以使用快捷键啦！\n\n## 成果\n在 Terminal 中，按下 `Command + B`：\n\n![共享文件夹](virtualbox-archlinux/screenfetch.png)\n\n为了比较好的效果，可以改一下 `screenfetch`。\n","source":"_posts/virtualbox-archlinux.md","raw":"title: OS X 与虚拟机中 Linux 无缝整合\ncategories: Geek\ntags: \n  - OS X\n  - Linux\n  - Archlinux\n  - VirtualBox\n  - 虚拟机\n  - SSH\npermalink: virtualbox-archlinux\ndate: 2016-03-07 09:04:27\n---\n\nOS X 中有很多与 GNU/Linux 相似的地方，但也有很大的差异，很多时候 GNU/Linux 系统比 OS X 好用一些，而 OS X 的图形界面比 GNU/Linux 不知要高到哪里去了 …… 二者兼得的方法，就是使用虚拟机。\n\n下面以最好用的虚拟机软件 `VirtualBox` 为例，演示配置 Archlinux 虚拟机与 OS X 主机无缝整合的步骤。\n\n<!-- more -->\n\n## 安装 OpenSSH\n首先，在虚拟机中安装好 Arch Linux 系统，并安装好增强工具。\n\n安装 OpenSSH：\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## 配置端口转发\n打开「设置」→「网络」，选择「网络地址转换「NAT」连接方式。\n\n![网络设置](virtualbox-archlinux/network.png)\n\n点击「端口转发」。\n\n![端口转发](virtualbox-archlinux/port.png)\n\n子系统端口填写 `22`，主机端口填一个大于 `1000` 的值，因为在 OS X 下，非 `root` 用户的进程是无法绑定 `1000` 以下的端口的。\n\n确定后，在主机的 Terminal 中尝试连接。\n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## 共享文件夹\n在 Virtualbox 的「设置」→「共享文件夹」中设置共享根目录。\n\n![共享文件夹](virtualbox-archlinux/share.png)\n\n为了解决权限问题，不要选择「自动挂载」，而是手动配置自动挂载。\n\n### `rc.local` 服务\n\nArchlinux 的 systemd 原生不支持开机自动执行 `rc.local` 文件，所以我们需要先添加一个服务。\n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n输入以下内容：\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n保存后启用服务，并创建 `rc.local` 文件：\n\n```bash\nsudo systemctl enable rc-local\n```\n\n### 自动挂载脚本\n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n重启后，虚拟机中的主目录就和主机上的主目录共享啦。\n\n## SSH 免密码登录\n进行完以上步骤后，已经可以在主机通过 SSH 连接到虚拟机了，但需要输入密码。我们可以使用私钥认证的方式免去输入密码。\n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n一路回车后，会在 `~/.ssh` 目录下生成私钥和公钥。\n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n因为主机和虚拟机的主目录是共享的，所以在主机里设置后，虚拟机里也会生效。\n\n现在试试 SSH 连接到虚拟机，应该不需要密码了。\n\n## 配置 Terminal 快捷键\n众所周知，Terminal 中以默认设置打开新窗口的快捷键是 `Command + N`。我们也可以设置打开新窗口并 SSH 连接到虚拟机的快捷键。\n\n### 添加描述文件\n在 Terminal 的偏好设置中，选择「描述文件」，把「Basic」配置复制一份，命名为「Basic Linux」，并在 `Shell` 一栏中填写「运行命令」为 SSH，不勾选下方的「在 Shell 中运行」。\n\n![共享文件夹](virtualbox-archlinux/terminal.png)\n\n这样就已经可以在菜单中打开连接虚拟机的新窗口了。\n\n### 添加快捷键\n在系统偏好设置中添加快捷键：\n\n「系统偏好设置」→「键盘」→「快捷键」→「应用程序快捷键」→「添加」\n\n![共享文件夹](virtualbox-archlinux/hotkey.png)\n\n点击「添加」后，就可以使用快捷键啦！\n\n## 成果\n在 Terminal 中，按下 `Command + B`：\n\n![共享文件夹](virtualbox-archlinux/screenfetch.png)\n\n为了比较好的效果，可以改一下 `screenfetch`。\n","slug":"virtualbox-archlinux","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbtu000f7gxlijmr1ahv"},{"title":"「UVa 1362」Exploring Pyramids - 区间DP + 计数原理","date":"2016-03-14T08:32:16.000Z","_content":"\n给定一棵树的欧拉序列，树的子节点是有序的，求有多少棵树满足这个欧拉序列。\n\n<!-- more -->\n\n### 链接\n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### 题解\n书上的解法，用 $ f(i, j) $ 表示欧拉序列 $ S $ 中的第 $ i $ 到第 $ j $ 个字符所表示的树的数量，则有：\n\n1. 当 $ i = j $ 时，$ f(i, j) = 1 $；\n2. 当 $ S(i) \\neq S(j) $ 时，$ f(i, j) = 0 $，因为欧拉序列的第一个点和最后一个点都必须是根节点。\n\n欧拉序列的一个特点是，每一次回溯到根都会将根节点记录下来。所以我们可以枚举中转点 $ k $，当 $ i = k = j $ 时，递归计算 $ (i, k) $ 区间内（第一棵子树）的答案和 $ [k, j] $ 区间的答案（其它子树），并将其相乘。\n\n多组数据一定要清数组，一定要清数组，一定要清数组 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","source":"_posts/uva-1362.md","raw":"title: 「UVa 1362」Exploring Pyramids - 区间DP + 计数原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - DP\n  - 区间DP\n  - 计数原理\npermalink: uva-1362\ndate: 2016-03-14 16:32:16\n---\n\n给定一棵树的欧拉序列，树的子节点是有序的，求有多少棵树满足这个欧拉序列。\n\n<!-- more -->\n\n### 链接\n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### 题解\n书上的解法，用 $ f(i, j) $ 表示欧拉序列 $ S $ 中的第 $ i $ 到第 $ j $ 个字符所表示的树的数量，则有：\n\n1. 当 $ i = j $ 时，$ f(i, j) = 1 $；\n2. 当 $ S(i) \\neq S(j) $ 时，$ f(i, j) = 0 $，因为欧拉序列的第一个点和最后一个点都必须是根节点。\n\n欧拉序列的一个特点是，每一次回溯到根都会将根节点记录下来。所以我们可以枚举中转点 $ k $，当 $ i = k = j $ 时，递归计算 $ (i, k) $ 区间内（第一棵子树）的答案和 $ [k, j] $ 区间的答案（其它子树），并将其相乘。\n\n多组数据一定要清数组，一定要清数组，一定要清数组 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","slug":"uva-1362","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbv7000u7gxlzxk94ogp"},{"title":"「UVa 11806」Cheerleaders - 组合数 + 容斥原理","date":"2016-03-11T14:10:34.000Z","_content":"\n在一个 $ M * N $ 的矩阵中摆放 $ K $ 只石子，要求第一行、第一列、第 $ \nM $ 行、第 $ N $ 列必须有石子，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### 题解\n1. 设 $ A $、$ C $ 分别表示第一行、第 $ M $ \n行**没有**摆放石子的方案集合；\n2. 设 $ B $、$ D $ 分别表示第一列、第 $ N $ \n列**没有**摆放石子的方案集合；\n3. 设 $ S $ 表示在 $ M * N $ 的矩阵中**任意**摆放 $ K $ \n只石子的方案集合。\n\n则问题转化为，求在集合 $ S $ 内但不在集合 $ A $、$ B $、$ C $、$ D $ \n内的元素总数。\n\n由容斥原理得，答案\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n各个集合的元素数量可用组合数计算，组合数需要预处理。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11806.md","raw":"title: 「UVa 11806」Cheerleaders - 组合数 + 容斥原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 组合数学\n  - 容斥原理\npermalink: uva-11806\ndate: 2016-03-11 22:10:34\n---\n\n在一个 $ M * N $ 的矩阵中摆放 $ K $ 只石子，要求第一行、第一列、第 $ \nM $ 行、第 $ N $ 列必须有石子，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### 题解\n1. 设 $ A $、$ C $ 分别表示第一行、第 $ M $ \n行**没有**摆放石子的方案集合；\n2. 设 $ B $、$ D $ 分别表示第一列、第 $ N $ \n列**没有**摆放石子的方案集合；\n3. 设 $ S $ 表示在 $ M * N $ 的矩阵中**任意**摆放 $ K $ \n只石子的方案集合。\n\n则问题转化为，求在集合 $ S $ 内但不在集合 $ A $、$ B $、$ C $、$ D $ \n内的元素总数。\n\n由容斥原理得，答案\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n各个集合的元素数量可用组合数计算，组合数需要预处理。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11806","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbvk00167gxl3urcceuh"},{"title":"「UVa 11538」Chess Queen - 计数原理","date":"2016-03-12T02:47:13.000Z","_content":"\n在一个 $ N * M $ 棋盘中放置两个皇后，使得它们可以相互攻击，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### 题解\n两个皇后可以互相攻击，当且仅当它们在「同一行」或「同一列」或「同一对角线」。这三种情况互相独立，可以用加法原理。\n\n考虑「同一行」的情况，用 $ f(a, b) $ 表示在一个 $ a $ 行 $ b $ 列的棋盘中放置两个皇后在同一行的方案数。令 $ a = 1 $，此时第一个皇后有 $ b $ 种放置方法，第二个有 $ b - 1 $ 种，即\n\n$$ f(1, b) = b(b - 1) $$\n\n推广到多行的情况，每一行的情况互不影响，可以用加法原理，即：\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n「同一列」和「同一行」原理相同，行列数互换后代入上式即可。\n\n「同一对角线」的情况比较复杂，假设 $ m ≥ n $，则同一方向的对角线中，有 $ m - n + 1 $ 条的长度为 $ n $（蓝色部分），剩下的两边分别有 $ n - 1 $ 条长度递增。\n\n![（图片使用 \nLibreOffice Calc \n制作）](uva-11538/cells.png)\n\n中间的一撮所对应的情况相当于在一个 $ m - n + 1 $ 行 $ n $ 列的棋盘中放置，使得两个皇后在**同一行**，即 $ f(m - n + 1, n) $。\n\n两边长度递增的对角线也要按照类似「同一行」的方法推导，即：\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n但是根据题目的数据范围，$ O(n) $ 地每次计算是会超时的，考虑展开。\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n分别使用平方和公式和等差数列求和公式展开，得\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n这是一边的长度递增的对角线上的方案数，两边的要乘以二，因为有两个方向，所以最后还要乘以二。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11538.md","raw":"title: 「UVa 11538」Chess Queen - 计数原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 组合数学\n  - 计数原理\npermalink: uva-11538\ndate: 2016-03-12 10:47:13\n---\n\n在一个 $ N * M $ 棋盘中放置两个皇后，使得它们可以相互攻击，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### 题解\n两个皇后可以互相攻击，当且仅当它们在「同一行」或「同一列」或「同一对角线」。这三种情况互相独立，可以用加法原理。\n\n考虑「同一行」的情况，用 $ f(a, b) $ 表示在一个 $ a $ 行 $ b $ 列的棋盘中放置两个皇后在同一行的方案数。令 $ a = 1 $，此时第一个皇后有 $ b $ 种放置方法，第二个有 $ b - 1 $ 种，即\n\n$$ f(1, b) = b(b - 1) $$\n\n推广到多行的情况，每一行的情况互不影响，可以用加法原理，即：\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n「同一列」和「同一行」原理相同，行列数互换后代入上式即可。\n\n「同一对角线」的情况比较复杂，假设 $ m ≥ n $，则同一方向的对角线中，有 $ m - n + 1 $ 条的长度为 $ n $（蓝色部分），剩下的两边分别有 $ n - 1 $ 条长度递增。\n\n![（图片使用 \nLibreOffice Calc \n制作）](uva-11538/cells.png)\n\n中间的一撮所对应的情况相当于在一个 $ m - n + 1 $ 行 $ n $ 列的棋盘中放置，使得两个皇后在**同一行**，即 $ f(m - n + 1, n) $。\n\n两边长度递增的对角线也要按照类似「同一行」的方法推导，即：\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n但是根据题目的数据范围，$ O(n) $ 地每次计算是会超时的，考虑展开。\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n分别使用平方和公式和等差数列求和公式展开，得\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n这是一边的长度递增的对角线上的方案数，两边的要乘以二，因为有两个方向，所以最后还要乘以二。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11538","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbvq001e7gxl9cy7mn8s"},{"title":"「UVa 11375」Matches - 递推","date":"2016-03-13T03:07:45.000Z","_content":"\n有 $ N $ 个火柴，用这些火柴能摆出非负整数，摆出的数不能有前导零，火柴不必用完，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### 题解\n首先考虑不存在数字 0 的情况，用 $ f(i) $ 表示用 $ i $ 个火柴棒能摆出的方案总数，用 $ c(x) $ 表示摆出数字 x 使用的火柴棒数量。\n\n前导零是不被允许的，所以初始状态要把 1 ~ 9 几个数字的方案数加一。\n\n每次递推用 $ f(i) $ 去更新 $ f(i + c(x)) $（$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $），表示在 $ f(i) $ 表示的数字尾部添加一个 $ x $ 所得的方案。\n\n递推计算完成后求出前缀和 $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $ 即为答案，如果 $ n \\geq 6 $ 则需要将答案加一（考虑单独的数字 0）。\n\n需要使用高精度。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11375.md","raw":"title: 「UVa 11375」Matches - 递推\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - 高精度\npermalink: uva-11375\ndate: 2016-03-13 11:07:45\n---\n\n有 $ N $ 个火柴，用这些火柴能摆出非负整数，摆出的数不能有前导零，火柴不必用完，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### 题解\n首先考虑不存在数字 0 的情况，用 $ f(i) $ 表示用 $ i $ 个火柴棒能摆出的方案总数，用 $ c(x) $ 表示摆出数字 x 使用的火柴棒数量。\n\n前导零是不被允许的，所以初始状态要把 1 ~ 9 几个数字的方案数加一。\n\n每次递推用 $ f(i) $ 去更新 $ f(i + c(x)) $（$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $），表示在 $ f(i) $ 表示的数字尾部添加一个 $ x $ 所得的方案。\n\n递推计算完成后求出前缀和 $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $ 即为答案，如果 $ n \\geq 6 $ 则需要将答案加一（考虑单独的数字 0）。\n\n需要使用高精度。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11375","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbw7001k7gxl1x7it5p0"},{"title":"「UVa 11361」Investigating Div-Sum Property - 数位DP","date":"2016-03-15T00:53:05.000Z","_content":"\n问在区间 $ [a, b] $ 内有多少数 $ x $ 满足：\n\n1. $ x $ 是 $ k $ 的倍数；\n2. $ x $ 的各位数之和是 $ k $ 的倍数。\n\n<!-- more -->\n\n### 链接\n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### 题解\n设 $ {\\rm sum}(x) $ 表示 $ x $ 的各位数之和，$ g(x, m_1, m_2) $ 表示 $ [0, x] $ 内有多少正整数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，问题转化为求 $ g(b, 0, 0) - g(a - 1, 0, 0) $。\n\n设 $ f(n, m_1, m_2) $ 表示有多少 $ n $ 位数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，计算 $ f $ 函数可以枚举最高位数字 1 ~ 9，并递归计算。\n\n$ g $ 函数也可以递归求，设参数 $ x $ 的最高位上的数为 $ t $，则可以先在 $ [0, t) $ 枚举最高位上的数，此时后面的低位数是任意的，可以由 $ f $ 函数来计算；最后令最高位为 $ x $，递归处理低位的数，累加起来就是答案。\n\n题目有坑，$ k $ 较大时结果直接为零 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11361.md","raw":"title: 「UVa 11361」Investigating Div-Sum Property - 数位DP\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - DP\n  - 数位DP\npermalink: uva-11361\ndate: 2016-03-15 08:53:05\n---\n\n问在区间 $ [a, b] $ 内有多少数 $ x $ 满足：\n\n1. $ x $ 是 $ k $ 的倍数；\n2. $ x $ 的各位数之和是 $ k $ 的倍数。\n\n<!-- more -->\n\n### 链接\n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### 题解\n设 $ {\\rm sum}(x) $ 表示 $ x $ 的各位数之和，$ g(x, m_1, m_2) $ 表示 $ [0, x] $ 内有多少正整数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，问题转化为求 $ g(b, 0, 0) - g(a - 1, 0, 0) $。\n\n设 $ f(n, m_1, m_2) $ 表示有多少 $ n $ 位数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，计算 $ f $ 函数可以枚举最高位数字 1 ~ 9，并递归计算。\n\n$ g $ 函数也可以递归求，设参数 $ x $ 的最高位上的数为 $ t $，则可以先在 $ [0, t) $ 枚举最高位上的数，此时后面的低位数是任意的，可以由 $ f $ 函数来计算；最后令最高位为 $ x $，递归处理低位的数，累加起来就是答案。\n\n题目有坑，$ k $ 较大时结果直接为零 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11361","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbwl001s7gxlxnu0xt5b"},{"title":"「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元","date":"2016-03-13T09:20:34.000Z","_content":"\n分别属于多个家族的 $ N $（$ N \\leq 40000 $）个人想要站成一排，但没有人想站在他爹前面，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### 题解\n题目描述的父子关系组成了一个森林，每个家族对应一棵树，我们可以添加一个虚拟节点，让它成为每个家族祖先的「父亲」，然后求出整棵树的方案数即为答案。\n\n用 $ f(i) $ 表示以 $ i $ 为根的子树的方案数，用 $ s(i) $ 表示以 $ i $ 为根的子树的大小。\n\n首先，$ i $ 的几棵子树各自的排列方案是相互独立的，可以使用乘法原理来计算。\n\n还要注意一点，$ i $ 的几棵子树的节点是可以穿插排列的，即只需要保证每对父子的相对位置而整体是无序的。如果对所有子树的节点做全排列，那么改变了原有的父子相对位置的排列方案都是无效的，即**同一种穿插方式中多次改变父子相对位置只有一次有效**。我们可以把同一个子树的节点看做相同的，然后做**有重复元素的全排列**，就可以得到正确结果，因为每一种排列都对应且只对应一种顺序。\n\n「子树各自的排列方案」和「节点的穿插顺序」是相互独立的，因此要用乘法原理。\n\n用 $ c(i) $ 表示 $ i $ 的子节点的集合，则递归计算的公式为：\n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n公式中使用了除法，模意义下的除以一个数等于乘以这个数的**乘法逆元**，所以要在程序开始时递推预处理出所有数的阶乘，并求出对应的乘法逆元。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11174.md","raw":"title: 「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 数论\n  - 递推\n  - 计数原理\n  - 乘法逆元\n  - 全排列\npermalink: uva-11174\ndate: 2016-03-13 17:20:34\n---\n\n分别属于多个家族的 $ N $（$ N \\leq 40000 $）个人想要站成一排，但没有人想站在他爹前面，求方案总数。\n\n<!-- more -->\n\n### 链接\n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### 题解\n题目描述的父子关系组成了一个森林，每个家族对应一棵树，我们可以添加一个虚拟节点，让它成为每个家族祖先的「父亲」，然后求出整棵树的方案数即为答案。\n\n用 $ f(i) $ 表示以 $ i $ 为根的子树的方案数，用 $ s(i) $ 表示以 $ i $ 为根的子树的大小。\n\n首先，$ i $ 的几棵子树各自的排列方案是相互独立的，可以使用乘法原理来计算。\n\n还要注意一点，$ i $ 的几棵子树的节点是可以穿插排列的，即只需要保证每对父子的相对位置而整体是无序的。如果对所有子树的节点做全排列，那么改变了原有的父子相对位置的排列方案都是无效的，即**同一种穿插方式中多次改变父子相对位置只有一次有效**。我们可以把同一个子树的节点看做相同的，然后做**有重复元素的全排列**，就可以得到正确结果，因为每一种排列都对应且只对应一种顺序。\n\n「子树各自的排列方案」和「节点的穿插顺序」是相互独立的，因此要用乘法原理。\n\n用 $ c(i) $ 表示 $ i $ 的子节点的集合，则递归计算的公式为：\n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n公式中使用了除法，模意义下的除以一个数等于乘以这个数的**乘法逆元**，所以要在程序开始时递推预处理出所有数的阶乘，并求出对应的乘法逆元。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11174","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbws00207gxlao5ulilq"},{"title":"「UVa 11137」Ingenuous Cubrency - 递推 / 背包DP","date":"2016-03-13T03:56:43.000Z","_content":"\n给出一个正整数 $ N $（$ N \\leq 1000 $），求有多少种方案把 $ N $ 表示成几个正整数的立方和的形式。\n\n<!-- more -->\n\n### 链接\n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### 题解\n书上的解法：用 $ f(i, j) $ 表示使用不超过 $ i $ 的整数的立方和表示数 $ j $ 的方案数。以 i 为阶段进行递推，对于每个 j，枚举新一个 $ i^3 $ 项的系数 $ x $ 使 $ j + xi^3 \\leq 1000 $，用 $ f(i - 1, j) $ 去更新 $ f(i, j + xi^3) $。最后 $ f(21, n) $ 即为答案。\n\n书上在最后提到可以优化。考虑将每个立方数看做物品，将 1000 看做背包，则问题转化为：求装满背包的方案。\n\n直接进行完全背包即可。\n\n### 代码\n#### 解法一\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### 解法二\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11137.md","raw":"title: 「UVa 11137」Ingenuous Cubrency - 递推 / 背包DP\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - DP\n  - 背包DP\npermalink: uva-11137\ndate: 2016-03-13 11:56:43\n---\n\n给出一个正整数 $ N $（$ N \\leq 1000 $），求有多少种方案把 $ N $ 表示成几个正整数的立方和的形式。\n\n<!-- more -->\n\n### 链接\n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### 题解\n书上的解法：用 $ f(i, j) $ 表示使用不超过 $ i $ 的整数的立方和表示数 $ j $ 的方案数。以 i 为阶段进行递推，对于每个 j，枚举新一个 $ i^3 $ 项的系数 $ x $ 使 $ j + xi^3 \\leq 1000 $，用 $ f(i - 1, j) $ 去更新 $ f(i, j + xi^3) $。最后 $ f(21, n) $ 即为答案。\n\n书上在最后提到可以优化。考虑将每个立方数看做物品，将 1000 看做背包，则问题转化为：求装满背包的方案。\n\n直接进行完全背包即可。\n\n### 代码\n#### 解法一\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### 解法二\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11137","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbx0002c7gxl4tcfmtol"},{"title":"「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数","date":"2016-03-15T07:35:55.000Z","_content":"\n串并联网络有两个端点，一个是源，一个是汇，递归定义如下：\n\n1. 一条单独的边是串并联网络；\n2. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将它们的源和汇分别接在一起也能得到串并联网络（并联）；\n3. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将 $ G1 $ 的源和 $ G2 $ 的汇接在一起也能得到串并联网络（串联）；\n\n并联或串联在一起的各个部分可以调换顺序，顺序改变后的串并联网络和之前是相同的。求 $ N $ 条边能组成多少种不同的串并联网络。\n\n<!-- more -->\n\n### 链接\n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### 题解\n书上的解法，考虑每个串并联网络都是一棵树，组成网络的几个部分是树的子节点，那么叶子节点就对应了网络中的边，并且整棵树从根到叶子，父子关系所代表的连接方式是交替着的，某一层是并联，则下一层即为串联。同一种树的形态，第一层的连接方式不同，也就对应了两个网络。\n\n问题转化为，求有多少子节点有序且有 $ N $ 个叶子节点的形态不同的树。设 $ f(n) $ 为答案，则可以根据各个子树所『分得』的叶子节点数量来递归求解 —— 回溯法枚举 $ n $ 的**整数划分**，就得到了单层子树所有的情况。\n\n假设整数划分的某一种方案中，有 $ k $ 个 $ i $，求这 $ k $ 棵子树的方案数可使用组合数：从 $ f(i) $ 个中选择 $ k $ 个，可重复选择，答案为 $ \\binom{f(i) + k - 1}{k} $。计算出每一组子树的方案数，相乘即为根节点的答案。\n\n最终答案为 $ f(n) * 2 $，注意 $ n = 1 $ 时答案为 $ 1 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","source":"_posts/uva-10253.md","raw":"title: 「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - 计数原理\n  - 组合数\n  - 整数划分\n  - 回溯\npermalink: uva-10253\ndate: 2016-03-15 15:35:55\n---\n\n串并联网络有两个端点，一个是源，一个是汇，递归定义如下：\n\n1. 一条单独的边是串并联网络；\n2. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将它们的源和汇分别接在一起也能得到串并联网络（并联）；\n3. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将 $ G1 $ 的源和 $ G2 $ 的汇接在一起也能得到串并联网络（串联）；\n\n并联或串联在一起的各个部分可以调换顺序，顺序改变后的串并联网络和之前是相同的。求 $ N $ 条边能组成多少种不同的串并联网络。\n\n<!-- more -->\n\n### 链接\n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### 题解\n书上的解法，考虑每个串并联网络都是一棵树，组成网络的几个部分是树的子节点，那么叶子节点就对应了网络中的边，并且整棵树从根到叶子，父子关系所代表的连接方式是交替着的，某一层是并联，则下一层即为串联。同一种树的形态，第一层的连接方式不同，也就对应了两个网络。\n\n问题转化为，求有多少子节点有序且有 $ N $ 个叶子节点的形态不同的树。设 $ f(n) $ 为答案，则可以根据各个子树所『分得』的叶子节点数量来递归求解 —— 回溯法枚举 $ n $ 的**整数划分**，就得到了单层子树所有的情况。\n\n假设整数划分的某一种方案中，有 $ k $ 个 $ i $，求这 $ k $ 棵子树的方案数可使用组合数：从 $ f(i) $ 个中选择 $ k $ 个，可重复选择，答案为 $ \\binom{f(i) + k - 1}{k} $。计算出每一组子树的方案数，相乘即为根节点的答案。\n\n最终答案为 $ f(n) * 2 $，注意 $ n = 1 $ 时答案为 $ 1 $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","slug":"uva-10253","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbx6002k7gxl6nvld6fc"},{"title":"「Tyvj 3317」火车票 - 划分DP","id":"18","updated":"2016-01-19T13:05:08.000Z","date":"2016-01-11T21:29:30.000Z","_content":"\n铁路线上有n（2 ≤ n ≤ 10000）个火车站，每个火车站到该线路的首发火车站距离都是已知的。任意两站之间的票价如下表所示：\n\n$$\\cases{0< X≤L1 & C1 \\\\ L1< X≤L2 & C2 \\\\ L2< X≤L3 & C3}$$\n\n其中L1，L2，L3，C1，C2，C3都是已知的正整数，且($1 ≤ L1 < L2 < L3 ≤ 10^9$, $1 ≤ C1 < C2 < C3 ≤ 10^9$)。显然若两站之间的距离大于 L3，那么从一站到另一站至少要买两张票。\n\n注意：每一张票在使用时只能从一站开始到另一站结束。\n\n对于给出的起点和终点，求出最省钱的方案。\n\n<!-- more -->\n\n### 链接\n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### 题解\n以经过火车站站点的数量划分阶段，用 $a[i]$表示从站点 `0` 到站点 `i` 的距离，用 $f[i]$ 表示从起点 `s` 到站点 `i` 所需要的最少花费，则转移方程为：\n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]≤L3\\} $$\n\n边界条件为\n\n$$ f[s] = 0 $$\n\n### 代码\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```","source":"_posts/tyvj-3317.md","raw":"title: 「Tyvj 3317」火车票 - 划分DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - 划分DP\npermalink: tyvj-3317\nid: 18\nupdated: '2016-01-19 21:05:08'\ndate: 2016-01-12 05:29:30\n---\n\n铁路线上有n（2 ≤ n ≤ 10000）个火车站，每个火车站到该线路的首发火车站距离都是已知的。任意两站之间的票价如下表所示：\n\n$$\\cases{0< X≤L1 & C1 \\\\ L1< X≤L2 & C2 \\\\ L2< X≤L3 & C3}$$\n\n其中L1，L2，L3，C1，C2，C3都是已知的正整数，且($1 ≤ L1 < L2 < L3 ≤ 10^9$, $1 ≤ C1 < C2 < C3 ≤ 10^9$)。显然若两站之间的距离大于 L3，那么从一站到另一站至少要买两张票。\n\n注意：每一张票在使用时只能从一站开始到另一站结束。\n\n对于给出的起点和终点，求出最省钱的方案。\n\n<!-- more -->\n\n### 链接\n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### 题解\n以经过火车站站点的数量划分阶段，用 $a[i]$表示从站点 `0` 到站点 `i` 的距离，用 $f[i]$ 表示从起点 `s` 到站点 `i` 所需要的最少花费，则转移方程为：\n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]≤L3\\} $$\n\n边界条件为\n\n$$ f[s] = 0 $$\n\n### 代码\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```","slug":"tyvj-3317","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbxh002w7gxl6cmbeyyp"},{"title":"「TJOI2013」最长上升子序列 - 离线 + 树状数组","date":"2016-04-03T14:49:33.000Z","_content":"\n给定一个序列，初始为空。现在我们将 $ 1 $ 到 $ N $ 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？\n\n<!-- more -->\n\n### 链接\n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### 题解\n首先，将操作离线，可以得到最终序列中每个元素的位置。\n\n因为是从小到大加入，所以对某个元素的答案有贡献的元素仅为位置比它小且在它之前加入的元素，所以直接用一个树状数组维护前缀最大值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-lis.md","raw":"title: 「TJOI2013」最长上升子序列 - 离线 + 树状数组\ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - 离线\n  - Splay\n  - 树状数组\npermalink: tjoi2015-lis\ndate: 2016-04-03 22:49:33\n---\n\n给定一个序列，初始为空。现在我们将 $ 1 $ 到 $ N $ 的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？\n\n<!-- more -->\n\n### 链接\n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### 题解\n首先，将操作离线，可以得到最终序列中每个元素的位置。\n\n因为是从小到大加入，所以对某个元素的答案有贡献的元素仅为位置比它小且在它之前加入的元素，所以直接用一个树状数组维护前缀最大值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tjoi2015-lis","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbxp00357gxliegcw6sq"},{"title":"Tarjan 强联通分量学习笔记","date":"2016-03-03T13:12:23.000Z","_content":"\n在一个有向图中，如果某两点间都有**互相**到达的路径，那么称中两个点**强联通**，如果任意两点都强联通，那么称这个图为**强联通图**；一个有向图的**极大**强联通子图称为**强联通分量**。\n\nTarjan 算法可以在 $ O(n + m) $ 的时间内求出一个图的所有强联通分量。\n\n<!-- more -->\n\n### 定义\nTarjan 算法的核心过程是一次 DFS，它基于的事实是，一个强联通分量中的点一定处于搜索树中同一棵子树中。\n\n栈，搜索树中同一棵子树中的点在栈中是相邻的。\n\n$ {\\rm dfn}(u) $ 表示进入节点 $ u $ 时的时间。\n\n$ {\\rm low}(u) $ 表示由节点 $ u $ 开始搜索所能到达的点中，在搜索树上是 $ u $ 的祖先且 $ {\\rm dfn} $ 最小的节点的 $ {\\rm dfn} $。\n\n### 算法描述\n1. 从起点开始 DFS；\n2. 进入一个节点时，初始化它的 $ {\\rm dfn} $ 和 $ {\\rm low} $ 均为当前时间戳，并进栈；\n3. 枚举当前点 $ v $ 的所有邻接点；\n4. 如果某个邻接点 $ u $ 已在栈中，则更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $；\n5. 如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $；\n6. 所有邻接点回溯完成后，如果当前点仍满足 $ {\\rm low}(v) = {\\rm dfn}(v) $，则将栈中从 $ v $ 到栈顶的所有元素出栈，并标记为一个强联通分量。\n\n### 解释\n枚举 $ v $ 的邻接点时，如果某个邻接点 $ u $ 已在栈中，则更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n因为栈中的所有点均为搜索树上点 $ v $ 的祖先，从搜索树上一个点搜到它的祖先，说明找到了一个环。此时用 $ u $ 去更新 $ v $ 的最远祖先。\n\n如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n点 $ u $ 出发能到达的点，点 $ v $ 必定也能到达。尽管 $ {\\rm low}(u) $ 可能不是 $ v $ 的祖先（可能是 $ u $ 或 $ v $ 本身），但这并不影响。\n\n所有邻接点回溯完成后，如果当前点仍满足\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n说明从当前点出发不可能回到任意一个搜索树上的祖先，即当前节点是某个强联通分量所在子树的根节点，而这些节点都在当前节点之后被压在了栈中。\n\n注意，$ {\\rm low} $ 值相同的两个点**一定**在同一个强联通分量中，但反之不成立，同一个强联通分量的点可能有不同的 $ {\\rm low} $ 值。\n\n### 模板\n实际代码中要用到两个栈，一个用于控制 DFS（代码中的 `s`），另一个用于 Tarjan 算法（代码中的 `t`）。\n\n因为图不一定是弱连通图，所以要以每个点为起点进行一次上述算法。\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","source":"_posts/tarjan-scc-notes.md","raw":"title: Tarjan 强联通分量学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 强联通分量\n  - Tarjan\n  - 算法模板\npermalink: tarjan-scc-notes\ndate: 2016-03-03 21:12:23\n---\n\n在一个有向图中，如果某两点间都有**互相**到达的路径，那么称中两个点**强联通**，如果任意两点都强联通，那么称这个图为**强联通图**；一个有向图的**极大**强联通子图称为**强联通分量**。\n\nTarjan 算法可以在 $ O(n + m) $ 的时间内求出一个图的所有强联通分量。\n\n<!-- more -->\n\n### 定义\nTarjan 算法的核心过程是一次 DFS，它基于的事实是，一个强联通分量中的点一定处于搜索树中同一棵子树中。\n\n栈，搜索树中同一棵子树中的点在栈中是相邻的。\n\n$ {\\rm dfn}(u) $ 表示进入节点 $ u $ 时的时间。\n\n$ {\\rm low}(u) $ 表示由节点 $ u $ 开始搜索所能到达的点中，在搜索树上是 $ u $ 的祖先且 $ {\\rm dfn} $ 最小的节点的 $ {\\rm dfn} $。\n\n### 算法描述\n1. 从起点开始 DFS；\n2. 进入一个节点时，初始化它的 $ {\\rm dfn} $ 和 $ {\\rm low} $ 均为当前时间戳，并进栈；\n3. 枚举当前点 $ v $ 的所有邻接点；\n4. 如果某个邻接点 $ u $ 已在栈中，则更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $；\n5. 如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $；\n6. 所有邻接点回溯完成后，如果当前点仍满足 $ {\\rm low}(v) = {\\rm dfn}(v) $，则将栈中从 $ v $ 到栈顶的所有元素出栈，并标记为一个强联通分量。\n\n### 解释\n枚举 $ v $ 的邻接点时，如果某个邻接点 $ u $ 已在栈中，则更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n因为栈中的所有点均为搜索树上点 $ v $ 的祖先，从搜索树上一个点搜到它的祖先，说明找到了一个环。此时用 $ u $ 去更新 $ v $ 的最远祖先。\n\n如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n点 $ u $ 出发能到达的点，点 $ v $ 必定也能到达。尽管 $ {\\rm low}(u) $ 可能不是 $ v $ 的祖先（可能是 $ u $ 或 $ v $ 本身），但这并不影响。\n\n所有邻接点回溯完成后，如果当前点仍满足\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n说明从当前点出发不可能回到任意一个搜索树上的祖先，即当前节点是某个强联通分量所在子树的根节点，而这些节点都在当前节点之后被压在了栈中。\n\n注意，$ {\\rm low} $ 值相同的两个点**一定**在同一个强联通分量中，但反之不成立，同一个强联通分量的点可能有不同的 $ {\\rm low} $ 值。\n\n### 模板\n实际代码中要用到两个栈，一个用于控制 DFS（代码中的 `s`），另一个用于 Tarjan 算法（代码中的 `t`）。\n\n因为图不一定是弱连通图，所以要以每个点为起点进行一次上述算法。\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","slug":"tarjan-scc-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbyb003h7gxlp28x0bwb"},{"title":"差分约束系统学习笔记","date":"2016-01-01T16:18:34.000Z","_content":"\n差分约束系统，就是给出一组形如 $x_i-x_j>=d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。\n\n<!-- more -->\n\n### 原理\n在图论中，求解单源最短路的算法在进行每一次每条边上的“松弛”操作时，都是根据以下条件：\n\n（其中 `from`、`to` 表示边的起点、终点，`$` 表示某个点到源点的当前距离）\n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n也就是说，每一次松弛操作保证了：\n\n```php\n$to - $from >= w\n```\n\n于是，我们可以把差分约束系统中的变量看做图中的**点**，把不等关系看做**边**，然后对整个图进行一次单源最短路算法，即可使所有不等式满足。\n\n如果图中存在**权值和为负**的环，则说明不等式组无解。\n\n### 实现\n对于每一个不等式 $x_i-x_j>=d$，从 `j` 向 `i` 连一条边，权值为 `d`。\n\n如果不等号的方向相反，即 $x_i-x_j>=d$，则应在不等式两边同时乘以 `-1`，变成 $x_j-x_i<=-d$，即从 `i` 到 `j` 连一条边，权值为 `-d`。\n\n算法初始化时，将源点的 `dist` 置为 `0`，其他的点 `dist` 置为无穷大。若有解，则算法结束后每个点的 `dist` 值即为解。\n\n如果图中有负边，则必须使用 Bellman-Ford 算法，如果 Bellman-Ford 算法在 `n - 1` 次松弛后还继续进行松弛，则说明图中有**权值和为负**的环，原不等式组无解。\n\n如果使用带有队列优化的 Bellman-Ford 算法，则每个点入队次数超过 `n` 时说明图中有**权值和为负**的环，原不等式组无解。\n\n### 例题\n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF 团卧底的后宫\n\n给出 `n` 个形如 $x_i-x_j<=d$ 或 $x_i-x_j>=d$ 的不等式，求一组使 $x_1$ 与 $x_n$ 差最大的解，输出最大差值，若无解输出 `-1`，若 $x_1$ 与 $x_n$ 的差为无限大则输出 `-2`。\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/system-of-difference-constraints-notes.md","raw":"title: 差分约束系统学习笔记\ncategories: OI\ntags: \n  - 图论\n  - 学习笔记\n  - 差分约束系统\n  - 最短路\n  - 算法模板\npermalink: system-of-difference-constraints-notes\ndate: 2016-01-02 00:18:34\n---\n\n差分约束系统，就是给出一组形如 $x_i-x_j>=d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。\n\n<!-- more -->\n\n### 原理\n在图论中，求解单源最短路的算法在进行每一次每条边上的“松弛”操作时，都是根据以下条件：\n\n（其中 `from`、`to` 表示边的起点、终点，`$` 表示某个点到源点的当前距离）\n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n也就是说，每一次松弛操作保证了：\n\n```php\n$to - $from >= w\n```\n\n于是，我们可以把差分约束系统中的变量看做图中的**点**，把不等关系看做**边**，然后对整个图进行一次单源最短路算法，即可使所有不等式满足。\n\n如果图中存在**权值和为负**的环，则说明不等式组无解。\n\n### 实现\n对于每一个不等式 $x_i-x_j>=d$，从 `j` 向 `i` 连一条边，权值为 `d`。\n\n如果不等号的方向相反，即 $x_i-x_j>=d$，则应在不等式两边同时乘以 `-1`，变成 $x_j-x_i<=-d$，即从 `i` 到 `j` 连一条边，权值为 `-d`。\n\n算法初始化时，将源点的 `dist` 置为 `0`，其他的点 `dist` 置为无穷大。若有解，则算法结束后每个点的 `dist` 值即为解。\n\n如果图中有负边，则必须使用 Bellman-Ford 算法，如果 Bellman-Ford 算法在 `n - 1` 次松弛后还继续进行松弛，则说明图中有**权值和为负**的环，原不等式组无解。\n\n如果使用带有队列优化的 Bellman-Ford 算法，则每个点入队次数超过 `n` 时说明图中有**权值和为负**的环，原不等式组无解。\n\n### 例题\n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF 团卧底的后宫\n\n给出 `n` 个形如 $x_i-x_j<=d$ 或 $x_i-x_j>=d$ 的不等式，求一组使 $x_1$ 与 $x_n$ 差最大的解，输出最大差值，若无解输出 `-1`，若 $x_1$ 与 $x_n$ 的差为无限大则输出 `-2`。\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"system-of-difference-constraints-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbyi003t7gxlf8ok45rs"},{"title":"后缀数组学习笔记","date":"2016-04-12T11:29:14.000Z","_content":"\n在 OI 竞赛中，有一类题目是面向字符串的。这类题目往往要求选手的程序快速地求出给定的字符串的某些信息，这就需要一些对应的数据结构和算法来维护字符串。后缀数组就是一个这样的数据结构 —— 它通过对字符串后缀的处理，可以方便地得到子串的信息。\n\n<!-- more -->\n\n### 定义\n字符串 $ s $ 连续的一段字符组成的串叫做字符串，更广义地，任何一个由可比较大小的元素组成的数组都可称为字符串。字符串的下标从 $ 0 $ 开始，长度为 $ {\\rm length}(s) $。\n\n后缀：$ {\\rm suffix}(i) $ 表示字符串 $ s $ 从第 $ i $ 个位置开始的后缀，即由 $ s[i] $ ~ $ s[n - 1] $ 组成的子串。\n\n字符串的比较：  \n两个字符串大小的比较，从首位开始，一位一位地按照 ASCII 码比较，如果从某位置开始不相同，则认为该位置处字符 ASCII 码小的字符串小；  \n如果一个字符串比较完了最后一位，而另一个没有，则认为前者（长度小的）小；  \n如果两个字符串长度相同并且所有位置上的字符均相同，则认为两个字符串相等。\n\n注意，同一个字符串的两个后缀是不可能相等的，因为无法满足相等的必要条件**长度相同**。\n\n后缀数组：$ {\\rm SA}[] $ 是一个一维数组，保存了对字符串 $ s $ 的所有后缀排序后的结果。$ {\\rm SA}[i] $ 表示第 $ i $ 小的后缀在原串中的起始位置。\n\n名次数组：$ {\\rm rank}[] $ 是一个一维数组，按起始位置保存了每个后缀在 $ {\\rm SA}[] $ 中的排名。$ {\\rm rank}[i] $ 表示 $ {\\rm suffix}(i) $ 的排名，即 $ {\\rm rank}[{\\rm SA}[i]] = i $（第 $ i $ 小的后缀的排名为 $ i $）。\n\n高度数组：$ {\\rm height}[] $ 是一个一维数组，保存了相邻两个后缀的最长公共前缀（Longest Common Prefix，LCP）长度。\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n即 $ {\\rm height}[i] $ 表示存在的最大的 $ x $，满足对于任何 $ k \\in [0, x) $ 有 $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $。\n\n### 后缀数组与名次数组的构造\n#### 朴素构造算法\n如果我们直观地通过定义来构造后缀数组与名次数组（即将每个后缀看做独立的字符串进行快速排序），时间复杂度为 $ O(n ^ 2 \\log n) $，但平方级别的复杂度通常是无法承受的。\n\n上述构造方法的瓶颈在于**字符串的比较**，原串的每个后缀的长度是 $ O(n) $ 级别的，最坏情况下需要 $ O(n) $ 次比较操作才能得到两个后缀的大小关系。\n\n##### 基于 Hash 的优化\n考虑对字符串进行 Hash。使用 BKDRHash 算法 $ O(n) $ 地预处理整个字符串后，可以 $ O(1) $ 地得到任意子串的 Hash 值，比较两个子串是否相等。\n\n这样，我们就得到了一个改进算法：比较两个后缀时，二分它们的 LCP 长度，并比较第一位不同的字符，总时间复杂度为 $ O(n \\log n \\log n) $。\n\n使用 Hash 来构造后缀数组的好处在于时间复杂度较低，并且可以动态维护（使用 `std::set`），坏处在于 Hash 的不稳定性。\n\n#### 倍增算法\n上述两个算法，我们都是将两个后缀看做独立字符串进行比较，而忽视了后缀之间的内在联系。一个更优的算法是**倍增算法**，它的主要思路是，每次利用上一次的结果，倍增计算出从每个位置 $ i $ 开始长度为 $ 2 ^ k $ 的子串的排名。\n\n算法的开始，我们有 `\"heheda\"`，从每个位置开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名分别为：\n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n为了求出长度为 $ 2 ^ 1 = 2 $ 的子串的排名，我们以每个位置 $ i $ 开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名作为位置 $ i $ 的**第一关键字**，以每个位置 $ i + 2 ^ 0 = i + 1 $ 开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名作为位置 $ i $ 的**第二关键字**，进行双关键字排序。\n\n对于 $ i + 2 ^ 0 \\geq n $ 的位置，我们用一个比其他所有值都小的数作为它的第二关键字，即 $ -1 $。\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n重复以上过程，求出长度为 $ 2 ^ 2 = 4 $ 的子串的排名：\n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n可以看出，这时候 $ {\\rm rank}[] $ 数组的最终值已被求出。而对于任何一组数据，显然可以在最坏情况下 $ O(\\log n) $ 轮上述过程后，求出 $ {\\rm rank}[] $ 数组的最终值。\n\n如果使用快速排序来实现双关键字排序，总时间复杂度为 $ O(n \\log n \\log n) $，实现难度比 Hash 的方法要低，并且更稳定。而考虑到每个关键字均为 $ [-1, n) $ 的整数，我们可以使用 $ O(n) $ 的基数排序，来将总时间复杂度将为 $ O(n \\log n) $。\n\n##### 代码\n\n首先，将原数据进行离散化，保证每个元素的值在 $ [0, n) $ 内。\n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir` 和 `sec` 分别表示第一关键字和第二关键字，`buc` 表示基数排序所用的桶。关键字的取值范围为 $ [-1, n) $，需要用到负数下标。\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n对每个单独的字符进行排序，得到它们的排名。\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n进行 $ O(\\log n) $ 次迭代（下文代码均为循环内操作）。\n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n设置每个位置的第一、第二关键字。\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n对第二关键字进行排序，$ {\\rm tmp}[i] $ 存储第 $ i $ **大**的第二关键字的所在位置。\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n对第一关键字进行排序，按照 $ {\\rm tmp}[] $ 中的顺序依次领取排名，在 $ {\\rm tmp}[] $ 中靠前的位置将较早领取排名，而较早领取到的排名较大。\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n按照后缀数组 $ {\\rm SA}[] $ 中的顺序求出名次数组 $ {\\rm rank}[] $，因为中间过程中排名会有并列，所以要分情况讨论：\n\n1. 没有前一名，当前位置的排名为 $ 0 $；\n2. 当前位置和前一名位置的第一、第二关键字均相等，当前位置的排名与前一位置的排名相等；\n3. 当前位置和前一名位置的第一或第二关键字不相等，当前位置的排名为前一位置的排名 $ + 1 $；\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n由于倍增算法时间复杂度较为优秀，并且实现难度不高，在实践中较为常用。另外，后缀数组也有线性的构造方法，例如 DC3，但其实现难度较高，实际应用不如倍增算法广。\n\n### 高度数组的计算\n后缀数组的大部分应用，都需要高度数组 $ {\\rm height}[] $ 的辅助，如果我们按照定义去计算 $ {\\rm height}[] $，最坏的时间复杂度为 $ O(n ^ 2) $。平方级别的复杂度仍然是无法承受的。\n\n#### 性质\n定义 $ h(i) $ 表示从第 $ i $ 个位置开始的后缀与排在其前一名的后缀的最长公共前缀，即当 $ {\\rm rank}[i] > 0 $ 时，有\n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n对于 $ h(i) $，有一个结论\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n当 $ h(i - 1) < 1 $ 时，结论显然是成立的，下面我们主要考虑 $ h(i - 1) \\geq 1 $ 的情况。\n\n令 $ u = {\\rm suffix}(i) $，$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $，即排在第 $ i $ 个位置的后缀和排在它前面一位的后缀；  \n令 $ u' = {\\rm suffix}(i - 1) $，$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $，即排在第 $ i - 1 $ 个位置的后缀和排在它前面一位的后缀。\n\n我们需要证明 $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $。\n\n现在换一个字符串 `\"heheheda\"` 作为例子，关系对应如下：\n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n当 $ h(i - 1) \\geq 1 $ 时，$ u' $ 与 $ v' $ 的第一个字符必定相等，同时去掉其第一个字符后，所得的两个新的后缀的最长公共前缀长度为 $ {\\rm LCP}(u', v') - 1 $。这两个后缀不一定是 $ u $ 和 $ v $（如果它们排名\t不相邻的话），但在后缀数组中，这两个后缀一定确定了一个包含 $ u $ 和 $ v $ 的区间（考虑位置靠前或靠后的后缀的影响），所以，结合下文中关于最长公共前缀的部分内容，$ {\\rm LCP}(u, v) $ 一定不会比它更小。\n\n#### 代码\n有了这一性质，我们可以按照 $ {\\rm height}[{\\rm SA}[i]] $ 的顺序递推。  \n设 $ k = {\\rm height}[{\\rm rank}[i - 1]] $（即上文的 $ h(i - 1) $），显然在计算每个 $ {\\rm height}[{\\rm rank}[i]] $ 时，$ k $ 每次减小 $ 1 $，最多增加到 $ n $，所以这个过程的时间复杂度为 $ O(n) $。  \n相对于前面 $ O(n \\log n) $ 的过程，线性的复杂度已经不会成为瓶颈。\n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n值得注意的是，$ {\\rm height}[0] $ 的值是无效的，因为排名最靠前的后缀没有前一名。\n\n### 最长公共前缀\n通过高度数组 $ {\\rm height}[] $，我们可以得到排名相邻的两个后缀的最长公共前缀。\n\n对于排名不相邻的两个后缀，它们的前缀的相似性比相邻后缀要差。显然排名不相邻的两个后缀的最长公共前缀长度**一定不会**比这两个后缀在后缀数组中确定的一段**区间中任意两个**相邻后缀的最长公共前缀长度**更长**。\n\n所以，求出这段区间内最小的 $ {\\rm height} $ 值即为这两个不相邻后缀的最长公共前缀长度。\n\n问题转化为区间最值查询（Range Minimum/Maximum Query，RMQ）问题，可以使用稀疏表（Sparse Table，ST）算法解决。该算法在 $ O(n \\log n) $ 的时间内预处理，并在 $ O(1) $ 的时间内完成每个询问。\n\n#### 代码\n代码中 $ {\\rm st}[i][t] $ 表示起始位置在 $ [i, i + 2 ^ t] $ 之间的所有相邻后缀的最长公共前缀长度的最小值，即 $ {\\rm LCP}(i, i + 2 ^ t) $。\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### 模板\n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","source":"_posts/suffix-array-notes.md","raw":"title: 后缀数组学习笔记\ncategories: OI\ntags: \n  - 后缀数组\n  - 字符串\n  - 学习笔记\n  - 算法模板\n  - 稀疏表\npermalink: suffix-array-notes\ndate: 2016-04-12 19:29:14\n---\n\n在 OI 竞赛中，有一类题目是面向字符串的。这类题目往往要求选手的程序快速地求出给定的字符串的某些信息，这就需要一些对应的数据结构和算法来维护字符串。后缀数组就是一个这样的数据结构 —— 它通过对字符串后缀的处理，可以方便地得到子串的信息。\n\n<!-- more -->\n\n### 定义\n字符串 $ s $ 连续的一段字符组成的串叫做字符串，更广义地，任何一个由可比较大小的元素组成的数组都可称为字符串。字符串的下标从 $ 0 $ 开始，长度为 $ {\\rm length}(s) $。\n\n后缀：$ {\\rm suffix}(i) $ 表示字符串 $ s $ 从第 $ i $ 个位置开始的后缀，即由 $ s[i] $ ~ $ s[n - 1] $ 组成的子串。\n\n字符串的比较：  \n两个字符串大小的比较，从首位开始，一位一位地按照 ASCII 码比较，如果从某位置开始不相同，则认为该位置处字符 ASCII 码小的字符串小；  \n如果一个字符串比较完了最后一位，而另一个没有，则认为前者（长度小的）小；  \n如果两个字符串长度相同并且所有位置上的字符均相同，则认为两个字符串相等。\n\n注意，同一个字符串的两个后缀是不可能相等的，因为无法满足相等的必要条件**长度相同**。\n\n后缀数组：$ {\\rm SA}[] $ 是一个一维数组，保存了对字符串 $ s $ 的所有后缀排序后的结果。$ {\\rm SA}[i] $ 表示第 $ i $ 小的后缀在原串中的起始位置。\n\n名次数组：$ {\\rm rank}[] $ 是一个一维数组，按起始位置保存了每个后缀在 $ {\\rm SA}[] $ 中的排名。$ {\\rm rank}[i] $ 表示 $ {\\rm suffix}(i) $ 的排名，即 $ {\\rm rank}[{\\rm SA}[i]] = i $（第 $ i $ 小的后缀的排名为 $ i $）。\n\n高度数组：$ {\\rm height}[] $ 是一个一维数组，保存了相邻两个后缀的最长公共前缀（Longest Common Prefix，LCP）长度。\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n即 $ {\\rm height}[i] $ 表示存在的最大的 $ x $，满足对于任何 $ k \\in [0, x) $ 有 $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $。\n\n### 后缀数组与名次数组的构造\n#### 朴素构造算法\n如果我们直观地通过定义来构造后缀数组与名次数组（即将每个后缀看做独立的字符串进行快速排序），时间复杂度为 $ O(n ^ 2 \\log n) $，但平方级别的复杂度通常是无法承受的。\n\n上述构造方法的瓶颈在于**字符串的比较**，原串的每个后缀的长度是 $ O(n) $ 级别的，最坏情况下需要 $ O(n) $ 次比较操作才能得到两个后缀的大小关系。\n\n##### 基于 Hash 的优化\n考虑对字符串进行 Hash。使用 BKDRHash 算法 $ O(n) $ 地预处理整个字符串后，可以 $ O(1) $ 地得到任意子串的 Hash 值，比较两个子串是否相等。\n\n这样，我们就得到了一个改进算法：比较两个后缀时，二分它们的 LCP 长度，并比较第一位不同的字符，总时间复杂度为 $ O(n \\log n \\log n) $。\n\n使用 Hash 来构造后缀数组的好处在于时间复杂度较低，并且可以动态维护（使用 `std::set`），坏处在于 Hash 的不稳定性。\n\n#### 倍增算法\n上述两个算法，我们都是将两个后缀看做独立字符串进行比较，而忽视了后缀之间的内在联系。一个更优的算法是**倍增算法**，它的主要思路是，每次利用上一次的结果，倍增计算出从每个位置 $ i $ 开始长度为 $ 2 ^ k $ 的子串的排名。\n\n算法的开始，我们有 `\"heheda\"`，从每个位置开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名分别为：\n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n为了求出长度为 $ 2 ^ 1 = 2 $ 的子串的排名，我们以每个位置 $ i $ 开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名作为位置 $ i $ 的**第一关键字**，以每个位置 $ i + 2 ^ 0 = i + 1 $ 开始，长度为 $ 2 ^ 0 = 1 $ 的子串的排名作为位置 $ i $ 的**第二关键字**，进行双关键字排序。\n\n对于 $ i + 2 ^ 0 \\geq n $ 的位置，我们用一个比其他所有值都小的数作为它的第二关键字，即 $ -1 $。\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n重复以上过程，求出长度为 $ 2 ^ 2 = 4 $ 的子串的排名：\n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n可以看出，这时候 $ {\\rm rank}[] $ 数组的最终值已被求出。而对于任何一组数据，显然可以在最坏情况下 $ O(\\log n) $ 轮上述过程后，求出 $ {\\rm rank}[] $ 数组的最终值。\n\n如果使用快速排序来实现双关键字排序，总时间复杂度为 $ O(n \\log n \\log n) $，实现难度比 Hash 的方法要低，并且更稳定。而考虑到每个关键字均为 $ [-1, n) $ 的整数，我们可以使用 $ O(n) $ 的基数排序，来将总时间复杂度将为 $ O(n \\log n) $。\n\n##### 代码\n\n首先，将原数据进行离散化，保证每个元素的值在 $ [0, n) $ 内。\n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir` 和 `sec` 分别表示第一关键字和第二关键字，`buc` 表示基数排序所用的桶。关键字的取值范围为 $ [-1, n) $，需要用到负数下标。\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n对每个单独的字符进行排序，得到它们的排名。\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n进行 $ O(\\log n) $ 次迭代（下文代码均为循环内操作）。\n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n设置每个位置的第一、第二关键字。\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n对第二关键字进行排序，$ {\\rm tmp}[i] $ 存储第 $ i $ **大**的第二关键字的所在位置。\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n对第一关键字进行排序，按照 $ {\\rm tmp}[] $ 中的顺序依次领取排名，在 $ {\\rm tmp}[] $ 中靠前的位置将较早领取排名，而较早领取到的排名较大。\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n按照后缀数组 $ {\\rm SA}[] $ 中的顺序求出名次数组 $ {\\rm rank}[] $，因为中间过程中排名会有并列，所以要分情况讨论：\n\n1. 没有前一名，当前位置的排名为 $ 0 $；\n2. 当前位置和前一名位置的第一、第二关键字均相等，当前位置的排名与前一位置的排名相等；\n3. 当前位置和前一名位置的第一或第二关键字不相等，当前位置的排名为前一位置的排名 $ + 1 $；\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n由于倍增算法时间复杂度较为优秀，并且实现难度不高，在实践中较为常用。另外，后缀数组也有线性的构造方法，例如 DC3，但其实现难度较高，实际应用不如倍增算法广。\n\n### 高度数组的计算\n后缀数组的大部分应用，都需要高度数组 $ {\\rm height}[] $ 的辅助，如果我们按照定义去计算 $ {\\rm height}[] $，最坏的时间复杂度为 $ O(n ^ 2) $。平方级别的复杂度仍然是无法承受的。\n\n#### 性质\n定义 $ h(i) $ 表示从第 $ i $ 个位置开始的后缀与排在其前一名的后缀的最长公共前缀，即当 $ {\\rm rank}[i] > 0 $ 时，有\n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n对于 $ h(i) $，有一个结论\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n当 $ h(i - 1) < 1 $ 时，结论显然是成立的，下面我们主要考虑 $ h(i - 1) \\geq 1 $ 的情况。\n\n令 $ u = {\\rm suffix}(i) $，$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $，即排在第 $ i $ 个位置的后缀和排在它前面一位的后缀；  \n令 $ u' = {\\rm suffix}(i - 1) $，$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $，即排在第 $ i - 1 $ 个位置的后缀和排在它前面一位的后缀。\n\n我们需要证明 $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $。\n\n现在换一个字符串 `\"heheheda\"` 作为例子，关系对应如下：\n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n当 $ h(i - 1) \\geq 1 $ 时，$ u' $ 与 $ v' $ 的第一个字符必定相等，同时去掉其第一个字符后，所得的两个新的后缀的最长公共前缀长度为 $ {\\rm LCP}(u', v') - 1 $。这两个后缀不一定是 $ u $ 和 $ v $（如果它们排名\t不相邻的话），但在后缀数组中，这两个后缀一定确定了一个包含 $ u $ 和 $ v $ 的区间（考虑位置靠前或靠后的后缀的影响），所以，结合下文中关于最长公共前缀的部分内容，$ {\\rm LCP}(u, v) $ 一定不会比它更小。\n\n#### 代码\n有了这一性质，我们可以按照 $ {\\rm height}[{\\rm SA}[i]] $ 的顺序递推。  \n设 $ k = {\\rm height}[{\\rm rank}[i - 1]] $（即上文的 $ h(i - 1) $），显然在计算每个 $ {\\rm height}[{\\rm rank}[i]] $ 时，$ k $ 每次减小 $ 1 $，最多增加到 $ n $，所以这个过程的时间复杂度为 $ O(n) $。  \n相对于前面 $ O(n \\log n) $ 的过程，线性的复杂度已经不会成为瓶颈。\n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n值得注意的是，$ {\\rm height}[0] $ 的值是无效的，因为排名最靠前的后缀没有前一名。\n\n### 最长公共前缀\n通过高度数组 $ {\\rm height}[] $，我们可以得到排名相邻的两个后缀的最长公共前缀。\n\n对于排名不相邻的两个后缀，它们的前缀的相似性比相邻后缀要差。显然排名不相邻的两个后缀的最长公共前缀长度**一定不会**比这两个后缀在后缀数组中确定的一段**区间中任意两个**相邻后缀的最长公共前缀长度**更长**。\n\n所以，求出这段区间内最小的 $ {\\rm height} $ 值即为这两个不相邻后缀的最长公共前缀长度。\n\n问题转化为区间最值查询（Range Minimum/Maximum Query，RMQ）问题，可以使用稀疏表（Sparse Table，ST）算法解决。该算法在 $ O(n \\log n) $ 的时间内预处理，并在 $ O(1) $ 的时间内完成每个询问。\n\n#### 代码\n代码中 $ {\\rm st}[i][t] $ 表示起始位置在 $ [i, i + 2 ^ t] $ 之间的所有相邻后缀的最长公共前缀长度的最小值，即 $ {\\rm LCP}(i, i + 2 ^ t) $。\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### 模板\n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","slug":"suffix-array-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbyn00427gxltciteri8"},{"title":"STL 在 OI 中的应用","id":"8","updated":"2016-02-17T02:35:37.000Z","date":"2015-12-23T21:43:15.000Z","_content":"\n在 OI 竞赛中，可以使用的语言有 C++、C、Pascal，其中 C++ 最大的优势是，它本身提供了一个模板库 —— Standard Template Library（标准模板库），简称 STL。STL 包含一系列算法和容器等，合理地使用 STL，可以在提高编写代码的效率。NOI 系列比赛自 2011 年起允许 C++ 选手使用 STL，所以我们应该利用好 STL，发挥 C++ 语言的优势。\n\n<!-- more -->\n\n### 分类\n> STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分。\n\n本文主要讲解容器、迭代器、算法，其他的几个部分在竞赛中很少使用到。\n\n### 命名空间\n命名空间（namespace）是 C++ 的一个特性，它被用于解决名称冲突，比如假设 Menci 和 aby890 都在自己的头文件里编写了一个 `work()` 函数，如果这两个函数我们都要用，则名称会产生冲突，但如果两人都将自己的函数写在单独的命名空间内，就成了 `Menci::work()` 和 `aby890::work()`，就不会冲突了。\n\nSTL 的所有内容都包含在 `std` 命名空间内。为什么命名空间不叫 `stl`？我也不知道。\n\n如果我们要调用 STL 中的 `sort` 函数（下文会有提到），要这样写：\n\n```cpp\nstd::sort(a, a + n);\n```\n\n我们也可以将 `std::sort` 这个函数“导入”到全局中，就可以直接 `sort(a, a + n)` 这样调用了。  \n使用 `using` 关键字来“导入”命名空间中的函数或类。\n\n```cpp\nusing std::sort;\n```\n\n也可以将整个命名空间导入全局，这样就可以直接访问命名空间中的所有内容，但更容易产生名称冲突（比如你可能会声明一个叫做 `max` 的变量，但它会覆盖 STL 中的 `max` 函数）。  \n使用 `using namespace` 来“导入”整个命名空间。\n\n```cpp\nusing namespace std;\n```\n\n### 算法\nSTL 中的算法主要包含在 `<algorithm>` 头文件中，这个文件名要记住，每天念一遍。\n\n##### 排序\nSTL 中提供一系列与排序有关的函数，其中最常用到的是 `sort` 和 `stable_sort`，`sort` 是不稳定的排序，它的期望时间复杂度为 $O(n {\\log} n)$，`stable_sort` 是稳定的排序，它的时间复杂度为 $O(n {\\log} n)$。\n\n`sort` 使用类似与快速排序的算法，在大多数情况下能获得最高的效率，`stable_sort` 使用多路归并排序算法，可以在稳定的前提下取得较高的效率。一般常用 `sort`。\n\n用法（以 `sort` 为例，`stable_sort` 相同）：\n\n对左闭右开区间 [l, r) 排序，使用 `sort(l, r)`。其中 l 和 r 是指向元素的**迭代器**，在了解**迭代器**之前，我们可以将其理解为指向元素的指针。\n\n注意这里的区间表示是一个**左闭右开区间**，STL 中经常会出现这种区间，如果我们要对一个数组 a 的前 n 个元素进行排序，则对应区间为 [a, a + n)，因为 a 指向数组的第一个元素（下标为 0），a + n 指向数组的第 n 个元素**之后**。\n\n`sort` 函数默认是升序排序，如果需要降序，可以通过自定义“比较函数”来实现。\n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并**降序**排序后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n降序排序是**大于号**，升序排序是**小于号**（注意**不能**加等号变成大于等于、小于等于），如果不指定比较函数，默认为**升序**。\n\n也可以通过**重载运算符**或者定义**比较函数**的方法对结构体进行排序：\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n写在结构体中的 `operator<` 即为重载运算符，这让我们的结构体支持小于号的比较操作。  \n结构体下面的 `compare` 是比较函数，**比较函数**和**重载运算符**只需要写一个就够了。\n\n注意两种写法中的 `const` 和 `&` 都不能省略。\n\n##### 去重\n\n使用 `unique` 函数来去除数组中的重复元素，其调用格式与 `sort` 类似，注意调用 `unique` 前必须保证数组是有序的（升序降序都可以）。\n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` 函数返回去重后的数组的最后一个元素之后，一般通过用返回值减去首地址的方法获得不重复的元素数量：\n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并升序排序并去重后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### 较大、较小值\n\n使用 `max` 和 `min` 来取得两个数中较大或较小的。\n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); // 结果为 890\ny = std::min(a, b); // 结果为 -1\n```\n\n##### 查找\n\nSTL 中常用的用于查找的函数有三个：`lower_bound`、`upper_bound`、`binary_search`，一般 `lower_bound` 最为常用。\n\n`lower_bound` 用于在一个升序序列中查找某个元素，并返回第一个**不小于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`upper_bound` 用于在一个升序序列中查找某个元素，并返回第一个**大于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`binary_search` 用于确定某个元素有没有在一个升序序列中出现过，返回 `true` 或 `false`。\n\n三个函数的时间复杂度均为$O({\\log}n)$。\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1 指向 a 中第 4 个元素 a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2 指向 a 中第 5 个元素 a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3 指向 a 中第 7 个元素 a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n，因为数组 a 中没有不小于 8 的元素，此时访问 *p4 会越界\n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false 因为数组 a 中没有 3\n```\n\n##### 交换\n使用 `swap` 函数交换两个变量的值。\n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### 迭代器\n迭代器是用于访问 STL 容器中元素的一种数据类型，一般迭代器的声明如下：\n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n上述代码声明了一个迭代器 `p`，其中 `CONTAINER` 是容器类型，可以是 `vector`、`set` 等，`T` 是容器中元素的类型。\n\n一般的，容器的 `begin()` 方法返回**首个元素**的迭代器， `end()` 方法返回**最后一个元素之后**的迭代器。这两个迭代器确定了一个包含容器内所有元素的**左闭右开区间** `[begin(), end())`。对于任何指向有效元素的迭代器都有其**不等于** `end()`，`end()` 并不指向任何一个元素，试图访问 `end()` 对应的元素是非法的。\n\n在使用 STL 提供的算法时，可以用迭代器表示一个区间，如：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n一些容器的迭代器可以支持**随机访问**，如指向 `vector[i]` 的迭代器为 `vector.begin() + i`，而另一些容器如 `set` 不支持这种用法。\n\n所有的迭代器都支持使用 `++` 和 `--` 运算符将迭代器加一或减一。\n\n迭代器的用法类似于指向数组元素的指针，对于迭代器 `p`，用 `*p` 得到迭代器对应的元素；如果该迭代器所对应的元素类型为结构体，则可以直接使用 `->` 访问其对应结构体中的元素。\n\n一般的，使用迭代器遍历容器类似于下述代码：\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### 容器\n\n##### 数组 vector\nSTL 在头文件 `<vector>` 提供了一个**可变长**的数组 `vector`，它支持动态的插入、删除操作。\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 0。\n\n```cpp\nstd::vector<int> v;\n```\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 n。\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector` 提供 `begin()` 和 `end()`，分别获取指向**第一个元素**和**最后一个元素之后**的迭代器。\n\n以下代码对 v 中的所有元素以升序排序：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n使用 `size()` 得到 `vector` 的元素数量，使用 `resize()` 重新指定 `vector` 的元素数量。\n\n分别使用 `push_back()` 和 `pop_back()` 在 `vector` 的**尾部**加入或删除元素，这两个过程的时间复杂度为$O(1)$。\n\n使用 `insert()` 在某个特定的位置插入一个元素，时间复杂度为$O(n)$。\n\n使用 `erase()` 删除某个位置的元素，时间复杂度为$O(n)$。\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n// 依次输出 12345、23333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n注意，在加入元素时，如果 `vector` 拥有的内存空间不足以存放欲加入的元素，则 `vector` 会申请一块新的内存，并将旧数据拷贝过去，这个过程通常花费 $O(n)$ 的时间。\n\n##### 集合 set\nSTL 在头文件 `<set>` 中提供了一个**有序集合** `set`，其中的元素全部是**唯一**的，并且插入进的元素自动按照升序排列，但 `set` 不支持通过下标定位某个元素，只能通过**迭代器**遍历。\n\n以下代码声明了一个 `int` 类型的集合。\n\n```cpp\nstd::set<int> s;\n```\n\n使用 `insert()` 在集合中加入一个元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `erase()` 删除集合中**某个元素**或**某个位置的元素**，其时间复杂度均为$O({\\log}n)$。\n\n`set` 自身提供 `lower_bound()` 用于定位元素，其作用与前文中的同名函数类似，也可以使用 `find()` 来精确查找元素。\n\n遍历 `set` 只能使用**迭代器**。`set` 的迭代器为 `set<T>::iterator`，其中 `T` 为元素类型。\n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // 重复插入无效\ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end()，因为未找到 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n// 依次输出 -1、23333\n```\n\n上述代码中运用的迭代器的方法在 STL 容器中较为常见。\n\n##### 字符串 string\nSTL 在头文件 `<string>` 中将一些与字符串有关的操作封装在了 `string` 内。\n\n使用 `cin` 和 `cout` 来输入、输出字符串。\n\n使用 `find()` 查找另一个字符串在该字符串中的出现位置，返回结果从 0 开始。\n\n使用 `c_str()` 获得 `string` 对应的 `const char *` 类型数据，可用于向 C 库函数传递。\n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos，因为没有找到 23333\n\npos = s.find(\"ci\");\n// pos = 3，因为出现位置为第 4 个字符\n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n// 输出两次 Menci\n```\n\n##### 队列 queue\nSTL 在头文件 `<queue>` 中提供了先入先出（FIFO）队列 `queue`。\n\n使用 `push()` 向队列中加入元素。\n\n使用 `front()` 获取队首元素（并不删除）。\n\n使用 `pop()` 删除队首元素。\n\n使用 `empty()` 判断队列是否为空。\n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true，队列初始为空\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n// 依次输出 23333，66666\n```\n\n##### 栈 stack\nSTL 在头文件 `<stack>` 提供了后入先出（LIFO）栈 `stack`。\n\n使用 `push()` 向栈中加入元素。\n\n使用 `top()` 获取栈顶元素（并不删除）。\n\n使用 `pop()` 删除栈顶元素。\n\n使用 `empty()` 判断栈是否为空。\n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true，栈初始为空\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n// 依次输出 66666，23333\n```\n\n##### 优先队列 priority_queue\nSTL 在头文件 `<queue>` 中提供优先队列 `priority_queue`，在任意时间都能取出队列中的**最大值**。\n\n使用 `push()` 向优先队列中加入元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `top()` 获取优先队列中**最大**的元素（并不删除），其时间复杂度为$O(1)$。\n\n使用 `pop()` 删除优先队列中**最大**元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `empty()` 判断优先队列是否为空。\n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true，优先队列初始为空\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n// 依次输出 66666，23333，-1\n```\n\n`priority_queue` 默认提供队列中的**最大值**，也可以以以下声明方式让 `priority_queue` 提供**最小值**。\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n注意把三个 `T` 换成优先队列中元素的类型（如 `int`）；`std::greater<T>` 的右边要加一个空格，否则会被编译器误认为是 `>>` 右移运算符。","source":"_posts/stl-in-oi.md","raw":"title: STL 在 OI 中的应用\ncategories: OI\ntags: \n  - C++\n  - STL\npermalink: stl-in-oi\nid: 8\nupdated: '2016-02-17 10:35:37'\ndate: 2015-12-24 05:43:15\n---\n\n在 OI 竞赛中，可以使用的语言有 C++、C、Pascal，其中 C++ 最大的优势是，它本身提供了一个模板库 —— Standard Template Library（标准模板库），简称 STL。STL 包含一系列算法和容器等，合理地使用 STL，可以在提高编写代码的效率。NOI 系列比赛自 2011 年起允许 C++ 选手使用 STL，所以我们应该利用好 STL，发挥 C++ 语言的优势。\n\n<!-- more -->\n\n### 分类\n> STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分。\n\n本文主要讲解容器、迭代器、算法，其他的几个部分在竞赛中很少使用到。\n\n### 命名空间\n命名空间（namespace）是 C++ 的一个特性，它被用于解决名称冲突，比如假设 Menci 和 aby890 都在自己的头文件里编写了一个 `work()` 函数，如果这两个函数我们都要用，则名称会产生冲突，但如果两人都将自己的函数写在单独的命名空间内，就成了 `Menci::work()` 和 `aby890::work()`，就不会冲突了。\n\nSTL 的所有内容都包含在 `std` 命名空间内。为什么命名空间不叫 `stl`？我也不知道。\n\n如果我们要调用 STL 中的 `sort` 函数（下文会有提到），要这样写：\n\n```cpp\nstd::sort(a, a + n);\n```\n\n我们也可以将 `std::sort` 这个函数“导入”到全局中，就可以直接 `sort(a, a + n)` 这样调用了。  \n使用 `using` 关键字来“导入”命名空间中的函数或类。\n\n```cpp\nusing std::sort;\n```\n\n也可以将整个命名空间导入全局，这样就可以直接访问命名空间中的所有内容，但更容易产生名称冲突（比如你可能会声明一个叫做 `max` 的变量，但它会覆盖 STL 中的 `max` 函数）。  \n使用 `using namespace` 来“导入”整个命名空间。\n\n```cpp\nusing namespace std;\n```\n\n### 算法\nSTL 中的算法主要包含在 `<algorithm>` 头文件中，这个文件名要记住，每天念一遍。\n\n##### 排序\nSTL 中提供一系列与排序有关的函数，其中最常用到的是 `sort` 和 `stable_sort`，`sort` 是不稳定的排序，它的期望时间复杂度为 $O(n {\\log} n)$，`stable_sort` 是稳定的排序，它的时间复杂度为 $O(n {\\log} n)$。\n\n`sort` 使用类似与快速排序的算法，在大多数情况下能获得最高的效率，`stable_sort` 使用多路归并排序算法，可以在稳定的前提下取得较高的效率。一般常用 `sort`。\n\n用法（以 `sort` 为例，`stable_sort` 相同）：\n\n对左闭右开区间 [l, r) 排序，使用 `sort(l, r)`。其中 l 和 r 是指向元素的**迭代器**，在了解**迭代器**之前，我们可以将其理解为指向元素的指针。\n\n注意这里的区间表示是一个**左闭右开区间**，STL 中经常会出现这种区间，如果我们要对一个数组 a 的前 n 个元素进行排序，则对应区间为 [a, a + n)，因为 a 指向数组的第一个元素（下标为 0），a + n 指向数组的第 n 个元素**之后**。\n\n`sort` 函数默认是升序排序，如果需要降序，可以通过自定义“比较函数”来实现。\n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并**降序**排序后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n降序排序是**大于号**，升序排序是**小于号**（注意**不能**加等号变成大于等于、小于等于），如果不指定比较函数，默认为**升序**。\n\n也可以通过**重载运算符**或者定义**比较函数**的方法对结构体进行排序：\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n写在结构体中的 `operator<` 即为重载运算符，这让我们的结构体支持小于号的比较操作。  \n结构体下面的 `compare` 是比较函数，**比较函数**和**重载运算符**只需要写一个就够了。\n\n注意两种写法中的 `const` 和 `&` 都不能省略。\n\n##### 去重\n\n使用 `unique` 函数来去除数组中的重复元素，其调用格式与 `sort` 类似，注意调用 `unique` 前必须保证数组是有序的（升序降序都可以）。\n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` 函数返回去重后的数组的最后一个元素之后，一般通过用返回值减去首地址的方法获得不重复的元素数量：\n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并升序排序并去重后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### 较大、较小值\n\n使用 `max` 和 `min` 来取得两个数中较大或较小的。\n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); // 结果为 890\ny = std::min(a, b); // 结果为 -1\n```\n\n##### 查找\n\nSTL 中常用的用于查找的函数有三个：`lower_bound`、`upper_bound`、`binary_search`，一般 `lower_bound` 最为常用。\n\n`lower_bound` 用于在一个升序序列中查找某个元素，并返回第一个**不小于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`upper_bound` 用于在一个升序序列中查找某个元素，并返回第一个**大于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`binary_search` 用于确定某个元素有没有在一个升序序列中出现过，返回 `true` 或 `false`。\n\n三个函数的时间复杂度均为$O({\\log}n)$。\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1 指向 a 中第 4 个元素 a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2 指向 a 中第 5 个元素 a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3 指向 a 中第 7 个元素 a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n，因为数组 a 中没有不小于 8 的元素，此时访问 *p4 会越界\n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false 因为数组 a 中没有 3\n```\n\n##### 交换\n使用 `swap` 函数交换两个变量的值。\n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### 迭代器\n迭代器是用于访问 STL 容器中元素的一种数据类型，一般迭代器的声明如下：\n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n上述代码声明了一个迭代器 `p`，其中 `CONTAINER` 是容器类型，可以是 `vector`、`set` 等，`T` 是容器中元素的类型。\n\n一般的，容器的 `begin()` 方法返回**首个元素**的迭代器， `end()` 方法返回**最后一个元素之后**的迭代器。这两个迭代器确定了一个包含容器内所有元素的**左闭右开区间** `[begin(), end())`。对于任何指向有效元素的迭代器都有其**不等于** `end()`，`end()` 并不指向任何一个元素，试图访问 `end()` 对应的元素是非法的。\n\n在使用 STL 提供的算法时，可以用迭代器表示一个区间，如：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n一些容器的迭代器可以支持**随机访问**，如指向 `vector[i]` 的迭代器为 `vector.begin() + i`，而另一些容器如 `set` 不支持这种用法。\n\n所有的迭代器都支持使用 `++` 和 `--` 运算符将迭代器加一或减一。\n\n迭代器的用法类似于指向数组元素的指针，对于迭代器 `p`，用 `*p` 得到迭代器对应的元素；如果该迭代器所对应的元素类型为结构体，则可以直接使用 `->` 访问其对应结构体中的元素。\n\n一般的，使用迭代器遍历容器类似于下述代码：\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### 容器\n\n##### 数组 vector\nSTL 在头文件 `<vector>` 提供了一个**可变长**的数组 `vector`，它支持动态的插入、删除操作。\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 0。\n\n```cpp\nstd::vector<int> v;\n```\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 n。\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector` 提供 `begin()` 和 `end()`，分别获取指向**第一个元素**和**最后一个元素之后**的迭代器。\n\n以下代码对 v 中的所有元素以升序排序：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n使用 `size()` 得到 `vector` 的元素数量，使用 `resize()` 重新指定 `vector` 的元素数量。\n\n分别使用 `push_back()` 和 `pop_back()` 在 `vector` 的**尾部**加入或删除元素，这两个过程的时间复杂度为$O(1)$。\n\n使用 `insert()` 在某个特定的位置插入一个元素，时间复杂度为$O(n)$。\n\n使用 `erase()` 删除某个位置的元素，时间复杂度为$O(n)$。\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n// 依次输出 12345、23333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n注意，在加入元素时，如果 `vector` 拥有的内存空间不足以存放欲加入的元素，则 `vector` 会申请一块新的内存，并将旧数据拷贝过去，这个过程通常花费 $O(n)$ 的时间。\n\n##### 集合 set\nSTL 在头文件 `<set>` 中提供了一个**有序集合** `set`，其中的元素全部是**唯一**的，并且插入进的元素自动按照升序排列，但 `set` 不支持通过下标定位某个元素，只能通过**迭代器**遍历。\n\n以下代码声明了一个 `int` 类型的集合。\n\n```cpp\nstd::set<int> s;\n```\n\n使用 `insert()` 在集合中加入一个元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `erase()` 删除集合中**某个元素**或**某个位置的元素**，其时间复杂度均为$O({\\log}n)$。\n\n`set` 自身提供 `lower_bound()` 用于定位元素，其作用与前文中的同名函数类似，也可以使用 `find()` 来精确查找元素。\n\n遍历 `set` 只能使用**迭代器**。`set` 的迭代器为 `set<T>::iterator`，其中 `T` 为元素类型。\n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // 重复插入无效\ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end()，因为未找到 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n// 依次输出 -1、23333\n```\n\n上述代码中运用的迭代器的方法在 STL 容器中较为常见。\n\n##### 字符串 string\nSTL 在头文件 `<string>` 中将一些与字符串有关的操作封装在了 `string` 内。\n\n使用 `cin` 和 `cout` 来输入、输出字符串。\n\n使用 `find()` 查找另一个字符串在该字符串中的出现位置，返回结果从 0 开始。\n\n使用 `c_str()` 获得 `string` 对应的 `const char *` 类型数据，可用于向 C 库函数传递。\n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos，因为没有找到 23333\n\npos = s.find(\"ci\");\n// pos = 3，因为出现位置为第 4 个字符\n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n// 输出两次 Menci\n```\n\n##### 队列 queue\nSTL 在头文件 `<queue>` 中提供了先入先出（FIFO）队列 `queue`。\n\n使用 `push()` 向队列中加入元素。\n\n使用 `front()` 获取队首元素（并不删除）。\n\n使用 `pop()` 删除队首元素。\n\n使用 `empty()` 判断队列是否为空。\n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true，队列初始为空\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n// 依次输出 23333，66666\n```\n\n##### 栈 stack\nSTL 在头文件 `<stack>` 提供了后入先出（LIFO）栈 `stack`。\n\n使用 `push()` 向栈中加入元素。\n\n使用 `top()` 获取栈顶元素（并不删除）。\n\n使用 `pop()` 删除栈顶元素。\n\n使用 `empty()` 判断栈是否为空。\n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true，栈初始为空\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n// 依次输出 66666，23333\n```\n\n##### 优先队列 priority_queue\nSTL 在头文件 `<queue>` 中提供优先队列 `priority_queue`，在任意时间都能取出队列中的**最大值**。\n\n使用 `push()` 向优先队列中加入元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `top()` 获取优先队列中**最大**的元素（并不删除），其时间复杂度为$O(1)$。\n\n使用 `pop()` 删除优先队列中**最大**元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `empty()` 判断优先队列是否为空。\n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true，优先队列初始为空\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n// 依次输出 66666，23333，-1\n```\n\n`priority_queue` 默认提供队列中的**最大值**，也可以以以下声明方式让 `priority_queue` 提供**最小值**。\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n注意把三个 `T` 换成优先队列中元素的类型（如 `int`）；`std::greater<T>` 的右边要加一个空格，否则会被编译器误认为是 `>>` 右移运算符。","slug":"stl-in-oi","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbyu004c7gxlrw692n1q"},{"title":"「SPOJ 694」Distinct Substrings - 后缀数组","date":"2016-04-12T13:40:06.000Z","_content":"\n给定一个字符串，求该字符串含有的本质不同的子串数量。\n\n<!-- more -->\n\n### 链接\n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### 题解\n每个子串都是原字符串的某个后缀的前缀，所以我们可以统计每个后缀的前缀数量。在后缀数组中，排名第 $ i $ 的后缀与排名第 $ i - 1 $ 的后缀有 $ {\\rm height}[i] $ 个相同的前缀，所以要从答案中减去这些。\n\n设数组下标从 1 开始，则答案为\n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/spoj-694.md","raw":"title: 「SPOJ 694」Distinct Substrings - 后缀数组\ncategories: OI\ntags: \n  - SPOJ\n  - 后缀数组\n  - 字符串\npermalink: spoj-694\ndate: 2016-04-12 21:40:06\n---\n\n给定一个字符串，求该字符串含有的本质不同的子串数量。\n\n<!-- more -->\n\n### 链接\n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### 题解\n每个子串都是原字符串的某个后缀的前缀，所以我们可以统计每个后缀的前缀数量。在后缀数组中，排名第 $ i $ 的后缀与排名第 $ i - 1 $ 的后缀有 $ {\\rm height}[i] $ 个相同的前缀，所以要从答案中减去这些。\n\n设数组下标从 1 开始，则答案为\n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"spoj-694","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbz2004i7gxl9btnyuj5"},{"title":"Splay 学习笔记（三）","date":"2016-01-19T12:02:00.000Z","_content":"\n在《Splay 学习笔记（一）》中，我们学会了利用 Splay 来维护二叉排序树，现在让我们来把我们的 Splay 变得更加优美。\n\n<!-- more -->\n\n### 结构体定义\n两个孩子用一个数组来存，0 表示左孩子，1 表示右孩子，不需要再编写函数来获得某个孩子的引用了。\n\n引入 `count` 成员，表示这个值共出现了几次，不再重复插入相同的值，效率可以得到提高，特别是求前趋后继，实现起来也会变得更加简单。\n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay 操作\n把之前的“旋转到某位置”改为“旋转直到某节点成为自己的父节点”，不需要二级指针了，也不需要判断如果参数为 `NULL` 那么转到根了。\n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n### 节点的前趋 / 后继\n直接 `Splay` 后求即可，不需要多次迭代了。\n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### 选择\n选择第 `k` 小的元素时，需要把循环的条件改为**`k` 是否在 `[rank + 1, rank + count]`**的范围内，迭代到右子树时也要做相应的改动。\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### 完整代码（普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-3.md","raw":"title: Splay 学习笔记（三）\ncategories: OI\ntags: \n  - Splay\n  - 高级数据结构\n  - 学习笔记\n  - 数据结构\n  - 算法模板\npermalink: splay-notes-3\ndate: 2016-01-19 20:02:00\n---\n\n在《Splay 学习笔记（一）》中，我们学会了利用 Splay 来维护二叉排序树，现在让我们来把我们的 Splay 变得更加优美。\n\n<!-- more -->\n\n### 结构体定义\n两个孩子用一个数组来存，0 表示左孩子，1 表示右孩子，不需要再编写函数来获得某个孩子的引用了。\n\n引入 `count` 成员，表示这个值共出现了几次，不再重复插入相同的值，效率可以得到提高，特别是求前趋后继，实现起来也会变得更加简单。\n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay 操作\n把之前的“旋转到某位置”改为“旋转直到某节点成为自己的父节点”，不需要二级指针了，也不需要判断如果参数为 `NULL` 那么转到根了。\n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n### 节点的前趋 / 后继\n直接 `Splay` 后求即可，不需要多次迭代了。\n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### 选择\n选择第 `k` 小的元素时，需要把循环的条件改为**`k` 是否在 `[rank + 1, rank + count]`**的范围内，迭代到右子树时也要做相应的改动。\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### 完整代码（普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-3","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbz6004o7gxln32euenu"},{"title":"Splay 学习笔记（二）","id":"7","updated":"2016-01-19T13:07:35.000Z","date":"2015-12-22T21:44:41.000Z","_content":"\n在 Splay 学习笔记（一）中，我们学会了用 Splay 维护二叉排序树，来实现了有序集合的查询 / 修改操作，接下来，我们来研究 Splay 在维护数列中的用途。\n\n<!-- more -->\n\n### 基本原理\n我们知道，Splay 可以在不改变二叉树的中序遍历的情况下对节点进行旋转，通常我们用 Splay 来维护二叉排序树，用 Splay 维护的二叉排序树支持**区间删除**操作，但我们也可以通过一个数列的中序遍历创建一棵 Splay，然后使用类似区间删除中选择区间的原理来处理区间问题。\n\n这里，我们使用 Splay 实现数列的区间反转，反转一段区间，就对应了二叉树中的反转其**中序遍历**，我们可以使用递归交换左右子树的方法来实现，类比线段树的区间操作，在这里也可以应用线段树中的 `lazy-tag` 思想，给区间打标记。\n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n其中 `reversed` 表示以该节点为根的 Splay（其中序序列）有没有被反转，`bound` 表示该节点是否为数列的边界（相当于原 Splay 二叉排序树中的 `MIN` 和 `MAX` 两个虚拟节点）。\n\n### 数列de构建\n我们通常使用一个数列（数组）来初始化 Splay，这里使用递归构造每个区间的方式实现。具体我们编写两个 `build()`，分别针对**整棵树**和**一个区间**。\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n为了方便区间操作，我们在树的最左下端和最右下端分别创建一个虚拟节点，表示整棵树所表示的**开区间**的边界。\n\n注意递归构建时的区间计算，与线段树的**只有叶子节点表示单点，其它节点全部表示区间**不同，Splay 的每个节点都既表示**一个单点**，又表示**以该节点为根的 Splay 的所有节点构成的区间**，每个节点所代表的区间都会根据树的形态变化而变化，正因为如此，我们才可以通过 Splay 实现灵活的区间操作。\n\n### 标记de下放\n我们对区间操作的维护采用了类似线段树中 `lazy-tag` 的思想。同样，在 Splay 中，我们也需要在必要时对标记进行下放。\n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n反转标记的下放非常简单，交换左右子树，然后将标记打到子树上（`^= 1` 这里使用位运算异或来实现取反）。\n\n### 单点de选择\n当我们需要查询数列中某个点的信息时，我们需要对单点进行 `select()` 操作，这恰好对应了原 Splay 中选择第 `k` 大的操作。\n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n**注意**：`while` 循环判断条件中，调用 `node->lsize()` 取得其左子树大小前，一定要先将 `node` 的标记下放。**如果某个节点上的标记没有被下放，那么对其左、右孩子的访问都是非法的。**\n\n### 区间de选择\n为了实现区间操作，我们需要选择某个区间。注意这里的 `select()` 操作得到区间是指**代表该区间的节点**。为了准确的选择区间，我们需要对树的形态做一些调整。\n\n在 Splay 中选择一个开区间的步骤：\n\n1. 将区间的左端点 `Splay` 到**根**；\n2. 将区间的右端点 `Splay` 到**根的右子树**；\n3. 右端点的左子树即为要选择的区间。\n\n代码实现要注意**闭区间**到**开区间**的转化，同时，这里也体现出了两个虚拟节点带来的便利。\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### 区间de操作\n对区间进行操作时，我们只需要选择这段区间，并对所得的节点打上标记即可。\n\n以区间反转为例：\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### 结果de获取\n为了在结束时获取操作结果并输出，我们编写 `fetch()` 方法，将整棵树的中序序列复制到一个数组中。\n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n需要注意及时进行 `pushdown()` 操作和对边界的判断。\n\n### 注意事项\n需要注意的是，在访问每个节点之前，我们都需要保证树上没有**针对该节点**的标记（即从根节点到该节点的一整条链上没有标记），否则即为不可预料的非法访问。\n\n旋转，操作前先对父节点和自身执行 `pushdown()`，**然后再求 `relation()`**。\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay` 操作，每次循环开始时需要对父节点进行一次 `pushdown()`，因为接下来就要调用 `relation()`。\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n还有上文提到过的单点选择 `select()` 和 `dfs()` 遍历，因为涉及到对子节点的访问，所以在访问前也需要 `pushdown()`。\n\n### 完整代码（Tyvj / BZOJ 文艺平衡树）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### 总结\n学完了这些，对 Splay 维护数列的原理与实现也就基本了解了。其他的一些功能，比如区间最值，区间求和也都大同小异。有些区间操作使用线段树也可实现，但 Splay 的另一个优势在于，它可以动态地插入、删除节点，也就可以实现动态插入、删除区间，这是线段树所不具备的。","source":"_posts/splay-notes-2.md","raw":"title: Splay 学习笔记（二）\ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\npermalink: splay-notes-2\nid: 7\nupdated: '2016-01-19 21:07:35'\ndate: 2015-12-23 05:44:41\n---\n\n在 Splay 学习笔记（一）中，我们学会了用 Splay 维护二叉排序树，来实现了有序集合的查询 / 修改操作，接下来，我们来研究 Splay 在维护数列中的用途。\n\n<!-- more -->\n\n### 基本原理\n我们知道，Splay 可以在不改变二叉树的中序遍历的情况下对节点进行旋转，通常我们用 Splay 来维护二叉排序树，用 Splay 维护的二叉排序树支持**区间删除**操作，但我们也可以通过一个数列的中序遍历创建一棵 Splay，然后使用类似区间删除中选择区间的原理来处理区间问题。\n\n这里，我们使用 Splay 实现数列的区间反转，反转一段区间，就对应了二叉树中的反转其**中序遍历**，我们可以使用递归交换左右子树的方法来实现，类比线段树的区间操作，在这里也可以应用线段树中的 `lazy-tag` 思想，给区间打标记。\n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n其中 `reversed` 表示以该节点为根的 Splay（其中序序列）有没有被反转，`bound` 表示该节点是否为数列的边界（相当于原 Splay 二叉排序树中的 `MIN` 和 `MAX` 两个虚拟节点）。\n\n### 数列de构建\n我们通常使用一个数列（数组）来初始化 Splay，这里使用递归构造每个区间的方式实现。具体我们编写两个 `build()`，分别针对**整棵树**和**一个区间**。\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n为了方便区间操作，我们在树的最左下端和最右下端分别创建一个虚拟节点，表示整棵树所表示的**开区间**的边界。\n\n注意递归构建时的区间计算，与线段树的**只有叶子节点表示单点，其它节点全部表示区间**不同，Splay 的每个节点都既表示**一个单点**，又表示**以该节点为根的 Splay 的所有节点构成的区间**，每个节点所代表的区间都会根据树的形态变化而变化，正因为如此，我们才可以通过 Splay 实现灵活的区间操作。\n\n### 标记de下放\n我们对区间操作的维护采用了类似线段树中 `lazy-tag` 的思想。同样，在 Splay 中，我们也需要在必要时对标记进行下放。\n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n反转标记的下放非常简单，交换左右子树，然后将标记打到子树上（`^= 1` 这里使用位运算异或来实现取反）。\n\n### 单点de选择\n当我们需要查询数列中某个点的信息时，我们需要对单点进行 `select()` 操作，这恰好对应了原 Splay 中选择第 `k` 大的操作。\n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n**注意**：`while` 循环判断条件中，调用 `node->lsize()` 取得其左子树大小前，一定要先将 `node` 的标记下放。**如果某个节点上的标记没有被下放，那么对其左、右孩子的访问都是非法的。**\n\n### 区间de选择\n为了实现区间操作，我们需要选择某个区间。注意这里的 `select()` 操作得到区间是指**代表该区间的节点**。为了准确的选择区间，我们需要对树的形态做一些调整。\n\n在 Splay 中选择一个开区间的步骤：\n\n1. 将区间的左端点 `Splay` 到**根**；\n2. 将区间的右端点 `Splay` 到**根的右子树**；\n3. 右端点的左子树即为要选择的区间。\n\n代码实现要注意**闭区间**到**开区间**的转化，同时，这里也体现出了两个虚拟节点带来的便利。\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### 区间de操作\n对区间进行操作时，我们只需要选择这段区间，并对所得的节点打上标记即可。\n\n以区间反转为例：\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### 结果de获取\n为了在结束时获取操作结果并输出，我们编写 `fetch()` 方法，将整棵树的中序序列复制到一个数组中。\n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n需要注意及时进行 `pushdown()` 操作和对边界的判断。\n\n### 注意事项\n需要注意的是，在访问每个节点之前，我们都需要保证树上没有**针对该节点**的标记（即从根节点到该节点的一整条链上没有标记），否则即为不可预料的非法访问。\n\n旋转，操作前先对父节点和自身执行 `pushdown()`，**然后再求 `relation()`**。\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay` 操作，每次循环开始时需要对父节点进行一次 `pushdown()`，因为接下来就要调用 `relation()`。\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n还有上文提到过的单点选择 `select()` 和 `dfs()` 遍历，因为涉及到对子节点的访问，所以在访问前也需要 `pushdown()`。\n\n### 完整代码（Tyvj / BZOJ 文艺平衡树）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### 总结\n学完了这些，对 Splay 维护数列的原理与实现也就基本了解了。其他的一些功能，比如区间最值，区间求和也都大同小异。有些区间操作使用线段树也可实现，但 Splay 的另一个优势在于，它可以动态地插入、删除节点，也就可以实现动态插入、删除区间，这是线段树所不具备的。","slug":"splay-notes-2","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbza004v7gxl8zej8l37"},{"title":"Splay 学习笔记（一）","id":"6","updated":"2016-01-19T13:07:47.000Z","date":"2015-12-19T21:36:24.000Z","_content":"\n上周周四开始学 Splay，一边看《高级数据结构》，一边看 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》，现在终于弄明白最基础的一部分了。\n\n<!-- more -->\n\n### Splay 是什么?\nSplay Tree（伸展树）是一种自平衡二叉排序树，可以在均摊$O({\\log} n)$的时间内完成基于 Splay（伸展）操作的修改与查询。\n\n### 基本结构\n根据定义，Splay 是一棵二叉树，它的左子树和右子树分别是一棵 Splay，并且存储的值满足左子树 < 根 < 右子树，以下为每个 Splay 节点的定义。\n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n其中 `root` 表示指向**指向根节点的指针**的指针，这样做可以方便从任意一个节点找到整棵 Splay 的根节点，并修改它。`size` 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了 `size`，就可以轻松地实现选择和排名操作。\n\n### 准备\n为了方便各种复杂的操作，我们先为节点类 `node_t` 编写几个短小的方法，代码如下：\n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n这里在 `node_t` 的析构函数中递归释放所有内存，这在区间删除中可能耗时较长，如果内存不紧张，可以考虑不释放内存。\n\n为了旋转操作的方便，我们给每个节点设置一个“关系”属性，表示该节点与其父节点的关系，若该节点为左孩子，则“关系”为 `0`，反之则为 `1`。`relation()` 方法用来计算这个“关系”，而 `child()` 方法返回与该节点“关系”为 `x` 的子节点的**引用**。\n\n`maintain()` 方法则用来重新计算以该节点为根的 Splay 的大小，注意，为免去不必要的计算，假设两个子节点的大小是**已经计算好**的，不会再将其重新计算。\n\n### 旋转\n为了调换 Splay 中父节点与子节点的位置，我们实现 `rotate()` 方法，该方法在**保证以下三点**的情况下，将该节点向上移动一个位置：\n\n1. 整棵 Splay 的中序遍历不变；\n2. 受影响节点的 `size` 仍然有效；\n3. `*root` 总是指向整棵 Splay 的根。\n\n以左旋（若当前节点为父节点的左孩子）为例，旋转分为四个步骤：\n\n1. 将**祖父**节点与自身连接；\n2. 将自己的**右孩子**接到自己的父节点的**左孩子**的位置（替代自己）；\n3. 将父节点接到自己的**右孩子**的位置；\n4. 检查如果此时自身节点为根，则更新 `*root`。\n\n如图（图片来自 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》）：\n![splay](splay-notes-1/splay.png)\n\n代码：\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay 操作\nSplay 规定，每访问一个节点后，都要强制将该节点旋转到根的位置，于是我们很容易想到使用一个循环，判断是否已经到达目标，若不是则旋转，但这种方法的出现的问题在于，一条单链在旋转后仍然是单链，而且每次操作的时间复杂度无法得到保证！\n\n所以我们需要 `Splay` 操作来进行更加“智能化”的旋转，`Splay` 操作的每一次循环分为三步：\n\n1. 如果父节点为目标位置，则向上旋转；\n2. 如果**当前节点与父节点的“关系”**和**父节点与祖父节点的“关系”相同**，则先旋转父节点，再旋转自身；\n3. 如果不满足以上条件，则将自身连续旋转两次。\n\n代码（省略旋转目标的旋转到根）：\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### 插入\n一棵二叉排序树最基础的操作就是插入。\n\n首先，设置一个变量 `target`，表示要插入到的位置，它被初始化为指向根节点，每次循环判断要插入的值大于或小于当前的 `target` 的值，并修改 `target` 为指向某个孩子，循环直到 `target` 指向一个 `NULL`，即可在此位置创建新节点。\n\n插入完成后，需要将新节点 `Splay` 到根的位置。\n\n代码：\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n为了下文**删除**操作的方便，我们在每棵 Splay 构造时为其插入两个节点，分别表示无穷大和无穷小，树中其他节点的值都应该在这两个节点的值构成的**开区间**内。\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### 查找\n根据二叉排序树的有序性，我们可以很轻松的根据值查找到对应的节点，即从根开始查找，根据当前节点的值与要查找节点的值的大小关系，迭代到对应的子节点上，当当前节点的值等于要查找的值时即找到，若当前节点为 `NULL`，则说明查找失败。\n\n注意，当有多个相同值时，查找过程应该返回相同值中排名最靠前的，在此我们使用求找到节点的**前趋**，然后求其**后继**的方法（前趋和后继的求法见下文）。\n\n查找过程结束后，需要将找到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### 排名\n一个值在二叉排序树中的排名，即为该值在此二叉排序树的**中序遍历**中第一次出现的位置。\n\n在 Splay 中求排名非常简单，只要找到对应的节点，将其 `Splay` 到根，此时其左子树的 `size + 1` 即为所求的排名，而因为我们在初始化时多插入了一个“无穷小”节点，所以还要将 `1` 减去。\n\n一个有效数值的排名从 `1` 开始，因为表示“无穷小”的节点的排名为 `0`。\n\n代码：\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### 选择\n对应“排名”操作，二叉排序树有“选择”操作——返回此二叉排序树的**中序遍历**中的第 `k` 个元素。\n\n选择比排名要复杂一些，Splay 的选择过程和其他二叉排序树是相同的，我们通过以下几个步骤来实现：\n\n1. 初始化“当前节点”为根；\n2. 每次循环判断**以当前节点为根的 Splay 中**比该节点小的元素数量是否为 `k - 1`，如果是，则该节点即为要选择的节点；\n3. 如果 `k` 小于当前节点的排名，则迭代到左子树，否则，将 `k` 的值减小**当前节点的排名**后迭代到右子树（因为我们跳过的节点数等于**当前节点排名**）。\n\n选择过程结束后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n### 节点的前趋 / 后继\n我们定义二叉排序树中一个节点的前趋为在此二叉排序树的中序遍历中最后一个数值**小于**该节点数值的节点，同理，一个节点的后继为在此二叉排序树的中序遍历中第一个数值**大于**该节点数值的节点。\n\n以节点的前趋为例，其在 Splay 中的实现为：\n\n1. 将欲求其前趋的节点 `Splay` 到根；\n2. 找到根节点**左子树**的**最右链**的**最下端**（后继则相反），该节点即为此二叉排序树的中序遍历中最后一个数值**小于等于**根节点数值的节点；\n3. 如果该节点的数值与欲求其前趋的节点的数值相等，则转到步骤 1，否则该节点即为所求的前趋。\n\n求出节点的前趋或后继后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n### 值的前趋 / 后继\n我们定义一个数 `x` 在一棵二叉排序树中的前趋为此二叉排序树中小于 `x` 的数中最大的数，同理，一个数 `x` 在一棵二叉排序树中的后继为此二叉排序树中大于 `x` 的数中最小的数。\n\n以值的前趋为例，其实现分为两种情况：\n\n1. 欲求前趋的值在此二叉排序树中，则找到该值对应的节点并求其前趋即可；\n2. 欲求前趋的值不在此二叉排序树中，我们将该值作为一个新节点插入此二叉排序树，用情况 1 的方法求得其前趋，然后将插入的节点删除即可（删除的方法见下文）。\n\n代码：\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n### 删除（单点 / 区间）\nSplay 支持两种删除操作：单点删除和区间删除。因为单点删除即为左右端点相同的区间删除，所以我们在此主要讨论区间删除。\n\nSplay 的区间删除实现并不难，但方法非常的巧妙（下文中提到的前趋、后继均为节点的前趋、后继）：\n\n1. 将左端点的前趋 `Splay` 到根；\n2. 将右端点的后继 `Splay` 到**根的右子树**；\n3. 删除**右端点的后继的左子树**；\n4. 分别重新计算右端点的后继、左端点的前趋的 `size`。\n\n代码：\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### 完整代码（Tyvj / BZOJ / CodeVS 普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-1.md","raw":"title: Splay 学习笔记（一）\ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\npermalink: splay-notes-1\nid: 6\nupdated: '2016-01-19 21:07:47'\ndate: 2015-12-20 05:36:24\n---\n\n上周周四开始学 Splay，一边看《高级数据结构》，一边看 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》，现在终于弄明白最基础的一部分了。\n\n<!-- more -->\n\n### Splay 是什么?\nSplay Tree（伸展树）是一种自平衡二叉排序树，可以在均摊$O({\\log} n)$的时间内完成基于 Splay（伸展）操作的修改与查询。\n\n### 基本结构\n根据定义，Splay 是一棵二叉树，它的左子树和右子树分别是一棵 Splay，并且存储的值满足左子树 < 根 < 右子树，以下为每个 Splay 节点的定义。\n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n其中 `root` 表示指向**指向根节点的指针**的指针，这样做可以方便从任意一个节点找到整棵 Splay 的根节点，并修改它。`size` 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了 `size`，就可以轻松地实现选择和排名操作。\n\n### 准备\n为了方便各种复杂的操作，我们先为节点类 `node_t` 编写几个短小的方法，代码如下：\n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n这里在 `node_t` 的析构函数中递归释放所有内存，这在区间删除中可能耗时较长，如果内存不紧张，可以考虑不释放内存。\n\n为了旋转操作的方便，我们给每个节点设置一个“关系”属性，表示该节点与其父节点的关系，若该节点为左孩子，则“关系”为 `0`，反之则为 `1`。`relation()` 方法用来计算这个“关系”，而 `child()` 方法返回与该节点“关系”为 `x` 的子节点的**引用**。\n\n`maintain()` 方法则用来重新计算以该节点为根的 Splay 的大小，注意，为免去不必要的计算，假设两个子节点的大小是**已经计算好**的，不会再将其重新计算。\n\n### 旋转\n为了调换 Splay 中父节点与子节点的位置，我们实现 `rotate()` 方法，该方法在**保证以下三点**的情况下，将该节点向上移动一个位置：\n\n1. 整棵 Splay 的中序遍历不变；\n2. 受影响节点的 `size` 仍然有效；\n3. `*root` 总是指向整棵 Splay 的根。\n\n以左旋（若当前节点为父节点的左孩子）为例，旋转分为四个步骤：\n\n1. 将**祖父**节点与自身连接；\n2. 将自己的**右孩子**接到自己的父节点的**左孩子**的位置（替代自己）；\n3. 将父节点接到自己的**右孩子**的位置；\n4. 检查如果此时自身节点为根，则更新 `*root`。\n\n如图（图片来自 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》）：\n![splay](splay-notes-1/splay.png)\n\n代码：\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay 操作\nSplay 规定，每访问一个节点后，都要强制将该节点旋转到根的位置，于是我们很容易想到使用一个循环，判断是否已经到达目标，若不是则旋转，但这种方法的出现的问题在于，一条单链在旋转后仍然是单链，而且每次操作的时间复杂度无法得到保证！\n\n所以我们需要 `Splay` 操作来进行更加“智能化”的旋转，`Splay` 操作的每一次循环分为三步：\n\n1. 如果父节点为目标位置，则向上旋转；\n2. 如果**当前节点与父节点的“关系”**和**父节点与祖父节点的“关系”相同**，则先旋转父节点，再旋转自身；\n3. 如果不满足以上条件，则将自身连续旋转两次。\n\n代码（省略旋转目标的旋转到根）：\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### 插入\n一棵二叉排序树最基础的操作就是插入。\n\n首先，设置一个变量 `target`，表示要插入到的位置，它被初始化为指向根节点，每次循环判断要插入的值大于或小于当前的 `target` 的值，并修改 `target` 为指向某个孩子，循环直到 `target` 指向一个 `NULL`，即可在此位置创建新节点。\n\n插入完成后，需要将新节点 `Splay` 到根的位置。\n\n代码：\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n为了下文**删除**操作的方便，我们在每棵 Splay 构造时为其插入两个节点，分别表示无穷大和无穷小，树中其他节点的值都应该在这两个节点的值构成的**开区间**内。\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### 查找\n根据二叉排序树的有序性，我们可以很轻松的根据值查找到对应的节点，即从根开始查找，根据当前节点的值与要查找节点的值的大小关系，迭代到对应的子节点上，当当前节点的值等于要查找的值时即找到，若当前节点为 `NULL`，则说明查找失败。\n\n注意，当有多个相同值时，查找过程应该返回相同值中排名最靠前的，在此我们使用求找到节点的**前趋**，然后求其**后继**的方法（前趋和后继的求法见下文）。\n\n查找过程结束后，需要将找到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### 排名\n一个值在二叉排序树中的排名，即为该值在此二叉排序树的**中序遍历**中第一次出现的位置。\n\n在 Splay 中求排名非常简单，只要找到对应的节点，将其 `Splay` 到根，此时其左子树的 `size + 1` 即为所求的排名，而因为我们在初始化时多插入了一个“无穷小”节点，所以还要将 `1` 减去。\n\n一个有效数值的排名从 `1` 开始，因为表示“无穷小”的节点的排名为 `0`。\n\n代码：\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### 选择\n对应“排名”操作，二叉排序树有“选择”操作——返回此二叉排序树的**中序遍历**中的第 `k` 个元素。\n\n选择比排名要复杂一些，Splay 的选择过程和其他二叉排序树是相同的，我们通过以下几个步骤来实现：\n\n1. 初始化“当前节点”为根；\n2. 每次循环判断**以当前节点为根的 Splay 中**比该节点小的元素数量是否为 `k - 1`，如果是，则该节点即为要选择的节点；\n3. 如果 `k` 小于当前节点的排名，则迭代到左子树，否则，将 `k` 的值减小**当前节点的排名**后迭代到右子树（因为我们跳过的节点数等于**当前节点排名**）。\n\n选择过程结束后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n### 节点的前趋 / 后继\n我们定义二叉排序树中一个节点的前趋为在此二叉排序树的中序遍历中最后一个数值**小于**该节点数值的节点，同理，一个节点的后继为在此二叉排序树的中序遍历中第一个数值**大于**该节点数值的节点。\n\n以节点的前趋为例，其在 Splay 中的实现为：\n\n1. 将欲求其前趋的节点 `Splay` 到根；\n2. 找到根节点**左子树**的**最右链**的**最下端**（后继则相反），该节点即为此二叉排序树的中序遍历中最后一个数值**小于等于**根节点数值的节点；\n3. 如果该节点的数值与欲求其前趋的节点的数值相等，则转到步骤 1，否则该节点即为所求的前趋。\n\n求出节点的前趋或后继后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n### 值的前趋 / 后继\n我们定义一个数 `x` 在一棵二叉排序树中的前趋为此二叉排序树中小于 `x` 的数中最大的数，同理，一个数 `x` 在一棵二叉排序树中的后继为此二叉排序树中大于 `x` 的数中最小的数。\n\n以值的前趋为例，其实现分为两种情况：\n\n1. 欲求前趋的值在此二叉排序树中，则找到该值对应的节点并求其前趋即可；\n2. 欲求前趋的值不在此二叉排序树中，我们将该值作为一个新节点插入此二叉排序树，用情况 1 的方法求得其前趋，然后将插入的节点删除即可（删除的方法见下文）。\n\n代码：\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n### 删除（单点 / 区间）\nSplay 支持两种删除操作：单点删除和区间删除。因为单点删除即为左右端点相同的区间删除，所以我们在此主要讨论区间删除。\n\nSplay 的区间删除实现并不难，但方法非常的巧妙（下文中提到的前趋、后继均为节点的前趋、后继）：\n\n1. 将左端点的前趋 `Splay` 到根；\n2. 将右端点的后继 `Splay` 到**根的右子树**；\n3. 删除**右端点的后继的左子树**；\n4. 分别重新计算右端点的后继、左端点的前趋的 `size`。\n\n代码：\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### 完整代码（Tyvj / BZOJ / CodeVS 普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-1","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbzf00527gxlepfrj38j"},{"title":"「SDOI2016」储能表 - 二进制","date":"2016-04-18T09:06:53.000Z","_content":"\n有一个 $ n $ 行 $ m $ 列的表格，行从 $ 0 $ 到 $ n - 1 $ 编号，列从 $ 0 $ 到 $ m - 1 $ 编号。  \n每个格子都储存着能量。最初，第 $ i $ 行第 $ j $ 列的格子储存着 $ (i \\ {\\rm xor} \\ j) $ 点能量。所以，整个表格储存的总能量是，\n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n随着时间的推移，格子中的能量会渐渐减少。一个时间单位，每个格子中的能量都会减少 $ 1 $。显然，一个格子的能量减少到 $ 0 $ 之后就不会再减少了。  \n也就是说，$ k $ 个时间单位后，整个表格储存的总能量是，\n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n给出一个表格，求 $ k $ 个时间单位后它储存的总能量。  \n由于总能量可能较大，输出时对 $ p $ 取模。\n\n<!-- more -->\n\n### 链接\n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### 题解\n正解是数位 DP …… 这里讲一种乱搞做法 ……\n\n考虑异或的性质：\n\n性质一：对于任意 $ x < 2 ^ N $，$ y < 2 ^ N $，必有 $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n> 证明：之前两个数的从低到高第 $ N $ 位均为 $ 0 $，现在均为 $ 1 $，异或后结果不变。\n\n性质二：对于任意 $ x \\neq y $，必有 $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n> 证明：反证法，假设 $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $，则有 $ x \\ {\\rm xor} \\ a = z $、$ y \\ {\\rm xor} \\ a = z $，即 $ x = y $，与题设矛盾。\n\n性质三：对于任意 $ x < 2 ^ N $，$ [0, 2 ^ N - 1] $ 的所有数与 $ x $ 的异或所得结果取遍 $ [0, 2 ^ N - 1] $ 的所有数。\n\n> 证明：显然，有性质 2 可知这些数互不相同，并且二进制最多有 $ N $ 位，不可能大于等于 $ 2 ^ N $，即这 $ 2 ^ N - 1 $ 个互不相同的数都在 $ [0, 2 ^ N - 1] $ 内。\n\n设 $ n > m $，为方便阅读，$ n $ 表示列数，$ m $ 表示行数。\n\n打表找规律，先从最简单的开始搞。不考虑 $ k $，当 $ n = m = 2 ^ N $（$ N = 3 $）时，结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n可以看到，整个矩阵的每一行包含了 $ [0, 2 ^ N - 1] $ 的所有数字。直接使用等差数列求和公式计算即可。\n\n稍复杂的情况，设 $ N = \\lfloor \\log_2 n \\rfloor $，$ M = \\lfloor \\log_2 m \\rfloor $。当 $ N = M $ 时，打表结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n左上角的黑色部分可以直接规约到第一种情况。红色的部分中，参与异或运算的一个数多了一个二进制位，根据性质三，这一部分能取到 $ [2 ^ N， 2 ^ N + 2 ^ M - 1] $ 的所有数。绿色部分同理。\n\n对于黄色部分，相当于去掉了 $ n $ 和 $ m $ 的最高位后的一个子问题，递归计算即可。\n\n更复杂的情况，当 $ N > M $（因为 $ n > m $ 所以不可能存在 $ N < M $）时，打表结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n由性质三得，左边黑色部分取遍了 $ [0, 2 ^ N - 1] $，可用等差数列求和公式直接计算，右边部分都大于等于 $ 2 ^ N $，将它们同时减去 $ 2 ^ N $ 后即为 $ N = M $ 的情况，递归处理后为每个数加上 $ 2 ^ N $ 即可。\n\n现在考虑 $ k $ 对结果的影响，我们在计算一个等差数列 $ 0, 1, 2, 3, … n $ 时，前面所有 $ \\leq k $ 的项都会变成 $ 0 $，后面所有项减去 $ k $，相当于一个以 $ 1 $ 开始，长度为 $ n - k $ 的等差数列，代入公式即可。\n\n对于最后一种情况的递归，需要在 $ k $ 中将 $ n $ 的最高位去掉。最后为每个数加上时，对每个数的增量减去 $ k $ 即可。\n\n每次递归时，会去掉 $ n $ 二进制最高位上的 $ 1 $，其他的计算都可以在常数时间内完成，总时间复杂度为 $ O(T \\log (\\max(n, m))) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-table.md","raw":"title: 「SDOI2016」储能表 - 二进制\ndate: 2016-04-18 17:06:53\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - 二进制\n  - 异或\n  - 位运算\npermalink: sdoi2016-table\n---\n\n有一个 $ n $ 行 $ m $ 列的表格，行从 $ 0 $ 到 $ n - 1 $ 编号，列从 $ 0 $ 到 $ m - 1 $ 编号。  \n每个格子都储存着能量。最初，第 $ i $ 行第 $ j $ 列的格子储存着 $ (i \\ {\\rm xor} \\ j) $ 点能量。所以，整个表格储存的总能量是，\n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n随着时间的推移，格子中的能量会渐渐减少。一个时间单位，每个格子中的能量都会减少 $ 1 $。显然，一个格子的能量减少到 $ 0 $ 之后就不会再减少了。  \n也就是说，$ k $ 个时间单位后，整个表格储存的总能量是，\n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n给出一个表格，求 $ k $ 个时间单位后它储存的总能量。  \n由于总能量可能较大，输出时对 $ p $ 取模。\n\n<!-- more -->\n\n### 链接\n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### 题解\n正解是数位 DP …… 这里讲一种乱搞做法 ……\n\n考虑异或的性质：\n\n性质一：对于任意 $ x < 2 ^ N $，$ y < 2 ^ N $，必有 $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n> 证明：之前两个数的从低到高第 $ N $ 位均为 $ 0 $，现在均为 $ 1 $，异或后结果不变。\n\n性质二：对于任意 $ x \\neq y $，必有 $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n> 证明：反证法，假设 $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $，则有 $ x \\ {\\rm xor} \\ a = z $、$ y \\ {\\rm xor} \\ a = z $，即 $ x = y $，与题设矛盾。\n\n性质三：对于任意 $ x < 2 ^ N $，$ [0, 2 ^ N - 1] $ 的所有数与 $ x $ 的异或所得结果取遍 $ [0, 2 ^ N - 1] $ 的所有数。\n\n> 证明：显然，有性质 2 可知这些数互不相同，并且二进制最多有 $ N $ 位，不可能大于等于 $ 2 ^ N $，即这 $ 2 ^ N - 1 $ 个互不相同的数都在 $ [0, 2 ^ N - 1] $ 内。\n\n设 $ n > m $，为方便阅读，$ n $ 表示列数，$ m $ 表示行数。\n\n打表找规律，先从最简单的开始搞。不考虑 $ k $，当 $ n = m = 2 ^ N $（$ N = 3 $）时，结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n可以看到，整个矩阵的每一行包含了 $ [0, 2 ^ N - 1] $ 的所有数字。直接使用等差数列求和公式计算即可。\n\n稍复杂的情况，设 $ N = \\lfloor \\log_2 n \\rfloor $，$ M = \\lfloor \\log_2 m \\rfloor $。当 $ N = M $ 时，打表结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n左上角的黑色部分可以直接规约到第一种情况。红色的部分中，参与异或运算的一个数多了一个二进制位，根据性质三，这一部分能取到 $ [2 ^ N， 2 ^ N + 2 ^ M - 1] $ 的所有数。绿色部分同理。\n\n对于黄色部分，相当于去掉了 $ n $ 和 $ m $ 的最高位后的一个子问题，递归计算即可。\n\n更复杂的情况，当 $ N > M $（因为 $ n > m $ 所以不可能存在 $ N < M $）时，打表结果为\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n由性质三得，左边黑色部分取遍了 $ [0, 2 ^ N - 1] $，可用等差数列求和公式直接计算，右边部分都大于等于 $ 2 ^ N $，将它们同时减去 $ 2 ^ N $ 后即为 $ N = M $ 的情况，递归处理后为每个数加上 $ 2 ^ N $ 即可。\n\n现在考虑 $ k $ 对结果的影响，我们在计算一个等差数列 $ 0, 1, 2, 3, … n $ 时，前面所有 $ \\leq k $ 的项都会变成 $ 0 $，后面所有项减去 $ k $，相当于一个以 $ 1 $ 开始，长度为 $ n - k $ 的等差数列，代入公式即可。\n\n对于最后一种情况的递归，需要在 $ k $ 中将 $ n $ 的最高位去掉。最后为每个数加上时，对每个数的增量减去 $ k $ 即可。\n\n每次递归时，会去掉 $ n $ 二进制最高位上的 $ 1 $，其他的计算都可以在常数时间内完成，总时间复杂度为 $ O(T \\log (\\max(n, m))) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-table","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbzp00597gxlc1p1mf1t"},{"title":"SDOI2016 Round1 行纪","date":"2016-04-09T13:59:32.000Z","_content":"\n第一次参加省选，感觉还是要写点什么比较好吧，哪怕记记流水账 ……\n\n<!-- more -->\n\n### Day 0\n早上，火车到了济南，打电话问了问老师要坐哪路公交车 …… 到了酒店开了房，感觉还不错 …… 然而老师要到下午才能赶过来 ……\n\n下午正睡觉，老师给我打电话说让我赶紧过去 …… 报道啊啊啊啊 ……\n\n坐公交车去了山师报道 …… 考场在山师**附中** ……\n\n路不远这两天不用坐车了吧，走着也没关系诶 ……\n\n下午回去调了道费用流，练练 EK 模板 ……\n\n晚上去超市买了两个士力架，两盒牛奶，一块香皂 ……\n\n回酒店我竟然记得路！果然自己一个人出来一趟学会了认路的技能吗 QwQ ……\n\n晚上调了一道组合数学，还是 yts1999 出的题，%%%！\n\n睡觉睡不着，又用手机上 Blog 看了看模板 ……\n\n### Day 1\n早上大约七点半到了考点，抽了号 ……  \n早就知道这里的电脑是 XP 系统，还好之前集训时熟悉的 Windows 下的操作 ……  \n7:59 准时发题，和 WC 一样是纸质的 ……\n\n喝水看题 ……\n\n第一题：异或？异或有什么性质来着？难道是线性基？肯定不是啊喂 …… 看这样子像个 DP？打个表找找规律吧 ……  \n30min 过去了 ……  \n…… 然而并没有什么规律，打好 20 分暴力放在一边 ……\n\n第二题：一个数是另一个数的约数 …… 一个数除以另一个数是质数 …… 等等！数据这么大怎么判断质数！Miller – Rabin 我不会啊啊啊啊 ……  \n写个线性筛 + 试除吧 ……  \n匹配？收益大于等于零？看起来像是要二分的样子。跑费用流？等等！这是不是二分图啊！  \npapapa 敲了个二分图染色，跑了 $ 1000 \\times 1000 $ 的数据发现是二分图 …… 虽然不会证就当它是吧反正我不会带花树再说了带花树 $ O((n + m) ^ 3) $ 也过不了啊喂！  \n建图还是要先二分图染色再重建的 …… 常数会不会太大？算了就这样吧 …… 几分钟敲了个 EK 模板，还好昨天刚敲过 ……  \n一个半小时（具体时间记不清了）后样例过了 ……  \n写对拍 ……  \n诶这暴力咋写？  \n把每个数拆成 $ b_i $ 个数搞，复杂度爆炸但是对拍足够了吧 ……  \n半个小时后开始对拍 ……  \n`Wrong Answer on Test #7`？md 暴力写错了 …… 滚去改  \n`Wrong Answer on Test #13`？md 又是暴力写错了 …… 滚去改  \n然后就是一堆 `Accepted` ……  先放在那里吧 ……\n\n第三题：树？！我会树剖！  \n这标记是什么鬼 …… 根本不会啊 …… 难道是 SegmentTree Beats？ 先打个暴力吧 ……  \n每次询问一遍 BFS 相当的暴力，嗯样例能过 ……  \n部分分有 $ a = 0 $ 的点，写个树剖吧 ……  \n……  \n十一点半了 ……  树剖写完了，赶紧对拍 ……  \n`Wrong Answer on Test #18`？缩小数据范围试试 …… 该不会暴力又写错了吧 ……  \n`Wrong Answer on Test #32` …… 数据范围够小了手算下 …… 嗯我的树剖写错了 ……  \nmd 这线段树什么鬼 …… 改线段树 ……  \nmd 我的树剖根本没有计算出 `size` 啊怎么剖出来的 ……  \n`s.top()` 接着 `s.pop()` 蛤？……  \n改完树剖已经 12:40 了 …… 对拍终于不出错了 ……\n\n回去看 T2 …… maya 忘了写静态内存了 …… 改改改 ……  \nT2 复杂度有点大？就当他是 $ O(跑得出) $ 吧 …… 来组 $ n = 200 $ 试试 ……  \n答案好几万，跑了 1.5s ……  \n啊啊啊啊啊啊啊啊啊怎么办来不及优化了啊 ……  \n算了，T 就 T 吧 …… 回去检查检查文件 ……\n\n下午知道了成绩，140，rank9，还算可以吧 ……\n\nheheda AK 了！  \nstd rank2！\n\n……\n\n感觉明天要考字符串、反演、法法塔之类的 …… 啥都不会，药丸啊 …… 晚上赶紧写了个 KMP 模板 …… 也许明天打暴力用得到？\n\n其实，Day1 成绩好未必是一件好事？起点越高，失败后便摔得越惨吧。  \n但愿 Day2 不会滚粗。\n\n### Day 2\n今天不用抽号了，去的晚一点没关系 …… 7:50 进了考场\n\nwow 昨天的目录还在，不用重新写对拍了诶 ……\n\n7:57 准时发题 ……\n\n喝水看题 ……\n\n第一题：maya这不是集训原题的弱化版吗！完了我不会啊啊啊啊怎么办，暴力后缀数组能有 60 分啊啊啊啊，他们肯定至少能写出来 60 分啊啊啊啊，今天注定滚粗了啊啊啊啊啊  \n先打个 30 分暴力吧，`std::set< std::vector<int> >` 够暴力吧 ……  \n\n第二题：maya计数问题！前段时间写过不少类似的题吧，推推式子看 …… 我们先来求没有稳定数的排列数 …… 然后至少一个稳定的排列数量 …… 诶这个好像要容斥？  \n二十分钟后，脑海里一片空白 …… 这种题他们肯定都会啊，我怎么就是想不出来啊啊啊啊，第一题怎么办 ……  \n先打个 10 分暴力吧 …… $ O(n!) $ 枚举全排列 ……\n\n第三题：好像是个 DP？10 分可以爆搜？$ O(n ^ 3) $ 的划分 DP 可以 30 分？不管了，先回去想想第一题吧 …… 也许还有希望 ……\n\n嗯 …… 后缀数组，先用 `std::sort` 写个暴力后缀数组再说 ……  \n好像求出 `height` 可以统计子串数？让我想想 …… `height` 表示排名相邻两个后缀的最长公共前缀长度 …… 这个好像可以线性递推？不管了，写个暴力吧 ……\n\n于是我有了一个 $ O(n ^ 2 \\log n + n ^ 2) $ 的后缀数组 ……\n\n让我想想，每个后缀对答案的贡献是 ……\n\n1.5h 过去了，终于把暴力后缀数组写完，暴力求 `height` 写完，统计子串数量写完 ……\n\n手敲了一组大数据，答案和暴力结果一样，感觉推导的应该没问题 ……\n\n$ O(n ^ 2) $ 求 `height` 明显复杂度太高吧？让我想想怎么线性递推 ……  \n对于某个后缀的 `height`，当这个后缀与前一个后缀的首个字符相等时，结果为后一个字符所对应后缀的 `height + 1`，否则为 0 ……  \n用 `\"heheda\"` 作为例子手算了一下，感觉没问题 ……  \n恩好像没问题，就这样写吧 ……  \n实在不知道递推顺序，就记忆搜索吧 ……  \n\n嗯，让我想想后缀数组复杂度能不能降一降，写个倍增试试？\n\n倍增的框架敲上了，想想怎么基数排序来着 …… 怎么基数排序来着 ……  \n将近半个小时过去了，还是没想到怎么基数排序 ……  \n算了吧，直接丢给 `std::sort` 做双关键字吧！\n\n于是我的后缀数组变成了 $ O(n \\log n \\log n + n) $ ……\n\n让我再试组数据 …… 啊啊啊啊啊怎么和暴力结果不一样啊！！！  \n后缀数组把倍增换成原来的暴力排序，结果还是不对 ……  \n难道是 `height` 求错了？  \n改成原来的平方暴力 ……  \n嗯，好像是对的 ……  \nmaya我递推式推错了 …… 怎么办怎么办怎么办！\n\n看了看时间已经十一点半多了 ……  \n算了吧，换成平方暴力！\n\n后缀数组的复杂度定格为 $ O(n \\log n \\log n + n ^ 2) $ ……  \n瓶颈依然是 `height` 的平方 …… 药丸 ……  \n\n赶紧写第三题！  \n乘上一个整数表示方差？看来要维护两个信息啊 …… 和的平方与平方的和 …… 啥玩意 …… 还是记忆搜索吧 ……\n\n写完自认为能有 30 分的 DP 之后已经 12:40 了 ……  \n赶紧测测样例，maya样例不过啊 ……  \n输出中间结果试试 …… maya除不开啊 ……  \n一定是我式子推错了吧 ……  \n赶紧换成 `double` 就算精度炸了说不定还有希望啊 ……  \n恩就这样吧 …… 样例总算过了 ……  \n\n12:50，赶紧检查一下前两题，文件输入输出写好 …… 关文件 …… 调试代码去掉 ……  \nmaya第二题的表打错了啊啊啊赶紧重新打 ……  \n\n13:00 结束 …… 深感药丸 ……\n\n听讲题 ……\n\nDay1 T1 数位DP？  \nT2 好像我的做法不是正解？正解没有二分 …… 怪不得跑这么慢 ……  \nT3 有点类似超哥线段树的东西？不懂啊 Orz\n\nDay2 T1 后缀自动机裸题？后缀数组搞一搞就好？  \n唉后悔没学后缀数组了 ……  \nT2 叫什么错位排列？maya我就剩一点容斥就能推出 60 分做法了啊啊啊啊啊 ……  \nT3 斜率优化？好像我暴力的式子也推错了 …… 爆零啦 ……  \n\n成绩出来了 …… 90 分滚粗 …… 直接掉到 60 多名了 ……\n\n果然 Day1 的 Flag 生效了？\n\n下午坐火车走了，晚上回到了临沂 ……\n","source":"_posts/sdoi2016-round1.md","raw":"title: SDOI2016 Round1 行纪\ncategories: \n  - Diary\n  - OI\ntags: \n  - 游记\n  - SDOI\n  - 省选\npermalink: sdoi2016-round1\ndate: 2016-04-09 21:59:32\n---\n\n第一次参加省选，感觉还是要写点什么比较好吧，哪怕记记流水账 ……\n\n<!-- more -->\n\n### Day 0\n早上，火车到了济南，打电话问了问老师要坐哪路公交车 …… 到了酒店开了房，感觉还不错 …… 然而老师要到下午才能赶过来 ……\n\n下午正睡觉，老师给我打电话说让我赶紧过去 …… 报道啊啊啊啊 ……\n\n坐公交车去了山师报道 …… 考场在山师**附中** ……\n\n路不远这两天不用坐车了吧，走着也没关系诶 ……\n\n下午回去调了道费用流，练练 EK 模板 ……\n\n晚上去超市买了两个士力架，两盒牛奶，一块香皂 ……\n\n回酒店我竟然记得路！果然自己一个人出来一趟学会了认路的技能吗 QwQ ……\n\n晚上调了一道组合数学，还是 yts1999 出的题，%%%！\n\n睡觉睡不着，又用手机上 Blog 看了看模板 ……\n\n### Day 1\n早上大约七点半到了考点，抽了号 ……  \n早就知道这里的电脑是 XP 系统，还好之前集训时熟悉的 Windows 下的操作 ……  \n7:59 准时发题，和 WC 一样是纸质的 ……\n\n喝水看题 ……\n\n第一题：异或？异或有什么性质来着？难道是线性基？肯定不是啊喂 …… 看这样子像个 DP？打个表找找规律吧 ……  \n30min 过去了 ……  \n…… 然而并没有什么规律，打好 20 分暴力放在一边 ……\n\n第二题：一个数是另一个数的约数 …… 一个数除以另一个数是质数 …… 等等！数据这么大怎么判断质数！Miller – Rabin 我不会啊啊啊啊 ……  \n写个线性筛 + 试除吧 ……  \n匹配？收益大于等于零？看起来像是要二分的样子。跑费用流？等等！这是不是二分图啊！  \npapapa 敲了个二分图染色，跑了 $ 1000 \\times 1000 $ 的数据发现是二分图 …… 虽然不会证就当它是吧反正我不会带花树再说了带花树 $ O((n + m) ^ 3) $ 也过不了啊喂！  \n建图还是要先二分图染色再重建的 …… 常数会不会太大？算了就这样吧 …… 几分钟敲了个 EK 模板，还好昨天刚敲过 ……  \n一个半小时（具体时间记不清了）后样例过了 ……  \n写对拍 ……  \n诶这暴力咋写？  \n把每个数拆成 $ b_i $ 个数搞，复杂度爆炸但是对拍足够了吧 ……  \n半个小时后开始对拍 ……  \n`Wrong Answer on Test #7`？md 暴力写错了 …… 滚去改  \n`Wrong Answer on Test #13`？md 又是暴力写错了 …… 滚去改  \n然后就是一堆 `Accepted` ……  先放在那里吧 ……\n\n第三题：树？！我会树剖！  \n这标记是什么鬼 …… 根本不会啊 …… 难道是 SegmentTree Beats？ 先打个暴力吧 ……  \n每次询问一遍 BFS 相当的暴力，嗯样例能过 ……  \n部分分有 $ a = 0 $ 的点，写个树剖吧 ……  \n……  \n十一点半了 ……  树剖写完了，赶紧对拍 ……  \n`Wrong Answer on Test #18`？缩小数据范围试试 …… 该不会暴力又写错了吧 ……  \n`Wrong Answer on Test #32` …… 数据范围够小了手算下 …… 嗯我的树剖写错了 ……  \nmd 这线段树什么鬼 …… 改线段树 ……  \nmd 我的树剖根本没有计算出 `size` 啊怎么剖出来的 ……  \n`s.top()` 接着 `s.pop()` 蛤？……  \n改完树剖已经 12:40 了 …… 对拍终于不出错了 ……\n\n回去看 T2 …… maya 忘了写静态内存了 …… 改改改 ……  \nT2 复杂度有点大？就当他是 $ O(跑得出) $ 吧 …… 来组 $ n = 200 $ 试试 ……  \n答案好几万，跑了 1.5s ……  \n啊啊啊啊啊啊啊啊啊怎么办来不及优化了啊 ……  \n算了，T 就 T 吧 …… 回去检查检查文件 ……\n\n下午知道了成绩，140，rank9，还算可以吧 ……\n\nheheda AK 了！  \nstd rank2！\n\n……\n\n感觉明天要考字符串、反演、法法塔之类的 …… 啥都不会，药丸啊 …… 晚上赶紧写了个 KMP 模板 …… 也许明天打暴力用得到？\n\n其实，Day1 成绩好未必是一件好事？起点越高，失败后便摔得越惨吧。  \n但愿 Day2 不会滚粗。\n\n### Day 2\n今天不用抽号了，去的晚一点没关系 …… 7:50 进了考场\n\nwow 昨天的目录还在，不用重新写对拍了诶 ……\n\n7:57 准时发题 ……\n\n喝水看题 ……\n\n第一题：maya这不是集训原题的弱化版吗！完了我不会啊啊啊啊怎么办，暴力后缀数组能有 60 分啊啊啊啊，他们肯定至少能写出来 60 分啊啊啊啊，今天注定滚粗了啊啊啊啊啊  \n先打个 30 分暴力吧，`std::set< std::vector<int> >` 够暴力吧 ……  \n\n第二题：maya计数问题！前段时间写过不少类似的题吧，推推式子看 …… 我们先来求没有稳定数的排列数 …… 然后至少一个稳定的排列数量 …… 诶这个好像要容斥？  \n二十分钟后，脑海里一片空白 …… 这种题他们肯定都会啊，我怎么就是想不出来啊啊啊啊，第一题怎么办 ……  \n先打个 10 分暴力吧 …… $ O(n!) $ 枚举全排列 ……\n\n第三题：好像是个 DP？10 分可以爆搜？$ O(n ^ 3) $ 的划分 DP 可以 30 分？不管了，先回去想想第一题吧 …… 也许还有希望 ……\n\n嗯 …… 后缀数组，先用 `std::sort` 写个暴力后缀数组再说 ……  \n好像求出 `height` 可以统计子串数？让我想想 …… `height` 表示排名相邻两个后缀的最长公共前缀长度 …… 这个好像可以线性递推？不管了，写个暴力吧 ……\n\n于是我有了一个 $ O(n ^ 2 \\log n + n ^ 2) $ 的后缀数组 ……\n\n让我想想，每个后缀对答案的贡献是 ……\n\n1.5h 过去了，终于把暴力后缀数组写完，暴力求 `height` 写完，统计子串数量写完 ……\n\n手敲了一组大数据，答案和暴力结果一样，感觉推导的应该没问题 ……\n\n$ O(n ^ 2) $ 求 `height` 明显复杂度太高吧？让我想想怎么线性递推 ……  \n对于某个后缀的 `height`，当这个后缀与前一个后缀的首个字符相等时，结果为后一个字符所对应后缀的 `height + 1`，否则为 0 ……  \n用 `\"heheda\"` 作为例子手算了一下，感觉没问题 ……  \n恩好像没问题，就这样写吧 ……  \n实在不知道递推顺序，就记忆搜索吧 ……  \n\n嗯，让我想想后缀数组复杂度能不能降一降，写个倍增试试？\n\n倍增的框架敲上了，想想怎么基数排序来着 …… 怎么基数排序来着 ……  \n将近半个小时过去了，还是没想到怎么基数排序 ……  \n算了吧，直接丢给 `std::sort` 做双关键字吧！\n\n于是我的后缀数组变成了 $ O(n \\log n \\log n + n) $ ……\n\n让我再试组数据 …… 啊啊啊啊啊怎么和暴力结果不一样啊！！！  \n后缀数组把倍增换成原来的暴力排序，结果还是不对 ……  \n难道是 `height` 求错了？  \n改成原来的平方暴力 ……  \n嗯，好像是对的 ……  \nmaya我递推式推错了 …… 怎么办怎么办怎么办！\n\n看了看时间已经十一点半多了 ……  \n算了吧，换成平方暴力！\n\n后缀数组的复杂度定格为 $ O(n \\log n \\log n + n ^ 2) $ ……  \n瓶颈依然是 `height` 的平方 …… 药丸 ……  \n\n赶紧写第三题！  \n乘上一个整数表示方差？看来要维护两个信息啊 …… 和的平方与平方的和 …… 啥玩意 …… 还是记忆搜索吧 ……\n\n写完自认为能有 30 分的 DP 之后已经 12:40 了 ……  \n赶紧测测样例，maya样例不过啊 ……  \n输出中间结果试试 …… maya除不开啊 ……  \n一定是我式子推错了吧 ……  \n赶紧换成 `double` 就算精度炸了说不定还有希望啊 ……  \n恩就这样吧 …… 样例总算过了 ……  \n\n12:50，赶紧检查一下前两题，文件输入输出写好 …… 关文件 …… 调试代码去掉 ……  \nmaya第二题的表打错了啊啊啊赶紧重新打 ……  \n\n13:00 结束 …… 深感药丸 ……\n\n听讲题 ……\n\nDay1 T1 数位DP？  \nT2 好像我的做法不是正解？正解没有二分 …… 怪不得跑这么慢 ……  \nT3 有点类似超哥线段树的东西？不懂啊 Orz\n\nDay2 T1 后缀自动机裸题？后缀数组搞一搞就好？  \n唉后悔没学后缀数组了 ……  \nT2 叫什么错位排列？maya我就剩一点容斥就能推出 60 分做法了啊啊啊啊啊 ……  \nT3 斜率优化？好像我暴力的式子也推错了 …… 爆零啦 ……  \n\n成绩出来了 …… 90 分滚粗 …… 直接掉到 60 多名了 ……\n\n果然 Day1 的 Flag 生效了？\n\n下午坐火车走了，晚上回到了临沂 ……\n","slug":"sdoi2016-round1","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdbzx005m7gxl7vyghdv1"},{"title":"「SDOI2016」排列计数 - 组合数学 + 错位排列","date":"2016-04-13T03:45:13.000Z","_content":"\n求有多少种长度为 $ n $ 的序列 $ A $，满足以下条件：\n\n* $ 1 $ ~ $ n $ 这 $ n $ 个数在序列中各出现了一次\n* 若第 $ i $ 个数 $ A[i] $ 的值为 $ i $，则称 $ i $ 是稳定的。序列恰好有 $ m $ 个数是稳定的\n\n满足条件的序列可能很多，序列数对 $ 10 ^ 9 + 7 $ 取模。\n\n<!-- more -->\n\n### 链接\n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### 题解\n根据条件一，我们得知这是一个全排列。\n\n对于条件二，我们可以先从 $ n $ 个数中选出 $ m $ 个，使它们的值是稳定的，然后使剩下的 $ n - m $ 全部错位排列。\n\n设 $ f(i) $ 表示长度为 i 的序列的错位排列数，答案即为\n\n$$ C(n, m) * f(n - m) $$\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-permutation.md","raw":"title: 「SDOI2016」排列计数 - 组合数学 + 错位排列\ndate: 2016-04-13 11:45:13\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - 组合数学\n  - 数学\n  - 错位排列\n  - 组合数\npermalink: sdoi2016-permutation\n---\n\n求有多少种长度为 $ n $ 的序列 $ A $，满足以下条件：\n\n* $ 1 $ ~ $ n $ 这 $ n $ 个数在序列中各出现了一次\n* 若第 $ i $ 个数 $ A[i] $ 的值为 $ i $，则称 $ i $ 是稳定的。序列恰好有 $ m $ 个数是稳定的\n\n满足条件的序列可能很多，序列数对 $ 10 ^ 9 + 7 $ 取模。\n\n<!-- more -->\n\n### 链接\n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### 题解\n根据条件一，我们得知这是一个全排列。\n\n对于条件二，我们可以先从 $ n $ 个数中选出 $ m $ 个，使它们的值是稳定的，然后使剩下的 $ n - m $ 全部错位排列。\n\n设 $ f(i) $ 表示长度为 i 的序列的错位排列数，答案即为\n\n$$ C(n, m) * f(n - m) $$\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-permutation","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc03005w7gxlulvf8i3q"},{"title":"「SDOI2016」数字配对 - 费用流","date":"2016-04-09T10:06:43.000Z","_content":"\n有 $ n $ 种数字，第 $ i $ 种数字是 $ a_i $、有 $ b_i $ 个，权值是 $ c_i $。\n\n若两个数字 $ a_i $、$ a_j $ 满足，$ a_i $ 是 $ a_j $ 的倍数，且 $ \\frac{a_i}{a_j} $ 是一个质数，那么这两个数字可以配对，并获得 $ c_i \\times c_j $ 的价值。\n\n一个数字只能参与一次配对，可以不参与配对。  \n在获得的价值总和不小于 $ 0 $ 的前提下，求最多进行多少次配对。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### 题解\n线性筛预处理质数（到 $ 10 ^ 6 $ 肯定够用了），用试除法判断质数，可以匹配的数字连边，做一遍二分图染色。\n\n源点到所有 $ X $ 点连边，容量为 $ b_i $ 费用为 $ 0 $；所有 $ Y $ 点向汇点连边，容量为 $ b_i $ 费用为 $ 0 $；可以匹配的数字从 $ X $ 点向 $ Y $ 点连边，容量为无穷大，费用为 $ -(c_i \\times c_j) $。\n\n先求出整张网络的最大流作为二分的上界。然后建立超级源点，并从超级源点向源点连边，二分这条边的容量，用费用流检验，如果费用 $ \\leq 0 $ 说明可行。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-pair.md","raw":"title: 「SDOI2016」数字配对 - 费用流\ndate: 2016-04-09 18:06:43\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - Edmonds-Karp\n  - 数论\n  - 素数判定\n  - 线性筛\n  - 网络流\n  - 费用流\n  - 二分答案\npermalink: sdoi2016-pair\n---\n\n有 $ n $ 种数字，第 $ i $ 种数字是 $ a_i $、有 $ b_i $ 个，权值是 $ c_i $。\n\n若两个数字 $ a_i $、$ a_j $ 满足，$ a_i $ 是 $ a_j $ 的倍数，且 $ \\frac{a_i}{a_j} $ 是一个质数，那么这两个数字可以配对，并获得 $ c_i \\times c_j $ 的价值。\n\n一个数字只能参与一次配对，可以不参与配对。  \n在获得的价值总和不小于 $ 0 $ 的前提下，求最多进行多少次配对。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### 题解\n线性筛预处理质数（到 $ 10 ^ 6 $ 肯定够用了），用试除法判断质数，可以匹配的数字连边，做一遍二分图染色。\n\n源点到所有 $ X $ 点连边，容量为 $ b_i $ 费用为 $ 0 $；所有 $ Y $ 点向汇点连边，容量为 $ b_i $ 费用为 $ 0 $；可以匹配的数字从 $ X $ 点向 $ Y $ 点连边，容量为无穷大，费用为 $ -(c_i \\times c_j) $。\n\n先求出整张网络的最大流作为二分的上界。然后建立超级源点，并从超级源点向源点连边，二分这条边的容量，用费用流检验，如果费用 $ \\leq 0 $ 说明可行。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-pair","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc0a00667gxlox6nho5e"},{"title":"「SDOI2016」征途 - 斜率优化DP","date":"2016-04-17T14:46:04.000Z","_content":"\nPine 开始了从 $ S $ 地到 $ T $ 地的征途。  \n从 $ S $ 地到 $ T $ 地的路可以划分成 $ n $ 段，相邻两段路的分界点设有休息站。  \nPine 计划用 $ m $ 天到达 $ T $ 地。除第 $ m $ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。  \nPine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。  \n帮助 Pine 求出最小方差是多少。\n\n设方差是 $ v $，可以证明，$ v \\times m ^ 2 $ 是一个整数。为了避免精度误差，输出结果时输出 $ v \\times m ^ 2 $。\n\n<!-- more -->\n\n### 链接\n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### 题解\n设 $ a_i $ 为每一天的路程，$ S = \\sum\\limits_{i = 1} ^ n a_i $，题目要求即为最小化\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n将上式展开，整理得\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n因为 $ m $ 是个常数，$ S ^ 2 $ 是个常数，所以只要最小化\n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n即可\n\n设 $ f[j][i] $ 表示前 $ i $ 段路，分成 $ j $ 天的最优方案对应上式的值，则有\n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\n直接以这个式子进行划分DP，状态数为 $ O(nm) $，时间复杂度为 $ O(nm ^ 2) $，预计得分 60 分。\n\n尝试进行优化。首先，二维的状态存储，显然第一维是可以滚动的，设 $ g(i) = f[j - 1][i] $。考虑 $ k $ 的两个取值 $ k = a $ 和 $ k = b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n左边是一个斜率的式子，分子和分母都是单调的，右边也是单调的。使用一个单调队列来存储一些决策点，使得从前到后每一个决策点都比下一个决策点更优，需要满足的条件是：\n\n1. 较后面的一对点组成的斜率比较前面一对点大；\n2. 第 $ a $ 个点与第 $ b $ 个点（$ a > b $）组成的斜率大于 $ 2 s_i $（如果小于，说明较靠后的 $ a $ 点更优）。\n\n因为斜率是单调递增的，所以第 2 条只需要使前两个元素满足条件即可。\n\n枚举 $ i $，不需要枚举 $ k $，而是从单调队列中寻找最优决策点。首先检查队首元素，使其满足条件 2，此时队首即为最优解；然后将当前决策点作为新的 $ k $ 加入到队列尾部，需要先删除一些决策点使得条件 1 被满足。因为每个决策点最多会被添加、删除各一次，所以状态转移的代价为均摊 $ O(1) $，总时间复杂度降为 $ O(nm) $，可以通过本题。\n\n注意正无穷的取值，合理取值可以避免特判。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-journey.md","raw":"title: 「SDOI2016」征途 - 斜率优化DP\ndate: 2016-04-17 22:46:04\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - DP\n  - 斜率优化\n  - 单调队列\npermalink: sdoi2016-journey\n---\n\nPine 开始了从 $ S $ 地到 $ T $ 地的征途。  \n从 $ S $ 地到 $ T $ 地的路可以划分成 $ n $ 段，相邻两段路的分界点设有休息站。  \nPine 计划用 $ m $ 天到达 $ T $ 地。除第 $ m $ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。  \nPine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。  \n帮助 Pine 求出最小方差是多少。\n\n设方差是 $ v $，可以证明，$ v \\times m ^ 2 $ 是一个整数。为了避免精度误差，输出结果时输出 $ v \\times m ^ 2 $。\n\n<!-- more -->\n\n### 链接\n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### 题解\n设 $ a_i $ 为每一天的路程，$ S = \\sum\\limits_{i = 1} ^ n a_i $，题目要求即为最小化\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n将上式展开，整理得\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n因为 $ m $ 是个常数，$ S ^ 2 $ 是个常数，所以只要最小化\n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n即可\n\n设 $ f[j][i] $ 表示前 $ i $ 段路，分成 $ j $ 天的最优方案对应上式的值，则有\n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\n直接以这个式子进行划分DP，状态数为 $ O(nm) $，时间复杂度为 $ O(nm ^ 2) $，预计得分 60 分。\n\n尝试进行优化。首先，二维的状态存储，显然第一维是可以滚动的，设 $ g(i) = f[j - 1][i] $。考虑 $ k $ 的两个取值 $ k = a $ 和 $ k = b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n左边是一个斜率的式子，分子和分母都是单调的，右边也是单调的。使用一个单调队列来存储一些决策点，使得从前到后每一个决策点都比下一个决策点更优，需要满足的条件是：\n\n1. 较后面的一对点组成的斜率比较前面一对点大；\n2. 第 $ a $ 个点与第 $ b $ 个点（$ a > b $）组成的斜率大于 $ 2 s_i $（如果小于，说明较靠后的 $ a $ 点更优）。\n\n因为斜率是单调递增的，所以第 2 条只需要使前两个元素满足条件即可。\n\n枚举 $ i $，不需要枚举 $ k $，而是从单调队列中寻找最优决策点。首先检查队首元素，使其满足条件 2，此时队首即为最优解；然后将当前决策点作为新的 $ k $ 加入到队列尾部，需要先删除一些决策点使得条件 1 被满足。因为每个决策点最多会被添加、删除各一次，所以状态转移的代价为均摊 $ O(1) $，总时间复杂度降为 $ O(nm) $，可以通过本题。\n\n注意正无穷的取值，合理取值可以避免特判。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-journey","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc0l006o7gxlou4w8vc2"},{"title":"「SDOI2016」生成魔咒 - 后缀数组","date":"2016-04-12T13:57:57.000Z","_content":"\n魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $ 1 $、$ 2 $ 拼凑起来形成一个魔咒串 $ [1, 2] $。  \n一个魔咒串 $ S $ 的非空字串被称为魔咒串 $ S $ 的生成魔咒。  \n例如 $ S = [1, 2, 1] $ 时，它的生成魔咒有 $ [1] $、$ [2] $、$ [1, 2] $、$ [2, 1] $、$ [1, 2, 1] $ 五种。$ S = [1, 1, 1] $ 时，它的生成魔咒有 $ [1] $、$ [1, 1] $、$ [1, 1, 1] $ 三种。  \n最初 $ S $ 为空串。共进行 $ n $ 次操作，每次操作是在 $ S $ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $ S $ 共有多少种生成魔咒。\n\n<!-- more -->\n\n### 链接\n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### 题解\n如果没有加入字符的操作，可以直接使用后缀数组的 $ {\\rm height} $ 计算。有了在结尾加入字符的操作，我们可以将整个串反转，变成在开头加入字符，这样相当于每次添加一个后缀。\n\n将操作离线，得到最终的串，对它建立后缀数组和稀疏表。\n\n用一个 `std::set` 维护当前已经被加入的后缀的排名，以方便查询当前加入的后缀的排名前、后一位的后缀。\n\n考虑每次加入一个新的后缀对答案的贡献。统计每个时刻串中的重复子串数量，设新加入的后缀为 $ i $，排在它前、后一位的后缀分别为 $ pred $、$ succ $。\n\n在加入之前，$ pred $、$ succ $ 的排名是相邻的，而现在不相邻了，需要减去它们的最长公共前缀长度。加入之后，$ pred $、$ succ $ 都与 $ i $ 相邻，需要加上它们的最长公共前缀长度。\n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n根据等差数列求和公式，长度为 $ i $ 的字符串的总子串数量为\n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n每次用总子串数量减去重复数量即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-incantation.md","raw":"title: 「SDOI2016」生成魔咒 - 后缀数组\ndate: 2016-04-12 21:57:57\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - 后缀数组\n  - 字符串\n  - RMQ\npermalink: sdoi2016-incantation\n---\n\n魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $ 1 $、$ 2 $ 拼凑起来形成一个魔咒串 $ [1, 2] $。  \n一个魔咒串 $ S $ 的非空字串被称为魔咒串 $ S $ 的生成魔咒。  \n例如 $ S = [1, 2, 1] $ 时，它的生成魔咒有 $ [1] $、$ [2] $、$ [1, 2] $、$ [2, 1] $、$ [1, 2, 1] $ 五种。$ S = [1, 1, 1] $ 时，它的生成魔咒有 $ [1] $、$ [1, 1] $、$ [1, 1, 1] $ 三种。  \n最初 $ S $ 为空串。共进行 $ n $ 次操作，每次操作是在 $ S $ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $ S $ 共有多少种生成魔咒。\n\n<!-- more -->\n\n### 链接\n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### 题解\n如果没有加入字符的操作，可以直接使用后缀数组的 $ {\\rm height} $ 计算。有了在结尾加入字符的操作，我们可以将整个串反转，变成在开头加入字符，这样相当于每次添加一个后缀。\n\n将操作离线，得到最终的串，对它建立后缀数组和稀疏表。\n\n用一个 `std::set` 维护当前已经被加入的后缀的排名，以方便查询当前加入的后缀的排名前、后一位的后缀。\n\n考虑每次加入一个新的后缀对答案的贡献。统计每个时刻串中的重复子串数量，设新加入的后缀为 $ i $，排在它前、后一位的后缀分别为 $ pred $、$ succ $。\n\n在加入之前，$ pred $、$ succ $ 的排名是相邻的，而现在不相邻了，需要减去它们的最长公共前缀长度。加入之后，$ pred $、$ succ $ 都与 $ i $ 相邻，需要加上它们的最长公共前缀长度。\n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n根据等差数列求和公式，长度为 $ i $ 的字符串的总子串数量为\n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n每次用总子串数量减去重复数量即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-incantation","published":1,"updated":"2016-04-30T13:37:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc0q006y7gxluwg7htoy"},{"title":"「SDOI2016」游戏 - 树链剖分","date":"2016-04-15T14:25:55.000Z","_content":"\nAlice 和 Bob 在玩一个游戏。  \n游戏在一棵有 $ n $ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $ 123456789123456789 $。  \n有时，Alice 会选择一条从 $ s $ 到 $ t $ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $ r $，若 $ r $ 与 $ s $ 的距离是 $ dis $，那么 Alice 在点 $ r $ 上添加的数字是 $ a \\times dis + b $。  \n有时，Bob 会选择一条从 $ s $ 到 $ t $ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。  \nBob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### 题解\n首先，树链剖分，转化成链上的操作，使用线段树维护。\n\n对一条路径上的每个点添加一个数字，设 $ p = {\\rm LCA}(s, t) $ ，可以把这条路径分为两条链，即 $ s \\rightarrow p $、$ p \\rightarrow t $。\n\n![Tree](sdoi2016-game/tree.png)\n\n设 $ {\\rm dist}(u, v) $ 为 u、v 两点间距离，则左边一条路径上每一个点被赋的值为\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n注意到，后面的 $ a \\times {\\rm dist}(s, root) + b $ 是一个常数。\n\n右边的一条路径上每个点被赋的值为\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n同理，后面的 $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ 也是一个常数。\n\n这样，我们得到了两个直线的斜截式方程，问题转化为：在序列上给一段区间添加一条直线；求一段区间内所有直线方程带入 $ x $ 值后的最小 $ y $ 值。\n\n这个问题可以使用线段树解决，每个节点维护：\n\n1. 区间最小值；\n2. 在当前节点 `mid` （区间中点）处取得值最小的一条直线。\n\n因为所有叶子节点的 `mid` 构成了整条线段，所以这样维护一定可以取得最小值。\n\n注意到直线的方程这种标记是不能合并的，所以每当添加一条直线的时候，判断这条直线在区间左端点、区间中点、区间右端点处带入得到的值是否比原有直线更优。\n\n如果左右端点都取**不**到更优值，则中点一定取不到更优值，且子节点的中点（整个区间）都取不到更优值，因为一次函数的图像是单调的。此时直接舍弃新的直线即可。\n\n如果左右端点都能取到更优值，同理，中点一定能取到更优值，且子节点的中点（整个区间）都能取到更优值。此时直接更新舍弃旧的直线即可。\n\n其他的情况，均为左右端点之一能取到更优值。如果中点能取到更优值，可以将新旧直线互换，并将左右端点能否取到更优值取反。即转化为，只有左右端点之一能取到更优值。\n\n此时的两条直线图像是这样的（因为带入的横坐标是离散的，所以真实的情况并不一定是直线，此处便于理解画成直线）：\n\n![Line](sdoi2016-game/line.png)\n\n旧直线为浅色，新直线为深色。可以看出在左端点处，新直线取得更优值，因为新直线已经不可能对当前节点（的中点处）有贡献，而只**可能**对左半个区间（的中点）有贡献，所以直接在线段树上向左子树下放即可。这是一个递归的过程。\n\n这样有一个问题，当前区间的新直线可能对两个子节点所控制的区间的中点的值有贡献，而查询时有可能查询到两个子节点而忽略当前节点。为了解决此问题，在查询子节点时，先尝试将自身记录的直线下放下去。\n\n树链剖分会产生最多 $ O(\\log n) $ 条重链，线段树上一次查询或修改操作会访问最多 $ O(\\log n) $ 个节点，每个标记最多被下传 $ O(\\log n) $ 次，所以该算法的时间复杂度为 $ O(n \\log ^ 3 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-game.md","raw":"title: 「SDOI2016」游戏 - 树链剖分\ndate: 2016-04-15 22:25:55\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - 树链剖分\n  - 线段树\n  - 数学\n  - 数据结构\n  - 最近公共祖先\npermalink: sdoi2016-game\n---\n\nAlice 和 Bob 在玩一个游戏。  \n游戏在一棵有 $ n $ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $ 123456789123456789 $。  \n有时，Alice 会选择一条从 $ s $ 到 $ t $ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $ r $，若 $ r $ 与 $ s $ 的距离是 $ dis $，那么 Alice 在点 $ r $ 上添加的数字是 $ a \\times dis + b $。  \n有时，Bob 会选择一条从 $ s $ 到 $ t $ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。  \nBob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### 题解\n首先，树链剖分，转化成链上的操作，使用线段树维护。\n\n对一条路径上的每个点添加一个数字，设 $ p = {\\rm LCA}(s, t) $ ，可以把这条路径分为两条链，即 $ s \\rightarrow p $、$ p \\rightarrow t $。\n\n![Tree](sdoi2016-game/tree.png)\n\n设 $ {\\rm dist}(u, v) $ 为 u、v 两点间距离，则左边一条路径上每一个点被赋的值为\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n注意到，后面的 $ a \\times {\\rm dist}(s, root) + b $ 是一个常数。\n\n右边的一条路径上每个点被赋的值为\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n同理，后面的 $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ 也是一个常数。\n\n这样，我们得到了两个直线的斜截式方程，问题转化为：在序列上给一段区间添加一条直线；求一段区间内所有直线方程带入 $ x $ 值后的最小 $ y $ 值。\n\n这个问题可以使用线段树解决，每个节点维护：\n\n1. 区间最小值；\n2. 在当前节点 `mid` （区间中点）处取得值最小的一条直线。\n\n因为所有叶子节点的 `mid` 构成了整条线段，所以这样维护一定可以取得最小值。\n\n注意到直线的方程这种标记是不能合并的，所以每当添加一条直线的时候，判断这条直线在区间左端点、区间中点、区间右端点处带入得到的值是否比原有直线更优。\n\n如果左右端点都取**不**到更优值，则中点一定取不到更优值，且子节点的中点（整个区间）都取不到更优值，因为一次函数的图像是单调的。此时直接舍弃新的直线即可。\n\n如果左右端点都能取到更优值，同理，中点一定能取到更优值，且子节点的中点（整个区间）都能取到更优值。此时直接更新舍弃旧的直线即可。\n\n其他的情况，均为左右端点之一能取到更优值。如果中点能取到更优值，可以将新旧直线互换，并将左右端点能否取到更优值取反。即转化为，只有左右端点之一能取到更优值。\n\n此时的两条直线图像是这样的（因为带入的横坐标是离散的，所以真实的情况并不一定是直线，此处便于理解画成直线）：\n\n![Line](sdoi2016-game/line.png)\n\n旧直线为浅色，新直线为深色。可以看出在左端点处，新直线取得更优值，因为新直线已经不可能对当前节点（的中点处）有贡献，而只**可能**对左半个区间（的中点）有贡献，所以直接在线段树上向左子树下放即可。这是一个递归的过程。\n\n这样有一个问题，当前区间的新直线可能对两个子节点所控制的区间的中点的值有贡献，而查询时有可能查询到两个子节点而忽略当前节点。为了解决此问题，在查询子节点时，先尝试将自身记录的直线下放下去。\n\n树链剖分会产生最多 $ O(\\log n) $ 条重链，线段树上一次查询或修改操作会访问最多 $ O(\\log n) $ 个节点，每个标记最多被下传 $ O(\\log n) $ 次，所以该算法的时间复杂度为 $ O(n \\log ^ 3 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-game","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc1100777gxlaeb2arly"},{"title":"「SDOI2015」星际战争 - 网络流","date":"2016-02-29T07:42:11.000Z","_content":"\nY 军团一共派遣了 $ N $ 个巨型机器人进攻 X 军团的阵地，其中第 $ i $ 个巨型机器人的装甲值为 $ A_i $。当一个巨型机器人的装甲值减少到 0 或者以下时，这个巨型机器人就被摧毁了。X 军团有 $ M $ 个激光武器，其中第 $ i $ 个激光武器每秒可以削减一个巨型机器人 $ B_i $ 的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### 题解\n先二分一个时间，然后用网络流判定是否能在这段时间内打完。\n\n1. 从源点到每一个武器连一条边，容量为武器的威力 × 时间；\n2. 从每一个机器人向汇点连一条边，容量为该机器人的装甲值；\n3. 从每个武器向所有从该武器能攻击的机器人连一条边，容量为正无穷。\n\n嗯，说起来很容易对吧w ……\n\n然而答案是实数，实数二分倒没什么问题，要注意的是 Dinic 模板也要改成实数的。\n\n二分的范围不太好确定，既然题目明确有解，那就定上界为**用一个威力最小的武器打所有机器人所用时间**，反正不会错。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n \nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n \nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n \n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n \nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n \ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n \nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n \n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n \n\t\ts->level = 1;\n\t\t \n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n \n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn false;\n\t}\n \n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n \n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn 0;\n\t}\n \n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n \n\t\treturn ans;\n\t}\n} dinic;\n \ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n \n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n \ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n \ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n \n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n \n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n \n\tdouble flow = dinic(s, t, n + m + 2);\n \n\tcleanUp(n + m + 2);\n \n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n \ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n \n\treturn l + (r - l) / 2;\n}\n \nint main() {\n\tscanf(\"%d %d\", &n, &m);\n \n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n \n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n \n\tprintf(\"%.6lf\\n\", dichotomy());\n \n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-war.md","raw":"title: 「SDOI2015」星际战争 - 网络流\ndate: 2016-02-29 15:42:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Dinic\n  - 图论\n  - 网络流\n  - 二分答案\n  - 实数二分\npermalink: sdoi2015-war\n---\n\nY 军团一共派遣了 $ N $ 个巨型机器人进攻 X 军团的阵地，其中第 $ i $ 个巨型机器人的装甲值为 $ A_i $。当一个巨型机器人的装甲值减少到 0 或者以下时，这个巨型机器人就被摧毁了。X 军团有 $ M $ 个激光武器，其中第 $ i $ 个激光武器每秒可以削减一个巨型机器人 $ B_i $ 的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### 题解\n先二分一个时间，然后用网络流判定是否能在这段时间内打完。\n\n1. 从源点到每一个武器连一条边，容量为武器的威力 × 时间；\n2. 从每一个机器人向汇点连一条边，容量为该机器人的装甲值；\n3. 从每个武器向所有从该武器能攻击的机器人连一条边，容量为正无穷。\n\n嗯，说起来很容易对吧w ……\n\n然而答案是实数，实数二分倒没什么问题，要注意的是 Dinic 模板也要改成实数的。\n\n二分的范围不太好确定，既然题目明确有解，那就定上界为**用一个威力最小的武器打所有机器人所用时间**，反正不会错。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n \nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n \nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n \n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n \nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n \ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n \nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n \n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n \n\t\ts->level = 1;\n\t\t \n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n \n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn false;\n\t}\n \n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n \n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn 0;\n\t}\n \n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n \n\t\treturn ans;\n\t}\n} dinic;\n \ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n \n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n \ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n \ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n \n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n \n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n \n\tdouble flow = dinic(s, t, n + m + 2);\n \n\tcleanUp(n + m + 2);\n \n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n \ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n \n\treturn l + (r - l) / 2;\n}\n \nint main() {\n\tscanf(\"%d %d\", &n, &m);\n \n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n \n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n \n\tprintf(\"%.6lf\\n\", dichotomy());\n \n\treturn 0;\n}\n```\n","slug":"sdoi2015-war","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc1f007i7gxlkcupd9ic"},{"title":"「SDOI2010」星际竞速 - 费用流","date":"2016-02-29T13:30:11.000Z","_content":"\n大赛要求车手们从一颗与这 $ N $ 颗行星之间没有任何航路的天体出发，访问这 $ N $ 颗行星每颗恰好一次。超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会沿星际航路高速航行。在能力爆发模式下，经过一段时间的定位之后，它能瞬间移动到任意一个行星。在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。求完成比赛的最少时间。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### 题解\n求完成比赛的最少时间，很容易想到最短路，然而不确定起点终点而且恰好访问一次都不太适合最短路 …… 考虑网络流建模吧。\n\n刚开始想到的一个**错误**的解法：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出，之间连一条容量为 1，费用为零的边；\n2. 从源点到每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点到汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 建立『中转站』，从每个点到中转站连一条容量为 1 费用为 0 的边；从中转站到每个点连一条容量为 1 费用为定位时间的边。\n\n求出最小费用最大流 …… 呃，答案就是零 ……\n\n很容易想出上面的模型是错的，因为它不能保证每个点都被访问过 —— 虽然它比较直观。\n\n再来分析一下题意，每个点都经过一次，有点类似路径覆盖，而路径覆盖中是没有边权的，考虑把边权加在费用上。\n\n一种**类似于路径覆盖**的建模方式：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出；\n2. 从源点向每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点向汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 从源点向每个**出点**连一条容量为 1 费用为定位时间的边。\n\n这种建模思想抓住了题目中『每个点经过一次』的条件，避开了路径上的问题 —— 整个网络保证了到汇点边全部满流，也就对应了每个点被经过一次。\n\n处理『瞬间移动』的思路是，不考虑是从哪个星球移动过来，向哪里走 —— 因为从每个点向哪里走是由选择的边决定的（甚至可能瞬移到的点就是终点），只需要考虑，瞬移经过的点不需要再在其他路径上被经过，所以直接从源点连到某个点的出点就好啦。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-starrace.md","raw":"title: 「SDOI2010」星际竞速 - 费用流 \ndate: 2016-02-29 21:30:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Edmonds-Karp\n  - 图论\n  - 网络流\n  - 费用流\npermalink: sdoi2010-starrace\n---\n\n大赛要求车手们从一颗与这 $ N $ 颗行星之间没有任何航路的天体出发，访问这 $ N $ 颗行星每颗恰好一次。超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会沿星际航路高速航行。在能力爆发模式下，经过一段时间的定位之后，它能瞬间移动到任意一个行星。在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。求完成比赛的最少时间。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### 题解\n求完成比赛的最少时间，很容易想到最短路，然而不确定起点终点而且恰好访问一次都不太适合最短路 …… 考虑网络流建模吧。\n\n刚开始想到的一个**错误**的解法：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出，之间连一条容量为 1，费用为零的边；\n2. 从源点到每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点到汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 建立『中转站』，从每个点到中转站连一条容量为 1 费用为 0 的边；从中转站到每个点连一条容量为 1 费用为定位时间的边。\n\n求出最小费用最大流 …… 呃，答案就是零 ……\n\n很容易想出上面的模型是错的，因为它不能保证每个点都被访问过 —— 虽然它比较直观。\n\n再来分析一下题意，每个点都经过一次，有点类似路径覆盖，而路径覆盖中是没有边权的，考虑把边权加在费用上。\n\n一种**类似于路径覆盖**的建模方式：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出；\n2. 从源点向每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点向汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 从源点向每个**出点**连一条容量为 1 费用为定位时间的边。\n\n这种建模思想抓住了题目中『每个点经过一次』的条件，避开了路径上的问题 —— 整个网络保证了到汇点边全部满流，也就对应了每个点被经过一次。\n\n处理『瞬间移动』的思路是，不考虑是从哪个星球移动过来，向哪里走 —— 因为从每个点向哪里走是由选择的边决定的（甚至可能瞬移到的点就是终点），只需要考虑，瞬移经过的点不需要再在其他路径上被经过，所以直接从源点连到某个点的出点就好啦。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-starrace","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc1k007t7gxlchvct3wh"},{"title":"「SDOI2008」洞穴勘测 - Link-Cut Tree","date":"2016-03-15T12:06:34.000Z","_content":"\n如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间出现了一条通道，终端机上会显示一条指令 `Connect u v`；如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间的通道被毁，终端机上会显示一条指令 `Destroy u v`。辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $ u $ 和洞穴 $ v $ 是否连通。已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### 题解\n最简单的 Link-Cut Tree 模板题。\n\n相当于能拆的并查集。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/sdoi2008-cave.md","raw":"title: 「SDOI2008」洞穴勘测 - Link-Cut Tree \ndate: 2016-03-15 20:06:34\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - CodeVS\n  - 数据结构\n  - 高级数据结构\n  - 动态树\n  - Link-Cut Tree\npermalink: sdoi2008-cave\n---\n\n如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间出现了一条通道，终端机上会显示一条指令 `Connect u v`；如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间的通道被毁，终端机上会显示一条指令 `Destroy u v`。辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $ u $ 和洞穴 $ v $ 是否连通。已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### 题解\n最简单的 Link-Cut Tree 模板题。\n\n相当于能拆的并查集。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"sdoi2008-cave","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc1n00817gxlpz38xqjl"},{"title":"「SCOI2015」小凸解密码 - set","date":"2016-03-25T00:53:27.000Z","_content":"\n给定一个环形数列 $ A $ 和运算符序列 $ C $，可以从任意一个位置作为起点计算 $ B $，方法为：\n\n1. $ B_0 = A_0 $；\n2. 当 $ C_x = + $ 时，$ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $；\n3. 当 $ C_x = * $ 时，$ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $；\n\n每次可以修改 $ A $ 和 $ C $ 中的某一个元素，询问以指定起点开始计算 $ B $ 得到的环形数列 $ B $ 中距离 $ B_0 $ 最远的零区间中距离 $ B_0 $ 最近的零的距离。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### 题解\n首先，可以发现在没有修改的情况下，指定的不同起点只是起点得到的值不同，我们先直接递推计算出 B，查询的时候修改 $ B_0 = A_0 $ 查询完改回去。一次修改只会影响两个位置（$ B_i $ 和 $ B_{i + 1} $）。\n\n所以问题转化为，维护一个环形零一串，每次修改一个位置，查询到某个位置的最近零区间。\n\n用 `set` 维护每一个零区间，然后各种分情况讨论 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-password.md","raw":"title: 「SCOI2015」小凸解密码 - set\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - set\n  - 乱搞\npermalink: scoi2015-password\ndate: 2016-03-25 08:53:27\n---\n\n给定一个环形数列 $ A $ 和运算符序列 $ C $，可以从任意一个位置作为起点计算 $ B $，方法为：\n\n1. $ B_0 = A_0 $；\n2. 当 $ C_x = + $ 时，$ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $；\n3. 当 $ C_x = * $ 时，$ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $；\n\n每次可以修改 $ A $ 和 $ C $ 中的某一个元素，询问以指定起点开始计算 $ B $ 得到的环形数列 $ B $ 中距离 $ B_0 $ 最远的零区间中距离 $ B_0 $ 最近的零的距离。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### 题解\n首先，可以发现在没有修改的情况下，指定的不同起点只是起点得到的值不同，我们先直接递推计算出 B，查询的时候修改 $ B_0 = A_0 $ 查询完改回去。一次修改只会影响两个位置（$ B_i $ 和 $ B_{i + 1} $）。\n\n所以问题转化为，维护一个环形零一串，每次修改一个位置，查询到某个位置的最近零区间。\n\n用 `set` 维护每一个零区间，然后各种分情况讨论 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-password","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc1z008c7gxl3bej5e3s"},{"title":"「SCOI2015」情报传递 - 离线 + Link-Cut Tree","date":"2016-03-22T10:09:12.000Z","_content":"\n奈特公司有着庞大的情报网络。情报网络中共有 $ n $ 名情报员。每名情报员有若干名下线，除 1 名大头目外其余 $ n - 1 $ 名情报员有且仅有 1 名上线。每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $ T $ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $ X $ 号情报员传递给 $ Y $ 号情报员。\n\n情报员最初处于潜伏阶段，危险值为 0；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 1 点危险值（开始搜集情报的当天危险值仍为 0，第 2 天危险值为 1，以此类推）。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $ C $。公司认为，传递这条情报的所有情报员中，危险值大于 $ C $ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### 题解\n因为整个网络是一棵树，所以可以用一棵 Link-Cut Tree 来维护。\n\n前 30 分，无修改操作，直接求出两点距离。\n\n30 ~ 60 分，保证 $ C = 0 $，修改直接单点修改值为 1，查询直接查询有多少 1 即可。\n\n后 40 分，考虑到对于每个查询操作，只有距离它 $ C + 1 $ 天之前的修改操作对它有贡献，所以可以将操作离线，保证每次修改后直接处理查询即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-message.md","raw":"title: 「SCOI2015」情报传递 - 离线 + Link-Cut Tree\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - 离线\n  - Link-Cut Tree\n  - 数据结构\n  - 高级数据结构\npermalink: scoi2015-message\ndate: 2016-03-22 18:09:12\n---\n\n奈特公司有着庞大的情报网络。情报网络中共有 $ n $ 名情报员。每名情报员有若干名下线，除 1 名大头目外其余 $ n - 1 $ 名情报员有且仅有 1 名上线。每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $ T $ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $ X $ 号情报员传递给 $ Y $ 号情报员。\n\n情报员最初处于潜伏阶段，危险值为 0；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 1 点危险值（开始搜集情报的当天危险值仍为 0，第 2 天危险值为 1，以此类推）。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $ C $。公司认为，传递这条情报的所有情报员中，危险值大于 $ C $ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### 题解\n因为整个网络是一棵树，所以可以用一棵 Link-Cut Tree 来维护。\n\n前 30 分，无修改操作，直接求出两点距离。\n\n30 ~ 60 分，保证 $ C = 0 $，修改直接单点修改值为 1，查询直接查询有多少 1 即可。\n\n后 40 分，考虑到对于每个查询操作，只有距离它 $ C + 1 $ 天之前的修改操作对它有贡献，所以可以将操作离线，保证每次修改后直接处理查询即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-message","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc25008m7gxlp013chiy"},{"title":"「SCOI2015」小凸玩矩阵 - 二分图匹配","date":"2016-03-22T09:56:34.000Z","_content":"\n小方给小凸一个 $ N * M $（$ N \\leq M $）的矩阵 $ A $，要求小秃从其中选出 $ N $个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的 $ N $ 个数中第 $ K $ 大的数字的最小值是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### 题解\n二分第 $ K $ 大的数是多少，然后建二分图，用行匹配列，检验匹配数是不是大于等于 $ N - K + 1 $。\n\n注意，是第 $ K $ 大，不是第 $ K $ 小！\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-matrix.md","raw":"title: 「SCOI2015」小凸玩矩阵 - 二分图匹配\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - 二分答案\n  - 二分图匹配\n  - 网络流\n  - Dinic\npermalink: scoi2015-matrix\ndate: 2016-03-22 17:56:34\n---\n\n小方给小凸一个 $ N * M $（$ N \\leq M $）的矩阵 $ A $，要求小秃从其中选出 $ N $个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的 $ N $ 个数中第 $ K $ 大的数字的最小值是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### 题解\n二分第 $ K $ 大的数是多少，然后建二分图，用行匹配列，检验匹配数是不是大于等于 $ N - K + 1 $。\n\n注意，是第 $ K $ 大，不是第 $ K $ 小！\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-matrix","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc29008v7gxlxesrg10e"},{"title":"「SCOI2015」小凸玩密室 - 树形DP","date":"2016-03-23T15:16:05.000Z","_content":"\n密室是一棵有 $ n $ 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。每个灯泡有个权值 $ A_i $，每条边也有个权值 $ B_i $。点亮第 $ 1 $ 个灯泡不需要花费，之后每点亮 $ 1 $ 个新的灯泡 $ V $ 的花费，等于上一个被点亮的灯泡 $ U $ 到这个点 $ V $ 的距离 $ D_{u, v} $，乘以这个点的权值 $ A_v $。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。请告诉他们，逃出密室的最少花费是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### 题解\n动态规划，用 $ f_{x, i} $ 表示走完 $ x $ 及其子树再走到其第 $ i $ 层祖先的另一个孩子的最小代价。\n\n\n当 $ x $ 为叶子节点时，直接走过去\n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n当 $ x $ 只有左儿子时，先走到左孩子，再从左孩子走过去\n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n当 $ x $ 既有左儿子，又有右儿子时，考虑先走哪个最优\n\n另一个 DP：$ g_{x, i} $ 表示走完 $ x $ 及其子树再走到其第 $ i $ 层祖先的最小代价。\n\n当 $ x $ 为叶子节点时，直接走过去\n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n当 $ x $ 只有左儿子时，先走到左孩子，再从左孩子走过去\n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n当 $ x $ 既有左儿子，又有右儿子时，考虑先走哪个最优\n\n\n状态表示中，$ i = 0 $ 表示停在任意位置，因为计算 $ {\\rm dist} $ 的时候任何一个点走到 $ 0 $ 的花费都是 $ 0 $。\n\n枚举从哪个点开始，如果从根开始，答案为 $ g_{1, 0} $，否则先走自己，再走兄弟，再走父亲，再走父亲的兄弟的顺序，直到走到根，取所有答案的最小值。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-light.md","raw":"title: 「SCOI2015」小凸玩密室 - 树形DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - DP\n  - 树形DP\npermalink: scoi2015-light\ndate: 2016-03-23 23:16:05\n---\n\n密室是一棵有 $ n $ 个节点的完全二叉树，每个节点有一个灯泡。点亮所有灯泡即可逃出密室。每个灯泡有个权值 $ A_i $，每条边也有个权值 $ B_i $。点亮第 $ 1 $ 个灯泡不需要花费，之后每点亮 $ 1 $ 个新的灯泡 $ V $ 的花费，等于上一个被点亮的灯泡 $ U $ 到这个点 $ V $ 的距离 $ D_{u, v} $，乘以这个点的权值 $ A_v $。在点灯的过程中，要保证任意时刻所有被点亮的灯泡必须连通，在点亮一个灯泡后必须先点亮其子树所有灯泡才能点亮其他灯泡。请告诉他们，逃出密室的最少花费是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### 题解\n动态规划，用 $ f_{x, i} $ 表示走完 $ x $ 及其子树再走到其第 $ i $ 层祖先的另一个孩子的最小代价。\n\n\n当 $ x $ 为叶子节点时，直接走过去\n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n当 $ x $ 只有左儿子时，先走到左孩子，再从左孩子走过去\n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n当 $ x $ 既有左儿子，又有右儿子时，考虑先走哪个最优\n\n另一个 DP：$ g_{x, i} $ 表示走完 $ x $ 及其子树再走到其第 $ i $ 层祖先的最小代价。\n\n当 $ x $ 为叶子节点时，直接走过去\n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n当 $ x $ 只有左儿子时，先走到左孩子，再从左孩子走过去\n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n当 $ x $ 既有左儿子，又有右儿子时，考虑先走哪个最优\n\n\n状态表示中，$ i = 0 $ 表示停在任意位置，因为计算 $ {\\rm dist} $ 的时候任何一个点走到 $ 0 $ 的花费都是 $ 0 $。\n\n枚举从哪个点开始，如果从根开始，答案为 $ g_{1, 0} $，否则先走自己，再走兄弟，再走父亲，再走父亲的兄弟的顺序，直到走到根，取所有答案的最小值。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-light","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc2e00957gxlqyprrsdc"},{"title":"「SCOI2015」国旗计划 - 贪心 + 倍增","date":"2016-03-22T10:25:14.000Z","_content":"\nA 国幅员辽阔，边境线上设有 $ M $ 个边防站，顺时针编号 $ 1 $ 至 $ M $。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。每名战士的奔袭区间都不会被其他战士的奔袭区间所包含。\n\n现在，局长希望知道，至少需要多少名战士，才能使得他们的奔袭区间覆盖全部的边境线。局长还希望知道对于每一名战士，在他必须参加国旗计划的前提下，至少需要多少名战士才能覆盖全部边境线。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### 题解\n首先，明确一个贪心的思路：对于任何一个战士，选择他后要选择的下一个，一定是在他后面并且与他奔袭区间交集最小的（因为所有的区间完全覆盖并且没有相互包含）。\n\n把所有区间翻倍存储，以左端点排序。\n\n40 分：枚举每个战士，在他之后的所有战士中确定一个与他奔袭区间交集最小的，作为他的下一个（时间复杂度 $ O(n ^ 2) $）；然后对于每个询问从该战士开始不断找下一个战士，直到找回来为止；\n\n70 分：把找「下一个战士」的复杂度优化为 $ O(n \\log n) $，使用 `std::upper_bound`，用当前战士的区间右端点和其他区间的左端点比较，返回的结果 -1 即为要找的「下一个战士」。\n\n100 分：思考回答询问时的过程，每次线性地向后扫描做了很多重复的工作，考虑到无论从那个战士出发，经过的相同位置向后的路线都是相同的，所以可以先 $ O(n \\log n) $ 地预处理出一个稀疏表，用 $ next_{i, j} $ 表示战士 $ i $ 向后找 $ 2 ^ j $ 次所到达的战士，然后就可以 $ O(\\log n) $ 地回答每个询问了。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-flag.md","raw":"title: 「SCOI2015」国旗计划 - 贪心 + 倍增\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安徽集训\n  - 贪心\n  - 倍增\npermalink: scoi2015-flag\ndate: 2016-03-22 18:25:14\n---\n\nA 国幅员辽阔，边境线上设有 $ M $ 个边防站，顺时针编号 $ 1 $ 至 $ M $。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。每名战士的奔袭区间都不会被其他战士的奔袭区间所包含。\n\n现在，局长希望知道，至少需要多少名战士，才能使得他们的奔袭区间覆盖全部的边境线。局长还希望知道对于每一名战士，在他必须参加国旗计划的前提下，至少需要多少名战士才能覆盖全部边境线。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### 题解\n首先，明确一个贪心的思路：对于任何一个战士，选择他后要选择的下一个，一定是在他后面并且与他奔袭区间交集最小的（因为所有的区间完全覆盖并且没有相互包含）。\n\n把所有区间翻倍存储，以左端点排序。\n\n40 分：枚举每个战士，在他之后的所有战士中确定一个与他奔袭区间交集最小的，作为他的下一个（时间复杂度 $ O(n ^ 2) $）；然后对于每个询问从该战士开始不断找下一个战士，直到找回来为止；\n\n70 分：把找「下一个战士」的复杂度优化为 $ O(n \\log n) $，使用 `std::upper_bound`，用当前战士的区间右端点和其他区间的左端点比较，返回的结果 -1 即为要找的「下一个战士」。\n\n100 分：思考回答询问时的过程，每次线性地向后扫描做了很多重复的工作，考虑到无论从那个战士出发，经过的相同位置向后的路线都是相同的，所以可以先 $ O(n \\log n) $ 地预处理出一个稀疏表，用 $ next_{i, j} $ 表示战士 $ i $ 向后找 $ 2 ^ j $ 次所到达的战士，然后就可以 $ O(\\log n) $ 地回答每个询问了。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-flag","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc2i009d7gxlumwgqmhg"},{"title":"「SCOI2011」糖果 - 强联通分量 + 拓扑排序","date":"2016-03-04T13:32:23.000Z","_content":"\n幼儿园里有 $ N $ 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。在分配糖果的时候，需要满足小朋友们的 $ K $ 个要求。幼儿园的糖果总是有限的，想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### 题解\n在满足题目的要求下，最优解一定是：最少的一个，比别人多也只多一个。很容易想到用查分约束系统来做。\n\n然而刚学了 Tarjan 就想乱搞搞，做法是，把所有关系转化为小于等于和小于两种，先把小于等于的边全部加进去，跑一遍 Tarjan，然后缩点，此时一个强联通分量上的小朋友糖果数是相同的。\n\n把小于的边再加上，进行拓扑排序，如果有环说明无解。把小于等于的边权值置为 0，小于的边权值置为 1，入度为零的点距离置为 1。求出所有最长路，每个点距离乘以该点小朋友的数量的和即为答案。\n\n注意开 `long long`。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2011-candy.md","raw":"title: 「SCOI2011」糖果 - 强联通分量 + 拓扑排序\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 强联通分量\n  - Tarjan\n  - 缩点\n  - 拓扑排序\n  - 差分约束系统\npermalink: scoi2011-candy\ndate: 2016-03-04 21:32:23\n---\n\n幼儿园里有 $ N $ 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。在分配糖果的时候，需要满足小朋友们的 $ K $ 个要求。幼儿园的糖果总是有限的，想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### 题解\n在满足题目的要求下，最优解一定是：最少的一个，比别人多也只多一个。很容易想到用查分约束系统来做。\n\n然而刚学了 Tarjan 就想乱搞搞，做法是，把所有关系转化为小于等于和小于两种，先把小于等于的边全部加进去，跑一遍 Tarjan，然后缩点，此时一个强联通分量上的小朋友糖果数是相同的。\n\n把小于的边再加上，进行拓扑排序，如果有环说明无解。把小于等于的边权值置为 0，小于的边权值置为 1，入度为零的点距离置为 1。求出所有最长路，每个点距离乘以该点小朋友的数量的和即为答案。\n\n注意开 `long long`。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","slug":"scoi2011-candy","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc2n009m7gxlki7qv37i"},{"title":"「SCOI2010」游戏 - 二分图匹配","date":"2016-03-07T01:43:18.000Z","_content":"\n在游戏里，他拥有很多的装备，每种装备都有两个属性，这些属性的值用 $ [1, 10000] $ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 终极 BOSS 很奇怪，攻击他的装备所使用的属性值必须从 $ 1 $ 开始连续递增地攻击，才能对 BOSS 产生伤害。也就是说一开始的时候，只能使用某个属性值为 $ 1 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 2 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 3 $ 的装备攻击 BOSS …… 以此类推。他最多能连续攻击 BOSS 多少次？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### 题解\n看一下数据范围 $ N ≤ 1000000 $，如果枚举每件武器，肯定要 $ O(n) $ 的算法才能过，但又想不出 $ O(n) $ 的算法来 ……\n\n我们换一种思路，从属性值小到大，之间如果有一个数不能没有可用的武器，则不可能继续打出比这个数更大的属性值了。也就是说答案具有单调性，可以采用枚举答案并检验的方法。\n\n题目中并没有要求某个属性值要由特定的武器打出，所以说可以任意选择某个可用的武器来打出指定的属性值。\n\n从 $ 1 $ 开始，任选一个可打出 $ 1 $ 的武器并标记为使用过，枚举时如果发现能打出 $ X $ 的武器全部被用过了，就尝试将某一件属性值为 $ \\{X, Y\\} $ 武器标记为 $ X $，并寻找 $ Y $ 的替代（$ Y < X $），这样递归下去，直到某个属性值使用了一件没有被使用武器，则成功，否则失败。\n\n算法思想与『二分图匹配』中的匈牙利算法比较相似。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2010-game.md","raw":"title: 「SCOI2010」游戏 - 二分图匹配\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 图论\n  - 二分图匹配\n  - 匈牙利算法\n  - 枚举答案\npermalink: scoi2010-game\ndate: 2016-03-07 09:43:18\n---\n\n在游戏里，他拥有很多的装备，每种装备都有两个属性，这些属性的值用 $ [1, 10000] $ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 终极 BOSS 很奇怪，攻击他的装备所使用的属性值必须从 $ 1 $ 开始连续递增地攻击，才能对 BOSS 产生伤害。也就是说一开始的时候，只能使用某个属性值为 $ 1 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 2 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 3 $ 的装备攻击 BOSS …… 以此类推。他最多能连续攻击 BOSS 多少次？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### 题解\n看一下数据范围 $ N ≤ 1000000 $，如果枚举每件武器，肯定要 $ O(n) $ 的算法才能过，但又想不出 $ O(n) $ 的算法来 ……\n\n我们换一种思路，从属性值小到大，之间如果有一个数不能没有可用的武器，则不可能继续打出比这个数更大的属性值了。也就是说答案具有单调性，可以采用枚举答案并检验的方法。\n\n题目中并没有要求某个属性值要由特定的武器打出，所以说可以任意选择某个可用的武器来打出指定的属性值。\n\n从 $ 1 $ 开始，任选一个可打出 $ 1 $ 的武器并标记为使用过，枚举时如果发现能打出 $ X $ 的武器全部被用过了，就尝试将某一件属性值为 $ \\{X, Y\\} $ 武器标记为 $ X $，并寻找 $ Y $ 的替代（$ Y < X $），这样递归下去，直到某个属性值使用了一件没有被使用武器，则成功，否则失败。\n\n算法思想与『二分图匹配』中的匈牙利算法比较相似。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","slug":"scoi2010-game","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc2s009x7gxlv26o9ugw"},{"title":"「SCOI2009」windy 数 - 数位DP","date":"2016-05-12T09:25:00.000Z","_content":"\nwindy 定义了一种 windy 数。不含前导零且相邻两个数字之差至少为 $ 2 $ 的正整数被称为 windy 数。\n\nwindy 想知道，在 $ A $ 和 $ B $ 之间，包括 $ A $ 和 $ B $，总共有多少个 windy 数？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### 题解\n数位 DP，设\n\n$$ f[n][last][notZero][limited] $$\n\n表示最后 $ n $ 位数，这 $ n $ 位数的前一位数是 $ last $，之前是否有非零数（如果前面全是零则不考虑差分限制），是否达到上界，的总数量。\n\nPS：不允许有前导零的实现方式是，允许前导零，但不对前导零设置限制。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","source":"_posts/scoi2009-windy.md","raw":"title: 「SCOI2009」windy 数 - 数位DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 数位DP\n  - DP\npermalink: scoi2009-windy\ndate: 2016-05-12 17:25:00\n---\n\nwindy 定义了一种 windy 数。不含前导零且相邻两个数字之差至少为 $ 2 $ 的正整数被称为 windy 数。\n\nwindy 想知道，在 $ A $ 和 $ B $ 之间，包括 $ A $ 和 $ B $，总共有多少个 windy 数？\n\n<!-- more -->\n\n### 链接\n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### 题解\n数位 DP，设\n\n$$ f[n][last][notZero][limited] $$\n\n表示最后 $ n $ 位数，这 $ n $ 位数的前一位数是 $ last $，之前是否有非零数（如果前面全是零则不考虑差分限制），是否达到上界，的总数量。\n\nPS：不允许有前导零的实现方式是，允许前导零，但不对前导零设置限制。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","slug":"scoi2009-windy","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc2x00a77gxlvjsr26s3"},{"title":"「SCOI2007」修车 - 费用流","date":"2016-03-09T01:52:35.000Z","_content":"\n同一时刻有 $ N $ 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 $ M $ 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 $ M $ 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。\n\n顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### 题解\n为每辆车建立点，为每个技术人员的**每一次修车**建立点。\n\n设第 $ i $ 个技术人员修第 $ j $ 辆车所用时间为 $ t_{i, j} $，第 $ i $ 辆车的点为 $ v_i $，第 $ i $ 个技术人员倒数第 $ k $ 次修车（此时有 $ k $ 个人在等待）的点为 $ v_{j, k} $（$ k {\\in} [1, n] $）。\n\n从源点向每辆车连边，容量为 1，费用为 0；从每个 $ v_i $ 向每个 $ v_{j, k} $ 连边，容量为 1，费用为 $ t_{i, j} * k $；从每个 $ v_{j, k} $ 向汇点连边，容量为 1，费用为 0。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n又一次把 $ n $、$ m $ 读入倒了 ……\n\n又一次敲错 EK 模板 ……\n\nhehe\n","source":"_posts/scoi2007-repair.md","raw":"title: 「SCOI2007」修车 - 费用流\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - SCOI\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\npermalink: scoi2007-repair\ndate: 2016-03-09 09:52:35\n---\n\n同一时刻有 $ N $ 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 $ M $ 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 $ M $ 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。\n\n顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### 题解\n为每辆车建立点，为每个技术人员的**每一次修车**建立点。\n\n设第 $ i $ 个技术人员修第 $ j $ 辆车所用时间为 $ t_{i, j} $，第 $ i $ 辆车的点为 $ v_i $，第 $ i $ 个技术人员倒数第 $ k $ 次修车（此时有 $ k $ 个人在等待）的点为 $ v_{j, k} $（$ k {\\in} [1, n] $）。\n\n从源点向每辆车连边，容量为 1，费用为 0；从每个 $ v_i $ 向每个 $ v_{j, k} $ 连边，容量为 1，费用为 $ t_{i, j} * k $；从每个 $ v_{j, k} $ 向汇点连边，容量为 1，费用为 0。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n又一次把 $ n $、$ m $ 读入倒了 ……\n\n又一次敲错 EK 模板 ……\n\nhehe\n","slug":"scoi2007-repair","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc3100ad7gxldtkg5k8d"},{"title":"「POJ 3461」Oulipo - KMP","date":"2016-04-09T13:36:23.000Z","_content":"\n给出两个字符串，求一个字符串在另一个字符串中的出现次数。\n\n<!-- more -->\n\n### 题解\nKMP 裸题，拿来练练模板 ……\n\n注意 `next` 千万不要声明成 `char` 型，别问我为什么要说这个 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/poj-3461.md","raw":"title: 「POJ 3461」Oulipo - KMP\ncategories: OI\ntags: \n  - POJ\n  - KMP\n  - 字符串\n  - 算法模板\npermalink: poj-3461\ndate: 2016-04-09 21:36:23\n---\n\n给出两个字符串，求一个字符串在另一个字符串中的出现次数。\n\n<!-- more -->\n\n### 题解\nKMP 裸题，拿来练练模板 ……\n\n注意 `next` 千万不要声明成 `char` 型，别问我为什么要说这个 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","slug":"poj-3461","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc3600am7gxlbbk8vdob"},{"title":"「POJ 2728」Desert King - 01 分数规划","date":"2016-03-11T01:33:14.000Z","_content":"\n一个王国有 $ N $ 个城市，每个城市有坐标 $ (x, y) $ 和海拔 $ z $，在 $ N $ 个城市之间修水渠，要保证每个城市有水，水渠是水平的，每个城市的海拔不同，现在要求修单位长度的水渠的海拔高度差最小。\n\n<!-- more -->\n\n### 链接\n[POJ 2728](http://poj.org/problem?id=2728)\n\n### 题解\n最优比率生成树，01 分数规划，搞的不是很明白 …… Orz\n\nPS：果然我的代码自带大常数，搞了一早上不是 WA 就是 TLE，最后把编译器从 G++ 改为 VC++ 就 AC 了 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-2728.md","raw":"title: 「POJ 2728」Desert King - 01 分数规划\ncategories: OI\ntags: \n  - POJ\n  - Prim\n  - 生成树\n  - 二分答案\n  - 实数二分\n  - 分数规划\npermalink: poj-2728\ndate: 2016-03-11 09:33:14\n---\n\n一个王国有 $ N $ 个城市，每个城市有坐标 $ (x, y) $ 和海拔 $ z $，在 $ N $ 个城市之间修水渠，要保证每个城市有水，水渠是水平的，每个城市的海拔不同，现在要求修单位长度的水渠的海拔高度差最小。\n\n<!-- more -->\n\n### 链接\n[POJ 2728](http://poj.org/problem?id=2728)\n\n### 题解\n最优比率生成树，01 分数规划，搞的不是很明白 …… Orz\n\nPS：果然我的代码自带大常数，搞了一早上不是 WA 就是 TLE，最后把编译器从 G++ 改为 VC++ 就 AC 了 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","slug":"poj-2728","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc3c00au7gxl9ejcro5j"},{"title":"「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推","date":"2016-03-14T04:12:45.000Z","_content":"\n给定 $ N $（$ N \\leq 50 $）个点，在平面上固定其位置，求这些点最多能组成多少个不同的无向连通图。\n\n<!-- more -->\n\n### 链接\n[POJ 1737](http://poj.org/problem?id=1737)\n\n### 题解\n统计连通图的方案数是困难的，但我们可以轻易地计算出用 N 个点组成任意图的方案数：因为 N 个点的**无向**图最多有 $ \\frac{N(N - 1)}{2} $ 条边，考虑每条边选或不选，则共有 $ 2 ^ {\\frac{N(N - 1)}{2}} $ 种不同的图。\n\n求出任意图的方案数后，只要再求出非连通图的方案数，就可以得到答案。考虑 $ N $ 个点组成的非连通图中的点 $ v $，它一定处于一个由 $ K $（$ 1 \\leq K \\leq N - 1 $）个点组成的**联通分量**中，点 $ v $ 确定后，组成这个联通分量还需要 $ K - 1 $ 个点，总方案数为 $ \\binom{N - 1}{K - 1} $；每个连通分量都是一个**连通图**，可以递归来求；考虑完一个联通分量，图的剩余部分（与该联通分量隔离的 $ N - K $ 个点）是一个任意图，也可以递归来求。\n\n设 $ n $ 个点组成连通图的方案数为 $ f(n) $、组成非联通图的方案数为 $ g(n) $、组成任意图的方案数为 $ h(n) $，则递归计算 $ f(n) $ 的公式为：\n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n需要使用高精度。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-1737.md","raw":"title: 「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推\ncategories: OI\ntags: \n  - POJ\n  - 递推\n  - 高精度\n  - 组合数\n  - 计数原理\n  - 数学\npermalink: poj-1737\ndate: 2016-03-14 12:12:45\n---\n\n给定 $ N $（$ N \\leq 50 $）个点，在平面上固定其位置，求这些点最多能组成多少个不同的无向连通图。\n\n<!-- more -->\n\n### 链接\n[POJ 1737](http://poj.org/problem?id=1737)\n\n### 题解\n统计连通图的方案数是困难的，但我们可以轻易地计算出用 N 个点组成任意图的方案数：因为 N 个点的**无向**图最多有 $ \\frac{N(N - 1)}{2} $ 条边，考虑每条边选或不选，则共有 $ 2 ^ {\\frac{N(N - 1)}{2}} $ 种不同的图。\n\n求出任意图的方案数后，只要再求出非连通图的方案数，就可以得到答案。考虑 $ N $ 个点组成的非连通图中的点 $ v $，它一定处于一个由 $ K $（$ 1 \\leq K \\leq N - 1 $）个点组成的**联通分量**中，点 $ v $ 确定后，组成这个联通分量还需要 $ K - 1 $ 个点，总方案数为 $ \\binom{N - 1}{K - 1} $；每个连通分量都是一个**连通图**，可以递归来求；考虑完一个联通分量，图的剩余部分（与该联通分量隔离的 $ N - K $ 个点）是一个任意图，也可以递归来求。\n\n设 $ n $ 个点组成连通图的方案数为 $ f(n) $、组成非联通图的方案数为 $ g(n) $、组成任意图的方案数为 $ h(n) $，则递归计算 $ f(n) $ 的公式为：\n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n需要使用高精度。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"poj-1737","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc3i00b57gxlijbblc93"},{"title":"OS X 日常必备软件","date":"2016-03-13T15:00:14.000Z","_content":"\n这些「必备软件」是我日常必备的，不一定适合每一个人，需要者自取。有一部分是跨平台的，在 GNU/Linux 或 Windows 下也可用。\n\n<!-- more -->\n\n## 系统类\n### Karabiner\nWebsite：[https://pqrs.org/osx/karabiner/](https://pqrs.org/osx/karabiner/)  \nGithub：[https://github.com/tekezo/Karabiner](https://github.com/tekezo/Karabiner)  \nHomebrew：`brew cask install karabiner`  \nLicense：Public Domain  \nPlatform：OS X\n\n![Karabiner](osx-softwares/karabiner.png)\n\n一个用来增强键盘的小工具，对黑苹果很有用，可以把键盘左上角的那个键「§」「±」映射为「`」「~」，还可以把 Home、End 键映射为到行首、行尾，满足之前在 Linux 上的使用习惯。\n\n### Virtualbox\nWebsite：[https://www.virtualbox.org/](https://www.virtualbox.org/)  \nHomebrew：`brew cask install virtualbox`  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux、Windows\n\n![Virtualbox](osx-softwares/virtualbox.png)\n\n一款跨平台虚拟机软件，体积比较小，平常用这个开着 Archlinux，需要的时候 SSH 连进去。感觉比 Parallels Desktop 好用一些，上手起来也比较容易吧。\n\n## 工具类\n### Flashlight\nWebsite：[http://flashlight.nateparrott.com/](http://flashlight.nateparrott.com/)  \nGithub：[https://github.com/nate-parrott/Flashlight](https://github.com/nate-parrott/Flashlight)  \nHomebrew：`brew cask install flashlight`  \nLicense：MIT && GNU GPL v2  \nPlatform：OS X\n\n![Flashlight 配置面板](osx-softwares/flashlight.png)\n\nSpotlight 的增强工具，有很多便捷的命令可以安装，在 OS X Yosemite 10.10.5 下需要手动配置 SIMBL 注入，比较麻烦，好像到了 El Captian 就用不了了 ……\n\n### ShadowSocksX\nGithub：[https://github.com/shadowsocks/shadowsocks-iOS](https://github.com/shadowsocks/shadowsocks-iOS)  \nHomebrew：`brew cask install shadowsocksx`  \nLicense：GNU GPL v3  \nPlatform：OS X\n\n![ShadowSocksX](osx-softwares/shadowsocksx.png)\n\nOS X 的图形界面 ShadowSocks 客户端，可以方便的配置、切换服务器。\n\n### File Roller\nWebsite：[http://fileroller.xx51.net/fileroller/index_zh_CN.html](http://fileroller.xx51.net/fileroller/index_zh_CN.html)  \nGithub：[https://github.com/wkt/file-roller-osx](https://github.com/wkt/file-roller-osx)  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux\n\n![File Roller](osx-softwares/fileroller.png)\n\nLinux 下 GNOME 的归档管理器，被人强行移植到 OS X 上来 …… 无奈 OS X 连个归档管理器都不自带 …… 原来是不资磁 Retina 的，强行开了 Retina 图标就这样了 …… 嗯，能用就行对吧，拖拽什么的还是资磁的。\n\n### Go2Shell\nWebsite：[http://zipzapmac.com/Go2Shell](http://zipzapmac.com/Go2Shell)  \nHomebrew：`brew cask install go2shell`  \nLicense：Free  \nPlatform：OS X\n\n![Go2Shell](osx-softwares/go2shell.png)\n\n一个按钮在 Finder 中打开命令行，而且图标 >_< 很萌！\n\n### TeamViewer\nWebsite：[http://www.teamviewer.com/](http://www.teamviewer.com/)  \nHomebrew：`brew cask install teamviewer`  \nLicense：Free  \nPlatform：OS X、GNU/Linux、Windows\n\n![TeamViewer](osx-softwares/teamviewer.png)\n\n最好用的远程控制软件没有之一。\n\n## 常用类\n### MacVim\nWebsite：[https://macvim-dev.github.io/macvim/](https://macvim-dev.github.io/macvim/)  \nGithub：[https://github.com/macvim-dev/macvim](https://github.com/macvim-dev/macvim)  \nHomebrew：`brew cask install macvim`  \nLicense：Vim License  \nPlatform：OS X\n\n![MacVim](osx-softwares/macvim.png)\n\nOS X 下的 Vim 图形界面，相对 GVim 的好处是背景可以透明、支持多标签页。\n\n### MacDown\nWebsite：[http://macdown.uranusjr.com/](http://macdown.uranusjr.com/)  \nGithub：[https://github.com/uranusjr/macdown](https://github.com/uranusjr/macdown)  \nHomebrew：`brew cask install macdown`  \nLicense：MIT  \nPlatform：OS X\n\n![MacDown](osx-softwares/macdown.png)\n\n一款 Markdown 编辑器，比那些在线的 Web App 好用，界面比较萌、比较简洁，兼容性也不错。\n\n### FeelUOwn\nGithub：[https://github.com/cosven/FeelUOwn](https://github.com/cosven/FeelUOwn)  \nLicense：GNU GPL v3  \nPlatform：OS X、GNU/Linux\n\n![FeelUOwn](osx-softwares/feeluown.png)\n\n网易云音乐客户端，比较轻量，能听歌但好像也只能听歌 ……\n\n### GIMP\nWebsite：[https://www.gimp.org/](https://www.gimp.org/)  \nGithub：[https://github.com/GNOME/gimp](https://github.com/GNOME/gimp)  \nHomebrew：`brew cask install gimp`  \nLicense：GNU GPL v3  \nPlatform：OS X、GNU/Linux、Windows\n\n![GIMP](osx-softwares/gimp.png)\n\n专业的图像处理软件，虽然我不那么专业，平常用来剪剪图搞搞模糊还是挺资磁的。只是 Gtk+ 的图形界面在 OS X 下表现不是很好，非原生界面感觉怪怪的 ……\n\n### LibreOffice\nWebsite：[https://www.libreoffice.org/](https://www.libreoffice.org/)  \nGithub：[https://github.com/LibreOffice](https://github.com/LibreOffice)  \nHomebrew：`brew cask install libreoffice`  \nLicense：Mozilla Public License v2.0  \nPlatform：OS X、GNU/Linux、Windows\n\n![LibreOffice Writer](osx-softwares/libreoffice-writer.png)\n\n文档处理软件，它的 Writer 和 Calc 比较好用，Impress 不如 PowerPoint 好用。一般除了做幻灯片之外不需要开 MS Office。\n\n### VLC\nWebsite：[http://www.videolan.org/vlc/](http://www.videolan.org/vlc/)  \nGithub：[https://github.com/videolan/vlc](https://github.com/videolan/vlc)  \nHomebrew：`brew cask install vlc`  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux、Windows\n\n![VLC](osx-softwares/vlc.png)\n\n用过最好用的视频播放器，基本上常见不常见的格式都能打开。\n","source":"_posts/osx-softwares.md","raw":"title: OS X 日常必备软件\ncategories: Geek\ntags:\n  - OS X\n  - 软件\npermalink: osx-softwares\ndate: 2016-03-13 23:00:14\n---\n\n这些「必备软件」是我日常必备的，不一定适合每一个人，需要者自取。有一部分是跨平台的，在 GNU/Linux 或 Windows 下也可用。\n\n<!-- more -->\n\n## 系统类\n### Karabiner\nWebsite：[https://pqrs.org/osx/karabiner/](https://pqrs.org/osx/karabiner/)  \nGithub：[https://github.com/tekezo/Karabiner](https://github.com/tekezo/Karabiner)  \nHomebrew：`brew cask install karabiner`  \nLicense：Public Domain  \nPlatform：OS X\n\n![Karabiner](osx-softwares/karabiner.png)\n\n一个用来增强键盘的小工具，对黑苹果很有用，可以把键盘左上角的那个键「§」「±」映射为「`」「~」，还可以把 Home、End 键映射为到行首、行尾，满足之前在 Linux 上的使用习惯。\n\n### Virtualbox\nWebsite：[https://www.virtualbox.org/](https://www.virtualbox.org/)  \nHomebrew：`brew cask install virtualbox`  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux、Windows\n\n![Virtualbox](osx-softwares/virtualbox.png)\n\n一款跨平台虚拟机软件，体积比较小，平常用这个开着 Archlinux，需要的时候 SSH 连进去。感觉比 Parallels Desktop 好用一些，上手起来也比较容易吧。\n\n## 工具类\n### Flashlight\nWebsite：[http://flashlight.nateparrott.com/](http://flashlight.nateparrott.com/)  \nGithub：[https://github.com/nate-parrott/Flashlight](https://github.com/nate-parrott/Flashlight)  \nHomebrew：`brew cask install flashlight`  \nLicense：MIT && GNU GPL v2  \nPlatform：OS X\n\n![Flashlight 配置面板](osx-softwares/flashlight.png)\n\nSpotlight 的增强工具，有很多便捷的命令可以安装，在 OS X Yosemite 10.10.5 下需要手动配置 SIMBL 注入，比较麻烦，好像到了 El Captian 就用不了了 ……\n\n### ShadowSocksX\nGithub：[https://github.com/shadowsocks/shadowsocks-iOS](https://github.com/shadowsocks/shadowsocks-iOS)  \nHomebrew：`brew cask install shadowsocksx`  \nLicense：GNU GPL v3  \nPlatform：OS X\n\n![ShadowSocksX](osx-softwares/shadowsocksx.png)\n\nOS X 的图形界面 ShadowSocks 客户端，可以方便的配置、切换服务器。\n\n### File Roller\nWebsite：[http://fileroller.xx51.net/fileroller/index_zh_CN.html](http://fileroller.xx51.net/fileroller/index_zh_CN.html)  \nGithub：[https://github.com/wkt/file-roller-osx](https://github.com/wkt/file-roller-osx)  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux\n\n![File Roller](osx-softwares/fileroller.png)\n\nLinux 下 GNOME 的归档管理器，被人强行移植到 OS X 上来 …… 无奈 OS X 连个归档管理器都不自带 …… 原来是不资磁 Retina 的，强行开了 Retina 图标就这样了 …… 嗯，能用就行对吧，拖拽什么的还是资磁的。\n\n### Go2Shell\nWebsite：[http://zipzapmac.com/Go2Shell](http://zipzapmac.com/Go2Shell)  \nHomebrew：`brew cask install go2shell`  \nLicense：Free  \nPlatform：OS X\n\n![Go2Shell](osx-softwares/go2shell.png)\n\n一个按钮在 Finder 中打开命令行，而且图标 >_< 很萌！\n\n### TeamViewer\nWebsite：[http://www.teamviewer.com/](http://www.teamviewer.com/)  \nHomebrew：`brew cask install teamviewer`  \nLicense：Free  \nPlatform：OS X、GNU/Linux、Windows\n\n![TeamViewer](osx-softwares/teamviewer.png)\n\n最好用的远程控制软件没有之一。\n\n## 常用类\n### MacVim\nWebsite：[https://macvim-dev.github.io/macvim/](https://macvim-dev.github.io/macvim/)  \nGithub：[https://github.com/macvim-dev/macvim](https://github.com/macvim-dev/macvim)  \nHomebrew：`brew cask install macvim`  \nLicense：Vim License  \nPlatform：OS X\n\n![MacVim](osx-softwares/macvim.png)\n\nOS X 下的 Vim 图形界面，相对 GVim 的好处是背景可以透明、支持多标签页。\n\n### MacDown\nWebsite：[http://macdown.uranusjr.com/](http://macdown.uranusjr.com/)  \nGithub：[https://github.com/uranusjr/macdown](https://github.com/uranusjr/macdown)  \nHomebrew：`brew cask install macdown`  \nLicense：MIT  \nPlatform：OS X\n\n![MacDown](osx-softwares/macdown.png)\n\n一款 Markdown 编辑器，比那些在线的 Web App 好用，界面比较萌、比较简洁，兼容性也不错。\n\n### FeelUOwn\nGithub：[https://github.com/cosven/FeelUOwn](https://github.com/cosven/FeelUOwn)  \nLicense：GNU GPL v3  \nPlatform：OS X、GNU/Linux\n\n![FeelUOwn](osx-softwares/feeluown.png)\n\n网易云音乐客户端，比较轻量，能听歌但好像也只能听歌 ……\n\n### GIMP\nWebsite：[https://www.gimp.org/](https://www.gimp.org/)  \nGithub：[https://github.com/GNOME/gimp](https://github.com/GNOME/gimp)  \nHomebrew：`brew cask install gimp`  \nLicense：GNU GPL v3  \nPlatform：OS X、GNU/Linux、Windows\n\n![GIMP](osx-softwares/gimp.png)\n\n专业的图像处理软件，虽然我不那么专业，平常用来剪剪图搞搞模糊还是挺资磁的。只是 Gtk+ 的图形界面在 OS X 下表现不是很好，非原生界面感觉怪怪的 ……\n\n### LibreOffice\nWebsite：[https://www.libreoffice.org/](https://www.libreoffice.org/)  \nGithub：[https://github.com/LibreOffice](https://github.com/LibreOffice)  \nHomebrew：`brew cask install libreoffice`  \nLicense：Mozilla Public License v2.0  \nPlatform：OS X、GNU/Linux、Windows\n\n![LibreOffice Writer](osx-softwares/libreoffice-writer.png)\n\n文档处理软件，它的 Writer 和 Calc 比较好用，Impress 不如 PowerPoint 好用。一般除了做幻灯片之外不需要开 MS Office。\n\n### VLC\nWebsite：[http://www.videolan.org/vlc/](http://www.videolan.org/vlc/)  \nGithub：[https://github.com/videolan/vlc](https://github.com/videolan/vlc)  \nHomebrew：`brew cask install vlc`  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux、Windows\n\n![VLC](osx-softwares/vlc.png)\n\n用过最好用的视频播放器，基本上常见不常见的格式都能打开。\n","slug":"osx-softwares","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc3n00bd7gxl8ns3jgyl"},{"title":"OS X 使用自定义分辨率开启 Retina（HiDPI）支持","date":"2016-03-16T02:50:45.000Z","_content":"\n有些电脑的显示器虽然是『高分辨率』，但像素的细腻程度仍然不及 Apple 的 Retina 显示器（用四个实际像素点渲染一个逻辑像素点）。比如我的显示器在 Ubuntu 下设置缩放 1.25 倍得到的体验最佳，但在黑苹果 OS X 系统中是不能开启非两倍的 HiDPI 的，一个解决方案是以较高的分辨率开启两倍 HiDPI，再让渲染时缩放回显示器的实际分辨率。\n\n需要注意的是，这种解决方案并不完美 —— 这样会使字体失去一部分次像素渲染效果，不支持 Retina 的应用程序显示效果极差，并且图形性能有较大损失。\n\n<!-- more -->\n\n### 需要的工具\n* Xcode 或其他 plist 编辑器\n\n有人说需要 IORegExplorer、SwitchResX，其实都是在找麻烦 ……\n\n### 获取硬件信息\n获取显示器的 `DisplayVendorID`、`DisplayProductID`、`IODisplayEDID` 和 `IODisplayPrefsKey`：\n\n```bash\nioreg -l | grep DisplayVendorID\n#     | |   | |         \"DisplayVendorID\" = 1711\nioreg -l | grep DisplayProductID\n#    | |   | |         \"DisplayProductID\" = 4413\nioreg -l | grep IODisplayEDID\n#    | |   | |         \"IODisplayEDID\" = <00ffffffffffff0006af3d110000000003170104951f11780287e5a456509e260d505400000001010101010101010101010101010101143780b87038244010103e0035ad100000180000000f0000000000000000000000000020000000fe0041554f0a202020202020202020000000fe004231343048414e30312e31200a00a1>\nioreg -l | grep IODisplayPrefsKey\n#    | |   | |         \"IODisplayPrefsKey\" = \"IOService:/AppleACPIPlatformExpert/PCI0@0/AppleACPIPCI/GFX0@2/AppleIntelFramebuffer@0/display0/AppleDisplay-6af-113d\"\n```\n\n记下这些数据，待会用得到。\n\n### 创建配置文件\n我的 `IODisplayPrefsKey` 最后一段是：\n\n```plain\nAppleDisplay-6af-113d\n```\n\n创建配置文件夹及文件：\n\n```bash\nmkdir DisplayVendorID-6af\nnano DisplayVendorID-6af/DisplayProductID-113d.plist\n```\n\n把其中的 `6af` 和 `113d` 替换为你的 `IODisplayPrefsKey` 中的数字，并在 `nano` 中粘贴以下内容（我的模板）：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>DisplayProductName</key>\n\t<string>Menci&apos;s Display &gt;_&lt;</string>\n\t<key>DisplayProductID</key>\n\t<integer>26609</integer>\n\t<key>DisplayVendorID</key>\n\t<integer>14499</integer>\n\t<key>IODisplayEDID</key>\n\t<data>AP///////wAGrz0RAAAAAAMXAQSVHxF4AoflpFZQniYNUFQAAAABAQEBAQEBAQEBAQEBAQEBFDeAuHA4JEAQED4ANa0QAAAYAAAADwAAAAAAAAAAAAAAAAAgAAAA/gBBVU8KICAgICAgICAgAAAA/gBCMTQwSEFOMDEuMSAKAKE=</data>\n\t<key>scale-resolutions</key>\n\t<array>\n\t\t<data>AAAKAAAABaAAAAAB</data>\n\t\t<data>AAAFVgAAAwAAAAAB</data>\n\t\t<data>AAAKrAAABgAAAAAB</data>\n\t</array>\n</dict>\n</plist>\n```\n\n`Control + O` 回车保存，`Control + X` 退出。\n\n### 编辑配置文件\n用 plist 编辑器打开 `DisplayProductID-XXXX.plist` 文件：\n\n![plist 编辑](/Users/Menci/Hexo/source/_posts/osx-enable-retina/plist-edit.png)\n\n把 `DisplayVendorID`、`DisplayProductID`、`IODisplayEDID` 修改为第一步记下的值，`DisplayProductName` 可以随意修改。\n\n展开 `scale-resolutions`，这里面就是我们的自定义分辨率，格式如下（所有数字均为十六进制）：\n\n```plain\n<横向分辨率 纵向分辨率 1>\n```\n\n比如我要添加一个 `1366 × 768 (HiDPI)` 选项，则要先乘以二，得到 `2732 × 1536`，然后转换为十六进制（可以用系统自带的 `Calculator.app`）填入，即：\n\n```plain\n<00000aac 00000600 00000001>\n```\n\n填好后保存退出。\n\n### 应用配置文件\n将配置文件复制到系统目录下，并去掉 `.plist` 后缀：\n\n```bash\ncd DisplayVendorID-6af\nmv DisplayProductID-113d.plist DisplayProductID-113d\nsudo cp -r . /System/Library/Displays/Overrides/\n```\n\n开启系统分辨率缩放支持：\n\n```bash\nsudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES;\n```\n\n重启后在显示器设置中选择『缩放』，就可以看到自定义的分辨率了。\n","source":"_posts/osx-enable-retina.md","raw":"title: OS X 使用自定义分辨率开启 Retina（HiDPI）支持\ncategories: Geek\ntags:\n  - OS X\n  - HiDPI\npermalink: osx-enable-retina\ndate: 2016-03-16 10:50:45\n---\n\n有些电脑的显示器虽然是『高分辨率』，但像素的细腻程度仍然不及 Apple 的 Retina 显示器（用四个实际像素点渲染一个逻辑像素点）。比如我的显示器在 Ubuntu 下设置缩放 1.25 倍得到的体验最佳，但在黑苹果 OS X 系统中是不能开启非两倍的 HiDPI 的，一个解决方案是以较高的分辨率开启两倍 HiDPI，再让渲染时缩放回显示器的实际分辨率。\n\n需要注意的是，这种解决方案并不完美 —— 这样会使字体失去一部分次像素渲染效果，不支持 Retina 的应用程序显示效果极差，并且图形性能有较大损失。\n\n<!-- more -->\n\n### 需要的工具\n* Xcode 或其他 plist 编辑器\n\n有人说需要 IORegExplorer、SwitchResX，其实都是在找麻烦 ……\n\n### 获取硬件信息\n获取显示器的 `DisplayVendorID`、`DisplayProductID`、`IODisplayEDID` 和 `IODisplayPrefsKey`：\n\n```bash\nioreg -l | grep DisplayVendorID\n#     | |   | |         \"DisplayVendorID\" = 1711\nioreg -l | grep DisplayProductID\n#    | |   | |         \"DisplayProductID\" = 4413\nioreg -l | grep IODisplayEDID\n#    | |   | |         \"IODisplayEDID\" = <00ffffffffffff0006af3d110000000003170104951f11780287e5a456509e260d505400000001010101010101010101010101010101143780b87038244010103e0035ad100000180000000f0000000000000000000000000020000000fe0041554f0a202020202020202020000000fe004231343048414e30312e31200a00a1>\nioreg -l | grep IODisplayPrefsKey\n#    | |   | |         \"IODisplayPrefsKey\" = \"IOService:/AppleACPIPlatformExpert/PCI0@0/AppleACPIPCI/GFX0@2/AppleIntelFramebuffer@0/display0/AppleDisplay-6af-113d\"\n```\n\n记下这些数据，待会用得到。\n\n### 创建配置文件\n我的 `IODisplayPrefsKey` 最后一段是：\n\n```plain\nAppleDisplay-6af-113d\n```\n\n创建配置文件夹及文件：\n\n```bash\nmkdir DisplayVendorID-6af\nnano DisplayVendorID-6af/DisplayProductID-113d.plist\n```\n\n把其中的 `6af` 和 `113d` 替换为你的 `IODisplayPrefsKey` 中的数字，并在 `nano` 中粘贴以下内容（我的模板）：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>DisplayProductName</key>\n\t<string>Menci&apos;s Display &gt;_&lt;</string>\n\t<key>DisplayProductID</key>\n\t<integer>26609</integer>\n\t<key>DisplayVendorID</key>\n\t<integer>14499</integer>\n\t<key>IODisplayEDID</key>\n\t<data>AP///////wAGrz0RAAAAAAMXAQSVHxF4AoflpFZQniYNUFQAAAABAQEBAQEBAQEBAQEBAQEBFDeAuHA4JEAQED4ANa0QAAAYAAAADwAAAAAAAAAAAAAAAAAgAAAA/gBBVU8KICAgICAgICAgAAAA/gBCMTQwSEFOMDEuMSAKAKE=</data>\n\t<key>scale-resolutions</key>\n\t<array>\n\t\t<data>AAAKAAAABaAAAAAB</data>\n\t\t<data>AAAFVgAAAwAAAAAB</data>\n\t\t<data>AAAKrAAABgAAAAAB</data>\n\t</array>\n</dict>\n</plist>\n```\n\n`Control + O` 回车保存，`Control + X` 退出。\n\n### 编辑配置文件\n用 plist 编辑器打开 `DisplayProductID-XXXX.plist` 文件：\n\n![plist 编辑](/Users/Menci/Hexo/source/_posts/osx-enable-retina/plist-edit.png)\n\n把 `DisplayVendorID`、`DisplayProductID`、`IODisplayEDID` 修改为第一步记下的值，`DisplayProductName` 可以随意修改。\n\n展开 `scale-resolutions`，这里面就是我们的自定义分辨率，格式如下（所有数字均为十六进制）：\n\n```plain\n<横向分辨率 纵向分辨率 1>\n```\n\n比如我要添加一个 `1366 × 768 (HiDPI)` 选项，则要先乘以二，得到 `2732 × 1536`，然后转换为十六进制（可以用系统自带的 `Calculator.app`）填入，即：\n\n```plain\n<00000aac 00000600 00000001>\n```\n\n填好后保存退出。\n\n### 应用配置文件\n将配置文件复制到系统目录下，并去掉 `.plist` 后缀：\n\n```bash\ncd DisplayVendorID-6af\nmv DisplayProductID-113d.plist DisplayProductID-113d\nsudo cp -r . /System/Library/Displays/Overrides/\n```\n\n开启系统分辨率缩放支持：\n\n```bash\nsudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES;\n```\n\n重启后在显示器设置中选择『缩放』，就可以看到自定义的分辨率了。\n","slug":"osx-enable-retina","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc4p00bi7gxla72agt47"},{"title":"数论学习笔记（一）","date":"2016-01-19T13:48:24.000Z","_content":"\n数论是 OI 中很重要的一部分，然而我基本上都不会，所以从现在开始我要学数论！\n\n<!-- more -->\n\n### 欧几里得\n算是 OI 中数论最基本的了吧，求两个数的最大公约数。\n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b ≠ 0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n顺便求两个数的最小公倍数。\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n写程序时先除后乘防炸。\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得 `exgcd` 可以在求出 $\\gcd(a,b)$ 的同时求出二元一次不定方程 $ax+by=\\gcd(a,b)$的一组整数解。\n\n举个栗子，求 $\\gcd(47,30)$ 时，得到以下式子。\n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n把余数移到左边\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n从 $\\gcd(47,30)=1$ 开始，将四个式子依次带入，得\n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n解得 $x=-7,y=11$。\n\n由上述式子可观察到，每次辗转交换了 `x` 和 `y`，并将 `y` 减去了原 `x` 与辗转相除所得商的乘积。\n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes 筛法\n在筛选之前，先认为每个数都是素数。枚举所有数，如果这个数是素数，那么筛掉这个数的所有倍数，标记它们为“不是素数”。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n两个优化：\n1. 第二层循环可以从 $i^2$ 开始，因为对于每个小于 $i$ 的数 $i'$，$i*i'$ 都已经在第 $i'$ 次循环筛掉了。\n2. 枚举 $[2,\\sqrt{n}]$ 的素数即可，因为对于每个合数 $p>\\sqrt{n}$，则必有素数 $k$ 满足 $p=k*k'$ 且 $k< \\sqrt{n}$，所以 $p$ 会在第 $k$ 次循环被筛掉。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### 欧拉函数\n根据唯一分解定理，任何一个正整数 $n$ 都可以写成 $k$ 个素数的幂的积的形式，其中第 $i$ 个素数的指数为 $a_i$。即：\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n根据容斥原理，从总数 $n$ 中先减去每个 $p_i$ 的倍数，再把多减的补回来，再把多补的减回来 …… 最终得到公式\n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n把求和和容斥原理的应用全部展开之后就是\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n程序实现就是先令结果为 $n$，每次把结果除掉一个 $p$ 再乘上 $p-1$。嗯，不是很好理解 ……\n\n对于给定的 $n$，用类似筛法的思想枚举素数，每次找到一个素数后把它的倍数全部筛掉。\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // 前面没筛干净的\n\treturn ans;\n}\n```\n\n未完待续 ……\n","source":"_posts/number-theory-notes-1.md","raw":"title: 数论学习笔记（一）\ncategories: OI\ntags: \n  - 数学\n  - 数论\n  - 学习笔记\n  - 算法模板  \npermalink: number-theory-notes-1\ndate: 2016-01-19 21:48:24\n---\n\n数论是 OI 中很重要的一部分，然而我基本上都不会，所以从现在开始我要学数论！\n\n<!-- more -->\n\n### 欧几里得\n算是 OI 中数论最基本的了吧，求两个数的最大公约数。\n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b ≠ 0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n顺便求两个数的最小公倍数。\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n写程序时先除后乘防炸。\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得 `exgcd` 可以在求出 $\\gcd(a,b)$ 的同时求出二元一次不定方程 $ax+by=\\gcd(a,b)$的一组整数解。\n\n举个栗子，求 $\\gcd(47,30)$ 时，得到以下式子。\n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n把余数移到左边\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n从 $\\gcd(47,30)=1$ 开始，将四个式子依次带入，得\n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n解得 $x=-7,y=11$。\n\n由上述式子可观察到，每次辗转交换了 `x` 和 `y`，并将 `y` 减去了原 `x` 与辗转相除所得商的乘积。\n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes 筛法\n在筛选之前，先认为每个数都是素数。枚举所有数，如果这个数是素数，那么筛掉这个数的所有倍数，标记它们为“不是素数”。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n两个优化：\n1. 第二层循环可以从 $i^2$ 开始，因为对于每个小于 $i$ 的数 $i'$，$i*i'$ 都已经在第 $i'$ 次循环筛掉了。\n2. 枚举 $[2,\\sqrt{n}]$ 的素数即可，因为对于每个合数 $p>\\sqrt{n}$，则必有素数 $k$ 满足 $p=k*k'$ 且 $k< \\sqrt{n}$，所以 $p$ 会在第 $k$ 次循环被筛掉。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### 欧拉函数\n根据唯一分解定理，任何一个正整数 $n$ 都可以写成 $k$ 个素数的幂的积的形式，其中第 $i$ 个素数的指数为 $a_i$。即：\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n根据容斥原理，从总数 $n$ 中先减去每个 $p_i$ 的倍数，再把多减的补回来，再把多补的减回来 …… 最终得到公式\n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n把求和和容斥原理的应用全部展开之后就是\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n程序实现就是先令结果为 $n$，每次把结果除掉一个 $p$ 再乘上 $p-1$。嗯，不是很好理解 ……\n\n对于给定的 $n$，用类似筛法的思想枚举素数，每次找到一个素数后把它的倍数全部筛掉。\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // 前面没筛干净的\n\treturn ans;\n}\n```\n\n未完待续 ……\n","slug":"number-theory-notes-1","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc4x00bn7gxlo5visj96"},{"title":"用 std::stack 实现非递归 DFS","date":"2016-04-08T06:30:21.000Z","_content":"\n众所周知，在有些省份（比如山东、河南），省选时使用 Windows 垃圾系统评测，而 Windows 下默认的系统栈非常小（只有 1M），这造成了有些 DFS 相关算法无法通过极端数据，而是发生『栈溢出』的错误。一种解决方法是使用非递归的 DFS。\n\n<!-- more -->\n\n### 框架\n我们通常这样实现递归 DFS：\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n第一次访问每个元素时，标记它为访问过，并对其进行初始化操作；枚举所有子元素，分为『未访问过』和『已访问过』分别进行处理。\n\n为了将这个过程转化为非递归，我们使用一个栈来存储 DFS 搜索树上的一条链。\n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan 强联通分量模板\n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### 树链剖分模板\n树链剖分的 DFS 过程比较特殊，我们可以每次将一个节点的所有子节点压入栈中，所有子树全部遍历完后回溯回来上传信息。\n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","source":"_posts/non-recursion-dfs-with-stack.md","raw":"title: 用 std::stack 实现非递归 DFS\ncategories: OI\ntags: \n  - STL\n  - DFS\n  - 算法模板\n  - Tarjan\n  - 强联通分量\n  - 树链剖分\npermalink: non-recursion-dfs-with-stack\ndate: 2016-04-08 14:30:21\n---\n\n众所周知，在有些省份（比如山东、河南），省选时使用 Windows 垃圾系统评测，而 Windows 下默认的系统栈非常小（只有 1M），这造成了有些 DFS 相关算法无法通过极端数据，而是发生『栈溢出』的错误。一种解决方法是使用非递归的 DFS。\n\n<!-- more -->\n\n### 框架\n我们通常这样实现递归 DFS：\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n第一次访问每个元素时，标记它为访问过，并对其进行初始化操作；枚举所有子元素，分为『未访问过』和『已访问过』分别进行处理。\n\n为了将这个过程转化为非递归，我们使用一个栈来存储 DFS 搜索树上的一条链。\n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan 强联通分量模板\n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### 树链剖分模板\n树链剖分的 DFS 过程比较特殊，我们可以每次将一个节点的所有子节点压入栈中，所有子树全部遍历完后回溯回来上传信息。\n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","slug":"non-recursion-dfs-with-stack","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc5000bt7gxl9opg9hci"},{"title":"「NOIP2012」同余方程 - 扩展欧几里得","date":"2016-01-19T13:20:19.000Z","_content":"\n求关于 `x` 同余方程 $ax ≡ 1 ({\\rm mod} \\ b)$的最小正整数解。 \n\n<!-- more -->\n\n### 链接\n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### 题解\n扩展欧几里得裸题，注意求最小正整数解，求出来 `x` 要模一次 `b`，然后加上 `b` 再模一次。\n\n### 代码\n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-mod.md","raw":"title: 「NOIP2012」同余方程 - 扩展欧几里得\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Tyvj\n  - 数论\n  - EXGCD\n  - 乘法逆元\npermalink: noip2012-mod\ndate: 2016-01-19 21:20:19\n---\n\n求关于 `x` 同余方程 $ax ≡ 1 ({\\rm mod} \\ b)$的最小正整数解。 \n\n<!-- more -->\n\n### 链接\n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### 题解\n扩展欧几里得裸题，注意求最小正整数解，求出来 `x` 要模一次 `b`，然后加上 `b` 再模一次。\n\n### 代码\n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","slug":"noip2012-mod","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc5600c27gxlrudhw41n"},{"title":"「NOIP2010」关押罪犯 - 二分图染色","id":"54","updated":"2016-02-19T08:06:06.000Z","date":"2016-02-19T08:00:26.000Z","_content":"\nS 城现有两座监狱，一共关押着 `N` 名罪犯，编号分别为 `1 ~ N`，我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。每年每一对有仇恨的罪犯会发生一次冲突。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力。那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小，求这个最小值是多少？\n\n<!-- more -->\n\n### 链接\n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[洛谷 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### 题解\n因为要求最小值，所以考虑二分答案。当我们二分一个答案 `x` 后，只需要考虑怒气值大于 `x` 的成对罪犯了，这时候对整张图进行二分图染色，如果能被染色成为二分图，则这个答案合法。\n\n二分图染色：把每个未标记的节点标记为任意一种颜色，对其进行一次 BFS，每一次扩展把未被染色的节点标记为与自身相反的颜色，如果发现扩展出去的节点的颜色与自身相同，则染色失败。\n\n时间复杂度为 $ O(n{log}n) $，理论上来说可以过 100% 的数据，然而 Tyvj 的评测机太烂竟然 TLE 了一个点。\n\n有神犇说可以用并查集，然而我太弱不会 …… qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-prison.md","raw":"title: 「NOIP2010」关押罪犯 - 二分图染色\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Vijos\n  - 洛谷\n  - 图论\n  - 二分答案\n  - 二分图染色\npermalink: noip2010-prison\nid: 54\nupdated: '2016-02-19 16:06:06'\ndate: 2016-02-19 16:00:26\n---\n\nS 城现有两座监狱，一共关押着 `N` 名罪犯，编号分别为 `1 ~ N`，我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。每年每一对有仇恨的罪犯会发生一次冲突。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力。那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小，求这个最小值是多少？\n\n<!-- more -->\n\n### 链接\n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[洛谷 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### 题解\n因为要求最小值，所以考虑二分答案。当我们二分一个答案 `x` 后，只需要考虑怒气值大于 `x` 的成对罪犯了，这时候对整张图进行二分图染色，如果能被染色成为二分图，则这个答案合法。\n\n二分图染色：把每个未标记的节点标记为任意一种颜色，对其进行一次 BFS，每一次扩展把未被染色的节点标记为与自身相反的颜色，如果发现扩展出去的节点的颜色与自身相同，则染色失败。\n\n时间复杂度为 $ O(n{log}n) $，理论上来说可以过 100% 的数据，然而 Tyvj 的评测机太烂竟然 TLE 了一个点。\n\n有神犇说可以用并查集，然而我太弱不会 …… qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","slug":"noip2010-prison","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc5b00cc7gxltax11l2n"},{"title":"「NOIP2006」能量项链 - 区间DP","id":"19","updated":"2016-01-19T13:04:41.000Z","date":"2016-01-12T21:19:28.000Z","_content":"\n在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为$m*r*n$（Mars单位），新产生的珠子的头标记为m，尾标记为n。\n需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### 题解\n首先，项链是一个环，枚举断点给它拆开。\n\n区间DP，用 $a[i]$ 表示第 `i` 颗珠子的头标记（即第 `i + 1` 颗珠子的尾标记），用 $f[i][j]$ 表示第 `i` 到第 `j` 颗珠子聚合成一颗后释放能量的最大值，枚举 `k`，自 `k` 处断开后，无论左右两段如何聚合，两段分别聚合成的两个珠子的标记值是不变的，即状态转移方程为：\n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n边界条件为：\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n注意代码编写时，访问最后一颗珠子的尾标记时，会越界，可以通过将下标对珠子总数取模的方法解决，因为最后一颗珠子的尾标记等于第一颗珠子的头标记。\n\n总时间复杂度为 $O(n^4)$，刚好解决 $n=100$ 的最大测试点 TvT。\n\n调试可费了大功夫，详见**注释掉的代码**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/noip2006-energy.md","raw":"title: 「NOIP2006」能量项链 - 区间DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - Tyvj\n  - 区间DP\npermalink: noip2006-energy\nid: 19\nupdated: '2016-01-19 21:04:41'\ndate: 2016-01-13 05:19:28\n---\n\n在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为$m*r*n$（Mars单位），新产生的珠子的头标记为m，尾标记为n。\n需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### 题解\n首先，项链是一个环，枚举断点给它拆开。\n\n区间DP，用 $a[i]$ 表示第 `i` 颗珠子的头标记（即第 `i + 1` 颗珠子的尾标记），用 $f[i][j]$ 表示第 `i` 到第 `j` 颗珠子聚合成一颗后释放能量的最大值，枚举 `k`，自 `k` 处断开后，无论左右两段如何聚合，两段分别聚合成的两个珠子的标记值是不变的，即状态转移方程为：\n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n边界条件为：\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n注意代码编写时，访问最后一颗珠子的尾标记时，会越界，可以通过将下标对珠子总数取模的方法解决，因为最后一颗珠子的尾标记等于第一颗珠子的头标记。\n\n总时间复杂度为 $O(n^4)$，刚好解决 $n=100$ 的最大测试点 TvT。\n\n调试可费了大功夫，详见**注释掉的代码**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"noip2006-energy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc5g00co7gxl9efaah6b"},{"title":"「NOIP2006」金明的预算方案 - 背包DP + 树形DP","id":"25","updated":"2016-01-19T13:02:58.000Z","date":"2016-01-16T22:11:03.000Z","_content":"\n金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的。\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[洛谷 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### 题解\n其实题挺水的，直接枚举选哪个附件就好，但学了树形 DP 就要写一写嘛。\n\n首先，我们有一个 01 背包的方程：\n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n对某个节点求解时，先对每一个子物品递归求解，然后进行一次 01 背包，得到一个由该物品及其附属物品组成的泛化物品组，然后一级一级地传到最顶层。\n\n设置一个价值与费用均为 `0` 的虚拟节点并将其作为所有无依赖的物品的父节点，求解 `0` 即为最终结果。\n\n更具体的讲解详见《背包九讲》。~~我太弱了讲不明白呢。~~\n\nPS：有个“坑”就是题目中的背包容量太大太大了，是妥妥的要 TLE 的（只能过前五个），但是因为背包容量和每件物品的体积都是 `10` 的倍数，所以读入数据后直接除以 `10` 就好。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```","source":"_posts/noip2006-budget.md","raw":"title: 「NOIP2006」金明的预算方案 - 背包DP + 树形DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - Vijos\n  - 树形DP\n  - 洛谷\n  - 背包DP\npermalink: noip2006-budget\nid: 25\nupdated: '2016-01-19 21:02:58'\ndate: 2016-01-17 06:11:03\n---\n\n金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的。\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[洛谷 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### 题解\n其实题挺水的，直接枚举选哪个附件就好，但学了树形 DP 就要写一写嘛。\n\n首先，我们有一个 01 背包的方程：\n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n对某个节点求解时，先对每一个子物品递归求解，然后进行一次 01 背包，得到一个由该物品及其附属物品组成的泛化物品组，然后一级一级地传到最顶层。\n\n设置一个价值与费用均为 `0` 的虚拟节点并将其作为所有无依赖的物品的父节点，求解 `0` 即为最终结果。\n\n更具体的讲解详见《背包九讲》。~~我太弱了讲不明白呢。~~\n\nPS：有个“坑”就是题目中的背包容量太大太大了，是妥妥的要 TLE 的（只能过前五个），但是因为背包容量和每件物品的体积都是 `10` 的倍数，所以读入数据后直接除以 `10` 就好。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```","slug":"noip2006-budget","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc5k00cv7gxldukxbeh1"},{"title":"「NOIP2003」数字游戏 - 划分DP","id":"20","updated":"2016-01-19T13:04:15.000Z","date":"2016-01-13T20:23:38.000Z","_content":"\n在你面前有一圈整数（一共 `n`（≤ 50）个），你要按顺序将其分为 `m`（≤ 9）个部分，各部分内的数字相加，相加所得的 `m` 个结果对 10 取模后再相乘，最终得到一个数 `k`。游戏的要求是使你所得的 `k` 最大或者最小。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[洛谷 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### 题解\n又是一道划分 DP，不过坑挺多的 …… 一是枚举断点，二是注意**负数对 `10` 取模后的结果是正数**。\n\n以最大值为例，以“分的部分”的数量划分阶段，用 $ f[i][j] $ 表示前 `i` 个数划分为 `j` 个部分所得的最大值，状态转移方程为：\n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n边界条件为：\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n求和可以用前缀和来维护，但是注意**枚举每个断点都必须重新初始化前缀和**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```","source":"_posts/noip2003-game.md","raw":"title: 「NOIP2003」数字游戏 - 划分DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - 划分DP\n  - 洛谷\n  - Tyvj\npermalink: noip2003-game\nid: 20\nupdated: '2016-01-19 21:04:15'\ndate: 2016-01-14 04:23:38\n---\n\n在你面前有一圈整数（一共 `n`（≤ 50）个），你要按顺序将其分为 `m`（≤ 9）个部分，各部分内的数字相加，相加所得的 `m` 个结果对 10 取模后再相乘，最终得到一个数 `k`。游戏的要求是使你所得的 `k` 最大或者最小。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[洛谷 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### 题解\n又是一道划分 DP，不过坑挺多的 …… 一是枚举断点，二是注意**负数对 `10` 取模后的结果是正数**。\n\n以最大值为例，以“分的部分”的数量划分阶段，用 $ f[i][j] $ 表示前 `i` 个数划分为 `j` 个部分所得的最大值，状态转移方程为：\n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n边界条件为：\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n求和可以用前缀和来维护，但是注意**枚举每个断点都必须重新初始化前缀和**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```","slug":"noip2003-game","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc5n00d47gxlxpxf1sqd"},{"title":"「NOIP2000」乘积最大 - 划分DP","id":"16","updated":"2016-01-19T13:05:38.000Z","date":"2016-01-08T21:10:45.000Z","_content":"\n在一个长度为 `N`（<= 400）的数字字符串中加上 `K`（<= 6）个乘号，使所得表达式值最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### 题解\n考虑划分 DP，以加入的乘号数量作为划分阶段，用 `f[n][k]` 表示原数字前 `n` 位中加入 `k` 个乘号所得表达式的最大值，预处理出 `a[i][j]` 表示原数字第 `i` 位到第 `j` 位组成的数字，则转移方程为：\n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n因为数据较水，所以使用 `long long` 即可，无需高精。\n\n### 代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```","source":"_posts/noip2000-cheng-ji-zui-da.md","raw":"title: 「NOIP2000」乘积最大 - 划分DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - 划分DP\npermalink: noip2000-cheng-ji-zui-da\nid: 16\nupdated: '2016-01-19 21:05:38'\ndate: 2016-01-09 05:10:45\n---\n\n在一个长度为 `N`（<= 400）的数字字符串中加上 `K`（<= 6）个乘号，使所得表达式值最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### 题解\n考虑划分 DP，以加入的乘号数量作为划分阶段，用 `f[n][k]` 表示原数字前 `n` 位中加入 `k` 个乘号所得表达式的最大值，预处理出 `a[i][j]` 表示原数字第 `i` 位到第 `j` 位组成的数字，则转移方程为：\n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n因为数据较水，所以使用 `long long` 即可，无需高精。\n\n### 代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```","slug":"noip2000-cheng-ji-zui-da","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc5r00dc7gxls3txrtmt"},{"title":"「NOI2015」程序自动分析 - 离散化 + 并查集","id":"34","updated":"2016-01-21T13:36:13.000Z","date":"2016-01-21T13:32:49.000Z","_content":"\n给定 `n` 个形如$x_i=x_j$或$x_i≠x_j$的变量相等 / 不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### 题解\n首先，`x` 的值很大，我们要把它离散化掉。\n\n然后用一个并查集，要离线做，先把相等的都并掉，然后枚举所有不相等的，如果某一对被并了说明不成立。\n\n一定不要用 `std::map`！！！可以自己写哈希表或者用 `std::tr1::unordered_map`。\n\n### 代码\n#### 手写哈希表\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n### 吐槽\n写这道题时共出了一下几条沙茶错误：\n\n1. 忘记离线；\n2. 并查集初始化太小；\n3. 内存池类模板参数填错；\n4. 多组数据忘记初始化；\n5. 用了很奇怪的哈希方法，TLE。\n","source":"_posts/noi2015-prog.md","raw":"title: 「NOI2015」程序自动分析 - 离散化 + 并查集\ncategories: OI\ntags: \n  - NOI\n  - 离散化\n  - 并查集\n  - 哈希\n  - map\npermalink: noi2015-prog\nid: 34\nupdated: '2016-01-21 21:36:13'\ndate: 2016-01-21 21:32:49\n---\n\n给定 `n` 个形如$x_i=x_j$或$x_i≠x_j$的变量相等 / 不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### 题解\n首先，`x` 的值很大，我们要把它离散化掉。\n\n然后用一个并查集，要离线做，先把相等的都并掉，然后枚举所有不相等的，如果某一对被并了说明不成立。\n\n一定不要用 `std::map`！！！可以自己写哈希表或者用 `std::tr1::unordered_map`。\n\n### 代码\n#### 手写哈希表\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n### 吐槽\n写这道题时共出了一下几条沙茶错误：\n\n1. 忘记离线；\n2. 并查集初始化太小；\n3. 内存池类模板参数填错；\n4. 多组数据忘记初始化；\n5. 用了很奇怪的哈希方法，TLE。\n","slug":"noi2015-prog","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc5v00di7gxlptmqzgmm"},{"title":"「NOI2015」软件包管理器 - 树链剖分","id":"35","updated":"2016-01-29T00:22:32.000Z","date":"2016-01-23T02:10:12.000Z","_content":"\n你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环，当然也不会有一个软件包依赖自己。用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### 题解\n首先，两种操作抽象为树上询问与修改：\n\n1. 询问某节点到根的一条链上有多少个节点打了标记；\n2. 将某节点到根的一条链上所有节点打上标记；\n3. 询问某节点的整棵子树上有多少个节点打了标记；\n4. 将某节点的整棵子树上所有节点打上标记。\n\n对于前两种，普通的树链剖分就可以了，但是对于后两种，我们还需要维护一个 DFS 序。DFS 序和轻重路径划分的维护看起来是有冲突的，实际上只要按照 DFS 的方式连接路径，并且在 DFS 时先遍历重链连接的子树，同时记录 DFS 序，这样得到的 DFS 序中，同一条路径是连续的，同一棵子树也是连续的。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2015-manager.md","raw":"title: 「NOI2015」软件包管理器 - 树链剖分\ncategories: OI\ntags: \n  - NOI\n  - CodeVS\n  - BZOJ\n  - 树链剖分\n  - 数据结构\n  - 高级数据结构\npermalink: noi2015-manager\nid: 35\nupdated: '2016-01-29 08:22:32'\ndate: 2016-01-23 10:10:12\n---\n\n你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环，当然也不会有一个软件包依赖自己。用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### 题解\n首先，两种操作抽象为树上询问与修改：\n\n1. 询问某节点到根的一条链上有多少个节点打了标记；\n2. 将某节点到根的一条链上所有节点打上标记；\n3. 询问某节点的整棵子树上有多少个节点打了标记；\n4. 将某节点的整棵子树上所有节点打上标记。\n\n对于前两种，普通的树链剖分就可以了，但是对于后两种，我们还需要维护一个 DFS 序。DFS 序和轻重路径划分的维护看起来是有冲突的，实际上只要按照 DFS 的方式连接路径，并且在 DFS 时先遍历重链连接的子树，同时记录 DFS 序，这样得到的 DFS 序中，同一条路径是连续的，同一棵子树也是连续的。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2015-manager","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc6000du7gxly53a1g0o"},{"title":"「NOI2014」起床困难综合征 - 位运算 + 贪心","date":"2016-04-03T14:39:31.000Z","_content":"\ndrd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $ n $ 扇防御门组成。每扇防御门包括一个运算 $ \\rm op $ 和一个参数 $ t $，其中运算一定是 $ \\rm OR $，$ \\rm XOR $，$ \\rm AND $ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $ x $，则其通过这扇防御门后攻击力将变为 $ x ~ {\\rm op} ~ t $。最终 drd 受到的伤害为对方初始攻击力 $ x $ 依次经过所有 $ n $ 扇防御门后转变得到的攻击力。\n由于 atm 水平有限，他的初始攻击力只能为 $ 0 $ 到 $ m $ 之间的一个整数（即他的初始攻击力只能在 $ 0 $，$ 1 $，$ … $，$ m $ 中任选，但在通过防御门之后的攻击力不受 $ m $ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### 题解\n贪心从高位到低位枚举，检验当前位在初始值为 $ 0 $ 情况下的答案是否可以为 $ 1 $，如果不能则检验当前位初始值能否为 $ 1 $，并检验当前位在初始值为 $ 1 $ 情况下的答案是否可以为 $ 1 $。\n\n注意要用 `unsigned int`，否则会变成负数。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-sleep.md","raw":"title: 「NOI2014」起床困难综合征 - 位运算 + 贪心\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - 位运算\n  - 贪心\npermalink: noi2014-sleep\ndate: 2016-04-03 22:39:31\n---\n\ndrd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 $ n $ 扇防御门组成。每扇防御门包括一个运算 $ \\rm op $ 和一个参数 $ t $，其中运算一定是 $ \\rm OR $，$ \\rm XOR $，$ \\rm AND $ 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 $ x $，则其通过这扇防御门后攻击力将变为 $ x ~ {\\rm op} ~ t $。最终 drd 受到的伤害为对方初始攻击力 $ x $ 依次经过所有 $ n $ 扇防御门后转变得到的攻击力。\n由于 atm 水平有限，他的初始攻击力只能为 $ 0 $ 到 $ m $ 之间的一个整数（即他的初始攻击力只能在 $ 0 $，$ 1 $，$ … $，$ m $ 中任选，但在通过防御门之后的攻击力不受 $ m $ 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### 题解\n贪心从高位到低位枚举，检验当前位在初始值为 $ 0 $ 情况下的答案是否可以为 $ 1 $，如果不能则检验当前位初始值能否为 $ 1 $，并检验当前位在初始值为 $ 1 $ 情况下的答案是否可以为 $ 1 $。\n\n注意要用 `unsigned int`，否则会变成负数。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-sleep","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc6b00e27gxlh9irpqcx"},{"title":"「NOI2006」最大获利 - 最大权闭合图","date":"2016-03-10T11:33:42.000Z","_content":"\n在前期市场调查和站址勘测之后，公司得到了一共 $ N $ 个可以作为通讯信号中转站的地址，建立第 $ i $ 个通讯中转站需要的成本为 $ Pi $（$ 1 ≤ i ≤ N $）。另外公司调查得出了所有期望中的用户群，一共 $ M $ 个。关于第 $ i $ 个用户群的信息概括为 $ Ai $, $ Bi $ 和 $ Ci $：这些用户会使用中转站 $ Ai $ 和中转站 $ Bi $ 进行通讯，公司可以获益 $ Ci $。（$ 1 ≤ i ≤ M $，$ 1 ≤ Ai $，$ Bi ≤ N $）公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？\n\n<!-- more -->\n\n### 链接\n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### 题解\n裸的最大权闭合图，用最小割。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2006-profit.md","raw":"title: 「NOI2006」最大获利 - 最大权闭合图\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - 图论\n  - 网络流\n  - 最小割\n  - 最大权闭合图\n  - Dinic\npermalink: noi2006-profit\ndate: 2016-03-10 19:33:42\n---\n\n在前期市场调查和站址勘测之后，公司得到了一共 $ N $ 个可以作为通讯信号中转站的地址，建立第 $ i $ 个通讯中转站需要的成本为 $ Pi $（$ 1 ≤ i ≤ N $）。另外公司调查得出了所有期望中的用户群，一共 $ M $ 个。关于第 $ i $ 个用户群的信息概括为 $ Ai $, $ Bi $ 和 $ Ci $：这些用户会使用中转站 $ Ai $ 和中转站 $ Bi $ 进行通讯，公司可以获益 $ Ci $。（$ 1 ≤ i ≤ M $，$ 1 ≤ Ai $，$ Bi ≤ N $）公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？\n\n<!-- more -->\n\n### 链接\n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### 题解\n裸的最大权闭合图，用最小割。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"noi2006-profit","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc6e00e87gxll1p2348l"},{"title":"「NOI2004」郁闷的出纳员 - Splay","id":"37","updated":"2016-01-24T15:11:06.000Z","date":"2016-01-24T15:09:03.000Z","_content":"\n工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，现在工资第 `k` 多的员工拿多少工资。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### 题解\n这是道 Splay 入门题，多思考思考还是挺容易的。\n\n唯一的难点貌似在同时修改工资，这时候只要像维护数列那样弄一个标记，然后向下传就好咯。扣工资时直接删掉 $[-{\\infty}+1,min-1]$ 范围内的节点就好。\n\n还有统计离开公司人数，一开始还在想删除时用了辅助节点，不知道该怎么算，一想才知道，直接看整棵树的大小变了多少嘛！\n\n第四次敲 Splay，在从临沂经西安到成都的飞机上用了一个小时。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","source":"_posts/noi2004-cashier.md","raw":"title: 「NOI2004」郁闷的出纳员 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - Splay\n  - 高级数据结构\n  - 数据结构\npermalink: noi2004-cashier\nid: 37\nupdated: '2016-01-24 23:11:06'\ndate: 2016-01-24 23:09:03\n---\n\n工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，现在工资第 `k` 多的员工拿多少工资。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### 题解\n这是道 Splay 入门题，多思考思考还是挺容易的。\n\n唯一的难点貌似在同时修改工资，这时候只要像维护数列那样弄一个标记，然后向下传就好咯。扣工资时直接删掉 $[-{\\infty}+1,min-1]$ 范围内的节点就好。\n\n还有统计离开公司人数，一开始还在想删除时用了辅助节点，不知道该怎么算，一想才知道，直接看整棵树的大小变了多少嘛！\n\n第四次敲 Splay，在从临沂经西安到成都的飞机上用了一个小时。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","slug":"noi2004-cashier","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc6j00ek7gxl3l09l5co"},{"title":"「NOI2003」文本编辑器 - Splay","date":"2016-03-06T11:49:35.000Z","_content":"\n|        操作名称        | 输入文件中的格式 | 功能 |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         | 将光标移动到第 $ k $ 个字符之后，如果 $ k=0 $，将光标移到文本第一个字符之前 |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     | 在光标后插入长度为 $ n $ 的字符串 $ s $，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       | 删除光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          | 输出光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | 光标前移一个字符\n| $ {\\rm NEXT}() $       | `Next`           | 光标后移一个字符\n\n<!-- more -->\n\n### 链接\n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### 题解\n块状链表太鬼畜辣！还是 Splay 比较好写好调w\n\n一点小技巧，插入的时候可以照着选择区间的方法选出一段空白区间，然后 `build` 出一棵子树给接上去，可以少一个 $ \\log $。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2003-editor.md","raw":"title: 「NOI2003」文本编辑器 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - Splay\n  - 高级数据结构\n  - 数据结构\npermalink: noi2003-editor\ndate: 2016-03-06 19:49:35\n---\n\n|        操作名称        | 输入文件中的格式 | 功能 |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         | 将光标移动到第 $ k $ 个字符之后，如果 $ k=0 $，将光标移到文本第一个字符之前 |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     | 在光标后插入长度为 $ n $ 的字符串 $ s $，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       | 删除光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          | 输出光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | 光标前移一个字符\n| $ {\\rm NEXT}() $       | `Next`           | 光标后移一个字符\n\n<!-- more -->\n\n### 链接\n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### 题解\n块状链表太鬼畜辣！还是 Splay 比较好写好调w\n\n一点小技巧，插入的时候可以照着选择区间的方法选出一段空白区间，然后 `build` 出一棵子树给接上去，可以少一个 $ \\log $。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2003-editor","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc6p00es7gxlvfiss8zu"},{"title":"「NOI2002」银河英雄传说 - 并查集","id":"2","updated":"2016-01-19T13:08:24.000Z","date":"2015-11-22T17:14:53.000Z","_content":"\n有 30000 个元素，初始时每个元素以单独的队列形式存在，支持一下两种操作：\n\n1.动态合并两条队列，将 `x` 元素所在队列首合并在 `y` 元素所在队列尾；  \n2.查询 `x` 与 `y` 是否在同一条队列中，若是，查询 `x` 与 `y` 间隔元素数量。\n\n共 500,000 次操作。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### 题解\n由「查询」操作，考虑到使用并查集。用并查集维护两个元素是否在同一队列中，可以对查询是否在同一队列中作出回答。  \n考虑将并查集扩展，维护每一个元素**所在队列**的队首和队尾。\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n然后就是查询间隔数量，这里采用前缀和的方式。\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)` 的计算方法，根据合并时对 `head` 数组进行的修改，可得 `find_head(x)` 的迭代次数即为 `x` 到 `x` 所在队队首的元素数量。\n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n使用这种方式维护并查集，不能对并查集使用路径压缩的优化，故整个算法时间复杂度为 $O(nm)$。  \n所以 …… Boom！  \n\n解决方法：在进行路径压缩的同时，维护每一个 `x` 到 `head[x]` 的「距离」 `prefix[x]`。  \n在 `find(x)` 或者 `pre(x)` 每一次迭代时，进行路径压缩，并把 `prefix[x]` 加上 `pre(head[x])`，即**队列中在 `x` 元素之前的元素的「前缀和」**。  \n\n注意：  \n 1.**当迭代到根节点下时，不能对 `prefix[x]` 做修改。**  \n 2.队首元素，即**满足 `head[x] == x` 的元素**的前缀和应总是0。  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn prefix[x];\n}\n```\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### 吐槽\n这是当年 NOI2002 的一道水（大雾）题。  \n刚开始学并查集的时候尝试做过这题，然后 …… 然后就没有然后了。  \n今天突然想起这题，就用了一个小时把它 A 掉了。","source":"_posts/noi2002-galaxy.md","raw":"title: 「NOI2002」银河英雄传说 - 并查集\ncategories: OI\ntags: \n  - CodeVS\n  - NOI\n  - 并查集\npermalink: noi2002-galaxy\nid: 2\nupdated: '2016-01-19 21:08:24'\ndate: 2015-11-23 01:14:53\n---\n\n有 30000 个元素，初始时每个元素以单独的队列形式存在，支持一下两种操作：\n\n1.动态合并两条队列，将 `x` 元素所在队列首合并在 `y` 元素所在队列尾；  \n2.查询 `x` 与 `y` 是否在同一条队列中，若是，查询 `x` 与 `y` 间隔元素数量。\n\n共 500,000 次操作。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### 题解\n由「查询」操作，考虑到使用并查集。用并查集维护两个元素是否在同一队列中，可以对查询是否在同一队列中作出回答。  \n考虑将并查集扩展，维护每一个元素**所在队列**的队首和队尾。\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n然后就是查询间隔数量，这里采用前缀和的方式。\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)` 的计算方法，根据合并时对 `head` 数组进行的修改，可得 `find_head(x)` 的迭代次数即为 `x` 到 `x` 所在队队首的元素数量。\n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n使用这种方式维护并查集，不能对并查集使用路径压缩的优化，故整个算法时间复杂度为 $O(nm)$。  \n所以 …… Boom！  \n\n解决方法：在进行路径压缩的同时，维护每一个 `x` 到 `head[x]` 的「距离」 `prefix[x]`。  \n在 `find(x)` 或者 `pre(x)` 每一次迭代时，进行路径压缩，并把 `prefix[x]` 加上 `pre(head[x])`，即**队列中在 `x` 元素之前的元素的「前缀和」**。  \n\n注意：  \n 1.**当迭代到根节点下时，不能对 `prefix[x]` 做修改。**  \n 2.队首元素，即**满足 `head[x] == x` 的元素**的前缀和应总是0。  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn prefix[x];\n}\n```\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### 吐槽\n这是当年 NOI2002 的一道水（大雾）题。  \n刚开始学并查集的时候尝试做过这题，然后 …… 然后就没有然后了。  \n今天突然想起这题，就用了一个小时把它 A 掉了。","slug":"noi2002-galaxy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc6v00ez7gxlgxuh8l20"},{"title":"乘法逆元的几种计算方法","date":"2016-04-13T04:11:17.000Z","_content":"\n乘法逆元是数论中重要的内容，也是 OI 中常用到的数论算法之一。所以，如何高效的求出乘法逆元是一个值得研究的问题。\n\n这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。\n\n<!-- more -->\n\n### 定义\n在 $ {\\rm mod} \\ p $ 的意义下我们把 $ x $ 的乘法逆元写作 $ x ^ {-1} $。  \n乘法逆元有如下的性质：\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n乘法逆元的一大应用是模意义下的除法，除法在模意义下并不是封闭的，但我们可以根据上述公式，将其转化为乘法。\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### 费马小定理\n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n要求 $ p $ 为素数。\n\n上述公式可变形为\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n由乘法逆元的定义，$ a ^ {p - 2} $ 即为 $ a $ 的乘法逆元。\n\n使用快速幂计算 $ a ^ {p - 2} $，总时间复杂度为 $ O(\\log a) $。\n\n#### 代码\n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得（EXGCD）算法可以在 $ O(\\log \\max(a, b)) $ 的时间内求出关于 $ x $、$ y $ 的方程\n\n\n$$ ax + by = \\gcd(a, b) $$\n\n的一组整数解\n\n当 $ b $ 为素数时，$ \\gcd(a, b) = 1 $，此时有\n\n$$ ax \\equiv 1 \\pmod b $$\n\n时间复杂度为 $ O(\\log a) $。\n\n#### 代码\n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### 递推法\n设 $ p = k \\times i + r $，（$ r < i $，$ 1 < i < p $），则有\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n两边同时乘上 $ r ^ {-1} + i ^ {-1} $，得\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n移项，得\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n即\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n我们可以利用这个式子进行递推，边界条件为 $ 1 ^ {-1} \\equiv 1 \\pmod p $，时间复杂度为 $ O(n) $。\n\n#### 代码\n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","source":"_posts/mul-inverse.md","raw":"title: 乘法逆元的几种计算方法\ncategories: OI\ntags: \n  - 数学\n  - 数论\n  - 学习笔记\n  - 算法模板\n  - 乘法逆元\npermalink: mul-inverse\ndate: 2016-04-13 12:11:17\n---\n\n乘法逆元是数论中重要的内容，也是 OI 中常用到的数论算法之一。所以，如何高效的求出乘法逆元是一个值得研究的问题。\n\n这里我们只讨论当模数为素数的情况，因为如果模数不为素数，则不一定每个数都有逆元。\n\n<!-- more -->\n\n### 定义\n在 $ {\\rm mod} \\ p $ 的意义下我们把 $ x $ 的乘法逆元写作 $ x ^ {-1} $。  \n乘法逆元有如下的性质：\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n乘法逆元的一大应用是模意义下的除法，除法在模意义下并不是封闭的，但我们可以根据上述公式，将其转化为乘法。\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### 费马小定理\n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n要求 $ p $ 为素数。\n\n上述公式可变形为\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n由乘法逆元的定义，$ a ^ {p - 2} $ 即为 $ a $ 的乘法逆元。\n\n使用快速幂计算 $ a ^ {p - 2} $，总时间复杂度为 $ O(\\log a) $。\n\n#### 代码\n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得（EXGCD）算法可以在 $ O(\\log \\max(a, b)) $ 的时间内求出关于 $ x $、$ y $ 的方程\n\n\n$$ ax + by = \\gcd(a, b) $$\n\n的一组整数解\n\n当 $ b $ 为素数时，$ \\gcd(a, b) = 1 $，此时有\n\n$$ ax \\equiv 1 \\pmod b $$\n\n时间复杂度为 $ O(\\log a) $。\n\n#### 代码\n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### 递推法\n设 $ p = k \\times i + r $，（$ r < i $，$ 1 < i < p $），则有\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n两边同时乘上 $ r ^ {-1} + i ^ {-1} $，得\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n移项，得\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n即\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n我们可以利用这个式子进行递推，边界条件为 $ 1 ^ {-1} \\equiv 1 \\pmod p $，时间复杂度为 $ O(n) $。\n\n#### 代码\n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","slug":"mul-inverse","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc6y00f47gxlq5i526pn"},{"title":"单调队列学习笔记","date":"2016-01-14T21:44:45.000Z","_content":"\n单调队列，就是单调的队列，通常用来解决滑动窗口的最值问题，可以应用到 DP 的优化上。一个单调队列中的元素总是单调递增（或递减）的。\n\n<!-- more -->\n\n### 滑动窗口\n例：有一个队列，每次从队尾加入一个元素，或从队首删除一个元素，并在任何时刻求整个队列的最大值。\n\n一个很直接的想法是使用优先队列 `priority_queue` 即堆，堆可以在 $O(1)$ 的时间内求出最大值，但每次加入或删除时需要 $O({\\log}n)$ 的时间完成堆的调整，但是用了堆后就不能按照进队的顺序出队了！这时候你可以大胆地写一个平衡树或者 `set`——如果你不怕多出来的 $\\log$ 和平衡树常数带来的 TLE 的话。\n\n单调队列就是解决这类问题的数据结构，我们用一个辅助队列，使该队列的首元素总是原队列的最大值，这样就可以 $O(1)$ 地求出队列的最大值了。\n\n### 维护单调队列\n现有需要维护最大值的队列 `Q`，和辅助队列 `M`，设计算法使任何时刻时 `M` 队首元素都是当前 `Q` 的最大值。\n\n每次在 `Q` 的队尾加入元素 `x` 时，也将其加入到 `M` 中，从 `M` 的队尾向前遍历，将遍历到的所有 **小于等 `x` 的元素**全部删除，因为它们在 `x` 之前被加入到队列中，在 `x` 出队前它们就已经都出队了，即**在 `x` 出队前这些元素不可能成为队列中的最大值**。\n\n每次在 `Q` 的队首删除元素时，将要删除的元素与 `M` 的队首元素比较，如果该元素与 `M` 队首元素相等，即**该元素为执行删除操作前队列的最大值**，则同时也要将 `M` 的队首元素删除，使原 `Q` 的次小值成为 `M` 的队首元素，保证 `M` 的队首元素是删除操作后 `Q` 中最大的元素。\n\n### 应用\n状态转移方程形如 $f[x]=\\max\\{g(k)\\}+w[x]$ 的动态规划可以使用单调队列来优化。\n\n### 实现\n因为同时要从队列的两端添加、删除，所以要使用 `deque` 实现，而不是 `queue`。\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","source":"_posts/monotone-queue-notes.md","raw":"title: 单调队列学习笔记\ncategories: OI\ntags: \n  - 单调队列\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\n  - 算法模板  \npermalink: monotone-queue-notes\ndate: 2016-01-15 05:44:45\n---\n\n单调队列，就是单调的队列，通常用来解决滑动窗口的最值问题，可以应用到 DP 的优化上。一个单调队列中的元素总是单调递增（或递减）的。\n\n<!-- more -->\n\n### 滑动窗口\n例：有一个队列，每次从队尾加入一个元素，或从队首删除一个元素，并在任何时刻求整个队列的最大值。\n\n一个很直接的想法是使用优先队列 `priority_queue` 即堆，堆可以在 $O(1)$ 的时间内求出最大值，但每次加入或删除时需要 $O({\\log}n)$ 的时间完成堆的调整，但是用了堆后就不能按照进队的顺序出队了！这时候你可以大胆地写一个平衡树或者 `set`——如果你不怕多出来的 $\\log$ 和平衡树常数带来的 TLE 的话。\n\n单调队列就是解决这类问题的数据结构，我们用一个辅助队列，使该队列的首元素总是原队列的最大值，这样就可以 $O(1)$ 地求出队列的最大值了。\n\n### 维护单调队列\n现有需要维护最大值的队列 `Q`，和辅助队列 `M`，设计算法使任何时刻时 `M` 队首元素都是当前 `Q` 的最大值。\n\n每次在 `Q` 的队尾加入元素 `x` 时，也将其加入到 `M` 中，从 `M` 的队尾向前遍历，将遍历到的所有 **小于等 `x` 的元素**全部删除，因为它们在 `x` 之前被加入到队列中，在 `x` 出队前它们就已经都出队了，即**在 `x` 出队前这些元素不可能成为队列中的最大值**。\n\n每次在 `Q` 的队首删除元素时，将要删除的元素与 `M` 的队首元素比较，如果该元素与 `M` 队首元素相等，即**该元素为执行删除操作前队列的最大值**，则同时也要将 `M` 的队首元素删除，使原 `Q` 的次小值成为 `M` 的队首元素，保证 `M` 的队首元素是删除操作后 `Q` 中最大的元素。\n\n### 应用\n状态转移方程形如 $f[x]=\\max\\{g(k)\\}+w[x]$ 的动态规划可以使用单调队列来优化。\n\n### 实现\n因为同时要从队列的两端添加、删除，所以要使用 `deque` 实现，而不是 `queue`。\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","slug":"monotone-queue-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc7300fb7gxl7xogketu"},{"title":"莫队算法学习笔记","date":"2016-05-01T00:14:50.000Z","_content":"\n算法竞赛中有这样一类题目，给定一个序列 $ [1,\\ n] $，每次查询 $ [l,\\ r] $ 区间的信息。这类题目没有修改操作，只有查询，并且操作没有加密（允许离线），莫队算法就是针对这类题目的一个离线算法。\n\n<!-- more -->\n\n莫队算法的核心思想是，假如我们已经知道了 $ [l,\\ r] $ 的答案，又可以很方便地向 $ [l,\\ r + 1] $、$ [l,\\ r - 1] $、$ [l - 1,\\ r] $、$ [l + 1,\\ r] $ 扩展，就可以实现让答案在每个询问之间转移。假设每次扩展的时间为 $ O(1) $，又因为每次转移最多有 $ O(n) $ 次扩展，所以算法总时间复杂度为 $ O(n ^ 2) $，通常会超时。\n\n我们可以将区间分为 $ \\sqrt n $ 块，每块的大小为 $ \\sqrt n $，并且将询问以**左端点所在的块**为第一关键字、以**右端点**为第二关键字排序，之后再进行上述算法。\n\n排序后，只有第一关键字不同的询问之间才会产生块之间的转移，而又因为共有 $ O(\\sqrt n) $ 块，所以不同块之间的转移最多发生 $ O(\\sqrt n) $ 次，不同块之间转移的总次数为 $ O((\\sqrt n) ^ 2) = O(n) $。每一块的大小为 $ O(\\sqrt n) $，即每一块内最多有 $ O((\\sqrt n) ^ 2) = O(n) $ 个不同的区间。所以，每经过一个块，都要进行 $ O(n) $ 次转移，乘上总块数 $ O(\\sqrt n) $，即相同块内的转移的总次数为 $ O(n \\sqrt n) $。\n\n每次扩展的时间复杂度不同时，适当调整块的大小，可以降低使整个算法的时间复杂度。\n","source":"_posts/mo-algorithm-notes.md","raw":"title: 莫队算法学习笔记\ncategories: OI\ntags: \n  - 莫队\n  - 学习笔记\n  - 数据结构\npermalink: mo-algorithm-notes\ndate: 2016-05-01 08:14:50\n---\n\n算法竞赛中有这样一类题目，给定一个序列 $ [1,\\ n] $，每次查询 $ [l,\\ r] $ 区间的信息。这类题目没有修改操作，只有查询，并且操作没有加密（允许离线），莫队算法就是针对这类题目的一个离线算法。\n\n<!-- more -->\n\n莫队算法的核心思想是，假如我们已经知道了 $ [l,\\ r] $ 的答案，又可以很方便地向 $ [l,\\ r + 1] $、$ [l,\\ r - 1] $、$ [l - 1,\\ r] $、$ [l + 1,\\ r] $ 扩展，就可以实现让答案在每个询问之间转移。假设每次扩展的时间为 $ O(1) $，又因为每次转移最多有 $ O(n) $ 次扩展，所以算法总时间复杂度为 $ O(n ^ 2) $，通常会超时。\n\n我们可以将区间分为 $ \\sqrt n $ 块，每块的大小为 $ \\sqrt n $，并且将询问以**左端点所在的块**为第一关键字、以**右端点**为第二关键字排序，之后再进行上述算法。\n\n排序后，只有第一关键字不同的询问之间才会产生块之间的转移，而又因为共有 $ O(\\sqrt n) $ 块，所以不同块之间的转移最多发生 $ O(\\sqrt n) $ 次，不同块之间转移的总次数为 $ O((\\sqrt n) ^ 2) = O(n) $。每一块的大小为 $ O(\\sqrt n) $，即每一块内最多有 $ O((\\sqrt n) ^ 2) = O(n) $ 个不同的区间。所以，每经过一个块，都要进行 $ O(n) $ 次转移，乘上总块数 $ O(\\sqrt n) $，即相同块内的转移的总次数为 $ O(n \\sqrt n) $。\n\n每次扩展的时间复杂度不同时，适当调整块的大小，可以降低使整个算法的时间复杂度。\n","slug":"mo-algorithm-notes","published":1,"updated":"2016-05-01T00:15:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc7700fi7gxlrjns3ou0"},{"title":"最小生成树 && 次小生成树","date":"2016-01-01T22:08:50.000Z","_content":"\n最近回顾了一下图论中的最小生成树算法，又学习了神奇（个卵）的“次小生成树”的算法。\n\n总体来说，图论里面的东西还是挺灵活的嘛 ~\n\n<!-- more -->\n\n### 最小生成树\n\n#### Kruskal 算法\n对所有边进行排序，用**并查集**维护连通性，从小到大枚举边，判断当前边的起止点是否在同一连通块中，若不是，则加入这条边，否则放弃这条边。\n\n图结构需要以边集数组储存。\n\n时间复杂度为 $O(m{\\log}m)$（其中 `m` 为边数）。\n\n据说适用于稀疏图。\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim 算法\nPrim 算法相对于 Kruskal 算法而言有一定难度，它把所有的点分为两个集合：在最小生成树中和不在最小生成树中，每次找到一条连接两个集合的**权值最小**的边，将它添加到最小生成树中。\n\n对于 Prim 算法，可以考虑类似于 Dijkstra 单源最短路算法的堆优化，即设置一个优先队列，初始时将从源点（可任取）出发的边加进优先队列中，每次从优先队列中不断弹出权值最小的边，直至得到一条边连接两个集合，则将这条边添加到最小生成树中，然后将这条边的出点的所有出边加入优先队列中。\n\n图结构需要以邻接表储存。\n\n使用优先队列的时间复杂度为 $O(m{\\log}n)$（其中 `n` 为结点数，`m` 为边数）。  \n不使用任何优化的时间复杂度为 $O(n^2)$（其中 `n` 为结点数）。\n\n据说适用于稠密图。\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### 次小生成树\n一个图的次小生成树，是指**异于该图的最小生成树**的**边权和最小**的生成树。\n\n注意，这里的次小生成树是**非严格**次小，即可能存在一个图，其最小生成树与次小生成树的边权和相等。\n\n#### 算法\n不难得出，次小生成树可以由最小生成树更换一条边得到。\n\n首先构造原图的最小生成树，然后枚举每一条**不在最小生成树中**的边 `(u, v, w)`，尝试将这条边加入生成树，因为直接加入边会产生环，所以我们需要在加边之前删去最小生成树上 `u` 到 `v` 的路径上**权值最大**的边。在枚举每一条边时我们都会得到一棵生成树，这些生成树中边权和最小的即为要求的次小生成树。\n\n需要在构造最小生成树时将完整的树结构构造出来，并且使用树上倍增算法查询两点间边权值最大的值。\n\n#### 代码（POJ 1679）\n链接：[POJ 1679](http://poj.org/problem?id=1679)\n\n题目要求判断最小生成树的唯一性。求出该图的非严格次小生成树，与最小生成树的权值和作比较即可。\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/minimum-spanning-tree-notes.md","raw":"title: '最小生成树 && 次小生成树'\ncategories: OI\ntags: \n  - Kruskal\n  - POJ\n  - Prim\n  - 倍增\n  - 图论\n  - 学习笔记\n  - 并查集\n  - 最小生成树\n  - 算法模板  \npermalink: minimum-spanning-tree-notes\ndate: 2016-01-02 06:08:50\n---\n\n最近回顾了一下图论中的最小生成树算法，又学习了神奇（个卵）的“次小生成树”的算法。\n\n总体来说，图论里面的东西还是挺灵活的嘛 ~\n\n<!-- more -->\n\n### 最小生成树\n\n#### Kruskal 算法\n对所有边进行排序，用**并查集**维护连通性，从小到大枚举边，判断当前边的起止点是否在同一连通块中，若不是，则加入这条边，否则放弃这条边。\n\n图结构需要以边集数组储存。\n\n时间复杂度为 $O(m{\\log}m)$（其中 `m` 为边数）。\n\n据说适用于稀疏图。\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim 算法\nPrim 算法相对于 Kruskal 算法而言有一定难度，它把所有的点分为两个集合：在最小生成树中和不在最小生成树中，每次找到一条连接两个集合的**权值最小**的边，将它添加到最小生成树中。\n\n对于 Prim 算法，可以考虑类似于 Dijkstra 单源最短路算法的堆优化，即设置一个优先队列，初始时将从源点（可任取）出发的边加进优先队列中，每次从优先队列中不断弹出权值最小的边，直至得到一条边连接两个集合，则将这条边添加到最小生成树中，然后将这条边的出点的所有出边加入优先队列中。\n\n图结构需要以邻接表储存。\n\n使用优先队列的时间复杂度为 $O(m{\\log}n)$（其中 `n` 为结点数，`m` 为边数）。  \n不使用任何优化的时间复杂度为 $O(n^2)$（其中 `n` 为结点数）。\n\n据说适用于稠密图。\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### 次小生成树\n一个图的次小生成树，是指**异于该图的最小生成树**的**边权和最小**的生成树。\n\n注意，这里的次小生成树是**非严格**次小，即可能存在一个图，其最小生成树与次小生成树的边权和相等。\n\n#### 算法\n不难得出，次小生成树可以由最小生成树更换一条边得到。\n\n首先构造原图的最小生成树，然后枚举每一条**不在最小生成树中**的边 `(u, v, w)`，尝试将这条边加入生成树，因为直接加入边会产生环，所以我们需要在加边之前删去最小生成树上 `u` 到 `v` 的路径上**权值最大**的边。在枚举每一条边时我们都会得到一棵生成树，这些生成树中边权和最小的即为要求的次小生成树。\n\n需要在构造最小生成树时将完整的树结构构造出来，并且使用树上倍增算法查询两点间边权值最大的值。\n\n#### 代码（POJ 1679）\n链接：[POJ 1679](http://poj.org/problem?id=1679)\n\n题目要求判断最小生成树的唯一性。求出该图的非严格次小生成树，与最小生成树的权值和作比较即可。\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"minimum-spanning-tree-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc7b00fo7gxlh8z62fyr"},{"title":"自动将 LaTex 代码转义为 Markdown 格式的小程序","id":"39","updated":"2016-01-27T05:28:28.000Z","date":"2016-01-24T15:43:18.000Z","_content":"\n### 项目地址\nhttps://github.com/Menci/markdown-latex-helper\n\n### 功能\n写文章时经常用 LaTex 来写公式，因为这样可以通过 MathJax 来方便地渲染。\n\n但是 LaTex 代码中的一些符号（如 `*` 和 `~`）会与 Markdown 语法冲突。于是，就有了这个小程序，它可以自动把文档中的 LaTex 代码转义为 Markdown 的格式。\n\n<!-- more -->\n\n使用前\n```latex\n\\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} * {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}}\n```\n\n使用后\n```latex\n\\\\phi\\(n\\)=\\{\\\\sum\\_\\{S\\{\\\\subseteq\\}\\\\\\{p\\_1\\,p\\_2\\,\\\\ldots\\,p\\_k\\\\\\}\\}\\{\\(\\-1\\)^\\{|S|\\}\\} \\*  \\{\\\\frac\\{n\\}\\{ \\{\\\\prod\\_\\{ \\{p\\_i\\}\\{\\\\in\\}S\\} \\} \\\\ p\\_i \\}\\}\\}\n```\n\n### 编译与使用\n```bash\n$ clang++ markdown-latex-helper.cpp -o markdown-latex-helper -std=c++11\n```\n\n`clang++` 可以换成你喜欢的编译器，注意 `-std=c++11` 不能省。\n\n```bash\n$ markdown-latex-helper < infile.md > outfile.md\n```\n\n使用的时候要通过命令行，暂时没有图形界面。","source":"_posts/markdown-latex-helper.md","raw":"title: 自动将 LaTex 代码转义为 Markdown 格式的小程序\ncategories: Geek\ntags: \n  - Markdown\n  - LaTex\n  - GitHub\npermalink: markdown-latex-helper\nid: 39\nupdated: '2016-01-27 13:28:28'\ndate: 2016-01-24 23:43:18\n---\n\n### 项目地址\nhttps://github.com/Menci/markdown-latex-helper\n\n### 功能\n写文章时经常用 LaTex 来写公式，因为这样可以通过 MathJax 来方便地渲染。\n\n但是 LaTex 代码中的一些符号（如 `*` 和 `~`）会与 Markdown 语法冲突。于是，就有了这个小程序，它可以自动把文档中的 LaTex 代码转义为 Markdown 的格式。\n\n<!-- more -->\n\n使用前\n```latex\n\\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} * {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}}\n```\n\n使用后\n```latex\n\\\\phi\\(n\\)=\\{\\\\sum\\_\\{S\\{\\\\subseteq\\}\\\\\\{p\\_1\\,p\\_2\\,\\\\ldots\\,p\\_k\\\\\\}\\}\\{\\(\\-1\\)^\\{|S|\\}\\} \\*  \\{\\\\frac\\{n\\}\\{ \\{\\\\prod\\_\\{ \\{p\\_i\\}\\{\\\\in\\}S\\} \\} \\\\ p\\_i \\}\\}\\}\n```\n\n### 编译与使用\n```bash\n$ clang++ markdown-latex-helper.cpp -o markdown-latex-helper -std=c++11\n```\n\n`clang++` 可以换成你喜欢的编译器，注意 `-std=c++11` 不能省。\n\n```bash\n$ markdown-latex-helper < infile.md > outfile.md\n```\n\n使用的时候要通过命令行，暂时没有图形界面。","slug":"markdown-latex-helper","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc7g00g17gxlxib44pzr"},{"title":"Link-Cut Tree 学习笔记","date":"2016-01-19T12:50:40.000Z","_content":"\nLink-Cut Tree 是一种用来维护动态森林连通性的数据结构，适用于动态树问题。它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 $O({\\log}n)$，但常数因子较大，一般效率会低于树链剖分。\n\n<!-- more -->\n\n### 定义\n一棵 Link-Cut Tree 上的边分为两种：实边和虚边。每一种边都是有向的，由子节点指向父节点。首尾相连的实边组成的不可延伸的链叫做路径。路径中**深度最大**的节点称为路径头部，**深度最小**的节点称为路径尾部。\n\n将每一条路径上的节点按照深度排序，得到一个序列，用 Splay 来维护这个序列。\n\n每一条链对应着一棵 Splay，每棵 Splay 的根节点有一个成员 `Path Parent`，表示该 Splay 维护的路径的尾部的节点的**父节点**，整棵树的根节点所对应的 Splay 节点的 `Path Parent` 为空；其他节点（不是其所在 Splay 的根节点的节点）的 `Path Parent` 也为空。\n\n`value` 用于维护点权，`sum` 和 `max` 是根据题目要求维护的链上的区间信息。`reversed` 表示以该节点为根的 Splay 有没有被翻转。\n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### 操作\nLink-Cut Tree 支持以下几种基本操作：\n\n1. `Access(u)`，“访问”某个节点 `u`，被“访问”过的节点会与根节点之间以路径相连，并且该节点为路径头部（最下端）；\n2. `Evert(u)`，将某个节点 `u` 置为其所在树的根节点，该操作等价于把该节点到根节点所经过的所有边方向取反；\n3. `Link(u, v)`，将某两个节点 `u` 和 `v` 连接，执行操作后 `u` 成为 `v` 的父节点；\n4. `Cut(u, v)`，将某两个节点 `u` 和 `v` 分离，执行操作后 `v` 及其子节点组成单独的一棵树；\n5. `FindRoot(u)`，查找某个节点 `u` 所在树的根节点；\n6. `MakeTree()`，向森林中种植一棵新的树。\n\n### `Access` 操作\n#### `Expose` 操作\n在实现 `Access` 操作前，我们先来实现 `Expose` 操作，它的作用是将当前节点置为其所在路径的头部节点，即切断自该节点向下的部分路径。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点有右孩子，那么断开其与其右孩子的连接。\n\n不要忘了各种标记的下放和值的维护。\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` 操作\n接下来，我们来实现 `Splice` 操作，它的作用是将**当前节点**所在的路径与**其尾部节点的父节点**所在的路径合并，即实现了路径的向上延长。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点没有 `Path Parent`，那么说明该节点所在路径中包含根节点，即 `Splice` 操作失败。\n3. 对该节点的 `Path Parent` 执行 `Expose` 操作，将其原有的路径断开；\n4. 将该节点连接到其 `Path Parent` 的右孩子上，并将 `Path Parent` 置为空。\n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` 操作\n有了 `Expose` 和 `Splice`，`Access` 就简单多了，`Expose` 后执行 `Splice` 直到失败即可。\n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` 操作\n首先执行 `Access`，将该节点与根节点之间用一条完整的路径连接，然后翻转这条路径即可。\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` 操作\n将节点 `v` 置为其所在树的根，然后将其 `Path Parent` 置为节点 `u` 即可。\n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` 操作\n`Cut` 操作稍微复杂一点：\n\n1. 将节点 `u` 置为其所在树的根节点，以保证 `v` 是 `u` 的子节点；\n2. 对 `v` 执行 `Access` 操作，将 `v` 与 `u` 之间用一条完整的路径连接；\n3. 对 `v` 执行 `Splay` 操作，将 `v` 置于**其所在 Splay 的根节点**；\n4. 将 `v` 与其左子树分离，即将路径断开。\n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query` 和 `Update` 操作\n以 `QueryMax(u, v)` 查询两个点之间的点权最大值为例。首先在 `Node` 结构体中存储 `max` 成员，并在 `Maintain()` 中维护它。\n\n首先，如果需要查询某个点到根节点之间的点权最大值，只需先访问这个节点，即 `Access(u)`，然后对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，此时 `u` 的 `max` 存储的值即为 `u` 到其所在树的根节点的路径上的点权最大值。\n\n如果要查询任意两点间的点权最大值，只需要先对其中一个节点执行 `Evert` 操作，将其置为树根，就可以转化为上述情况进行处理。\n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n要修改某个点的点权值，只需要对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，然后直接修改即可，这样可以避免修改时标记的向上传递。\n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` 操作\n直接新建节点就可以。\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n### 其他操作 & 注意事项\n1. 进行 `Splay` 和 `Rotate` 时，要注意标记的传递；\n2. `Rotate` 时，需要将自己的 `Path Parent` 与父节点的 `Path Parent` 互换，以保证 `Path Parent` 成员的有效值总在一棵 Splay 的根节点上。\n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### 完整代码（树的统计）\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/link-cut-tree-notes.md","raw":"title: Link-Cut Tree 学习笔记\ncategories: OI\ntags: \n  - Link-Cut Tree\n  - 动态树\n  - Splay\n  - 数据结构\n  - 高级数据结构\n  - 算法模板  \npermalink: link-cut-tree-notes\ndate: 2016-01-19 20:50:40\n---\n\nLink-Cut Tree 是一种用来维护动态森林连通性的数据结构，适用于动态树问题。它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 $O({\\log}n)$，但常数因子较大，一般效率会低于树链剖分。\n\n<!-- more -->\n\n### 定义\n一棵 Link-Cut Tree 上的边分为两种：实边和虚边。每一种边都是有向的，由子节点指向父节点。首尾相连的实边组成的不可延伸的链叫做路径。路径中**深度最大**的节点称为路径头部，**深度最小**的节点称为路径尾部。\n\n将每一条路径上的节点按照深度排序，得到一个序列，用 Splay 来维护这个序列。\n\n每一条链对应着一棵 Splay，每棵 Splay 的根节点有一个成员 `Path Parent`，表示该 Splay 维护的路径的尾部的节点的**父节点**，整棵树的根节点所对应的 Splay 节点的 `Path Parent` 为空；其他节点（不是其所在 Splay 的根节点的节点）的 `Path Parent` 也为空。\n\n`value` 用于维护点权，`sum` 和 `max` 是根据题目要求维护的链上的区间信息。`reversed` 表示以该节点为根的 Splay 有没有被翻转。\n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### 操作\nLink-Cut Tree 支持以下几种基本操作：\n\n1. `Access(u)`，“访问”某个节点 `u`，被“访问”过的节点会与根节点之间以路径相连，并且该节点为路径头部（最下端）；\n2. `Evert(u)`，将某个节点 `u` 置为其所在树的根节点，该操作等价于把该节点到根节点所经过的所有边方向取反；\n3. `Link(u, v)`，将某两个节点 `u` 和 `v` 连接，执行操作后 `u` 成为 `v` 的父节点；\n4. `Cut(u, v)`，将某两个节点 `u` 和 `v` 分离，执行操作后 `v` 及其子节点组成单独的一棵树；\n5. `FindRoot(u)`，查找某个节点 `u` 所在树的根节点；\n6. `MakeTree()`，向森林中种植一棵新的树。\n\n### `Access` 操作\n#### `Expose` 操作\n在实现 `Access` 操作前，我们先来实现 `Expose` 操作，它的作用是将当前节点置为其所在路径的头部节点，即切断自该节点向下的部分路径。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点有右孩子，那么断开其与其右孩子的连接。\n\n不要忘了各种标记的下放和值的维护。\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` 操作\n接下来，我们来实现 `Splice` 操作，它的作用是将**当前节点**所在的路径与**其尾部节点的父节点**所在的路径合并，即实现了路径的向上延长。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点没有 `Path Parent`，那么说明该节点所在路径中包含根节点，即 `Splice` 操作失败。\n3. 对该节点的 `Path Parent` 执行 `Expose` 操作，将其原有的路径断开；\n4. 将该节点连接到其 `Path Parent` 的右孩子上，并将 `Path Parent` 置为空。\n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` 操作\n有了 `Expose` 和 `Splice`，`Access` 就简单多了，`Expose` 后执行 `Splice` 直到失败即可。\n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` 操作\n首先执行 `Access`，将该节点与根节点之间用一条完整的路径连接，然后翻转这条路径即可。\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` 操作\n将节点 `v` 置为其所在树的根，然后将其 `Path Parent` 置为节点 `u` 即可。\n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` 操作\n`Cut` 操作稍微复杂一点：\n\n1. 将节点 `u` 置为其所在树的根节点，以保证 `v` 是 `u` 的子节点；\n2. 对 `v` 执行 `Access` 操作，将 `v` 与 `u` 之间用一条完整的路径连接；\n3. 对 `v` 执行 `Splay` 操作，将 `v` 置于**其所在 Splay 的根节点**；\n4. 将 `v` 与其左子树分离，即将路径断开。\n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query` 和 `Update` 操作\n以 `QueryMax(u, v)` 查询两个点之间的点权最大值为例。首先在 `Node` 结构体中存储 `max` 成员，并在 `Maintain()` 中维护它。\n\n首先，如果需要查询某个点到根节点之间的点权最大值，只需先访问这个节点，即 `Access(u)`，然后对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，此时 `u` 的 `max` 存储的值即为 `u` 到其所在树的根节点的路径上的点权最大值。\n\n如果要查询任意两点间的点权最大值，只需要先对其中一个节点执行 `Evert` 操作，将其置为树根，就可以转化为上述情况进行处理。\n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n要修改某个点的点权值，只需要对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，然后直接修改即可，这样可以避免修改时标记的向上传递。\n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` 操作\n直接新建节点就可以。\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n### 其他操作 & 注意事项\n1. 进行 `Splay` 和 `Rotate` 时，要注意标记的传递；\n2. `Rotate` 时，需要将自己的 `Path Parent` 与父节点的 `Path Parent` 互换，以保证 `Path Parent` 成员的有效值总在一棵 Splay 的根节点上。\n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### 完整代码（树的统计）\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"link-cut-tree-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc7l00g97gxl2alvczf5"},{"title":"KMP 学习笔记","date":"2015-12-29T20:19:36.000Z","_content":"\nKMP（Knuth-Morris-Pratt）是算法竞赛中常用的字符串匹配算法之一，它可以有效地利用失配信息来使得匹配全过程中不回溯，从而在线性时间内完成匹配。\n\n<!-- more -->\n\n### 原理\n设模式串 `pattern` 为 `\"utqqutnu\"`，目标串 `target` 为 `\"utqlwutqqutnu`\"，使用朴素算法进行匹配时（`\"-\"` 表示匹配成功，`\"|\"` 表示在此字符失配）：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n首先，将两串首部对齐，逐个字符匹配，可见在字符 `'l'` 处失配，按照朴素算法的思想，我们需要把模式串右移一个字符，然后再从模式串首部开始匹配，即：\n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n这时发现从第一个字符起就不匹配，还要继续右移 ……\n\n但是，似乎有一种更好的策略：我们可以直接把模式串的开头对齐目标串的 `\"ut\"` 处，就可以一次跳过几个字符，并且模式串无需回溯：\n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n而接下来这次失配后，本来需要将模式串与 `'t'` 对齐，但事实上并不需要，将模式串直接与 `'l'` 对齐即可。\n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP 算法就是利用了失配后的**部分匹配**信息来选择模式串的移动方式，尽可能地避免无用的匹配。\n\n### 失配信息de利用\n通过上述例子我们可以观察到，如果**部分匹配**的串有对称的**前后缀**，则我们可以直接将**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐，如：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n例子中的部分匹配串为 `\"utqqut\"`，有对称的前后缀 `\"ut\"`，则可以直接将目标串的第二个 `\"ut\"` 与模式串的第一个 `\"ut\"` 对齐。\n\n再来看这个例子，模式串为 `\"ttitty\"`，目标串为 `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n此时的部分匹配串为 `\"ttitt\"`，它有两个对称的前后缀，分别是 `\"tt\"` 和 `\"t\"`，我们会想，以 `\"t\"` 对齐，可以移动更长的距离，事实上呢？\n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n在模式串第二个 `'t'` 处失配后，继续匹配，最终结果是匹配失败。\n\n然而，如果我们以 `\"tt\"` 对齐，则有：\n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n结果是匹配成功。\n\n这个例子告诉我们，当部分匹配串有多个对称前后缀时，需要选择**最长的**，以保证匹配结果的正确。\n\n### 失配信息de推导\n事实上，KMP 算法利用的**失配信息**是与目标串无关的，它仅与模式串有关，我们可以用递推的方法在线性的时间内求出模式串的**每个可能的部分匹配串（即所有前缀）**前缀的失配信息。\n\n我们定义 `next` 数组是一个长度等于模式串长度的数组，它的第 `i` 个成员代表以模式串前 `i` 个字符作为部分匹配串时，部分匹配串的**最长对称前后缀**长度。\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nnext  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n推导 `next[i]` 的方法如下：\n\n1. 如果 `next[i - 1]` 不为 0，且第 `i` 个字符与第 `next[i - 1] +　１` 个字符相同，则 `next[i]` 即为 `next[i - 1] + 1`；\n2. 如果 `next[i - 1]` 为 0，且第 `i` 个字符与首个字符相同，则 `next[i] = 1`，否则 `next[i] = 0`；\n3. 难点：如果 `next[i - 1]` 不为 0，且第 `i` 个字符与第 `next[i - 1] +　１` 个字符**不同**，则继续对比第 `i` 个字符与 `next[next[i - 1] + 1]` 个字符，一直向前找直到匹配或者找到了 0。\n\n如模式串：*agct*agc**a**gct*agct*\n\n加粗的 `'a'` 与最后一个 `'t'` 不匹配，此时向前找找到 `\"agctagc\"` 的最后一个 `'c'` 的**对称位置的后一个字符**，发现是 `'t'`，则找到前后的 `\"agct\"` 是一个对称的前后缀。\n\n### 匹配de方法\n有了 `next` 数组，匹配就简单多了，只要根据以下三种情况对应处理即可：\n\n1. 如果当前字符匹配，则继续匹配下一个字符；\n2. 如果当前在**模式串的首字符处**不匹配，则直接将模式串右移一个字符；\n3. 否则移动模式串，使**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐。\n\n### 完整代码（CodeVS 1204）\n因为 C++ 中数组从 `0` 开始，所以有些地方与上文中的表示不同。\n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint next[MAXN] = { 0 };\n\n\tnext[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = next[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = next[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tnext[i] = k + 1;\n\t\t} else {\n\t\t\tnext[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << next[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n","source":"_posts/kmp-notes.md","raw":"title: KMP 学习笔记\ncategories: OI\ntags: \n  - CodeVS\n  - KMP\n  - 字符串\n  - 学习笔记\n  - 算法模板  \npermalink: kmp-notes\ndate: 2015-12-30 04:19:36\n---\n\nKMP（Knuth-Morris-Pratt）是算法竞赛中常用的字符串匹配算法之一，它可以有效地利用失配信息来使得匹配全过程中不回溯，从而在线性时间内完成匹配。\n\n<!-- more -->\n\n### 原理\n设模式串 `pattern` 为 `\"utqqutnu\"`，目标串 `target` 为 `\"utqlwutqqutnu`\"，使用朴素算法进行匹配时（`\"-\"` 表示匹配成功，`\"|\"` 表示在此字符失配）：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n首先，将两串首部对齐，逐个字符匹配，可见在字符 `'l'` 处失配，按照朴素算法的思想，我们需要把模式串右移一个字符，然后再从模式串首部开始匹配，即：\n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n这时发现从第一个字符起就不匹配，还要继续右移 ……\n\n但是，似乎有一种更好的策略：我们可以直接把模式串的开头对齐目标串的 `\"ut\"` 处，就可以一次跳过几个字符，并且模式串无需回溯：\n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n而接下来这次失配后，本来需要将模式串与 `'t'` 对齐，但事实上并不需要，将模式串直接与 `'l'` 对齐即可。\n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP 算法就是利用了失配后的**部分匹配**信息来选择模式串的移动方式，尽可能地避免无用的匹配。\n\n### 失配信息de利用\n通过上述例子我们可以观察到，如果**部分匹配**的串有对称的**前后缀**，则我们可以直接将**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐，如：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n例子中的部分匹配串为 `\"utqqut\"`，有对称的前后缀 `\"ut\"`，则可以直接将目标串的第二个 `\"ut\"` 与模式串的第一个 `\"ut\"` 对齐。\n\n再来看这个例子，模式串为 `\"ttitty\"`，目标串为 `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n此时的部分匹配串为 `\"ttitt\"`，它有两个对称的前后缀，分别是 `\"tt\"` 和 `\"t\"`，我们会想，以 `\"t\"` 对齐，可以移动更长的距离，事实上呢？\n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n在模式串第二个 `'t'` 处失配后，继续匹配，最终结果是匹配失败。\n\n然而，如果我们以 `\"tt\"` 对齐，则有：\n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n结果是匹配成功。\n\n这个例子告诉我们，当部分匹配串有多个对称前后缀时，需要选择**最长的**，以保证匹配结果的正确。\n\n### 失配信息de推导\n事实上，KMP 算法利用的**失配信息**是与目标串无关的，它仅与模式串有关，我们可以用递推的方法在线性的时间内求出模式串的**每个可能的部分匹配串（即所有前缀）**前缀的失配信息。\n\n我们定义 `next` 数组是一个长度等于模式串长度的数组，它的第 `i` 个成员代表以模式串前 `i` 个字符作为部分匹配串时，部分匹配串的**最长对称前后缀**长度。\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nnext  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n推导 `next[i]` 的方法如下：\n\n1. 如果 `next[i - 1]` 不为 0，且第 `i` 个字符与第 `next[i - 1] +　１` 个字符相同，则 `next[i]` 即为 `next[i - 1] + 1`；\n2. 如果 `next[i - 1]` 为 0，且第 `i` 个字符与首个字符相同，则 `next[i] = 1`，否则 `next[i] = 0`；\n3. 难点：如果 `next[i - 1]` 不为 0，且第 `i` 个字符与第 `next[i - 1] +　１` 个字符**不同**，则继续对比第 `i` 个字符与 `next[next[i - 1] + 1]` 个字符，一直向前找直到匹配或者找到了 0。\n\n如模式串：*agct*agc**a**gct*agct*\n\n加粗的 `'a'` 与最后一个 `'t'` 不匹配，此时向前找找到 `\"agctagc\"` 的最后一个 `'c'` 的**对称位置的后一个字符**，发现是 `'t'`，则找到前后的 `\"agct\"` 是一个对称的前后缀。\n\n### 匹配de方法\n有了 `next` 数组，匹配就简单多了，只要根据以下三种情况对应处理即可：\n\n1. 如果当前字符匹配，则继续匹配下一个字符；\n2. 如果当前在**模式串的首字符处**不匹配，则直接将模式串右移一个字符；\n3. 否则移动模式串，使**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐。\n\n### 完整代码（CodeVS 1204）\n因为 C++ 中数组从 `0` 开始，所以有些地方与上文中的表示不同。\n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint next[MAXN] = { 0 };\n\n\tnext[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = next[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = next[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tnext[i] = k + 1;\n\t\t} else {\n\t\t\tnext[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << next[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n","slug":"kmp-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc7p00gh7gxlh9qtvwxz"},{"title":"「JSOI2016」灯塔 - 分块 + RMQ","date":"2016-04-20T14:56:35.000Z","_content":"\nJSOI 的国境线上有 $ N $ 一座连续的山峰，其中第 $ i $ 座的高度是 $ h_i $。为了简单起见，我们认为这 $ N $ 座山峰排成了连续一条直线。\n\n如果在第 $ i $ 座山峰上建立一座高度为 $ p \\ (p \\geq 0) $ 的灯塔，JYY 发现，这座灯塔能够照亮第 $ j $ 座山峰，当且仅当满足如下不等式：\n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI 国王希望对于每一座山峰，JYY 都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度。你能帮助 JYY 么？\n\n<!-- more -->\n\n### 题解\n题目要求计算所有\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n打表可以发现 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 的取值有 $ O(\\sqrt{n}) $ 种，而对于每种取值，$ j $ 总是连续的最多两段区间。\n\n考虑每个 $ j $ 对 $ p_i $ 的影响，当 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 相同时，只有 $ h_j $ 最大的 $ j $ 会对 $ p_j $ 有影响。\n\n枚举 i，然后枚举 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 的值，问题转化为求一段区间内 $ h_j $ 的最大值，即 RMQ 问题，使用稀疏表即可解决。\n\n总时间复杂度为 $ O(n \\log n + n \\sqrt n) $，最大的数据要跑接近 3s ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-light.md","raw":"title: 「JSOI2016」灯塔 - 分块 + RMQ\ncategories: OI\ntags: \n  - JSOI\n  - 分块\n  - 乱搞\n  - RMQ\npermalink: jsoi2016-light\ndate: 2016-04-20 22:56:35\n---\n\nJSOI 的国境线上有 $ N $ 一座连续的山峰，其中第 $ i $ 座的高度是 $ h_i $。为了简单起见，我们认为这 $ N $ 座山峰排成了连续一条直线。\n\n如果在第 $ i $ 座山峰上建立一座高度为 $ p \\ (p \\geq 0) $ 的灯塔，JYY 发现，这座灯塔能够照亮第 $ j $ 座山峰，当且仅当满足如下不等式：\n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI 国王希望对于每一座山峰，JYY 都能提供建造一座能够照亮全部其他山峰的灯塔所需要的最小高度。你能帮助 JYY 么？\n\n<!-- more -->\n\n### 题解\n题目要求计算所有\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n打表可以发现 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 的取值有 $ O(\\sqrt{n}) $ 种，而对于每种取值，$ j $ 总是连续的最多两段区间。\n\n考虑每个 $ j $ 对 $ p_i $ 的影响，当 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 相同时，只有 $ h_j $ 最大的 $ j $ 会对 $ p_j $ 有影响。\n\n枚举 i，然后枚举 $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $ 的值，问题转化为求一段区间内 $ h_j $ 的最大值，即 RMQ 问题，使用稀疏表即可解决。\n\n总时间复杂度为 $ O(n \\log n + n \\sqrt n) $，最大的数据要跑接近 3s ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-light","published":1,"updated":"2016-04-30T13:37:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc7s00go7gxlqo6z2sav"},{"title":"「JSOI2016」飞机调度 - 最短路 + 网络流","date":"2016-04-23T16:41:33.000Z","_content":"\nJSOI 王国里有 $ N $ 个机场，编号为 $ 1 $ 到 $ N $。从 $ i $ 号机场到 $ j $ 号机场需要飞行 $ T_{i, j} $ 的时间。由于风向，地理位置和航空管制的因素，$ T_{i, j} $ 和 $ T_{j, i} $ 并不一定相同。\n\n此外，由于飞机降落之后需要例行维修和加油。当一架飞机降落 $ k $ 号机场时，需要花费 $ P_k $ 的维护时间才能再次起飞。\n\nJS Airways 一共运营 $ M $ 条航线，其中第 $ i $ 条直飞航线需要在 $ D_i $ 时刻从 $ X_i $ 机场起飞，不经停，飞往 $ Y_i $ 机场。\n\n为了简化问题，我们假设 JS Airway 可以在 $ 0 $ 时刻在任意机场布置任意多架加油维护完毕的飞机；为了减少飞机的使用数，我们允许 JS Airways 增开任意多条临时航线以满足飞机的调度需求。\n\nJYY 想知道，理论上 JS Airways 最少需要多少架飞机才能完成所有这 $ M $ 个航班。\n\n<!-- more -->\n\n### 题解\n根据题意，从 $ i $ 机场经过 $ k $ 机场飞往 $ j $ 机场（不计在 $ i $、$ j $ 的维护时间）所需时间为 $ T[i][k] + P[k] + T[k][j] $，所以我们可以先使用 Floyd 求出任意两个机场之间经过若干次中转可以到达的最短时间。\n\n考虑两条航线 $ A $ 和 $ B $，若一架飞机飞完 $ A $ 后可以接着飞 $ B $，则需要满足的条件为（二者之一）：\n\n1. $ A $ 的终点为 $ B $ 的起点，且 $ A $ 的着陆时间加上维护时间早于 $ B $ 的起飞时间；\n2. $ A $ 的着陆时间加上从 $ A $ 的终点经过若干次中转到 $ B $ 的起点所用时间加上若干次维护时间早于 $ B $ 的起飞时间。\n\n根据上述两个条件，可以建立一张有向无环图，$ A \\Rightarrow B $ 有边当且仅当一架飞机飞完 $ A $ 航线后可以接着飞 $ B $ 航线。即一架飞机连续飞的航线组成了图中的一条路径，题目中要求飞机数最少，即可转化为使用最少的路径覆盖整个图，转化为二分图匹配模型，使用网络流解决即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-flight.md","raw":"title: 「JSOI2016」飞机调度 - 最短路 + 网络流\ncategories: OI\ntags: \n  - JSOI\n  - 网络流\n  - Dinic\n  - 最短路\n  - Floyd\npermalink: jsoi2016-flight\ndate: 2016-04-24 00:41:33\n---\n\nJSOI 王国里有 $ N $ 个机场，编号为 $ 1 $ 到 $ N $。从 $ i $ 号机场到 $ j $ 号机场需要飞行 $ T_{i, j} $ 的时间。由于风向，地理位置和航空管制的因素，$ T_{i, j} $ 和 $ T_{j, i} $ 并不一定相同。\n\n此外，由于飞机降落之后需要例行维修和加油。当一架飞机降落 $ k $ 号机场时，需要花费 $ P_k $ 的维护时间才能再次起飞。\n\nJS Airways 一共运营 $ M $ 条航线，其中第 $ i $ 条直飞航线需要在 $ D_i $ 时刻从 $ X_i $ 机场起飞，不经停，飞往 $ Y_i $ 机场。\n\n为了简化问题，我们假设 JS Airway 可以在 $ 0 $ 时刻在任意机场布置任意多架加油维护完毕的飞机；为了减少飞机的使用数，我们允许 JS Airways 增开任意多条临时航线以满足飞机的调度需求。\n\nJYY 想知道，理论上 JS Airways 最少需要多少架飞机才能完成所有这 $ M $ 个航班。\n\n<!-- more -->\n\n### 题解\n根据题意，从 $ i $ 机场经过 $ k $ 机场飞往 $ j $ 机场（不计在 $ i $、$ j $ 的维护时间）所需时间为 $ T[i][k] + P[k] + T[k][j] $，所以我们可以先使用 Floyd 求出任意两个机场之间经过若干次中转可以到达的最短时间。\n\n考虑两条航线 $ A $ 和 $ B $，若一架飞机飞完 $ A $ 后可以接着飞 $ B $，则需要满足的条件为（二者之一）：\n\n1. $ A $ 的终点为 $ B $ 的起点，且 $ A $ 的着陆时间加上维护时间早于 $ B $ 的起飞时间；\n2. $ A $ 的着陆时间加上从 $ A $ 的终点经过若干次中转到 $ B $ 的起点所用时间加上若干次维护时间早于 $ B $ 的起飞时间。\n\n根据上述两个条件，可以建立一张有向无环图，$ A \\Rightarrow B $ 有边当且仅当一架飞机飞完 $ A $ 航线后可以接着飞 $ B $ 航线。即一架飞机连续飞的航线组成了图中的一条路径，题目中要求飞机数最少，即可转化为使用最少的路径覆盖整个图，转化为二分图匹配模型，使用网络流解决即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-flight","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc7w00gw7gxlu7kkccpn"},{"title":"「JSOI2009」游戏 - 博弈 + 二分图匹配","date":"2016-04-28T14:10:42.000Z","_content":"\n在 $ N \\times M $ 的迷宫中有一个棋子，AA 首先任意选择棋子放置的位置。然后，YY 和 AA 轮流将棋子移动到相邻的格子里。\n\n游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。\n\n求 AA 初始将棋子放在哪些格子会有必胜策略。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### 题解\n题目要求 AA 初始放置棋子的位置，使得 AA 有必胜策略，即为求必败态（因为 AA 是后手）。\n\n对网格图进行奇偶染色，建立二分图，求出有效格子的最大匹配。\n\n考虑将初始点放置在非匹配点上，如果此时没有任何边与其相连，则 YY 负，否则 YY 一定会沿着一条**非匹配**边走向另一个**匹配**点（如果这个点是非匹配点，则匹配这条边后，总匹配数可以增加，显然与最大匹配相矛盾），此时 AA 一定可以沿着一条匹配边走回来，状态恢复到初始状态，最终 YY 找不到一条非匹配边，负。\n\n我们得到结论：不在最大匹配上的点，一定是先手必败点。\n\n而如果一个点在最大匹配上，我们考虑这样一条路径，从该点开始沿着匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 走下去，如果这条路径的长度（边的数量）为偶数，则终点和起点在（二分图划分中的）同一集合中。此时将整个路径中每条边时候匹配取反，则整张图仍然是一个最大匹配。\n\n另一个结论：如果一个点**不一定**在最大匹配上，则它一定是先手必败点。\n\n使用 Dinic 算法求出二分图最大匹配后，在残量网络上进行 BFS，从源点开始，始终沿着**不满流**的边走，所有经过的且在左侧的点均**不一定在最大匹配上**，右边同理。\n\n考虑上述算法的正确性，从源点走向的第一个点一定是**非匹配点**，继续走一步，一定是沿着**非匹配边**会走到右侧点，再走一步，一定是沿着**匹配边的反向边**走回左侧。显然，每次走到左侧的点时，路径长度均为偶数，且沿着二分图中的匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 得证。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","source":"_posts/jsoi2009-game.md","raw":"title: 「JSOI2009」游戏 - 博弈 + 二分图匹配\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - 博弈\n  - 二分图匹配\n  - 网络流\n  - Dinic\npermalink: jsoi2009-game\ndate: 2016-04-28 22:10:42\n---\n\n在 $ N \\times M $ 的迷宫中有一个棋子，AA 首先任意选择棋子放置的位置。然后，YY 和 AA 轮流将棋子移动到相邻的格子里。\n\n游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。\n\n求 AA 初始将棋子放在哪些格子会有必胜策略。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### 题解\n题目要求 AA 初始放置棋子的位置，使得 AA 有必胜策略，即为求必败态（因为 AA 是后手）。\n\n对网格图进行奇偶染色，建立二分图，求出有效格子的最大匹配。\n\n考虑将初始点放置在非匹配点上，如果此时没有任何边与其相连，则 YY 负，否则 YY 一定会沿着一条**非匹配**边走向另一个**匹配**点（如果这个点是非匹配点，则匹配这条边后，总匹配数可以增加，显然与最大匹配相矛盾），此时 AA 一定可以沿着一条匹配边走回来，状态恢复到初始状态，最终 YY 找不到一条非匹配边，负。\n\n我们得到结论：不在最大匹配上的点，一定是先手必败点。\n\n而如果一个点在最大匹配上，我们考虑这样一条路径，从该点开始沿着匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 走下去，如果这条路径的长度（边的数量）为偶数，则终点和起点在（二分图划分中的）同一集合中。此时将整个路径中每条边时候匹配取反，则整张图仍然是一个最大匹配。\n\n另一个结论：如果一个点**不一定**在最大匹配上，则它一定是先手必败点。\n\n使用 Dinic 算法求出二分图最大匹配后，在残量网络上进行 BFS，从源点开始，始终沿着**不满流**的边走，所有经过的且在左侧的点均**不一定在最大匹配上**，右边同理。\n\n考虑上述算法的正确性，从源点走向的第一个点一定是**非匹配点**，继续走一步，一定是沿着**非匹配边**会走到右侧点，再走一步，一定是沿着**匹配边的反向边**走回左侧。显然，每次走到左侧的点时，路径长度均为偶数，且沿着二分图中的匹配边 - 非匹配边 - 匹配边 - 非匹配边 …… 得证。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","slug":"jsoi2009-game","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc8000h47gxlc5dhu6bz"},{"title":"「JSOI2008」最大数 - Splay","id":"56","updated":"2016-02-20T02:13:55.000Z","date":"2016-02-20T02:11:00.000Z","_content":"\n现在请求你维护一个数列，要求提供以下两种操作：\n\n1. 查询操作。  \n   语法：`Q L`  \n   功能：查询当前数列中末尾 `L` 个数中的最大的数，并输出这个数的值。  \n   限制：`L` 不超过当前数列的长度。\n2. 插入操作。\n   语法：`A n`  \n   功能：将 `n` 加上 `t`，其中 `t` 是最近一次查询操作的答案（如果还未执行过查询操作，则 `t = 0`)，并将所得结果对一个固定的常数 `D` 取模，将所得答案插入到数列的末尾。  \n   限制：`n` 是非负整数并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### 题解\nSplay 裸题不用说了吧 ……\n\n话说开一棵大线段树也资磁吧？\n\n敲个 Splay 练练代码能力，结果折腾了俩小时，这段时间代码能力急剧下降啊！qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-maxnumber.md","raw":"title: 「JSOI2008」最大数 - Splay\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - 数据结构\n  - 高级数据结构\npermalink: jsoi2008-maxnumber\nid: 56\nupdated: '2016-02-20 10:13:55'\ndate: 2016-02-20 10:11:00\n---\n\n现在请求你维护一个数列，要求提供以下两种操作：\n\n1. 查询操作。  \n   语法：`Q L`  \n   功能：查询当前数列中末尾 `L` 个数中的最大的数，并输出这个数的值。  \n   限制：`L` 不超过当前数列的长度。\n2. 插入操作。\n   语法：`A n`  \n   功能：将 `n` 加上 `t`，其中 `t` 是最近一次查询操作的答案（如果还未执行过查询操作，则 `t = 0`)，并将所得结果对一个固定的常数 `D` 取模，将所得答案插入到数列的末尾。  \n   限制：`n` 是非负整数并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### 题解\nSplay 裸题不用说了吧 ……\n\n话说开一棵大线段树也资磁吧？\n\n敲个 Splay 练练代码能力，结果折腾了俩小时，这段时间代码能力急剧下降啊！qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-maxnumber","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc8500hd7gxl98iox26o"},{"title":"「HNOI2016」树 - 最近公共祖先 + 主席树","date":"2016-05-11T09:28:00.000Z","_content":"\n小 A 想做一棵很大的树，但是他手上的材料有限，只好用点小技巧了。开始，小 A 只有一棵结点数为 $ N $ 的树，结点的编号为 $ 1,\\ 2,\\ \\dots,\\ N $，其中结点 $ 1 $ 为根；我们称这颗树为模板树。小 A 决定通过这棵模板树来构建一颗大树。构建过程如下：\n\n1. 将模板树复制为初始的大树；\n2. 以下 3，4，5 步循环执行 $ M $ 次；\n3. 选择两个数字 $ a,\\ b $，其中 $ 1 \\leq a \\leq N $，$ 1 \\leq b \\leq 当前大树的结点数 $；\n4. 将模板树中以结点 $ a $ 为根的子树复制一遍，挂到大树中结点 $ b $ 的下方（也就是说，模板树中的结点 $ a $ 为根的子树复制到大树中后，将成为大树中结点 $ b $ 的子树)；\n5. 将新加入大树的结点按照在模板树中编号的顺序重新编号。例如，假设在进行 4 步之前大树有 $ L $ 个结点，模板树中以 $ a $ 为根的子树共有 $ C $ 个结点，那么新加入模板树的 $ C $ 个结点在大树中的编号将是 $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $；大树中这 $ C $ 个结点编号的大小顺序和模板树中对应的 $ C $ 个结点的大小顺序是一致的。\n\n现在他想问你，树中一些结点对的距离是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### 题解\n在新树中用一个节点代表模板树中的一棵子树，存储每个节点在模板树中的根，其真实父节点在模板树中的节点，边设置为新节点到其新树中父节点的根节点的距离。对新树和模板树分别进行树链剖分。\n\n需要从编号求出在新树中的节点时，记录新树中每个节点代表的区间，进行二分查找。需要求出模板树中的节点时，先求出在区间内的编号，再做区间第 $ k $ 大查询，使用主席树即可。\n\n求距离时，分三种情况讨论：\n\n1. 两个点在新树中的统一节点内，直接在模板树中找最近公共租先；\n2. 两个点在新树中的节点的的最近公共租先为其中一个节点，分别求出多段距离相加减；\n3. 其他情况，比情况 2 复杂一些，方法类似。\n\n总时间复杂度为 $ O((m + q) \\log n) $，具体实现细节见代码。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-tree.md","raw":"title: 「HNOI2016」树 - 最近公共祖先 + 主席树\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - 树链剖分\n  - 主席树\n  - 最近公共祖先\npermalink: hnoi2016-tree\ndate: 2016-05-11 17:28:00\n---\n\n小 A 想做一棵很大的树，但是他手上的材料有限，只好用点小技巧了。开始，小 A 只有一棵结点数为 $ N $ 的树，结点的编号为 $ 1,\\ 2,\\ \\dots,\\ N $，其中结点 $ 1 $ 为根；我们称这颗树为模板树。小 A 决定通过这棵模板树来构建一颗大树。构建过程如下：\n\n1. 将模板树复制为初始的大树；\n2. 以下 3，4，5 步循环执行 $ M $ 次；\n3. 选择两个数字 $ a,\\ b $，其中 $ 1 \\leq a \\leq N $，$ 1 \\leq b \\leq 当前大树的结点数 $；\n4. 将模板树中以结点 $ a $ 为根的子树复制一遍，挂到大树中结点 $ b $ 的下方（也就是说，模板树中的结点 $ a $ 为根的子树复制到大树中后，将成为大树中结点 $ b $ 的子树)；\n5. 将新加入大树的结点按照在模板树中编号的顺序重新编号。例如，假设在进行 4 步之前大树有 $ L $ 个结点，模板树中以 $ a $ 为根的子树共有 $ C $ 个结点，那么新加入模板树的 $ C $ 个结点在大树中的编号将是 $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $；大树中这 $ C $ 个结点编号的大小顺序和模板树中对应的 $ C $ 个结点的大小顺序是一致的。\n\n现在他想问你，树中一些结点对的距离是多少。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### 题解\n在新树中用一个节点代表模板树中的一棵子树，存储每个节点在模板树中的根，其真实父节点在模板树中的节点，边设置为新节点到其新树中父节点的根节点的距离。对新树和模板树分别进行树链剖分。\n\n需要从编号求出在新树中的节点时，记录新树中每个节点代表的区间，进行二分查找。需要求出模板树中的节点时，先求出在区间内的编号，再做区间第 $ k $ 大查询，使用主席树即可。\n\n求距离时，分三种情况讨论：\n\n1. 两个点在新树中的统一节点内，直接在模板树中找最近公共租先；\n2. 两个点在新树中的节点的的最近公共租先为其中一个节点，分别求出多段距离相加减；\n3. 其他情况，比情况 2 复杂一些，方法类似。\n\n总时间复杂度为 $ O((m + q) \\log n) $，具体实现细节见代码。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-tree","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc8800hk7gxl1ky688fk"},{"title":"「HNOI2016」序列 - 莫队 + RMQ","date":"2016-04-30T13:23:18.000Z","_content":"\n给定长度为 $ n $ 的序列：$ a_1,\\ a_2,\\ \\dots,\\ a_n $，记为 $ a[1:n] $。类似的，$ a[l:r] $（$ 1 \\leq l \\leq r \\leq n $）是指序列：$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $。若 $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $，则称 $ a[s:t] $ 是 $ a[l:r] $ 的子序列。\n\n现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \\leq l \\leq r \\leq n $，求 $ a[l:r] $ 的不同子序列的最小值之和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### 题解\n[Sengxian 的题解](https://blog.sengxian.com/solutions/bzoj-4540)\n\n对于无修改的区间询问，我们可以将操作离线，采用莫队算法解决。\n\n为便于叙述，定义 $ [i] $ 为位置 $ i $ 处的元素（即 $ a_i $）；$ [ \\ [l,\\ r],\\ R \\ ] $ 为左端点属于 $ [l,\\ r] $，右端点为 $ R $ 的所有子序列。\n\n已知区间 $ [l,\\ r - 1] $ 的答案，考虑新加入的元素 $ [r] $ 对询问的影响。新元素加入后，产生了 $ r - l + 1 $ 个子序列，它们是 $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $。\n\n$ [l, r] $ 中存在一个最小值 $ [m] $，使得 $ [ \\ [l,\\ m],\\ r \\ ] $ 的最小值均为 $ [m] $，举个例子\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n区间 $ [ \\ [1,\\ 4],\\ 6 \\ ] $ 的最小值均为 $ [4] $，即 $ 1 $。\n\n考虑剩下的 $ r - m $ 个子序列，从 $ r $ 向左走，经过的所有比 $ [r] $ **大**的元素，以这些元素的位置为左端点，$ r $ 为右端点的所有子序列的最小值均为 $ [r] $。直到到达第一个比 $ [r] $ 小的元素（例子中的 $ [8] = 3 $），其位置记做 $ {\\rm left}(r) = p $。\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $ 右边有 $ r - p = 10 - 8 = 2 $ 个子序列，他们的最小值均为 $ [10] = 4 $，这些子序列对答案的贡献为 $ (r - p) \\times [r] $。\n\n仿照刚才的做法，继续向左找第一个小于 $ [p] = 3 $ 的元素，其值为 $ [6] = 2 $，即 $ {\\rm left}(p) = p' = 6 $。\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $ 右边有 $ p - p' = 8 - 6 = 2 $ 个子序列，他们的最小值均为 $ [8] = 3 $，这些子序列对答案的贡献为 $ (p - p') \\times [p] $。\n\n继续向左找，找到第一个比 $ p' $ 小的元素，其值为 $ 1 $，即 $ {\\rm left}(p') = m = 4 $，注意此时已经找到整个区间内的最小值，左端点在 $ m $ 及其左侧的所有子序列对答案的贡献已经被考虑过，恰好只剩下 $ p' - m = 6 - 4 = 2 $ 个子序列，其最小值均为 $ [p'] = 2 $，这些子序列对答案的贡献为 $ (p' - m) \\times [p'] $。\n\n若直接使用上述算法计算每个元素的贡献，单次计算的时间复杂度为 $ O(n) $，超时。\n\n定义 $ m = \\min[l,\\ r] $ 为区间 $ [l,\\ r] $ 的最小值所在的位置，设 $ f(l, r) $ 为区间 $ [l,\\ r] $ 内除最小值之外的其它值对答案的贡献，则有\n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n注意到整个式子除边界条件中的 $ m $ 之外，和 $ l $ 是无关的。\n\n设 $ s(i) $ 为从 $ i $ 位置一直向左跳，直到跳到所有元素中的最小值，用上述方法计算出的贡献总和，则有\n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n注意到刚才的例子中，$ {\\rm left}(p') = {\\rm left}(m + 1) = m $，即**最后一跳的位置**和**最小值的右边一个位置**向左跳跳到的位置相同。所以\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n使用单调栈算法（保持栈底到栈顶的元素单调递增）预处理出每个 $ {\\rm left}(i) $，之后可以在 $ O(n) $ 的时间内递推出 $ s(i) $。区间向左扩展时同理，向右边跳即可。\n\n而对于 RMQ，使用稀疏表在 $ O(n \\log n) $ 的时间内预处理后，即可在 $ O(1) $ 的时间内回答每次查询。最终，每次转移的时间降为 $ O(1) $，总时间复杂度为 $ O(q \\log q + n \\sqrt n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-sequence.md","raw":"title: 「HNOI2016」序列 - 莫队 + RMQ\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - 莫队\n  - RMQ\npermalink: hnoi2016-sequence\ndate: 2016-04-30 21:23:18\n---\n\n给定长度为 $ n $ 的序列：$ a_1,\\ a_2,\\ \\dots,\\ a_n $，记为 $ a[1:n] $。类似的，$ a[l:r] $（$ 1 \\leq l \\leq r \\leq n $）是指序列：$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $。若 $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $，则称 $ a[s:t] $ 是 $ a[l:r] $ 的子序列。\n\n现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \\leq l \\leq r \\leq n $，求 $ a[l:r] $ 的不同子序列的最小值之和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### 题解\n[Sengxian 的题解](https://blog.sengxian.com/solutions/bzoj-4540)\n\n对于无修改的区间询问，我们可以将操作离线，采用莫队算法解决。\n\n为便于叙述，定义 $ [i] $ 为位置 $ i $ 处的元素（即 $ a_i $）；$ [ \\ [l,\\ r],\\ R \\ ] $ 为左端点属于 $ [l,\\ r] $，右端点为 $ R $ 的所有子序列。\n\n已知区间 $ [l,\\ r - 1] $ 的答案，考虑新加入的元素 $ [r] $ 对询问的影响。新元素加入后，产生了 $ r - l + 1 $ 个子序列，它们是 $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $。\n\n$ [l, r] $ 中存在一个最小值 $ [m] $，使得 $ [ \\ [l,\\ m],\\ r \\ ] $ 的最小值均为 $ [m] $，举个例子\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n区间 $ [ \\ [1,\\ 4],\\ 6 \\ ] $ 的最小值均为 $ [4] $，即 $ 1 $。\n\n考虑剩下的 $ r - m $ 个子序列，从 $ r $ 向左走，经过的所有比 $ [r] $ **大**的元素，以这些元素的位置为左端点，$ r $ 为右端点的所有子序列的最小值均为 $ [r] $。直到到达第一个比 $ [r] $ 小的元素（例子中的 $ [8] = 3 $），其位置记做 $ {\\rm left}(r) = p $。\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $ 右边有 $ r - p = 10 - 8 = 2 $ 个子序列，他们的最小值均为 $ [10] = 4 $，这些子序列对答案的贡献为 $ (r - p) \\times [r] $。\n\n仿照刚才的做法，继续向左找第一个小于 $ [p] = 3 $ 的元素，其值为 $ [6] = 2 $，即 $ {\\rm left}(p) = p' = 6 $。\n\n| 位置 | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|  值  | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n| 标记 | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $ 右边有 $ p - p' = 8 - 6 = 2 $ 个子序列，他们的最小值均为 $ [8] = 3 $，这些子序列对答案的贡献为 $ (p - p') \\times [p] $。\n\n继续向左找，找到第一个比 $ p' $ 小的元素，其值为 $ 1 $，即 $ {\\rm left}(p') = m = 4 $，注意此时已经找到整个区间内的最小值，左端点在 $ m $ 及其左侧的所有子序列对答案的贡献已经被考虑过，恰好只剩下 $ p' - m = 6 - 4 = 2 $ 个子序列，其最小值均为 $ [p'] = 2 $，这些子序列对答案的贡献为 $ (p' - m) \\times [p'] $。\n\n若直接使用上述算法计算每个元素的贡献，单次计算的时间复杂度为 $ O(n) $，超时。\n\n定义 $ m = \\min[l,\\ r] $ 为区间 $ [l,\\ r] $ 的最小值所在的位置，设 $ f(l, r) $ 为区间 $ [l,\\ r] $ 内除最小值之外的其它值对答案的贡献，则有\n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n注意到整个式子除边界条件中的 $ m $ 之外，和 $ l $ 是无关的。\n\n设 $ s(i) $ 为从 $ i $ 位置一直向左跳，直到跳到所有元素中的最小值，用上述方法计算出的贡献总和，则有\n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n注意到刚才的例子中，$ {\\rm left}(p') = {\\rm left}(m + 1) = m $，即**最后一跳的位置**和**最小值的右边一个位置**向左跳跳到的位置相同。所以\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n使用单调栈算法（保持栈底到栈顶的元素单调递增）预处理出每个 $ {\\rm left}(i) $，之后可以在 $ O(n) $ 的时间内递推出 $ s(i) $。区间向左扩展时同理，向右边跳即可。\n\n而对于 RMQ，使用稀疏表在 $ O(n \\log n) $ 的时间内预处理后，即可在 $ O(1) $ 的时间内回答每次查询。最终，每次转移的时间降为 $ O(1) $，总时间复杂度为 $ O(q \\log q + n \\sqrt n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-sequence","published":1,"updated":"2016-05-01T05:59:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc8d00hu7gxl5sxvs8n3"},{"title":"「HNOI2016」网络 - 树链剖分 + DFS 序","date":"2016-05-11T09:08:00.000Z","_content":"\n一个简单的网络系统可以被描述成一棵无根树。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度。在每一个时刻，只有可能出现下列三种事件中的一种：\n\n1. 在某两个服务器之间出现一条新的数据交互请求；\n2. 某个数据交互结束请求；\n3. 某个服务器出现故障。\n\n系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### 题解\n对树进行树链剖分，并得到其 DFS 序。树上的一条路经转化为 DFS 序上的 $ O(\\log n) $ 个区间。\n\n考虑一条未完成的交互请求**不**会受到某服务器故障的影响，当且仅当这条交互请求**不**经过这台服务器。所以只需要维护不经过某台服务器的请求即可。一条请求会影响树的 DFS 序上 $ O(\\log n) $ 个区间，其补集即为不经过的服务器，仍然是 $ O(\\log n) $ 个区间。\n\n再就是维护重要度最大的请求，可以在线段树的每个节点上维护一个堆，并将标记永久化（不下传标记，用从根到叶子的一条链上的值更新答案），同时存储每条请求是否已结束，并及时将堆顶已结束的请求删除。\n\n总时间复杂度为 $ O(n \\log ^ 3 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","source":"_posts/hnoi2016-network.md","raw":"title: 「HNOI2016」网络 - 树链剖分 + DFS 序\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - 树链剖分\n  - DFS 序\npermalink: hnoi2016-network\ndate: 2016-05-11 17:08:00\n---\n\n一个简单的网络系统可以被描述成一棵无根树。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度。在每一个时刻，只有可能出现下列三种事件中的一种：\n\n1. 在某两个服务器之间出现一条新的数据交互请求；\n2. 某个数据交互结束请求；\n3. 某个服务器出现故障。\n\n系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### 题解\n对树进行树链剖分，并得到其 DFS 序。树上的一条路经转化为 DFS 序上的 $ O(\\log n) $ 个区间。\n\n考虑一条未完成的交互请求**不**会受到某服务器故障的影响，当且仅当这条交互请求**不**经过这台服务器。所以只需要维护不经过某台服务器的请求即可。一条请求会影响树的 DFS 序上 $ O(\\log n) $ 个区间，其补集即为不经过的服务器，仍然是 $ O(\\log n) $ 个区间。\n\n再就是维护重要度最大的请求，可以在线段树的每个节点上维护一个堆，并将标记永久化（不下传标记，用从根到叶子的一条链上的值更新答案），同时存储每条请求是否已结束，并及时将堆顶已结束的请求删除。\n\n总时间复杂度为 $ O(n \\log ^ 3 n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","slug":"hnoi2016-network","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc8h00i07gxlx08y4cu0"},{"title":"「HNOI2016」最小公倍数 - 分块 + 并查集","date":"2016-05-11T08:39:00.000Z","_content":"\n给定一张 $ N $ 个顶点 $ M $ 条边的无向图（顶点编号为 $ 1,\\ 2,\\ \\dots,\\ n $），每条边上带有权值。所有权值都可以分解成 $ 2 ^ a 3 ^ b $ 的形式。现在有 $ q $ 个询问，每次询问给定四个参数 $ u $、$ v $、$ a $ 和 $ b $，请你求出是否存在一条顶点 $ u $ 到 $ v $ 之间的路径，使得路径依次经过的边上的权值的最小公倍数为 $ 2 ^ a 3 ^ b $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### 题解\n因为**路径**可以不是**简单路径**，所以只要两个点在同一连通块内，就一定可以找到一条连接它们的路径。多个数写成 $ 2 $ 和 $ 3 $ 的幂的积的形式的数 $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $ 的最小公倍数，为这些数中 $ 2 $ 的最高次幂乘以 $ 3 $ 的最高次幂，即 $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $。\n\n问题转化为，判断是否能选取若干条组成同一连通块的边，保证给定的两个点相连通，并且连通块内 $ a $ 和 $ b $ 的最大值分别等于给定的值。\n\n显然，边上的 $ a $ 和 $ b $ 中的任意一个比询问的对应值要大，则这条边不会对询问产生影响。考虑对于某一次询问，从小到大加入 $ a $ 和 $ b $ 均小于等于询问值的边，使用并查集维护连通性和连通块内的最大值，并在加入所有边后判断连通块内最大值是否等于询问值。总时间复杂度为 $ O(qm \\  \\alpha(m)) $，超时。\n\n注意到，如果我们将边按照 $ a $ 排序，并离线处理所有询问，可以每次将 $ a $ 小于等于某个询问的边按照 $ b $ 再次排序，得到所有对答案有贡献的边。\n\n考虑将所有边按照 $ a $ 排序后分为 $ T $ 块，每次处理某一块时，取出之前所有块中的边（这些边中的 $ a $ 均小于等于当前块内的所有询问中的 $ a $），并将其按照 $ b $ 排序。取出询问值 $ a $ 在当前块范围内的所有询问，也将其按照 $ b $ 排序。将取出的所有边增量加入并查集，并同时依次处理所有取出的询问。而块内的边也会对块内询问有影响，每处理一次询问时，枚举块内所有边，用上文中的暴力方式将其加入并查集，并在处理完一次询问后将操作**撤销**。\n\n撤销并查集的方法是，维护一个栈，栈内存储所有被修改的位置及其原本的值，以栈的大小作为状态。恢复时，从栈顶弹出，每次将原本的值修改回去，直到栈大小等于原本的栈大小。注意这里**不能**使用路径压缩，而是要使用**按秩合并**。\n\n分析一下上述算法的时间复杂度：每个询问只会被处理最多一次，处理每次询问时遍历了大小为 $ O(\\frac{n}{T}) $ 的块，其中对并查集进行了最多 $ O(\\frac{n}{T}) $ 次，这部分的时间复杂度为 $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $。处理块之前的边时，每条边最多参与 $ T $ 次排序，每个询问最多参与 $ 1 $ 次排序，这部分的时间复杂度为 $ O(T m \\log m + q \\log q) $。取 $ T = \\sqrt m $，则总时间复杂度为 $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-multiple.md","raw":"title: 「HNOI2016」最小公倍数 - 分块 + 并查集\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - CodeVS\n  - HNOI\n  - 分块\n  - 并查集\npermalink: hnoi2016-multiple\ndate: 2016-05-11 16:39:00\n---\n\n给定一张 $ N $ 个顶点 $ M $ 条边的无向图（顶点编号为 $ 1,\\ 2,\\ \\dots,\\ n $），每条边上带有权值。所有权值都可以分解成 $ 2 ^ a 3 ^ b $ 的形式。现在有 $ q $ 个询问，每次询问给定四个参数 $ u $、$ v $、$ a $ 和 $ b $，请你求出是否存在一条顶点 $ u $ 到 $ v $ 之间的路径，使得路径依次经过的边上的权值的最小公倍数为 $ 2 ^ a 3 ^ b $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### 题解\n因为**路径**可以不是**简单路径**，所以只要两个点在同一连通块内，就一定可以找到一条连接它们的路径。多个数写成 $ 2 $ 和 $ 3 $ 的幂的积的形式的数 $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $ 的最小公倍数，为这些数中 $ 2 $ 的最高次幂乘以 $ 3 $ 的最高次幂，即 $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $。\n\n问题转化为，判断是否能选取若干条组成同一连通块的边，保证给定的两个点相连通，并且连通块内 $ a $ 和 $ b $ 的最大值分别等于给定的值。\n\n显然，边上的 $ a $ 和 $ b $ 中的任意一个比询问的对应值要大，则这条边不会对询问产生影响。考虑对于某一次询问，从小到大加入 $ a $ 和 $ b $ 均小于等于询问值的边，使用并查集维护连通性和连通块内的最大值，并在加入所有边后判断连通块内最大值是否等于询问值。总时间复杂度为 $ O(qm \\  \\alpha(m)) $，超时。\n\n注意到，如果我们将边按照 $ a $ 排序，并离线处理所有询问，可以每次将 $ a $ 小于等于某个询问的边按照 $ b $ 再次排序，得到所有对答案有贡献的边。\n\n考虑将所有边按照 $ a $ 排序后分为 $ T $ 块，每次处理某一块时，取出之前所有块中的边（这些边中的 $ a $ 均小于等于当前块内的所有询问中的 $ a $），并将其按照 $ b $ 排序。取出询问值 $ a $ 在当前块范围内的所有询问，也将其按照 $ b $ 排序。将取出的所有边增量加入并查集，并同时依次处理所有取出的询问。而块内的边也会对块内询问有影响，每处理一次询问时，枚举块内所有边，用上文中的暴力方式将其加入并查集，并在处理完一次询问后将操作**撤销**。\n\n撤销并查集的方法是，维护一个栈，栈内存储所有被修改的位置及其原本的值，以栈的大小作为状态。恢复时，从栈顶弹出，每次将原本的值修改回去，直到栈大小等于原本的栈大小。注意这里**不能**使用路径压缩，而是要使用**按秩合并**。\n\n分析一下上述算法的时间复杂度：每个询问只会被处理最多一次，处理每次询问时遍历了大小为 $ O(\\frac{n}{T}) $ 的块，其中对并查集进行了最多 $ O(\\frac{n}{T}) $ 次，这部分的时间复杂度为 $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $。处理块之前的边时，每条边最多参与 $ T $ 次排序，每个询问最多参与 $ 1 $ 次排序，这部分的时间复杂度为 $ O(T m \\log m + q \\log q) $。取 $ T = \\sqrt m $，则总时间复杂度为 $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-multiple","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc8x00i87gxle231ll57"},{"title":"「HNOI2008」玩具装箱 - 斜率优化DP","date":"2016-04-24T03:23:41.000Z","_content":"\nP 教授有编号为 $ 1 $ ~ $ N $ 的 $ N $ 件玩具，第 $ i $ 件玩具经过压缩后变成一维长度为 $ C_i $。为了方便整理，P 教授要求在一个一维容器中的玩具编号是连续的。如果将第 $ i $ 件玩具到第 $ j $ 个玩具放到一个容器中，那么容器的长度将为 $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $。如果容器长度为 $ x $。其制作费用为 $ (x - L) ^ 2 $。其中 $ L $ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容\n器，甚至超过 $ L $。但他希望费用最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### 题解\n动态规划，设 $ f[i] $ 表示前 i 件玩具放进若干个容器中的最小费用，前缀和 $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $。\n\n转移时枚举前面多少个装在同一个箱子里，设它为 $ j $，则第 $ j + 1 $ ~ $ i $ 个装在同一个箱子里，长度为 $ i - j - 1 + s(i) - s(j) $，即\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n直接计算的复杂度为 $ O(n ^ 2) $，超时，考虑优化。\n\n设 $ g(i) = s(i) + i - L - 1 $，$ h(j) = s(j) + j $，上面的方程可以转化为\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n考虑两个决策 $ j = a $ 和 $ j = b $（$ a > b $），若 a 比 b 优，当且仅当\n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n左边成为了斜率的形式，三个式子都是单调的，因此可以用一个单调队列维护每个决策，保证最优决策在队首，两两决策点形成的斜率递增，每次状态转移复杂度降为 $ O(1) $，总时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2008-toy.md","raw":"title: 「HNOI2008」玩具装箱 - 斜率优化DP\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - COGS\n  - HNOI\n  - 斜率优化\n  - 单调队列\n  - DP\npermalink: hnoi2008-toy\ndate: 2016-04-24 11:23:41\n---\n\nP 教授有编号为 $ 1 $ ~ $ N $ 的 $ N $ 件玩具，第 $ i $ 件玩具经过压缩后变成一维长度为 $ C_i $。为了方便整理，P 教授要求在一个一维容器中的玩具编号是连续的。如果将第 $ i $ 件玩具到第 $ j $ 个玩具放到一个容器中，那么容器的长度将为 $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $。如果容器长度为 $ x $。其制作费用为 $ (x - L) ^ 2 $。其中 $ L $ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容\n器，甚至超过 $ L $。但他希望费用最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### 题解\n动态规划，设 $ f[i] $ 表示前 i 件玩具放进若干个容器中的最小费用，前缀和 $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $。\n\n转移时枚举前面多少个装在同一个箱子里，设它为 $ j $，则第 $ j + 1 $ ~ $ i $ 个装在同一个箱子里，长度为 $ i - j - 1 + s(i) - s(j) $，即\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n直接计算的复杂度为 $ O(n ^ 2) $，超时，考虑优化。\n\n设 $ g(i) = s(i) + i - L - 1 $，$ h(j) = s(j) + j $，上面的方程可以转化为\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n考虑两个决策 $ j = a $ 和 $ j = b $（$ a > b $），若 a 比 b 优，当且仅当\n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n左边成为了斜率的形式，三个式子都是单调的，因此可以用一个单调队列维护每个决策，保证最优决策在队首，两两决策点形成的斜率递增，每次状态转移复杂度降为 $ O(1) $，总时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"hnoi2008-toy","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc9400ig7gxlo6tw62ih"},{"title":"「HNOI2004」宠物收养所 - set","id":"5","updated":"2016-01-19T13:08:01.000Z","date":"2015-12-15T21:14:20.000Z","_content":"\n有 `N`（<= 80000）个宠物或领养者，每个宠物或者领养者有一个特点值 `a`，每次当宠物或领养者到来时，从已有的当中匹配一个与其特点值相差最小（且特点值较小）的并删除，计算所有的领养特点值差的总和。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### 题解\n匹配相差最小的元素，很容易联想到复杂度为$O({\\log} n)$的二分查找，但是题目要求动态插入删除，考虑使用 STL 中的 set。\n\n为宠物和领养者各维护一个 set，每当有新的到来时，从另一个 set 中 `lower_bound` 找出**第一个大于等于**该特点值的元素，该元素的上一个即为**第一个小于**该特点值的元素，取二者与新加入的特点值相差较小的即可。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2004-pet.md","raw":"title: 「HNOI2004」宠物收养所 - set\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - HNOI\n  - set\n  - STL\npermalink: hnoi2004-pet\nid: 5\nupdated: '2016-01-19 21:08:01'\ndate: 2015-12-16 05:14:20\n---\n\n有 `N`（<= 80000）个宠物或领养者，每个宠物或者领养者有一个特点值 `a`，每次当宠物或领养者到来时，从已有的当中匹配一个与其特点值相差最小（且特点值较小）的并删除，计算所有的领养特点值差的总和。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### 题解\n匹配相差最小的元素，很容易联想到复杂度为$O({\\log} n)$的二分查找，但是题目要求动态插入删除，考虑使用 STL 中的 set。\n\n为宠物和领养者各维护一个 set，每当有新的到来时，从另一个 set 中 `lower_bound` 找出**第一个大于等于**该特点值的元素，该元素的上一个即为**第一个小于**该特点值的元素，取二者与新加入的特点值相差较小的即可。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"hnoi2004-pet","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc9a00ip7gxlhyg3cpv4"},{"title":"「HDU 5462」King's Order - 数位DP","date":"2016-05-11T23:47:00.000Z","_content":"\n由于国王的口吃并没有治愈，所以传令中可能出现：“让第三军-军-军，到前线去”这样的命令。由于大洋国在军队中安插了间谍，战事紧急，很多时候前线的指挥官不能分清哪些命令真正来自国王。但国王的命令有一个特点，他每次连续重复的字符最多 $ 3 $ 次. 所以说他的命令中没有：“让第三军-军-军-军，到前线去”，但是可以有：“让第三军-军 ，到前线去”。\n\n此时将军找到了你，你需要告诉他，给定命令的长度长度为 $ n $，有多少种不同的命令可以是国王发出的。（也就是求长度为 $ n $ 的合格字符串的个数）当然，国王可能说出一句话没有犯任何口吃，就像他那次演讲一样。\n\n<!-- more -->\n\n### 链接\n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### 题解\n数位 DP，设\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n表示长度为 $ n $ 的字符串，最后四个字符中两两是否相等，最后一个字符是 $ lastChar $，状态转移时，枚举最后一个字符，如果三个标志位均为真，则状态非法，答案为零。\n\n每次不需要重新计算，利用之前计算过的值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5642.md","raw":"title: 「HDU 5462」King's Order - 数位DP\ncategories: OI\ntags: \n  - HDU\n  - BestCoder\n  - 数位DP\n  - DP\npermalink: hdu-5642\ndate: 2016-05-12 07:47:00\n---\n\n由于国王的口吃并没有治愈，所以传令中可能出现：“让第三军-军-军，到前线去”这样的命令。由于大洋国在军队中安插了间谍，战事紧急，很多时候前线的指挥官不能分清哪些命令真正来自国王。但国王的命令有一个特点，他每次连续重复的字符最多 $ 3 $ 次. 所以说他的命令中没有：“让第三军-军-军-军，到前线去”，但是可以有：“让第三军-军 ，到前线去”。\n\n此时将军找到了你，你需要告诉他，给定命令的长度长度为 $ n $，有多少种不同的命令可以是国王发出的。（也就是求长度为 $ n $ 的合格字符串的个数）当然，国王可能说出一句话没有犯任何口吃，就像他那次演讲一样。\n\n<!-- more -->\n\n### 链接\n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### 题解\n数位 DP，设\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n表示长度为 $ n $ 的字符串，最后四个字符中两两是否相等，最后一个字符是 $ lastChar $，状态转移时，枚举最后一个字符，如果三个标志位均为真，则状态非法，答案为零。\n\n每次不需要重新计算，利用之前计算过的值即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5642","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc9g00iw7gxlhg61978n"},{"title":"「HDU 632」Rikka with Array - 数位DP","date":"2016-05-12T14:11:00.000Z","_content":"\n设 $ A(x) $ 表示 $ x $ 的二进制表示中 $ 1 $ 的数量，求满足 $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $ 的数对 $ [i, j] $ 的数量。\n\n<!-- more -->\n\n### 链接\n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### 题解\n数位 DP，设\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n表示二进制表示的最后 $ n $ 位，之前各位组成的数的差（$ j - i $）为 $ gap $，是否 $ i \\lt j $ 或 $ i = j $，$ i $、$ j $ 的之前所有位是否均达到上界的合法数对数量。\n\n转移时枚举 $ i $、$ j $ 的下一位分别是 $ 0 $ 或者 $ 1 $ 即可。\n\n注意，不需要考虑 $ i \\gt j $ 的情况，因为确定了二进制较高位满足一大一小后，较低位不会使其大小关系更改，即这种状态不可能合法。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5632.md","raw":"title: 「HDU 632」Rikka with Array - 数位DP\ncategories: OI\ntags: \n  - HDU\n  - 数位DP\n  - DP\npermalink: hdu-5632\ndate: 2016-05-12 22:11:00\n---\n\n设 $ A(x) $ 表示 $ x $ 的二进制表示中 $ 1 $ 的数量，求满足 $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $ 的数对 $ [i, j] $ 的数量。\n\n<!-- more -->\n\n### 链接\n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### 题解\n数位 DP，设\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n表示二进制表示的最后 $ n $ 位，之前各位组成的数的差（$ j - i $）为 $ gap $，是否 $ i \\lt j $ 或 $ i = j $，$ i $、$ j $ 的之前所有位是否均达到上界的合法数对数量。\n\n转移时枚举 $ i $、$ j $ 的下一位分别是 $ 0 $ 或者 $ 1 $ 即可。\n\n注意，不需要考虑 $ i \\gt j $ 的情况，因为确定了二进制较高位满足一大一小后，较低位不会使其大小关系更改，即这种状态不可能合法。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5632","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc9l00j47gxlo9q5g4g9"},{"title":"「HDU 2089」不要 62 - 数位DP","date":"2016-05-12T03:56:00.000Z","_content":"\n不吉利的数字为所有含有 $ 4 $ 或 $ 62 $ 的号码。例如：$ 62315,\\ 73418,\\ 88914 $ 都属于不吉利号码。但是，$ 61152 $ 虽然含有 $ 6 $ 和 $ 2 $，但不是 $ 62 $ 连号，所以不属于不吉利数字之列。\n\n你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\n\n<!-- more -->\n\n### 链接\n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### 题解\n数位 DP，设\n\n$$ f[n][last][flag] $$\n\n表示号码的最后 $ n $ 位，这 $ n $ 位的上一个字符是 $ last $，之前的字符是否全部紧贴上界，的总数量。\n\n每次枚举这 $ n $ 位的最高位，特判 $ 4 $，特判连续的 $ 62 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-2089.md","raw":"title: 「HDU 2089」不要 62 - 数位DP\ncategories: OI\ntags: \n  - HDU\n  - 数位DP\n  - DP\npermalink: hdu-2089\ndate: 2016-05-12 11:56:00\n---\n\n不吉利的数字为所有含有 $ 4 $ 或 $ 62 $ 的号码。例如：$ 62315,\\ 73418,\\ 88914 $ 都属于不吉利号码。但是，$ 61152 $ 虽然含有 $ 6 $ 和 $ 2 $，但不是 $ 62 $ 连号，所以不属于不吉利数字之列。\n\n你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\n\n<!-- more -->\n\n### 链接\n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### 题解\n数位 DP，设\n\n$$ f[n][last][flag] $$\n\n表示号码的最后 $ n $ 位，这 $ n $ 位的上一个字符是 $ last $，之前的字符是否全部紧贴上界，的总数量。\n\n每次枚举这 $ n $ 位的最高位，特判 $ 4 $，特判连续的 $ 62 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-2089","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc9o00j97gxlwb6tgu8b"},{"title":"「HAOI2016」食物链 - 拓扑排序 + DP","date":"2016-04-28T14:20:45.000Z","_content":"\n给 $ n $ 个物种和 $ m $ 条能量流动关系，求其中的食物链条数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### 题解\n题意中没有说清楚**食物链**的概念，根据样例可知，由生产者走向最高级消费者的简单路径，多条食物链可以有重叠。\n\n我们令边的方向为生产者到最高级消费者，对整张图进行拓扑排序，同时 DP 出从入度为零的点（生产者）到该点的路径条数（一定是简单路径）。\n\n所有出度为零（保证是最高级消费者）且原入度不为零（保证**不是**生产者，单独一个生产者没有消费者不算食物链）的点上的路径条数和即为食物链数量。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/haoi2016-chain.md","raw":"title: 「HAOI2016」食物链 - 拓扑排序 + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - 拓扑排序\n  - DP\npermalink: haoi2016-chain\ndate: 2016-04-28 22:20:45\n---\n\n给 $ n $ 个物种和 $ m $ 条能量流动关系，求其中的食物链条数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### 题解\n题意中没有说清楚**食物链**的概念，根据样例可知，由生产者走向最高级消费者的简单路径，多条食物链可以有重叠。\n\n我们令边的方向为生产者到最高级消费者，对整张图进行拓扑排序，同时 DP 出从入度为零的点（生产者）到该点的路径条数（一定是简单路径）。\n\n所有出度为零（保证是最高级消费者）且原入度不为零（保证**不是**生产者，单独一个生产者没有消费者不算食物链）的点上的路径条数和即为食物链数量。\n\n### 代码\n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"haoi2016-chain","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdc9r00je7gxlfjklrjin"},{"title":"「HAOI2015」树上操作 - 树链剖分 + DFS序","date":"2016-04-03T14:32:45.000Z","_content":"\n有一棵点数为 $ N $ 的树，以点 $ 1 $ 为根，且树点有边权。然后有 $ M $ 个操作，分为三种：\n\n1. 把某个节点 $ x $ 的点权增加 $ a $。\n2. 把某个节点 $ x $ 为根的子树中所有点的点权都增加 $ a $。\n3. 询问某个节点 $ x $ 到根的路径中所有点的点权和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### 题解\n裸树剖 + DFS序，注意要开 `long long`，要不然和暴力分一样 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2015-t2.md","raw":"title: 「HAOI2015」树上操作 - 树链剖分 + DFS序\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 树链剖分\n  - 线段树\n  - DFS序\npermalink: haoi2015-t2\ndate: 2016-04-03 22:32:45\n---\n\n有一棵点数为 $ N $ 的树，以点 $ 1 $ 为根，且树点有边权。然后有 $ M $ 个操作，分为三种：\n\n1. 把某个节点 $ x $ 的点权增加 $ a $。\n2. 把某个节点 $ x $ 为根的子树中所有点的点权都增加 $ a $。\n3. 询问某个节点 $ x $ 到根的路径中所有点的点权和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### 题解\n裸树剖 + DFS序，注意要开 `long long`，要不然和暴力分一样 ……\n\n### 代码\n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2015-t2","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcac00jm7gxl5i54isf7"},{"title":"「HAOI2011」Problem b - 莫比乌斯反演","date":"2016-04-08T03:32:33.000Z","_content":"\n对于给出的 $ n $ 个询问，每次求有多少个数对 $ (x, y) $，满足 $ a \\leq x \\leq b $，$ c \\leq y \\leq d $，且 $ \\gcd(x, y) = k $，$ \\gcd(x, y) $函数为 $ x $ 和 $ y $ 的最大公约数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### 题解\n问题为：求\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n设\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n根据容斥原理，答案即为\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n现在的问题就是求出 $ F $ 函数的值\n\n设\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n构造函数 $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n由莫比乌斯反演得\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n这时候我们已经可以暴力计算 $ F(n, m, k) $ 了\n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n但是这样的复杂度还是会超时的，我们考虑分块计算。\n\n注意到我们的代码中多次出现了形如 $ \\frac{n}{k} $ 的式子，考虑构造一个新函数 $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n此时的 $ F' $ 已经可以分块计算了，通过预处理 $ \\mu(T) $ 的前缀和，我们可以在 $ O(\\sqrt{n}) $ 的时间内回答一组询问。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2011-problemb.md","raw":"title: 「HAOI2011」Problem b - 莫比乌斯反演\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - 莫比乌斯反演\n  - 数论\n  - 数学\n  - 线性筛\npermalink: haoi2011-problemb\ndate: 2016-04-08 11:32:33\n---\n\n对于给出的 $ n $ 个询问，每次求有多少个数对 $ (x, y) $，满足 $ a \\leq x \\leq b $，$ c \\leq y \\leq d $，且 $ \\gcd(x, y) = k $，$ \\gcd(x, y) $函数为 $ x $ 和 $ y $ 的最大公约数。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### 题解\n问题为：求\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n设\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n根据容斥原理，答案即为\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n现在的问题就是求出 $ F $ 函数的值\n\n设\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n构造函数 $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n由莫比乌斯反演得\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n这时候我们已经可以暴力计算 $ F(n, m, k) $ 了\n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n但是这样的复杂度还是会超时的，我们考虑分块计算。\n\n注意到我们的代码中多次出现了形如 $ \\frac{n}{k} $ 的式子，考虑构造一个新函数 $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n此时的 $ F' $ 已经可以分块计算了，通过预处理 $ \\mu(T) $ 的前缀和，我们可以在 $ O(\\sqrt{n}) $ 的时间内回答一组询问。\n\n### 代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2011-problemb","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcag00ju7gxlldwvtg4e"},{"title":"「HAOI2006」受欢迎的牛 - 强联通分量","date":"2016-03-04T13:28:17.000Z","_content":"\n每一头牛的愿望就是变成一头最受欢迎的牛。现在有 $ N $ 头牛，给你 $ M $ 对整数 $ (A,B) $，表示牛 $ A $ 认为牛 $ B $ 受欢迎。 这种关系是具有传递性的，如果 $ A $ 认为 $ B $ 受欢迎，$ B $ 认为 $ C $ 受欢迎，那么牛 $ A $ 也认为牛 $ C $ 受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### 题解\n求出强联通分量，缩点，然后判断是不是只有一个出度为零的点，如果是输出它的大小。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2006-cow.md","raw":"title: 「HAOI2006」受欢迎的牛 - 强联通分量\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 强联通分量\n  - Tarjan\n  - 缩点\npermalink: haoi2006-cow\ndate: 2016-03-04 21:28:17\n---\n\n每一头牛的愿望就是变成一头最受欢迎的牛。现在有 $ N $ 头牛，给你 $ M $ 对整数 $ (A,B) $，表示牛 $ A $ 认为牛 $ B $ 受欢迎。 这种关系是具有传递性的，如果 $ A $ 认为 $ B $ 受欢迎，$ B $ 认为 $ C $ 受欢迎，那么牛 $ A $ 也认为牛 $ C $ 受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### 题解\n求出强联通分量，缩点，然后判断是不是只有一个出度为零的点，如果是输出它的大小。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","slug":"haoi2006-cow","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcb300k47gxlulrcl53w"},{"title":"GDB 入门教程","id":"41","updated":"2016-02-05T02:59:41.000Z","date":"2016-02-05T02:58:07.000Z","_content":"\nGDB（GNU Debugger）是 GNU 计划中的标准调试器，可以在 UNIX、Linux 和 Windows 下运行，支持多种语言（如 C、C++、Pascal 等）程序的调试。\n\n<!-- more -->\n\n### 安装\n#### Linux\n在 Ubuntu 及其衍生版本下，使用 `apt` 安装 GDB。\n```bash\nsudo apt-get install gdb\n```\n另外，NOI Linux 也中有预装的 GDB。\n\n在 RHEL/Fedora/Archlinux 下，使用其各自的包管理器来安装 GDB。\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n在 Windows 下，可选择 Cygwin/MSYS2 环境，也需使用其各自的包管理器来安装 GDB，但通常使用更加轻量的 MinGW 工具集。\n\n一般地，Dev-C++ 安装时会配带 MinGW，我们可以在其 `bin` 目录下找到 `gdb.exe`，为了方便，我们通常将 `bin` 目录的路径添加进 `PATH` 环境变量中，这样我们就可以直接在 `cmd` 中执行 `gdb` 命令。\n\n### 启动\n在控制台中输入 `gdb` 命令（Windows 系统有时需要手动配置环境变量），启动 GDB：\n```bash\ngdb\n```\n在 GDB 中，用 `file` 命令指定需要被调试的程序：\n```bash\n(gdb) file test\n```\n或者，也可以直接在启动 GDB 的时候指定需要被调试的程序：\n```bash\ngdb test\n```\n其中 `test` 为被调试的程序的可执行文件名。\n\n需要注意的是，被 GDB 调试的程序，**在编译时需要加上 `-g` 选项，表示在生成的可执行文件中包含调试信息**。\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB 启动时的提示大概是酱紫的：\n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### 运行\n使用 `run`（简写为 `r`）命令运行被调试的程序。\n```bash\n(gdb) run\n```\n之后可以像直接运行程序一样输入数据并获得输出，程序正常退出时，会得到类似于以下的提示：\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\n如果程序出现运行时错误（Runtime Error，RE），则会有一下提示，此时程序中断（以访问无效内存为例）：\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n其中 `SIGSEGV` 表示程序中断的信号，后面跟着解释文本“Segmentation fault”，即“段错误”。中间一行是程序中断所在函数及其调用参数，下面一行是程序中断所在行的代码，开头 `6` 为行号。\n\n出现这种情况时，我们可以使用各种调试命令对其进行调♂试。\n\n### 退出\n使用 `quit`（简写为 `q`）命令退出。\n\n如果程序正常运行结束，则 `q` 命令会成功退出 GDB，否则我们将会收到类似如下的提示：\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n这时候输入 `y` 后回车，可以强制杀死被调试的进行并退出 GDB。\n\n### 断点\n使用 `break`（简写为 `b`）命令设置断点，后跟一个行号或者函数名，之后程序会在执行到该行时中断。\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` 命令也可以在断点位置后跟一个条件，仅当该条件为真时程序中断。\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n使用 `r` 运行程序，当你输入 `528` 时，程序中断，否则程序继续运行。\n\nPascal 在设置条件断点时会有所不同，如这里的 `==` 需要改为 `=`。\n\n### 控制\n使用 `continue`（简写为 `c`）命令使中断的程序继续运行。\n\n注意，这里“中断的程序”指的是**通过断点中断**的程序，而不是**运行时错误**而中断的，如果我们强制让一个运行时错误的程序继续运行 …… 你猜它会怎样 ……\n\n使用 `step`（简写为 `s`）命令使中断的程序执行一行，如果该行有函数调用，程序将跟踪进入函数，在函数体的第一行中断。\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n或者，你想让我用 Pascal 来演示一下的话，是酱紫的：\n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n使用 `next`（简写为 `n`）命令使中断的程序执行一行，如果该行有函数调用，程序将**不**跟踪进入函数，直接在下一行中断。\n\n源程序不变，执行效果如下：\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### 监视\n在 GDB 中，可以对表达式的值进行监视。\n\n使用 `print`（简写为 `p`）命令输出一个表达式的值，这里的表达式可以只是一个变量，也可以是包含了多个函数调用的复杂表达式。\n\n来看这个经典的 A + B 问题：\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n使用 `display`（简写为 `disp`）命令持续监视某个表达式的值。\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n在 GDB 7.0 之后的版本，可以直接使用 `p` 命令输出 STL 容器的内容。\n\n### 栈\n在函数调用时，系统栈会储存函数的调用信息，使用 `backtrace`（简写为 `bt`）命令查看调用栈。\n\n为了方便演示，我们写一个使系统栈溢出的函数来演示。\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n（以上省略 272043 行）\n\n`bt` 命令可以看到函数的调用信息，同时调用参数、调用位置（行号）也会被显示。\n\n使用 `frame` 命令切换正在调试的函数上下文。\n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n从例子中我们看到，`frame 3` 命令使当前上下文切换到了 `d(x)` 函数中，此时 `p x` 输出的值为 `4`，与我们调用时所传递的值相同。\n\n`frame` 命令在调试在 STL 中崩溃的程序时有很大作用，我们需要切换到自己的函数的上下文中，而不是对 STL 进行调试。\n\n### 查看代码\n使用 `list`（简写为 `l`）命令查看部分代码，后跟一个行号，表示查看从该行开始若干行的代码。\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","source":"_posts/gnu-debugger.md","raw":"title: GDB 入门教程\ncategories: OI\ntags: \n  - GDB\n  - 调试\n  - C++\npermalink: gnu-debugger\nid: 41\nupdated: '2016-02-05 10:59:41'\ndate: 2016-02-05 10:58:07\n---\n\nGDB（GNU Debugger）是 GNU 计划中的标准调试器，可以在 UNIX、Linux 和 Windows 下运行，支持多种语言（如 C、C++、Pascal 等）程序的调试。\n\n<!-- more -->\n\n### 安装\n#### Linux\n在 Ubuntu 及其衍生版本下，使用 `apt` 安装 GDB。\n```bash\nsudo apt-get install gdb\n```\n另外，NOI Linux 也中有预装的 GDB。\n\n在 RHEL/Fedora/Archlinux 下，使用其各自的包管理器来安装 GDB。\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n在 Windows 下，可选择 Cygwin/MSYS2 环境，也需使用其各自的包管理器来安装 GDB，但通常使用更加轻量的 MinGW 工具集。\n\n一般地，Dev-C++ 安装时会配带 MinGW，我们可以在其 `bin` 目录下找到 `gdb.exe`，为了方便，我们通常将 `bin` 目录的路径添加进 `PATH` 环境变量中，这样我们就可以直接在 `cmd` 中执行 `gdb` 命令。\n\n### 启动\n在控制台中输入 `gdb` 命令（Windows 系统有时需要手动配置环境变量），启动 GDB：\n```bash\ngdb\n```\n在 GDB 中，用 `file` 命令指定需要被调试的程序：\n```bash\n(gdb) file test\n```\n或者，也可以直接在启动 GDB 的时候指定需要被调试的程序：\n```bash\ngdb test\n```\n其中 `test` 为被调试的程序的可执行文件名。\n\n需要注意的是，被 GDB 调试的程序，**在编译时需要加上 `-g` 选项，表示在生成的可执行文件中包含调试信息**。\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB 启动时的提示大概是酱紫的：\n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### 运行\n使用 `run`（简写为 `r`）命令运行被调试的程序。\n```bash\n(gdb) run\n```\n之后可以像直接运行程序一样输入数据并获得输出，程序正常退出时，会得到类似于以下的提示：\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\n如果程序出现运行时错误（Runtime Error，RE），则会有一下提示，此时程序中断（以访问无效内存为例）：\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n其中 `SIGSEGV` 表示程序中断的信号，后面跟着解释文本“Segmentation fault”，即“段错误”。中间一行是程序中断所在函数及其调用参数，下面一行是程序中断所在行的代码，开头 `6` 为行号。\n\n出现这种情况时，我们可以使用各种调试命令对其进行调♂试。\n\n### 退出\n使用 `quit`（简写为 `q`）命令退出。\n\n如果程序正常运行结束，则 `q` 命令会成功退出 GDB，否则我们将会收到类似如下的提示：\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n这时候输入 `y` 后回车，可以强制杀死被调试的进行并退出 GDB。\n\n### 断点\n使用 `break`（简写为 `b`）命令设置断点，后跟一个行号或者函数名，之后程序会在执行到该行时中断。\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` 命令也可以在断点位置后跟一个条件，仅当该条件为真时程序中断。\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n使用 `r` 运行程序，当你输入 `528` 时，程序中断，否则程序继续运行。\n\nPascal 在设置条件断点时会有所不同，如这里的 `==` 需要改为 `=`。\n\n### 控制\n使用 `continue`（简写为 `c`）命令使中断的程序继续运行。\n\n注意，这里“中断的程序”指的是**通过断点中断**的程序，而不是**运行时错误**而中断的，如果我们强制让一个运行时错误的程序继续运行 …… 你猜它会怎样 ……\n\n使用 `step`（简写为 `s`）命令使中断的程序执行一行，如果该行有函数调用，程序将跟踪进入函数，在函数体的第一行中断。\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n或者，你想让我用 Pascal 来演示一下的话，是酱紫的：\n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n使用 `next`（简写为 `n`）命令使中断的程序执行一行，如果该行有函数调用，程序将**不**跟踪进入函数，直接在下一行中断。\n\n源程序不变，执行效果如下：\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### 监视\n在 GDB 中，可以对表达式的值进行监视。\n\n使用 `print`（简写为 `p`）命令输出一个表达式的值，这里的表达式可以只是一个变量，也可以是包含了多个函数调用的复杂表达式。\n\n来看这个经典的 A + B 问题：\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n使用 `display`（简写为 `disp`）命令持续监视某个表达式的值。\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n在 GDB 7.0 之后的版本，可以直接使用 `p` 命令输出 STL 容器的内容。\n\n### 栈\n在函数调用时，系统栈会储存函数的调用信息，使用 `backtrace`（简写为 `bt`）命令查看调用栈。\n\n为了方便演示，我们写一个使系统栈溢出的函数来演示。\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n（以上省略 272043 行）\n\n`bt` 命令可以看到函数的调用信息，同时调用参数、调用位置（行号）也会被显示。\n\n使用 `frame` 命令切换正在调试的函数上下文。\n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n从例子中我们看到，`frame 3` 命令使当前上下文切换到了 `d(x)` 函数中，此时 `p x` 输出的值为 `4`，与我们调用时所传递的值相同。\n\n`frame` 命令在调试在 STL 中崩溃的程序时有很大作用，我们需要切换到自己的函数的上下文中，而不是对 STL 进行调试。\n\n### 查看代码\n使用 `list`（简写为 `l`）命令查看部分代码，后跟一个行号，表示查看从该行开始若干行的代码。\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","slug":"gnu-debugger","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcbb00kb7gxluczgmi86"},{"title":"线性筛法筛素数、莫比乌斯函数、欧拉函数","date":"2016-04-08T05:14:55.000Z","_content":"\n线性筛法（欧拉筛法）可以在 $ O(n) $ 的时间内获得 $ [1, n] $ 的所有素数。算法保证每个合数都会被它的最小质因子筛掉，所以复杂度是线性的。同时，我们可以利用这一特性，结合积性函数的性质，在 $ O(n) $ 的时间内筛出一些积性函数的值。\n\n<!-- more -->\n\n### 欧拉函数\n欧拉函数 $ \\phi(n) $ 的定义为：小于 $ n $ 的正整数中与 $ n $ 互质的数的个数，$ \\phi(1) = 1 $。\n\n当 $ n $ 为质数时，根据定义，显然有 $ \\phi(n) = n - 1 $。\n\n设 $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times … \\times p_N ^ {k_N} $，其中 $ p_i $ 为素数，则有\n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n设 $ p_1 $ 为 $ n $ 最小质因子，$ n' = \\frac{n}{p_1} $，在线性筛中，$ n $ 通过 $ n' \\times p_1 $ 被筛掉。\n\n当 $ n' \\ {\\rm mod} \\ p_1 = 0 $，即 $ k_1 \\gt 1 $ 时，$ n' $ 含有 $ n $ 的所有质因子，则有\n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n当 $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $，即 $ k_1 = 1 $ 时，$ n' $ 与 $ p_1 $ 互质，根据积性函数的性质有\n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### 莫比乌斯函数\n莫比乌斯函数 $ \\mu(n) $ 的定义：\n\n设 $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times … \\times p_N ^ {k_N} $，其中 $ p_i $ 为素数\n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n当 $ n $ 为质数时，根据定义，显然有 $ \\mu(n) = -1 $。\n\n设 $ p_1 $ 为 $ n $ 最小质因子，$ n' = \\frac{n}{p_1} $，在线性筛中，$ n $ 通过 $ n' \\times p_1 $ 被筛掉。\n\n当 $ n' \\ {\\rm mod} \\ p_1 = 0 $，即 $ k_1 \\gt 1 $ 时，由定义得\n\n$$ \\mu(n) = 0 $$\n\n当 $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $，即 $ k_1 = 1 $ 时，$ n' $ 有 $ N - 1 $ 个质因子，此时我们分情况讨论，若 $ \\mu(n') \\neq 0 $，即 $ n' $ 的所有质因子次数均为 $ 1 $，根据定义有\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n若 $ \\mu(n') = 0 $，说明 $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $，根据定义显然有\n\n$$ \\mu(n) = 0 $$\n\n此时 $ \\mu(n) = -\\mu(n') $ 仍然成立。\n\n\n### 模板\n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","source":"_posts/euler-sieve.md","raw":"title: 线性筛法筛素数、莫比乌斯函数、欧拉函数\ncategories: OI\ntags: \n  - 数学\n  - 数论\n  - 学习笔记\n  - 算法模板\n  - 线性筛\npermalink: euler-sieve\ndate: 2016-04-08 13:14:55\n---\n\n线性筛法（欧拉筛法）可以在 $ O(n) $ 的时间内获得 $ [1, n] $ 的所有素数。算法保证每个合数都会被它的最小质因子筛掉，所以复杂度是线性的。同时，我们可以利用这一特性，结合积性函数的性质，在 $ O(n) $ 的时间内筛出一些积性函数的值。\n\n<!-- more -->\n\n### 欧拉函数\n欧拉函数 $ \\phi(n) $ 的定义为：小于 $ n $ 的正整数中与 $ n $ 互质的数的个数，$ \\phi(1) = 1 $。\n\n当 $ n $ 为质数时，根据定义，显然有 $ \\phi(n) = n - 1 $。\n\n设 $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times … \\times p_N ^ {k_N} $，其中 $ p_i $ 为素数，则有\n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n设 $ p_1 $ 为 $ n $ 最小质因子，$ n' = \\frac{n}{p_1} $，在线性筛中，$ n $ 通过 $ n' \\times p_1 $ 被筛掉。\n\n当 $ n' \\ {\\rm mod} \\ p_1 = 0 $，即 $ k_1 \\gt 1 $ 时，$ n' $ 含有 $ n $ 的所有质因子，则有\n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n当 $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $，即 $ k_1 = 1 $ 时，$ n' $ 与 $ p_1 $ 互质，根据积性函数的性质有\n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### 莫比乌斯函数\n莫比乌斯函数 $ \\mu(n) $ 的定义：\n\n设 $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times … \\times p_N ^ {k_N} $，其中 $ p_i $ 为素数\n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n当 $ n $ 为质数时，根据定义，显然有 $ \\mu(n) = -1 $。\n\n设 $ p_1 $ 为 $ n $ 最小质因子，$ n' = \\frac{n}{p_1} $，在线性筛中，$ n $ 通过 $ n' \\times p_1 $ 被筛掉。\n\n当 $ n' \\ {\\rm mod} \\ p_1 = 0 $，即 $ k_1 \\gt 1 $ 时，由定义得\n\n$$ \\mu(n) = 0 $$\n\n当 $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $，即 $ k_1 = 1 $ 时，$ n' $ 有 $ N - 1 $ 个质因子，此时我们分情况讨论，若 $ \\mu(n') \\neq 0 $，即 $ n' $ 的所有质因子次数均为 $ 1 $，根据定义有\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n若 $ \\mu(n') = 0 $，说明 $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $，根据定义显然有\n\n$$ \\mu(n) = 0 $$\n\n此时 $ \\mu(n) = -\\mu(n') $ 仍然成立。\n\n\n### 模板\n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","slug":"euler-sieve","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcbf00ki7gxlk2koowhj"},{"title":"Edmonds-Karp 费用流学习笔记","date":"2016-02-19T09:04:38.000Z","_content":"\n有一类网络流问题，最大流并不唯一，而每一条边都有一个单位流量的费用，最优解的目标是保证流量最大的前提下使总费用最小。单纯的最大流可以使用 Edmonds-Karp 算法求解，但这个算法不够优，最常用的是 Dinic 算法。但 Edmonds-Karp 确是最小费用流问题最常用的算法。\n\n<!-- more -->\n\n### 定义\n费用（`cost`）：单位流量流过一条边需要支付的费用，算法的目标是使总流量最大的前提下总费用最小。\n\n其他的定义和 Dinic 中基本相同，但 Edmonds-Karp 中没有『层次』和『层次图』的概念。\n\nEdmonds-Karp 的反向边的费用是原边的费用相反数。\n\n### 算法\n1. 在残量网络中以『费用』为距离，沿着未满流边找出一条从源点到汇点的最短路，并进行增广。\n2. 增广时将总费用加上**汇点的距离** × **增广流量**。\n3. 无法找到增广路时算法结束，此时已找出网络的最小费用最大流。\n\n找最短路时，一般使用 Bellman-Ford 算法，因为网络中一般都会存在负权边，而不可能有负环——当有负环时，最小费用最大流不存在。\n\nEdmonds-Karp 基于一个事实：如果当前费用是在当前流量下的最小费用，那么以最小费用增广之后的费用也为增广后的流量下的最小费用。不断增广找到的就是最小费用最大流。\n\n### 代码实现\n```cpp\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","source":"_posts/edmonds-karp-notes.md","raw":"title: Edmonds-Karp 费用流学习笔记\ncategories: OI\ntags: \n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 学习笔记\n  - 算法模板  \npermalink: edmonds-karp-notes\ndate: 2016-02-19 17:04:38\n---\n\n有一类网络流问题，最大流并不唯一，而每一条边都有一个单位流量的费用，最优解的目标是保证流量最大的前提下使总费用最小。单纯的最大流可以使用 Edmonds-Karp 算法求解，但这个算法不够优，最常用的是 Dinic 算法。但 Edmonds-Karp 确是最小费用流问题最常用的算法。\n\n<!-- more -->\n\n### 定义\n费用（`cost`）：单位流量流过一条边需要支付的费用，算法的目标是使总流量最大的前提下总费用最小。\n\n其他的定义和 Dinic 中基本相同，但 Edmonds-Karp 中没有『层次』和『层次图』的概念。\n\nEdmonds-Karp 的反向边的费用是原边的费用相反数。\n\n### 算法\n1. 在残量网络中以『费用』为距离，沿着未满流边找出一条从源点到汇点的最短路，并进行增广。\n2. 增广时将总费用加上**汇点的距离** × **增广流量**。\n3. 无法找到增广路时算法结束，此时已找出网络的最小费用最大流。\n\n找最短路时，一般使用 Bellman-Ford 算法，因为网络中一般都会存在负权边，而不可能有负环——当有负环时，最小费用最大流不存在。\n\nEdmonds-Karp 基于一个事实：如果当前费用是在当前流量下的最小费用，那么以最小费用增广之后的费用也为增广后的流量下的最小费用。不断增广找到的就是最小费用最大流。\n\n### 代码实现\n```cpp\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","slug":"edmonds-karp-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcbj00kp7gxljb9uj75l"},{"title":"Dinic 学习笔记","date":"2016-02-03T10:57:59.000Z","_content":"\nDinic 算法是一种对于网络流问题的增广路算法，它通过对残量网络进行分层，并在层次图上寻找增广路的方式，实现了在$ O(n^2m) $的时间内求出网络的最大流。\n\n<!-- more -->\n\n### 定义\n* 容量：`capacity(e)` 表示一条有向边 `e(u, v)` 的最大允许的流量。\n\n* 流量：`flow(e)` 表示一条有向边 `e(u, v)` 总容量中已被占用的流量。\n\n* 剩余容量：即 `capacity(e) - flow(e)`，表示当前时刻某条有向边 `e(u, v)` 总流量中未被占用的部分。\n\n* 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 0，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n\n* 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n\n* 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余流量为**增广流量**。\n\n* 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上**增广流量**的过程。\n\n* 层次： `level(u)` 表示节点 `u` 在层次图中与源点的距离。\n\n* 层次图：在原残量网络中按照每个节点的层次来分层，只保留**相邻两层**的节点的图，**满载（即流量等于容量）的边不存在于层次图中**。\n\n### 算法\n1. 遍历残量网络，建立层次图；\n2. 在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；\n3. 重复 `(2)`，直至层次图中不存在增广路，回到 `(1)` 重新建立层次图；\n4. 直到层次图无法建立，则当前流量即为最大流量。\n\n每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理。\n\n### 优化\nDinic 有一个常见的优化——当前弧优化。\n\n该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFS 这个点的时候直接可以从这条边的下一条边开始。\n\n### 代码实现\n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","source":"_posts/dinic-notes.md","raw":"title: Dinic 学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 网络流\n  - Dinic\n  - 算法模板  \npermalink: dinic-notes\ndate: 2016-02-03 18:57:59\n---\n\nDinic 算法是一种对于网络流问题的增广路算法，它通过对残量网络进行分层，并在层次图上寻找增广路的方式，实现了在$ O(n^2m) $的时间内求出网络的最大流。\n\n<!-- more -->\n\n### 定义\n* 容量：`capacity(e)` 表示一条有向边 `e(u, v)` 的最大允许的流量。\n\n* 流量：`flow(e)` 表示一条有向边 `e(u, v)` 总容量中已被占用的流量。\n\n* 剩余容量：即 `capacity(e) - flow(e)`，表示当前时刻某条有向边 `e(u, v)` 总流量中未被占用的部分。\n\n* 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 0，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n\n* 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n\n* 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余流量为**增广流量**。\n\n* 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上**增广流量**的过程。\n\n* 层次： `level(u)` 表示节点 `u` 在层次图中与源点的距离。\n\n* 层次图：在原残量网络中按照每个节点的层次来分层，只保留**相邻两层**的节点的图，**满载（即流量等于容量）的边不存在于层次图中**。\n\n### 算法\n1. 遍历残量网络，建立层次图；\n2. 在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；\n3. 重复 `(2)`，直至层次图中不存在增广路，回到 `(1)` 重新建立层次图；\n4. 直到层次图无法建立，则当前流量即为最大流量。\n\n每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理。\n\n### 优化\nDinic 有一个常见的优化——当前弧优化。\n\n该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFS 这个点的时候直接可以从这条边的下一条边开始。\n\n### 代码实现\n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","slug":"dinic-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcbn00kx7gxlaermrpai"},{"title":"全错位排列递推公式的推导","date":"2016-04-13T07:41:16.000Z","_content":"\n将按照顺序排列的 $ 1 $ ~ $ n $ 打乱，重新排列，要求每个元素都不能在自己原有的位置上，求方案总数。\n\n<!-- more -->\n\n设答案为 $ f(n) $。\n\n首先考虑第 $ n $ 号位置上放哪个元素，有 $ n - 1 $ 种方案，假设放的是 $ 1 $；\n\n考虑把 $ n $ 号元素放在哪个位置，如果我们删掉 $ n $ 号位置（不再考虑原有的 $ 1 $ 号元素），然后把 $ n $ 号元素的标号改为 $ 1 $，这样问题就成为了一个子问题 $ f(n - 1) $。\n\n但是这样考虑是有问题的 —— 原有的 $ n $ 号元素被编号为 1 后，就再也不可能被放到 1 号位置了，但原问题中，这是一种可行方案，所以要把这种情况加上。如果把 $ n $ 号元素放到 1 号位置，可以不再考虑这两个位置，问题转化为另一个子问题 $ f(n - 2) $。\n\n这样，我们得到一个递推式\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","source":"_posts/derangement-number.md","raw":"title: 全错位排列递推公式的推导\ncategories: OI\ntags: \n  - 数学\n  - 学习笔记\n  - 错位排列\npermalink: derangement-number\ndate: 2016-04-13 15:41:16\n---\n\n将按照顺序排列的 $ 1 $ ~ $ n $ 打乱，重新排列，要求每个元素都不能在自己原有的位置上，求方案总数。\n\n<!-- more -->\n\n设答案为 $ f(n) $。\n\n首先考虑第 $ n $ 号位置上放哪个元素，有 $ n - 1 $ 种方案，假设放的是 $ 1 $；\n\n考虑把 $ n $ 号元素放在哪个位置，如果我们删掉 $ n $ 号位置（不再考虑原有的 $ 1 $ 号元素），然后把 $ n $ 号元素的标号改为 $ 1 $，这样问题就成为了一个子问题 $ f(n - 1) $。\n\n但是这样考虑是有问题的 —— 原有的 $ n $ 号元素被编号为 1 后，就再也不可能被放到 1 号位置了，但原问题中，这是一种可行方案，所以要把这种情况加上。如果把 $ n $ 号元素放到 1 号位置，可以不再考虑这两个位置，问题转化为另一个子问题 $ f(n - 2) $。\n\n这样，我们得到一个递推式\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","slug":"derangement-number","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcbq00l47gxl49z36wv5"},{"title":"树链剖分学习笔记","date":"2015-12-27T14:48:11.000Z","_content":"\n树链剖分，就是把一棵树咔嚓咔嚓剖成一堆不相交的链，然后在链上结合搞基数据结构进行各种查询或者修改操作。\n\n<!-- more -->\n\n### 题目：树的统计\n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n给出一棵树，每个点有一个可修改的点权，每次查询两点之间**所有点**的点权和或点权最大值。\n\n### 基本思想\n![CutTree](cut-tree-notes/cutTree.png)\n\n把整棵树划分成许多条**链**，使每个节点都在唯一的链上，对每一条链维护一棵**线段树**，把在树上的操作转移到线段树上。\n\n具体剖的话，这里采用**轻重边路径剖分**的方式，剖最大子树，这样可以保证整棵树上的轻边和链的数量都不超过 $O({\\log}n)$。\n\n### 定义\n```cpp\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n```\n\n对于每个节点，`depth` 表示这个节点的深度（即到整棵树的根的距离），`size` 表示以这个节点为根的树的大小（即节点总数），`maxSizeChild` 表示该节点的最大子树，`maxDepth` 表示自当前节点向下沿着 `maxSizeChild` 走，走到的最大深度，即链的最底端节点的深度。\n\n每个节点都在一条链上，我们把这些链叫做路径（Path），每条路径的最顶端点（深度最小的）称为链顶节点 `top`，并且为路径上的所有节点维护一棵线段树，而每个节点的 `pos` 表示自己在自己的路径上的编号。\n\n### 剖分\n剖分的过程主要由两次搜索组成，首先，我们来一遍 `DFS`，求出每个节点的 `maxSizeChild` 和 `maxDepth`。\n\n```cpp\nstack<Tree *> s;\n\ns.push(root);\nwhile (!s.empty()) {\n\tTree *tree = s.top();\n\tif (tree->visited) {\n\t\ttree->size = 1;\n\t\ttree->maxDepth = tree->depth;\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ttree->size += child->size;\n\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t}\n\t\t}\n\n\t\ts.pop();\n\t} else {\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ts.push(child);\n\t\t}\n\n\t\ttree->visited = true;\n\t}\n}\n```\n\n然后，我们用第二遍搜索来把每一条链连接起来，`DFS` 和 `BFS` 都可以，因为 `BFS` 好写就用 `BFS` 吧 ……\n\n对于每个节点，如果它是根或它不是父节点的 `maxDepthChild`，则我们创建一条从该节点开始的链，否则该节点所在链即为父节点所在链。\n\n```cpp\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n```\n\n最后，在线段树上更新每个点的权值：\n\n```cpp\nfor (uint i = 0; i < n; i++) {\n\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n}\n```\n\n### 修改\n修改某个点的权值，只需要在该节点所在链上的线段树中更新即可。\n\n```cpp\ninline void update(uint x, uint w) {\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n```\n\n### 查询\n查询两个点 `[u, v]` 之间的点权和（或点权极值）的思路如下：\n\n1. 如果 `u` 与 `v` 不同一条链上，则使二者中**所在链链顶节点**深度最小的一个跳到**所在链链顶节点**的父节点位置，继续回到 1；\n2. 如果 `u` 与 `v` 在同一条链上，则直接从线段树中查询。\n\n```cpp\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n```\n\n### 附：无根树转有根树\n为了剖分时更容易一些，我们可以把读入的无根树转化成有根树，这样搜索的时候方便点，当然常数也会大一些 ……\n\n```cpp\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 附：线段树\n我们使用线段树来维护每一条链，这里只用到了单点修改，也可以换成树状数组或者 zkw 线段树。\n\n```cpp\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n```\n### 完整代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing std::queue;\nusing std::stack;\nusing std::swap;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 30000;\n\nstruct Node {\n\tstruct Edge *edges;\n\tuint id;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, Edge *next) : from(from), to(to), next(next) {}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n\nuint n, q;\n\ninline void addEdge(uint a, uint b) {\n\tnodes[a].edges = new Edge(&nodes[a], &nodes[b], nodes[a].edges);\n\tnodes[b].edges = new Edge(&nodes[b], &nodes[a], nodes[b].edges);\n}\n\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void cut() {\n\tstack<Tree *> s;\n\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *tree = s.top();\n\t\tif (tree->visited) {\n\t\t\ttree->size = 1;\n\t\t\ttree->maxDepth = tree->depth;\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ttree->size += child->size;\n\t\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t} else {\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ts.push(child);\n\t\t\t}\n\n\t\t\ttree->visited = true;\n\t\t}\n\t}\n\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n\t}\n}\n\ninline void update(uint x, uint w) {\n\ttreeNodes[x].w = w;\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n\ninline int queryMax(uint u, uint v) {\n\tint result = INT_MIN;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult = std::max(result, a->path->segmentTree->queryMax(0, a->pos));\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult = std::max(result, a->path->segmentTree->queryMax(a->pos, b->pos));\n\treturn result;\n}\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tfor (uint i = 0; i < n - 1; i++) {\n\t\tuint a, b;\n\t\tscanf(\"%u %u\", &a, &b);\n\t\ta--, b--;\n\n\t\taddEdge(a, b);\n\t}\n\n\tconvert();\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint w;\n\t\tscanf(\"%u\", &w);\n\t\ttreeNodes[i].w = w;\n\t}\n\n\tcut();\n\n\tscanf(\"%u\", &q);\n\n\tfor (uint i = 0; i < q; i++) {\n\t\tchar command[6 + 1];\n\t\tscanf(\"%s\", command);\n\t\tif (command[1] == 'H') { // CHANGE\n\t\t\tuint x;\n\t\t\tint w;\n\t\t\tscanf(\"%u %d\", &x, &w);\n\t\t\tx--;\n\n\t\t\tupdate(x, w);\n\t\t} else {\n\t\t\tuint u, v;\n\t\t\tscanf(\"%u %u\", &u, &v);\n\t\t\tu--, v--;\n\n\t\t\tif (command[1] == 'M') { // QMAX\n\t\t\t\tprintf(\"%d\\n\", queryMax(u, v));\n\t\t\t} else { // QSUM\n\t\t\t\tprintf(\"%d\\n\", querySum(u, v));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/cut-tree-notes.md","raw":"title: 树链剖分学习笔记\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - 数据结构\n  - 树链剖分\n  - 高级数据结构\n  - 算法模板  \npermalink: cut-tree-notes\ndate: 2015-12-27 22:48:11\n---\n\n树链剖分，就是把一棵树咔嚓咔嚓剖成一堆不相交的链，然后在链上结合搞基数据结构进行各种查询或者修改操作。\n\n<!-- more -->\n\n### 题目：树的统计\n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n给出一棵树，每个点有一个可修改的点权，每次查询两点之间**所有点**的点权和或点权最大值。\n\n### 基本思想\n![CutTree](cut-tree-notes/cutTree.png)\n\n把整棵树划分成许多条**链**，使每个节点都在唯一的链上，对每一条链维护一棵**线段树**，把在树上的操作转移到线段树上。\n\n具体剖的话，这里采用**轻重边路径剖分**的方式，剖最大子树，这样可以保证整棵树上的轻边和链的数量都不超过 $O({\\log}n)$。\n\n### 定义\n```cpp\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n```\n\n对于每个节点，`depth` 表示这个节点的深度（即到整棵树的根的距离），`size` 表示以这个节点为根的树的大小（即节点总数），`maxSizeChild` 表示该节点的最大子树，`maxDepth` 表示自当前节点向下沿着 `maxSizeChild` 走，走到的最大深度，即链的最底端节点的深度。\n\n每个节点都在一条链上，我们把这些链叫做路径（Path），每条路径的最顶端点（深度最小的）称为链顶节点 `top`，并且为路径上的所有节点维护一棵线段树，而每个节点的 `pos` 表示自己在自己的路径上的编号。\n\n### 剖分\n剖分的过程主要由两次搜索组成，首先，我们来一遍 `DFS`，求出每个节点的 `maxSizeChild` 和 `maxDepth`。\n\n```cpp\nstack<Tree *> s;\n\ns.push(root);\nwhile (!s.empty()) {\n\tTree *tree = s.top();\n\tif (tree->visited) {\n\t\ttree->size = 1;\n\t\ttree->maxDepth = tree->depth;\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ttree->size += child->size;\n\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t}\n\t\t}\n\n\t\ts.pop();\n\t} else {\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ts.push(child);\n\t\t}\n\n\t\ttree->visited = true;\n\t}\n}\n```\n\n然后，我们用第二遍搜索来把每一条链连接起来，`DFS` 和 `BFS` 都可以，因为 `BFS` 好写就用 `BFS` 吧 ……\n\n对于每个节点，如果它是根或它不是父节点的 `maxDepthChild`，则我们创建一条从该节点开始的链，否则该节点所在链即为父节点所在链。\n\n```cpp\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n```\n\n最后，在线段树上更新每个点的权值：\n\n```cpp\nfor (uint i = 0; i < n; i++) {\n\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n}\n```\n\n### 修改\n修改某个点的权值，只需要在该节点所在链上的线段树中更新即可。\n\n```cpp\ninline void update(uint x, uint w) {\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n```\n\n### 查询\n查询两个点 `[u, v]` 之间的点权和（或点权极值）的思路如下：\n\n1. 如果 `u` 与 `v` 不同一条链上，则使二者中**所在链链顶节点**深度最小的一个跳到**所在链链顶节点**的父节点位置，继续回到 1；\n2. 如果 `u` 与 `v` 在同一条链上，则直接从线段树中查询。\n\n```cpp\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n```\n\n### 附：无根树转有根树\n为了剖分时更容易一些，我们可以把读入的无根树转化成有根树，这样搜索的时候方便点，当然常数也会大一些 ……\n\n```cpp\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 附：线段树\n我们使用线段树来维护每一条链，这里只用到了单点修改，也可以换成树状数组或者 zkw 线段树。\n\n```cpp\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n```\n### 完整代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing std::queue;\nusing std::stack;\nusing std::swap;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 30000;\n\nstruct Node {\n\tstruct Edge *edges;\n\tuint id;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, Edge *next) : from(from), to(to), next(next) {}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n\nuint n, q;\n\ninline void addEdge(uint a, uint b) {\n\tnodes[a].edges = new Edge(&nodes[a], &nodes[b], nodes[a].edges);\n\tnodes[b].edges = new Edge(&nodes[b], &nodes[a], nodes[b].edges);\n}\n\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void cut() {\n\tstack<Tree *> s;\n\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *tree = s.top();\n\t\tif (tree->visited) {\n\t\t\ttree->size = 1;\n\t\t\ttree->maxDepth = tree->depth;\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ttree->size += child->size;\n\t\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t} else {\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ts.push(child);\n\t\t\t}\n\n\t\t\ttree->visited = true;\n\t\t}\n\t}\n\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n\t}\n}\n\ninline void update(uint x, uint w) {\n\ttreeNodes[x].w = w;\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n\ninline int queryMax(uint u, uint v) {\n\tint result = INT_MIN;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult = std::max(result, a->path->segmentTree->queryMax(0, a->pos));\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult = std::max(result, a->path->segmentTree->queryMax(a->pos, b->pos));\n\treturn result;\n}\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tfor (uint i = 0; i < n - 1; i++) {\n\t\tuint a, b;\n\t\tscanf(\"%u %u\", &a, &b);\n\t\ta--, b--;\n\n\t\taddEdge(a, b);\n\t}\n\n\tconvert();\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint w;\n\t\tscanf(\"%u\", &w);\n\t\ttreeNodes[i].w = w;\n\t}\n\n\tcut();\n\n\tscanf(\"%u\", &q);\n\n\tfor (uint i = 0; i < q; i++) {\n\t\tchar command[6 + 1];\n\t\tscanf(\"%s\", command);\n\t\tif (command[1] == 'H') { // CHANGE\n\t\t\tuint x;\n\t\t\tint w;\n\t\t\tscanf(\"%u %d\", &x, &w);\n\t\t\tx--;\n\n\t\t\tupdate(x, w);\n\t\t} else {\n\t\t\tuint u, v;\n\t\t\tscanf(\"%u %u\", &u, &v);\n\t\t\tu--, v--;\n\n\t\t\tif (command[1] == 'M') { // QMAX\n\t\t\t\tprintf(\"%d\\n\", queryMax(u, v));\n\t\t\t} else { // QSUM\n\t\t\t\tprintf(\"%d\\n\", querySum(u, v));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"cut-tree-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcbu00l97gxlo5v8n43d"},{"title":"「CTSC1999」星际转移 - 网络流","id":"59","updated":"2016-02-24T13:42:46.000Z","date":"2016-02-24T13:41:36.000Z","_content":"\n现有 `n` 个太空站位于地球与月球之间，且有 `m` 艘太空船在其间来回穿梭。每个太空站可容纳无限多的人，第 `i` 个太空船只可容纳 `H[i]` 个人。每艘太空船将周期性地停靠一系列的太空站。每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。求让所有人尽快地全部转移到月球上的最短时间。\n\n<!-- more -->\n\n### 链接\n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### 题解\n话说这题真是难调 …… qwq\n\n考虑到『一个太空站和一个时间点』确定了一个状态，枚举答案 `t`，将每个太空站拆成 `t + 1` 个点（因为初始状态是在 0 时刻）。对于每一个时刻，从**上一时刻每个太空船的停留站**到**这一时刻每个太空船的停留站**连一条边，容量为该太空船载客量；对于任何一个太空站，从上一时刻到这一时刻连一条边，容量为正无穷（表示人停留在太空站）；对于任意时刻的地球，从源点向其连一条边，容量为正无穷；对于任意时刻的月球，从其向汇点连一条边，容量为正无穷。\n\n从小到大枚举答案，答案每增大 1，在原图中加入新边。直到汇点的流量大于等于总人数，则答案合法。\n\n也可以二分答案 …… 不过那样要拆掉图重建，总感觉数据小的情况下比枚举还要慢。qwq\n\n数据范围有坑！数据范围有坑！数据范围有坑！`n` 和 `m` 的最大值颠倒了！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/ctsc1999-home.md","raw":"title: 「CTSC1999」星际转移 - 网络流\ncategories: OI\ntags: \n  - COGS\n  - CTSC\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\n  - 枚举答案\npermalink: ctsc1999-home\nid: 59\nupdated: '2016-02-24 21:42:46'\ndate: 2016-02-24 21:41:36\n---\n\n现有 `n` 个太空站位于地球与月球之间，且有 `m` 艘太空船在其间来回穿梭。每个太空站可容纳无限多的人，第 `i` 个太空船只可容纳 `H[i]` 个人。每艘太空船将周期性地停靠一系列的太空站。每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。求让所有人尽快地全部转移到月球上的最短时间。\n\n<!-- more -->\n\n### 链接\n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### 题解\n话说这题真是难调 …… qwq\n\n考虑到『一个太空站和一个时间点』确定了一个状态，枚举答案 `t`，将每个太空站拆成 `t + 1` 个点（因为初始状态是在 0 时刻）。对于每一个时刻，从**上一时刻每个太空船的停留站**到**这一时刻每个太空船的停留站**连一条边，容量为该太空船载客量；对于任何一个太空站，从上一时刻到这一时刻连一条边，容量为正无穷（表示人停留在太空站）；对于任意时刻的地球，从源点向其连一条边，容量为正无穷；对于任意时刻的月球，从其向汇点连一条边，容量为正无穷。\n\n从小到大枚举答案，答案每增大 1，在原图中加入新边。直到汇点的流量大于等于总人数，则答案合法。\n\n也可以二分答案 …… 不过那样要拆掉图重建，总感觉数据小的情况下比枚举还要慢。qwq\n\n数据范围有坑！数据范围有坑！数据范围有坑！`n` 和 `m` 的最大值颠倒了！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"ctsc1999-home","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcc000lh7gxl0zs1qtlr"},{"title":"「CTSC1997」选课 - 树形DP","id":"15","updated":"2016-01-19T13:05:52.000Z","date":"2016-01-06T21:12:01.000Z","_content":"\n学校开设了 N（<= 300） 门课程，每门课程有不同的学分，每个学生最多可以选择 M 门课程，有些课程有“先修课”，即这门课必须在先修课选定之后再选，每门课程的先修课最多有一门。求获得学分最多的选课方案。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### 题解\n很显然，这里的依赖关系是以森林的形式给出的，我们增加一个虚拟节点作为所有无先修课的课程的父节点，搜索这棵树，用 $f[i][m]$ 表示选择第 `i` 个节点及其之后节点（兄弟或孩子）中的 `m` 个节点所对应的课程所获得的最大学分，则有两个转移方向：\n\n1. 给第 `i` 个节点和它的**一个或多个子节点**分配一定的课程数量 `k`，剩余课程数量 `m - k - 1` 分给**下一个兄弟节点**。\n2. 不选择第 `i` 个节点，全部课程数量 `m` 分配给**下一个兄弟节点**。\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n树结构储存时使用类似邻接表的结构，储存当前节点的第一个孩子节点，和下一个兄弟节点。\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### 代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","source":"_posts/ctsc1997-course.md","raw":"title: 「CTSC1997」选课 - 树形DP\ncategories: OI\ntags: \n  - CodeVS\n  - CTSC\n  - DP\n  - 树形DP\npermalink: ctsc1997-course\nid: 15\nupdated: '2016-01-19 21:05:52'\ndate: 2016-01-07 05:12:01\n---\n\n学校开设了 N（<= 300） 门课程，每门课程有不同的学分，每个学生最多可以选择 M 门课程，有些课程有“先修课”，即这门课必须在先修课选定之后再选，每门课程的先修课最多有一门。求获得学分最多的选课方案。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### 题解\n很显然，这里的依赖关系是以森林的形式给出的，我们增加一个虚拟节点作为所有无先修课的课程的父节点，搜索这棵树，用 $f[i][m]$ 表示选择第 `i` 个节点及其之后节点（兄弟或孩子）中的 `m` 个节点所对应的课程所获得的最大学分，则有两个转移方向：\n\n1. 给第 `i` 个节点和它的**一个或多个子节点**分配一定的课程数量 `k`，剩余课程数量 `m - k - 1` 分给**下一个兄弟节点**。\n2. 不选择第 `i` 个节点，全部课程数量 `m` 分配给**下一个兄弟节点**。\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n树结构储存时使用类似邻接表的结构，储存当前节点的第一个孩子节点，和下一个兄弟节点。\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### 代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","slug":"ctsc1997-course","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcc500ls7gxle5bcvdwu"},{"title":"CTSC2016 & APIO2016 行纪","date":"2016-05-09T10:18:13.000Z","_content":"\n第一次参加 CTSC & APIO，流水账如下。\n\n<!-- more -->\n\n### 5.1\n早上五点来到了北京，转了两路地铁一路公交又走了段路，终于到了昆泰酒店 ……  \n因为来的有点早，还不能开房，报名人员也没来，只好先在大厅坐下了，感觉这酒店网速不给力啊 QAQ  \n八点开了房，住在十楼，双人间。和我住一间屋的还没来，估计是莱芜或者青岛的神犇？qwq\n\n过了会青岛二中的来了，Oxer 和我住一间屋。去旁边屋里膜了一发 yts1999 大爷，RP++\n\n看了看报名表，看到 Teachk 来了，于是找他面基去了 ovo 还有大连的好几个神犇（虽然我都不认识\n\n和 HA 的小伙伴碰了碰头，CXC 并没有来（唉。。。）  \n中午一起去次饭了 QwQ 食堂的饭好评 只是学校有点远喔 ……\n\n下午睡了一会，醒来去他们那里，~~sui 和 Fancy 在给他们学校高一的同学讲课，讲完~~过了一会我们就去试机了  \nCOGS 观光团到齐了嘛 QwQ ~~然而好多人、姓名、ID 对不起来~~  \n顺便参观了一下八十中的教学楼，好高端 ovo  \n选手用机操作系统是 NOI Linux（Ubuntu 14.04 LTS）好评！  \n~~（想想 SDOI 连个像样的编程环境都没有真是太反人类了啊喂~~\n\nFancy 问我怎样才能把 vim 配置背下来，于是我把每一行的含义给她讲了一遍  \n然而 sui 表示缩写多好记呀~  \n~~我会告诉你们我第一次在 JSOI 考场上写 vim 配置的时候还列出所有命令找了一遍？~~\n\n过一会安师大附中的神犇们来了，在喊试机题目是哪年的 NOI 题目，水水水 …… ~~听不下去了就和小伙伴走了~~  \n逛了逛校园就去次下午饭了~~这里的饭真好次呀~~\n\n次完饭回到酒店，上完厕所发现自己 QQ 登不上了（smg ……  \n喂喂喂我刚才不就是说了一句 %fqk 吗怎么成不良信息了 ……  \n换了个 QQ 号，顺便找到 DQS 神犇加回了之前的群 ……  \n~~辣鸡腾讯，吃枣药丸！~~\n\n晚上找小伙伴们玩，然后被拉到另一个房间，发现 COGS 观光团的人都在。  \nsui：这就是 Menci！  \n众人：%%%%% ……  \n~~Menci：mdzz … &@!#@%~& ……~~\n\n他们说 wmd 明后天会来监考，然后我随口问了一句 Chenyao 怎么不来 ……  \n他们给我指了一下屋子里的某个人，说，这就是 Chenyao ……  \n~~mdzz ……~~\n~~Chenyao 真的好萌好帅呀 Orz！~~\n\n看他们玩了一个叫做『妙不可言』的神奇的卡牌游戏 ……  \n玩了一局之后他们墙裂要求我加入，于是我也没拒绝 ……  \n愉♂快地玩完一局之后发现时间不早了，回屋洗澡睡觉 …… qwq\n\n### 5.2\nCTSC2016 Day1\n\n七点钟从酒店出发，和他们一起去了学校  \n早饭还不错嘛，油条、鸡蛋、煎饼没有果子、豆浆、包子 ……\n\n怎么就我一个在图书馆考啊喂 …… 泥萌都在教学楼 ……  \n图书馆在哪里啊喂 ……  \n哦 …… 就在教学楼旁边 ……\n\n图书馆外面遇到了青岛二中的 dms 神犇，膜了一发 ……  \n诶怎么还不入场 …… 都八点半了啊喂 ……  \n入场之后看了下电脑上的时间，八点四十多 ……  \n~~mdzz ……~~\n\n喝水看题 ……\n\n第一题，蛤？题意都读不懂语文水平真是太差了 ……  \n第三题，提交答案？蛤？（此处省略一张 这题能做？.jpg）  \n第二题，Suffix Array？写个后缀数组打打暴力吧，怎么这么小气才给 5 分暴力分啊 ……  \n\n开始敲后缀数组 ……  \n二十分钟后，后缀数组敲完了 ……  \n对拍一下吧 ……  \n诶怎么显示出错的两行都一样？  \n自己看看输出文件吧，发现有两个排名被弄反了 ……  \n跟踪调试了好久，发现某个地方漏了个 `else` ……  \n~~mdzz ……~~\n\n码好爆搜，试试样例 ……  \n样例一过了 ……  \n样例二输出小了很多 ……  \n调了好久调不出来，最后输出了，诶发现字符串怎么变短了 …… 诶这个 `n` 怎么变小了 ……  \n~~mdzz~~，忘了清数组了 ……\n\n清了数组又试了下样例，怎么还是不对啊喂 ……  \n开始各种乱调 ……  \n调了一个小时，答案没变 ……  \n~~今天上午就杠这题了！杠出来就有 5 分了！~~\n\n『选手注意，第二题第二个样例改为 ……』  \n啊，所以说我的是对的？  \n~~mdzz 我都调了一个多小时了啊喂~~  \n\n看来第二题有 5 分了，冷静下来读了读第一题题意，发现能读懂了，尝试写了下 5 分暴力，很快调出来了 ……\n\n看到了一二两题都有好多部分分，但是不好搞啊 ……  \n看了下 T3，根本不可做啊，题答怎么玩啊我不会 ……\n\n还剩二十分钟了，想想把 T3 全填上随机数吧 …… 说不定能有几分 ……\n\n出了考场，外面下雨了，打开手机接着接到了 Fancy 的电话 ……  \nFancy：我们等了你十多分钟，没等到你，就先去食堂了  \nMenci：&@!#@%~& …… 要不让 sui 来接我吧 ……  \n~~mdzz 为什么只有图书馆延时了啊喂 ……~~\n\n和他们讨论了一下题  \n『第三题第一个点组合数、第二个点 01 背包、第 X 个点矩阵乘法，还真是十合一 ……』  \n蛤？  \n『第一题题意读不懂啊 …… 第二题中间的部分分可以打表找规律 ……』  \n蛤？  \n『第三题搞了搞前两个点，后面的全输出 0 ……』  \n蛤？  \n蛤？蛤？  \nmdzz …… 我为什么要输出随机数啊喂，输出 0 才能得分啊喂 ……\n\n~~我怎么感觉就我分数最低啊喂 ……~~\n\n下午讲题，全程听不懂 …… 听不懂 …… XD  \n第一题 yts1999 用一种奇怪的方法用超哥线段树搞了搞部分分 ……  \n蛤？  \n第三题十个点十个算法 …… 弃疗保平安 ……\n\n看了成绩，`5 + 5 + 2 = 12` 分，第三题随机数炸了 ……  \n果然就我分最低，Fancy 输出 0 拿了 15 分 ……\n\n感觉要 Fe 滚粗了 ……\n\n晚上，sui 给我讲了 HNOI 的几道题，于是我在调题，~~他们都去颓了~~。\n\n### 5.3\n上午，集训队论文答辩，听懂的东西不多啊 …… QAQ（窝还是太弱辣\n\nfaebdc 讲的网络流还是挺赞的 ……\n\n下午报告会，大家都说不想去了 …… 于是打算在酒店碎觉 ……  \n然后接到 Fancy 的电话，说不参加报告会取消明天比赛资格 ……\n\n蛤？赶紧起来走吧 ……  \n在讨论组里问了一下，他们表示都不去 ……  \n\n来到之后报告会已经开始了 …… 人好少 QAQ 看来是没这回事 …… mdzz ……  \n睡觉睡不着了还是打开电脑看题吧 qwq ……  \nsui 打开电脑打一个叫『以撒』（← 是不是这两个字啊喂 0.0）的游戏，好高端 ovo，Fancy 拿出 Kindle 看知乎日报，好高端 ovo ……\n\n放眼望去整个报告厅基本上都在干正事（大雾 ……\n\n晚上正在调题的时候，Fancy 拿起手机问我这人是谁 ……  \nwoc … 这不是 fqk 神犇么！！！  \nfqk：Fancy 是男的女的？  \nMenci：&@!#@%~& ……  \nfqk：wori … （躲在椅子下面.jpg）你常说的 HA 的小伙伴我以为都是男的 …… 我是 sb ……  \n（fqk 本来就是 s（hen）b（en）啊 2333\n\n### 5.4\nCTSC2016 Day2\n\n还是在图书馆，不过这次准时开考了\n\n喝水看题 ……\n\n第一题，蛤？  \n第二题，蛤？  \n第三题，提交答案，蛤？\n\n完了这是要爆零的节奏吗 QAQ 嗯先看看题答吧 …… XD\n\n第一个点数据好小，写个爆搜试试 ……  \n爆搜调出来了，10 分到手  \n搜了一下第二个点，爆内存了，爆内存前得到的最优解才 3 分，不行啊，看看数据试试 ……\n\n只有一个人，没有负边，没有限制 ……  \n这不是网络流么 2333  \n敲了个网络流，还没敲完 …… mdzz …… 啥网络流啊 ……\n\n嗯 …… 试试 SPFA 最长路 qwq ……  \n二十分钟后 …… md怎么一分多种还没跑完，该不会进环了吧 ……  \nmdzz …… 这数据有（you）环（du）！\n\n一想，这不是 APIO2009 的 atm 那题么 ……  \n无奈开始码 Tarjan ……\n\nTarjan 调了快一个小时，我真弱啊这么基础的算法都要调这么久 ……  \n缩点跑最长路，发现答案是对的，然后就是怎么输出路径的问题了 ……  \n脑补了一下，把一个强连通分量走完，然后走到下一个 ……\n\n嗯好像没错，开始写吧 ……  \n写完开始调，诶这个函数怎么没有被调用 ……\n\n~~mdzz ……~~ 怎么只有一个强连通分量啊喂 ……  \n不过这样简单一些，直接走完整个强连通分量就好了\n\n思路是，考虑一棵搜索树上，每条边都能被访问到  \n只要可以沿着原来的边回溯回去，就可以很容易地走完所有边  \n于是在每次回溯的时候再跑一遍另一个搜索，搜出一条路径来\n\n写完之后调了半个小时，开 `O3` 跑了一分多种终于跑出来了  \n打开输出文件一看，有大约 n 平方条边 …… 输出文件 3M+  \n`checker` 跑了一秒多，答案是对的，20 分有了 ……\n\n看了下，发现这个点和其他点不一样，这个程序跑不出其他的点 QAQ 只好爆搜，但每个点都连个可行解都搜不出来 ……  \n还剩不到二十分钟了，弃疗吧 …… XD\n\n前两题都没写 ……\n\n中午在食堂遇见 Dashgua，他说第三题直接 SPFA，遇到环就跳出来，就有 70 分了 ……  \n~~mdzz ……~~  \n感觉自己真的连 Cu 都拿不到啊 ……  \ndms 说他 A 了一提，太神啦！\n\n下午讲题，很多人吐槽题答被乱搞好几十分，个个的程序都比我简单 …… ~~mdzz ……~~\n\n晚上闭幕式，中间的游戏环节有个猜谜，明明我猜出来了但主持人没听到 qwq （`O(E)` 不是 SPFA 还能是啥啊喂  \n宣读获奖名单，果然 Fe 滚粗了 QAQ\n\n回到酒店，被青岛二中的拐走了，yts1999、Oxer、dms、heheda 等几位神犇都在 ……  \n于是他们教我一种叫做『够级』的扑克牌游戏 2333 ……\n\n玩了几局之后就跑下去了 qwq  \n想起来还没找胜利一中的 abclzr 神犇面基呢，于是就先去找到了他聊了一会，lzr 好神啊！\n\nKZ 要我帮他调一下 Ubuntu、Windows 双系统的时间设置 …… 虽然没搞过但听起来好简单的样子  \n调了好久最后发现改改时区就可以 ……\n\n### 5.5\n休息日。\n\n上午他们睡到很晚才起来 ……\n\n去学校次早饭回来的路上，讨论组里  \nKZ：把 Menci 叫过来，我们要吃饭 ……  \nFancy：Menci 能吃吗？  \n~~Menci：&@!#@%~&~~  \n~~此处应有『一脸茫然.jpg』~~\n\n回来之后调了一会题又该次中午饭了 qvq\n\nFancy 说她小姨要带她去天安门，好高端 ……  \n其他人商量着去香山，窝表示对此并不感兴趣 ……\n\n于是中午自己回来了，睡醒觉就四点多了，写了一会题，不知不觉一道题写了 N 天了 ……\n\n晚上看见 SDOI 群里有人搞大新闻 ……（此处省略 &@!#@%~&）…… 233333333\n\n### 5.6\n听说 fqk 的学长要来讲课？太神辣！\n\n到了讲厅，抢了第一排的座位近距离围观，然而并不能听懂什么高端的 XXXX 搜索算法 Orz，下课期间上去问了问，还真是 fqk 的学长（这还有假？\n\n唉，听不懂弃疗吧 qwq ……\n\n晚上把 HNOI 某树调出来了，又按照神兽的做法写了写 APIO 练习赛的交互，好水的题 qwq  \nAPIO 的题不可能这么水吧\n\n### 5.7\nAPIO2016 Day1\n\nAPIO 的开考时间晚一些，可以提前进场 qwq 于是就可以先写好 vim 配置了 ……\n\n省常中的 Johann 神犇坐我左边，%%% ……\n\n题目有纸张和 PDF 的，在线评测实时反馈，好高端 qwq\n\n喝水看题 ……\n\n第一题，蛤？打个暴力试试 ……  \n第二题，蛤？第一个子任务我都不会啊 ……  \n第三题，蛤？交互，限制啥啥啥次数？\n\n打好了第一题暴力，冷静下来想了想其实第一个子任务就是一个序列，求所有单调上升序列数量。怎么跟食物链这么像呢 …… 建图拓扑排序然后直接 DP 嘛 …… 半个小时才调出来（暴露水平了 XD\n\n第二题第一个子任务 …… 试试平均数？不行啊，打个暴力吧 …… 发现答案是全部变成这些数中的其中一个，那就枚举一遍这些数吧 ……\n\n两个半小时拿了 16 分了 ……\n\n看第三题，上来一个小时啥都不会，后来一想，~~mdzz~~ …… 直接从两边向中间逼近，然后得到整个序列不就好了 ……  \n提交，30.38 分 …… 这样就有 46.38 分了 …… 还不够啊，想想第二个子任务 ……\n\n脑补了一下感觉二分复杂度是对的，随便写了一个交上去发现才 42 分，哪里不对？卡卡常试试 ……  \n卡了卡常交上去发现 WA 了，发现漏情况了，改了之后又交上去 …… 诶，怎么不评测了 ……\n\n用 CMS 自带的提问功能问了一下主办方，被告知服务器不稳定 ……（~~辣鸡服务器，毁我比赛~~  \n于是只好自己对拍，发现是对的，继续卡常数，发现卡不到很低了，感觉这不是正解~~（当然不是）~~……\n\n最后又交了一下，还是评不出来，而且没给加时 …… 就这样结束了\n\n下午讲题，T3 正解分块 …… 我傻逼了都想到鸽笼原理的怎么就不分块呢 ……  \nT2 我原本想到的子任务 2 的树形 DP 是对的，没时间写了啊 …… QAQ\n\n发现又是就我分低，这是三题签到分啊，又要 Fe 滚粗了么 XD\n\n晚上他们都去 THU 看智能体大赛了，然而我表示并不想去，就会酒店找湖北的小伙伴玩了 QwQ  \n和 Fuxey 和 Sengxian 他们聊了一晚上，十一点多才回去 …… qwq  \nSengxian 表示他才是**真·签到分**，46.38 分 23333\n\n### 5.8\n听课。\n\n上午讲物理引擎 …… smg …… 拿出笔记本电脑准备写 sui 给我讲的题 …… 诶怎么开不了机 ……  \nmdzz …… 昨晚忘关机了，没电了 XD\n\n于是 Fancy 把笔记本电脑借给了我，写了一上午的题，还是没调出来 ……  \n下午还是听不懂课，继续调题 …… 然而 Fancy 的电脑也没电了 XD\n\n晚上闭幕式 …… Cu 线好低，46 分就有 ……\n\n回到酒店又被青岛二中的拐走了，zdw1999 竟然也被拐过去了 qvq  \n打了两局保皇 ……\n\n于是又去找 HA 的小伙伴了 …… 刚进房间大家都很兴奋的样子 …… ~~这是要搞个大新闻？~~\n\n~~（由于某些原因，此处删除若干字）~~\n\n然后继续调今天上午写的题，过了样例，交到 COGS 上，WWTTTTTTTT，弃疗 ……\n\n最后帮 Fancy 搞了搞 Ubuntu 下的指纹识别，KZ 表示也要我帮他弄弄，然而已经快十二点了 …… XD\n\n### 5.9\n早上八点去次饭，get 成就 最后一个走出食堂 23333\n\n晚上的火车，于是先在酒店待了一上午 ……\n\n考虑到车站环境并不太好，又在酒店大厅里待了一下午 …… qwq\n\n晚上就要坐车回去咯 ……\n\n再见 ……\n","source":"_posts/ctsc-apio-2016.md","raw":"title: CTSC2016 & APIO2016 行纪\ncategories: \n  - Diary\n  - OI\ntags: \n  - 游记\n  - APIO\n  - CTSC\npermalink: ctsc-apio-2016\ndate: 2016-05-09 18:18:13\n---\n\n第一次参加 CTSC & APIO，流水账如下。\n\n<!-- more -->\n\n### 5.1\n早上五点来到了北京，转了两路地铁一路公交又走了段路，终于到了昆泰酒店 ……  \n因为来的有点早，还不能开房，报名人员也没来，只好先在大厅坐下了，感觉这酒店网速不给力啊 QAQ  \n八点开了房，住在十楼，双人间。和我住一间屋的还没来，估计是莱芜或者青岛的神犇？qwq\n\n过了会青岛二中的来了，Oxer 和我住一间屋。去旁边屋里膜了一发 yts1999 大爷，RP++\n\n看了看报名表，看到 Teachk 来了，于是找他面基去了 ovo 还有大连的好几个神犇（虽然我都不认识\n\n和 HA 的小伙伴碰了碰头，CXC 并没有来（唉。。。）  \n中午一起去次饭了 QwQ 食堂的饭好评 只是学校有点远喔 ……\n\n下午睡了一会，醒来去他们那里，~~sui 和 Fancy 在给他们学校高一的同学讲课，讲完~~过了一会我们就去试机了  \nCOGS 观光团到齐了嘛 QwQ ~~然而好多人、姓名、ID 对不起来~~  \n顺便参观了一下八十中的教学楼，好高端 ovo  \n选手用机操作系统是 NOI Linux（Ubuntu 14.04 LTS）好评！  \n~~（想想 SDOI 连个像样的编程环境都没有真是太反人类了啊喂~~\n\nFancy 问我怎样才能把 vim 配置背下来，于是我把每一行的含义给她讲了一遍  \n然而 sui 表示缩写多好记呀~  \n~~我会告诉你们我第一次在 JSOI 考场上写 vim 配置的时候还列出所有命令找了一遍？~~\n\n过一会安师大附中的神犇们来了，在喊试机题目是哪年的 NOI 题目，水水水 …… ~~听不下去了就和小伙伴走了~~  \n逛了逛校园就去次下午饭了~~这里的饭真好次呀~~\n\n次完饭回到酒店，上完厕所发现自己 QQ 登不上了（smg ……  \n喂喂喂我刚才不就是说了一句 %fqk 吗怎么成不良信息了 ……  \n换了个 QQ 号，顺便找到 DQS 神犇加回了之前的群 ……  \n~~辣鸡腾讯，吃枣药丸！~~\n\n晚上找小伙伴们玩，然后被拉到另一个房间，发现 COGS 观光团的人都在。  \nsui：这就是 Menci！  \n众人：%%%%% ……  \n~~Menci：mdzz … &@!#@%~& ……~~\n\n他们说 wmd 明后天会来监考，然后我随口问了一句 Chenyao 怎么不来 ……  \n他们给我指了一下屋子里的某个人，说，这就是 Chenyao ……  \n~~mdzz ……~~\n~~Chenyao 真的好萌好帅呀 Orz！~~\n\n看他们玩了一个叫做『妙不可言』的神奇的卡牌游戏 ……  \n玩了一局之后他们墙裂要求我加入，于是我也没拒绝 ……  \n愉♂快地玩完一局之后发现时间不早了，回屋洗澡睡觉 …… qwq\n\n### 5.2\nCTSC2016 Day1\n\n七点钟从酒店出发，和他们一起去了学校  \n早饭还不错嘛，油条、鸡蛋、煎饼没有果子、豆浆、包子 ……\n\n怎么就我一个在图书馆考啊喂 …… 泥萌都在教学楼 ……  \n图书馆在哪里啊喂 ……  \n哦 …… 就在教学楼旁边 ……\n\n图书馆外面遇到了青岛二中的 dms 神犇，膜了一发 ……  \n诶怎么还不入场 …… 都八点半了啊喂 ……  \n入场之后看了下电脑上的时间，八点四十多 ……  \n~~mdzz ……~~\n\n喝水看题 ……\n\n第一题，蛤？题意都读不懂语文水平真是太差了 ……  \n第三题，提交答案？蛤？（此处省略一张 这题能做？.jpg）  \n第二题，Suffix Array？写个后缀数组打打暴力吧，怎么这么小气才给 5 分暴力分啊 ……  \n\n开始敲后缀数组 ……  \n二十分钟后，后缀数组敲完了 ……  \n对拍一下吧 ……  \n诶怎么显示出错的两行都一样？  \n自己看看输出文件吧，发现有两个排名被弄反了 ……  \n跟踪调试了好久，发现某个地方漏了个 `else` ……  \n~~mdzz ……~~\n\n码好爆搜，试试样例 ……  \n样例一过了 ……  \n样例二输出小了很多 ……  \n调了好久调不出来，最后输出了，诶发现字符串怎么变短了 …… 诶这个 `n` 怎么变小了 ……  \n~~mdzz~~，忘了清数组了 ……\n\n清了数组又试了下样例，怎么还是不对啊喂 ……  \n开始各种乱调 ……  \n调了一个小时，答案没变 ……  \n~~今天上午就杠这题了！杠出来就有 5 分了！~~\n\n『选手注意，第二题第二个样例改为 ……』  \n啊，所以说我的是对的？  \n~~mdzz 我都调了一个多小时了啊喂~~  \n\n看来第二题有 5 分了，冷静下来读了读第一题题意，发现能读懂了，尝试写了下 5 分暴力，很快调出来了 ……\n\n看到了一二两题都有好多部分分，但是不好搞啊 ……  \n看了下 T3，根本不可做啊，题答怎么玩啊我不会 ……\n\n还剩二十分钟了，想想把 T3 全填上随机数吧 …… 说不定能有几分 ……\n\n出了考场，外面下雨了，打开手机接着接到了 Fancy 的电话 ……  \nFancy：我们等了你十多分钟，没等到你，就先去食堂了  \nMenci：&@!#@%~& …… 要不让 sui 来接我吧 ……  \n~~mdzz 为什么只有图书馆延时了啊喂 ……~~\n\n和他们讨论了一下题  \n『第三题第一个点组合数、第二个点 01 背包、第 X 个点矩阵乘法，还真是十合一 ……』  \n蛤？  \n『第一题题意读不懂啊 …… 第二题中间的部分分可以打表找规律 ……』  \n蛤？  \n『第三题搞了搞前两个点，后面的全输出 0 ……』  \n蛤？  \n蛤？蛤？  \nmdzz …… 我为什么要输出随机数啊喂，输出 0 才能得分啊喂 ……\n\n~~我怎么感觉就我分数最低啊喂 ……~~\n\n下午讲题，全程听不懂 …… 听不懂 …… XD  \n第一题 yts1999 用一种奇怪的方法用超哥线段树搞了搞部分分 ……  \n蛤？  \n第三题十个点十个算法 …… 弃疗保平安 ……\n\n看了成绩，`5 + 5 + 2 = 12` 分，第三题随机数炸了 ……  \n果然就我分最低，Fancy 输出 0 拿了 15 分 ……\n\n感觉要 Fe 滚粗了 ……\n\n晚上，sui 给我讲了 HNOI 的几道题，于是我在调题，~~他们都去颓了~~。\n\n### 5.3\n上午，集训队论文答辩，听懂的东西不多啊 …… QAQ（窝还是太弱辣\n\nfaebdc 讲的网络流还是挺赞的 ……\n\n下午报告会，大家都说不想去了 …… 于是打算在酒店碎觉 ……  \n然后接到 Fancy 的电话，说不参加报告会取消明天比赛资格 ……\n\n蛤？赶紧起来走吧 ……  \n在讨论组里问了一下，他们表示都不去 ……  \n\n来到之后报告会已经开始了 …… 人好少 QAQ 看来是没这回事 …… mdzz ……  \n睡觉睡不着了还是打开电脑看题吧 qwq ……  \nsui 打开电脑打一个叫『以撒』（← 是不是这两个字啊喂 0.0）的游戏，好高端 ovo，Fancy 拿出 Kindle 看知乎日报，好高端 ovo ……\n\n放眼望去整个报告厅基本上都在干正事（大雾 ……\n\n晚上正在调题的时候，Fancy 拿起手机问我这人是谁 ……  \nwoc … 这不是 fqk 神犇么！！！  \nfqk：Fancy 是男的女的？  \nMenci：&@!#@%~& ……  \nfqk：wori … （躲在椅子下面.jpg）你常说的 HA 的小伙伴我以为都是男的 …… 我是 sb ……  \n（fqk 本来就是 s（hen）b（en）啊 2333\n\n### 5.4\nCTSC2016 Day2\n\n还是在图书馆，不过这次准时开考了\n\n喝水看题 ……\n\n第一题，蛤？  \n第二题，蛤？  \n第三题，提交答案，蛤？\n\n完了这是要爆零的节奏吗 QAQ 嗯先看看题答吧 …… XD\n\n第一个点数据好小，写个爆搜试试 ……  \n爆搜调出来了，10 分到手  \n搜了一下第二个点，爆内存了，爆内存前得到的最优解才 3 分，不行啊，看看数据试试 ……\n\n只有一个人，没有负边，没有限制 ……  \n这不是网络流么 2333  \n敲了个网络流，还没敲完 …… mdzz …… 啥网络流啊 ……\n\n嗯 …… 试试 SPFA 最长路 qwq ……  \n二十分钟后 …… md怎么一分多种还没跑完，该不会进环了吧 ……  \nmdzz …… 这数据有（you）环（du）！\n\n一想，这不是 APIO2009 的 atm 那题么 ……  \n无奈开始码 Tarjan ……\n\nTarjan 调了快一个小时，我真弱啊这么基础的算法都要调这么久 ……  \n缩点跑最长路，发现答案是对的，然后就是怎么输出路径的问题了 ……  \n脑补了一下，把一个强连通分量走完，然后走到下一个 ……\n\n嗯好像没错，开始写吧 ……  \n写完开始调，诶这个函数怎么没有被调用 ……\n\n~~mdzz ……~~ 怎么只有一个强连通分量啊喂 ……  \n不过这样简单一些，直接走完整个强连通分量就好了\n\n思路是，考虑一棵搜索树上，每条边都能被访问到  \n只要可以沿着原来的边回溯回去，就可以很容易地走完所有边  \n于是在每次回溯的时候再跑一遍另一个搜索，搜出一条路径来\n\n写完之后调了半个小时，开 `O3` 跑了一分多种终于跑出来了  \n打开输出文件一看，有大约 n 平方条边 …… 输出文件 3M+  \n`checker` 跑了一秒多，答案是对的，20 分有了 ……\n\n看了下，发现这个点和其他点不一样，这个程序跑不出其他的点 QAQ 只好爆搜，但每个点都连个可行解都搜不出来 ……  \n还剩不到二十分钟了，弃疗吧 …… XD\n\n前两题都没写 ……\n\n中午在食堂遇见 Dashgua，他说第三题直接 SPFA，遇到环就跳出来，就有 70 分了 ……  \n~~mdzz ……~~  \n感觉自己真的连 Cu 都拿不到啊 ……  \ndms 说他 A 了一提，太神啦！\n\n下午讲题，很多人吐槽题答被乱搞好几十分，个个的程序都比我简单 …… ~~mdzz ……~~\n\n晚上闭幕式，中间的游戏环节有个猜谜，明明我猜出来了但主持人没听到 qwq （`O(E)` 不是 SPFA 还能是啥啊喂  \n宣读获奖名单，果然 Fe 滚粗了 QAQ\n\n回到酒店，被青岛二中的拐走了，yts1999、Oxer、dms、heheda 等几位神犇都在 ……  \n于是他们教我一种叫做『够级』的扑克牌游戏 2333 ……\n\n玩了几局之后就跑下去了 qwq  \n想起来还没找胜利一中的 abclzr 神犇面基呢，于是就先去找到了他聊了一会，lzr 好神啊！\n\nKZ 要我帮他调一下 Ubuntu、Windows 双系统的时间设置 …… 虽然没搞过但听起来好简单的样子  \n调了好久最后发现改改时区就可以 ……\n\n### 5.5\n休息日。\n\n上午他们睡到很晚才起来 ……\n\n去学校次早饭回来的路上，讨论组里  \nKZ：把 Menci 叫过来，我们要吃饭 ……  \nFancy：Menci 能吃吗？  \n~~Menci：&@!#@%~&~~  \n~~此处应有『一脸茫然.jpg』~~\n\n回来之后调了一会题又该次中午饭了 qvq\n\nFancy 说她小姨要带她去天安门，好高端 ……  \n其他人商量着去香山，窝表示对此并不感兴趣 ……\n\n于是中午自己回来了，睡醒觉就四点多了，写了一会题，不知不觉一道题写了 N 天了 ……\n\n晚上看见 SDOI 群里有人搞大新闻 ……（此处省略 &@!#@%~&）…… 233333333\n\n### 5.6\n听说 fqk 的学长要来讲课？太神辣！\n\n到了讲厅，抢了第一排的座位近距离围观，然而并不能听懂什么高端的 XXXX 搜索算法 Orz，下课期间上去问了问，还真是 fqk 的学长（这还有假？\n\n唉，听不懂弃疗吧 qwq ……\n\n晚上把 HNOI 某树调出来了，又按照神兽的做法写了写 APIO 练习赛的交互，好水的题 qwq  \nAPIO 的题不可能这么水吧\n\n### 5.7\nAPIO2016 Day1\n\nAPIO 的开考时间晚一些，可以提前进场 qwq 于是就可以先写好 vim 配置了 ……\n\n省常中的 Johann 神犇坐我左边，%%% ……\n\n题目有纸张和 PDF 的，在线评测实时反馈，好高端 qwq\n\n喝水看题 ……\n\n第一题，蛤？打个暴力试试 ……  \n第二题，蛤？第一个子任务我都不会啊 ……  \n第三题，蛤？交互，限制啥啥啥次数？\n\n打好了第一题暴力，冷静下来想了想其实第一个子任务就是一个序列，求所有单调上升序列数量。怎么跟食物链这么像呢 …… 建图拓扑排序然后直接 DP 嘛 …… 半个小时才调出来（暴露水平了 XD\n\n第二题第一个子任务 …… 试试平均数？不行啊，打个暴力吧 …… 发现答案是全部变成这些数中的其中一个，那就枚举一遍这些数吧 ……\n\n两个半小时拿了 16 分了 ……\n\n看第三题，上来一个小时啥都不会，后来一想，~~mdzz~~ …… 直接从两边向中间逼近，然后得到整个序列不就好了 ……  \n提交，30.38 分 …… 这样就有 46.38 分了 …… 还不够啊，想想第二个子任务 ……\n\n脑补了一下感觉二分复杂度是对的，随便写了一个交上去发现才 42 分，哪里不对？卡卡常试试 ……  \n卡了卡常交上去发现 WA 了，发现漏情况了，改了之后又交上去 …… 诶，怎么不评测了 ……\n\n用 CMS 自带的提问功能问了一下主办方，被告知服务器不稳定 ……（~~辣鸡服务器，毁我比赛~~  \n于是只好自己对拍，发现是对的，继续卡常数，发现卡不到很低了，感觉这不是正解~~（当然不是）~~……\n\n最后又交了一下，还是评不出来，而且没给加时 …… 就这样结束了\n\n下午讲题，T3 正解分块 …… 我傻逼了都想到鸽笼原理的怎么就不分块呢 ……  \nT2 我原本想到的子任务 2 的树形 DP 是对的，没时间写了啊 …… QAQ\n\n发现又是就我分低，这是三题签到分啊，又要 Fe 滚粗了么 XD\n\n晚上他们都去 THU 看智能体大赛了，然而我表示并不想去，就会酒店找湖北的小伙伴玩了 QwQ  \n和 Fuxey 和 Sengxian 他们聊了一晚上，十一点多才回去 …… qwq  \nSengxian 表示他才是**真·签到分**，46.38 分 23333\n\n### 5.8\n听课。\n\n上午讲物理引擎 …… smg …… 拿出笔记本电脑准备写 sui 给我讲的题 …… 诶怎么开不了机 ……  \nmdzz …… 昨晚忘关机了，没电了 XD\n\n于是 Fancy 把笔记本电脑借给了我，写了一上午的题，还是没调出来 ……  \n下午还是听不懂课，继续调题 …… 然而 Fancy 的电脑也没电了 XD\n\n晚上闭幕式 …… Cu 线好低，46 分就有 ……\n\n回到酒店又被青岛二中的拐走了，zdw1999 竟然也被拐过去了 qvq  \n打了两局保皇 ……\n\n于是又去找 HA 的小伙伴了 …… 刚进房间大家都很兴奋的样子 …… ~~这是要搞个大新闻？~~\n\n~~（由于某些原因，此处删除若干字）~~\n\n然后继续调今天上午写的题，过了样例，交到 COGS 上，WWTTTTTTTT，弃疗 ……\n\n最后帮 Fancy 搞了搞 Ubuntu 下的指纹识别，KZ 表示也要我帮他弄弄，然而已经快十二点了 …… XD\n\n### 5.9\n早上八点去次饭，get 成就 最后一个走出食堂 23333\n\n晚上的火车，于是先在酒店待了一上午 ……\n\n考虑到车站环境并不太好，又在酒店大厅里待了一下午 …… qwq\n\n晚上就要坐车回去咯 ……\n\n再见 ……\n","slug":"ctsc-apio-2016","published":1,"updated":"2016-05-10T08:34:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdccb00ly7gxl7bb483dh"},{"title":"「CQOI2016」手机号码 - 数位DP","date":"2016-04-21T15:31:24.000Z","_content":"\n工具需要检测的号码特征有两个：号码中要出现至少 $ 3 $ 个相邻的相同数字，号码中不能同时出现 $ 8 $ 和 $ 4 $。号码必须同时包含两个特征才满足条件。满足条件的号码例如：$ 3000988721 $、$ 23333333333 $、$ 14444101000 $。而不满足条件的号码例如：$ 1015400080 $、$ 10010012022 $。\n\n手机号码一定是 $ 11 $ 位数，前不含前导的 $ 0 $。工具接收两个数 $ L $ 和 $ R $，自动统计出 $ [L, R] $ 区间内所有满足条件的号码数量。$ L $ 和 $ R $ 也是 $ 11 $ 位的手机号码。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### 题解\n设 $ F(x) $ 表示小于等于 $ x $ 的电话号码中合法的数量，$ F(R) - F(L - 1) $ 即为答案。\n\n计算 $ F(x) $ 时枚举最高位，使用数位 DP，状态为：\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n从前到后依次表示：还剩几位、最高位最大是几（$ 10 $ 表示从这一位开始均不限制）、上一位是几、上一位与上上一位是否相等、是否已有三个相邻的相同数字、是否已有 $ 4 $、是否已有 $ 8 $。\n\n转移时，枚举最高位上的数，如果最高位 $ < limit $，则之后的位上的数的大小均无限制。如果上上一位于上一位相等且当前位于上一位相等，认为已有三个相邻的相同数字。\n\n每次数位 DP 的时间复杂度为 $ O(10 ^ 4 * 2 ^ 4) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-number.md","raw":"title: 「CQOI2016」手机号码 - 数位DP\ndate: 2016-04-21 23:31:24\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - 数位DP\n  - DP\npermalink: cqoi2016-number\n---\n\n工具需要检测的号码特征有两个：号码中要出现至少 $ 3 $ 个相邻的相同数字，号码中不能同时出现 $ 8 $ 和 $ 4 $。号码必须同时包含两个特征才满足条件。满足条件的号码例如：$ 3000988721 $、$ 23333333333 $、$ 14444101000 $。而不满足条件的号码例如：$ 1015400080 $、$ 10010012022 $。\n\n手机号码一定是 $ 11 $ 位数，前不含前导的 $ 0 $。工具接收两个数 $ L $ 和 $ R $，自动统计出 $ [L, R] $ 区间内所有满足条件的号码数量。$ L $ 和 $ R $ 也是 $ 11 $ 位的手机号码。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### 题解\n设 $ F(x) $ 表示小于等于 $ x $ 的电话号码中合法的数量，$ F(R) - F(L - 1) $ 即为答案。\n\n计算 $ F(x) $ 时枚举最高位，使用数位 DP，状态为：\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n从前到后依次表示：还剩几位、最高位最大是几（$ 10 $ 表示从这一位开始均不限制）、上一位是几、上一位与上上一位是否相等、是否已有三个相邻的相同数字、是否已有 $ 4 $、是否已有 $ 8 $。\n\n转移时，枚举最高位上的数，如果最高位 $ < limit $，则之后的位上的数的大小均无限制。如果上上一位于上一位相等且当前位于上一位相等，认为已有三个相邻的相同数字。\n\n每次数位 DP 的时间复杂度为 $ O(10 ^ 4 * 2 ^ 4) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-number","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdccf00m57gxlybq5nazi"},{"title":"「CQOI2016」不同的最小割 - 分治 + 网络流","date":"2016-04-21T10:57:52.000Z","_content":"\n对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $ s $，$ t $ 不在同一个部分中，则称这个划分是关于 $ s $，$ t $ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $ s $，$ t $ 的最小割指的是在关于 $ s $，$ t $ 的割中容量最小的割。\n\n考虑有 $ N $ 个点的无向连通图中所有点对的最小割的容量，共能得到 $ \\frac{N(N − 1)}{2} $个数值。这些数值中互不相同的有多少个呢？\n\n<!-- more -->\n\n### 链接\n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### 题解\n首先从所有点中，任选两个点 $ s $、$ t $ 做最小割，可以得到 $ S $ 和 $ T $ 两个集合。\n\n然后从 $ S $ 集合（$ T $ 集合对应相同）中任选一个点 $ u $，做 $ s $ 和 $ u $ 的最小割（全局），得到两个集合 $ S' $、$ T' $，取出 $ S $ 和 $ S' $ 的交集，作为新的集合递归下去。直到集合中只剩下一个点为止。\n\n上述操作共进行了 $ N - 1 $ 次，所得的所有最小割容量中不同的数量即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-cuts.md","raw":"title: 「CQOI2016」不同的最小割 - 分治 + 网络流\ndate: 2016-04-21 18:57:52\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - 网络流\n  - Dinic\n  - 分治\npermalink: cqoi2016-cuts\n---\n\n对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $ s $，$ t $ 不在同一个部分中，则称这个划分是关于 $ s $，$ t $ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $ s $，$ t $ 的最小割指的是在关于 $ s $，$ t $ 的割中容量最小的割。\n\n考虑有 $ N $ 个点的无向连通图中所有点对的最小割的容量，共能得到 $ \\frac{N(N − 1)}{2} $个数值。这些数值中互不相同的有多少个呢？\n\n<!-- more -->\n\n### 链接\n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### 题解\n首先从所有点中，任选两个点 $ s $、$ t $ 做最小割，可以得到 $ S $ 和 $ T $ 两个集合。\n\n然后从 $ S $ 集合（$ T $ 集合对应相同）中任选一个点 $ u $，做 $ s $ 和 $ u $ 的最小割（全局），得到两个集合 $ S' $、$ T' $，取出 $ S $ 和 $ S' $ 的交集，作为新的集合递归下去。直到集合中只剩下一个点为止。\n\n上述操作共进行了 $ N - 1 $ 次，所得的所有最小割容量中不同的数量即为答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-cuts","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdccj00mc7gxl2myyavig"},{"title":"组合数学学习笔记","date":"2016-03-15T09:16:12.000Z","_content":"\n计数原理、排列、组合、递推关系、等差数列求和公式、自然数平方和公式、二项式定理。\n\n<!-- more -->\n\n### 计数原理\n#### 加法原理\n做一件事有 $ n $ 种途径，每种途径有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### 乘法原理\n做一件事有 $ n $ 个步骤，每个步骤有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### 容斥原理\n统计多个集合的并的元素数量：先加上所有集合的元素的元素数量，再减去『多加的』每两个集合相交的元素数量，再加上『多减的』每三个集合相交的元素数量 ……\n\n即等式左边是多个集合的并的元素数量，等式右边每一项是几个几何的交的元素数量，每一项的符号取决于元素数量的奇偶。\n\n### 排列\n#### 全排列\n把 $ n $ 个元素按照不同顺序排列，设总方案数为 $ f(n) $（定义 $ f(0) = 1 $），考虑第一个元素摆放的位置，得出公式\n\n$$ f(n) = f(n - 1) * n $$\n\n即 $ f(n) = n! $。\n\n#### 普通排列\n从 $ n $ 个元素中取 $ k $ 个，按照不同顺序排列，设总方案数为 $ P(n, k) $，每次选一个数，第一次有 $ n $ 种选择，第二次有 $ n - 1 $ 种选择，直到第 $ k $ 次有 $ n - k + 1 $ 种选择，即\n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n将上式与 $ n! $ 对比，缺少 $ n - k $ 及之后的项，即\n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### 有重复元素的全排列\n从 $ k $ 种元素，第 $ i $ 种有 $ n_i $ 个，设 $ n = \\sum\\limits_{i = 1}^{k}n_i $，为了保证答案不重复，可以先求出 $ n! $，再除去每种元素重复的情况，即\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### 组合\n#### 组合数\n从 n 个元素中选择 k 个，顺序无关，设总方案数为 $ C(n, k) $。把排列数 $ P(n, k) $ 看做先从 n 各种选择 k 个元素，再对 k 个元素做全排列，即\n\n$$ P(n, k) = C(n, k) * k! $$\n\n移项得\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### 组合数的性质\n$ C(n, 0) = C(n, n) = 1 $ 全选或全不选只有一种方案。\n\n$ C(n, k) = C(n, n - k) $ 选择 $ k $ 个拿走相当于选择 $ n - k $ 个留下。\n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ 考虑最后一个选还是不选（Pascal 公式，常用来递推计算组合数表）。\n\n#### 可重复选择的组合\n从 n 种无限多的元素中选择 k 个，共有 $ C(n + k - 1, k) $ 种方案。\n\n#### 组合数的计算\n##### 组合数表\n用 Pascal 公式递推，组合数太大要开高精度或者取模。\n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### 单个计算\n书上有用 `double` 来算的，因为中间乘法 `long long` 可能会溢出，不知道那样会不会损失精度。\n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### 递推关系\n#### Fibonacci 数列\n楼梯上共有 $ n $ 个台阶，一次可以走一个或两个，总方案数为\n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n边界为\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan 数\n给定一个凸 $ n $ 边形，用 $ n - 3 $ 条不相交的直线将它剖分成 $ n - 2 $ 个三角形，设方案总数为 $ f(n) $。\n\n对每个顶点编号，第 $ i $ 个顶点编号为 $ V_i $。作三角形 $ {V_1}{V_k}{V_n} $（$ 1 \\lt k \\lt n $），该三角形左边是一个 $ k $ 边形，右边是一个 $ n - k + 1 $ 边形，即\n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### 公式\n#### 等差数列\n设数列 $ \\{ a_1, a_2, \\cdots, a_n \\} $ 对于任意的 $ 1 \\lt i \\leq n $ 满足 $ a_t - a_{i - 1} = d $，则有\n\n$$ a_i = a_i + (i - 1)d $$\n\n求和公式为\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### 自然数平方和\n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n不会证。\n\n#### 二项式定理\n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","source":"_posts/combinatorics-notes.md","raw":"title: 组合数学学习笔记\ncategories: OI\ntags: \n  - 数学\n  - 组合数学\n  - 学习笔记\n  - 算法模板  \npermalink: combinatorics-notes\ndate: 2016-03-15 17:16:12\n---\n\n计数原理、排列、组合、递推关系、等差数列求和公式、自然数平方和公式、二项式定理。\n\n<!-- more -->\n\n### 计数原理\n#### 加法原理\n做一件事有 $ n $ 种途径，每种途径有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### 乘法原理\n做一件事有 $ n $ 个步骤，每个步骤有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### 容斥原理\n统计多个集合的并的元素数量：先加上所有集合的元素的元素数量，再减去『多加的』每两个集合相交的元素数量，再加上『多减的』每三个集合相交的元素数量 ……\n\n即等式左边是多个集合的并的元素数量，等式右边每一项是几个几何的交的元素数量，每一项的符号取决于元素数量的奇偶。\n\n### 排列\n#### 全排列\n把 $ n $ 个元素按照不同顺序排列，设总方案数为 $ f(n) $（定义 $ f(0) = 1 $），考虑第一个元素摆放的位置，得出公式\n\n$$ f(n) = f(n - 1) * n $$\n\n即 $ f(n) = n! $。\n\n#### 普通排列\n从 $ n $ 个元素中取 $ k $ 个，按照不同顺序排列，设总方案数为 $ P(n, k) $，每次选一个数，第一次有 $ n $ 种选择，第二次有 $ n - 1 $ 种选择，直到第 $ k $ 次有 $ n - k + 1 $ 种选择，即\n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n将上式与 $ n! $ 对比，缺少 $ n - k $ 及之后的项，即\n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### 有重复元素的全排列\n从 $ k $ 种元素，第 $ i $ 种有 $ n_i $ 个，设 $ n = \\sum\\limits_{i = 1}^{k}n_i $，为了保证答案不重复，可以先求出 $ n! $，再除去每种元素重复的情况，即\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### 组合\n#### 组合数\n从 n 个元素中选择 k 个，顺序无关，设总方案数为 $ C(n, k) $。把排列数 $ P(n, k) $ 看做先从 n 各种选择 k 个元素，再对 k 个元素做全排列，即\n\n$$ P(n, k) = C(n, k) * k! $$\n\n移项得\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### 组合数的性质\n$ C(n, 0) = C(n, n) = 1 $ 全选或全不选只有一种方案。\n\n$ C(n, k) = C(n, n - k) $ 选择 $ k $ 个拿走相当于选择 $ n - k $ 个留下。\n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ 考虑最后一个选还是不选（Pascal 公式，常用来递推计算组合数表）。\n\n#### 可重复选择的组合\n从 n 种无限多的元素中选择 k 个，共有 $ C(n + k - 1, k) $ 种方案。\n\n#### 组合数的计算\n##### 组合数表\n用 Pascal 公式递推，组合数太大要开高精度或者取模。\n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### 单个计算\n书上有用 `double` 来算的，因为中间乘法 `long long` 可能会溢出，不知道那样会不会损失精度。\n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### 递推关系\n#### Fibonacci 数列\n楼梯上共有 $ n $ 个台阶，一次可以走一个或两个，总方案数为\n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n边界为\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan 数\n给定一个凸 $ n $ 边形，用 $ n - 3 $ 条不相交的直线将它剖分成 $ n - 2 $ 个三角形，设方案总数为 $ f(n) $。\n\n对每个顶点编号，第 $ i $ 个顶点编号为 $ V_i $。作三角形 $ {V_1}{V_k}{V_n} $（$ 1 \\lt k \\lt n $），该三角形左边是一个 $ k $ 边形，右边是一个 $ n - k + 1 $ 边形，即\n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### 公式\n#### 等差数列\n设数列 $ \\{ a_1, a_2, \\cdots, a_n \\} $ 对于任意的 $ 1 \\lt i \\leq n $ 满足 $ a_t - a_{i - 1} = d $，则有\n\n$$ a_i = a_i + (i - 1)d $$\n\n求和公式为\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### 自然数平方和\n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n不会证。\n\n#### 二项式定理\n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","slug":"combinatorics-notes","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcco00mk7gxlj0psr7st"},{"title":"「COGS 746」骑士共存 - 二分图最大独立集","id":"53","updated":"2016-02-19T03:44:48.000Z","date":"2016-02-19T03:43:42.000Z","_content":"\n在一个 $ N * N $ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。问最多可以在棋盘上放多少个其实。\n\n<!-- more -->\n\n### 链接\n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### 题解\n在题图中可以发现，每个马可以攻击的格子都在与自身颜色不同的格子上，即整个棋盘可以建立为二分图，并使能互相攻击到的格子位于不同的两列。\n\n> 根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n> 建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n> ——摘自《「COGS 734」方格取数 - 二分图最大独立集》\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-746.md","raw":"title: 「COGS 746」骑士共存 - 二分图最大独立集\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\n  - 最大独立集\npermalink: cogs-746\nid: 53\nupdated: '2016-02-19 11:44:48'\ndate: 2016-02-19 11:43:42\n---\n\n在一个 $ N * N $ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。问最多可以在棋盘上放多少个其实。\n\n<!-- more -->\n\n### 链接\n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### 题解\n在题图中可以发现，每个马可以攻击的格子都在与自身颜色不同的格子上，即整个棋盘可以建立为二分图，并使能互相攻击到的格子位于不同的两列。\n\n> 根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n> 建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n> ——摘自《「COGS 734」方格取数 - 二分图最大独立集》\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-746","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdccr00mq7gxlc2znhshh"},{"title":"「COGS 742」深海机器人 - 费用流","id":"58","updated":"2016-02-23T13:44:58.000Z","date":"2016-02-23T13:44:06.000Z","_content":"\n有多个深海机器人到达深海海底后离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n<!-- more -->\n\n### 链接\n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### 题解\n最大费用最大流建模，从源点向每个起点连一条边，流量为出发的机器人数量，费用为零；从每个终点向汇点连一条边，流量为到达的机器人数量，费用为零；把每个格点看做点，从每个格点向其东边、北边各连**两条**边，第一条容量为 1，费用为生物标本价值的相反数（保证第一个通过的机器人取走标本），另一条容量为正无穷，费用为 0（保证多个机器人可占据同一位置，并且路径可重叠）。\n\n计算坐标是个大坑。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-742.md","raw":"title: 「COGS 742」深海机器人 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - Edmonds-Karp\n  - 网络流 24 题\n  - 图论\n  - 网络流\n  - 费用流\npermalink: cogs-742\nid: 58\nupdated: '2016-02-23 21:44:58'\ndate: 2016-02-23 21:44:06\n---\n\n有多个深海机器人到达深海海底后离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n<!-- more -->\n\n### 链接\n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### 题解\n最大费用最大流建模，从源点向每个起点连一条边，流量为出发的机器人数量，费用为零；从每个终点向汇点连一条边，流量为到达的机器人数量，费用为零；把每个格点看做点，从每个格点向其东边、北边各连**两条**边，第一条容量为 1，费用为生物标本价值的相反数（保证第一个通过的机器人取走标本），另一条容量为正无穷，费用为 0（保证多个机器人可占据同一位置，并且路径可重叠）。\n\n计算坐标是个大坑。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-742","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdccy00mz7gxl4b36ljo9"},{"title":"「COGS 741」负载平衡 - 费用流","id":"61","updated":"2016-02-25T07:38:10.000Z","date":"2016-02-25T07:37:15.000Z","_content":"\nG 公司有 `n` 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 `n` 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。\n\n<!-- more -->\n\n### 链接\n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### 题解\n这道题猛地看上去有点像之前写过的一道贪心 —— 均分纸牌，那道题只要把每一个数减去平均数，然后从左到右累加，特判一下零就好。但这题难点在于是环形的。\n\n首先，还是要将每个仓库中的库存数量减去平均数，目标便转化为把正数全部加到负数中。『只能在相邻的仓库之间搬运』这一条件，让人很容易想到在相邻仓库之间连边，但稍微思考一下就会发现这样是不行的，因为有时候需要将货物重复移动多次才能到达目的仓库。\n\n不妨只考虑最终的结果 —— 正数最后都要被移动到负数里面。在相邻的仓库之间转移，单位代价是 1，则隔着多个位置的仓库之间转移的代价就是**两间仓库的最短距离**，环中两点的最短路只有两种情况，顺时针走或者逆时针走，预处理出来就好。\n\n从源点向每个库存量为正数的点连一条边，容量为库存量，费用为 0；从每个库存量为负数的点向汇点连一条边，容量为库存量的相反数，费用为 0；从每个库存量为正数的点向每个库存量为负数的点连一条边，容量为正无穷，费用为**两间仓库的最短距离**，求出最小费用最大流，则费用即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-741.md","raw":"title: 「COGS 741」负载平衡 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流 24 题\n  - Edmonds-Karp\n  - 费用流\npermalink: cogs-741\nid: 61\nupdated: '2016-02-25 15:38:10'\ndate: 2016-02-25 15:37:15\n---\n\nG 公司有 `n` 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 `n` 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。\n\n<!-- more -->\n\n### 链接\n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### 题解\n这道题猛地看上去有点像之前写过的一道贪心 —— 均分纸牌，那道题只要把每一个数减去平均数，然后从左到右累加，特判一下零就好。但这题难点在于是环形的。\n\n首先，还是要将每个仓库中的库存数量减去平均数，目标便转化为把正数全部加到负数中。『只能在相邻的仓库之间搬运』这一条件，让人很容易想到在相邻仓库之间连边，但稍微思考一下就会发现这样是不行的，因为有时候需要将货物重复移动多次才能到达目的仓库。\n\n不妨只考虑最终的结果 —— 正数最后都要被移动到负数里面。在相邻的仓库之间转移，单位代价是 1，则隔着多个位置的仓库之间转移的代价就是**两间仓库的最短距离**，环中两点的最短路只有两种情况，顺时针走或者逆时针走，预处理出来就好。\n\n从源点向每个库存量为正数的点连一条边，容量为库存量，费用为 0；从每个库存量为负数的点向汇点连一条边，容量为库存量的相反数，费用为 0；从每个库存量为正数的点向每个库存量为负数的点连一条边，容量为正无穷，费用为**两间仓库的最短距离**，求出最小费用最大流，则费用即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-741","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcd300n77gxl0q7qp4zz"},{"title":"「COGS 740」分配问题 - 二分图最大权匹配","id":"60","updated":"2016-02-25T00:10:00.000Z","date":"2016-02-25T00:08:29.000Z","_content":"\n有 `n` 件工作要分配给 `n` 个人做。第 `i` 个人做第 `j` 件工作产生的效益为 `c[i][j]`。试设计一个将 `n` 件工作分配给 `n` 个人做的分配方案，使产生的总效益最大。\n\n<!-- more -->\n\n### 链接\n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### 题解\n把工作和人放在网络流模型中，可以发现这是一张二分图，问题转化为从图中选取一些边，使这些边没有交点（没有人做重复的工作，没有工作被重复做），并且边权总和最大。即**二分图最大权匹配**。\n\n建立源点与汇点，从源点向每个人连一条边，容量为 1（每个人只能匹配一次），费用为 0；从每个工作到汇点连一条边，容量为 1（每个工作只能匹配一次），费用为 0；从每个人向每个工作连一条边，容量为 0，费用为效益的相反数。求出网络的最小费用最大流，所得费用的相反数即为最大权匹配。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","source":"_posts/cogs-740.md","raw":"title: 「COGS 740」分配问题 - 二分图最大权匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流 24 题\n  - Edmonds-Karp\n  - 费用流\n  - 二分图匹配\npermalink: cogs-740\nid: 60\nupdated: '2016-02-25 08:10:00'\ndate: 2016-02-25 08:08:29\n---\n\n有 `n` 件工作要分配给 `n` 个人做。第 `i` 个人做第 `j` 件工作产生的效益为 `c[i][j]`。试设计一个将 `n` 件工作分配给 `n` 个人做的分配方案，使产生的总效益最大。\n\n<!-- more -->\n\n### 链接\n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### 题解\n把工作和人放在网络流模型中，可以发现这是一张二分图，问题转化为从图中选取一些边，使这些边没有交点（没有人做重复的工作，没有工作被重复做），并且边权总和最大。即**二分图最大权匹配**。\n\n建立源点与汇点，从源点向每个人连一条边，容量为 1（每个人只能匹配一次），费用为 0；从每个工作到汇点连一条边，容量为 1（每个工作只能匹配一次），费用为 0；从每个人向每个工作连一条边，容量为 0，费用为效益的相反数。求出网络的最小费用最大流，所得费用的相反数即为最大权匹配。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","slug":"cogs-740","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcd900nf7gxlmfuiuwnz"},{"title":"「COGS 739」运输问题 - 费用流","id":"57","updated":"2016-02-23T12:35:48.000Z","date":"2016-02-20T13:37:35.000Z","_content":"\nW 公司有 `m` 个仓库和 `n` 个零售商店。第 `i` 个仓库有 $ a_i $ 个货物，第 `j` 个商店需要 $ b_j $ 个货物，从第 `i` 个仓库运输到第 `j` 个零售商店的费用为 $ c_{ij} $，要将所有货物运到商店，最小费用是多少？\n\n<!-- more -->\n\n### 链接\n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### 题解\n裸费用流。\n\n从源点向每个仓库连接一条边，容量为仓库的货物数量；从每个商店向汇点连一条边，容量为商店需要的货物数量；在每一对仓库和商店之间连接一条边，容量为无穷大，费用为运输费用。分别求出最大、最小费用最大流就是答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-739.md","raw":"title: 「COGS 739」运输问题 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 网络流 24 题\npermalink: cogs-739\nid: 57\nupdated: '2016-02-23 20:35:48'\ndate: 2016-02-20 21:37:35\n---\n\nW 公司有 `m` 个仓库和 `n` 个零售商店。第 `i` 个仓库有 $ a_i $ 个货物，第 `j` 个商店需要 $ b_j $ 个货物，从第 `i` 个仓库运输到第 `j` 个零售商店的费用为 $ c_{ij} $，要将所有货物运到商店，最小费用是多少？\n\n<!-- more -->\n\n### 链接\n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### 题解\n裸费用流。\n\n从源点向每个仓库连接一条边，容量为仓库的货物数量；从每个商店向汇点连一条边，容量为商店需要的货物数量；在每一对仓库和商店之间连接一条边，容量为无穷大，费用为运输费用。分别求出最大、最小费用最大流就是答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-739","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcde00no7gxlbuz36g9x"},{"title":"「COGS 738」数字梯形 - 费用流","id":"52","updated":"2016-02-19T03:35:21.000Z","date":"2016-02-19T03:33:27.000Z","_content":"\n一个数字梯形，共有 `n` 行，第一行有 `m` 个数字，每一行都比上一行多一个数字。从第一行的每一个数字开始，每一次向左下方或左上方走，直到最后一行，有以下三种规则：\n\n1. 任意两条路径没有公共部分；\n2. 任意两条路径只能在点（数字）上有公共部分，不能在边（数字与数字之间）上有公共部分；\n3. 任意两条路径可以在点上或边上有公共部分。\n\n求分别在这三种规则下的路径所经过数字总和的最大值。\n\n<!-- more -->\n\n### 链接\n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### 题解\n因为是从第一行走到最后一行，对于路径有限制，并且最大化总和，所以考虑费用流建模。\n\n将每个数字拆成两个点，中间一条边容量为 1，费用为该数字的相反数；从源点到第一行每个数字的入点连一条边，容量为 1，费用为 0；从最后一行每个数字的出点向汇点连一条边，容量为 1，费用为 1；对于除最后一行外的每个数字，从其出点向其下方两个数字的入点分别连一条边，容量为 1，费用为 0。求出网络的最小费用最大流，则结果费用的相反数即为第一问答案。\n\n有了第一问的基础，后面两问就比较容易了，第二问因为可以在数字上重复，就把每个数字的入点和出点之间的边容量改为正无穷，把指向汇点的边容量也改为正无穷；第三问因为可以在边上重复，就在第二问的基础上把每个数字的出点向下方连接的两条边容量改为正无穷。\n\n一定要注意，计算网络流节点编号要用**梯形面积公式**，设源点 `s` 的编号为 0，则对数字进行拆点后所得的点数量为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $，即汇点的编号为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-738.md","raw":"title: 「COGS 738」数字梯形 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 网络流 24 题\npermalink: cogs-738\nid: 52\nupdated: '2016-02-19 11:35:21'\ndate: 2016-02-19 11:33:27\n---\n\n一个数字梯形，共有 `n` 行，第一行有 `m` 个数字，每一行都比上一行多一个数字。从第一行的每一个数字开始，每一次向左下方或左上方走，直到最后一行，有以下三种规则：\n\n1. 任意两条路径没有公共部分；\n2. 任意两条路径只能在点（数字）上有公共部分，不能在边（数字与数字之间）上有公共部分；\n3. 任意两条路径可以在点上或边上有公共部分。\n\n求分别在这三种规则下的路径所经过数字总和的最大值。\n\n<!-- more -->\n\n### 链接\n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### 题解\n因为是从第一行走到最后一行，对于路径有限制，并且最大化总和，所以考虑费用流建模。\n\n将每个数字拆成两个点，中间一条边容量为 1，费用为该数字的相反数；从源点到第一行每个数字的入点连一条边，容量为 1，费用为 0；从最后一行每个数字的出点向汇点连一条边，容量为 1，费用为 1；对于除最后一行外的每个数字，从其出点向其下方两个数字的入点分别连一条边，容量为 1，费用为 0。求出网络的最小费用最大流，则结果费用的相反数即为第一问答案。\n\n有了第一问的基础，后面两问就比较容易了，第二问因为可以在数字上重复，就把每个数字的入点和出点之间的边容量改为正无穷，把指向汇点的边容量也改为正无穷；第三问因为可以在边上重复，就在第二问的基础上把每个数字的出点向下方连接的两条边容量改为正无穷。\n\n一定要注意，计算网络流节点编号要用**梯形面积公式**，设源点 `s` 的编号为 0，则对数字进行拆点后所得的点数量为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $，即汇点的编号为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-738","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcdi00nw7gxlwmrid2b6"},{"title":"「COGS 734」方格取数 - 二分图最大独立集","id":"51","updated":"2016-02-15T09:03:18.000Z","date":"2016-02-15T09:02:01.000Z","_content":"\n在一个有 $ M * N $ 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大。\n\n<!-- more -->\n\n### 链接\n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### 题解\n任意两个数所在的方格没有公共边，考虑把所有的格子建成图，不能同时选择的点之间两两连边，求出一个点权和最大的子图（最大独立集），其和即为答案。\n\n进一步分析，发现这个图是一个二分图 —— 因为每个点只会和**棋盘中与其相邻的点**连边。\n\n根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n建立二分图模型的时候注意细节。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-734.md","raw":"title: 「COGS 734」方格取数 - 二分图最大独立集\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\n  - 最大独立集\npermalink: cogs-734\nid: 51\nupdated: '2016-02-15 17:03:18'\ndate: 2016-02-15 17:02:01\n---\n\n在一个有 $ M * N $ 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大。\n\n<!-- more -->\n\n### 链接\n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### 题解\n任意两个数所在的方格没有公共边，考虑把所有的格子建成图，不能同时选择的点之间两两连边，求出一个点权和最大的子图（最大独立集），其和即为答案。\n\n进一步分析，发现这个图是一个二分图 —— 因为每个点只会和**棋盘中与其相邻的点**连边。\n\n根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n建立二分图模型的时候注意细节。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-734","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcdl00o47gxlcumk9pto"},{"title":"「COGS 731」最长递增子序列 - 线性DP + 网络流","id":"48","updated":"2016-02-09T06:40:10.000Z","date":"2016-02-09T06:37:32.000Z","_content":"\n给定正整数序列 `X1 ~ Xn`。\n\n1. 计算其最长递增子序列的长度 `s`。\n2. 计算从给定的序列中最多可取出多少个长度为 `s` 的递增子序列。\n3. 如果允许在取出的序列中多次使用 `X1` 和 `Xn`，则从给定序列中最多可取出多少个长度为 `s` 的递增子序列。\n\n<!-- more -->\n\n### 链接\n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### 题解\n首先，重要的事情说三遍：**非严格递增！非严格递增！非严格递增！**\n\n设以 $X_i$ 结尾的最长递增子序列长度为 $F_i$，用动态规划求出每个 $F_i$，最大的一个就是第一问答案，设它为 $K$。\n\n第二问采用网络流建模：\n\n1. 对于每个满足 $F_i = K$ 的点，从该点向汇点连一条边，容量为 1；\n2. 对于每个满足 $F_i = 1$ 的点，从源点向该点连一条边，容量为 1；\n3. 对于第一问中每一次所有的有效状态转移（即满足$ X_j≤X_i $且$F_i=F_j+1$的点对 `i`、`j`）从 `j` 向 `i` 连一条边，容量为 1。\n\n求出最大流即为答案。\n\n但是这样做有个问题，某一个点可能被使用所次，不符合题目要求。解决方法是把每一个点 `i` 拆成两个点 `i` 和 `i'`，所有进入该点的边连接 `i`，所有出该点边从 `i'` 连出，并从 `i` 到 `i'` 连接一条容量为 1 的边，保证了流过每个点的流量最多为 1。\n\n第三问只需要在第二问的基础上做出一些修改，把所有与 `1`、`n` 两个点相关的边容量改为无穷大，就可以使这两个数“可多次使用”。\n\n**注意特判**，如果输入进来的是一个严格递降序列，答案就是 1、N、N。从这里我们可以看出细节的重要性以及出题人的恶意。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-731.md","raw":"title: 「COGS 731」最长递增子序列 - 线性DP + 网络流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\npermalink: cogs-731\nid: 48\nupdated: '2016-02-09 14:40:10'\ndate: 2016-02-09 14:37:32\n---\n\n给定正整数序列 `X1 ~ Xn`。\n\n1. 计算其最长递增子序列的长度 `s`。\n2. 计算从给定的序列中最多可取出多少个长度为 `s` 的递增子序列。\n3. 如果允许在取出的序列中多次使用 `X1` 和 `Xn`，则从给定序列中最多可取出多少个长度为 `s` 的递增子序列。\n\n<!-- more -->\n\n### 链接\n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### 题解\n首先，重要的事情说三遍：**非严格递增！非严格递增！非严格递增！**\n\n设以 $X_i$ 结尾的最长递增子序列长度为 $F_i$，用动态规划求出每个 $F_i$，最大的一个就是第一问答案，设它为 $K$。\n\n第二问采用网络流建模：\n\n1. 对于每个满足 $F_i = K$ 的点，从该点向汇点连一条边，容量为 1；\n2. 对于每个满足 $F_i = 1$ 的点，从源点向该点连一条边，容量为 1；\n3. 对于第一问中每一次所有的有效状态转移（即满足$ X_j≤X_i $且$F_i=F_j+1$的点对 `i`、`j`）从 `j` 向 `i` 连一条边，容量为 1。\n\n求出最大流即为答案。\n\n但是这样做有个问题，某一个点可能被使用所次，不符合题目要求。解决方法是把每一个点 `i` 拆成两个点 `i` 和 `i'`，所有进入该点的边连接 `i`，所有出该点边从 `i'` 连出，并从 `i` 到 `i'` 连接一条容量为 1 的边，保证了流过每个点的流量最多为 1。\n\n第三问只需要在第二问的基础上做出一些修改，把所有与 `1`、`n` 两个点相关的边容量改为无穷大，就可以使这两个数“可多次使用”。\n\n**注意特判**，如果输入进来的是一个严格递降序列，答案就是 1、N、N。从这里我们可以看出细节的重要性以及出题人的恶意。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-731","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcdq00oc7gxlxzzeaaro"},{"title":"「COGS 729」圆桌聚餐 - 网络流","id":"47","updated":"2016-02-09T06:41:05.000Z","date":"2016-02-09T05:42:59.000Z","_content":"\n假设有来自 `m` 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 `ri`。会议餐厅共有 `n` 张餐桌，每张餐桌可容纳 `ci` 个代表就餐。\n\n为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。\n\n<!-- more -->\n\n### 链接\n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### 题解\n问题的关键就是：\n\n**每个单位最多有一个人做到一张单独的餐桌上！**\n\n进行网络流建模，建立源点 `S`，由 `S` 向每个代表单位的点连一条边，容量为单位人数；建立汇点 `T`，由每个代表餐桌的点向 `T` 连一条边，容量为餐桌容纳人数；分别从每个单位向所有餐桌连一条边，容量为 `1`。\n\n然后求出最大流，如果最大流小于所有单位人数总和，那么问题无解，否则有解，即所有由单位指向餐桌的边构成了一组解。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-729.md","raw":"title: 「COGS 729」圆桌聚餐 - 网络流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流 24 题\n  - Dinic\npermalink: cogs-729\nid: 47\nupdated: '2016-02-09 14:41:05'\ndate: 2016-02-09 13:42:59\n---\n\n假设有来自 `m` 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 `ri`。会议餐厅共有 `n` 张餐桌，每张餐桌可容纳 `ci` 个代表就餐。\n\n为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。\n\n<!-- more -->\n\n### 链接\n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### 题解\n问题的关键就是：\n\n**每个单位最多有一个人做到一张单独的餐桌上！**\n\n进行网络流建模，建立源点 `S`，由 `S` 向每个代表单位的点连一条边，容量为单位人数；建立汇点 `T`，由每个代表餐桌的点向 `T` 连一条边，容量为餐桌容纳人数；分别从每个单位向所有餐桌连一条边，容量为 `1`。\n\n然后求出最大流，如果最大流小于所有单位人数总和，那么问题无解，否则有解，即所有由单位指向餐桌的边构成了一组解。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-729","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcdz00oj7gxlha5tnnx3"},{"title":"「COGS 728」最小路径覆盖问题 - 二分图匹配","id":"45","updated":"2016-02-06T14:53:58.000Z","date":"2016-02-06T14:52:12.000Z","_content":"\n给定有向图 $G=(V,E)$ 。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。P 中路径可以从 V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。\n\n设计一个有效算法求一个有向无环图 G 的最小路径覆盖。\n\n<!-- more -->\n\n### 链接\n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### 题解\n用最少的路径覆盖所有的点。先从最简单的图开始，如果图中没有边，那么每个点都是一条独立的路径；如果添加一条边进去，那么需要的路径数量就减小 1；如果再添加一条边进去，并且这条边与上一条边有相同起点或终点的话，那么这条边对答案是没有贡献的，如果这条边与上一条边首尾相接或者不相交的话，那么需要的路径数量减小 1。\n\n综上所述，问题转化为，从一个有向无环图中选出尽量多的边，使任意两条边没有相同起点或终点。\n\n进一步将问题转化为二分图匹配，将每个点拆成左右两个，对于原图中任意一条有向边 `(u, v)`，在新图中将左边的 `u` 和右边的 `v` 连接，然后求出最大匹配，用总点数减去最大匹配就是答案。\n\n输出方案嘛，只要枚举起点然后沿着匹配边向下搜就好咯 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-728.md","raw":"title: 「COGS 728」最小路径覆盖问题 - 二分图匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 二分图匹配\n  - 网络流 24 题\npermalink: cogs-728\nid: 45\nupdated: '2016-02-06 22:53:58'\ndate: 2016-02-06 22:52:12\n---\n\n给定有向图 $G=(V,E)$ 。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。P 中路径可以从 V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。\n\n设计一个有效算法求一个有向无环图 G 的最小路径覆盖。\n\n<!-- more -->\n\n### 链接\n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### 题解\n用最少的路径覆盖所有的点。先从最简单的图开始，如果图中没有边，那么每个点都是一条独立的路径；如果添加一条边进去，那么需要的路径数量就减小 1；如果再添加一条边进去，并且这条边与上一条边有相同起点或终点的话，那么这条边对答案是没有贡献的，如果这条边与上一条边首尾相接或者不相交的话，那么需要的路径数量减小 1。\n\n综上所述，问题转化为，从一个有向无环图中选出尽量多的边，使任意两条边没有相同起点或终点。\n\n进一步将问题转化为二分图匹配，将每个点拆成左右两个，对于原图中任意一条有向边 `(u, v)`，在新图中将左边的 `u` 和右边的 `v` 连接，然后求出最大匹配，用总点数减去最大匹配就是答案。\n\n输出方案嘛，只要枚举起点然后沿着匹配边向下搜就好咯 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-728","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdce300oq7gxlcsx4a32s"},{"title":"「COGS 727」太空飞行计划 - 最大权闭合图","id":"49","updated":"2016-02-15T00:45:03.000Z","date":"2016-02-15T00:39:38.000Z","_content":"\nW 教授正在为国家航天中心计划一系列的太空飞行。可供选择的实验集合为 $ E = \\{ E1, E2, …, Em \\} $，这些实验需要使用的全部仪器的集合为 $ I = \\{ I1, I2, …, In \\} $。实验 $ E_j $ 需要用到的仪器是 $ R_j∈I $。仪器 $ I_k $ 的费用为 $ c_k $。实验 $ E_j $ 的赞助商为该实验结果支付 $ p_j $。设计方案使收益最大。 \n\n<!-- more -->\n\n### 链接\n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### 题解\n首先，这个问题抽象出来是一个『最大权闭合图』问题 —— 把每个实验作为点，权值为获利；把每个仪器作为点，权值为费用的**相反数**，求出一个点权和最大的子图，使这个子图中的每个点的所有出边指向的点都在这个子图中。特殊的，这个子图可以为空。\n\n根据胡伯涛的论文，最大权闭合图可以用最小割模型来求解：添加源点和汇点，对于原图中的每个**正权点**，连接一条从源点流向该点的边，容量为权值；对于原图中的每个**负权点**，连接一条从该点流向汇点的边，容量为权值的**绝对值**；对于原图中的每一条有向边，对应在网络中连接一条容量为正无穷的边。求出该网络的最小割，割边中所有边一定是从源点连接到一个正权点或从一个负权点连到汇点，这些与割边相连的正权点是**不选择**的点，与割边相连的负权点是**选择**的负权点。\n\n重点来说下怎么求最小割，用 Dinic 求出最大流之后，在**包含反向边**的残量网络中沿着**不满流**的边进行 BFS，将遍历到的点做上标记。BFS 结束后，所有有标记的点组成 `S` 集合，无标记的点组成 `T` 集合。枚举每条边，所有跨越了 `S` 和 `T` 集合的边组成了最小割。\n\n得到不选择的正权点之后，用 `std::set_difference` 求出与所有正权点的差集就是选择的正权点。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-727.md","raw":"title: 「COGS 727」太空飞行计划 - 最大权闭合图\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流 24 题\n  - 最大权闭合图\npermalink: cogs-727\nid: 49\nupdated: '2016-02-15 08:45:03'\ndate: 2016-02-15 08:39:38\n---\n\nW 教授正在为国家航天中心计划一系列的太空飞行。可供选择的实验集合为 $ E = \\{ E1, E2, …, Em \\} $，这些实验需要使用的全部仪器的集合为 $ I = \\{ I1, I2, …, In \\} $。实验 $ E_j $ 需要用到的仪器是 $ R_j∈I $。仪器 $ I_k $ 的费用为 $ c_k $。实验 $ E_j $ 的赞助商为该实验结果支付 $ p_j $。设计方案使收益最大。 \n\n<!-- more -->\n\n### 链接\n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### 题解\n首先，这个问题抽象出来是一个『最大权闭合图』问题 —— 把每个实验作为点，权值为获利；把每个仪器作为点，权值为费用的**相反数**，求出一个点权和最大的子图，使这个子图中的每个点的所有出边指向的点都在这个子图中。特殊的，这个子图可以为空。\n\n根据胡伯涛的论文，最大权闭合图可以用最小割模型来求解：添加源点和汇点，对于原图中的每个**正权点**，连接一条从源点流向该点的边，容量为权值；对于原图中的每个**负权点**，连接一条从该点流向汇点的边，容量为权值的**绝对值**；对于原图中的每一条有向边，对应在网络中连接一条容量为正无穷的边。求出该网络的最小割，割边中所有边一定是从源点连接到一个正权点或从一个负权点连到汇点，这些与割边相连的正权点是**不选择**的点，与割边相连的负权点是**选择**的负权点。\n\n重点来说下怎么求最小割，用 Dinic 求出最大流之后，在**包含反向边**的残量网络中沿着**不满流**的边进行 BFS，将遍历到的点做上标记。BFS 结束后，所有有标记的点组成 `S` 集合，无标记的点组成 `T` 集合。枚举每条边，所有跨越了 `S` 和 `T` 集合的边组成了最小割。\n\n得到不选择的正权点之后，用 `std::set_difference` 求出与所有正权点的差集就是选择的正权点。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-727","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdce800oy7gxlgb8vnyq2"},{"title":"「COGS 439」软件补丁 - 记忆化搜索 + 位运算","id":"50","updated":"2016-02-15T02:17:27.000Z","date":"2016-02-15T02:13:28.000Z","_content":"\n现在有一个软件，共有 `n` 个 BUG，开发人员开发了 `m` 个补丁，每个补丁有一个应用条件，要求某些 BUG 比如存在，某些 BUG 可以不存在，某些 BUG 存在或不存在都可以；每个补丁有一个影响，会使某些 BUG 消失，会使某些 BUG 产生；每个 BUG 有一个应用时间。问修复所有 BUG 需要的最短时间为多少。\n\n<!-- more -->\n\n### 链接\n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### 题解\n记录状态：用一个 `unsigned int` 类型的数记录状态，从右边数第 `i` 个二进制位表示第 `i` 个 BUG 是否存在。用 `std::tr1::unordered_map`（哈希表）存储状态到所有时间的映射，即 `map[status]` 表示从初始状态到状态 `status` 所用的最短时间。\n\n状态转移：每个补丁存储两个值 `effectAddition`、`effectSubtract`，前者表示应用该补丁后新增加的 BUG，后者表示减少的 BUG，则状态转移为：\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n一个难点在于怎样判断补丁的应用条件，「某些 BUG 存在或不存在都可以」是难以用位运算来体现的（或者说我不会），所以我们可以把这种情况转化为「某些 BUG 必须存在」，然后在判断条件时先将当前状态加上那些「可有可无」的 BUG，然后继续判断。\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n话说其实这道题暴力表示状态，一位一位地判断、转移也可以过的，而且照样是 COGS 上提交记录第一 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 吐槽\n又是一道不是网络流但被放进「网络流 24 题」里的~~水~~题。","source":"_posts/cogs-439.md","raw":"title: 「COGS 439」软件补丁 - 记忆化搜索 + 位运算\ncategories: OI\ntags: \n  - 搜索\n  - 记忆化搜索\n  - 位运算\n  - COGS\n  - 网络流 24 题\n  - map\npermalink: cogs-439\nid: 50\nupdated: '2016-02-15 10:17:27'\ndate: 2016-02-15 10:13:28\n---\n\n现在有一个软件，共有 `n` 个 BUG，开发人员开发了 `m` 个补丁，每个补丁有一个应用条件，要求某些 BUG 比如存在，某些 BUG 可以不存在，某些 BUG 存在或不存在都可以；每个补丁有一个影响，会使某些 BUG 消失，会使某些 BUG 产生；每个 BUG 有一个应用时间。问修复所有 BUG 需要的最短时间为多少。\n\n<!-- more -->\n\n### 链接\n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### 题解\n记录状态：用一个 `unsigned int` 类型的数记录状态，从右边数第 `i` 个二进制位表示第 `i` 个 BUG 是否存在。用 `std::tr1::unordered_map`（哈希表）存储状态到所有时间的映射，即 `map[status]` 表示从初始状态到状态 `status` 所用的最短时间。\n\n状态转移：每个补丁存储两个值 `effectAddition`、`effectSubtract`，前者表示应用该补丁后新增加的 BUG，后者表示减少的 BUG，则状态转移为：\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n一个难点在于怎样判断补丁的应用条件，「某些 BUG 存在或不存在都可以」是难以用位运算来体现的（或者说我不会），所以我们可以把这种情况转化为「某些 BUG 必须存在」，然后在判断条件时先将当前状态加上那些「可有可无」的 BUG，然后继续判断。\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n话说其实这道题暴力表示状态，一位一位地判断、转移也可以过的，而且照样是 COGS 上提交记录第一 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 吐槽\n又是一道不是网络流但被放进「网络流 24 题」里的~~水~~题。","slug":"cogs-439","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcec00p67gxlw71boa6p"},{"title":"「COGS 396」魔术球问题 - 贪心","id":"46","updated":"2016-02-06T15:04:22.000Z","date":"2016-02-06T15:02:55.000Z","_content":"\n假设有 `n` 根柱子，现要按下述规则在这n根柱子中依次放入编号为 1，2，3，4 ...... 的球。\n\n1. 每次只能在某根柱子的最上面放球；\n2. 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 `n` 根柱子上最多能放多少个球。\n\n<!-- more -->\n\n### 链接\n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### 题解\n放球的两个条件很显然，在上面放再多的球是不影响下面的。并且，某个球放在哪一根柱子上，只会影响其之上的球的编号，而不会影响全局的球总数。\n\n所以可以使用贪心解决：策略是，先从一个柱子开始，每次枚举所有柱子，只要某个柱子能放就放上去，然后继续放下一个；直到所有的柱子不能放当前的球，则添加一个柱子；最后不能在添加时，就是最优解。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-396.md","raw":"title: 「COGS 396」魔术球问题 - 贪心\ncategories: OI\ntags: \n  - COGS\n  - 贪心\n  - 网络流 24 题\npermalink: cogs-396\nid: 46\nupdated: '2016-02-06 23:04:22'\ndate: 2016-02-06 23:02:55\n---\n\n假设有 `n` 根柱子，现要按下述规则在这n根柱子中依次放入编号为 1，2，3，4 ...... 的球。\n\n1. 每次只能在某根柱子的最上面放球；\n2. 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 `n` 根柱子上最多能放多少个球。\n\n<!-- more -->\n\n### 链接\n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### 题解\n放球的两个条件很显然，在上面放再多的球是不影响下面的。并且，某个球放在哪一根柱子上，只会影响其之上的球的编号，而不会影响全局的球总数。\n\n所以可以使用贪心解决：策略是，先从一个柱子开始，每次枚举所有柱子，只要某个柱子能放就放上去，然后继续放下一个；直到所有的柱子不能放当前的球，则添加一个柱子；最后不能在添加时，就是最优解。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-396","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcei00pg7gxlfl997cn6"},{"title":"「COGS 14」搭配飞行员 - 二分图匹配","id":"44","updated":"2016-02-06T14:22:28.000Z","date":"2016-02-06T14:21:18.000Z","_content":"\n从一个二分图中选出尽量多的边，使得任意两条边没有公共点。\n\n<!-- more -->\n\n### 链接\n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### 题解\n二分图匹配，可以用匈牙利~~也可以用带花树~~，然而我不会写。\n\n所以要把二分图最大匹配转化成最大流 …… \n\n设二分图左右两列分别为 `X` 和 `Y`，建立超级源点 `S`，从 `S` 向 `X` 中的每个点连一条边，容量为 `1`，建立超级汇点 `T`，从 `Y` 中的每个点向 `T` 连一条边，容量为 `1`。最后对于原图的每一条边 `(u, v)`（假设 `u` 在左侧 `v` 在右侧），连接一条由 `u` 指向 `v` 的**有向**边，容量为 `1`。然后跑一遍最大流就是最大匹配啦！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-14.md","raw":"title: 「COGS 14」搭配飞行员 - 二分图匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 二分图匹配\n  - 网络流 24 题\npermalink: cogs-14\nid: 44\nupdated: '2016-02-06 22:22:28'\ndate: 2016-02-06 22:21:18\n---\n\n从一个二分图中选出尽量多的边，使得任意两条边没有公共点。\n\n<!-- more -->\n\n### 链接\n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### 题解\n二分图匹配，可以用匈牙利~~也可以用带花树~~，然而我不会写。\n\n所以要把二分图最大匹配转化成最大流 …… \n\n设二分图左右两列分别为 `X` 和 `Y`，建立超级源点 `S`，从 `S` 向 `X` 中的每个点连一条边，容量为 `1`，建立超级汇点 `T`，从 `Y` 中的每个点向 `T` 连一条边，容量为 `1`。最后对于原图的每一条边 `(u, v)`（假设 `u` 在左侧 `v` 在右侧），连接一条由 `u` 指向 `v` 的**有向**边，容量为 `1`。然后跑一遍最大流就是最大匹配啦！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-14","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcem00pl7gxl8o65x5ay"},{"title":"「CodeVS 3269」混合背包 - 背包DP","id":"3","updated":"2016-01-19T13:08:13.000Z","date":"2015-11-22T21:00:15.000Z","_content":"\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> 1）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 题解\n混合三种背包问题，很经典的一个问题。  \n首先分开考虑这三种背包问题的解法。  \n使用动态规划，用 `f[v]` 表示把所有物品按要求装入一个体积为 `v` （`v` <= `V`）的背包时，装入背包内物品总价值的最大值。    \n首先，对于 01 背包，显而易见其方程为：\n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n实现代码（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n特别注意第二层循环枚举 `v` 时的顺序，`v` 必须从 `V` 到 `0` 循环，因为当前 `f[v]` 要根据一个当 `v` 更小时的 `f[v]` 推出（为了腾出大小为 `Vi` 的空间防第 `i` 件物品），保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**没有尝试过**放置第 `i` 件物品时的状态。  \n\n对于完全背包，我们可以将其每件拆分成 `V` / `Vi` 件 `01` 背包物品，对每件物品进行一次 01 背包处理。但显然这样做效率会很低。  \n考虑到完全背包与 01 背包的不同点，仅在于 01 背包每种物品**只能放置一次**，而完全背包可以放置**任意次**，将其体现在动态规划的状态转移上，即完全背包问题，需要保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**已经尝试过**放置第 `i` 件物品时的状态。而只需将第二层循环 `v` 的遍历顺序改为从 `0` 到 `V` 即可。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n这两段代码的差异比较难理解，这里举个例子：背包容量 `V = 10`，仅有一件物品体积 `Vi = 3`，价值 `Wi = 5`，现将这件物品尝试放入背包。  \n\n如果这件物品是 `01` 背包：  \n当 `v = 10` 时，**`f[v - Vi] = f[7] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 9` 时，`f[v - Vi] = f[6] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 8` 时，`f[v - Vi] = f[5] = 0`，`f[v]` 被更新为 `5`。  \n**当 `v = 7` 时，`f[v - Vi] = f[4] = 0`，`f[v]` 被更新为 `5`。**  \n……  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 3` 时，`f[v - Vi] = f[0] = 0`，`f[v]` 被更新为 `5`。  \n\n如果这件物品是完全背包：  \n当 `v = 3` 时，**`f[v - Vi] = f[0] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n……  \n**当 `v = 6` 时，`f[v - Vi] = f[3] = 5`，`f[v]` 被更新为 `10`。**  \n……  \n**当 `v = 9` 时，`f[v - Vi] = f[6] = 10`，`f[v]` 被更新为 `15`。**  \n当 `v = 10` 时，`f[v - Vi] = f[7] = 10`，`f[v]` 被更新为 `15`。  \n\n以上例子可以体现出 01 背包与完全背包解法上的区别与问题实质的联系。  \n\n回到原来的话题上来，我们已经解决了前两类问题——01 背包和完全背包，现在来看多重背包。  \n还是考虑拆分，把一件可以装 `Mi` 次的多重背包物品拆分成 `Mi` 件 01 背包物品，分别对其进行 01 背包处理。这种方法很好理解，但时间复杂度达到了$O(V*{\\Sigma}Mi)$，考虑将其优化。  \n我们采用类似二进制的思想，将每个多重背包物品拆分为 `t` 个不同的 01 背包物品，每一个拆分后的物品都有一个系数 `k`，该物品的体积和价值分别等于**原物品的体积和价值乘以这个系数**，并且使所有拆分后的物品的系数之和${\\Sigma}k = Mi$，即原物品最多被放置的次数。并且要使每个系数 `k` 分别为 $1$,$2$,$4$,…,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$。  \n举个例子，当 `Mi = 17` 时，将其拆成 `5` 件物品，系数 `k` 分别为 `1`,`2`,`4`,`8`,`2`。  \n使用二进制思想优化过的算法，复杂度降为了$O(V * {\\Sigma}{\\log}Wi)$。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j 将 1 按二进制位左移 j 位，快速计算 2 的 j 次方\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { // 如果不能 2 的幂作为系数将原物品完全拆分，则多拆分出一件物品 k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n三种背包问题的思路明确后，就可以考虑混合背包问题了，具体实现方法是对于每一种物品，判断物品类型，分别进行处理。  \n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### 吐槽\n这段时间在学习 dp，听 liujz 学长讲完后自己抱着书啃了好久 ……  \n算是有些理解了吧 >_<\n","source":"_posts/codevs-3269.md","raw":"title: 「CodeVS 3269」混合背包 - 背包DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 背包DP\npermalink: codevs-3269\nid: 3\nupdated: '2016-01-19 21:08:13'\ndate: 2015-11-23 05:00:15\n---\n\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> 1）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 题解\n混合三种背包问题，很经典的一个问题。  \n首先分开考虑这三种背包问题的解法。  \n使用动态规划，用 `f[v]` 表示把所有物品按要求装入一个体积为 `v` （`v` <= `V`）的背包时，装入背包内物品总价值的最大值。    \n首先，对于 01 背包，显而易见其方程为：\n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n实现代码（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n特别注意第二层循环枚举 `v` 时的顺序，`v` 必须从 `V` 到 `0` 循环，因为当前 `f[v]` 要根据一个当 `v` 更小时的 `f[v]` 推出（为了腾出大小为 `Vi` 的空间防第 `i` 件物品），保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**没有尝试过**放置第 `i` 件物品时的状态。  \n\n对于完全背包，我们可以将其每件拆分成 `V` / `Vi` 件 `01` 背包物品，对每件物品进行一次 01 背包处理。但显然这样做效率会很低。  \n考虑到完全背包与 01 背包的不同点，仅在于 01 背包每种物品**只能放置一次**，而完全背包可以放置**任意次**，将其体现在动态规划的状态转移上，即完全背包问题，需要保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**已经尝试过**放置第 `i` 件物品时的状态。而只需将第二层循环 `v` 的遍历顺序改为从 `0` 到 `V` 即可。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n这两段代码的差异比较难理解，这里举个例子：背包容量 `V = 10`，仅有一件物品体积 `Vi = 3`，价值 `Wi = 5`，现将这件物品尝试放入背包。  \n\n如果这件物品是 `01` 背包：  \n当 `v = 10` 时，**`f[v - Vi] = f[7] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 9` 时，`f[v - Vi] = f[6] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 8` 时，`f[v - Vi] = f[5] = 0`，`f[v]` 被更新为 `5`。  \n**当 `v = 7` 时，`f[v - Vi] = f[4] = 0`，`f[v]` 被更新为 `5`。**  \n……  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 3` 时，`f[v - Vi] = f[0] = 0`，`f[v]` 被更新为 `5`。  \n\n如果这件物品是完全背包：  \n当 `v = 3` 时，**`f[v - Vi] = f[0] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n……  \n**当 `v = 6` 时，`f[v - Vi] = f[3] = 5`，`f[v]` 被更新为 `10`。**  \n……  \n**当 `v = 9` 时，`f[v - Vi] = f[6] = 10`，`f[v]` 被更新为 `15`。**  \n当 `v = 10` 时，`f[v - Vi] = f[7] = 10`，`f[v]` 被更新为 `15`。  \n\n以上例子可以体现出 01 背包与完全背包解法上的区别与问题实质的联系。  \n\n回到原来的话题上来，我们已经解决了前两类问题——01 背包和完全背包，现在来看多重背包。  \n还是考虑拆分，把一件可以装 `Mi` 次的多重背包物品拆分成 `Mi` 件 01 背包物品，分别对其进行 01 背包处理。这种方法很好理解，但时间复杂度达到了$O(V*{\\Sigma}Mi)$，考虑将其优化。  \n我们采用类似二进制的思想，将每个多重背包物品拆分为 `t` 个不同的 01 背包物品，每一个拆分后的物品都有一个系数 `k`，该物品的体积和价值分别等于**原物品的体积和价值乘以这个系数**，并且使所有拆分后的物品的系数之和${\\Sigma}k = Mi$，即原物品最多被放置的次数。并且要使每个系数 `k` 分别为 $1$,$2$,$4$,…,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$。  \n举个例子，当 `Mi = 17` 时，将其拆成 `5` 件物品，系数 `k` 分别为 `1`,`2`,`4`,`8`,`2`。  \n使用二进制思想优化过的算法，复杂度降为了$O(V * {\\Sigma}{\\log}Wi)$。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j 将 1 按二进制位左移 j 位，快速计算 2 的 j 次方\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { // 如果不能 2 的幂作为系数将原物品完全拆分，则多拆分出一件物品 k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n三种背包问题的思路明确后，就可以考虑混合背包问题了，具体实现方法是对于每一种物品，判断物品类型，分别进行处理。  \n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### 吐槽\n这段时间在学习 dp，听 liujz 学长讲完后自己抱着书啃了好久 ……  \n算是有些理解了吧 >_<\n","slug":"codevs-3269","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcer00pt7gxl6tghvzfo"},{"title":"「CodeVS 3269」混合背包 - 背包DP + 单调队列","id":"23","updated":"2016-01-19T13:03:26.000Z","date":"2016-01-14T21:47:45.000Z","_content":"\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> `1`）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 题解\n01 和完全这两种之前写过，这里就重点说说怎么用单调队列来解多重。\n\n首先，对于多重背包的每件物品，`n` 表示这件物品的数量，`w` 表示这件物品的体积，`c` 表示这件物品的价值。\n\n朴素的多重背包状态转移方程为：\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n设 $r=i ~~ \\% ~~ c$，$m=i ~~ / ~~ c$。\n\n`m` 的意义为，如果当前状态的背包容量全部用来放当前物品，能放多少件。  \n`r` 的意义为，如果当前状态的背包容量全部用来放当前物品，则剩下的容量是多少。\n\n到此，我们可以修改一下方程，使原来的枚举 `i` 变为先枚举 `r`，然后在 $[0,m]$ 上枚举 `d`，以 $(m-d)*c+r$代替原来的 `i`。\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n令\n\n$$ k=m-d $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n进一步化为\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n令\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n由此得到一个可以用单调队列优化的方程，结合方程我们知道，$ f[k*c+r] $是由之前的 `n + 1` 项的最大值推出的，于是用一个长度为 `n + 1` 的单调队列维护 $g(k,r)$，就可以 $O(1)$ 地求出每个状态。\n\n需要注意的是，在使用单调队列实现这个算法时，方程中的 `m` 应该被替换为当前状态对应的 `k`，因为枚举的 `k` 总是当前状态的**背包容量全部用来放当前物品的最大件数**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```","source":"_posts/codevs-3269-monotone-queue.md","raw":"title: 「CodeVS 3269」混合背包 - 背包DP + 单调队列\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 单调队列\n  - 背包DP\npermalink: codevs-3269-monotone-queue\nid: 23\nupdated: '2016-01-19 21:03:26'\ndate: 2016-01-15 05:47:45\n---\n\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> `1`）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 题解\n01 和完全这两种之前写过，这里就重点说说怎么用单调队列来解多重。\n\n首先，对于多重背包的每件物品，`n` 表示这件物品的数量，`w` 表示这件物品的体积，`c` 表示这件物品的价值。\n\n朴素的多重背包状态转移方程为：\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n设 $r=i ~~ \\% ~~ c$，$m=i ~~ / ~~ c$。\n\n`m` 的意义为，如果当前状态的背包容量全部用来放当前物品，能放多少件。  \n`r` 的意义为，如果当前状态的背包容量全部用来放当前物品，则剩下的容量是多少。\n\n到此，我们可以修改一下方程，使原来的枚举 `i` 变为先枚举 `r`，然后在 $[0,m]$ 上枚举 `d`，以 $(m-d)*c+r$代替原来的 `i`。\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n令\n\n$$ k=m-d $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n进一步化为\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n令\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n由此得到一个可以用单调队列优化的方程，结合方程我们知道，$ f[k*c+r] $是由之前的 `n + 1` 项的最大值推出的，于是用一个长度为 `n + 1` 的单调队列维护 $g(k,r)$，就可以 $O(1)$ 地求出每个状态。\n\n需要注意的是，在使用单调队列实现这个算法时，方程中的 `m` 应该被替换为当前状态对应的 `k`，因为枚举的 `k` 总是当前状态的**背包容量全部用来放当前物品的最大件数**。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```","slug":"codevs-3269-monotone-queue","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdceu00py7gxlxv0q8tbq"},{"title":"「CodeVS 3168 / 3162」抄书问题 - 划分DP / 二分答案","id":"14","updated":"2016-01-06T13:03:26.000Z","date":"2016-01-05T21:47:45.000Z","_content":"\n把 `M` 本有顺序的书分给 `K` 个人抄写，每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的（比如不能把第一、第三、第四本数给同一个人抄写）。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3162 - 抄书问题](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 - 抄书问题 3](http://codevs.cn/problem/3168/)\n\n### 划分DP\n考虑用动态规划求出最短时间，以 $a[m]$ 表示第 `m` 本书的页数，$f[m][k]$ 表示前 `m` 本书给前 `k` 个人抄需要的最短时间。\n\n边界条件为：\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n转移方程为：\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n即，枚举第 `k` 个人抄的书数，从“前面 `k - 1` 个人每人只抄一本，剩下的全留给第 `k` 个人”到“前面 `k - 1` 个人一共抄 `m - 1` 本，给第 `k` 个人留一本”，并上第 `k` 个人抄的时间，取最小值。\n\n求书本页数的区间和可以用一个前缀和数组来优化时间复杂度，故该算法时间复杂度为 $O(km^2)$。\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### 二分答案\n加大后的数据量已不能使用 DP 的方法，考虑对最短时间在**最大页数**到**总页数**之间进行二分，检验过程**贪心**枚举每一本书，从最后一个人开始，如果当前的人还能抄就给他抄，否则给前一个人抄，如果最后能抄完则可行。\n\n时间复杂度为 $O(m{\\log}m)$。\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### 方案输出\n输出方案算是这题最难的地方。~~才不会告诉你们我 WA 了 8 次呢！~~\n\n和二分答案求最短时间的思路相似，贪心枚举每本书，从最后一个人开始（注意题目要求前面的人少抄），如果当前人还能抄，就给他抄，否则给下一个人抄，**如果剩余人的数量大于剩余书的数量，则无论如何都要给下一个人抄（后面的全给抄完了咱前面的吵啥啊）**。\n\n输出顺序可以用一个栈来调整。\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n### 代码（划分DP，CodeVS 3162）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### 代码（二分答案，CodeVS 3162，CodeVS 3168）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3168-3162.md","raw":"title: 「CodeVS 3168 / 3162」抄书问题 - 划分DP / 二分答案\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 二分答案\n  - 划分DP\n  - 贪心\npermalink: codevs-3168-3162\nid: 14\nupdated: '2016-01-06 21:03:26'\ndate: 2016-01-06 05:47:45\n---\n\n把 `M` 本有顺序的书分给 `K` 个人抄写，每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的（比如不能把第一、第三、第四本数给同一个人抄写）。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。\n\n<!-- more -->\n\n### 链接\n[CodeVS 3162 - 抄书问题](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 - 抄书问题 3](http://codevs.cn/problem/3168/)\n\n### 划分DP\n考虑用动态规划求出最短时间，以 $a[m]$ 表示第 `m` 本书的页数，$f[m][k]$ 表示前 `m` 本书给前 `k` 个人抄需要的最短时间。\n\n边界条件为：\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n转移方程为：\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n即，枚举第 `k` 个人抄的书数，从“前面 `k - 1` 个人每人只抄一本，剩下的全留给第 `k` 个人”到“前面 `k - 1` 个人一共抄 `m - 1` 本，给第 `k` 个人留一本”，并上第 `k` 个人抄的时间，取最小值。\n\n求书本页数的区间和可以用一个前缀和数组来优化时间复杂度，故该算法时间复杂度为 $O(km^2)$。\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### 二分答案\n加大后的数据量已不能使用 DP 的方法，考虑对最短时间在**最大页数**到**总页数**之间进行二分，检验过程**贪心**枚举每一本书，从最后一个人开始，如果当前的人还能抄就给他抄，否则给前一个人抄，如果最后能抄完则可行。\n\n时间复杂度为 $O(m{\\log}m)$。\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### 方案输出\n输出方案算是这题最难的地方。~~才不会告诉你们我 WA 了 8 次呢！~~\n\n和二分答案求最短时间的思路相似，贪心枚举每本书，从最后一个人开始（注意题目要求前面的人少抄），如果当前人还能抄，就给他抄，否则给下一个人抄，**如果剩余人的数量大于剩余书的数量，则无论如何都要给下一个人抄（后面的全给抄完了咱前面的吵啥啊）**。\n\n输出顺序可以用一个栈来调整。\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n### 代码（划分DP，CodeVS 3162）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### 代码（二分答案，CodeVS 3162，CodeVS 3168）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","slug":"codevs-3168-3162","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcey00q47gxlyypavzj4"},{"title":"「CodeVS 2822」爱在心中 - 强联通分量","date":"2016-03-04T02:47:42.000Z","_content":"\n在爱的国度里有 N 个人，在他们的心中都有着一个爱的名单，上面记载着他所爱的人（不会出现自爱的情况）。爱是具有传递性的，即如果 A 爱 B，B 爱 C，则 A 也爱 C。\n\n如果有这样一部分人，他们彼此都相爱，则他们就超越了一切的限制，用集体的爱化身成为一个爱心天使。现在，我们想知道在这个爱的国度里会出现多少爱心天使。而且，如果某个爱心天使被其他所有人或爱心天使所爱则请输出这个爱心天使是由哪些人构成的，否则输出 -1。\n\n<!-- more -->\n\n### 链接\n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### 题解\n第一问很明显的，求出图中有多少不是单点的强联通分量就是答案。\n\n第二问，把每个强联通分量缩成一个点，重新构图，如果新图中有出度为零的点，则该点对应的原图中的点集即为第二问答案。注意排除一个点情况。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/codevs-2822.md","raw":"title: 「CodeVS 2822」爱在心中 - 强联通分量\ncategories: OI\ntags: \n  - CodeVS\n  - 图论\n  - Tarjan\n  - 强联通分量\n  - 缩点\npermalink: codevs-2822\ndate: 2016-03-04 10:47:42\n---\n\n在爱的国度里有 N 个人，在他们的心中都有着一个爱的名单，上面记载着他所爱的人（不会出现自爱的情况）。爱是具有传递性的，即如果 A 爱 B，B 爱 C，则 A 也爱 C。\n\n如果有这样一部分人，他们彼此都相爱，则他们就超越了一切的限制，用集体的爱化身成为一个爱心天使。现在，我们想知道在这个爱的国度里会出现多少爱心天使。而且，如果某个爱心天使被其他所有人或爱心天使所爱则请输出这个爱心天使是由哪些人构成的，否则输出 -1。\n\n<!-- more -->\n\n### 链接\n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### 题解\n第一问很明显的，求出图中有多少不是单点的强联通分量就是答案。\n\n第二问，把每个强联通分量缩成一个点，重新构图，如果新图中有出度为零的点，则该点对应的原图中的点集即为第二问答案。注意排除一个点情况。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"codevs-2822","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcf300qb7gxlbk259ooz"},{"title":"「CodeVS 2598」编辑距离问题 - 线性DP","id":"17","updated":"2016-01-19T13:05:21.000Z","date":"2016-01-08T21:32:19.000Z","_content":"\n设 A 和 B 是 2 个字符串。要用最少的字符操作将字符串 A 转换为字符串 B。这里所说的字符操作包括：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n求将字符串 A 变换为字符串 B 所用的最少字符操作数，即 A 到 B 的编辑距离。\n\n字符串 A、B 的长度均不超过4000。\n\n<!-- more -->\n\n### 链接\n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### 题解\n字符串的题乍一看都很恶心，但这道题仔细想想还是很简单的。\n用 `f[i][j]` 表示字符串 A 的前 `i` 个字符到字符串 B 的前 `j` 个字符的编辑距离，则转移方程为：\n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i] ≠ B[j]} $$\n\n当 $ A[i]=B[j] $ 时，当前位置无需编辑，直接等于上一位的编辑距离。\n\n当 $ A[i]≠B[j] $ 时，有三种情况：\n\n1. 字符串 B 的前 `j` 位可由 $A[i]$ 编辑到 $B[j-1]$ 后插入 B 的第 `j` 个字符得到。\n2. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j]$ 后删除 A 的第 `i` 个字符得到。\n3. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j-1]$ 后修改 A 的第 `i` 个字符为 B 的第 `j` 个字符得到。\n\n### 代码\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```","source":"_posts/codevs-2598.md","raw":"title: 「CodeVS 2598」编辑距离问题 - 线性DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 字符串\n  - 线性DP\npermalink: codevs-2598\nid: 17\nupdated: '2016-01-19 21:05:21'\ndate: 2016-01-09 05:32:19\n---\n\n设 A 和 B 是 2 个字符串。要用最少的字符操作将字符串 A 转换为字符串 B。这里所说的字符操作包括：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n求将字符串 A 变换为字符串 B 所用的最少字符操作数，即 A 到 B 的编辑距离。\n\n字符串 A、B 的长度均不超过4000。\n\n<!-- more -->\n\n### 链接\n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### 题解\n字符串的题乍一看都很恶心，但这道题仔细想想还是很简单的。\n用 `f[i][j]` 表示字符串 A 的前 `i` 个字符到字符串 B 的前 `j` 个字符的编辑距离，则转移方程为：\n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i] ≠ B[j]} $$\n\n当 $ A[i]=B[j] $ 时，当前位置无需编辑，直接等于上一位的编辑距离。\n\n当 $ A[i]≠B[j] $ 时，有三种情况：\n\n1. 字符串 B 的前 `j` 位可由 $A[i]$ 编辑到 $B[j-1]$ 后插入 B 的第 `j` 个字符得到。\n2. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j]$ 后删除 A 的第 `i` 个字符得到。\n3. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j-1]$ 后修改 A 的第 `i` 个字符为 B 的第 `j` 个字符得到。\n\n### 代码\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```","slug":"codevs-2598","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcf600qi7gxljb852cwb"},{"title":"「CodeVS 1563」奶牛的交通 - 网络流","id":"42","updated":"2016-02-06T14:23:12.000Z","date":"2016-02-05T13:06:41.000Z","_content":"\n给出一个无向图，问最少割掉多少个点使 `s` 点与 `t` 点不连通。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[洛谷 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### 题解\n首先，这题一看就是最小割，由最小割最大流定理得，求出最大流就是最小割。\n\n怎么流？\n\n一般的网络流，流量都在边上，求出的割也是割的边 …… 而我们这次需要割点，那就拆点呀！\n\n把每个点拆成 `i` 和 `i'` 两个点，`i` 表示进入这个点，`i'` 表示离开这个点。由 `i` 向 `i'` 连接一条有向边，容量为 1。对于原图中任意一条有向边 `(i, j)`，连接 `(i', j)`，容量为正无穷。\n\n于是就完成了喜闻乐见的建模，求出 `s'` 到 `t` （想一想为什么不是 `s` 到 `t'`？）的最大流就是答案啦！\n\n###代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1563.md","raw":"title: 「CodeVS 1563」奶牛的交通 - 网络流\ncategories: OI\ntags: \n  - CodeVS\n  - 网络流\n  - Dinic\n  - 图论\npermalink: codevs-1563\nid: 42\nupdated: '2016-02-06 22:23:12'\ndate: 2016-02-05 21:06:41\n---\n\n给出一个无向图，问最少割掉多少个点使 `s` 点与 `t` 点不连通。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[洛谷 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### 题解\n首先，这题一看就是最小割，由最小割最大流定理得，求出最大流就是最小割。\n\n怎么流？\n\n一般的网络流，流量都在边上，求出的割也是割的边 …… 而我们这次需要割点，那就拆点呀！\n\n把每个点拆成 `i` 和 `i'` 两个点，`i` 表示进入这个点，`i'` 表示离开这个点。由 `i` 向 `i'` 连接一条有向边，容量为 1。对于原图中任意一条有向边 `(i, j)`，连接 `(i', j)`，容量为正无穷。\n\n于是就完成了喜闻乐见的建模，求出 `s'` 到 `t` （想一想为什么不是 `s` 到 `t'`？）的最大流就是答案啦！\n\n###代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","slug":"codevs-1563","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcfa00qp7gxl63jk5htk"},{"title":"「CodeVS 1345」饥饿的奶牛 - 线性DP","id":"21","updated":"2016-01-19T13:04:02.000Z","date":"2016-01-13T21:17:18.000Z","_content":"\n在 `n`（≤ 1000）条线段中选出若干条，保证任意两条线段没有公共点（端点也不能重合），使总长度最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### 题解\n刚开始确实晕了，又是想线段树又是想背包 ……\n\n保证线段不重合是个难点 …… 解决方法以线段的右端点排序，**去除后效性**。\n\n以 $ f[i] $ 表示前 `i` 条线段中选出若干条（必选第 `i` 条）的最大总长度，则转移方程为：\n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n简单地说，就是只要**保证最后一条线段不与当前线段重合**，就可以添加当前线段。\n\n注意最终答案是 $ max\\{f[i],i{\\in}[1,n]\\} $，而不一定是 $f[n]$，因为不选最后一条线段可能比选最后一条线段更优。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/codevs-1345.md","raw":"title: 「CodeVS 1345」饥饿的奶牛 - 线性DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 线性DP\npermalink: codevs-1345\nid: 21\nupdated: '2016-01-19 21:04:02'\ndate: 2016-01-14 05:17:18\n---\n\n在 `n`（≤ 1000）条线段中选出若干条，保证任意两条线段没有公共点（端点也不能重合），使总长度最大。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### 题解\n刚开始确实晕了，又是想线段树又是想背包 ……\n\n保证线段不重合是个难点 …… 解决方法以线段的右端点排序，**去除后效性**。\n\n以 $ f[i] $ 表示前 `i` 条线段中选出若干条（必选第 `i` 条）的最大总长度，则转移方程为：\n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n简单地说，就是只要**保证最后一条线段不与当前线段重合**，就可以添加当前线段。\n\n注意最终答案是 $ max\\{f[i],i{\\in}[1,n]\\} $，而不一定是 $f[n]$，因为不选最后一条线段可能比选最后一条线段更优。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"codevs-1345","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcfe00qv7gxlr6haopbr"},{"title":"主席树学习笔记","date":"2016-05-11T13:06:00.000Z","_content":"\n主席树是一种数据结构，其主要应用是区间第 $ k $ 大问题。\n\n<!-- more -->\n\n### 权值线段树\n传统的线段树用于维护一条线段上的区间，可以方便地查询区间信息。而如果将线段树转化为『权值线段树』，每个叶子节点存储某个元素出现次数，一条线段的总和表示区间内所有数出现次数的总和。\n\n利用权值线段树可以方便地求出整体第 $ k $ 大 —— 从根节点向下走，如果 $ k $ 小于等于左子树大小，说明第 $ k $ 大在左子树的区间中，在左子树中继续查找即可；否则，说明第 $ k $ 大在右子树的区间中，此时将 $ k $ 减去左子树大小，并在右子树中继续查找。\n\n查找过程类似平衡树，时间复杂度为 $ O(\\log n) $。\n\n### 前缀和\n上述算法可以用来处理整个序列上的第 $ k $ 大，而我们可以对于一个长度为 $ n $ 的序列 $ a $ 建立 $ n $ 棵上述的权值线段树，第 $ i $ 棵表示『$ a_1 $ ~ $ a_i $ 的所有数』组成的权值线段树。如果要查询 $ [l, r] $ 中的第 $ k $ 大，可以使用第 $ r $ 棵线段树减去第 $ l - 1 $ 棵线段树，得到整个区间组成的权值线段树，并进行上述算法得到区间中的第 $ k $ 大。\n\n这个算法存在两个问题：\n\n1. 每个线段树要占用 $ O(n \\log n) $ 的空间，算法的空间复杂度为 $ O(n ^ 2 \\log n) $，占用空间过多；\n2. 建立每棵线段树至少要用 $ O(n \\log n) $ 的时间，每次查询又要用 $ O(n \\log n) $ 的时间构建区间的权值线段树，总时间复杂度 $ O((n + m) n \\log n) $。\n\n看上去还不如**每次直接提取出区间，并使用后线性选择得到答案**的 $ O(n ^ 2) $ 的朴素算法优秀。\n\n### 主席树\n仔细思考，发现上述算法的 $ n $ 棵线段树中，相邻的两棵线段树仅有 $ O(\\log n) $ 个节点不同，因此本质不同的节点只有 $ O(n \\log n) $ 个。我们可以充分利用这一特点，每次只重新创建与上次所不同的节点，相同的节点直接使用前一棵的即可。\n\n为了节省空间，可以将第 $ 0 $ 棵线段树置为空，每次插入一个新叶子节点时接入一条长度为 $ O(\\log n) $ 的链。总空间、时间复杂度仍为 $ O(n \\log n) $\n\n查询时构造整棵线段树，需要构造 $ O(n \\log n) $ 个节点，但每次查询只会用到 $ O(\\log n) $ 个节点，直接动态构造这些节点即可。为了方便，可以不显式构造这些节点，而是直接用两棵线段树上的值相减。\n\n### 模板\n[POJ 2104](http://poj.org/problem?id=2104)  \n动态分配内存会超时，需要静态分配内存。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/chairman-tree-notes.md","raw":"title: 主席树学习笔记\ncategories: OI\ntags: \n  - 数据结构\n  - 主席树\n  - 学习笔记\n  - 算法模板\npermalink: chairman-tree-notes\ndate: 2016-05-11 21:06:00\n---\n\n主席树是一种数据结构，其主要应用是区间第 $ k $ 大问题。\n\n<!-- more -->\n\n### 权值线段树\n传统的线段树用于维护一条线段上的区间，可以方便地查询区间信息。而如果将线段树转化为『权值线段树』，每个叶子节点存储某个元素出现次数，一条线段的总和表示区间内所有数出现次数的总和。\n\n利用权值线段树可以方便地求出整体第 $ k $ 大 —— 从根节点向下走，如果 $ k $ 小于等于左子树大小，说明第 $ k $ 大在左子树的区间中，在左子树中继续查找即可；否则，说明第 $ k $ 大在右子树的区间中，此时将 $ k $ 减去左子树大小，并在右子树中继续查找。\n\n查找过程类似平衡树，时间复杂度为 $ O(\\log n) $。\n\n### 前缀和\n上述算法可以用来处理整个序列上的第 $ k $ 大，而我们可以对于一个长度为 $ n $ 的序列 $ a $ 建立 $ n $ 棵上述的权值线段树，第 $ i $ 棵表示『$ a_1 $ ~ $ a_i $ 的所有数』组成的权值线段树。如果要查询 $ [l, r] $ 中的第 $ k $ 大，可以使用第 $ r $ 棵线段树减去第 $ l - 1 $ 棵线段树，得到整个区间组成的权值线段树，并进行上述算法得到区间中的第 $ k $ 大。\n\n这个算法存在两个问题：\n\n1. 每个线段树要占用 $ O(n \\log n) $ 的空间，算法的空间复杂度为 $ O(n ^ 2 \\log n) $，占用空间过多；\n2. 建立每棵线段树至少要用 $ O(n \\log n) $ 的时间，每次查询又要用 $ O(n \\log n) $ 的时间构建区间的权值线段树，总时间复杂度 $ O((n + m) n \\log n) $。\n\n看上去还不如**每次直接提取出区间，并使用后线性选择得到答案**的 $ O(n ^ 2) $ 的朴素算法优秀。\n\n### 主席树\n仔细思考，发现上述算法的 $ n $ 棵线段树中，相邻的两棵线段树仅有 $ O(\\log n) $ 个节点不同，因此本质不同的节点只有 $ O(n \\log n) $ 个。我们可以充分利用这一特点，每次只重新创建与上次所不同的节点，相同的节点直接使用前一棵的即可。\n\n为了节省空间，可以将第 $ 0 $ 棵线段树置为空，每次插入一个新叶子节点时接入一条长度为 $ O(\\log n) $ 的链。总空间、时间复杂度仍为 $ O(n \\log n) $\n\n查询时构造整棵线段树，需要构造 $ O(n \\log n) $ 个节点，但每次查询只会用到 $ O(\\log n) $ 个节点，直接动态构造这些节点即可。为了方便，可以不显式构造这些节点，而是直接用两棵线段树上的值相减。\n\n### 模板\n[POJ 2104](http://poj.org/problem?id=2104)  \n动态分配内存会超时，需要静态分配内存。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"chairman-tree-notes","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcfh00r07gxlu1hll84k"},{"title":"「Codeforces 628D」Magic Numbers - 数位DP","date":"2016-05-12T07:47:00.000Z","_content":"\n我们认为一个数是 `d-magic` 的，当且仅当数字 $ d $ 出现在这个数字的十进制表示的所有偶数位上，而不会出现在其它位上。\n\n例如，$ 1727374,\\ 17,\\ 1 $ 是 `7-magic` 的，但 $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $ 不是 `7-magic` 的。\n\n找出能被 `m` 整除的 `d-magic` 的数字在区间 $ [a, b] $ 内的数量。\n\n<!-- more -->\n\n### 链接\n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### 题解\n数位 DP，设\n\n$$ f[n][limit][r] $$\n\n表示数字的最后 $ n $ 位，最高位最大为 $ limit $，模 $ m $ 的余数为 $ r $ 的数量。\n\n对于 $ [a, b] $ 的限制，我们通常定义函数 $ g(x) $ 表示 $ [0, x] $ 中的数量，求出 $ g(b) - g(a - 1) $，但这道题目中 $ a $ 是高精度数，不方便做减法，可以先求出 $ g(b) - g(a) $，然后特判 $ a $ 是否有效。\n\n### 代码\n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","source":"_posts/cf-628d.md","raw":"title: 「Codeforces 628D」Magic Numbers - 数位DP\ncategories: OI\ntags: \n  - Codeforces\n  - 数位DP\n  - DP\npermalink: cf-628d\ndate: 2016-05-12 15:47:00\n---\n\n我们认为一个数是 `d-magic` 的，当且仅当数字 $ d $ 出现在这个数字的十进制表示的所有偶数位上，而不会出现在其它位上。\n\n例如，$ 1727374,\\ 17,\\ 1 $ 是 `7-magic` 的，但 $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $ 不是 `7-magic` 的。\n\n找出能被 `m` 整除的 `d-magic` 的数字在区间 $ [a, b] $ 内的数量。\n\n<!-- more -->\n\n### 链接\n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### 题解\n数位 DP，设\n\n$$ f[n][limit][r] $$\n\n表示数字的最后 $ n $ 位，最高位最大为 $ limit $，模 $ m $ 的余数为 $ r $ 的数量。\n\n对于 $ [a, b] $ 的限制，我们通常定义函数 $ g(x) $ 表示 $ [0, x] $ 中的数量，求出 $ g(b) - g(a - 1) $，但这道题目中 $ a $ 是高精度数，不方便做减法，可以先求出 $ g(b) - g(a) $，然后特判 $ a $ 是否有效。\n\n### 代码\n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","slug":"cf-628d","published":1,"updated":"2016-05-13T11:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcfl00r67gxlllutle9w"},{"title":"「BZOJ 4403」序列统计 - 组合数","date":"2016-04-08T14:11:34.000Z","_content":"\n给定三个正整数 $ N $、$ L $ 和 $ R $，统计长度在 $ 1 $ 到 $ N $ 之间，元素大小都在 $ L $ 到 $ R $ 之间的单调不降序列的数量。输出答案对 $ 10 ^ 6 + 3 $ 取模的结果。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### 题解\n问题等价于，从 $ [1, R - L + 1] $ 中选择 $ N $ 个数（可重复）的方案数。\n\n设\n\n$$ M = R - L + 1 $$\n\n答案为\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n直接算组合数会超时，需要用 Lucas 定理\n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n当 $ n \\lt p, m \\lt p $ 时，直接**使用公式**计算即可。\n\n不要预处理逆元，用到的时候用费马小定理计算即可。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4403.md","raw":"title: 「BZOJ 4403」序列统计 - 组合数\ncategories: OI\ntags: \n  - BZOJ\n  - 数学\n  - 组合数学\n  - 组合数\n  - 数论\n  - Lucas 定理\n  - 乘法逆元\npermalink: bzoj-4403\ndate: 2016-04-08 22:11:34\n---\n\n给定三个正整数 $ N $、$ L $ 和 $ R $，统计长度在 $ 1 $ 到 $ N $ 之间，元素大小都在 $ L $ 到 $ R $ 之间的单调不降序列的数量。输出答案对 $ 10 ^ 6 + 3 $ 取模的结果。\n\n<!-- more -->\n\n### 链接\n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### 题解\n问题等价于，从 $ [1, R - L + 1] $ 中选择 $ N $ 个数（可重复）的方案数。\n\n设\n\n$$ M = R - L + 1 $$\n\n答案为\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n直接算组合数会超时，需要用 Lucas 定理\n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n当 $ n \\lt p, m \\lt p $ 时，直接**使用公式**计算即可。\n\n不要预处理逆元，用到的时候用费马小定理计算即可。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4403","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcfs00rc7gxlavhzikeu"},{"title":"「BZOJ 3511」土地划分 - 最小割","date":"2016-04-06T14:33:05.000Z","_content":"\n给定一张 $ n $ 个点 $ m $ 条边的无向连通图，初始时 $ 1 $ 号点属于集合 $ A $，$ n $ 号点属于集合 $ B $。现在要将其他点划分进两个集合，并使得评分最高，评分方式如下：\n\n1. 对于点 $ i $，划给 $ A $ 集合得 $ VA_i $ 分，划给 $ B $ 集合得 $ VB_i $ 分；\n2. 对于一条边 $ i $，若它连接两个 $ A $ 集合点，则得 $ EA_i $ 分，若它连接两个 $ B $ 集合点，则得 $ EB_i $ 分，否则将扣除 $ EC_i $ 分。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### 题解\n建立最小割模型，使 $ A $ 集合的点与 $ S $ 联通，$ B $ 集合的点与 $ T $ 联通。\n\n对于每个点 $ u $，连边 $ (S, u) = VA_i $，割掉这条边表示它不被放在 $ A $ 集合中；连边 $ (u, T) = VB_i $，割掉这条边表示它不被放在 $ B $ 集合中。\n\n对于已经确定的点 $ 1 $ 和点 $ n $，连两条容量为正无穷的边 $ (S, 1) $ 和 $ (n, T) $，这两条边都不会被割掉。\n\n对于原图中的每条边，将其转化为容量为 $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $ 的双向边，并对于两个端点，连接 $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $。\n\n如果两个端点都在 $ A $ 集合中，那么两条容量为 $ EB_i $ 的边会被割掉，如果两个端点都在 $ B $ 集合中，那么两条容量为 $ EA_i $ 的边会被割掉，否则会割掉一条容量为 $ EA_i $，一条容量为 $ EB_i $ 的边，并且中间的边也会被割掉。\n\n求出最小割即为损失，$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ 减去损失即为答案。\n\n输入的数字可能有奇数，可以把所有数字乘以二再进行处理。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3511.md","raw":"title: 「BZOJ 3511」土地划分 - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - 安徽集训\n  - 网络流\n  - Dinic\n  - 最小割\npermalink: bzoj-3511\ndate: 2016-04-06 22:33:05\n---\n\n给定一张 $ n $ 个点 $ m $ 条边的无向连通图，初始时 $ 1 $ 号点属于集合 $ A $，$ n $ 号点属于集合 $ B $。现在要将其他点划分进两个集合，并使得评分最高，评分方式如下：\n\n1. 对于点 $ i $，划给 $ A $ 集合得 $ VA_i $ 分，划给 $ B $ 集合得 $ VB_i $ 分；\n2. 对于一条边 $ i $，若它连接两个 $ A $ 集合点，则得 $ EA_i $ 分，若它连接两个 $ B $ 集合点，则得 $ EB_i $ 分，否则将扣除 $ EC_i $ 分。\n\n<!-- more -->\n\n### 链接\n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### 题解\n建立最小割模型，使 $ A $ 集合的点与 $ S $ 联通，$ B $ 集合的点与 $ T $ 联通。\n\n对于每个点 $ u $，连边 $ (S, u) = VA_i $，割掉这条边表示它不被放在 $ A $ 集合中；连边 $ (u, T) = VB_i $，割掉这条边表示它不被放在 $ B $ 集合中。\n\n对于已经确定的点 $ 1 $ 和点 $ n $，连两条容量为正无穷的边 $ (S, 1) $ 和 $ (n, T) $，这两条边都不会被割掉。\n\n对于原图中的每条边，将其转化为容量为 $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $ 的双向边，并对于两个端点，连接 $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $。\n\n如果两个端点都在 $ A $ 集合中，那么两条容量为 $ EB_i $ 的边会被割掉，如果两个端点都在 $ B $ 集合中，那么两条容量为 $ EA_i $ 的边会被割掉，否则会割掉一条容量为 $ EA_i $，一条容量为 $ EB_i $ 的边，并且中间的边也会被割掉。\n\n求出最小割即为损失，$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ 减去损失即为答案。\n\n输入的数字可能有奇数，可以把所有数字乘以二再进行处理。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3511","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcfx00rm7gxlavyou84c"},{"title":"「BZOJ 2820」YY的GCD - 莫比乌斯反演","date":"2016-04-07T14:24:12.000Z","_content":"\n求 $ 1 \\leq x \\leq N $，$ 1 \\leq y \\leq M $ 且 $ \\gcd(x, y) $ 为质数的 $ (x, y) $ 数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### 题解\n首先，我们只需要处理 $ N \\leq M $ 的情况，当 $ M \\lt N $ 的情况只需要交换 $ N $ 和 $ M $ 即可。\n\n设小于 $ N $ 质数为 $ p_1, p_2, …, p_n $，则答案为\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n根据莫比乌斯反演，我们有\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n令 $ T = p_k \\times d $\t，我们在外层枚举 $ T $ 然后对每个质因子计算 $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n设\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times … p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times … p_n ^ {x_n} $$\n\n考虑线性筛求 $ \\mu $ 的过程，当 $ T' \\ {\\rm mod} \\ p_1 = 0 $ 时\n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n当 $ x_1 \\gt 1 $ 时\n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n线性筛后分块处理即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2820.md","raw":"title: 「BZOJ 2820」YY的GCD - 莫比乌斯反演\ncategories: OI\ntags: \n  - BZOJ\n  - 莫比乌斯反演\n  - 数论\n  - 线性筛\n  - 数学\npermalink: bzoj-2820\ndate: 2016-04-07 22:24:12\n---\n\n求 $ 1 \\leq x \\leq N $，$ 1 \\leq y \\leq M $ 且 $ \\gcd(x, y) $ 为质数的 $ (x, y) $ 数量。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### 题解\n首先，我们只需要处理 $ N \\leq M $ 的情况，当 $ M \\lt N $ 的情况只需要交换 $ N $ 和 $ M $ 即可。\n\n设小于 $ N $ 质数为 $ p_1, p_2, …, p_n $，则答案为\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n根据莫比乌斯反演，我们有\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n令 $ T = p_k \\times d $\t，我们在外层枚举 $ T $ 然后对每个质因子计算 $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n设\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times … p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times … p_n ^ {x_n} $$\n\n考虑线性筛求 $ \\mu $ 的过程，当 $ T' \\ {\\rm mod} \\ p_1 = 0 $ 时\n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n当 $ x_1 \\gt 1 $ 时\n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n线性筛后分块处理即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2820","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcg100rt7gxl8hbcjvm9"},{"title":"「BZOJ 2683」简单题 - CDQ","id":"43","updated":"2016-02-05T14:46:27.000Z","date":"2016-02-05T14:42:35.000Z","_content":"\n有一个$N*N$的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作：\n\n1. 将格子$(x,y)$里的数字加上$A$；\n2. 输出$(x1,y1)(x2,y2)$这个矩形内的数字和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### 题解\n离线，按照 X 轴排序，将其转化为时间 …… 然后 CDQ 之！\n\n进行 CDQ 时，用一个树状数组维护 Y 轴的信息，把 ID 小于等于 `mid` 的一半中的修改操作产生的影响加到 ID 大于 `mid` 的另一半的查询结果中。\n\n因为统计的是矩形区域的数字总和，所以要把一次询问转化为四次，用下图所示的方法求出答案（图片来自 WC2016 李建老师的课件）：\n\n![cdq](bzoj-2683/cdq.png)\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2683.md","raw":"title: 「BZOJ 2683」简单题 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - 树状数组\n  - 高级数据结构\n  - 数据结构\npermalink: bzoj-2683\nid: 43\nupdated: '2016-02-05 22:46:27'\ndate: 2016-02-05 22:42:35\n---\n\n有一个$N*N$的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作：\n\n1. 将格子$(x,y)$里的数字加上$A$；\n2. 输出$(x1,y1)(x2,y2)$这个矩形内的数字和。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### 题解\n离线，按照 X 轴排序，将其转化为时间 …… 然后 CDQ 之！\n\n进行 CDQ 时，用一个树状数组维护 Y 轴的信息，把 ID 小于等于 `mid` 的一半中的修改操作产生的影响加到 ID 大于 `mid` 的另一半的查询结果中。\n\n因为统计的是矩形区域的数字总和，所以要把一次询问转化为四次，用下图所示的方法求出答案（图片来自 WC2016 李建老师的课件）：\n\n![cdq](bzoj-2683/cdq.png)\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2683","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcg400s07gxl5ibozgby"},{"title":"「BZOJ 2442」修剪草坪 - 线性DP + 单调队列","id":"24","updated":"2016-01-19T13:03:11.000Z","date":"2016-01-16T14:32:47.000Z","_content":"\nFJ 有 `N`（$1 ≤ N ≤ 100,000$）只排成一排的奶牛，编号为 `1` 到 `N`。每只奶牛的效率是不同的，奶牛 `i` 的效率为$E_i$（$0 ≤ E_i ≤ 1,000,000,000$）。\n\n靠近的奶牛们很熟悉，因此，如果 FJ 安排超过 `K` 只连续的奶牛，那么，这些奶牛就会罢工去开派对。因此，现在 FJ 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 `K` 只奶牛。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### 题解\n一个 $O(n^2)$ 的解法是采用线性 DP，用 $a[i]$ 表示第 `i` 头奶牛的效率，$f[i]$ 表示选择前 `i` 只奶牛中部分或全部可获得的最大效率，对于每次状态转移，枚举 `j`（$i-k ≤ j < i$），计算不选择第 `j` 头奶牛时的最大效率。\n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n边界条件为：\n\n$$ f[1]=a[1] $$\n\n用前缀和数组来维护效率和，每次转移要耗费 $O(n)$ 的时间。\n\n实现代码：（注意边界判断和数组访问的 `-1`）\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n现在让我们来尝试优化这个 DP，首先，设\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n忽略 $f[i-1]$，把转移方程中的前缀和项展开\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n令\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n则转移方程的前半部分化为\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n用一个长度为 `k + 1` 的单调队列来维护 $g(j)$，然后就可以优化到 $O(1)$ 的计算出每个状态。\n\n最终，新的转移方程为\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n两个坑：\n\n1. $E_i$加起来妥妥的爆 `int`，快上 `long long` 保平安；\n2. 边界条件！边界条件！边界条件！\n\n~~（才不是坑呢是我太弱了啦）~~\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2442.md","raw":"title: 「BZOJ 2442」修剪草坪 - 线性DP + 单调队列\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - DP\n  - 单调队列\n  - 线性DP\npermalink: bzoj-2442\nid: 24\nupdated: '2016-01-19 21:03:11'\ndate: 2016-01-16 22:32:47\n---\n\nFJ 有 `N`（$1 ≤ N ≤ 100,000$）只排成一排的奶牛，编号为 `1` 到 `N`。每只奶牛的效率是不同的，奶牛 `i` 的效率为$E_i$（$0 ≤ E_i ≤ 1,000,000,000$）。\n\n靠近的奶牛们很熟悉，因此，如果 FJ 安排超过 `K` 只连续的奶牛，那么，这些奶牛就会罢工去开派对。因此，现在 FJ 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 `K` 只奶牛。\n\n<!-- more -->\n\n### 链接\n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### 题解\n一个 $O(n^2)$ 的解法是采用线性 DP，用 $a[i]$ 表示第 `i` 头奶牛的效率，$f[i]$ 表示选择前 `i` 只奶牛中部分或全部可获得的最大效率，对于每次状态转移，枚举 `j`（$i-k ≤ j < i$），计算不选择第 `j` 头奶牛时的最大效率。\n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n边界条件为：\n\n$$ f[1]=a[1] $$\n\n用前缀和数组来维护效率和，每次转移要耗费 $O(n)$ 的时间。\n\n实现代码：（注意边界判断和数组访问的 `-1`）\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n现在让我们来尝试优化这个 DP，首先，设\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n忽略 $f[i-1]$，把转移方程中的前缀和项展开\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n令\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n则转移方程的前半部分化为\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n用一个长度为 `k + 1` 的单调队列来维护 $g(j)$，然后就可以优化到 $O(1)$ 的计算出每个状态。\n\n最终，新的转移方程为\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n两个坑：\n\n1. $E_i$加起来妥妥的爆 `int`，快上 `long long` 保平安；\n2. 边界条件！边界条件！边界条件！\n\n~~（才不是坑呢是我太弱了啦）~~\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```","slug":"bzoj-2442","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcga00s87gxl5aewyvyt"},{"title":"「BZOJ 2296」随机种子 - 数论基础","date":"2016-04-01T14:59:45.000Z","_content":"\n给定一个数 $ x $（$ 0 \\leq x \\leq 10 ^ 6 $），求一个数 $ n $ 满足：\n\n1. $ n $ 的十进制表示中包含 0 ~ 9 的所有数；\n2. $ n ~ {\\rm mod} ~ x = 0 $；\n3. $ 0 \\leq n \\leq 10 ^ {16} $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### 题解\n做这题需要有点数论基础，构造方法并不难，首先为了满足性质 1，我们可以令 n 的十进制表示中的前 10 位为 $ 9876543210 $，这样我们只需要考虑后 6 位即可。\n\n设 $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $，想象我们通过若干次减法把 $ 9876543210 $ 减到了 $ d $，所以我们只要令 $ n = 9876543210 \\times 10 ^ 6 + x - d $ 即可。\n\n注意 0 的特判。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2296.md","raw":"title: 「BZOJ 2296」随机种子 - 数论基础\ncategories: OI\ntags: \n  - BZOJ\n  - 数论\n  - 安徽集训\npermalink: bzoj-2296\ndate: 2016-04-01 22:59:45\n---\n\n给定一个数 $ x $（$ 0 \\leq x \\leq 10 ^ 6 $），求一个数 $ n $ 满足：\n\n1. $ n $ 的十进制表示中包含 0 ~ 9 的所有数；\n2. $ n ~ {\\rm mod} ~ x = 0 $；\n3. $ 0 \\leq n \\leq 10 ^ {16} $。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### 题解\n做这题需要有点数论基础，构造方法并不难，首先为了满足性质 1，我们可以令 n 的十进制表示中的前 10 位为 $ 9876543210 $，这样我们只需要考虑后 6 位即可。\n\n设 $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $，想象我们通过若干次减法把 $ 9876543210 $ 减到了 $ d $，所以我们只要令 $ n = 9876543210 \\times 10 ^ 6 + x - d $ 即可。\n\n注意 0 的特判。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2296","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcgf00sf7gxlpatraj92"},{"title":"「BZOJ 2143」飞飞侠 - 最短路","date":"2016-03-22T11:50:15.000Z","_content":"\n飞国是一个 $ N * M $ 的矩形方阵，每个格子代表一个街区。飞国是没有交通工具的。飞侠完全靠地面的弹射装置来移动。每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹力。设第 $ i $ 行第 $ j $ 列的弹射装置有 $ A_{ij} $ 的费用和 $ B_{ij} $ 的弹力。并规定有相邻边的格子间距离是 $ 1 $。那么，任何飞侠都只需要在 $ (i,j) $ 支付 $ A_{ij} $ 的费用就可以任 意选择弹到距离不超过 $ B_{ij} $ 的位置了。\n\n有三个飞侠，分别叫做 X、Y、Z。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $ 3 $ 个飞侠的坐标，求往哪里集合大家需要花的费用总和最低。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2143](www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### 题解\n直接裸最短路只能过 40%，考虑从每个位置能走到的位置的坐标最多为 $ B_{ij} $，为空中的每个位置建立节点，从地面到空中 $ B_{ij} $ 高度需要 $ A_{ij} $ 的花费，从空中每个位置到其前后左右位置，高度下降一个单位，花费为 0。这样做有效的减少了边的数量，虽然点变多了，但 Dijkstra 的堆优化效果会更加明显。\n\n然而这样还是过不了的 …… 考虑到 Dijkstra 贪心选择最近点的特点，如果从堆中取出的点的到起点距离比三个飞侠的到起点的距离还要大，就可以直接剪枝。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2143.md","raw":"title: 「BZOJ 2143」飞飞侠 - 最短路\ncategories: OI\ntags: \n  - BZOJ\n  - 最短路\n  - Dijkstra\n  - 安徽集训\npermalink: bzoj-2143\ndate: 2016-03-22 19:50:15\n---\n\n飞国是一个 $ N * M $ 的矩形方阵，每个格子代表一个街区。飞国是没有交通工具的。飞侠完全靠地面的弹射装置来移动。每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹力。设第 $ i $ 行第 $ j $ 列的弹射装置有 $ A_{ij} $ 的费用和 $ B_{ij} $ 的弹力。并规定有相邻边的格子间距离是 $ 1 $。那么，任何飞侠都只需要在 $ (i,j) $ 支付 $ A_{ij} $ 的费用就可以任 意选择弹到距离不超过 $ B_{ij} $ 的位置了。\n\n有三个飞侠，分别叫做 X、Y、Z。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $ 3 $ 个飞侠的坐标，求往哪里集合大家需要花的费用总和最低。\n\n<!-- more -->\n\n### 链接\n[BZOJ 2143](www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### 题解\n直接裸最短路只能过 40%，考虑从每个位置能走到的位置的坐标最多为 $ B_{ij} $，为空中的每个位置建立节点，从地面到空中 $ B_{ij} $ 高度需要 $ A_{ij} $ 的花费，从空中每个位置到其前后左右位置，高度下降一个单位，花费为 0。这样做有效的减少了边的数量，虽然点变多了，但 Dijkstra 的堆优化效果会更加明显。\n\n然而这样还是过不了的 …… 考虑到 Dijkstra 贪心选择最近点的特点，如果从堆中取出的点的到起点距离比三个飞侠的到起点的距离还要大，就可以直接剪枝。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2143","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcgi00sk7gxlfu31t4jm"},{"title":"「BZOJ 2038」小Z的袜子 - 莫队","date":"2016-04-01T14:15:45.000Z","_content":"\n给一个数列 $ x_1 $ ~ $ x_n $，给出 $ m $ 个询问，每次询问 $ x_i $ ~ $ x_j $ 中，任选两个数相同的概率。\n\n<!-- more -->\n\n### 题解\n先按照 $ \\sqrt n $ 分块，以区间左端点所在块为第一关键字，区间右端点为第二关键字排序，使用莫队算法。\n\n问题可转化为：求 $ x_i $ ~ $ x_j $ 中相等的数字对数。\n\n记某个时刻每个数字 $ x $ 的出现次数为 $ c_i $ 考虑每个数字对答案的贡献，答案为：\n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n每加进来或删去一个数字时，可以重新计算单个数字对答案的贡献来得到新的答案。\n\n计算出相等的对数后，除以总对数即为最终答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2038.md","raw":"title: 「BZOJ 2038」小Z的袜子 - 莫队\ncategories: OI\ntags: \n  - BZOJ\n  - 莫队\n  - 分块\n  - 安徽集训\npermalink: bzoj-2038\ndate: 2016-04-01 22:15:45\n---\n\n给一个数列 $ x_1 $ ~ $ x_n $，给出 $ m $ 个询问，每次询问 $ x_i $ ~ $ x_j $ 中，任选两个数相同的概率。\n\n<!-- more -->\n\n### 题解\n先按照 $ \\sqrt n $ 分块，以区间左端点所在块为第一关键字，区间右端点为第二关键字排序，使用莫队算法。\n\n问题可转化为：求 $ x_i $ ~ $ x_j $ 中相等的数字对数。\n\n记某个时刻每个数字 $ x $ 的出现次数为 $ c_i $ 考虑每个数字对答案的贡献，答案为：\n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n每加进来或删去一个数字时，可以重新计算单个数字对答案的贡献来得到新的答案。\n\n计算出相等的对数后，除以总对数即为最终答案。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2038","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcgm00sr7gxl0tydqz4m"},{"title":"「BZOJ 1756」小白逛公园 - 线段树","id":"38","updated":"2016-01-24T15:24:35.000Z","date":"2016-01-24T15:19:48.000Z","_content":"\n路的一边从南到北依次排着 `n` 个公园，一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 `a` 个和第 `b` 个公园之间（包括 `a`、`b` 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。那么，就请你来帮小白选择公园吧。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### 题解\n区间内最大连续和，还带修改，当然是线段树咯！\n\n每个节点维护以下几项信息：\n\n1. 区间总和；\n2. 区间最大连续和；\n3. **强制包含左端点**的最大连续和；\n4. **强制包含右端点**的最大连续和。\n\n然后使用动态规划的方式求出每个节点的四个值即可。\n\n查询麻烦一点，如果跨左右子树查询的话，需要维护**要查询的区间**的以上四项值，然后用相似的方式向上传递。\n\n合并两个区间时，需要注意细节。\n\n还有就是读入 `a`、`b` 时，有可能 `a` 比 `b` 大！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1756.md","raw":"title: 「BZOJ 1756」小白逛公园 - 线段树\ncategories: OI\ntags: \n  - BZOJ\n  - 线段树\n  - 高级数据结构\n  - 数据结构\n  - DP\npermalink: bzoj-1756\nid: 38\nupdated: '2016-01-24 23:24:35'\ndate: 2016-01-24 23:19:48\n---\n\n路的一边从南到北依次排着 `n` 个公园，一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 `a` 个和第 `b` 个公园之间（包括 `a`、`b` 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。那么，就请你来帮小白选择公园吧。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### 题解\n区间内最大连续和，还带修改，当然是线段树咯！\n\n每个节点维护以下几项信息：\n\n1. 区间总和；\n2. 区间最大连续和；\n3. **强制包含左端点**的最大连续和；\n4. **强制包含右端点**的最大连续和。\n\n然后使用动态规划的方式求出每个节点的四个值即可。\n\n查询麻烦一点，如果跨左右子树查询的话，需要维护**要查询的区间**的以上四项值，然后用相似的方式向上传递。\n\n合并两个区间时，需要注意细节。\n\n还有就是读入 `a`、`b` 时，有可能 `a` 比 `b` 大！\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1756","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcgq00sx7gxlvhxsf9g0"},{"title":"「BZOJ 1477」青蛙的约会 - 扩展欧几里得","date":"2016-01-23T15:20:01.000Z","_content":"\n我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### 题解\n设两只青蛙跳了 $t$ 次后碰面，则有：\n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n令 $k=k_{1}-k_{2}$，得\n\n$$ (x+tm)-(y+tn)=kL $$\n\n移项，得\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n题目转化为求一个二元一次不定方程的**最小正整数**解。\n\n扩展欧几里得直接上即可，注意细节，注意细节，注意细节！\n\n### 代码\n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1477.md","raw":"title: 「BZOJ 1477」青蛙的约会 - 扩展欧几里得\ncategories: OI\ntags: \n  - BZOJ\n  - Tyvj\n  - EXGCD\n  - 数论\npermalink: bzoj-1477\ndate: 2016-01-23 23:20:01\n---\n\n我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### 题解\n设两只青蛙跳了 $t$ 次后碰面，则有：\n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n令 $k=k_{1}-k_{2}$，得\n\n$$ (x+tm)-(y+tn)=kL $$\n\n移项，得\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n题目转化为求一个二元一次不定方程的**最小正整数**解。\n\n扩展欧几里得直接上即可，注意细节，注意细节，注意细节！\n\n### 代码\n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1477","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcgu00t47gxlawllrulf"},{"title":"「BZOJ 1251」序列终结者 - Splay","id":"27","updated":"2016-01-19T13:02:18.000Z","date":"2016-01-18T13:44:15.000Z","_content":"\n给定一个长度为 `N` 的序列，每个序列的元素是一个整数。要支持以下三种操作：\n\n1. 将 `[L,R]` 这个区间内的所有数加上 `V`。\n2. 将 `[L,R]` 这个区间翻转，比如 `1 2 3 4` 变成 `4 3 2 1`。\n3. 求 `[L,R]` 这个区间中的最大值。 最开始所有元素都是 `0`。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### 题解\nSplay 裸题，比文艺平衡树强一点，那个没有区间修改和查询。\n\n区间修改：和翻转一样，维护一个 `lazy-tag`，然后 `pushDown()` 的时候下放即可。\n\n区间查询：维护一个子树值的和，查询的时候直接选择区间然后返回这个和。需要在 `maintain()` 中维护。\n\n细节需要注意，各种下放 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1251.md","raw":"title: 「BZOJ 1251」序列终结者 - Splay\ncategories: OI\ntags: \n  - Splay\n  - BZOJ\n  - CodeVS\n  - 高级数据结构\npermalink: bzoj-1251\nid: 27\nupdated: '2016-01-19 21:02:18'\ndate: 2016-01-18 21:44:15\n---\n\n给定一个长度为 `N` 的序列，每个序列的元素是一个整数。要支持以下三种操作：\n\n1. 将 `[L,R]` 这个区间内的所有数加上 `V`。\n2. 将 `[L,R]` 这个区间翻转，比如 `1 2 3 4` 变成 `4 3 2 1`。\n3. 求 `[L,R]` 这个区间中的最大值。 最开始所有元素都是 `0`。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### 题解\nSplay 裸题，比文艺平衡树强一点，那个没有区间修改和查询。\n\n区间修改：和翻转一样，维护一个 `lazy-tag`，然后 `pushDown()` 的时候下放即可。\n\n区间查询：维护一个子树值的和，查询的时候直接选择区间然后返回这个和。需要在 `maintain()` 中维护。\n\n细节需要注意，各种下放 ……\n\n### 代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","slug":"bzoj-1251","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdch100ta7gxlebyl70gd"},{"title":"「HNOI2008」越狱 - 计数原理","date":"2016-04-06T13:04:45.000Z","_content":"\n监狱有连续编号为 $ 1 … N $ 的 $ N $ 个房间，每个房间关押一个犯人，有M种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### 题解\n考虑计算「不会越狱的方案数」，用「方案总数」减去「不会越狱的方案数」即可。\n\n方案总数：一共 $ N $ 个位置，每个位置有 $ M $ 种选择，总方案数为 $ M ^ N $。\n\n不会越狱的方案数：第一个位置有 $ M $ 种选择，之后每个位置都不能与上一个位置相同，即有 $ M - 1 $ 种选择，方案数为 $ M * (M - 1) ^ {N - 1} $。\n\n所以答案为 $ M ^ N - M * (M - 1) ^ {N - 1} $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1008.md","raw":"title: 「HNOI2008」越狱 - 计数原理\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - 计数原理\n  - 快速幂\npermalink: bzoj-1008\ndate: 2016-04-06 21:04:45\n---\n\n监狱有连续编号为 $ 1 … N $ 的 $ N $ 个房间，每个房间关押一个犯人，有M种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### 题解\n考虑计算「不会越狱的方案数」，用「方案总数」减去「不会越狱的方案数」即可。\n\n方案总数：一共 $ N $ 个位置，每个位置有 $ M $ 种选择，总方案数为 $ M ^ N $。\n\n不会越狱的方案数：第一个位置有 $ M $ 种选择，之后每个位置都不能与上一个位置相同，即有 $ M - 1 $ 种选择，方案数为 $ M * (M - 1) ^ {N - 1} $。\n\n所以答案为 $ M ^ N - M * (M - 1) ^ {N - 1} $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1008","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdch800tg7gxlbty2qdsn"},{"title":"「BeiJing2006」狼抓兔子 - 最小割","date":"2016-04-03T14:46:25.000Z","_content":"\n左上角点为 $ (1, 1) $，右下角点为 $ (N, M) $，有以下三种类型的道路：\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $ (1, 1) $ 的窝里，现在它们要跑到右下解 $ (N, M) $ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $ K $，狼王需要安排同样数量的 $ K $ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦.\n\n<!-- more -->\n\n### 链接\n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### 题解\nDinic 模板题，注意注意内存就好 ……\n\n边直接加双向边，反向边的容量和原边相等即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1001.md","raw":"title: 「BeiJing2006」狼抓兔子 - 最小割\ncategories: OI\ntags: \n  - BZOJ\n  - Dinic\n  - 网络流\n  - 最小割\npermalink: bzoj-1001\ndate: 2016-04-03 22:46:25\n---\n\n左上角点为 $ (1, 1) $，右下角点为 $ (N, M) $，有以下三种类型的道路：\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $ (1, 1) $ 的窝里，现在它们要跑到右下解 $ (N, M) $ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $ K $，狼王需要安排同样数量的 $ K $ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦.\n\n<!-- more -->\n\n### 链接\n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### 题解\nDinic 模板题，注意注意内存就好 ……\n\n边直接加双向边，反向边的容量和原边相等即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-1001","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdchc00tn7gxl1jiggtyq"},{"title":"高精度加、减、乘模板","date":"2016-03-14T13:34:42.000Z","_content":"\n今天早上写了一道高精度的题，一口气敲完了高精度加、减、乘。现在把模板放在这备用着 \n…… 需要者自取。\n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","source":"_posts/bigint-template.md","raw":"title: 高精度加、减、乘模板\ncategories: OI\ntags: \n  - 高精度\n  - 算法模板\npermalink: bigint-template\ndate: 2016-03-14 21:34:42\n---\n\n今天早上写了一道高精度的题，一口气敲完了高精度加、减、乘。现在把模板放在这备用着 \n…… 需要者自取。\n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","slug":"bigint-template","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdchg00tt7gxl0dvlybnw"},{"title":"「APIO2010」特别行动队 - 斜率优化DP","date":"2016-05-13T12:16:00.000Z","_content":"\n一支部队由 $ n $ 名预备役士兵组成，士兵从 $ 1 $ 到 $ n $ 编号，要将他们拆分成若干特别行动队，同一队中队员的编号应该连续。\n\n士兵 $ i $ 的初始战斗力为 $ x_i $ 一支特别行动队的初始战斗力 $ x $ 为各士兵初始战斗力之和。一支特别行动队的战斗力会被修正为 $ x' = Ax ^ 2 + Bx + C $，其中 $ A $、$ B $、$ C $ 已知，$ A < 0 $。\n\n求出将所有士兵组成若干特别行动队的最大总战斗力。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### 题解\n设 $ f[i] $ 表示前 $ i $ 名士兵分成若干特别行动队的最大战斗力，$ s_i $ 表示前缀和。\n\n枚举 $ j $，将第 $ j + 1 $ 到 $ i $ 个分在同一队里，状态转移方程为\n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n时间复杂度为 $ O(n ^ 2) $，超时，需要优化。\n\n考虑两个决策点 $ j = a $、$ j = b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n不等式右边单调递减，左边分母上的前缀和单调递增。\n\n用单调队列存储所有决策点，维护一个上凸壳，从左到后两两之间的斜率递减，且均小于当前的 $ 2 A s_i $，每次最优决策从最左边取得。\n\n时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","source":"_posts/apio2010-commando.md","raw":"title: 「APIO2010」特别行动队 - 斜率优化DP\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - DP\n  - 单调队列\n  - 斜率优化\npermalink: apio2010-commando\ndate: 2016-05-13 20:16:00\n---\n\n一支部队由 $ n $ 名预备役士兵组成，士兵从 $ 1 $ 到 $ n $ 编号，要将他们拆分成若干特别行动队，同一队中队员的编号应该连续。\n\n士兵 $ i $ 的初始战斗力为 $ x_i $ 一支特别行动队的初始战斗力 $ x $ 为各士兵初始战斗力之和。一支特别行动队的战斗力会被修正为 $ x' = Ax ^ 2 + Bx + C $，其中 $ A $、$ B $、$ C $ 已知，$ A < 0 $。\n\n求出将所有士兵组成若干特别行动队的最大总战斗力。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### 题解\n设 $ f[i] $ 表示前 $ i $ 名士兵分成若干特别行动队的最大战斗力，$ s_i $ 表示前缀和。\n\n枚举 $ j $，将第 $ j + 1 $ 到 $ i $ 个分在同一队里，状态转移方程为\n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n时间复杂度为 $ O(n ^ 2) $，超时，需要优化。\n\n考虑两个决策点 $ j = a $、$ j = b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n不等式右边单调递减，左边分母上的前缀和单调递增。\n\n用单调队列存储所有决策点，维护一个上凸壳，从左到后两两之间的斜率递减，且均小于当前的 $ 2 A s_i $，每次最优决策从最左边取得。\n\n时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","slug":"apio2010-commando","published":1,"updated":"2016-05-13T12:17:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdchn00tx7gxl4tt70e3r"},{"title":"「APIO2009」抢掠计划 - 强联通分量","date":"2016-03-10T11:57:45.000Z","_content":"\n城中的道路都是单向的。不同的道路由路口连接。在每个路口都设立了一个 ATM 取款机。酒吧也都设在路口，虽然并不是每个路口都设有酒吧。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。\n\n他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### 题解\nTarjan 求强联通分量，一个强联通分量中的点肯定可以同时被抢走。缩点后图转化为 DAG，求出 DAG 上的最长路即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n一开始想到最长路，然后写了个 Dijkstra …… 写了个 Dijkstra ……\n\n(╯‵□′)╯︵┻━┻ 为什么我要写 Dijkstra！\n\n┬—┬ノ('-'ノ) 改成 Bellman-Ford 之后 WA 的更离谱了 ……\n\n最后发现是读进来的起点下标忘了减一 ……\n\n以后不能再出这种沙茶错误了啊啊啊啊啊啊 OvO ……\n\n### 还是吐槽\n从测试点命名中我们可以看出出题人的恶意 →_→\n\n|       测试点      | 结果| 内存使用量 | 时间使用量|\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","source":"_posts/apio2009-atm.md","raw":"title: 「APIO2009」抢掠计划 - 强联通分量\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - 强联通分量\n  - Tarjan\n  - 缩点\n  - DAG\n  - 最长路\n  - Bellman-Ford\npermalink: apio2009-atm\ndate: 2016-03-10 19:57:45\n---\n\n城中的道路都是单向的。不同的道路由路口连接。在每个路口都设立了一个 ATM 取款机。酒吧也都设在路口，虽然并不是每个路口都设有酒吧。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。\n\n他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。\n\n<!-- more -->\n\n### 链接\n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### 题解\nTarjan 求强联通分量，一个强联通分量中的点肯定可以同时被抢走。缩点后图转化为 DAG，求出 DAG 上的最长路即为答案。\n\n### 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n一开始想到最长路，然后写了个 Dijkstra …… 写了个 Dijkstra ……\n\n(╯‵□′)╯︵┻━┻ 为什么我要写 Dijkstra！\n\n┬—┬ノ('-'ノ) 改成 Bellman-Ford 之后 WA 的更离谱了 ……\n\n最后发现是读进来的起点下标忘了减一 ……\n\n以后不能再出这种沙茶错误了啊啊啊啊啊啊 OvO ……\n\n### 还是吐槽\n从测试点命名中我们可以看出出题人的恶意 →_→\n\n|       测试点      | 结果| 内存使用量 | 时间使用量|\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","slug":"apio2009-atm","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdchs00u47gxl876jenkt"},{"title":"「AHOI2014」支线剧情 - 费用流","date":"2016-04-08T09:57:21.000Z","_content":"\n游戏中有 $ N $ 个剧情点，由 $ 1 $ 到 $ N $ 编号，第 $ i $ 个剧情点可以经过不同的支线剧情，前往 $ K_i $ 种不同的新的剧情点。当然如果为 $ 0 $，则说明 $ i $ 号剧情点是游戏的一个结局了。\n\n开始处在 $ 1 $ 号剧情点。任何一个剧情点都是从 $ 1 $ 号剧情点可达的。从任意剧情点出发，都不能再回到这个剧情点。要想回到之前的剧情点，唯一的方法就是开始新的游戏，回到 $ 1 $ 号剧情点。可以在任何时刻退出游戏并重新开始。求花费最少的时间，看完所有不同的支线剧情。\n\n<!-- more -->\n\n### 题解\n题目是一个这样的模型：给出一个带权 DAG，从每个点均可回到 1 号点且不需要花费，求从 1 号点出发遍历整个 DAG 的最小花费。\n\n建立有上下界的费用流模型。\n\n对于原图中的每条边 $ (u, v, w) $，转化为 $ (u, v, [1, \\infty], w) $ 表示可以经过一次或多次这条边。对于不是 $ 1 $ 号点的任意一点 $ u $，连接 $ (u, 1, \\infty, 0) $ 表示在任意一点可无限次回到 $ 1 $ 号点。\n\n考虑去掉容量下界，对于原图中的每条边 $ (u, v, w) $，连接 $ (S, v, 1, w) $，表示这条边至少被走一次，连接 $ (u, T, 1, 0) $ 表示把从源点强行流给 $ v $ 的流量补给汇点。\n\n实际上，$ (u, T, 1, 0) $ 类型的边是可以合并的，实现时只需要连边 $ (u, T, k_i, 0) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2014-story.md","raw":"title: 「AHOI2014」支线剧情 - 费用流\ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - 网络流\n  - 费用流\n  - 上下界网络流\n  - Edmonds-Karp\npermalink: ahoi2014-story\ndate: 2016-04-08 17:57:21\n---\n\n游戏中有 $ N $ 个剧情点，由 $ 1 $ 到 $ N $ 编号，第 $ i $ 个剧情点可以经过不同的支线剧情，前往 $ K_i $ 种不同的新的剧情点。当然如果为 $ 0 $，则说明 $ i $ 号剧情点是游戏的一个结局了。\n\n开始处在 $ 1 $ 号剧情点。任何一个剧情点都是从 $ 1 $ 号剧情点可达的。从任意剧情点出发，都不能再回到这个剧情点。要想回到之前的剧情点，唯一的方法就是开始新的游戏，回到 $ 1 $ 号剧情点。可以在任何时刻退出游戏并重新开始。求花费最少的时间，看完所有不同的支线剧情。\n\n<!-- more -->\n\n### 题解\n题目是一个这样的模型：给出一个带权 DAG，从每个点均可回到 1 号点且不需要花费，求从 1 号点出发遍历整个 DAG 的最小花费。\n\n建立有上下界的费用流模型。\n\n对于原图中的每条边 $ (u, v, w) $，转化为 $ (u, v, [1, \\infty], w) $ 表示可以经过一次或多次这条边。对于不是 $ 1 $ 号点的任意一点 $ u $，连接 $ (u, 1, \\infty, 0) $ 表示在任意一点可无限次回到 $ 1 $ 号点。\n\n考虑去掉容量下界，对于原图中的每条边 $ (u, v, w) $，连接 $ (S, v, 1, w) $，表示这条边至少被走一次，连接 $ (u, T, 1, 0) $ 表示把从源点强行流给 $ v $ 的流量补给汇点。\n\n实际上，$ (u, T, 1, 0) $ 类型的边是可以合并的，实现时只需要连边 $ (u, T, k_i, 0) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"ahoi2014-story","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdchy00uh7gxl55dcrxr4"},{"title":"「AHOI2008」紧急集合 - 最近公共祖先","date":"2016-03-07T12:36:46.000Z","_content":"\n在树上寻找一个点，使其到给定三点的距离之和最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### 题解\n从样例中找出规律，三个点两两之间的 LCA 必有一对相等，写了个数据生成器用大数据验证了一下，确实是成立的。\n\n进一步得到规律，要找的点就是除了相等的一对 LCA 以外的另一个 LCA …… 别问我怎么证明，我不会 qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2008-meet.md","raw":"title: 「AHOI2008」紧急集合 - 最近公共祖先\ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - 最近公共祖先\n  - 乱搞\n  - 倍增\npermalink: ahoi2008-meet\ndate: 2016-03-07 20:36:46\n---\n\n在树上寻找一个点，使其到给定三点的距离之和最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### 题解\n从样例中找出规律，三个点两两之间的 LCA 必有一对相等，写了个数据生成器用大数据验证了一下，确实是成立的。\n\n进一步得到规律，要找的点就是除了相等的一对 LCA 以外的另一个 LCA …… 别问我怎么证明，我不会 qwq\n\n### 代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"ahoi2008-meet","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdci600ur7gxlzssguj48"},{"title":"写在安徽集训之后 ……","date":"2016-04-07T09:28:56.000Z","_content":"\n现在是四月七日的下午，安徽集训刚刚结束，离 SDOI2016 R1 报道时间还有恰好一天。来这里的时间不短了，从最早在他们小机房里做题，到后来和很多学校一起在大教室听课，在大机房考试；从 3.16 来到，到今天结束，时间刚好 22 天。\n\n<!-- more -->\n\n如果要说学习效率，想必也不算太高。开始的几天，有些比较简单的题目还算可以，每天能订正出一两题；但后来的讲课，也便只能听懂不到五分之一了 —— 自己还有太多东西没有学，一时间要全部掌握，想想也是不可能的。对比一下我和其他人的水平，和我一样是高一的，有些已经刷完了 BZOJ 的第一版；还有一位同学才初三，却已经在 WC2016 拿到了三等奖。能感觉到自己正落后于别人，就要全力去追赶吧。\n\n想起差不多半年前的清北学堂培训，那是我第一次外出学习，当时听课的感受和现在差不多，能听懂的题目也是寥寥无几；后来还是在停课备战 NOIP 的时候，ljz 学长给我讲了一些算法和题目。现在想想看，那时算是我学习状态最好的时候了吧 …… 好像从未为一等奖而担心过什么。之后，ljz 的 NOIP 成绩很差，也便没有要参加省选，也就是从那时起，我开始自学。再后来去了冬令营，学到了不少东西，也长了不少见识，但那时终究还是没有现在的心情的 —— 那时的我从没有感觉到省选的紧张，也从没想过自己能不能进队的问题。而现在，我开始为自己而感到担忧 —— 我清楚自己与其他人的差距，更害怕失败。\n\n还有一件很重要的事，那就是在这里认识了三个河南的小伙伴 —— gcx、pyf、cxc，每天晚上和他们一起学习~~一起玩~~。在交流中，我感受到了『强省弱校』与『弱省强校』的差距。他们也给我讲了很多题，像那时的 ljz 一样。现在想想，有学长（学姐）给我讲题也是一件幸福的事吧 ……\n\n看着这些天做过的题，不禁有一种成就感，虽然做出来的题并不多，但能感觉到，自己确是在进步。总感到遥遥无期的省选，转眼间却近在眼前。如果努力了却没有成功，至少也不会有太大的遗憾，也许，这会是一个不一样的故事吧。\n\nSDOI bless all.\n\n![One Day](after-ah-studying/one-day.png)\n","source":"_posts/after-ah-studying.md","raw":"title: 写在安徽集训之后 ……\ncategories: \n  - Diary\n  - OI\ntags: \n  - 游记\n  - 安徽集训\npermalink: after-ah-studying\ndate: 2016-04-07 17:28:56\n---\n\n现在是四月七日的下午，安徽集训刚刚结束，离 SDOI2016 R1 报道时间还有恰好一天。来这里的时间不短了，从最早在他们小机房里做题，到后来和很多学校一起在大教室听课，在大机房考试；从 3.16 来到，到今天结束，时间刚好 22 天。\n\n<!-- more -->\n\n如果要说学习效率，想必也不算太高。开始的几天，有些比较简单的题目还算可以，每天能订正出一两题；但后来的讲课，也便只能听懂不到五分之一了 —— 自己还有太多东西没有学，一时间要全部掌握，想想也是不可能的。对比一下我和其他人的水平，和我一样是高一的，有些已经刷完了 BZOJ 的第一版；还有一位同学才初三，却已经在 WC2016 拿到了三等奖。能感觉到自己正落后于别人，就要全力去追赶吧。\n\n想起差不多半年前的清北学堂培训，那是我第一次外出学习，当时听课的感受和现在差不多，能听懂的题目也是寥寥无几；后来还是在停课备战 NOIP 的时候，ljz 学长给我讲了一些算法和题目。现在想想看，那时算是我学习状态最好的时候了吧 …… 好像从未为一等奖而担心过什么。之后，ljz 的 NOIP 成绩很差，也便没有要参加省选，也就是从那时起，我开始自学。再后来去了冬令营，学到了不少东西，也长了不少见识，但那时终究还是没有现在的心情的 —— 那时的我从没有感觉到省选的紧张，也从没想过自己能不能进队的问题。而现在，我开始为自己而感到担忧 —— 我清楚自己与其他人的差距，更害怕失败。\n\n还有一件很重要的事，那就是在这里认识了三个河南的小伙伴 —— gcx、pyf、cxc，每天晚上和他们一起学习~~一起玩~~。在交流中，我感受到了『强省弱校』与『弱省强校』的差距。他们也给我讲了很多题，像那时的 ljz 一样。现在想想，有学长（学姐）给我讲题也是一件幸福的事吧 ……\n\n看着这些天做过的题，不禁有一种成就感，虽然做出来的题并不多，但能感觉到，自己确是在进步。总感到遥遥无期的省选，转眼间却近在眼前。如果努力了却没有成功，至少也不会有太大的遗憾，也许，这会是一个不一样的故事吧。\n\nSDOI bless all.\n\n![One Day](after-ah-studying/one-day.png)\n","slug":"after-ah-studying","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcib00uy7gxlwurbf91o"},{"title":"省选季的碎碎念（二）","date":"2016-04-23T15:42:21.000Z","_content":"\n这段时间还是有不少事的，上个星期 HNOI 和 JSOI 刚结束，今天又是 HAOI。感觉又想写点什么了 ……\n\n<!-- more -->\n\nJSOI 炸的很惨，幸亏这不是我的省选 …… 不过如果是的话，我也许能考好些？两天的第一题还是蛮简单的，也许是现场没有发挥好吧，但我也不应该这样找理由啊 …… 弱就是弱，还是要好好学吧。中间的讲课挺赞的，讲课人在 AH 集训的时候见过，但这次讲的内容总算大多都能听懂了。\n\n不到一周前，湖北的 Fuxey 说他和 Sengxian 一起进队了，当然是为他们而高兴。而湖南的 Dashgua 就没有那么幸运了，高二还是没有进队，真是可惜啊。\n\n在省常中待了一个星期了，感觉这里还是很不错的。只是这里的题照样不会做，一个人学不知道要学什么，和他们一起学，效率也没有想象中的那么高。想想还是和三个河南的小伙伴在一起好些 …… 也许是我交际能力太差？在这里为什么认识不了那样好的小伙伴呢？\n\n不过，还是感觉自己从一轮结束之后，状态一直不是很好。为什么自己的 Day2 这么差？发挥的稍微好一点点，我就能前进不少名次吧？但是，现在想这些又有什么用呢 …… 也许是能力实在有限吧。现在才是高一，就算进不了省队，就算买不到 D 类，我也还有一年的时间，还可以再来一次，但明年这个时候，我哪里还有后悔的机会呢？\n\nSDOI 群里，大家都在说自己的从前参加 NOIP 的故事 —— fqk 初三拿了普及一等，yts 高一参加 NOIP 时就在 BZOJ 上刷了 100 题。而我呢？高中才开始学，真的太晚了？看着自己 BZOJ 上可怜的通过数量，心里便很不是滋味。\n\n今天 HAOI 刚刚结束。神犇 sui 以 rank2 虐场，Fancy 顺利进入 A 队。而 CXC 却没有进队，就这样结束了，好可惜 …… 听说 changke 卡线进队了？那就恭喜了 ……\n\n想想自己，Round1 成绩不算理想，而 Round2 又近在眼前 …… 没有学的东西照样很多，做过的题目还是那么少。迷茫之中，路，又在何方？\n\n……\n\n> 如果你知道自己终将失败，你还会依旧努力、不放弃吗？\n\n一定会。\n\n> 为什么？\n\n因为，我喜欢 OI 啊。\n","source":"_posts/20160423-tsc-season-2.md","raw":"title: 省选季的碎碎念（二）\ncategories: \n  - Diary\n  - OI\ntags: \n  - 省选\n  - 碎碎念\npermalink: 20160423-tsc-season-2\ndate: 2016-04-23 23:42:21\n---\n\n这段时间还是有不少事的，上个星期 HNOI 和 JSOI 刚结束，今天又是 HAOI。感觉又想写点什么了 ……\n\n<!-- more -->\n\nJSOI 炸的很惨，幸亏这不是我的省选 …… 不过如果是的话，我也许能考好些？两天的第一题还是蛮简单的，也许是现场没有发挥好吧，但我也不应该这样找理由啊 …… 弱就是弱，还是要好好学吧。中间的讲课挺赞的，讲课人在 AH 集训的时候见过，但这次讲的内容总算大多都能听懂了。\n\n不到一周前，湖北的 Fuxey 说他和 Sengxian 一起进队了，当然是为他们而高兴。而湖南的 Dashgua 就没有那么幸运了，高二还是没有进队，真是可惜啊。\n\n在省常中待了一个星期了，感觉这里还是很不错的。只是这里的题照样不会做，一个人学不知道要学什么，和他们一起学，效率也没有想象中的那么高。想想还是和三个河南的小伙伴在一起好些 …… 也许是我交际能力太差？在这里为什么认识不了那样好的小伙伴呢？\n\n不过，还是感觉自己从一轮结束之后，状态一直不是很好。为什么自己的 Day2 这么差？发挥的稍微好一点点，我就能前进不少名次吧？但是，现在想这些又有什么用呢 …… 也许是能力实在有限吧。现在才是高一，就算进不了省队，就算买不到 D 类，我也还有一年的时间，还可以再来一次，但明年这个时候，我哪里还有后悔的机会呢？\n\nSDOI 群里，大家都在说自己的从前参加 NOIP 的故事 —— fqk 初三拿了普及一等，yts 高一参加 NOIP 时就在 BZOJ 上刷了 100 题。而我呢？高中才开始学，真的太晚了？看着自己 BZOJ 上可怜的通过数量，心里便很不是滋味。\n\n今天 HAOI 刚刚结束。神犇 sui 以 rank2 虐场，Fancy 顺利进入 A 队。而 CXC 却没有进队，就这样结束了，好可惜 …… 听说 changke 卡线进队了？那就恭喜了 ……\n\n想想自己，Round1 成绩不算理想，而 Round2 又近在眼前 …… 没有学的东西照样很多，做过的题目还是那么少。迷茫之中，路，又在何方？\n\n……\n\n> 如果你知道自己终将失败，你还会依旧努力、不放弃吗？\n\n一定会。\n\n> 为什么？\n\n因为，我喜欢 OI 啊。\n","slug":"20160423-tsc-season-2","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcig00v37gxl2e7rfckv"},{"title":"省选季的碎碎念","date":"2016-04-10T15:42:21.000Z","_content":"\nSDOI2016 Round1 和 SCOI2016 刚结束。有些心底的话，还是想说一说的 ……\n\n<!-- more -->\n\n对自己的省选，本来信心就不大，Day1 的 rank7 果然出乎意料。但我知道那是碰巧 …… 刚好考到了我会别人不会的东西，而别人会但我不会的东西比这多得多，预计自己 Day2 会失利，果然不出我所料 ……\n\n话说成绩 …… 我和 SD 一些神犇也比较熟，看到他们的成绩，心里也有种说不出的滋味 …… 第一天他们考的不如我，我想，他们付出的努力比我多得多，这不应该是他们应得的啊。第二天他们远超我，我想，我被落下这么远，该如何是好啊 ……\n\n心里总有些矛盾，感觉我的努力和他们的努力相比简直不值一提吧。如果我进队了他们不进，这不太可能吧？至少他们的成绩不会辜负他们的努力吧？但如果他们都进了，我又有什么机会呢？\n\n想想自己，还是学的时间太短吧。zyz 从初一开始学，我从高一开始学，这是怎样的差距？我不敢想象他们在我开始学之前的同时期会是怎样，但我明白，我需要更加努力，和更高的学习效率。我想，我还有机会吧，如果今年不行，就等到明年吧。\n\n刚刚结束的还有 SCOI2016，在火车上突然想起这事，问了问那边我唯一认识的 Miles。她只说了一句话 ——\n\n> 我退役了。\n\n感觉有种莫名的忧伤，是啊，我们都是万千 OIer 中最普通的一个，这是何等的渺小？也许省选本就应是这样一场残酷的竞争，用多数人的牺牲换来少数强者的闪耀吧 …… 我们又能说什么呢？又比如 Fuxey 他们省，连题都不是自己出的，整体水平也不会太强吧？也许这就是身处强省与弱省的命运吧。但到了 NOI 的赛场上，不也就没有区别了吗？只是，有些人，便再没有参加 NOI 的机会 ……\n\n每当感到孤单的时候，就又想起了 liujz、aby890 学长，如果他们没有那么早退役该多好。那样我就不会是一个人了吧 …… 然而事到如今，此话怎讲？他们不也迟早要离开我？我还是要努力，努力啊 ……\n\n前方的路还很长，Round 2 也并非遥遥无期，就在这一短暂的转折点，留下一个脚印吧！\n\n> 感谢这些日子大家的陪伴：SD：liujz、fqk、yzy、Loi\\_DQS、sxb\\_201、yts1999、Travis、Erii、CA；HA：gcx、Fancy、CXC、changke、Fmuckss；HB：Fuxey、Sengxian；JS：sr；SC：Miles；HN：Dashgua；LN：Kilryis、Teachk！\n\nSDOI HAOI HNOI JSOI LNOI Bless All ……\n","source":"_posts/20160410-tsc-season.md","raw":"title: 省选季的碎碎念\ncategories: \n  - Diary\n  - OI\ntags: \n  - 省选\n  - 碎碎念\npermalink: 20160410-tsc-season\ndate: 2016-04-10 23:42:21\n---\n\nSDOI2016 Round1 和 SCOI2016 刚结束。有些心底的话，还是想说一说的 ……\n\n<!-- more -->\n\n对自己的省选，本来信心就不大，Day1 的 rank7 果然出乎意料。但我知道那是碰巧 …… 刚好考到了我会别人不会的东西，而别人会但我不会的东西比这多得多，预计自己 Day2 会失利，果然不出我所料 ……\n\n话说成绩 …… 我和 SD 一些神犇也比较熟，看到他们的成绩，心里也有种说不出的滋味 …… 第一天他们考的不如我，我想，他们付出的努力比我多得多，这不应该是他们应得的啊。第二天他们远超我，我想，我被落下这么远，该如何是好啊 ……\n\n心里总有些矛盾，感觉我的努力和他们的努力相比简直不值一提吧。如果我进队了他们不进，这不太可能吧？至少他们的成绩不会辜负他们的努力吧？但如果他们都进了，我又有什么机会呢？\n\n想想自己，还是学的时间太短吧。zyz 从初一开始学，我从高一开始学，这是怎样的差距？我不敢想象他们在我开始学之前的同时期会是怎样，但我明白，我需要更加努力，和更高的学习效率。我想，我还有机会吧，如果今年不行，就等到明年吧。\n\n刚刚结束的还有 SCOI2016，在火车上突然想起这事，问了问那边我唯一认识的 Miles。她只说了一句话 ——\n\n> 我退役了。\n\n感觉有种莫名的忧伤，是啊，我们都是万千 OIer 中最普通的一个，这是何等的渺小？也许省选本就应是这样一场残酷的竞争，用多数人的牺牲换来少数强者的闪耀吧 …… 我们又能说什么呢？又比如 Fuxey 他们省，连题都不是自己出的，整体水平也不会太强吧？也许这就是身处强省与弱省的命运吧。但到了 NOI 的赛场上，不也就没有区别了吗？只是，有些人，便再没有参加 NOI 的机会 ……\n\n每当感到孤单的时候，就又想起了 liujz、aby890 学长，如果他们没有那么早退役该多好。那样我就不会是一个人了吧 …… 然而事到如今，此话怎讲？他们不也迟早要离开我？我还是要努力，努力啊 ……\n\n前方的路还很长，Round 2 也并非遥遥无期，就在这一短暂的转折点，留下一个脚印吧！\n\n> 感谢这些日子大家的陪伴：SD：liujz、fqk、yzy、Loi\\_DQS、sxb\\_201、yts1999、Travis、Erii、CA；HA：gcx、Fancy、CXC、changke、Fmuckss；HB：Fuxey、Sengxian；JS：sr；SC：Miles；HN：Dashgua；LN：Kilryis、Teachk！\n\nSDOI HAOI HNOI JSOI LNOI Bless All ……\n","slug":"20160410-tsc-season","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcik00v97gxlj4ghpxrl"},{"title":"「省选模拟赛」完美理论 - 最大权闭合图","date":"2016-04-04T02:35:52.000Z","_content":"\n有两棵点集相同的树，顶点编号为 $ 1 \\to n $，每个点都有一个权值，你需要选择一个点集的子集，使得这个子集在两棵树上都是一个联通块。你要选出权值和最大的子集，你只需要输出最大的权值和。\n\n<!-- more -->\n\n### 题解\n首先，我们可以枚举一个点，使得这个点在选择的连通块中，限制转化为：选择了某个点，就必须选择它的父节点。\n\n于是这就是经典的最大权闭合图问题，用最小割模型解决即可。\n\n考场上竟然没想出来！看了题解才发现自己是个傻逼 …… 考场上写了前 15 分的暴搜和「两棵树形态相同」的 25 分树形 DP。\n\n### 40分代码（暴搜 + 树形DP）\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160404-theory.md","raw":"title: 「省选模拟赛」完美理论 - 最大权闭合图\ncategories: OI\ntags: \n  - 安徽集训\n  - 树形DP\n  - 暴力\n  - 网络流\n  - Dinic\n  - 最大权闭合图\npermalink: 20160404-theory\ndate: 2016-04-04 10:35:52\n---\n\n有两棵点集相同的树，顶点编号为 $ 1 \\to n $，每个点都有一个权值，你需要选择一个点集的子集，使得这个子集在两棵树上都是一个联通块。你要选出权值和最大的子集，你只需要输出最大的权值和。\n\n<!-- more -->\n\n### 题解\n首先，我们可以枚举一个点，使得这个点在选择的连通块中，限制转化为：选择了某个点，就必须选择它的父节点。\n\n于是这就是经典的最大权闭合图问题，用最小割模型解决即可。\n\n考场上竟然没想出来！看了题解才发现自己是个傻逼 …… 考场上写了前 15 分的暴搜和「两棵树形态相同」的 25 分树形 DP。\n\n### 40分代码（暴搜 + 树形DP）\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160404-theory","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcio00ve7gxlxdc45n34"},{"title":"「省选模拟赛」扔鸡蛋 - DP","date":"2016-04-01T13:24:45.000Z","_content":"\n有 $ N $ 层楼，第 $ M $ 层以下扔鸡蛋会碎，你有 $ K $ 个鸡蛋，找出这个 $ M $ 需要多少次实验。\n\n<!-- more -->\n\n### 题解\n用 $ f_{i, j} $ 表示用 i 个鸡蛋做 j 次实验最多能测试出多少层的楼，考虑第一个鸡蛋是否摔碎，即：\n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n第二维大小取 $ 10 ^ 5 $ 即可，当询问 $ (N, K) $ 时，在 $ f_K $ 中二分查找 $ N $ 即可。\n\n注意当 $ K = 1, 2, 3 $ 时答案非常大，需要特判。\n\n当 $ K = 1 $ 时，答案为 $ N $。  \n当 $ K = 2 $ 时，设答案为 $ x $，有：\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n当 $ K = 3 $ 时，难以推出公式，我们可以再为 1 ~ 3 开一个 $ f $ 数组，第二维开到 $ 2 \\times 10 ^ 6 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/20160331-naive.md","raw":"title: 「省选模拟赛」扔鸡蛋 - DP\ncategories: OI\ntags: \n  - 安徽集训\n  - DP\n  - 二分查找\npermalink: 20160331-naive\ndate: 2016-04-01 21:24:45\n---\n\n有 $ N $ 层楼，第 $ M $ 层以下扔鸡蛋会碎，你有 $ K $ 个鸡蛋，找出这个 $ M $ 需要多少次实验。\n\n<!-- more -->\n\n### 题解\n用 $ f_{i, j} $ 表示用 i 个鸡蛋做 j 次实验最多能测试出多少层的楼，考虑第一个鸡蛋是否摔碎，即：\n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n第二维大小取 $ 10 ^ 5 $ 即可，当询问 $ (N, K) $ 时，在 $ f_K $ 中二分查找 $ N $ 即可。\n\n注意当 $ K = 1, 2, 3 $ 时答案非常大，需要特判。\n\n当 $ K = 1 $ 时，答案为 $ N $。  \n当 $ K = 2 $ 时，设答案为 $ x $，有：\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n当 $ K = 3 $ 时，难以推出公式，我们可以再为 1 ~ 3 开一个 $ f $ 数组，第二维开到 $ 2 \\times 10 ^ 6 $ 即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"20160331-naive","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcit00vn7gxl24nnilmb"},{"title":"「省选模拟赛」小奇的集合 - 矩阵乘法","date":"2016-03-20T14:50:45.000Z","_content":"\n有一个大小为 $ n $ 的可重集 $ S $，小奇每次操作可以加入一个数 $ a + b $（$ a $，$ b $ 均属于 $ S $），求 $ k $ 次操作后它可获得的 $ S $ 的和的最大值（数据保证这个值为非负数）。\n\n<!-- more -->\n\n### 题解\n每次要取的都是最大的和次大的，考虑最大的和次大的都是非负数正数的情况，使用矩阵乘法（$ m1 $ 为最大值，$ m2 $ 为次大值，$ s $ 为当前总和）：\n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n对于次大值为负的情况，先模拟，直到为正再用矩阵乘法。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-set.md","raw":"title: 「省选模拟赛」小奇的集合 - 矩阵乘法\ncategories: OI\ntags: \n  - 安徽集训\n  - 矩阵乘法\n  - 快速幂\n  - 数学\npermalink: 20160319-set\ndate: 2016-03-20 22:50:45\n---\n\n有一个大小为 $ n $ 的可重集 $ S $，小奇每次操作可以加入一个数 $ a + b $（$ a $，$ b $ 均属于 $ S $），求 $ k $ 次操作后它可获得的 $ S $ 的和的最大值（数据保证这个值为非负数）。\n\n<!-- more -->\n\n### 题解\n每次要取的都是最大的和次大的，考虑最大的和次大的都是非负数正数的情况，使用矩阵乘法（$ m1 $ 为最大值，$ m2 $ 为次大值，$ s $ 为当前总和）：\n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n对于次大值为负的情况，先模拟，直到为正再用矩阵乘法。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-set","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcix00vt7gxl85gcmgvl"},{"title":"「省选模拟赛」小奇的糖果 - 扫描线 + 链表","date":"2016-03-20T14:58:12.000Z","_content":"\n有 $ N $ 个彩色糖果在平面上。小奇想在平面上取一条水平的线段，并拾起它上方或下方的所有糖果。求出最多能够拾起多少糖果，使得获得的糖果并不包含所有的颜色。\n\n<!-- more -->\n\n### 题解\n对纵坐标离散化。\n\n用树状数组维护「当前」横坐标在某个区间内的糖果数量。\n\n用链表维护「当前」某个糖果左边右边与它横坐标最近的两个糖果。\n\n扫描线从上往下扫，初始时树状数组为满，扫到某个新纵坐标把一条直线上所有糖果从树状数组中删掉。对于每个扫描到的糖果，先把它从链表中删掉，考虑这种颜色不选，统计它左边和它右边两个与它颜色相同的糖果之间的糖果数量，更新答案。\n\n跑扫描线之前还要先算出每两个相邻的糖果之间的答案。\n\n题目中允许取上边或下边，只需要将纵坐标取反即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-candy.md","raw":"title: 「省选模拟赛」小奇的糖果 - 扫描线 + 链表\ncategories: OI\ntags: \n  - 安徽集训\n  - 扫描线\n  - 链表\n  - 树状数组\n  - 离散化\npermalink: 20160319-candy\ndate: 2016-03-20 22:58:12\n---\n\n有 $ N $ 个彩色糖果在平面上。小奇想在平面上取一条水平的线段，并拾起它上方或下方的所有糖果。求出最多能够拾起多少糖果，使得获得的糖果并不包含所有的颜色。\n\n<!-- more -->\n\n### 题解\n对纵坐标离散化。\n\n用树状数组维护「当前」横坐标在某个区间内的糖果数量。\n\n用链表维护「当前」某个糖果左边右边与它横坐标最近的两个糖果。\n\n扫描线从上往下扫，初始时树状数组为满，扫到某个新纵坐标把一条直线上所有糖果从树状数组中删掉。对于每个扫描到的糖果，先把它从链表中删掉，考虑这种颜色不选，统计它左边和它右边两个与它颜色相同的糖果之间的糖果数量，更新答案。\n\n跑扫描线之前还要先算出每两个相邻的糖果之间的答案。\n\n题目中允许取上边或下边，只需要将纵坐标取反即可。\n\n### 代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-candy","published":1,"updated":"2016-04-30T13:35:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cio5pdcj200w07gxlc08pfam8"},{"title":"「ZJOI 2007」仓库建设 - 斜率优化DP","date":"2016-05-18T03:58:00.000Z","_content":"\n第 $ i $ 个工厂目前已有成品 $ P_i $ 件，在第 $ i $ 个位置建立仓库的费用是 $ C_i $。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于公司产品的对外销售处设置在山脚的工厂 $ N $，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送 $ 1 $ 个单位距离的费用是 $ 1 $。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：\n\n1. 工厂 $ i $ 距离工厂 $ 1 $ 的距离 $ x_i $（其中 $ x_1 = 0 $）；\n2. 工厂 $ i $ 目前已有成品数量 $ p_i $；\n3. 在工厂 $ i $ 建立仓库的费用 $ c_i $。\n\n请你帮助公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### 题解\n将整个序列翻转，变为从编号大的运往编号小的，设 $ S(i) $ 表示前 $ i $ 个工厂全部运到 $ 1 $ 号工厂的费用，$ s(i) $ 表示前 $ i $ 个工厂的成品总数量。\n\n设 $ f(i) $ 表示前 i 个工厂处理完成的最小花费，则\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n斜率优化，考虑两个决策 $ a $、$ b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","source":"_posts/zjoi2007-storage.md","raw":"title: 「ZJOI 2007」仓库建设 - 斜率优化DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - 斜率优化\n  - 单调队列\n  - DP\npermalink: zjoi2007-storage\ndate: 2016-05-18 11:58:00\n---\n\n第 $ i $ 个工厂目前已有成品 $ P_i $ 件，在第 $ i $ 个位置建立仓库的费用是 $ C_i $。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于公司产品的对外销售处设置在山脚的工厂 $ N $，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送 $ 1 $ 个单位距离的费用是 $ 1 $。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：\n\n1. 工厂 $ i $ 距离工厂 $ 1 $ 的距离 $ x_i $（其中 $ x_1 = 0 $）；\n2. 工厂 $ i $ 目前已有成品数量 $ p_i $；\n3. 在工厂 $ i $ 建立仓库的费用 $ c_i $。\n\n请你帮助公司寻找一个仓库建设的方案，使得总的费用（建造费用 + 运输费用）最小。\n\n<!-- more -->\n\n### 链接\n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### 题解\n将整个序列翻转，变为从编号大的运往编号小的，设 $ S(i) $ 表示前 $ i $ 个工厂全部运到 $ 1 $ 号工厂的费用，$ s(i) $ 表示前 $ i $ 个工厂的成品总数量。\n\n设 $ f(i) $ 表示前 i 个工厂处理完成的最小花费，则\n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n斜率优化，考虑两个决策 $ a $、$ b $（$ a > b $），若 $ a $ 比 $ b $ 优，则有\n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n维护决策点，使斜率递增，最优决策取队首。时间复杂度为 $ O(n) $。\n\n### 代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","slug":"zjoi2007-storage","published":1,"updated":"2016-05-18T03:58:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciocc9nv100006wxlze49h5ws"}],"PostAsset":[{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","post":"cio5pdbtu000f7gxlijmr1ahv","slug":"hotkey.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/network.png","post":"cio5pdbtu000f7gxlijmr1ahv","slug":"network.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/port.png","post":"cio5pdbtu000f7gxlijmr1ahv","slug":"port.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","post":"cio5pdbtu000f7gxlijmr1ahv","slug":"screenfetch.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/share.png","post":"cio5pdbtu000f7gxlijmr1ahv","slug":"share.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","post":"cio5pdbtu000f7gxlijmr1ahv","slug":"terminal.png","modified":1},{"_id":"source/_posts/uva-11538/cells.png","post":"cio5pdbvq001e7gxl9cy7mn8s","slug":"cells.png","modified":1},{"_id":"source/_posts/splay-notes-1/splay.png","post":"cio5pdbzf00527gxlepfrj38j","slug":"splay.png","modified":1},{"_id":"source/_posts/sdoi2016-game/line.png","post":"cio5pdc1100777gxlaeb2arly","slug":"line.png","modified":1},{"_id":"source/_posts/sdoi2016-game/tree.png","post":"cio5pdc1100777gxlaeb2arly","slug":"tree.png","modified":1},{"_id":"source/_posts/osx-softwares/dropbox.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"dropbox.png","modified":1},{"_id":"source/_posts/osx-softwares/feeluown.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"feeluown.png","modified":1},{"_id":"source/_posts/osx-softwares/fileroller.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"fileroller.png","modified":1},{"_id":"source/_posts/osx-softwares/flashlight.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"flashlight.png","modified":1},{"_id":"source/_posts/osx-softwares/gimp.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"gimp.png","modified":1},{"_id":"source/_posts/osx-softwares/go2shell.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"go2shell.png","modified":1},{"_id":"source/_posts/osx-softwares/karabiner.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"karabiner.png","modified":1},{"_id":"source/_posts/osx-softwares/libreoffice-writer.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"libreoffice-writer.png","modified":1},{"_id":"source/_posts/osx-softwares/macdown.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"macdown.png","modified":1},{"_id":"source/_posts/osx-softwares/macvim.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"macvim.png","modified":1},{"_id":"source/_posts/osx-softwares/shadowsocksx.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"shadowsocksx.png","modified":1},{"_id":"source/_posts/osx-softwares/teamviewer.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"teamviewer.png","modified":1},{"_id":"source/_posts/osx-softwares/virtualbox.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"virtualbox.png","modified":1},{"_id":"source/_posts/osx-softwares/vlc.png","post":"cio5pdc3n00bd7gxl8ns3jgyl","slug":"vlc.png","modified":1},{"_id":"source/_posts/osx-enable-retina/plist-edit.png","post":"cio5pdc4p00bi7gxla72agt47","slug":"plist-edit.png","modified":1},{"_id":"source/_posts/cut-tree-notes/cutTree.png","post":"cio5pdcbu00l97gxlo5v8n43d","slug":"cutTree.png","modified":1},{"_id":"source/_posts/bzoj-2683/cdq.png","post":"cio5pdcg400s07gxl5ibozgby","slug":"cdq.png","modified":1},{"_id":"source/_posts/after-ah-studying/one-day.png","post":"cio5pdcib00uy7gxlwurbf91o","slug":"one-day.png","modified":1}],"PostCategory":[{"post_id":"cio5pdbs700007gxl9hz0bvcf","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbsy00077gxl7bsbza5s"},{"post_id":"cio5pdbtu000f7gxlijmr1ahv","category_id":"cio5pdbtv000g7gxlxtf2p5x5","_id":"cio5pdbtz000n7gxl3wr43ogb"},{"post_id":"cio5pdbv7000u7gxlzxk94ogp","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbv9000v7gxlpnacnefa"},{"post_id":"cio5pdbvk00167gxl3urcceuh","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbvm00177gxljsl8mg6l"},{"post_id":"cio5pdbvq001e7gxl9cy7mn8s","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbvr001f7gxlq6j5h3su"},{"post_id":"cio5pdbw7001k7gxl1x7it5p0","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbwd001l7gxl64l9v6rc"},{"post_id":"cio5pdbwl001s7gxlxnu0xt5b","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbwm001t7gxl3et2q86g"},{"post_id":"cio5pdbws00207gxlao5ulilq","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbwu00217gxldgnypfom"},{"post_id":"cio5pdbx0002c7gxl4tcfmtol","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbx2002d7gxl3scx3kc4"},{"post_id":"cio5pdbx6002k7gxl6nvld6fc","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbx7002l7gxl2zj6wmgs"},{"post_id":"cio5pdbxh002w7gxl6cmbeyyp","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbxi002x7gxl24ksd30s"},{"post_id":"cio5pdbxp00357gxliegcw6sq","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbxr00367gxldwavekoe"},{"post_id":"cio5pdbyb003h7gxlp28x0bwb","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbyd003i7gxljay84lnp"},{"post_id":"cio5pdbyi003t7gxlf8ok45rs","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbyj003u7gxlkibihidv"},{"post_id":"cio5pdbyn00427gxltciteri8","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbyp00437gxlikwcmvca"},{"post_id":"cio5pdbyu004c7gxlrw692n1q","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbyw004d7gxlf4yznz4c"},{"post_id":"cio5pdbz2004i7gxl9btnyuj5","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbz3004j7gxl5if9i68r"},{"post_id":"cio5pdbz6004o7gxln32euenu","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbz8004p7gxly1jnzsgd"},{"post_id":"cio5pdbza004v7gxl8zej8l37","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbzd004w7gxluti0g37v"},{"post_id":"cio5pdbzf00527gxlepfrj38j","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbzh00537gxlxxg0olwx"},{"post_id":"cio5pdbzp00597gxlc1p1mf1t","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdbzr005a7gxlkorpbamd"},{"post_id":"cio5pdbzx005m7gxl7vyghdv1","category_id":"cio5pdbzy005n7gxlxhsa1xqi","_id":"cio5pdc01005u7gxlorx8cten"},{"post_id":"cio5pdbzx005m7gxl7vyghdv1","category_id":"cio5pdc00005q7gxllu61z44o","_id":"cio5pdc01005v7gxl70t96hw4"},{"post_id":"cio5pdc03005w7gxlulvf8i3q","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc05005x7gxlr54ftiqk"},{"post_id":"cio5pdc0a00667gxlox6nho5e","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc0c00677gxl4cn3btwa"},{"post_id":"cio5pdc0l006o7gxlou4w8vc2","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc0m006p7gxlrg48scc8"},{"post_id":"cio5pdc0q006y7gxluwg7htoy","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc0t006z7gxlh2in38cs"},{"post_id":"cio5pdc1100777gxlaeb2arly","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc1300787gxlcoprvvnk"},{"post_id":"cio5pdc1f007i7gxlkcupd9ic","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc1g007j7gxl3szstv97"},{"post_id":"cio5pdc1k007t7gxlchvct3wh","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc1l007u7gxlhnsc787o"},{"post_id":"cio5pdc1n00817gxlpz38xqjl","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc1p00827gxlpy1dj9kv"},{"post_id":"cio5pdc1z008c7gxl3bej5e3s","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc21008d7gxladzgrbzj"},{"post_id":"cio5pdc25008m7gxlp013chiy","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc26008n7gxluobxe9on"},{"post_id":"cio5pdc29008v7gxlxesrg10e","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc2b008w7gxll7d4vgln"},{"post_id":"cio5pdc2e00957gxlqyprrsdc","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc2f00967gxl806o7a3a"},{"post_id":"cio5pdc2i009d7gxlumwgqmhg","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc2j009e7gxljz0v57si"},{"post_id":"cio5pdc2n009m7gxlki7qv37i","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc2p009n7gxlmbglx9rn"},{"post_id":"cio5pdc2s009x7gxlv26o9ugw","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc2t009y7gxlez30qiii"},{"post_id":"cio5pdc2x00a77gxlvjsr26s3","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc2z00a87gxl10apurgx"},{"post_id":"cio5pdc3100ad7gxldtkg5k8d","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc3300ae7gxlnklyth9c"},{"post_id":"cio5pdc3600am7gxlbbk8vdob","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc3900an7gxl33lqpw3d"},{"post_id":"cio5pdc3c00au7gxl9ejcro5j","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc3d00av7gxlhl1oy5ho"},{"post_id":"cio5pdc3i00b57gxlijbblc93","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc3j00b67gxluhd0mfng"},{"post_id":"cio5pdc3n00bd7gxl8ns3jgyl","category_id":"cio5pdbtv000g7gxlxtf2p5x5","_id":"cio5pdc3o00be7gxltrgg7g97"},{"post_id":"cio5pdc4p00bi7gxla72agt47","category_id":"cio5pdbtv000g7gxlxtf2p5x5","_id":"cio5pdc4q00bj7gxlcne8hymi"},{"post_id":"cio5pdc4x00bn7gxlo5visj96","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc4y00bo7gxlcwtuth9d"},{"post_id":"cio5pdc5000bt7gxl9opg9hci","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc5200bu7gxlumjhm2e3"},{"post_id":"cio5pdc5600c27gxlrudhw41n","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc5800c37gxlxwsbpcpv"},{"post_id":"cio5pdc5b00cc7gxltax11l2n","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc5d00cd7gxl7idwebbi"},{"post_id":"cio5pdc5g00co7gxl9efaah6b","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc5i00cp7gxl30b4m56d"},{"post_id":"cio5pdc5k00cv7gxldukxbeh1","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc5l00cw7gxlev1tmhnt"},{"post_id":"cio5pdc5n00d47gxlxpxf1sqd","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc5o00d57gxlpn2qvkdv"},{"post_id":"cio5pdc5r00dc7gxls3txrtmt","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc5t00dd7gxlu6pkdv9i"},{"post_id":"cio5pdc5v00di7gxlptmqzgmm","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc5w00dj7gxll0gu090m"},{"post_id":"cio5pdc6000du7gxly53a1g0o","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc6100dv7gxltdffqj13"},{"post_id":"cio5pdc6b00e27gxlh9irpqcx","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc6c00e37gxlnwx23fb0"},{"post_id":"cio5pdc6e00e87gxll1p2348l","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc6f00e97gxlfzdqitnm"},{"post_id":"cio5pdc6j00ek7gxl3l09l5co","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc6n00el7gxlzprhngef"},{"post_id":"cio5pdc6p00es7gxlvfiss8zu","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc6s00et7gxlmn7dbkj1"},{"post_id":"cio5pdc6v00ez7gxlgxuh8l20","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc6x00f07gxln3rdfyc4"},{"post_id":"cio5pdc6y00f47gxlq5i526pn","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc7000f57gxl5t706yo4"},{"post_id":"cio5pdc7300fb7gxl7xogketu","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc7400fc7gxltidjxp01"},{"post_id":"cio5pdc7700fi7gxlrjns3ou0","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc7800fj7gxl5x5p87m5"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc7c00fp7gxluijqzhir"},{"post_id":"cio5pdc7g00g17gxlxib44pzr","category_id":"cio5pdbtv000g7gxlxtf2p5x5","_id":"cio5pdc7h00g27gxl5i7c8xt5"},{"post_id":"cio5pdc7l00g97gxl2alvczf5","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc7m00ga7gxlnpgca1l6"},{"post_id":"cio5pdc7p00gh7gxlh9qtvwxz","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc7q00gi7gxl3eigl562"},{"post_id":"cio5pdc7s00go7gxlqo6z2sav","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc7t00gp7gxllb98yxuy"},{"post_id":"cio5pdc7w00gw7gxlu7kkccpn","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc7x00gx7gxl1e76c6zz"},{"post_id":"cio5pdc8000h47gxlc5dhu6bz","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc8200h57gxl1dk4o5wy"},{"post_id":"cio5pdc8500hd7gxl98iox26o","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc8600he7gxlxauslvug"},{"post_id":"cio5pdc8800hk7gxl1ky688fk","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc8900hl7gxlq40jfb66"},{"post_id":"cio5pdc8d00hu7gxl5sxvs8n3","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc8e00hv7gxlhbhr2lbp"},{"post_id":"cio5pdc8h00i07gxlx08y4cu0","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc8i00i17gxlx6qc5x2w"},{"post_id":"cio5pdc8x00i87gxle231ll57","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc9100i97gxlm4mxxpt3"},{"post_id":"cio5pdc9400ig7gxlo6tw62ih","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc9600ih7gxlxvs1h2pz"},{"post_id":"cio5pdc9a00ip7gxlhyg3cpv4","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc9c00iq7gxlwashn2mt"},{"post_id":"cio5pdc9g00iw7gxlhg61978n","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc9h00ix7gxlbq8g2kfk"},{"post_id":"cio5pdc9l00j47gxlo9q5g4g9","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc9m00j57gxle0kipgfg"},{"post_id":"cio5pdc9o00j97gxlwb6tgu8b","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc9p00ja7gxlxd8ortru"},{"post_id":"cio5pdc9r00je7gxlfjklrjin","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdc9s00jf7gxl5p335vc0"},{"post_id":"cio5pdcac00jm7gxl5i54isf7","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcad00jn7gxldta07jrr"},{"post_id":"cio5pdcag00ju7gxlldwvtg4e","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcai00jv7gxlkvwpomwg"},{"post_id":"cio5pdcb300k47gxlulrcl53w","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcb800k57gxlme8hd4ai"},{"post_id":"cio5pdcbb00kb7gxluczgmi86","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcbc00kc7gxl0ar2k5q7"},{"post_id":"cio5pdcbf00ki7gxlk2koowhj","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcbg00kj7gxlzh80tvum"},{"post_id":"cio5pdcbj00kp7gxljb9uj75l","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcbk00kq7gxlg809vde8"},{"post_id":"cio5pdcbn00kx7gxlaermrpai","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcbo00ky7gxl6ede1cqv"},{"post_id":"cio5pdcbq00l47gxl49z36wv5","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcbs00l57gxl3b9602qu"},{"post_id":"cio5pdcbu00l97gxlo5v8n43d","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcbv00la7gxl8lzgmari"},{"post_id":"cio5pdcc000lh7gxl0zs1qtlr","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcc100li7gxldbj9hppn"},{"post_id":"cio5pdcc500ls7gxle5bcvdwu","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcc600lt7gxleq7sdgro"},{"post_id":"cio5pdccb00ly7gxl7bb483dh","category_id":"cio5pdbzy005n7gxlxhsa1xqi","_id":"cio5pdccc00lz7gxlm4gmcv7g"},{"post_id":"cio5pdccb00ly7gxl7bb483dh","category_id":"cio5pdc00005q7gxllu61z44o","_id":"cio5pdccd00m17gxlamv9h7p8"},{"post_id":"cio5pdccf00m57gxlybq5nazi","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcch00m67gxl2252l5vv"},{"post_id":"cio5pdccj00mc7gxl2myyavig","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdccl00md7gxlhoajxtdj"},{"post_id":"cio5pdcco00mk7gxlj0psr7st","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdccp00ml7gxl1h6uztaw"},{"post_id":"cio5pdccr00mq7gxlc2znhshh","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcct00mr7gxljqk1bss1"},{"post_id":"cio5pdccy00mz7gxl4b36ljo9","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcd000n07gxl6jd3big4"},{"post_id":"cio5pdcd300n77gxl0q7qp4zz","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcd600n87gxl4y9n35bd"},{"post_id":"cio5pdcd900nf7gxlmfuiuwnz","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcdb00ng7gxlkkh2ofa7"},{"post_id":"cio5pdcde00no7gxlbuz36g9x","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcdf00np7gxlbso8w0wa"},{"post_id":"cio5pdcdi00nw7gxlwmrid2b6","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcdj00nx7gxl229n5rqo"},{"post_id":"cio5pdcdl00o47gxlcumk9pto","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcdn00o57gxlmhf9kjq0"},{"post_id":"cio5pdcdq00oc7gxlxzzeaaro","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcds00od7gxleq6nxrcy"},{"post_id":"cio5pdcdz00oj7gxlha5tnnx3","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdce100ok7gxlup8s4xoy"},{"post_id":"cio5pdce300oq7gxlcsx4a32s","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdce500or7gxl866npa26"},{"post_id":"cio5pdce800oy7gxlgb8vnyq2","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdce900oz7gxlc0n9w83w"},{"post_id":"cio5pdcec00p67gxlw71boa6p","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdced00p77gxlqwk8tcr6"},{"post_id":"cio5pdcei00pg7gxlfl997cn6","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcek00ph7gxlpyffu38o"},{"post_id":"cio5pdcem00pl7gxl8o65x5ay","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdceo00pm7gxl43n79osg"},{"post_id":"cio5pdcer00pt7gxl6tghvzfo","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdces00pu7gxlogc7b1m3"},{"post_id":"cio5pdceu00py7gxlxv0q8tbq","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcev00pz7gxlrpdejhbs"},{"post_id":"cio5pdcey00q47gxlyypavzj4","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcf000q57gxl9ptw1ni1"},{"post_id":"cio5pdcf300qb7gxlbk259ooz","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcf400qc7gxlxl8mv58e"},{"post_id":"cio5pdcf600qi7gxljb852cwb","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcf800qj7gxl7xoeccw9"},{"post_id":"cio5pdcfa00qp7gxl63jk5htk","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcfc00qq7gxl14z72yn6"},{"post_id":"cio5pdcfe00qv7gxlr6haopbr","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcff00qw7gxlg4f2ubrp"},{"post_id":"cio5pdcfh00r07gxlu1hll84k","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcfj00r17gxlpkusxqlt"},{"post_id":"cio5pdcfl00r67gxlllutle9w","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcfm00r77gxl7ggwv251"},{"post_id":"cio5pdcfs00rc7gxlavhzikeu","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcft00rd7gxl03lq7o28"},{"post_id":"cio5pdcfx00rm7gxlavyou84c","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcfy00rn7gxlselbh6zn"},{"post_id":"cio5pdcg100rt7gxl8hbcjvm9","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcg200ru7gxlopg91jei"},{"post_id":"cio5pdcg400s07gxl5ibozgby","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcg600s17gxlav02v3j3"},{"post_id":"cio5pdcga00s87gxl5aewyvyt","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcgc00s97gxlxi1hhlp5"},{"post_id":"cio5pdcgf00sf7gxlpatraj92","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcgg00sg7gxl3bjs5mva"},{"post_id":"cio5pdcgi00sk7gxlfu31t4jm","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcgj00sl7gxlbigw3pie"},{"post_id":"cio5pdcgm00sr7gxl0tydqz4m","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcgn00ss7gxl4jhbbbwf"},{"post_id":"cio5pdcgq00sx7gxlvhxsf9g0","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcgr00sy7gxl29bb49f3"},{"post_id":"cio5pdcgu00t47gxlawllrulf","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcgz00t57gxl6rb8yq3g"},{"post_id":"cio5pdch100ta7gxlebyl70gd","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdch400tb7gxl8mzoizd2"},{"post_id":"cio5pdch800tg7gxlbty2qdsn","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdch900th7gxlmv77gccs"},{"post_id":"cio5pdchc00tn7gxl1jiggtyq","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdche00to7gxl45cqsyj8"},{"post_id":"cio5pdchg00tt7gxl0dvlybnw","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdchl00tu7gxlckbjpq92"},{"post_id":"cio5pdchn00tx7gxl4tt70e3r","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcho00ty7gxl706ca57v"},{"post_id":"cio5pdchs00u47gxl876jenkt","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcht00u57gxlltxjrqvx"},{"post_id":"cio5pdchy00uh7gxl55dcrxr4","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdci000ui7gxlvxsc07tb"},{"post_id":"cio5pdci600ur7gxlzssguj48","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdci800us7gxl7vumz0qw"},{"post_id":"cio5pdcib00uy7gxlwurbf91o","category_id":"cio5pdbzy005n7gxlxhsa1xqi","_id":"cio5pdcid00uz7gxlkjq33rb0"},{"post_id":"cio5pdcib00uy7gxlwurbf91o","category_id":"cio5pdc00005q7gxllu61z44o","_id":"cio5pdcie00v17gxlh1cjvi1p"},{"post_id":"cio5pdcig00v37gxl2e7rfckv","category_id":"cio5pdbzy005n7gxlxhsa1xqi","_id":"cio5pdcii00v47gxlb40kvyss"},{"post_id":"cio5pdcig00v37gxl2e7rfckv","category_id":"cio5pdc00005q7gxllu61z44o","_id":"cio5pdcij00v67gxl8xgb994f"},{"post_id":"cio5pdcik00v97gxlj4ghpxrl","category_id":"cio5pdbzy005n7gxlxhsa1xqi","_id":"cio5pdcim00va7gxlkl4ipw86"},{"post_id":"cio5pdcik00v97gxlj4ghpxrl","category_id":"cio5pdc00005q7gxllu61z44o","_id":"cio5pdcin00vc7gxl0jc507e9"},{"post_id":"cio5pdcio00ve7gxlxdc45n34","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcip00vf7gxlf5gwkem2"},{"post_id":"cio5pdcit00vn7gxl24nnilmb","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdciv00vo7gxlpukazyt5"},{"post_id":"cio5pdcix00vt7gxl85gcmgvl","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdciz00vu7gxl4pd79j8t"},{"post_id":"cio5pdcj200w07gxlc08pfam8","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"cio5pdcj400w17gxl58q9jqxh"},{"post_id":"ciocc9nv100006wxlze49h5ws","category_id":"cio5pdbsn00017gxl1xcox7g4","_id":"ciocc9nvh00016wxljkz9qneb"}],"PostTag":[{"post_id":"cio5pdbs700007gxl9hz0bvcf","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdbsz00087gxlh9bs4z3s"},{"post_id":"cio5pdbs700007gxl9hz0bvcf","tag_id":"cio5pdbsv00037gxlvjwoomqj","_id":"cio5pdbsz00097gxlkyek5tur"},{"post_id":"cio5pdbs700007gxl9hz0bvcf","tag_id":"cio5pdbsv00047gxlfvn3oupy","_id":"cio5pdbsz000a7gxleypeh89e"},{"post_id":"cio5pdbs700007gxl9hz0bvcf","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdbt0000b7gxl4k58le39"},{"post_id":"cio5pdbs700007gxl9hz0bvcf","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdbt0000c7gxlbq3yihv3"},{"post_id":"cio5pdbtu000f7gxlijmr1ahv","tag_id":"cio5pdbtv000h7gxlbjurbwt4","_id":"cio5pdbtz000o7gxlhc1fl5h5"},{"post_id":"cio5pdbtu000f7gxlijmr1ahv","tag_id":"cio5pdbtx000i7gxlfeeoytfo","_id":"cio5pdbu0000p7gxlqx9jf50b"},{"post_id":"cio5pdbtu000f7gxlijmr1ahv","tag_id":"cio5pdbty000j7gxlsjqo1jk7","_id":"cio5pdbu0000q7gxl4k6g4mhk"},{"post_id":"cio5pdbtu000f7gxlijmr1ahv","tag_id":"cio5pdbty000k7gxl0oiv5lnt","_id":"cio5pdbu0000r7gxlyljpxtg3"},{"post_id":"cio5pdbtu000f7gxlijmr1ahv","tag_id":"cio5pdbty000l7gxld23ktohn","_id":"cio5pdbu1000s7gxl88c5vd3d"},{"post_id":"cio5pdbtu000f7gxlijmr1ahv","tag_id":"cio5pdbty000m7gxlw27kdbsw","_id":"cio5pdbu1000t7gxlt4i7vz5i"},{"post_id":"cio5pdbv7000u7gxlzxk94ogp","tag_id":"cio5pdbv9000w7gxluzxlz0sr","_id":"cio5pdbvf00117gxlx2o5kmua"},{"post_id":"cio5pdbv7000u7gxlzxk94ogp","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdbvf00127gxlfm8apd74"},{"post_id":"cio5pdbv7000u7gxlzxk94ogp","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdbvg00137gxlfa3q3eqg"},{"post_id":"cio5pdbv7000u7gxlzxk94ogp","tag_id":"cio5pdbvc000z7gxldbi3v0iv","_id":"cio5pdbvg00147gxlhih0zxnh"},{"post_id":"cio5pdbv7000u7gxlzxk94ogp","tag_id":"cio5pdbvd00107gxl5dgcf65d","_id":"cio5pdbvg00157gxle7yhh5vu"},{"post_id":"cio5pdbvk00167gxl3urcceuh","tag_id":"cio5pdbv9000w7gxluzxlz0sr","_id":"cio5pdbvn001a7gxl3zjhyb51"},{"post_id":"cio5pdbvk00167gxl3urcceuh","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdbvo001b7gxl81ol5sia"},{"post_id":"cio5pdbvk00167gxl3urcceuh","tag_id":"cio5pdbvm00187gxll9f1j9fz","_id":"cio5pdbvo001c7gxllxfno91z"},{"post_id":"cio5pdbvk00167gxl3urcceuh","tag_id":"cio5pdbvn00197gxl3qlfl42k","_id":"cio5pdbvo001d7gxlzjixql8d"},{"post_id":"cio5pdbvq001e7gxl9cy7mn8s","tag_id":"cio5pdbv9000w7gxluzxlz0sr","_id":"cio5pdbvs001g7gxl1avu5lmh"},{"post_id":"cio5pdbvq001e7gxl9cy7mn8s","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdbvt001h7gxltf58pc25"},{"post_id":"cio5pdbvq001e7gxl9cy7mn8s","tag_id":"cio5pdbvm00187gxll9f1j9fz","_id":"cio5pdbvu001i7gxlkmw2777z"},{"post_id":"cio5pdbvq001e7gxl9cy7mn8s","tag_id":"cio5pdbvd00107gxl5dgcf65d","_id":"cio5pdbvu001j7gxldlmung0t"},{"post_id":"cio5pdbw7001k7gxl1x7it5p0","tag_id":"cio5pdbv9000w7gxluzxlz0sr","_id":"cio5pdbwg001o7gxlhlho3e6u"},{"post_id":"cio5pdbw7001k7gxl1x7it5p0","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdbwh001p7gxlstzyl5xp"},{"post_id":"cio5pdbw7001k7gxl1x7it5p0","tag_id":"cio5pdbwd001m7gxlr7k9tz34","_id":"cio5pdbwh001q7gxl5vsxnj9p"},{"post_id":"cio5pdbw7001k7gxl1x7it5p0","tag_id":"cio5pdbwf001n7gxlglbf3ugu","_id":"cio5pdbwi001r7gxl430ve3zb"},{"post_id":"cio5pdbwl001s7gxlxnu0xt5b","tag_id":"cio5pdbv9000w7gxluzxlz0sr","_id":"cio5pdbwp001v7gxldqkmi8ve"},{"post_id":"cio5pdbwl001s7gxlxnu0xt5b","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdbwp001w7gxlculdnh6a"},{"post_id":"cio5pdbwl001s7gxlxnu0xt5b","tag_id":"cio5pdbwd001m7gxlr7k9tz34","_id":"cio5pdbwp001x7gxl05of4ygp"},{"post_id":"cio5pdbwl001s7gxlxnu0xt5b","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdbwq001y7gxlnbf3vvds"},{"post_id":"cio5pdbwl001s7gxlxnu0xt5b","tag_id":"cio5pdbwn001u7gxlfrivh82f","_id":"cio5pdbwq001z7gxlemxnpi89"},{"post_id":"cio5pdbws00207gxlao5ulilq","tag_id":"cio5pdbv9000w7gxluzxlz0sr","_id":"cio5pdbwx00257gxldfb3pmak"},{"post_id":"cio5pdbws00207gxlao5ulilq","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdbwy00267gxlylj2totq"},{"post_id":"cio5pdbws00207gxlao5ulilq","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdbwy00277gxlqcvy46rc"},{"post_id":"cio5pdbws00207gxlao5ulilq","tag_id":"cio5pdbwd001m7gxlr7k9tz34","_id":"cio5pdbwy00287gxlerxxdjsx"},{"post_id":"cio5pdbws00207gxlao5ulilq","tag_id":"cio5pdbvd00107gxl5dgcf65d","_id":"cio5pdbwy00297gxlecf4hcjo"},{"post_id":"cio5pdbws00207gxlao5ulilq","tag_id":"cio5pdbww00237gxlmvwl7ksr","_id":"cio5pdbwy002a7gxltlfja3ea"},{"post_id":"cio5pdbws00207gxlao5ulilq","tag_id":"cio5pdbww00247gxl4heyjyjk","_id":"cio5pdbwy002b7gxlr9b2vqly"},{"post_id":"cio5pdbx0002c7gxl4tcfmtol","tag_id":"cio5pdbv9000w7gxluzxlz0sr","_id":"cio5pdbx3002f7gxlcfkuy44q"},{"post_id":"cio5pdbx0002c7gxl4tcfmtol","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdbx3002g7gxlwaix87e7"},{"post_id":"cio5pdbx0002c7gxl4tcfmtol","tag_id":"cio5pdbwd001m7gxlr7k9tz34","_id":"cio5pdbx3002h7gxlnjk39a9p"},{"post_id":"cio5pdbx0002c7gxl4tcfmtol","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdbx3002i7gxlgqscvpfs"},{"post_id":"cio5pdbx0002c7gxl4tcfmtol","tag_id":"cio5pdbx2002e7gxl98dbwg2u","_id":"cio5pdbx4002j7gxltkqjreco"},{"post_id":"cio5pdbx6002k7gxl6nvld6fc","tag_id":"cio5pdbv9000w7gxluzxlz0sr","_id":"cio5pdbxa002p7gxlqzqjoaq4"},{"post_id":"cio5pdbx6002k7gxl6nvld6fc","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdbxb002q7gxlesfyeoqt"},{"post_id":"cio5pdbx6002k7gxl6nvld6fc","tag_id":"cio5pdbwd001m7gxlr7k9tz34","_id":"cio5pdbxb002r7gxlvznt1gvj"},{"post_id":"cio5pdbx6002k7gxl6nvld6fc","tag_id":"cio5pdbvd00107gxl5dgcf65d","_id":"cio5pdbxb002s7gxlmnsd3f86"},{"post_id":"cio5pdbx6002k7gxl6nvld6fc","tag_id":"cio5pdbx8002m7gxl5rgyho8l","_id":"cio5pdbxb002t7gxlf5bbck84"},{"post_id":"cio5pdbx6002k7gxl6nvld6fc","tag_id":"cio5pdbxa002n7gxlclnxamrl","_id":"cio5pdbxb002u7gxlgu4geevx"},{"post_id":"cio5pdbx6002k7gxl6nvld6fc","tag_id":"cio5pdbxa002o7gxlyrqd3h6v","_id":"cio5pdbxb002v7gxlw9w79unv"},{"post_id":"cio5pdbxh002w7gxl6cmbeyyp","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdbxk00317gxls5motnxo"},{"post_id":"cio5pdbxh002w7gxl6cmbeyyp","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdbxl00327gxlawbv932q"},{"post_id":"cio5pdbxh002w7gxl6cmbeyyp","tag_id":"cio5pdbxj002z7gxl1s8lmudr","_id":"cio5pdbxl00337gxl858jhlqc"},{"post_id":"cio5pdbxh002w7gxl6cmbeyyp","tag_id":"cio5pdbxk00307gxlzi5bqtbs","_id":"cio5pdbxl00347gxlffd77s7y"},{"post_id":"cio5pdbxp00357gxliegcw6sq","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdbxt003c7gxlbkfrln8e"},{"post_id":"cio5pdbxp00357gxliegcw6sq","tag_id":"cio5pdbxs00387gxlz7ceba43","_id":"cio5pdby9003d7gxlrabf012m"},{"post_id":"cio5pdbxp00357gxliegcw6sq","tag_id":"cio5pdbxs00397gxl1thpztrb","_id":"cio5pdby9003e7gxl2bz554uo"},{"post_id":"cio5pdbxp00357gxliegcw6sq","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdby9003f7gxliyovlc2a"},{"post_id":"cio5pdbxp00357gxliegcw6sq","tag_id":"cio5pdbxt003b7gxlyv2erdmo","_id":"cio5pdby9003g7gxldgn6fhbx"},{"post_id":"cio5pdbyb003h7gxlp28x0bwb","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdbyg003o7gxlcf1yax9c"},{"post_id":"cio5pdbyb003h7gxlp28x0bwb","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdbyg003p7gxl1u3xsnu5"},{"post_id":"cio5pdbyb003h7gxlp28x0bwb","tag_id":"cio5pdbye003l7gxlra9zc2zv","_id":"cio5pdbyh003q7gxlqmta7stt"},{"post_id":"cio5pdbyb003h7gxlp28x0bwb","tag_id":"cio5pdbye003m7gxlnqh5kta4","_id":"cio5pdbyh003r7gxlulymch86"},{"post_id":"cio5pdbyb003h7gxlp28x0bwb","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdbyh003s7gxlrnmc30n9"},{"post_id":"cio5pdbyi003t7gxlf8ok45rs","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdbyl003x7gxlkz7ygmwb"},{"post_id":"cio5pdbyi003t7gxlf8ok45rs","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdbym003y7gxl1pec34w9"},{"post_id":"cio5pdbyi003t7gxlf8ok45rs","tag_id":"cio5pdbyj003v7gxl10t24hjl","_id":"cio5pdbym003z7gxldhypq1yf"},{"post_id":"cio5pdbyi003t7gxlf8ok45rs","tag_id":"cio5pdbyk003w7gxl5kxm7nfb","_id":"cio5pdbym00407gxluq35zh0m"},{"post_id":"cio5pdbyi003t7gxlf8ok45rs","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdbym00417gxl4g0d8fr3"},{"post_id":"cio5pdbyn00427gxltciteri8","tag_id":"cio5pdbyp00447gxlbixdds7j","_id":"cio5pdbyq00477gxl4jm37wou"},{"post_id":"cio5pdbyn00427gxltciteri8","tag_id":"cio5pdbyq00457gxlaq3vgwft","_id":"cio5pdbyr00487gxllr0yjvps"},{"post_id":"cio5pdbyn00427gxltciteri8","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdbyr00497gxl5vml61lo"},{"post_id":"cio5pdbyn00427gxltciteri8","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdbyr004a7gxl593dpdrx"},{"post_id":"cio5pdbyn00427gxltciteri8","tag_id":"cio5pdbyq00467gxlkp3do8rs","_id":"cio5pdbyr004b7gxlbnebuq02"},{"post_id":"cio5pdbyu004c7gxlrw692n1q","tag_id":"cio5pdbyw004e7gxlts06y0a6","_id":"cio5pdbyx004g7gxlhbofsobr"},{"post_id":"cio5pdbyu004c7gxlrw692n1q","tag_id":"cio5pdbyx004f7gxldr0hor7k","_id":"cio5pdbyx004h7gxlqhzfta52"},{"post_id":"cio5pdbz2004i7gxl9btnyuj5","tag_id":"cio5pdbz4004k7gxlpbxgu472","_id":"cio5pdbz5004l7gxlfcow65vl"},{"post_id":"cio5pdbz2004i7gxl9btnyuj5","tag_id":"cio5pdbyp00447gxlbixdds7j","_id":"cio5pdbz5004m7gxln5srrf1p"},{"post_id":"cio5pdbz2004i7gxl9btnyuj5","tag_id":"cio5pdbyq00457gxlaq3vgwft","_id":"cio5pdbz5004n7gxlrjlzckvo"},{"post_id":"cio5pdbz6004o7gxln32euenu","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdbz8004q7gxl5yxsibm4"},{"post_id":"cio5pdbz6004o7gxln32euenu","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdbz9004r7gxlje63u105"},{"post_id":"cio5pdbz6004o7gxln32euenu","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdbz9004s7gxl35ag3dhu"},{"post_id":"cio5pdbz6004o7gxln32euenu","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdbz9004t7gxl27m7n4wj"},{"post_id":"cio5pdbz6004o7gxln32euenu","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdbz9004u7gxlcn58yy5b"},{"post_id":"cio5pdbza004v7gxl8zej8l37","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdbzd004x7gxl3us3m0rm"},{"post_id":"cio5pdbza004v7gxl8zej8l37","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdbze004y7gxlvmbce61w"},{"post_id":"cio5pdbza004v7gxl8zej8l37","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdbze004z7gxl16byutyv"},{"post_id":"cio5pdbza004v7gxl8zej8l37","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdbze00507gxlpuhkzpqw"},{"post_id":"cio5pdbza004v7gxl8zej8l37","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdbze00517gxleuddgfr7"},{"post_id":"cio5pdbzf00527gxlepfrj38j","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdbzh00547gxlwk1qrehk"},{"post_id":"cio5pdbzf00527gxlepfrj38j","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdbzi00557gxl4t9pi0ik"},{"post_id":"cio5pdbzf00527gxlepfrj38j","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdbzi00567gxl6tzd12ys"},{"post_id":"cio5pdbzf00527gxlepfrj38j","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdbzi00577gxl13r1zotf"},{"post_id":"cio5pdbzf00527gxlepfrj38j","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdbzi00587gxlajgj74hz"},{"post_id":"cio5pdbzp00597gxlc1p1mf1t","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdbzu005g7gxlchldp1od"},{"post_id":"cio5pdbzp00597gxlc1p1mf1t","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdbzv005h7gxl0aaa927w"},{"post_id":"cio5pdbzp00597gxlc1p1mf1t","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdbzv005i7gxlbcgol81y"},{"post_id":"cio5pdbzp00597gxlc1p1mf1t","tag_id":"cio5pdbzs005d7gxl7czwm9f9","_id":"cio5pdbzv005j7gxlgthhnv2d"},{"post_id":"cio5pdbzp00597gxlc1p1mf1t","tag_id":"cio5pdbzs005e7gxlem2usze0","_id":"cio5pdbzv005k7gxlfvuupl5t"},{"post_id":"cio5pdbzp00597gxlc1p1mf1t","tag_id":"cio5pdbzt005f7gxli6q2re54","_id":"cio5pdbzv005l7gxlaqixc4wj"},{"post_id":"cio5pdbzx005m7gxl7vyghdv1","tag_id":"cio5pdbzy005o7gxlbc2g16ho","_id":"cio5pdc00005r7gxloh7ifou0"},{"post_id":"cio5pdbzx005m7gxl7vyghdv1","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc01005s7gxl1rwm0peg"},{"post_id":"cio5pdbzx005m7gxl7vyghdv1","tag_id":"cio5pdbzz005p7gxl1ab51zxq","_id":"cio5pdc01005t7gxl9g5x9wkx"},{"post_id":"cio5pdc03005w7gxlulvf8i3q","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc08005z7gxlaoeexoay"},{"post_id":"cio5pdc03005w7gxlulvf8i3q","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc0900607gxlikcxcns2"},{"post_id":"cio5pdc03005w7gxlulvf8i3q","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc0900617gxlqmhqf0z6"},{"post_id":"cio5pdc03005w7gxlulvf8i3q","tag_id":"cio5pdbvm00187gxll9f1j9fz","_id":"cio5pdc0900627gxl9xijnt19"},{"post_id":"cio5pdc03005w7gxlulvf8i3q","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdc0900637gxl1uy0g6j1"},{"post_id":"cio5pdc03005w7gxlulvf8i3q","tag_id":"cio5pdc06005y7gxlxtjuu9d1","_id":"cio5pdc0900647gxl3sekljmv"},{"post_id":"cio5pdc03005w7gxlulvf8i3q","tag_id":"cio5pdbx8002m7gxl5rgyho8l","_id":"cio5pdc0900657gxlml3u3vse"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc0g006e7gxlvp5inoi6"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc0i006f7gxl7siwp8g4"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc0j006g7gxlc4iw3p3s"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdc0j006h7gxlmfl0xsxc"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdc0j006i7gxlzdjlq5nh"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdc0e00697gxl3mow6ll2","_id":"cio5pdc0j006j7gxlgtnx6cw4"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdc0e006a7gxl9r6uk5gw","_id":"cio5pdc0j006k7gxlbjqjjb8o"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdc0j006l7gxl2ch961l4"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdc0j006m7gxludkpomhp"},{"post_id":"cio5pdc0a00667gxlox6nho5e","tag_id":"cio5pdc0g006d7gxl5o3ibwes","_id":"cio5pdc0j006n7gxl4pdqk15i"},{"post_id":"cio5pdc0l006o7gxlou4w8vc2","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc0p006s7gxl5hc0c2m7"},{"post_id":"cio5pdc0l006o7gxlou4w8vc2","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc0p006t7gxl9k2zu242"},{"post_id":"cio5pdc0l006o7gxlou4w8vc2","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc0p006u7gxlf2owymut"},{"post_id":"cio5pdc0l006o7gxlou4w8vc2","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc0p006v7gxl6d9ooml4"},{"post_id":"cio5pdc0l006o7gxlou4w8vc2","tag_id":"cio5pdc0n006q7gxl3cre2ot6","_id":"cio5pdc0p006w7gxl1pt1xbkp"},{"post_id":"cio5pdc0l006o7gxlou4w8vc2","tag_id":"cio5pdc0o006r7gxlpuwptv4k","_id":"cio5pdc0p006x7gxljprvfwl0"},{"post_id":"cio5pdc0q006y7gxluwg7htoy","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc0w00717gxl32rr17f5"},{"post_id":"cio5pdc0q006y7gxluwg7htoy","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc0y00727gxlwidp73xi"},{"post_id":"cio5pdc0q006y7gxluwg7htoy","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc0y00737gxlivbzu62z"},{"post_id":"cio5pdc0q006y7gxluwg7htoy","tag_id":"cio5pdbyp00447gxlbixdds7j","_id":"cio5pdc0y00747gxligyxa2y4"},{"post_id":"cio5pdc0q006y7gxluwg7htoy","tag_id":"cio5pdbyq00457gxlaq3vgwft","_id":"cio5pdc0y00757gxlcehbdbt8"},{"post_id":"cio5pdc0q006y7gxluwg7htoy","tag_id":"cio5pdc0v00707gxlmyg6e9aj","_id":"cio5pdc0y00767gxl8elnng1n"},{"post_id":"cio5pdc1100777gxlaeb2arly","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc15007a7gxlr1js6350"},{"post_id":"cio5pdc1100777gxlaeb2arly","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc15007b7gxlrlmuiub1"},{"post_id":"cio5pdc1100777gxlaeb2arly","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc15007c7gxloseqavog"},{"post_id":"cio5pdc1100777gxlaeb2arly","tag_id":"cio5pdbsv00037gxlvjwoomqj","_id":"cio5pdc15007d7gxl4wm456fa"},{"post_id":"cio5pdc1100777gxlaeb2arly","tag_id":"cio5pdbsv00047gxlfvn3oupy","_id":"cio5pdc15007e7gxlk07ghkex"},{"post_id":"cio5pdc1100777gxlaeb2arly","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdc16007f7gxl33yukd76"},{"post_id":"cio5pdc1100777gxlaeb2arly","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc16007g7gxl81gk10ci"},{"post_id":"cio5pdc1100777gxlaeb2arly","tag_id":"cio5pdc1400797gxl6dckrhhu","_id":"cio5pdc16007h7gxlq32tftr4"},{"post_id":"cio5pdc1f007i7gxlkcupd9ic","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc1i007m7gxlb86j1fgj"},{"post_id":"cio5pdc1f007i7gxlkcupd9ic","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc1i007n7gxlxr25ylsk"},{"post_id":"cio5pdc1f007i7gxlkcupd9ic","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdc1i007o7gxlql2j1v9x"},{"post_id":"cio5pdc1f007i7gxlkcupd9ic","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdc1i007p7gxlveutiqzx"},{"post_id":"cio5pdc1f007i7gxlkcupd9ic","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdc1i007q7gxlru9rkjn6"},{"post_id":"cio5pdc1f007i7gxlkcupd9ic","tag_id":"cio5pdc0g006d7gxl5o3ibwes","_id":"cio5pdc1i007r7gxl3lszqr2r"},{"post_id":"cio5pdc1f007i7gxlkcupd9ic","tag_id":"cio5pdc1h007l7gxlckrssqdx","_id":"cio5pdc1i007s7gxl6az7pkod"},{"post_id":"cio5pdc1k007t7gxlchvct3wh","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc1l007v7gxl3zonrtha"},{"post_id":"cio5pdc1k007t7gxlchvct3wh","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc1m007w7gxlgbgct2iq"},{"post_id":"cio5pdc1k007t7gxlchvct3wh","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdc1m007x7gxl9f4lwscj"},{"post_id":"cio5pdc1k007t7gxlchvct3wh","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdc1m007y7gxlx2mc5o7u"},{"post_id":"cio5pdc1k007t7gxlchvct3wh","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdc1m007z7gxl3lwc06iv"},{"post_id":"cio5pdc1k007t7gxlchvct3wh","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdc1m00807gxljgsaaaip"},{"post_id":"cio5pdc1n00817gxlpz38xqjl","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc1v00857gxliejt7m90"},{"post_id":"cio5pdc1n00817gxlpz38xqjl","tag_id":"cio5pdbzr005b7gxltfhff9t9","_id":"cio5pdc1w00867gxlg5qm57fg"},{"post_id":"cio5pdc1n00817gxlpz38xqjl","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc1w00877gxleb6q338u"},{"post_id":"cio5pdc1n00817gxlpz38xqjl","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc1w00887gxlmx4v8jkj"},{"post_id":"cio5pdc1n00817gxlpz38xqjl","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdc1w00897gxl1xq0ukf4"},{"post_id":"cio5pdc1n00817gxlpz38xqjl","tag_id":"cio5pdc1p00837gxl2cuoe7ki","_id":"cio5pdc1w008a7gxluc8a5vyd"},{"post_id":"cio5pdc1n00817gxlpz38xqjl","tag_id":"cio5pdc1v00847gxlzqvb06i5","_id":"cio5pdc1w008b7gxlxaj8zxx3"},{"post_id":"cio5pdc1z008c7gxl3bej5e3s","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc23008h7gxlfkl5srvb"},{"post_id":"cio5pdc1z008c7gxl3bej5e3s","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc23008i7gxlyv3ra2z6"},{"post_id":"cio5pdc1z008c7gxl3bej5e3s","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdc23008j7gxlqtdwevim"},{"post_id":"cio5pdc1z008c7gxl3bej5e3s","tag_id":"cio5pdc22008f7gxldf5qw2kl","_id":"cio5pdc23008k7gxl2izanaov"},{"post_id":"cio5pdc1z008c7gxl3bej5e3s","tag_id":"cio5pdc22008g7gxlh187bdoa","_id":"cio5pdc23008l7gxloqy0z732"},{"post_id":"cio5pdc25008m7gxlp013chiy","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc26008o7gxlddog3wsy"},{"post_id":"cio5pdc25008m7gxlp013chiy","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc27008p7gxlxelznnor"},{"post_id":"cio5pdc25008m7gxlp013chiy","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdc27008q7gxly6uzy5na"},{"post_id":"cio5pdc25008m7gxlp013chiy","tag_id":"cio5pdbxs00397gxl1thpztrb","_id":"cio5pdc27008r7gxlyzua2nt6"},{"post_id":"cio5pdc25008m7gxlp013chiy","tag_id":"cio5pdc1v00847gxlzqvb06i5","_id":"cio5pdc27008s7gxlxg8f7gg5"},{"post_id":"cio5pdc25008m7gxlp013chiy","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc27008t7gxlogzb74v0"},{"post_id":"cio5pdc25008m7gxlp013chiy","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdc27008u7gxle5l48qlu"},{"post_id":"cio5pdc29008v7gxlxesrg10e","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc2c008y7gxlcjiqpysy"},{"post_id":"cio5pdc29008v7gxlxesrg10e","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc2d008z7gxl3p4g057h"},{"post_id":"cio5pdc29008v7gxlxesrg10e","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdc2d00907gxldtd461ai"},{"post_id":"cio5pdc29008v7gxlxesrg10e","tag_id":"cio5pdc0g006d7gxl5o3ibwes","_id":"cio5pdc2d00917gxl2vg66eda"},{"post_id":"cio5pdc29008v7gxlxesrg10e","tag_id":"cio5pdc2b008x7gxlvmxjzsmb","_id":"cio5pdc2d00927gxluitwv8en"},{"post_id":"cio5pdc29008v7gxlxesrg10e","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdc2d00937gxlryuyhqyg"},{"post_id":"cio5pdc29008v7gxlxesrg10e","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdc2d00947gxl7kykk7hr"},{"post_id":"cio5pdc2e00957gxlqyprrsdc","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc2g00987gxlqjvl734g"},{"post_id":"cio5pdc2e00957gxlqyprrsdc","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc2h00997gxlh2aw98i2"},{"post_id":"cio5pdc2e00957gxlqyprrsdc","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdc2h009a7gxlnl31g6uv"},{"post_id":"cio5pdc2e00957gxlqyprrsdc","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc2h009b7gxlo8dxl7yp"},{"post_id":"cio5pdc2e00957gxlqyprrsdc","tag_id":"cio5pdc2f00977gxl68bup22o","_id":"cio5pdc2h009c7gxlgqx5wbi8"},{"post_id":"cio5pdc2i009d7gxlumwgqmhg","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc2l009h7gxl2nrc6fif"},{"post_id":"cio5pdc2i009d7gxlumwgqmhg","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc2m009i7gxlswmr797n"},{"post_id":"cio5pdc2i009d7gxlumwgqmhg","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdc2m009j7gxlyakf9q37"},{"post_id":"cio5pdc2i009d7gxlumwgqmhg","tag_id":"cio5pdc2k009f7gxlnjew189d","_id":"cio5pdc2m009k7gxln1hatach"},{"post_id":"cio5pdc2i009d7gxlumwgqmhg","tag_id":"cio5pdc2l009g7gxlw0pb8s7b","_id":"cio5pdc2m009l7gxl9bm87t35"},{"post_id":"cio5pdc2n009m7gxlki7qv37i","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc2q009q7gxl7shr01l9"},{"post_id":"cio5pdc2n009m7gxlki7qv37i","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc2r009r7gxl2h6zru9d"},{"post_id":"cio5pdc2n009m7gxlki7qv37i","tag_id":"cio5pdbye003l7gxlra9zc2zv","_id":"cio5pdc2r009s7gxlg2hhwkws"},{"post_id":"cio5pdc2n009m7gxlki7qv37i","tag_id":"cio5pdbye003m7gxlnqh5kta4","_id":"cio5pdc2r009t7gxlixk54civ"},{"post_id":"cio5pdc2n009m7gxlki7qv37i","tag_id":"cio5pdc2p009o7gxle76mq61s","_id":"cio5pdc2r009u7gxlor38rb9c"},{"post_id":"cio5pdc2n009m7gxlki7qv37i","tag_id":"cio5pdc2p009p7gxlt2xg447y","_id":"cio5pdc2r009v7gxl8a9bia1l"},{"post_id":"cio5pdc2n009m7gxlki7qv37i","tag_id":"cio5pdbyj003v7gxl10t24hjl","_id":"cio5pdc2r009w7gxljp24f7sk"},{"post_id":"cio5pdc2s009x7gxlv26o9ugw","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc2v00a17gxlh88mtauu"},{"post_id":"cio5pdc2s009x7gxlv26o9ugw","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc2w00a27gxl3btevjw2"},{"post_id":"cio5pdc2s009x7gxlv26o9ugw","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdc2w00a37gxlet8bgull"},{"post_id":"cio5pdc2s009x7gxlv26o9ugw","tag_id":"cio5pdc2b008x7gxlvmxjzsmb","_id":"cio5pdc2x00a47gxl0qdz4szg"},{"post_id":"cio5pdc2s009x7gxlv26o9ugw","tag_id":"cio5pdc2u009z7gxl4xaom7zh","_id":"cio5pdc2x00a57gxlg0o6oyop"},{"post_id":"cio5pdc2s009x7gxlv26o9ugw","tag_id":"cio5pdc2u00a07gxlaxrta1j6","_id":"cio5pdc2x00a67gxlhq5h6l74"},{"post_id":"cio5pdc2x00a77gxlvjsr26s3","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc2z00a97gxl1vhdxiab"},{"post_id":"cio5pdc2x00a77gxlvjsr26s3","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc3000aa7gxlt9vhqi2x"},{"post_id":"cio5pdc2x00a77gxlvjsr26s3","tag_id":"cio5pdbwn001u7gxlfrivh82f","_id":"cio5pdc3000ab7gxl6ytlhxuy"},{"post_id":"cio5pdc2x00a77gxlvjsr26s3","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc3000ac7gxl2d14uzer"},{"post_id":"cio5pdc3100ad7gxldtkg5k8d","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc3400af7gxla0xqd7dl"},{"post_id":"cio5pdc3100ad7gxldtkg5k8d","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc3500ag7gxlbb8qkaz3"},{"post_id":"cio5pdc3100ad7gxldtkg5k8d","tag_id":"cio5pdc21008e7gxlasctxpdl","_id":"cio5pdc3500ah7gxl74iiomyo"},{"post_id":"cio5pdc3100ad7gxldtkg5k8d","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdc3500ai7gxla3r9o63z"},{"post_id":"cio5pdc3100ad7gxldtkg5k8d","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdc3500aj7gxlwkf1pk1q"},{"post_id":"cio5pdc3100ad7gxldtkg5k8d","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdc3500ak7gxlqsdmi0pg"},{"post_id":"cio5pdc3100ad7gxldtkg5k8d","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdc3500al7gxlu0kn0vkr"},{"post_id":"cio5pdc3600am7gxlbbk8vdob","tag_id":"cio5pdc3900ao7gxlc87ha1y8","_id":"cio5pdc3a00aq7gxlyqotg0dm"},{"post_id":"cio5pdc3600am7gxlbbk8vdob","tag_id":"cio5pdc3a00ap7gxljh4b1do3","_id":"cio5pdc3b00ar7gxlsmx56xw6"},{"post_id":"cio5pdc3600am7gxlbbk8vdob","tag_id":"cio5pdbyq00457gxlaq3vgwft","_id":"cio5pdc3b00as7gxll14l5597"},{"post_id":"cio5pdc3600am7gxlbbk8vdob","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdc3b00at7gxlg3g57n3i"},{"post_id":"cio5pdc3c00au7gxl9ejcro5j","tag_id":"cio5pdc3900ao7gxlc87ha1y8","_id":"cio5pdc3f00az7gxliq29kzsp"},{"post_id":"cio5pdc3c00au7gxl9ejcro5j","tag_id":"cio5pdc3e00aw7gxln6ys7gpl","_id":"cio5pdc3g00b07gxlst2x2exl"},{"post_id":"cio5pdc3c00au7gxl9ejcro5j","tag_id":"cio5pdc3e00ax7gxlgb3up711","_id":"cio5pdc3g00b17gxlmoerwm7d"},{"post_id":"cio5pdc3c00au7gxl9ejcro5j","tag_id":"cio5pdc0g006d7gxl5o3ibwes","_id":"cio5pdc3g00b27gxlqfco93zs"},{"post_id":"cio5pdc3c00au7gxl9ejcro5j","tag_id":"cio5pdc1h007l7gxlckrssqdx","_id":"cio5pdc3h00b37gxl00crqvlg"},{"post_id":"cio5pdc3c00au7gxl9ejcro5j","tag_id":"cio5pdc3f00ay7gxlld9fxfdy","_id":"cio5pdc3h00b47gxl5ddaaez1"},{"post_id":"cio5pdc3i00b57gxlijbblc93","tag_id":"cio5pdc3900ao7gxlc87ha1y8","_id":"cio5pdc3k00b77gxl8sew0yvz"},{"post_id":"cio5pdc3i00b57gxlijbblc93","tag_id":"cio5pdbwd001m7gxlr7k9tz34","_id":"cio5pdc3l00b87gxldds7drud"},{"post_id":"cio5pdc3i00b57gxlijbblc93","tag_id":"cio5pdbwf001n7gxlglbf3ugu","_id":"cio5pdc3l00b97gxl3218um92"},{"post_id":"cio5pdc3i00b57gxlijbblc93","tag_id":"cio5pdbx8002m7gxl5rgyho8l","_id":"cio5pdc3l00ba7gxlfqi27exv"},{"post_id":"cio5pdc3i00b57gxlijbblc93","tag_id":"cio5pdbvd00107gxl5dgcf65d","_id":"cio5pdc3l00bb7gxlmvpfgmsk"},{"post_id":"cio5pdc3i00b57gxlijbblc93","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdc3l00bc7gxlesxn86l2"},{"post_id":"cio5pdc3n00bd7gxl8ns3jgyl","tag_id":"cio5pdbtv000h7gxlbjurbwt4","_id":"cio5pdc3q00bg7gxla30jauj1"},{"post_id":"cio5pdc3n00bd7gxl8ns3jgyl","tag_id":"cio5pdc3o00bf7gxl6bigzodf","_id":"cio5pdc3q00bh7gxl2f1x55u3"},{"post_id":"cio5pdc4p00bi7gxla72agt47","tag_id":"cio5pdbtv000h7gxlbjurbwt4","_id":"cio5pdc4s00bl7gxl17582cf2"},{"post_id":"cio5pdc4p00bi7gxla72agt47","tag_id":"cio5pdc4q00bk7gxlu6rb4v8h","_id":"cio5pdc4t00bm7gxl7ciqyvxt"},{"post_id":"cio5pdc4x00bn7gxlo5visj96","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdc4y00bp7gxl73chitd3"},{"post_id":"cio5pdc4x00bn7gxlo5visj96","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdc4z00bq7gxlbqw481ta"},{"post_id":"cio5pdc4x00bn7gxlo5visj96","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdc4z00br7gxlwww66nme"},{"post_id":"cio5pdc4x00bn7gxlo5visj96","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdc4z00bs7gxltxvtis6u"},{"post_id":"cio5pdc5000bt7gxl9opg9hci","tag_id":"cio5pdbyx004f7gxldr0hor7k","_id":"cio5pdc5400bw7gxl9pnjcpro"},{"post_id":"cio5pdc5000bt7gxl9opg9hci","tag_id":"cio5pdc5300bv7gxln4l63mzg","_id":"cio5pdc5500bx7gxlgidszdjm"},{"post_id":"cio5pdc5000bt7gxl9opg9hci","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdc5500by7gxlleduorla"},{"post_id":"cio5pdc5000bt7gxl9opg9hci","tag_id":"cio5pdbye003m7gxlnqh5kta4","_id":"cio5pdc5500bz7gxlrlw88qgu"},{"post_id":"cio5pdc5000bt7gxl9opg9hci","tag_id":"cio5pdbye003l7gxlra9zc2zv","_id":"cio5pdc5500c07gxltvngg6l5"},{"post_id":"cio5pdc5000bt7gxl9opg9hci","tag_id":"cio5pdbsv00037gxlvjwoomqj","_id":"cio5pdc5500c17gxl57kdbn9e"},{"post_id":"cio5pdc5600c27gxlrudhw41n","tag_id":"cio5pdc5800c47gxlym32ixlk","_id":"cio5pdc5a00c67gxl42eaj188"},{"post_id":"cio5pdc5600c27gxlrudhw41n","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc5a00c77gxlsrx8tj2c"},{"post_id":"cio5pdc5600c27gxlrudhw41n","tag_id":"cio5pdbxj002z7gxl1s8lmudr","_id":"cio5pdc5a00c87gxlcqjfc845"},{"post_id":"cio5pdc5600c27gxlrudhw41n","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdc5a00c97gxlswxbdeul"},{"post_id":"cio5pdc5600c27gxlrudhw41n","tag_id":"cio5pdc5900c57gxloprefquh","_id":"cio5pdc5a00ca7gxlgabz0khh"},{"post_id":"cio5pdc5600c27gxlrudhw41n","tag_id":"cio5pdbww00237gxlmvwl7ksr","_id":"cio5pdc5b00cb7gxlvavoxqz6"},{"post_id":"cio5pdc5b00cc7gxltax11l2n","tag_id":"cio5pdc5800c47gxlym32ixlk","_id":"cio5pdc5e00ch7gxlr5ux25k7"},{"post_id":"cio5pdc5b00cc7gxltax11l2n","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc5f00ci7gxl7nacmpfn"},{"post_id":"cio5pdc5b00cc7gxltax11l2n","tag_id":"cio5pdc5d00ce7gxl11x5i8p4","_id":"cio5pdc5f00cj7gxlz63gx8ai"},{"post_id":"cio5pdc5b00cc7gxltax11l2n","tag_id":"cio5pdc5d00cf7gxls80irt27","_id":"cio5pdc5f00ck7gxlux6pt1nm"},{"post_id":"cio5pdc5b00cc7gxltax11l2n","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdc5f00cl7gxl9njj3yja"},{"post_id":"cio5pdc5b00cc7gxltax11l2n","tag_id":"cio5pdc0g006d7gxl5o3ibwes","_id":"cio5pdc5f00cm7gxlu1l7y4ds"},{"post_id":"cio5pdc5b00cc7gxltax11l2n","tag_id":"cio5pdc5e00cg7gxluzwagfcb","_id":"cio5pdc5f00cn7gxlbzjruafw"},{"post_id":"cio5pdc5g00co7gxl9efaah6b","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc5i00cq7gxl80nsrfeh"},{"post_id":"cio5pdc5g00co7gxl9efaah6b","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc5j00cr7gxllnjf07nh"},{"post_id":"cio5pdc5g00co7gxl9efaah6b","tag_id":"cio5pdc5800c47gxlym32ixlk","_id":"cio5pdc5j00cs7gxlcyvr7pzb"},{"post_id":"cio5pdc5g00co7gxl9efaah6b","tag_id":"cio5pdbxj002z7gxl1s8lmudr","_id":"cio5pdc5j00ct7gxl4ndbd5lp"},{"post_id":"cio5pdc5g00co7gxl9efaah6b","tag_id":"cio5pdbvc000z7gxldbi3v0iv","_id":"cio5pdc5j00cu7gxlsd07c5x7"},{"post_id":"cio5pdc5k00cv7gxldukxbeh1","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc5l00cx7gxlwtaf82hu"},{"post_id":"cio5pdc5k00cv7gxldukxbeh1","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc5m00cy7gxlfg94iuk6"},{"post_id":"cio5pdc5k00cv7gxldukxbeh1","tag_id":"cio5pdbxj002z7gxl1s8lmudr","_id":"cio5pdc5m00cz7gxl678cnie5"},{"post_id":"cio5pdc5k00cv7gxldukxbeh1","tag_id":"cio5pdc5d00ce7gxl11x5i8p4","_id":"cio5pdc5m00d07gxl0dyj4wt9"},{"post_id":"cio5pdc5k00cv7gxldukxbeh1","tag_id":"cio5pdc2f00977gxl68bup22o","_id":"cio5pdc5m00d17gxltc0l8aa6"},{"post_id":"cio5pdc5k00cv7gxldukxbeh1","tag_id":"cio5pdc5d00cf7gxls80irt27","_id":"cio5pdc5m00d27gxlsqlqazq5"},{"post_id":"cio5pdc5k00cv7gxldukxbeh1","tag_id":"cio5pdbx2002e7gxl98dbwg2u","_id":"cio5pdc5m00d37gxlkcjk7dds"},{"post_id":"cio5pdc5n00d47gxlxpxf1sqd","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc5p00d67gxlgjyyest8"},{"post_id":"cio5pdc5n00d47gxlxpxf1sqd","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc5q00d77gxlkqijgrl1"},{"post_id":"cio5pdc5n00d47gxlxpxf1sqd","tag_id":"cio5pdc5800c47gxlym32ixlk","_id":"cio5pdc5q00d87gxl8xf9l5ze"},{"post_id":"cio5pdc5n00d47gxlxpxf1sqd","tag_id":"cio5pdbxk00307gxlzi5bqtbs","_id":"cio5pdc5q00d97gxlk7ripcyl"},{"post_id":"cio5pdc5n00d47gxlxpxf1sqd","tag_id":"cio5pdc5d00cf7gxls80irt27","_id":"cio5pdc5q00da7gxl5p1olglr"},{"post_id":"cio5pdc5n00d47gxlxpxf1sqd","tag_id":"cio5pdbxj002z7gxl1s8lmudr","_id":"cio5pdc5q00db7gxljrsvort5"},{"post_id":"cio5pdc5r00dc7gxls3txrtmt","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc5t00de7gxlt3oc76s0"},{"post_id":"cio5pdc5r00dc7gxls3txrtmt","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc5u00df7gxl44tnaw5p"},{"post_id":"cio5pdc5r00dc7gxls3txrtmt","tag_id":"cio5pdc5800c47gxlym32ixlk","_id":"cio5pdc5u00dg7gxlkx8y90jt"},{"post_id":"cio5pdc5r00dc7gxls3txrtmt","tag_id":"cio5pdbxk00307gxlzi5bqtbs","_id":"cio5pdc5u00dh7gxl36397nxe"},{"post_id":"cio5pdc5v00di7gxlptmqzgmm","tag_id":"cio5pdc5w00dk7gxlm32grigd","_id":"cio5pdc5z00dp7gxle8e6aqi9"},{"post_id":"cio5pdc5v00di7gxlptmqzgmm","tag_id":"cio5pdc5x00dl7gxlco5c19k5","_id":"cio5pdc5z00dq7gxlz3wcakmy"},{"post_id":"cio5pdc5v00di7gxlptmqzgmm","tag_id":"cio5pdc5x00dm7gxlostly15j","_id":"cio5pdc5z00dr7gxlp7r8q8te"},{"post_id":"cio5pdc5v00di7gxlptmqzgmm","tag_id":"cio5pdc5y00dn7gxlg5x0tlzj","_id":"cio5pdc5z00ds7gxlep35nih3"},{"post_id":"cio5pdc5v00di7gxlptmqzgmm","tag_id":"cio5pdc5y00do7gxlz3305p0r","_id":"cio5pdc5z00dt7gxl6cad49gu"},{"post_id":"cio5pdc6000du7gxly53a1g0o","tag_id":"cio5pdc5w00dk7gxlm32grigd","_id":"cio5pdc6200dw7gxlee7lcamc"},{"post_id":"cio5pdc6000du7gxly53a1g0o","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc6a00dx7gxlr77w0em6"},{"post_id":"cio5pdc6000du7gxly53a1g0o","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc6a00dy7gxlio2mthqe"},{"post_id":"cio5pdc6000du7gxly53a1g0o","tag_id":"cio5pdbsv00037gxlvjwoomqj","_id":"cio5pdc6a00dz7gxludkgv2qt"},{"post_id":"cio5pdc6000du7gxly53a1g0o","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc6a00e07gxl3c0zwziq"},{"post_id":"cio5pdc6000du7gxly53a1g0o","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdc6a00e17gxlqm3rcfuo"},{"post_id":"cio5pdc6b00e27gxlh9irpqcx","tag_id":"cio5pdc5w00dk7gxlm32grigd","_id":"cio5pdc6d00e47gxlj3xlhgz4"},{"post_id":"cio5pdc6b00e27gxlh9irpqcx","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc6d00e57gxl7jc4q32m"},{"post_id":"cio5pdc6b00e27gxlh9irpqcx","tag_id":"cio5pdbzt005f7gxli6q2re54","_id":"cio5pdc6d00e67gxl7puvktyw"},{"post_id":"cio5pdc6b00e27gxlh9irpqcx","tag_id":"cio5pdc2k009f7gxlnjew189d","_id":"cio5pdc6d00e77gxlk1r32eda"},{"post_id":"cio5pdc6e00e87gxll1p2348l","tag_id":"cio5pdc5w00dk7gxlm32grigd","_id":"cio5pdc6h00ec7gxlapfq3h9i"},{"post_id":"cio5pdc6e00e87gxll1p2348l","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc6i00ed7gxlnzlqc9qy"},{"post_id":"cio5pdc6e00e87gxll1p2348l","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc6i00ee7gxlq21ay04g"},{"post_id":"cio5pdc6e00e87gxll1p2348l","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdc6i00ef7gxl5hqm5769"},{"post_id":"cio5pdc6e00e87gxll1p2348l","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdc6i00eg7gxlqme6zgbq"},{"post_id":"cio5pdc6e00e87gxll1p2348l","tag_id":"cio5pdc6g00ea7gxlir6b5ij5","_id":"cio5pdc6i00eh7gxlgo44xubp"},{"post_id":"cio5pdc6e00e87gxll1p2348l","tag_id":"cio5pdc6g00eb7gxl165obbay","_id":"cio5pdc6i00ei7gxlgzjmy0fl"},{"post_id":"cio5pdc6e00e87gxll1p2348l","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdc6i00ej7gxlhgq10sc1"},{"post_id":"cio5pdc6j00ek7gxl3l09l5co","tag_id":"cio5pdc5w00dk7gxlm32grigd","_id":"cio5pdc6n00em7gxlg6ougyp4"},{"post_id":"cio5pdc6j00ek7gxl3l09l5co","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc6o00en7gxlz9wnz5m9"},{"post_id":"cio5pdc6j00ek7gxl3l09l5co","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc6o00eo7gxlezkjj6dv"},{"post_id":"cio5pdc6j00ek7gxl3l09l5co","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdc6o00ep7gxlorq2obqq"},{"post_id":"cio5pdc6j00ek7gxl3l09l5co","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdc6o00eq7gxlfai4l7fy"},{"post_id":"cio5pdc6j00ek7gxl3l09l5co","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc6o00er7gxlyviaq30m"},{"post_id":"cio5pdc6p00es7gxlvfiss8zu","tag_id":"cio5pdc5w00dk7gxlm32grigd","_id":"cio5pdc6t00eu7gxlnyjltkpk"},{"post_id":"cio5pdc6p00es7gxlvfiss8zu","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc6u00ev7gxlfd29e6yr"},{"post_id":"cio5pdc6p00es7gxlvfiss8zu","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdc6u00ew7gxlkamejjp2"},{"post_id":"cio5pdc6p00es7gxlvfiss8zu","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdc6u00ex7gxlvqmjclic"},{"post_id":"cio5pdc6p00es7gxlvfiss8zu","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc6u00ey7gxlh683rs16"},{"post_id":"cio5pdc6v00ez7gxlgxuh8l20","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc6x00f17gxldazlpenl"},{"post_id":"cio5pdc6v00ez7gxlgxuh8l20","tag_id":"cio5pdc5w00dk7gxlm32grigd","_id":"cio5pdc6x00f27gxlrjx2qhrr"},{"post_id":"cio5pdc6v00ez7gxlgxuh8l20","tag_id":"cio5pdc5x00dm7gxlostly15j","_id":"cio5pdc6x00f37gxl1xih8got"},{"post_id":"cio5pdc6y00f47gxlq5i526pn","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdc7000f67gxl50ihb81q"},{"post_id":"cio5pdc6y00f47gxlq5i526pn","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdc7100f77gxlxkoyg5ln"},{"post_id":"cio5pdc6y00f47gxlq5i526pn","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdc7100f87gxlf0noioh9"},{"post_id":"cio5pdc6y00f47gxlq5i526pn","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdc7100f97gxlflgnykdk"},{"post_id":"cio5pdc6y00f47gxlq5i526pn","tag_id":"cio5pdbww00237gxlmvwl7ksr","_id":"cio5pdc7100fa7gxlshn4vmqa"},{"post_id":"cio5pdc7300fb7gxl7xogketu","tag_id":"cio5pdc0o006r7gxlpuwptv4k","_id":"cio5pdc7500fd7gxlae4y6cps"},{"post_id":"cio5pdc7300fb7gxl7xogketu","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdc7600fe7gxlsn36bin6"},{"post_id":"cio5pdc7300fb7gxl7xogketu","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc7600ff7gxlkpnnlzf2"},{"post_id":"cio5pdc7300fb7gxl7xogketu","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdc7600fg7gxlarv30mmx"},{"post_id":"cio5pdc7300fb7gxl7xogketu","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdc7600fh7gxltc94hyh2"},{"post_id":"cio5pdc7700fi7gxlrjns3ou0","tag_id":"cio5pdc7800fk7gxlh8fa9xoa","_id":"cio5pdc7900fl7gxlvna4s5bd"},{"post_id":"cio5pdc7700fi7gxlrjns3ou0","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdc7a00fm7gxlgizymngg"},{"post_id":"cio5pdc7700fi7gxlrjns3ou0","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc7a00fn7gxlj713jt7x"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdc7c00fq7gxlzzp8vanc","_id":"cio5pdc7d00fs7gxlv42ojfpp"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdc3900ao7gxlc87ha1y8","_id":"cio5pdc7e00ft7gxlnz5perok"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdc3e00aw7gxln6ys7gpl","_id":"cio5pdc7f00fu7gxly8n5n34n"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdc2l009g7gxlw0pb8s7b","_id":"cio5pdc7f00fv7gxlu2tufci1"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdc7f00fw7gxlf3zg09gk"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdc7f00fx7gxlmcp90r4d"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdc5x00dm7gxlostly15j","_id":"cio5pdc7f00fy7gxlcru69zfi"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdc7d00fr7gxl6jrewa07","_id":"cio5pdc7f00fz7gxlbw3dif34"},{"post_id":"cio5pdc7b00fo7gxlh8z62fyr","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdc7f00g07gxlq9337hgw"},{"post_id":"cio5pdc7g00g17gxlxib44pzr","tag_id":"cio5pdc7h00g37gxl05g9q3vg","_id":"cio5pdc7j00g67gxlwz4zqc74"},{"post_id":"cio5pdc7g00g17gxlxib44pzr","tag_id":"cio5pdc7i00g47gxlfr9uwfqf","_id":"cio5pdc7k00g77gxlig1ibj5p"},{"post_id":"cio5pdc7g00g17gxlxib44pzr","tag_id":"cio5pdc7j00g57gxlfyazw2bo","_id":"cio5pdc7k00g87gxlnezsqc3e"},{"post_id":"cio5pdc7l00g97gxl2alvczf5","tag_id":"cio5pdc1v00847gxlzqvb06i5","_id":"cio5pdc7m00gb7gxlegcl7bcg"},{"post_id":"cio5pdc7l00g97gxl2alvczf5","tag_id":"cio5pdc1p00837gxl2cuoe7ki","_id":"cio5pdc7n00gc7gxljyvgso5a"},{"post_id":"cio5pdc7l00g97gxl2alvczf5","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdc7n00gd7gxla37gzyn6"},{"post_id":"cio5pdc7l00g97gxl2alvczf5","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc7n00ge7gxl3dy6n1a8"},{"post_id":"cio5pdc7l00g97gxl2alvczf5","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdc7n00gf7gxl0i2umr48"},{"post_id":"cio5pdc7l00g97gxl2alvczf5","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdc7n00gg7gxlkynovh32"},{"post_id":"cio5pdc7p00gh7gxlh9qtvwxz","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc7q00gj7gxl8mhmhd07"},{"post_id":"cio5pdc7p00gh7gxlh9qtvwxz","tag_id":"cio5pdc3a00ap7gxljh4b1do3","_id":"cio5pdc7r00gk7gxl3tfdwvxo"},{"post_id":"cio5pdc7p00gh7gxlh9qtvwxz","tag_id":"cio5pdbyq00457gxlaq3vgwft","_id":"cio5pdc7r00gl7gxly3am81fy"},{"post_id":"cio5pdc7p00gh7gxlh9qtvwxz","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdc7r00gm7gxluvqkj3zp"},{"post_id":"cio5pdc7p00gh7gxlh9qtvwxz","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdc7r00gn7gxliqjycnrq"},{"post_id":"cio5pdc7s00go7gxlqo6z2sav","tag_id":"cio5pdc7u00gq7gxlgpk70pf1","_id":"cio5pdc7v00gs7gxlofatw0ll"},{"post_id":"cio5pdc7s00go7gxlqo6z2sav","tag_id":"cio5pdc7u00gr7gxlngn0hejl","_id":"cio5pdc7v00gt7gxl1n6oe3l2"},{"post_id":"cio5pdc7s00go7gxlqo6z2sav","tag_id":"cio5pdc22008g7gxlh187bdoa","_id":"cio5pdc7v00gu7gxlewn8xgxn"},{"post_id":"cio5pdc7s00go7gxlqo6z2sav","tag_id":"cio5pdc0v00707gxlmyg6e9aj","_id":"cio5pdc7v00gv7gxl7diy8ka6"},{"post_id":"cio5pdc7w00gw7gxlu7kkccpn","tag_id":"cio5pdc7u00gq7gxlgpk70pf1","_id":"cio5pdc7z00gz7gxlkaw93ury"},{"post_id":"cio5pdc7w00gw7gxlu7kkccpn","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdc7z00h07gxln6hodffw"},{"post_id":"cio5pdc7w00gw7gxlu7kkccpn","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdc7z00h17gxlnu1o3xnn"},{"post_id":"cio5pdc7w00gw7gxlu7kkccpn","tag_id":"cio5pdbyk003w7gxl5kxm7nfb","_id":"cio5pdc7z00h27gxlu5t9tlwr"},{"post_id":"cio5pdc7w00gw7gxlu7kkccpn","tag_id":"cio5pdc7y00gy7gxlb5rackiw","_id":"cio5pdc7z00h37gxlzbi5cvf6"},{"post_id":"cio5pdc8000h47gxlc5dhu6bz","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc8300h77gxl2i43n1e9"},{"post_id":"cio5pdc8000h47gxlc5dhu6bz","tag_id":"cio5pdc7u00gq7gxlgpk70pf1","_id":"cio5pdc8400h87gxlds2sgka5"},{"post_id":"cio5pdc8000h47gxlc5dhu6bz","tag_id":"cio5pdc8200h67gxl34grrou7","_id":"cio5pdc8400h97gxlegwnyfb0"},{"post_id":"cio5pdc8000h47gxlc5dhu6bz","tag_id":"cio5pdc2b008x7gxlvmxjzsmb","_id":"cio5pdc8400ha7gxlcpm2g2qf"},{"post_id":"cio5pdc8000h47gxlc5dhu6bz","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdc8400hb7gxld67rej8k"},{"post_id":"cio5pdc8000h47gxlc5dhu6bz","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdc8400hc7gxle6obfi5u"},{"post_id":"cio5pdc8500hd7gxl98iox26o","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc8600hf7gxllkxzx8np"},{"post_id":"cio5pdc8500hd7gxl98iox26o","tag_id":"cio5pdc7u00gq7gxlgpk70pf1","_id":"cio5pdc8700hg7gxlzd2m4ava"},{"post_id":"cio5pdc8500hd7gxl98iox26o","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdc8700hh7gxlpbln1xgd"},{"post_id":"cio5pdc8500hd7gxl98iox26o","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdc8700hi7gxleffd7l40"},{"post_id":"cio5pdc8500hd7gxl98iox26o","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdc8700hj7gxlgmg6m83s"},{"post_id":"cio5pdc8800hk7gxl1ky688fk","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc8b00ho7gxld91sofqu"},{"post_id":"cio5pdc8800hk7gxl1ky688fk","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc8c00hp7gxlwrklaxw1"},{"post_id":"cio5pdc8800hk7gxl1ky688fk","tag_id":"cio5pdc8a00hm7gxlyftgig8j","_id":"cio5pdc8c00hq7gxl0d96et2w"},{"post_id":"cio5pdc8800hk7gxl1ky688fk","tag_id":"cio5pdbsv00037gxlvjwoomqj","_id":"cio5pdc8c00hr7gxl11ccj5mi"},{"post_id":"cio5pdc8800hk7gxl1ky688fk","tag_id":"cio5pdc8a00hn7gxl4sw57dfa","_id":"cio5pdc8c00hs7gxluo2w594b"},{"post_id":"cio5pdc8800hk7gxl1ky688fk","tag_id":"cio5pdc1400797gxl6dckrhhu","_id":"cio5pdc8c00ht7gxl627bo3ym"},{"post_id":"cio5pdc8d00hu7gxl5sxvs8n3","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc8e00hw7gxlekddzt8o"},{"post_id":"cio5pdc8d00hu7gxl5sxvs8n3","tag_id":"cio5pdc8a00hm7gxlyftgig8j","_id":"cio5pdc8f00hx7gxl0s1jdz0d"},{"post_id":"cio5pdc8d00hu7gxl5sxvs8n3","tag_id":"cio5pdc7800fk7gxlh8fa9xoa","_id":"cio5pdc8f00hy7gxlusz525pf"},{"post_id":"cio5pdc8d00hu7gxl5sxvs8n3","tag_id":"cio5pdc0v00707gxlmyg6e9aj","_id":"cio5pdc8f00hz7gxl5z7btto6"},{"post_id":"cio5pdc8h00i07gxlx08y4cu0","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc8j00i37gxlofye1fqe"},{"post_id":"cio5pdc8h00i07gxlx08y4cu0","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc8k00i47gxlw1nqq57n"},{"post_id":"cio5pdc8h00i07gxlx08y4cu0","tag_id":"cio5pdc8a00hm7gxlyftgig8j","_id":"cio5pdc8k00i57gxle0kis7nx"},{"post_id":"cio5pdc8h00i07gxlx08y4cu0","tag_id":"cio5pdbsv00037gxlvjwoomqj","_id":"cio5pdc8k00i67gxl29v2x53h"},{"post_id":"cio5pdc8h00i07gxlx08y4cu0","tag_id":"cio5pdc8i00i27gxlmm3dqsj9","_id":"cio5pdc8k00i77gxlbasqdzru"},{"post_id":"cio5pdc8x00i87gxle231ll57","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc9200ia7gxlifl71rkg"},{"post_id":"cio5pdc8x00i87gxle231ll57","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc9300ib7gxld37th5vh"},{"post_id":"cio5pdc8x00i87gxle231ll57","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc9300ic7gxltmzm0h17"},{"post_id":"cio5pdc8x00i87gxle231ll57","tag_id":"cio5pdc8a00hm7gxlyftgig8j","_id":"cio5pdc9300id7gxl3nd0bnqj"},{"post_id":"cio5pdc8x00i87gxle231ll57","tag_id":"cio5pdc7u00gr7gxlngn0hejl","_id":"cio5pdc9300ie7gxld43jxkmd"},{"post_id":"cio5pdc8x00i87gxle231ll57","tag_id":"cio5pdc5x00dm7gxlostly15j","_id":"cio5pdc9300if7gxld24sl6mq"},{"post_id":"cio5pdc9400ig7gxlo6tw62ih","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc9700ii7gxl8lfdvbkd"},{"post_id":"cio5pdc9400ig7gxlo6tw62ih","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc9800ij7gxlmlpuplno"},{"post_id":"cio5pdc9400ig7gxlo6tw62ih","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdc9800ik7gxl86tkmhc5"},{"post_id":"cio5pdc9400ig7gxlo6tw62ih","tag_id":"cio5pdc8a00hm7gxlyftgig8j","_id":"cio5pdc9800il7gxlgieibyt6"},{"post_id":"cio5pdc9400ig7gxlo6tw62ih","tag_id":"cio5pdc0n006q7gxl3cre2ot6","_id":"cio5pdc9800im7gxlizo34ipd"},{"post_id":"cio5pdc9400ig7gxlo6tw62ih","tag_id":"cio5pdc0o006r7gxlpuwptv4k","_id":"cio5pdc9800in7gxlivd23czc"},{"post_id":"cio5pdc9400ig7gxlo6tw62ih","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc9800io7gxl111zbfzq"},{"post_id":"cio5pdc9a00ip7gxlhyg3cpv4","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdc9c00ir7gxlxxumhowr"},{"post_id":"cio5pdc9a00ip7gxlhyg3cpv4","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdc9e00is7gxlx3febl9g"},{"post_id":"cio5pdc9a00ip7gxlhyg3cpv4","tag_id":"cio5pdc8a00hm7gxlyftgig8j","_id":"cio5pdc9e00it7gxl76z7qcvx"},{"post_id":"cio5pdc9a00ip7gxlhyg3cpv4","tag_id":"cio5pdc22008f7gxldf5qw2kl","_id":"cio5pdc9e00iu7gxlxzy9ofs6"},{"post_id":"cio5pdc9a00ip7gxlhyg3cpv4","tag_id":"cio5pdbyx004f7gxldr0hor7k","_id":"cio5pdc9e00iv7gxlma5tprkx"},{"post_id":"cio5pdc9g00iw7gxlhg61978n","tag_id":"cio5pdc9h00iy7gxlzc8xbvyz","_id":"cio5pdc9j00j07gxl458b4okw"},{"post_id":"cio5pdc9g00iw7gxlhg61978n","tag_id":"cio5pdc9i00iz7gxl1ywidqjk","_id":"cio5pdc9k00j17gxl4braukhl"},{"post_id":"cio5pdc9g00iw7gxlhg61978n","tag_id":"cio5pdbwn001u7gxlfrivh82f","_id":"cio5pdc9k00j27gxlym3tu9t6"},{"post_id":"cio5pdc9g00iw7gxlhg61978n","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc9k00j37gxlmowtzvvp"},{"post_id":"cio5pdc9l00j47gxlo9q5g4g9","tag_id":"cio5pdc9h00iy7gxlzc8xbvyz","_id":"cio5pdc9m00j67gxl97xw0kso"},{"post_id":"cio5pdc9l00j47gxlo9q5g4g9","tag_id":"cio5pdbwn001u7gxlfrivh82f","_id":"cio5pdc9n00j77gxl7tp2r83j"},{"post_id":"cio5pdc9l00j47gxlo9q5g4g9","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc9n00j87gxl2yk0j6mq"},{"post_id":"cio5pdc9o00j97gxlwb6tgu8b","tag_id":"cio5pdc9h00iy7gxlzc8xbvyz","_id":"cio5pdc9q00jb7gxlsyo6p9sj"},{"post_id":"cio5pdc9o00j97gxlwb6tgu8b","tag_id":"cio5pdbwn001u7gxlfrivh82f","_id":"cio5pdc9q00jc7gxl7fmkc5ff"},{"post_id":"cio5pdc9o00j97gxlwb6tgu8b","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdc9q00jd7gxlchkaay5f"},{"post_id":"cio5pdc9r00je7gxlfjklrjin","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdca900jh7gxlk3lwxoty"},{"post_id":"cio5pdc9r00je7gxlfjklrjin","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcaa00ji7gxl0kj3tsvs"},{"post_id":"cio5pdc9r00je7gxlfjklrjin","tag_id":"cio5pdc9t00jg7gxlxkuwlwzw","_id":"cio5pdcaa00jj7gxlvcovgz4q"},{"post_id":"cio5pdc9r00je7gxlfjklrjin","tag_id":"cio5pdc2p009p7gxlt2xg447y","_id":"cio5pdcaa00jk7gxl5c8i98zf"},{"post_id":"cio5pdc9r00je7gxlfjklrjin","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcaa00jl7gxlfypsho88"},{"post_id":"cio5pdcac00jm7gxl5i54isf7","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcaf00jp7gxlqiz6tga2"},{"post_id":"cio5pdcac00jm7gxl5i54isf7","tag_id":"cio5pdc9t00jg7gxlxkuwlwzw","_id":"cio5pdcaf00jq7gxltj89u27g"},{"post_id":"cio5pdcac00jm7gxl5i54isf7","tag_id":"cio5pdbsv00037gxlvjwoomqj","_id":"cio5pdcag00jr7gxlo6qjuzoq"},{"post_id":"cio5pdcac00jm7gxl5i54isf7","tag_id":"cio5pdbsv00047gxlfvn3oupy","_id":"cio5pdcag00js7gxlehfp7wiu"},{"post_id":"cio5pdcac00jm7gxl5i54isf7","tag_id":"cio5pdcae00jo7gxlqyxkp91i","_id":"cio5pdcag00jt7gxl7cj20f0a"},{"post_id":"cio5pdcag00ju7gxlldwvtg4e","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcaj00jx7gxlse3skokb"},{"post_id":"cio5pdcag00ju7gxlldwvtg4e","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcak00jy7gxllw9wk028"},{"post_id":"cio5pdcag00ju7gxlldwvtg4e","tag_id":"cio5pdc9t00jg7gxlxkuwlwzw","_id":"cio5pdcak00jz7gxlou4r8v1i"},{"post_id":"cio5pdcag00ju7gxlldwvtg4e","tag_id":"cio5pdcai00jw7gxlk6eiqxcy","_id":"cio5pdcal00k07gxlmvv5o9iw"},{"post_id":"cio5pdcag00ju7gxlldwvtg4e","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdcal00k17gxlli6up7qp"},{"post_id":"cio5pdcag00ju7gxlldwvtg4e","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdcal00k27gxljcjbbs59"},{"post_id":"cio5pdcag00ju7gxlldwvtg4e","tag_id":"cio5pdc0e006a7gxl9r6uk5gw","_id":"cio5pdcal00k37gxlu2b86q85"},{"post_id":"cio5pdcb300k47gxlulrcl53w","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcb800k67gxlhnwvq95a"},{"post_id":"cio5pdcb300k47gxlulrcl53w","tag_id":"cio5pdc9t00jg7gxlxkuwlwzw","_id":"cio5pdcb900k77gxl0zn3yjny"},{"post_id":"cio5pdcb300k47gxlulrcl53w","tag_id":"cio5pdbye003l7gxlra9zc2zv","_id":"cio5pdcba00k87gxlrx684sze"},{"post_id":"cio5pdcb300k47gxlulrcl53w","tag_id":"cio5pdbye003m7gxlnqh5kta4","_id":"cio5pdcba00k97gxlnhyay410"},{"post_id":"cio5pdcb300k47gxlulrcl53w","tag_id":"cio5pdc2p009o7gxle76mq61s","_id":"cio5pdcba00ka7gxlbwtavied"},{"post_id":"cio5pdcbb00kb7gxluczgmi86","tag_id":"cio5pdcbd00kd7gxl7hljt5sq","_id":"cio5pdcbe00kf7gxl55e8gwcw"},{"post_id":"cio5pdcbb00kb7gxluczgmi86","tag_id":"cio5pdcbd00ke7gxlv30gxnol","_id":"cio5pdcbe00kg7gxlfjod6p79"},{"post_id":"cio5pdcbb00kb7gxluczgmi86","tag_id":"cio5pdbyw004e7gxlts06y0a6","_id":"cio5pdcbe00kh7gxlphwhu0qx"},{"post_id":"cio5pdcbf00ki7gxlk2koowhj","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdcbh00kk7gxlekyrgg2g"},{"post_id":"cio5pdcbf00ki7gxlk2koowhj","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdcbi00kl7gxlt3nixzqz"},{"post_id":"cio5pdcbf00ki7gxlk2koowhj","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdcbi00km7gxly5ft7wdu"},{"post_id":"cio5pdcbf00ki7gxlk2koowhj","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdcbi00kn7gxlffgwimvd"},{"post_id":"cio5pdcbf00ki7gxlk2koowhj","tag_id":"cio5pdc0e006a7gxl9r6uk5gw","_id":"cio5pdcbi00ko7gxl5gym0sxo"},{"post_id":"cio5pdcbj00kp7gxljb9uj75l","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcbl00kr7gxl9sg7cu1m"},{"post_id":"cio5pdcbj00kp7gxljb9uj75l","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcbm00ks7gxlvu0icd4s"},{"post_id":"cio5pdcbj00kp7gxljb9uj75l","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdcbm00kt7gxlttu05zx1"},{"post_id":"cio5pdcbj00kp7gxljb9uj75l","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdcbm00ku7gxlxzizquki"},{"post_id":"cio5pdcbj00kp7gxljb9uj75l","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdcbm00kv7gxl3pa17mcp"},{"post_id":"cio5pdcbj00kp7gxljb9uj75l","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdcbm00kw7gxlpmw564jh"},{"post_id":"cio5pdcbn00kx7gxlaermrpai","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdcbo00kz7gxlxnaxoshl"},{"post_id":"cio5pdcbn00kx7gxlaermrpai","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcbp00l07gxlikiyhg6s"},{"post_id":"cio5pdcbn00kx7gxlaermrpai","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcbp00l17gxlh4j55cr9"},{"post_id":"cio5pdcbn00kx7gxlaermrpai","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdcbp00l27gxlopc3a48r"},{"post_id":"cio5pdcbn00kx7gxlaermrpai","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdcbp00l37gxljsiri79e"},{"post_id":"cio5pdcbq00l47gxl49z36wv5","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdcbs00l67gxlzor4gjmn"},{"post_id":"cio5pdcbq00l47gxl49z36wv5","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdcbt00l77gxlhnqfa254"},{"post_id":"cio5pdcbq00l47gxl49z36wv5","tag_id":"cio5pdc06005y7gxlxtjuu9d1","_id":"cio5pdcbt00l87gxl23v8f6ke"},{"post_id":"cio5pdcbu00l97gxlo5v8n43d","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcbv00lb7gxl4fvm7hf4"},{"post_id":"cio5pdcbu00l97gxlo5v8n43d","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcbw00lc7gxl7p6n2z1e"},{"post_id":"cio5pdcbu00l97gxlo5v8n43d","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdcbw00ld7gxlzifxpwru"},{"post_id":"cio5pdcbu00l97gxlo5v8n43d","tag_id":"cio5pdbsv00037gxlvjwoomqj","_id":"cio5pdcbx00le7gxlxvx9trmw"},{"post_id":"cio5pdcbu00l97gxlo5v8n43d","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdcbx00lf7gxlsjztkwpb"},{"post_id":"cio5pdcbu00l97gxlo5v8n43d","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdcbx00lg7gxlok2h7vxg"},{"post_id":"cio5pdcc000lh7gxl0zs1qtlr","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcc300ll7gxlvtoas8fn"},{"post_id":"cio5pdcc000lh7gxl0zs1qtlr","tag_id":"cio5pdcc100lj7gxlrl8cu1w5","_id":"cio5pdcc400lm7gxlnj58mt2s"},{"post_id":"cio5pdcc000lh7gxl0zs1qtlr","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcc400ln7gxlzt8ht550"},{"post_id":"cio5pdcc000lh7gxl0zs1qtlr","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcc400lo7gxlq4tdv4tm"},{"post_id":"cio5pdcc000lh7gxl0zs1qtlr","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdcc400lp7gxly3sc35u5"},{"post_id":"cio5pdcc000lh7gxl0zs1qtlr","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcc400lq7gxltt9ze5d1"},{"post_id":"cio5pdcc000lh7gxl0zs1qtlr","tag_id":"cio5pdc2u00a07gxlaxrta1j6","_id":"cio5pdcc400lr7gxle16ey1db"},{"post_id":"cio5pdcc500ls7gxle5bcvdwu","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcc700lu7gxl137ods22"},{"post_id":"cio5pdcc500ls7gxle5bcvdwu","tag_id":"cio5pdcc100lj7gxlrl8cu1w5","_id":"cio5pdcc800lv7gxl0mc3plrl"},{"post_id":"cio5pdcc500ls7gxle5bcvdwu","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcc800lw7gxlfnuravjf"},{"post_id":"cio5pdcc500ls7gxle5bcvdwu","tag_id":"cio5pdc2f00977gxl68bup22o","_id":"cio5pdcc800lx7gxl52dv7ait"},{"post_id":"cio5pdccb00ly7gxl7bb483dh","tag_id":"cio5pdbzy005o7gxlbc2g16ho","_id":"cio5pdccd00m27gxl45bd9976"},{"post_id":"cio5pdccb00ly7gxl7bb483dh","tag_id":"cio5pdccd00m07gxl7kmpuhru","_id":"cio5pdcce00m37gxlgkywzvd5"},{"post_id":"cio5pdccb00ly7gxl7bb483dh","tag_id":"cio5pdcc100lj7gxlrl8cu1w5","_id":"cio5pdcce00m47gxlh2wmqa2u"},{"post_id":"cio5pdccf00m57gxlybq5nazi","tag_id":"cio5pdcch00m77gxl4szkln0g","_id":"cio5pdcci00m87gxlohadflku"},{"post_id":"cio5pdccf00m57gxlybq5nazi","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcci00m97gxlnl4a1qz0"},{"post_id":"cio5pdccf00m57gxlybq5nazi","tag_id":"cio5pdbwn001u7gxlfrivh82f","_id":"cio5pdccj00ma7gxl5dqvbojp"},{"post_id":"cio5pdccf00m57gxlybq5nazi","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdccj00mb7gxlnnu0pjkg"},{"post_id":"cio5pdccj00mc7gxl2myyavig","tag_id":"cio5pdcch00m77gxl4szkln0g","_id":"cio5pdccm00mf7gxlypb6pt1e"},{"post_id":"cio5pdccj00mc7gxl2myyavig","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdccn00mg7gxlxrx1z6wh"},{"post_id":"cio5pdccj00mc7gxl2myyavig","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdccn00mh7gxlachm2tbt"},{"post_id":"cio5pdccj00mc7gxl2myyavig","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdccn00mi7gxlhxn809u5"},{"post_id":"cio5pdccj00mc7gxl2myyavig","tag_id":"cio5pdccl00me7gxl9v2ryrfy","_id":"cio5pdccn00mj7gxlvb4mif6x"},{"post_id":"cio5pdcco00mk7gxlj0psr7st","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdccq00mm7gxlqw2o0x6m"},{"post_id":"cio5pdcco00mk7gxlj0psr7st","tag_id":"cio5pdbvm00187gxll9f1j9fz","_id":"cio5pdccq00mn7gxlulq79n1v"},{"post_id":"cio5pdcco00mk7gxlj0psr7st","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdccq00mo7gxl8s76wi4b"},{"post_id":"cio5pdcco00mk7gxlj0psr7st","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdccq00mp7gxloftc5ofx"},{"post_id":"cio5pdccr00mq7gxlc2znhshh","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdccw00mt7gxlnaqrp4ff"},{"post_id":"cio5pdccr00mq7gxlc2znhshh","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdccx00mu7gxllueggbrr"},{"post_id":"cio5pdccr00mq7gxlc2znhshh","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdccx00mv7gxl5w5okh8w"},{"post_id":"cio5pdccr00mq7gxlc2znhshh","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdccx00mw7gxln5u2f5xm"},{"post_id":"cio5pdccr00mq7gxlc2znhshh","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdccx00mx7gxl10sftxr0"},{"post_id":"cio5pdccr00mq7gxlc2znhshh","tag_id":"cio5pdcct00ms7gxln3sfqqqq","_id":"cio5pdccy00my7gxljwiwi79i"},{"post_id":"cio5pdccy00mz7gxl4b36ljo9","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcd000n17gxlnl8fo1sb"},{"post_id":"cio5pdccy00mz7gxl4b36ljo9","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdcd100n27gxl160ej30r"},{"post_id":"cio5pdccy00mz7gxl4b36ljo9","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcd100n37gxlt9ahdepf"},{"post_id":"cio5pdccy00mz7gxl4b36ljo9","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcd200n47gxlj1w0y6lq"},{"post_id":"cio5pdccy00mz7gxl4b36ljo9","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcd200n57gxlc4uyuj39"},{"post_id":"cio5pdccy00mz7gxl4b36ljo9","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdcd200n67gxlhkdkm73o"},{"post_id":"cio5pdcd300n77gxl0q7qp4zz","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcd700n97gxlga8kk81w"},{"post_id":"cio5pdcd300n77gxl0q7qp4zz","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcd900na7gxlskuvm2dr"},{"post_id":"cio5pdcd300n77gxl0q7qp4zz","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcd900nb7gxlmkbb3uxv"},{"post_id":"cio5pdcd300n77gxl0q7qp4zz","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcd900nc7gxlv1agt17j"},{"post_id":"cio5pdcd300n77gxl0q7qp4zz","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdcd900nd7gxl7skmaikj"},{"post_id":"cio5pdcd300n77gxl0q7qp4zz","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdcd900ne7gxllrglcl3y"},{"post_id":"cio5pdcd900nf7gxlmfuiuwnz","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcdb00nh7gxlmze4rhm3"},{"post_id":"cio5pdcd900nf7gxlmfuiuwnz","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcdd00ni7gxlj1dl6gb2"},{"post_id":"cio5pdcd900nf7gxlmfuiuwnz","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcdd00nj7gxlxkuqm2rq"},{"post_id":"cio5pdcd900nf7gxlmfuiuwnz","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcdd00nk7gxlw4avh2tg"},{"post_id":"cio5pdcd900nf7gxlmfuiuwnz","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdcdd00nl7gxllmq8naku"},{"post_id":"cio5pdcd900nf7gxlmfuiuwnz","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdcdd00nm7gxlghf1kzcv"},{"post_id":"cio5pdcd900nf7gxlmfuiuwnz","tag_id":"cio5pdc2b008x7gxlvmxjzsmb","_id":"cio5pdcdd00nn7gxlge8qjoer"},{"post_id":"cio5pdcde00no7gxlbuz36g9x","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcdf00nq7gxl2qcde9sj"},{"post_id":"cio5pdcde00no7gxlbuz36g9x","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcdh00nr7gxlt47ywm65"},{"post_id":"cio5pdcde00no7gxlbuz36g9x","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcdh00ns7gxl8e0ttj43"},{"post_id":"cio5pdcde00no7gxlbuz36g9x","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdcdh00nt7gxl0ua7fezj"},{"post_id":"cio5pdcde00no7gxlbuz36g9x","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdcdh00nu7gxluzr5for6"},{"post_id":"cio5pdcde00no7gxlbuz36g9x","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcdh00nv7gxlzy87cxtw"},{"post_id":"cio5pdcdi00nw7gxlwmrid2b6","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcdj00ny7gxl3x9d73wl"},{"post_id":"cio5pdcdi00nw7gxlwmrid2b6","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcdl00nz7gxl13nnntqn"},{"post_id":"cio5pdcdi00nw7gxlwmrid2b6","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcdl00o07gxlvzb25phe"},{"post_id":"cio5pdcdi00nw7gxlwmrid2b6","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdcdl00o17gxlp6akbzwe"},{"post_id":"cio5pdcdi00nw7gxlwmrid2b6","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdcdl00o27gxlq3q8loqh"},{"post_id":"cio5pdcdi00nw7gxlwmrid2b6","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcdl00o37gxls03rr32r"},{"post_id":"cio5pdcdl00o47gxlcumk9pto","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcdn00o67gxl5qxoyxsk"},{"post_id":"cio5pdcdl00o47gxlcumk9pto","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcdp00o77gxl8t7l4kqk"},{"post_id":"cio5pdcdl00o47gxlcumk9pto","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcdp00o87gxls77xnvp3"},{"post_id":"cio5pdcdl00o47gxlcumk9pto","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdcdp00o97gxlby6hs31f"},{"post_id":"cio5pdcdl00o47gxlcumk9pto","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcdp00oa7gxlo4mbep7v"},{"post_id":"cio5pdcdl00o47gxlcumk9pto","tag_id":"cio5pdcct00ms7gxln3sfqqqq","_id":"cio5pdcdp00ob7gxlk9d7xti7"},{"post_id":"cio5pdcdq00oc7gxlxzzeaaro","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcdx00oe7gxl6tqy4gv8"},{"post_id":"cio5pdcdq00oc7gxlxzzeaaro","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcdy00of7gxlufpmdubt"},{"post_id":"cio5pdcdq00oc7gxlxzzeaaro","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcdy00og7gxlvo9xkfjc"},{"post_id":"cio5pdcdq00oc7gxlxzzeaaro","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdcdy00oh7gxlwlap27rz"},{"post_id":"cio5pdcdq00oc7gxlxzzeaaro","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcdy00oi7gxl2eoqulvv"},{"post_id":"cio5pdcdz00oj7gxlha5tnnx3","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdce100ol7gxl5ggt1fii"},{"post_id":"cio5pdcdz00oj7gxlha5tnnx3","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdce200om7gxlfz0sk311"},{"post_id":"cio5pdcdz00oj7gxlha5tnnx3","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdce200on7gxlwtzx3ygs"},{"post_id":"cio5pdcdz00oj7gxlha5tnnx3","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdce200oo7gxl6pi8qvdn"},{"post_id":"cio5pdcdz00oj7gxlha5tnnx3","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdce200op7gxl69o5jxjh"},{"post_id":"cio5pdce300oq7gxlcsx4a32s","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdce500os7gxlmgv8zig7"},{"post_id":"cio5pdce300oq7gxlcsx4a32s","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdce700ot7gxlv9vd68zv"},{"post_id":"cio5pdce300oq7gxlcsx4a32s","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdce700ou7gxl8efte9j3"},{"post_id":"cio5pdce300oq7gxlcsx4a32s","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdce700ov7gxl9x7yj18d"},{"post_id":"cio5pdce300oq7gxlcsx4a32s","tag_id":"cio5pdc2b008x7gxlvmxjzsmb","_id":"cio5pdce700ow7gxludxnqh2c"},{"post_id":"cio5pdce300oq7gxlcsx4a32s","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdce700ox7gxl65rfcp77"},{"post_id":"cio5pdce800oy7gxlgb8vnyq2","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcea00p07gxlhteccvdi"},{"post_id":"cio5pdce800oy7gxlgb8vnyq2","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdceb00p17gxldmdd5d3t"},{"post_id":"cio5pdce800oy7gxlgb8vnyq2","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdceb00p27gxlc3zc8ww2"},{"post_id":"cio5pdce800oy7gxlgb8vnyq2","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdceb00p37gxl4gzqsc89"},{"post_id":"cio5pdce800oy7gxlgb8vnyq2","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdceb00p47gxl9lw39pv0"},{"post_id":"cio5pdce800oy7gxlgb8vnyq2","tag_id":"cio5pdc6g00eb7gxl165obbay","_id":"cio5pdceb00p57gxl5eekgpmv"},{"post_id":"cio5pdcec00p67gxlw71boa6p","tag_id":"cio5pdced00p87gxlksh4ta82","_id":"cio5pdcef00pa7gxl8613my2w"},{"post_id":"cio5pdcec00p67gxlw71boa6p","tag_id":"cio5pdcee00p97gxlbdh1rwef","_id":"cio5pdceg00pb7gxlhcac1ax7"},{"post_id":"cio5pdcec00p67gxlw71boa6p","tag_id":"cio5pdbzt005f7gxli6q2re54","_id":"cio5pdceg00pc7gxlph21ynnc"},{"post_id":"cio5pdcec00p67gxlw71boa6p","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdceg00pd7gxl9e9f4g0b"},{"post_id":"cio5pdcec00p67gxlw71boa6p","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdceg00pe7gxl19hsstpa"},{"post_id":"cio5pdcec00p67gxlw71boa6p","tag_id":"cio5pdc5y00do7gxlz3305p0r","_id":"cio5pdceg00pf7gxlg0l6i1ti"},{"post_id":"cio5pdcei00pg7gxlfl997cn6","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcek00pi7gxl84gwx4bd"},{"post_id":"cio5pdcei00pg7gxlfl997cn6","tag_id":"cio5pdc2k009f7gxlnjew189d","_id":"cio5pdcel00pj7gxlcqq4ucmd"},{"post_id":"cio5pdcei00pg7gxlfl997cn6","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdcel00pk7gxlj2fss5te"},{"post_id":"cio5pdcem00pl7gxl8o65x5ay","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"cio5pdcep00pn7gxl925cabec"},{"post_id":"cio5pdcem00pl7gxl8o65x5ay","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdceq00po7gxlqw8k152l"},{"post_id":"cio5pdcem00pl7gxl8o65x5ay","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdceq00pp7gxlcgs9hnnm"},{"post_id":"cio5pdcem00pl7gxl8o65x5ay","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdceq00pq7gxl5bixmsh1"},{"post_id":"cio5pdcem00pl7gxl8o65x5ay","tag_id":"cio5pdc2b008x7gxlvmxjzsmb","_id":"cio5pdceq00pr7gxlbrsmwqhw"},{"post_id":"cio5pdcem00pl7gxl8o65x5ay","tag_id":"cio5pdcc200lk7gxlj386s8vt","_id":"cio5pdceq00ps7gxlcmqzji7w"},{"post_id":"cio5pdcer00pt7gxl6tghvzfo","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdces00pv7gxlo2eb6u9k"},{"post_id":"cio5pdcer00pt7gxl6tghvzfo","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcet00pw7gxl7b5o0qhz"},{"post_id":"cio5pdcer00pt7gxl6tghvzfo","tag_id":"cio5pdbx2002e7gxl98dbwg2u","_id":"cio5pdcet00px7gxlplspzi3m"},{"post_id":"cio5pdceu00py7gxlxv0q8tbq","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcew00q07gxlx9z4ed4v"},{"post_id":"cio5pdceu00py7gxlxv0q8tbq","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcex00q17gxljbqu8moo"},{"post_id":"cio5pdceu00py7gxlxv0q8tbq","tag_id":"cio5pdc0o006r7gxlpuwptv4k","_id":"cio5pdcex00q27gxl7wiw5qjr"},{"post_id":"cio5pdceu00py7gxlxv0q8tbq","tag_id":"cio5pdbx2002e7gxl98dbwg2u","_id":"cio5pdcex00q37gxlddjn48gn"},{"post_id":"cio5pdcey00q47gxlyypavzj4","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcf000q67gxlmfj1dfks"},{"post_id":"cio5pdcey00q47gxlyypavzj4","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcf200q77gxlkyhmbrtg"},{"post_id":"cio5pdcey00q47gxlyypavzj4","tag_id":"cio5pdc0g006d7gxl5o3ibwes","_id":"cio5pdcf200q87gxl64w74vdu"},{"post_id":"cio5pdcey00q47gxlyypavzj4","tag_id":"cio5pdbxk00307gxlzi5bqtbs","_id":"cio5pdcf200q97gxlrwrtek35"},{"post_id":"cio5pdcey00q47gxlyypavzj4","tag_id":"cio5pdc2k009f7gxlnjew189d","_id":"cio5pdcf200qa7gxl27qhdmz7"},{"post_id":"cio5pdcf300qb7gxlbk259ooz","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcf400qd7gxls56hj26m"},{"post_id":"cio5pdcf300qb7gxlbk259ooz","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcf500qe7gxl6stft0v4"},{"post_id":"cio5pdcf300qb7gxlbk259ooz","tag_id":"cio5pdbye003m7gxlnqh5kta4","_id":"cio5pdcf600qf7gxl2umbsqxs"},{"post_id":"cio5pdcf300qb7gxlbk259ooz","tag_id":"cio5pdbye003l7gxlra9zc2zv","_id":"cio5pdcf600qg7gxlxv9dht13"},{"post_id":"cio5pdcf300qb7gxlbk259ooz","tag_id":"cio5pdc2p009o7gxle76mq61s","_id":"cio5pdcf600qh7gxl556pblbi"},{"post_id":"cio5pdcf600qi7gxljb852cwb","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcf900ql7gxlvzabrcvg"},{"post_id":"cio5pdcf600qi7gxljb852cwb","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcfa00qm7gxlueypdony"},{"post_id":"cio5pdcf600qi7gxljb852cwb","tag_id":"cio5pdbyq00457gxlaq3vgwft","_id":"cio5pdcfa00qn7gxl72ovbmri"},{"post_id":"cio5pdcf600qi7gxljb852cwb","tag_id":"cio5pdcf800qk7gxlcej77o0i","_id":"cio5pdcfa00qo7gxlwr2lbtbe"},{"post_id":"cio5pdcfa00qp7gxl63jk5htk","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcfc00qr7gxlfmgnvcrf"},{"post_id":"cio5pdcfa00qp7gxl63jk5htk","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcfd00qs7gxlgownwvqj"},{"post_id":"cio5pdcfa00qp7gxl63jk5htk","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdcfd00qt7gxlalavrfv6"},{"post_id":"cio5pdcfa00qp7gxl63jk5htk","tag_id":"cio5pdbye003k7gxli7c56lor","_id":"cio5pdcfd00qu7gxl828nt7vz"},{"post_id":"cio5pdcfe00qv7gxlr6haopbr","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcfg00qx7gxlq48rw8lb"},{"post_id":"cio5pdcfe00qv7gxlr6haopbr","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcfg00qy7gxl7e9neoga"},{"post_id":"cio5pdcfe00qv7gxlr6haopbr","tag_id":"cio5pdcf800qk7gxlcej77o0i","_id":"cio5pdcfg00qz7gxlpe6o68bs"},{"post_id":"cio5pdcfh00r07gxlu1hll84k","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdcfj00r27gxltgc3fbrm"},{"post_id":"cio5pdcfh00r07gxlu1hll84k","tag_id":"cio5pdc8a00hn7gxl4sw57dfa","_id":"cio5pdcfk00r37gxl8hfja72w"},{"post_id":"cio5pdcfh00r07gxlu1hll84k","tag_id":"cio5pdbyd003j7gxlsl0bf3ir","_id":"cio5pdcfk00r47gxlrmklhgv0"},{"post_id":"cio5pdcfh00r07gxlu1hll84k","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdcfk00r57gxlwcxhnxo2"},{"post_id":"cio5pdcfl00r67gxlllutle9w","tag_id":"cio5pdcfm00r87gxlnwi8mt24","_id":"cio5pdcfq00r97gxlq0csn1pf"},{"post_id":"cio5pdcfl00r67gxlllutle9w","tag_id":"cio5pdbwn001u7gxlfrivh82f","_id":"cio5pdcfr00ra7gxlypp0urh1"},{"post_id":"cio5pdcfl00r67gxlllutle9w","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcfr00rb7gxlb5b95vs7"},{"post_id":"cio5pdcfs00rc7gxlavhzikeu","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcfv00rf7gxln2nr0pnt"},{"post_id":"cio5pdcfs00rc7gxlavhzikeu","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdcfw00rg7gxl029pd9t6"},{"post_id":"cio5pdcfs00rc7gxlavhzikeu","tag_id":"cio5pdbvm00187gxll9f1j9fz","_id":"cio5pdcfw00rh7gxl2s90nwvz"},{"post_id":"cio5pdcfs00rc7gxlavhzikeu","tag_id":"cio5pdbx8002m7gxl5rgyho8l","_id":"cio5pdcfw00ri7gxln7hea5m8"},{"post_id":"cio5pdcfs00rc7gxlavhzikeu","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdcfw00rj7gxliro3yqga"},{"post_id":"cio5pdcfs00rc7gxlavhzikeu","tag_id":"cio5pdcfu00re7gxlcejk6dkl","_id":"cio5pdcfw00rk7gxl9y0fotz2"},{"post_id":"cio5pdcfs00rc7gxlavhzikeu","tag_id":"cio5pdbww00237gxlmvwl7ksr","_id":"cio5pdcfw00rl7gxlyv195dpy"},{"post_id":"cio5pdcfx00rm7gxlavyou84c","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcfz00ro7gxlme1suw8s"},{"post_id":"cio5pdcfx00rm7gxlavyou84c","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdcg000rp7gxlinveau70"},{"post_id":"cio5pdcfx00rm7gxlavyou84c","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcg000rq7gxlgeoais27"},{"post_id":"cio5pdcfx00rm7gxlavyou84c","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdcg000rr7gxl8mt852y4"},{"post_id":"cio5pdcfx00rm7gxlavyou84c","tag_id":"cio5pdc6g00ea7gxlir6b5ij5","_id":"cio5pdcg000rs7gxl5wa34t6u"},{"post_id":"cio5pdcg100rt7gxl8hbcjvm9","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcg200rv7gxlse2t3skj"},{"post_id":"cio5pdcg100rt7gxl8hbcjvm9","tag_id":"cio5pdcai00jw7gxlk6eiqxcy","_id":"cio5pdcg400rw7gxl61j11299"},{"post_id":"cio5pdcg100rt7gxl8hbcjvm9","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdcg400rx7gxl4c46rujd"},{"post_id":"cio5pdcg100rt7gxl8hbcjvm9","tag_id":"cio5pdc0e006a7gxl9r6uk5gw","_id":"cio5pdcg400ry7gxlb8lct693"},{"post_id":"cio5pdcg100rt7gxl8hbcjvm9","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdcg400rz7gxl7wt8fy9l"},{"post_id":"cio5pdcg400s07gxl5ibozgby","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcg700s37gxlkuyoerfx"},{"post_id":"cio5pdcg400s07gxl5ibozgby","tag_id":"cio5pdcg600s27gxly4qykgfs","_id":"cio5pdcg800s47gxlcmm7r4vz"},{"post_id":"cio5pdcg400s07gxl5ibozgby","tag_id":"cio5pdbxt003b7gxlyv2erdmo","_id":"cio5pdcg800s57gxljszu8l0t"},{"post_id":"cio5pdcg400s07gxl5ibozgby","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdcg800s67gxl431cjwgd"},{"post_id":"cio5pdcg400s07gxl5ibozgby","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdcg800s77gxl7h07jyqr"},{"post_id":"cio5pdcga00s87gxl5aewyvyt","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcgc00sa7gxl2lds8cu5"},{"post_id":"cio5pdcga00s87gxl5aewyvyt","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdcge00sb7gxl30r3xctt"},{"post_id":"cio5pdcga00s87gxl5aewyvyt","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcge00sc7gxlw1cukgjd"},{"post_id":"cio5pdcga00s87gxl5aewyvyt","tag_id":"cio5pdc0o006r7gxlpuwptv4k","_id":"cio5pdcge00sd7gxlxsyhin3w"},{"post_id":"cio5pdcga00s87gxl5aewyvyt","tag_id":"cio5pdcf800qk7gxlcej77o0i","_id":"cio5pdcge00se7gxlldk006q8"},{"post_id":"cio5pdcgf00sf7gxlpatraj92","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcgg00sh7gxl5xswbl1h"},{"post_id":"cio5pdcgf00sf7gxlpatraj92","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdcgh00si7gxlovefsewe"},{"post_id":"cio5pdcgf00sf7gxlpatraj92","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdcgh00sj7gxlka8o5dj6"},{"post_id":"cio5pdcgi00sk7gxlfu31t4jm","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcgk00sn7gxltp4vrplo"},{"post_id":"cio5pdcgi00sk7gxlfu31t4jm","tag_id":"cio5pdbyk003w7gxl5kxm7nfb","_id":"cio5pdcgl00so7gxlq67l4162"},{"post_id":"cio5pdcgi00sk7gxlfu31t4jm","tag_id":"cio5pdcgk00sm7gxle92kmxiz","_id":"cio5pdcgl00sp7gxljudlbiq2"},{"post_id":"cio5pdcgi00sk7gxlfu31t4jm","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdcgl00sq7gxllwqat9z3"},{"post_id":"cio5pdcgm00sr7gxl0tydqz4m","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcgo00st7gxlkrbvpvsc"},{"post_id":"cio5pdcgm00sr7gxl0tydqz4m","tag_id":"cio5pdc7800fk7gxlh8fa9xoa","_id":"cio5pdcgp00su7gxl2mb2y85p"},{"post_id":"cio5pdcgm00sr7gxl0tydqz4m","tag_id":"cio5pdc7u00gr7gxlngn0hejl","_id":"cio5pdcgp00sv7gxlo5158dlg"},{"post_id":"cio5pdcgm00sr7gxl0tydqz4m","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdcgp00sw7gxlz7luzwqu"},{"post_id":"cio5pdcgq00sx7gxlvhxsf9g0","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcgs00sz7gxld7k3qv3v"},{"post_id":"cio5pdcgq00sx7gxlvhxsf9g0","tag_id":"cio5pdbsv00047gxlfvn3oupy","_id":"cio5pdcgt00t07gxldecfk49b"},{"post_id":"cio5pdcgq00sx7gxlvhxsf9g0","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdcgt00t17gxly6mtmbz9"},{"post_id":"cio5pdcgq00sx7gxlvhxsf9g0","tag_id":"cio5pdbsw00057gxlgupsqx56","_id":"cio5pdcgt00t27gxl3mq1oqmk"},{"post_id":"cio5pdcgq00sx7gxlvhxsf9g0","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcgt00t37gxlfbi6mflj"},{"post_id":"cio5pdcgu00t47gxlawllrulf","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdcgz00t67gxl8d57qbs1"},{"post_id":"cio5pdcgu00t47gxlawllrulf","tag_id":"cio5pdbxj002z7gxl1s8lmudr","_id":"cio5pdch000t77gxljoqv2yoz"},{"post_id":"cio5pdcgu00t47gxlawllrulf","tag_id":"cio5pdc5900c57gxloprefquh","_id":"cio5pdch000t87gxleftipyd3"},{"post_id":"cio5pdcgu00t47gxlawllrulf","tag_id":"cio5pdbwu00227gxl2m3s727r","_id":"cio5pdch000t97gxlsf98iuun"},{"post_id":"cio5pdch100ta7gxlebyl70gd","tag_id":"cio5pdbxs003a7gxl2s3rwsf9","_id":"cio5pdch400tc7gxlz1h2sj6l"},{"post_id":"cio5pdch100ta7gxlebyl70gd","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdch500td7gxlcad8ac3g"},{"post_id":"cio5pdch100ta7gxlebyl70gd","tag_id":"cio5pdbxj002y7gxlq7yh7kpw","_id":"cio5pdch600te7gxloc0l5z8n"},{"post_id":"cio5pdch100ta7gxlebyl70gd","tag_id":"cio5pdbsw00067gxlqj4lr8oc","_id":"cio5pdch600tf7gxljqer1be7"},{"post_id":"cio5pdch800tg7gxlbty2qdsn","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdchb00tj7gxl02meegl0"},{"post_id":"cio5pdch800tg7gxlbty2qdsn","tag_id":"cio5pdc8a00hm7gxlyftgig8j","_id":"cio5pdchb00tk7gxl5imldidb"},{"post_id":"cio5pdch800tg7gxlbty2qdsn","tag_id":"cio5pdbvd00107gxl5dgcf65d","_id":"cio5pdchb00tl7gxl8sjqvuck"},{"post_id":"cio5pdch800tg7gxlbty2qdsn","tag_id":"cio5pdcha00ti7gxl5e8nbaut","_id":"cio5pdchb00tm7gxlzmgwsef3"},{"post_id":"cio5pdchc00tn7gxl1jiggtyq","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdche00tp7gxllff57x6m"},{"post_id":"cio5pdchc00tn7gxl1jiggtyq","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdchf00tq7gxlm009gdp2"},{"post_id":"cio5pdchc00tn7gxl1jiggtyq","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdchf00tr7gxlun303dk9"},{"post_id":"cio5pdchc00tn7gxl1jiggtyq","tag_id":"cio5pdc6g00ea7gxlir6b5ij5","_id":"cio5pdchf00ts7gxlde53cplk"},{"post_id":"cio5pdchg00tt7gxl0dvlybnw","tag_id":"cio5pdbwf001n7gxlglbf3ugu","_id":"cio5pdchm00tv7gxlz71sfd6v"},{"post_id":"cio5pdchg00tt7gxl0dvlybnw","tag_id":"cio5pdbyf003n7gxl1t4d469s","_id":"cio5pdchm00tw7gxl35xp26fq"},{"post_id":"cio5pdchn00tx7gxl4tt70e3r","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdchp00tz7gxlw86skx2d"},{"post_id":"cio5pdchn00tx7gxl4tt70e3r","tag_id":"cio5pdccd00m07gxl7kmpuhru","_id":"cio5pdchq00u07gxlnuc0ak3k"},{"post_id":"cio5pdchn00tx7gxl4tt70e3r","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdchq00u17gxlwssaz9zu"},{"post_id":"cio5pdchn00tx7gxl4tt70e3r","tag_id":"cio5pdc0o006r7gxlpuwptv4k","_id":"cio5pdchq00u27gxlh17h2cvk"},{"post_id":"cio5pdchn00tx7gxl4tt70e3r","tag_id":"cio5pdc0n006q7gxl3cre2ot6","_id":"cio5pdchq00u37gxlxekv3f7c"},{"post_id":"cio5pdchs00u47gxl876jenkt","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdchw00u97gxlsmyfr72t"},{"post_id":"cio5pdchs00u47gxl876jenkt","tag_id":"cio5pdccd00m07gxl7kmpuhru","_id":"cio5pdchx00ua7gxlxo30m5wl"},{"post_id":"cio5pdchs00u47gxl876jenkt","tag_id":"cio5pdbye003l7gxlra9zc2zv","_id":"cio5pdchx00ub7gxlmwok1zu0"},{"post_id":"cio5pdchs00u47gxl876jenkt","tag_id":"cio5pdbye003m7gxlnqh5kta4","_id":"cio5pdchx00uc7gxle9kbi2bk"},{"post_id":"cio5pdchs00u47gxl876jenkt","tag_id":"cio5pdc2p009o7gxle76mq61s","_id":"cio5pdchx00ud7gxlapogg6qn"},{"post_id":"cio5pdchs00u47gxl876jenkt","tag_id":"cio5pdchu00u67gxljs2fb97c","_id":"cio5pdchy00ue7gxlx9lcvdhw"},{"post_id":"cio5pdchs00u47gxl876jenkt","tag_id":"cio5pdchu00u77gxl9zer1kin","_id":"cio5pdchy00uf7gxlrzztg89y"},{"post_id":"cio5pdchs00u47gxl876jenkt","tag_id":"cio5pdchv00u87gxl2z2phmu7","_id":"cio5pdchy00ug7gxlijpsexdy"},{"post_id":"cio5pdchy00uh7gxl55dcrxr4","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdci400ul7gxltlulxsu1"},{"post_id":"cio5pdchy00uh7gxl55dcrxr4","tag_id":"cio5pdci000uj7gxlwxp0eklr","_id":"cio5pdci500um7gxlntu7ihxg"},{"post_id":"cio5pdchy00uh7gxl55dcrxr4","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdci500un7gxlfqki7p3q"},{"post_id":"cio5pdchy00uh7gxl55dcrxr4","tag_id":"cio5pdc0f006c7gxl4u50hi6z","_id":"cio5pdci500uo7gxl1ml1ya7w"},{"post_id":"cio5pdchy00uh7gxl55dcrxr4","tag_id":"cio5pdci300uk7gxlj0dd1sbl","_id":"cio5pdci500up7gxl9wfrya13"},{"post_id":"cio5pdchy00uh7gxl55dcrxr4","tag_id":"cio5pdc0c00687gxlxi7pseac","_id":"cio5pdci500uq7gxlv1g1yqcf"},{"post_id":"cio5pdci600ur7gxlzssguj48","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"cio5pdci900ut7gxlj0wqmtpe"},{"post_id":"cio5pdci600ur7gxlzssguj48","tag_id":"cio5pdci000uj7gxlwxp0eklr","_id":"cio5pdcia00uu7gxlhlnffujh"},{"post_id":"cio5pdci600ur7gxlzssguj48","tag_id":"cio5pdc1400797gxl6dckrhhu","_id":"cio5pdcia00uv7gxli6tz1at4"},{"post_id":"cio5pdci600ur7gxlzssguj48","tag_id":"cio5pdc22008g7gxlh187bdoa","_id":"cio5pdcia00uw7gxlc6pp6kkq"},{"post_id":"cio5pdci600ur7gxlzssguj48","tag_id":"cio5pdc2l009g7gxlw0pb8s7b","_id":"cio5pdcia00ux7gxlazus1oau"},{"post_id":"cio5pdcib00uy7gxlwurbf91o","tag_id":"cio5pdbzy005o7gxlbc2g16ho","_id":"cio5pdcid00v07gxli0mjk2ak"},{"post_id":"cio5pdcib00uy7gxlwurbf91o","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdcie00v27gxlxhtspmn6"},{"post_id":"cio5pdcig00v37gxl2e7rfckv","tag_id":"cio5pdbzz005p7gxl1ab51zxq","_id":"cio5pdcij00v77gxlea4rja63"},{"post_id":"cio5pdcig00v37gxl2e7rfckv","tag_id":"cio5pdcii00v57gxlwp8fwbiy","_id":"cio5pdcik00v87gxl89tke6e2"},{"post_id":"cio5pdcik00v97gxlj4ghpxrl","tag_id":"cio5pdbzz005p7gxl1ab51zxq","_id":"cio5pdcim00vb7gxl4gpdsg5k"},{"post_id":"cio5pdcik00v97gxlj4ghpxrl","tag_id":"cio5pdcii00v57gxlwp8fwbiy","_id":"cio5pdcin00vd7gxlwb4ohwlu"},{"post_id":"cio5pdcio00ve7gxlxdc45n34","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdcir00vh7gxlf2rryhop"},{"post_id":"cio5pdcio00ve7gxlxdc45n34","tag_id":"cio5pdc2f00977gxl68bup22o","_id":"cio5pdcis00vi7gxlddnpzkjr"},{"post_id":"cio5pdcio00ve7gxlxdc45n34","tag_id":"cio5pdciq00vg7gxlujt0ge3i","_id":"cio5pdcis00vj7gxlym6fz9jw"},{"post_id":"cio5pdcio00ve7gxlxdc45n34","tag_id":"cio5pdc0f006b7gxlpc3pbsqp","_id":"cio5pdcis00vk7gxl5qjlkwjp"},{"post_id":"cio5pdcio00ve7gxlxdc45n34","tag_id":"cio5pdc1g007k7gxlwqrc2d4s","_id":"cio5pdcis00vl7gxlb1nzgsvc"},{"post_id":"cio5pdcio00ve7gxlxdc45n34","tag_id":"cio5pdc6g00eb7gxl165obbay","_id":"cio5pdcis00vm7gxl217llvlq"},{"post_id":"cio5pdcit00vn7gxl24nnilmb","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdciw00vq7gxlyd8gla6e"},{"post_id":"cio5pdcit00vn7gxl24nnilmb","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"cio5pdcix00vr7gxlcsxokd0m"},{"post_id":"cio5pdcit00vn7gxl24nnilmb","tag_id":"cio5pdciv00vp7gxleyfxuv22","_id":"cio5pdcix00vs7gxltkixnbxf"},{"post_id":"cio5pdcix00vt7gxl85gcmgvl","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdcj000vw7gxl3tk8yl65"},{"post_id":"cio5pdcix00vt7gxl85gcmgvl","tag_id":"cio5pdciz00vv7gxl8213x91a","_id":"cio5pdcj100vx7gxlpf0z5l65"},{"post_id":"cio5pdcix00vt7gxl85gcmgvl","tag_id":"cio5pdcha00ti7gxl5e8nbaut","_id":"cio5pdcj100vy7gxlo9c2ppdt"},{"post_id":"cio5pdcix00vt7gxl85gcmgvl","tag_id":"cio5pdbvb000x7gxl96xc23gy","_id":"cio5pdcj100vz7gxlymods5lk"},{"post_id":"cio5pdcj200w07gxlc08pfam8","tag_id":"cio5pdbsn00027gxl1su330r6","_id":"cio5pdcj600w47gxlklqfszsg"},{"post_id":"cio5pdcj200w07gxlc08pfam8","tag_id":"cio5pdcj400w27gxlgiy90j5o","_id":"cio5pdcj800w57gxlbtlx9mkm"},{"post_id":"cio5pdcj200w07gxlc08pfam8","tag_id":"cio5pdcj500w37gxlfsdc418b","_id":"cio5pdcj800w67gxlhwznzb59"},{"post_id":"cio5pdcj200w07gxlc08pfam8","tag_id":"cio5pdbxt003b7gxlyv2erdmo","_id":"cio5pdcj800w77gxlbdq24eov"},{"post_id":"cio5pdcj200w07gxlc08pfam8","tag_id":"cio5pdc5x00dl7gxlco5c19k5","_id":"cio5pdcj800w87gxlm8a2fcx0"},{"post_id":"ciocc9nv100006wxlze49h5ws","tag_id":"cio5pdbxr00377gxl7hh5uana","_id":"ciocc9nwq00036wxl5y6zzvmp"},{"post_id":"ciocc9nv100006wxlze49h5ws","tag_id":"cio5pdbzr005c7gxlzypw8fh8","_id":"ciocc9nwu00046wxl8tayict4"},{"post_id":"ciocc9nv100006wxlze49h5ws","tag_id":"ciocc9nvi00026wxl4iv9s7m9","_id":"ciocc9nwu00056wxl2fc01vw5"},{"post_id":"ciocc9nv100006wxlze49h5ws","tag_id":"cio5pdc0n006q7gxl3cre2ot6","_id":"ciocc9nwv00066wxlhp72ixnp"},{"post_id":"ciocc9nv100006wxlze49h5ws","tag_id":"cio5pdc0o006r7gxlpuwptv4k","_id":"ciocc9nwv00076wxldrw9yaok"},{"post_id":"ciocc9nv100006wxlze49h5ws","tag_id":"cio5pdbvc000y7gxlwuyvgbad","_id":"ciocc9nwv00086wxlyxyuxsws"}],"Tag":[{"name":"安徽集训","_id":"cio5pdbsn00027gxl1su330r6"},{"name":"树链剖分","_id":"cio5pdbsv00037gxlvjwoomqj"},{"name":"线段树","_id":"cio5pdbsv00047gxlfvn3oupy"},{"name":"数据结构","_id":"cio5pdbsw00057gxlgupsqx56"},{"name":"高级数据结构","_id":"cio5pdbsw00067gxlqj4lr8oc"},{"name":"OS X","_id":"cio5pdbtv000h7gxlbjurbwt4"},{"name":"Linux","_id":"cio5pdbtx000i7gxlfeeoytfo"},{"name":"Archlinux","_id":"cio5pdbty000j7gxlsjqo1jk7"},{"name":"VirtualBox","_id":"cio5pdbty000k7gxl0oiv5lnt"},{"name":"虚拟机","_id":"cio5pdbty000l7gxld23ktohn"},{"name":"SSH","_id":"cio5pdbty000m7gxlw27kdbsw"},{"name":"UVa","_id":"cio5pdbv9000w7gxluzxlz0sr"},{"name":"数学","_id":"cio5pdbvb000x7gxl96xc23gy"},{"name":"DP","_id":"cio5pdbvc000y7gxlwuyvgbad"},{"name":"区间DP","_id":"cio5pdbvc000z7gxldbi3v0iv"},{"name":"计数原理","_id":"cio5pdbvd00107gxl5dgcf65d"},{"name":"组合数学","_id":"cio5pdbvm00187gxll9f1j9fz"},{"name":"容斥原理","_id":"cio5pdbvn00197gxl3qlfl42k"},{"name":"递推","_id":"cio5pdbwd001m7gxlr7k9tz34"},{"name":"高精度","_id":"cio5pdbwf001n7gxlglbf3ugu"},{"name":"数位DP","_id":"cio5pdbwn001u7gxlfrivh82f"},{"name":"数论","_id":"cio5pdbwu00227gxl2m3s727r"},{"name":"乘法逆元","_id":"cio5pdbww00237gxlmvwl7ksr"},{"name":"全排列","_id":"cio5pdbww00247gxl4heyjyjk"},{"name":"背包DP","_id":"cio5pdbx2002e7gxl98dbwg2u"},{"name":"组合数","_id":"cio5pdbx8002m7gxl5rgyho8l"},{"name":"整数划分","_id":"cio5pdbxa002n7gxlclnxamrl"},{"name":"回溯","_id":"cio5pdbxa002o7gxlyrqd3h6v"},{"name":"CodeVS","_id":"cio5pdbxj002y7gxlq7yh7kpw"},{"name":"Tyvj","_id":"cio5pdbxj002z7gxl1s8lmudr"},{"name":"划分DP","_id":"cio5pdbxk00307gxlzi5bqtbs"},{"name":"BZOJ","_id":"cio5pdbxr00377gxl7hh5uana"},{"name":"TJOI","_id":"cio5pdbxs00387gxlz7ceba43"},{"name":"离线","_id":"cio5pdbxs00397gxl1thpztrb"},{"name":"Splay","_id":"cio5pdbxs003a7gxl2s3rwsf9"},{"name":"树状数组","_id":"cio5pdbxt003b7gxlyv2erdmo"},{"name":"学习笔记","_id":"cio5pdbyd003j7gxlsl0bf3ir"},{"name":"图论","_id":"cio5pdbye003k7gxli7c56lor"},{"name":"强联通分量","_id":"cio5pdbye003l7gxlra9zc2zv"},{"name":"Tarjan","_id":"cio5pdbye003m7gxlnqh5kta4"},{"name":"算法模板","_id":"cio5pdbyf003n7gxl1t4d469s"},{"name":"差分约束系统","_id":"cio5pdbyj003v7gxl10t24hjl"},{"name":"最短路","_id":"cio5pdbyk003w7gxl5kxm7nfb"},{"name":"后缀数组","_id":"cio5pdbyp00447gxlbixdds7j"},{"name":"字符串","_id":"cio5pdbyq00457gxlaq3vgwft"},{"name":"稀疏表","_id":"cio5pdbyq00467gxlkp3do8rs"},{"name":"C++","_id":"cio5pdbyw004e7gxlts06y0a6"},{"name":"STL","_id":"cio5pdbyx004f7gxldr0hor7k"},{"name":"SPOJ","_id":"cio5pdbz4004k7gxlpbxgu472"},{"name":"SDOI","_id":"cio5pdbzr005b7gxltfhff9t9"},{"name":"COGS","_id":"cio5pdbzr005c7gxlzypw8fh8"},{"name":"二进制","_id":"cio5pdbzs005d7gxl7czwm9f9"},{"name":"异或","_id":"cio5pdbzs005e7gxlem2usze0"},{"name":"位运算","_id":"cio5pdbzt005f7gxli6q2re54"},{"name":"游记","_id":"cio5pdbzy005o7gxlbc2g16ho"},{"name":"省选","_id":"cio5pdbzz005p7gxl1ab51zxq"},{"name":"错位排列","_id":"cio5pdc06005y7gxlxtjuu9d1"},{"name":"Edmonds-Karp","_id":"cio5pdc0c00687gxlxi7pseac"},{"name":"素数判定","_id":"cio5pdc0e00697gxl3mow6ll2"},{"name":"线性筛","_id":"cio5pdc0e006a7gxl9r6uk5gw"},{"name":"网络流","_id":"cio5pdc0f006b7gxlpc3pbsqp"},{"name":"费用流","_id":"cio5pdc0f006c7gxl4u50hi6z"},{"name":"二分答案","_id":"cio5pdc0g006d7gxl5o3ibwes"},{"name":"斜率优化","_id":"cio5pdc0n006q7gxl3cre2ot6"},{"name":"单调队列","_id":"cio5pdc0o006r7gxlpuwptv4k"},{"name":"RMQ","_id":"cio5pdc0v00707gxlmyg6e9aj"},{"name":"最近公共祖先","_id":"cio5pdc1400797gxl6dckrhhu"},{"name":"Dinic","_id":"cio5pdc1g007k7gxlwqrc2d4s"},{"name":"实数二分","_id":"cio5pdc1h007l7gxlckrssqdx"},{"name":"动态树","_id":"cio5pdc1p00837gxl2cuoe7ki"},{"name":"Link-Cut Tree","_id":"cio5pdc1v00847gxlzqvb06i5"},{"name":"SCOI","_id":"cio5pdc21008e7gxlasctxpdl"},{"name":"set","_id":"cio5pdc22008f7gxldf5qw2kl"},{"name":"乱搞","_id":"cio5pdc22008g7gxlh187bdoa"},{"name":"二分图匹配","_id":"cio5pdc2b008x7gxlvmxjzsmb"},{"name":"树形DP","_id":"cio5pdc2f00977gxl68bup22o"},{"name":"贪心","_id":"cio5pdc2k009f7gxlnjew189d"},{"name":"倍增","_id":"cio5pdc2l009g7gxlw0pb8s7b"},{"name":"缩点","_id":"cio5pdc2p009o7gxle76mq61s"},{"name":"拓扑排序","_id":"cio5pdc2p009p7gxlt2xg447y"},{"name":"匈牙利算法","_id":"cio5pdc2u009z7gxl4xaom7zh"},{"name":"枚举答案","_id":"cio5pdc2u00a07gxlaxrta1j6"},{"name":"POJ","_id":"cio5pdc3900ao7gxlc87ha1y8"},{"name":"KMP","_id":"cio5pdc3a00ap7gxljh4b1do3"},{"name":"Prim","_id":"cio5pdc3e00aw7gxln6ys7gpl"},{"name":"生成树","_id":"cio5pdc3e00ax7gxlgb3up711"},{"name":"分数规划","_id":"cio5pdc3f00ay7gxlld9fxfdy"},{"name":"软件","_id":"cio5pdc3o00bf7gxl6bigzodf"},{"name":"HiDPI","_id":"cio5pdc4q00bk7gxlu6rb4v8h"},{"name":"DFS","_id":"cio5pdc5300bv7gxln4l63mzg"},{"name":"NOIP","_id":"cio5pdc5800c47gxlym32ixlk"},{"name":"EXGCD","_id":"cio5pdc5900c57gxloprefquh"},{"name":"Vijos","_id":"cio5pdc5d00ce7gxl11x5i8p4"},{"name":"洛谷","_id":"cio5pdc5d00cf7gxls80irt27"},{"name":"二分图染色","_id":"cio5pdc5e00cg7gxluzwagfcb"},{"name":"NOI","_id":"cio5pdc5w00dk7gxlm32grigd"},{"name":"离散化","_id":"cio5pdc5x00dl7gxlco5c19k5"},{"name":"并查集","_id":"cio5pdc5x00dm7gxlostly15j"},{"name":"哈希","_id":"cio5pdc5y00dn7gxlg5x0tlzj"},{"name":"map","_id":"cio5pdc5y00do7gxlz3305p0r"},{"name":"最小割","_id":"cio5pdc6g00ea7gxlir6b5ij5"},{"name":"最大权闭合图","_id":"cio5pdc6g00eb7gxl165obbay"},{"name":"莫队","_id":"cio5pdc7800fk7gxlh8fa9xoa"},{"name":"Kruskal","_id":"cio5pdc7c00fq7gxlzzp8vanc"},{"name":"最小生成树","_id":"cio5pdc7d00fr7gxl6jrewa07"},{"name":"Markdown","_id":"cio5pdc7h00g37gxl05g9q3vg"},{"name":"LaTex","_id":"cio5pdc7i00g47gxlfr9uwfqf"},{"name":"GitHub","_id":"cio5pdc7j00g57gxlfyazw2bo"},{"name":"JSOI","_id":"cio5pdc7u00gq7gxlgpk70pf1"},{"name":"分块","_id":"cio5pdc7u00gr7gxlngn0hejl"},{"name":"Floyd","_id":"cio5pdc7y00gy7gxlb5rackiw"},{"name":"博弈","_id":"cio5pdc8200h67gxl34grrou7"},{"name":"HNOI","_id":"cio5pdc8a00hm7gxlyftgig8j"},{"name":"主席树","_id":"cio5pdc8a00hn7gxl4sw57dfa"},{"name":"DFS 序","_id":"cio5pdc8i00i27gxlmm3dqsj9"},{"name":"HDU","_id":"cio5pdc9h00iy7gxlzc8xbvyz"},{"name":"BestCoder","_id":"cio5pdc9i00iz7gxl1ywidqjk"},{"name":"HAOI","_id":"cio5pdc9t00jg7gxlxkuwlwzw"},{"name":"DFS序","_id":"cio5pdcae00jo7gxlqyxkp91i"},{"name":"莫比乌斯反演","_id":"cio5pdcai00jw7gxlk6eiqxcy"},{"name":"GDB","_id":"cio5pdcbd00kd7gxl7hljt5sq"},{"name":"调试","_id":"cio5pdcbd00ke7gxlv30gxnol"},{"name":"CTSC","_id":"cio5pdcc100lj7gxlrl8cu1w5"},{"name":"网络流 24 题","_id":"cio5pdcc200lk7gxlj386s8vt"},{"name":"APIO","_id":"cio5pdccd00m07gxl7kmpuhru"},{"name":"CQOI","_id":"cio5pdcch00m77gxl4szkln0g"},{"name":"分治","_id":"cio5pdccl00me7gxl9v2ryrfy"},{"name":"最大独立集","_id":"cio5pdcct00ms7gxln3sfqqqq"},{"name":"搜索","_id":"cio5pdced00p87gxlksh4ta82"},{"name":"记忆化搜索","_id":"cio5pdcee00p97gxlbdh1rwef"},{"name":"线性DP","_id":"cio5pdcf800qk7gxlcej77o0i"},{"name":"Codeforces","_id":"cio5pdcfm00r87gxlnwi8mt24"},{"name":"Lucas 定理","_id":"cio5pdcfu00re7gxlcejk6dkl"},{"name":"CDQ","_id":"cio5pdcg600s27gxly4qykgfs"},{"name":"Dijkstra","_id":"cio5pdcgk00sm7gxle92kmxiz"},{"name":"快速幂","_id":"cio5pdcha00ti7gxl5e8nbaut"},{"name":"DAG","_id":"cio5pdchu00u67gxljs2fb97c"},{"name":"最长路","_id":"cio5pdchu00u77gxl9zer1kin"},{"name":"Bellman-Ford","_id":"cio5pdchv00u87gxl2z2phmu7"},{"name":"AHOI","_id":"cio5pdci000uj7gxlwxp0eklr"},{"name":"上下界网络流","_id":"cio5pdci300uk7gxlj0dd1sbl"},{"name":"碎碎念","_id":"cio5pdcii00v57gxlwp8fwbiy"},{"name":"暴力","_id":"cio5pdciq00vg7gxlujt0ge3i"},{"name":"二分查找","_id":"cio5pdciv00vp7gxleyfxuv22"},{"name":"矩阵乘法","_id":"cio5pdciz00vv7gxl8213x91a"},{"name":"扫描线","_id":"cio5pdcj400w27gxlgiy90j5o"},{"name":"链表","_id":"cio5pdcj500w37gxlfsdc418b"},{"name":"ZJOI","_id":"ciocc9nvi00026wxl4iv9s7m9"}]}}