{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/vno/source/js/main.js","path":"js/main.js","modified":0},{"_id":"themes/vno/source/js/insight.js","path":"js/insight.js","modified":0},{"_id":"themes/vno/source/js/embed.js","path":"js/embed.js","modified":0},{"_id":"themes/vno/source/js/APlayer.min.js","path":"js/APlayer.min.js","modified":0},{"_id":"themes/vno/source/images/show/list.jpeg","path":"images/show/list.jpeg","modified":0},{"_id":"themes/vno/source/images/show/home.png","path":"images/show/home.png","modified":0},{"_id":"themes/vno/source/images/show/google-analytics.jpeg","path":"images/show/google-analytics.jpeg","modified":0},{"_id":"themes/vno/source/images/show/baidu_tongji.jpeg","path":"images/show/baidu_tongji.jpeg","modified":0},{"_id":"themes/vno/source/images/show/article.jpeg","path":"images/show/article.jpeg","modified":0},{"_id":"themes/vno/source/images/background-cover.jpg","path":"images/background-cover.jpg","modified":0},{"_id":"themes/vno/source/images/avatar.png","path":"images/avatar.png","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/vno/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0},{"_id":"themes/vno/source/css/vno.styl","path":"css/vno.styl","modified":0},{"_id":"themes/vno/source/css/tomorrow.css","path":"css/tomorrow.css","modified":0},{"_id":"themes/vno/source/css/search.styl","path":"css/search.styl","modified":0},{"_id":"source/music/mzr/mzr.ogg","path":"music/mzr/mzr.ogg","modified":0},{"_id":"source/music/mzr/mzr.lrc","path":"music/mzr/mzr.lrc","modified":0},{"_id":"source/music/mzr/mzr.jpg","path":"music/mzr/mzr.jpg","modified":0},{"_id":"source/images/zyz.png","path":"images/zyz.png","modified":0}],"Cache":[{"_id":"source/_posts/20160319-candy.md","shasum":"f13122a5162f37bd168bbe581916353a80bf96ce","modified":1462959204410},{"_id":"source/_posts/20160318-color.md","shasum":"4ba75ba58df47c2827d754b7cd1403c2e5a4fe5f","modified":1462959204410},{"_id":"source/_posts/20160319-set.md","shasum":"e7eb9c83dfd79c39fa6ab6288487d7451fd8be9f","modified":1462959204410},{"_id":"source/_posts/acam-notes/acam.svg","shasum":"443fe0f8ed15e6b9ef1aadeadef650b8ff57e031","modified":1481071571494},{"_id":"source/_posts/20160331-naive.md","shasum":"3ff152e74585ff685591863055fd944851352fd7","modified":1462959204420},{"_id":"source/_posts/acam-notes/acam2.svg","shasum":"02f0702387bd40ee0980ea1da05b2eff5fd05ec8","modified":1481071560998},{"_id":"source/_posts/20160404-theory.md","shasum":"e65366ddf744b97ea3c4e04212ea7f53221f1abe","modified":1477351973565},{"_id":"source/_posts/20160527-array.md","shasum":"a76262669f5104a91a95a469b2389802a606aaf0","modified":1464365684525},{"_id":"source/_posts/acam-notes.md","shasum":"d79024fb77cca744030dc564c1040c1badc7d015","modified":1483340624787},{"_id":"source/_posts/ahoi2008-meet.md","shasum":"e0b091db3a703654300269a5e26b61cc9b345c43","modified":1462959204420},{"_id":"source/_posts/ahoi2013-diff.md","shasum":"7bc65d01071dd6e1b407a23fe06febf89aae7bf0","modified":1475155507464},{"_id":"source/_posts/ahoi2013-homework.md","shasum":"c1885a83afeacf0ec2651d2dffc4433d66c71f46","modified":1483067289067},{"_id":"source/_posts/ahoi2014-story.md","shasum":"2612b109cd4041278c1c642edf3bdfd804a3abe1","modified":1482631025190},{"_id":"source/_posts/at-the-cross-of-time/mzr.lrc","shasum":"25283ad79892beb5c83c43d981fdd32fbee30466","modified":1472609600778},{"_id":"source/_posts/apio2009-atm.md","shasum":"4c8b22e60777afe7205ce9a900eb1a02256c28e8","modified":1462959204420},{"_id":"source/_posts/apio2010-commando.md","shasum":"8fa94fab900ebf9c22c4f8323b5ae51a80ba6041","modified":1477351986840},{"_id":"source/_posts/apio2012-dispatching.md","shasum":"05ea59ac8e5545546d5a6b9b363e0f91045dd1cb","modified":1483518413539},{"_id":"source/_posts/at-the-cross-of-time.md","shasum":"6a69e0576d4becf6c64d697f64b1600684f86600","modified":1483160692357},{"_id":"source/_posts/bigint-template.md","shasum":"934fda5bea22b36e0606b10d33bc5df2f37d2487","modified":1462959204420},{"_id":"source/_posts/bsgs-notes.md","shasum":"dc43f79b94f595c467266a940e86648458828d19","modified":1483361263572},{"_id":"source/_posts/bzoj-1001.md","shasum":"72d9592ee87d155d313e7f628a8cebfae4aea2da","modified":1462959204420},{"_id":"source/_posts/bzoj-1008.md","shasum":"9e33d15285f7e920f9c945333df08bcb7bcc2c21","modified":1462959204420},{"_id":"source/_posts/bzoj-1176.md","shasum":"15b02ad8dd8e0ee24c61c6b0a165b2207065e63c","modified":1466431866375},{"_id":"source/_posts/bzoj-1251.md","shasum":"c08cd8320d570bccf0d3bc1be414e62b28b8a4da","modified":1462959204420},{"_id":"source/_posts/bzoj-1334.md","shasum":"abdb171b4bac613dca99191ef1801a96a998caec","modified":1477351995812},{"_id":"source/_posts/bzoj-1468.md","shasum":"0b82120a77b6175dff7f5aa518b23484188ffa05","modified":1466071797460},{"_id":"source/_posts/bzoj-1477.md","shasum":"c595afe04efabe234f97173104721f64efdbd233","modified":1462959204420},{"_id":"source/_posts/bzoj-1585.md","shasum":"8fbfb910f2698f366ee666295c4d8d6749d22046","modified":1466583292252},{"_id":"source/_posts/bzoj-1597.md","shasum":"90b890eb6f1937eeca51175e70935f65f36ff154","modified":1477352334716},{"_id":"source/_posts/bzoj-1692.md","shasum":"7d031362d6e4cdaaa6bba2b6eb13706db8dc7efb","modified":1475156754344},{"_id":"source/_posts/bzoj-1706.md","shasum":"ab608ab18d6e990d5f08f0969c5102b3c699b970","modified":1475882328043},{"_id":"source/_posts/bzoj-1711.md","shasum":"625edc5f73eabf5673add401b9f8242356034202","modified":1475917486235},{"_id":"source/_posts/bzoj-1718.md","shasum":"ad23023b9d8804f44d542853b60d229f222aefb0","modified":1483234239897},{"_id":"source/_posts/bzoj-1756.md","shasum":"60bf2403886143b533d0a969f90c410a8550b425","modified":1462959204420},{"_id":"source/_posts/bzoj-2038.md","shasum":"f2168817f10ce4efdc4e11ddb87533de4e0ba411","modified":1462959204420},{"_id":"source/_posts/bzoj-2120.md","shasum":"4a9e78ff7483870d8bc9e453e382f61d37c00eeb","modified":1483062399370},{"_id":"source/_posts/bzoj-2127.md","shasum":"5f423860c93ca99cf0134ec7057af3a5caa1cf77","modified":1466583936327},{"_id":"source/_posts/bzoj-2132.md","shasum":"f09e494406452a281f11baad78e64b72692cced6","modified":1466672219417},{"_id":"source/_posts/bzoj-2143.md","shasum":"3fb8100c81c0111db2d10080b9786aa065ae6b10","modified":1465888560611},{"_id":"source/_posts/bzoj-2152.md","shasum":"d123e9e36bf39b483ec5daf21b61b81649bb5640","modified":1466071815564},{"_id":"source/_posts/bzoj-2194.md","shasum":"28422db536e022d9d404eb6714a6ead40b23f7d2","modified":1465651961781},{"_id":"source/_posts/bzoj-2296.md","shasum":"23212b789066f8b9bd854f2cb7b3ddea6585ec9e","modified":1462959204420},{"_id":"source/_posts/bzoj-2438.md","shasum":"a91564720a619f94894f8572d4551a53c46faebd","modified":1466843509077},{"_id":"source/_posts/bzoj-2442.md","shasum":"09e6f50360804dfd5882d273bbb6300f2da95aa0","modified":1477352012360},{"_id":"source/_posts/bzoj-2456.md","shasum":"021110d045d68e07f7e18e35ac8d3940b7836493","modified":1466172511587},{"_id":"source/_posts/bzoj-2683/cdq.png","shasum":"a95d0b02b915f092df6656298add0f0fc9662341","modified":1462955792540},{"_id":"source/_posts/bzoj-2462.md","shasum":"1732c3114d698e1c3d622c6b1a3d172100e0812c","modified":1473810063694},{"_id":"source/_posts/bzoj-2565.md","shasum":"6b64b4a04fbecc398f804a429813f19ef8bfd5d8","modified":1483345804649},{"_id":"source/_posts/bzoj-2580.md","shasum":"a73e63accb968c9992ae4c7e289994fcdbd507d5","modified":1474154745766},{"_id":"source/_posts/bzoj-2683.md","shasum":"926ec2d1b7000c24c1edd22d197180164cac76a8","modified":1466431930441},{"_id":"source/_posts/bzoj-2716.md","shasum":"fe2aec385e2971d42f1097e916fe964445aa424d","modified":1466824130905},{"_id":"source/_posts/bzoj-2820.md","shasum":"b893e9bbcea214b41bef4c502d833a930d123fdb","modified":1462959204420},{"_id":"source/_posts/bzoj-3156.md","shasum":"476a683d45bb01c6c6cca9af75e5f0c6f6c74734","modified":1477352022972},{"_id":"source/_posts/bzoj-3196.md","shasum":"154610a47819f898caa851b5b48c827183e00664","modified":1483340701203},{"_id":"source/_posts/bzoj-3230.md","shasum":"5882c46621fd0d914caa25ee49de7f163964c7b9","modified":1475191571909},{"_id":"source/_posts/bzoj-3262.md","shasum":"ad61bcd01d1a0afdc44e0e038123ff32c86a2e76","modified":1466341000696},{"_id":"source/_posts/bzoj-3275.md","shasum":"a14dc375463cfb3df8cc97d3adf5b78c7ca85456","modified":1464016159116},{"_id":"source/_posts/bzoj-3277.md","shasum":"07b57370422ef563976726932df98adac3478691","modified":1475192434037},{"_id":"source/_posts/bzoj-3438.md","shasum":"7fa24e4ae32a471e08cf89604521923861bd42e8","modified":1466493507214},{"_id":"source/_posts/bzoj-3511.md","shasum":"a69c5a7b074d933e3eb29d1b2c8a24645520728d","modified":1462959204420},{"_id":"source/_posts/bzoj-3697.md","shasum":"3560e2748c810aec86cc770aab1371f8f33698a6","modified":1474808740919},{"_id":"source/_posts/bzoj-3796.md","shasum":"d964d550ff1177bfbb1d19991f600624ab25824c","modified":1475192923083},{"_id":"source/_posts/bzoj-3894.md","shasum":"9cf338b78641a5cc1eb027d84506a587d7c9267d","modified":1466583943359},{"_id":"source/_posts/bzoj-3940.md","shasum":"34e3c58a8bed87be2046f4b4da66f095f3353edd","modified":1473810460840},{"_id":"source/_posts/bzoj-4145.md","shasum":"1383833b1739216df566d16f25ab76e377e728a8","modified":1477352032208},{"_id":"source/_posts/bzoj-3280.md","shasum":"f379b4a1212f7781164d71625d49ad3124d1b523","modified":1473508473657},{"_id":"source/_posts/bzoj-4247.md","shasum":"ecb5c5706b743d62fd19c3bcc03f4638b94e2be3","modified":1477352045720},{"_id":"source/_posts/bzoj-4318.md","shasum":"0004fbf6e758b707f24a98c3929912894626bdd0","modified":1464696387692},{"_id":"source/_posts/bzoj-4403.md","shasum":"0e503e9c28ace534c15b2b47576add9bd4027af5","modified":1462959204420},{"_id":"source/_posts/ceoi2004-two.md","shasum":"99ab98de7fb06f9fdfca038c023d4ff8f74f8755","modified":1477352054116},{"_id":"source/_posts/ceoi2008-order.md","shasum":"96b1a7c05854b6da645d341d870b6c958cac73a5","modified":1466582878396},{"_id":"source/_posts/cf-628d.md","shasum":"5bd19c9ec8ea646e78edcf23d15218c6060e1b47","modified":1477352319769},{"_id":"source/_posts/cf-716e.md","shasum":"521e9813b06b325fb88c8273b293ed5926b3365c","modified":1483340590680},{"_id":"source/_posts/cf-716e/example.svg","shasum":"a1d6731f2ef7e43ae48e27345954c6cb24a216b0","modified":1474439170788},{"_id":"source/_posts/bzoj-3289.md","shasum":"badb63442e7d4e0a8200f1e8cce98b2c16ee351d","modified":1483065935781},{"_id":"source/_posts/codevs-1345.md","shasum":"58546572e0bb94b562f55fdbf6649287a3107656","modified":1477352064784},{"_id":"source/_posts/chairman-tree-notes.md","shasum":"8be4f4b6d283778a78c6dc87d141029f34f57d51","modified":1462972004900},{"_id":"source/_posts/coci2015-divljak.md","shasum":"75aee7f3216c123eb41de62a2a657cf6fb2a9601","modified":1474239668919},{"_id":"source/_posts/codevs-1563.md","shasum":"90f4dda98f3aed528734d91eaa918ea58ad5d67d","modified":1466518742060},{"_id":"source/_posts/codevs-2822.md","shasum":"a5f2981e80882ae575f7c28d9552bddbe717915a","modified":1462959204420},{"_id":"source/_posts/codevs-2598.md","shasum":"9f5c7bea72bdd82e3f05c5e6284e8dd8e0aed8e8","modified":1477352072459},{"_id":"source/_posts/codevs-3269-monotone-queue.md","shasum":"b445e3b6240f19aae1b165e94fb3e2fa17162499","modified":1477352123283},{"_id":"source/_posts/codevs-3168-3162.md","shasum":"aafdf6bc35f4dcda18d9f89de0ae2ecb8c75c2c4","modified":1477352102283},{"_id":"source/_posts/cogs-14.md","shasum":"df074c69b9f8cacedba8ccea146ac644e8201397","modified":1462959204420},{"_id":"source/_posts/cogs-396.md","shasum":"fbfd2fc22b9c83aa16792fa61d51d702b53461f7","modified":1462959204430},{"_id":"source/_posts/cogs-439.md","shasum":"2426244914406bd35b753d445bb5fcd3e01a5c30","modified":1462959204430},{"_id":"source/_posts/cogs-727.md","shasum":"d3f3d51ba288685a52479e3847f4e84885fcdb3e","modified":1462959204430},{"_id":"source/_posts/codevs-3269.md","shasum":"b276f70ecd368aa72d5c1a48b680f475818b0d47","modified":1477352115991},{"_id":"source/_posts/cogs-728.md","shasum":"c7fa068adf3bf1f5f5b4add16374b265ef21ca11","modified":1462959204430},{"_id":"source/_posts/cogs-729.md","shasum":"bb45c57f781ff5c8eb0e87b3edadf7b206b81c01","modified":1462959204430},{"_id":"source/_posts/cogs-734.md","shasum":"4a748f8ae51d4d1990b89ac8081e53d74fbc183c","modified":1462959204430},{"_id":"source/_posts/cogs-731.md","shasum":"f16c01e7c3da8aa233df4daee546f3024726d239","modified":1477352304985},{"_id":"source/_posts/cogs-739.md","shasum":"4eb4f215432d85cc7bd93a357ee70d326f314504","modified":1462959204430},{"_id":"source/_posts/cogs-738.md","shasum":"01a88085f9e1823b8fc63e04a617b85fc1551ade","modified":1462959204430},{"_id":"source/_posts/cogs-740.md","shasum":"e90060c6feb6273cd400258627f141214574dd8f","modified":1462959204430},{"_id":"source/_posts/cogs-741.md","shasum":"91a8b62bd42e7be33d94ae1a9624d5a0d7c2c9a3","modified":1462959204430},{"_id":"source/_posts/cogs-746.md","shasum":"aa46c716f60453fdbbfa4ff4ccdca515e90e25ae","modified":1462959204430},{"_id":"source/_posts/cogs-742.md","shasum":"dc5b03c9e8b857ea345e0f906692847cc7c2508b","modified":1462959204430},{"_id":"source/_posts/cqoi2011-inverse.md","shasum":"5e6e7e3d0c82e5814f994d8468de30766070c55b","modified":1466431853556},{"_id":"source/_posts/combinatorics-notes.md","shasum":"f3e5e1bf1d06c126032426103df6f1990368ad07","modified":1462959204430},{"_id":"source/_posts/cqoi2016-cuts.md","shasum":"96b727a740bc374fefd4b8ca7d1c09b5f20648c4","modified":1462959204430},{"_id":"source/_posts/cqoi2016-number.md","shasum":"bae7a7e7008769b1bd14b496961ce95efd9f76c7","modified":1477352136359},{"_id":"source/_posts/ctsc1997-course.md","shasum":"48f7051612c8843ce79049b59c0fb88b0fbf557c","modified":1477352275933},{"_id":"source/_posts/ctsc1999-home.md","shasum":"978baaae9dd654467febabfa562eea00beb02859","modified":1462959204430},{"_id":"source/_posts/derangement-number.md","shasum":"1d85fe52fcf017157eeffc96e660b029b83cb31f","modified":1462959204430},{"_id":"source/_posts/ctsc-apio-2016.md","shasum":"b8a08df409b774cf281797e8a8dc95e01de5624a","modified":1479656971201},{"_id":"source/_posts/dinic-notes.md","shasum":"ec041e36d2aa97dad861d9851524cb01f3b5ed1a","modified":1482585228817},{"_id":"source/_posts/docker-sandbox-judger.md","shasum":"8a5895d636752944fc5f8b83c17dd594f7209331","modified":1481635493048},{"_id":"source/_posts/euler-circuit-notes.md","shasum":"22b4a062c5e61d3c1b2dec0e4c976346fd753e8f","modified":1483339121747},{"_id":"source/_posts/edmonds-karp-notes.md","shasum":"edba11cb82da34ac8af87a4462724abe868e94e5","modified":1482635144773},{"_id":"source/_posts/euler-sieve.md","shasum":"bdd661e2b3f1d99f802c6179a97c7c31dd4f883d","modified":1462959204440},{"_id":"source/_posts/fft-notes.md","shasum":"b36068745daabad1be6474be5e84e86c38fceee7","modified":1482474049497},{"_id":"source/_posts/fft-to-ntt.md","shasum":"1876bb4ba0acf94f95333a06dfdaa8eae3f51cd8","modified":1466170692116},{"_id":"source/_posts/fjoi2007-wheel.md","shasum":"62ed81583cf9b21d3798a0f89b3e4d4fe56ac776","modified":1476696387229},{"_id":"source/_posts/geometry-notes/1.ggb","shasum":"4e6d9a8a63ed9c440f40708c3d25a8b78eda515d","modified":1483666187955},{"_id":"source/_posts/geometry-notes/2.ggb","shasum":"661074f4858099ec573c4f9b145331bf3a0220f0","modified":1483668465407},{"_id":"source/_posts/geometry-notes/3.ggb","shasum":"0463664a0f02fc6736b06b234b660eb85e33c9e8","modified":1483670035666},{"_id":"source/_posts/geometry-notes/4.ggb","shasum":"e83654c63399e2af73b4d567a62ab55419c3b1d1","modified":1483672012782},{"_id":"source/_posts/geometry-notes/5.ggb","shasum":"6c347a3c0dd1ef65cf4671cfefe6c8e4c9ec3c65","modified":1483672862394},{"_id":"source/_posts/geometry-notes/6.ggb","shasum":"4f8d2e7c8949a912625f9d6dfb1e375d6dbda0c9","modified":1483688801569},{"_id":"source/_posts/geometry-notes.md","shasum":"3e5f73afc014f1fe837cb2b2ad0d6080657bab9a","modified":1483692199588},{"_id":"source/_posts/gnu-debugger.md","shasum":"a39a3556d1965b8fc4ce3404e23c4aa5587ceca1","modified":1462959204440},{"_id":"source/_posts/haoi2006-cow.md","shasum":"de4e6dcca3e29acdc131063a61ca1f8fd1ee3be1","modified":1462959204440},{"_id":"source/_posts/haoi2006-sequence/2.svg","shasum":"57a7cee258306ed3073e46a9e0e79f6485c8f100","modified":1481071191582},{"_id":"source/_posts/haoi2006-sequence/1.svg","shasum":"0337ba40ba7e2733cc657b79636f5f06e5f7c9a3","modified":1481071178527},{"_id":"source/_posts/haoi2007-ant.md","shasum":"2bd734af13a13d0361dc29d13a63b5120df22f8b","modified":1481619427004},{"_id":"source/_posts/haoi2006-sequence.md","shasum":"deabe14357855cd51e4690ddabaea2eb1e1933f4","modified":1481070972380},{"_id":"source/_posts/haoi2007-cover.md","shasum":"c3892255d5e8a099d5b5ca12afd35abdb7822642","modified":1481618244905},{"_id":"source/_posts/haoi2007-lis.md","shasum":"d559fad8378784179e8605eec1b0c70c6f75e34c","modified":1480580725224},{"_id":"source/_posts/haoi2008-candy.md","shasum":"e408ba8c0c27c36c3fa2606474560055131c2412","modified":1479021877454},{"_id":"source/_posts/haoi2007-square.md","shasum":"a4a760a50dd8df40925bed1f51856373fcfccc64","modified":1480634217457},{"_id":"source/_posts/haoi2007-separation.md","shasum":"4b6aaca21dcf4324d4d22dd6983c52d1d1411709","modified":1480895559695},{"_id":"source/_posts/haoi2008-coins.md","shasum":"b2a5b3bebb8b9bd49ac5e76691ae32acd10e19bd","modified":1479006702698},{"_id":"source/_posts/haoi2008-move.md","shasum":"f276822ba6612d78a2b2a3fb307a73134e8f61eb","modified":1481620097277},{"_id":"source/_posts/haoi2008-cir.md","shasum":"268b031e4e51141293fed8dc35b778c0e9d6c01f","modified":1479005811312},{"_id":"source/_posts/haoi2008-name.md","shasum":"55056d53974b62ac7ba9c4daa55fb46bf2d7b125","modified":1477352144055},{"_id":"source/_posts/haoi2008-stick.md","shasum":"76f7a22c09f8394f2aff8a2f54bd36ce570a048c","modified":1479007911164},{"_id":"source/_posts/haoi2008-rank.md","shasum":"71444692107dffe7bcdb1a3aac4d63117c922c61","modified":1481620085081},{"_id":"source/_posts/haoi2011-problemb.md","shasum":"80f9d8191d53d49067ee4e5c654cdc60a8a53384","modified":1462959204440},{"_id":"source/_posts/haoi2015-t2.md","shasum":"b46b9260d7c4fd96c6f56b7faf8eb10a7507fc55","modified":1473500685141},{"_id":"source/_posts/hdu-2089.md","shasum":"52c4b8de67b50c5f4addd2d422c958164ed2e5fd","modified":1477352153582},{"_id":"source/_posts/haoi2016-chain.md","shasum":"b722f46a179a7fd0fd2293235b225a75c3343ef2","modified":1462959204440},{"_id":"source/_posts/bzoj-3365.md","shasum":"3bfab6ccaa5e2dfd1fa3a6a4d65d68fb96a5b22a","modified":1466071781441},{"_id":"source/_posts/heoi2013-bag.md","shasum":"3d3544eca469964d0c67c98cc605e76bd654a445","modified":1477352200514},{"_id":"source/_posts/hdu-5632.md","shasum":"e8b90a7fda59235e4c0a7de7416e0f6bd2c2eaa9","modified":1477352162698},{"_id":"source/_posts/hdu-5906.md","shasum":"de080c085c1e5d051fc64319167bb951836391dc","modified":1475229652455},{"_id":"source/_posts/here-the-best-sight.md","shasum":"3637d1d214c07759c6d10333012d67e75f74f297","modified":1483314452149},{"_id":"source/_posts/hnoi2004-language.md","shasum":"7c4a81764969730a17d818d80444428dc84d8179","modified":1473723911171},{"_id":"source/_posts/hnoi2004-pet.md","shasum":"b2bda3d66ff145436b7eab827120e72edbae6c57","modified":1462959204440},{"_id":"source/_posts/hnoi2008-cards.md","shasum":"a99c6c4f9bbf046575f4cf52eae0fdb272c1cc59","modified":1476673417128},{"_id":"source/_posts/hnoi2008-gt.md","shasum":"51d30d56860cf265cf1a21586d14ed5b7371d2e1","modified":1475880765853},{"_id":"source/_posts/hnoi2008-kingdom.md","shasum":"630ff7a9fe9730a54e7fb2af393bb3975bc30b87","modified":1476696323487},{"_id":"source/_posts/hnoi2008-toy.md","shasum":"26405e1e114faeb135c6a647611853b9a3e34811","modified":1477352187662},{"_id":"source/_posts/hnoi2008-tree.md","shasum":"ba8997bd556bb160cc33b8978d55000e45c34b6e","modified":1476673607260},{"_id":"source/_posts/hnoi2010-chorus.md","shasum":"ef16ed9ed60a26fb7296c92f5456aff90b98849d","modified":1477352209310},{"_id":"source/_posts/hnoi2012-mine.md","shasum":"cce8a25d8ba4f48806c8b10b6ea947912bb72964","modified":1473292401367},{"_id":"source/_posts/hnoi2016-network.md","shasum":"701e1dfb9e177e0b4857e359cc2b2e32392fd4cd","modified":1462959589490},{"_id":"source/_posts/hnoi2016-multiple.md","shasum":"5f8819ca3130cd4e04f7c49a5ff3c52b50fe67a9","modified":1462959204440},{"_id":"source/_posts/hnoi2016-sequence.md","shasum":"584e140ef6c2aefe78304fcedce69218d3c90d55","modified":1462959204440},{"_id":"source/_posts/hdu-5642.md","shasum":"65de14e383af7e37e49ab3a7c18f8acacab2f00e","modified":1477352172278},{"_id":"source/_posts/jsoi2007-cipher.md","shasum":"72d59d69cd1774e5ff8550950b7787d1c5245fae","modified":1475154361131},{"_id":"source/_posts/jsoi2007-generator.md","shasum":"389a27109369808043d691bfce41bc3fa3b5b754","modified":1473636489303},{"_id":"source/_posts/jsoi2007-mahjong.md","shasum":"7168f1c1c3915f6bdfbe63ab8fb1ad6eacd8e872","modified":1478997155260},{"_id":"source/_posts/ioi2008-island.md","shasum":"c556010ee83873a588f35bf672275d3f03fd55de","modified":1477402349876},{"_id":"source/_posts/hnoi2016-tree.md","shasum":"d8e0634d20447cf11e6a3dc092629df943442b65","modified":1473486695350},{"_id":"source/_posts/jsoi2007-repair.md","shasum":"b471ddac6cf3614bf4c70f7422bdc0c88a77fb79","modified":1479000357614},{"_id":"source/_posts/jsoi2008-dotr.md","shasum":"b0d21a9fcaf6e34cd3a1d55b6f4db4914e7165f7","modified":1477352221646},{"_id":"source/_posts/jsoi2008-award.md","shasum":"8ac08f0cbca053ae3a9af3c3f8c7a333149e1ef9","modified":1476798062436},{"_id":"source/_posts/jsoi2008-maxnumber.md","shasum":"973b88d1287688eef3d8f99363a1db35399213db","modified":1462959204440},{"_id":"source/_posts/jsoi2008-prefix.md","shasum":"9d1e1e5bfc935b12dd2477dc09b31eeeda7651b8","modified":1476796235311},{"_id":"source/_posts/jsoi2008-starwar.md","shasum":"44f26d7aea8467915a733921932eb627c32c8657","modified":1476796800814},{"_id":"source/_posts/jsoi2009-game.md","shasum":"7e3bcdfbc619bd881e671216285cd1649f62b87a","modified":1462959204440},{"_id":"source/_posts/jsoi2016-flight.md","shasum":"9f52be4f9cddedb2ab7e6737ce2f387faa9147e6","modified":1462959238400},{"_id":"source/_posts/jsoi2009-game2.md","shasum":"982f4ff3511ef0b4262c197d007eafe92667d97e","modified":1474191031290},{"_id":"source/_posts/jsoi2016-light.md","shasum":"58533f261da20e6409234f6aee1ea40049a1f35f","modified":1462959204440},{"_id":"source/_posts/kmp-notes.md","shasum":"51550012962150b1d7c7bbfdce5f8275cd654ec1","modified":1483235057894},{"_id":"source/_posts/link-cut-tree-notes.md","shasum":"d0dd589310e783f3cc72f2d4a558396dde355f78","modified":1462959204440},{"_id":"source/_posts/manacher-notes/1.svg","shasum":"689f9a1a16fa6bebbe71921fe95a95791af6d03a","modified":1483355976711},{"_id":"source/_posts/manacher-notes.md","shasum":"5de4e5b4d8a9f65229dad35bfe02866aa9375749","modified":1483359315263},{"_id":"source/_posts/manacher-notes/2.svg","shasum":"9846f2acbe071d16813087471c83561141070942","modified":1483356000303},{"_id":"source/_posts/mo-algorithm-notes.md","shasum":"04963d986f2cbd596dfc9d92c1efdbb209e3afb7","modified":1462959204440},{"_id":"source/_posts/manacher-notes/3.svg","shasum":"2c61c2f78699f473f9c9758f7ed9fe4984ee1b97","modified":1483356016587},{"_id":"source/_posts/minimum-spanning-tree-notes.md","shasum":"5e376a19420ba0d04fbfc86ffb85254f8f33b464","modified":1462959204440},{"_id":"source/_posts/monotone-queue-notes.md","shasum":"fc7a11f33c6b9f425dde2c3b3c901e7018aca151","modified":1462959204440},{"_id":"source/_posts/mul-inverse.md","shasum":"88b06571986b29765bc702445e03c7db387ed3b1","modified":1462959204450},{"_id":"source/_posts/node-devide-notes.md","shasum":"125c398ee1be3445dbbc96b8e724e9ac97c3b9d9","modified":1466152641034},{"_id":"source/_posts/node-devide-notes/tree1.svg","shasum":"4de32d5e3b22eb531886d0f9f475f2a9982ee471","modified":1481071614437},{"_id":"source/_posts/ioi2011-race.md","shasum":"e656c8dc53b1d87d99f3d3e9ef8425949a54dde0","modified":1466078515927},{"_id":"source/_posts/node-devide-notes/tree2.svg","shasum":"407c61fdd3d63b87c5678d80c9b6213781d2cb1f","modified":1481071624189},{"_id":"source/_posts/noi2003-editor.md","shasum":"6d6ccf7f089180de540cb75879f4589b5c1e8ee4","modified":1462959204450},{"_id":"source/_posts/noi2006-profit.md","shasum":"cdf389673d9a8babd630e8c5bc247670b695bff4","modified":1462959204450},{"_id":"source/_posts/noi2008-candy/2.ggb","shasum":"b72de255a5a79e92a5a220da592cc30818579ca7","modified":1482481329150},{"_id":"source/_posts/noi2008-candy/1.svg","shasum":"487bedd4ee907b6af27bc2dff608d7084da67f46","modified":1482459268920},{"_id":"source/_posts/noi2008-candy/3.ggb","shasum":"7155350e293077d4fd36bd65715ea693ed339c80","modified":1482480473665},{"_id":"source/_posts/noi2008-candy/2.svg","shasum":"84a22ca72f6e0ff90dfce05b56f44e7ab66f3cc9","modified":1482480535076},{"_id":"source/_posts/noi2008-candy/4.ggb","shasum":"0c851a79d13d36a0bc06c1360ec5ca3b48e301a2","modified":1482481843625},{"_id":"source/_posts/noi2002-galaxy.md","shasum":"0b62ae091bdecd684968bd8eb0707890d71eeac1","modified":1462959204450},{"_id":"source/_posts/noi2008-candy/5.ggb","shasum":"e80d5ff3511748769937e358ca9f213db78a3adc","modified":1482482981048},{"_id":"source/_posts/noi2008-candy/6.ggb","shasum":"b968f70e6224debb5e16b9ea4a1e39ebc2de4834","modified":1482484170031},{"_id":"source/_posts/noi2008-candy/7.ggb","shasum":"fbf0ec7e19ee13b534e9aa66ded3170ec449261e","modified":1482484224546},{"_id":"source/_posts/noi2004-cashier.md","shasum":"0504fdf9c3754c9f1fa1b1be8befc3dcf0852794","modified":1462959204450},{"_id":"source/_posts/noi2008-candy.md","shasum":"ab7d37baeb1d12378e115a08a1d4a97c39af3e1d","modified":1482487256316},{"_id":"source/_posts/noi2011-type.md","shasum":"f84650491029914e9de402d6433b478d1caa32f0","modified":1473638033794},{"_id":"source/_posts/noi2012-random.md","shasum":"b0e78167c2a4168496fe6b70a1dc8d3b45962352","modified":1475883407010},{"_id":"source/_posts/noi2014-forest.md","shasum":"692c2d383b68f8c65f1a2b45c37cb788e7f76f47","modified":1468252483005},{"_id":"source/_posts/noi2014-sleep.md","shasum":"32c222899af7ba614509f0b5cb66bc0867154960","modified":1462959204450},{"_id":"source/_posts/noi2014-zoo.md","shasum":"48d488c5c348640989a59b2c84c2a60d8273ce10","modified":1468251707623},{"_id":"source/_posts/noi2015-dinner.md","shasum":"afbaf06fc29fcc73760e96692f67d386e51f7ffe","modified":1477352235002},{"_id":"source/_posts/noi2015-epic.md","shasum":"d9f2c20735718a4f922f1b7f0bf394fcbeb992a8","modified":1467336511308},{"_id":"source/_posts/noi2015-manager.md","shasum":"b718da5118bf865669f6505c4ac9acdba8339316","modified":1462959204450},{"_id":"source/_posts/noi2015-farm.md","shasum":"419b248d8bb0e510213977f23d5ef46b98526c8c","modified":1478001561067},{"_id":"source/_posts/noi2015-prog.md","shasum":"1f738de912a1b38d8bfc2d497e1b9c54236a13a4","modified":1478606807659},{"_id":"source/_posts/noi2015-savour.md","shasum":"05ae6befa30e37183474e5a856a8fd2b95741b93","modified":1467336519440},{"_id":"source/_posts/noi2016-excellent.md","shasum":"8d8033bffd7cc40a8a474d5914ff17c626524fc7","modified":1473118923830},{"_id":"source/_posts/noi2016-grid.md","shasum":"f86421c87bea57c995b00231fffadfd4fd54cecb","modified":1473638069201},{"_id":"source/_posts/noi2016-interval.md","shasum":"5e22b8b0f979a24af64e88dcc5ebbf8a75bddf16","modified":1473118751830},{"_id":"source/_posts/noip2000-cheng-ji-zui-da.md","shasum":"f98039cfa065e1662575945a0b1a582ec2ad2689","modified":1477351910525},{"_id":"source/_posts/noip2003-game.md","shasum":"6f382752e06de918287ed053ba5cc20db51b633a","modified":1477351904205},{"_id":"source/_posts/noip2006-energy.md","shasum":"2a1c5d16824f3e06c23b5f7cd692b187863a66bd","modified":1477351922329},{"_id":"source/_posts/noip2006-budget.md","shasum":"b350f36da264bb5fd90a5fee23019284efa9918c","modified":1477351822210},{"_id":"source/_posts/noip2010-flow.md","shasum":"7133e4ca1632ebbafbebee02cc749908e81af1f6","modified":1479029018684},{"_id":"source/_posts/noip2010-prison.md","shasum":"1c89f4fba3f01bec85a06ce8e5309a7e6d50f733","modified":1462959204450},{"_id":"source/_posts/noip2012-blockade.md","shasum":"dcbb2b7c28da18c0a662a6fd251f8d893461d8a4","modified":1479030258333},{"_id":"source/_posts/noip2012-classrooms.md","shasum":"3ec63cd7cf2caa054464e41e0e8428d52c234021","modified":1475917451595},{"_id":"source/_posts/noip2012-drive.md","shasum":"e7df25f732858eea47e4ebbb206e9cc30ab5d277","modified":1479028462387},{"_id":"source/_posts/noip2012-mod.md","shasum":"0fb6c0ef73a261e10a1b23b235c0492a247c1362","modified":1462959204450},{"_id":"source/_posts/noip2013-flower.md","shasum":"eac451fe25287a373570518cfab3666459c602ac","modified":1479026565336},{"_id":"source/_posts/noip2013-match.md","shasum":"a3b515c40a4d08f8abef8c1b26e0923df31b8d56","modified":1479024938455},{"_id":"source/_posts/noip2013-puzzle.md","shasum":"15b7b800cabdda94234aff34e9591e22974a4383","modified":1479033358177},{"_id":"source/_posts/noip2015-substring.md","shasum":"8132adb345d5966190126eb464240285ca345188","modified":1478069428453},{"_id":"source/_posts/noip2015-transport.md","shasum":"65287e79098fc97ed2f63ad521889c0e5cb853a5","modified":1476882449463},{"_id":"source/_posts/noip2016-angrybirds.md","shasum":"d4b424e95af568e449f201378bcccca21ffc3973","modified":1480425733905},{"_id":"source/_posts/noip2016-classroom.md","shasum":"a4730715dec75b04f15ebf35c7fc3e7c803c1a81","modified":1480404993407},{"_id":"source/_posts/noip2016-running/linear-backward1.svg","shasum":"f11ad00d6b6d9c4a9dbcdd756a54ac9f98aae87c","modified":1480402071309},{"_id":"source/_posts/noip2016-running/linear-forward1.svg","shasum":"21d1e9f4c290ba36e95ca3d1a3f03108f7e7d08c","modified":1480401570576},{"_id":"source/_posts/noip2016-earthworm.md","shasum":"1b2fcb76d67ccbceab9b7a4fccbdd8d36e25f77c","modified":1480425082980},{"_id":"source/_posts/noip2016-running/linear-forward2.svg","shasum":"d828849ead2a7f7a3ac34250ec3e468dd053fe4c","modified":1480401597915},{"_id":"source/_posts/noip2016-running.md","shasum":"4314316adc4ca81526daf243a8365e04f7224136","modified":1480404979183},{"_id":"source/_posts/noip2016-problem.md","shasum":"3f2bfceef09b7568444107ae65ed6222db1f5f29","modified":1480425142493},{"_id":"source/_posts/noip2015-landlords.md","shasum":"383d0be32afdf22cbb8c522fea4ae2fcde6b7676","modified":1476865979622},{"_id":"source/_posts/noip2016-toy.md","shasum":"5b73c18d444e50a23f5352203f26632af2830c2c","modified":1480404968883},{"_id":"source/_posts/noip2016.md","shasum":"a9273f495144f13620fd53d5e847c9f596becd2d","modified":1479656914658},{"_id":"source/_posts/non-recursion-dfs-with-stack.md","shasum":"77777eea132ddbbc8f0201f6438267a80a414656","modified":1462959204450},{"_id":"source/_posts/npm-debug.log","shasum":"881c868bf599dd4f4753f8b868bec0bb7a2a6f51","modified":1466824292761},{"_id":"source/_posts/number-theory-notes-1.md","shasum":"06a1c30f28a21e76f65bc5afc0d9766231d8af32","modified":1462959204450},{"_id":"source/_posts/poi2000-wir.md","shasum":"c7d42107d0fdf656828fda727b7c0207494f9dd3","modified":1473724314323},{"_id":"source/_posts/poi2005-kos.md","shasum":"7d2d41ca023967051b7c5e8262484cff78a75009","modified":1466591154146},{"_id":"source/_posts/poi2006-szk.md","shasum":"6eb519b750b4996e46308708f4676ef24bf623d3","modified":1466590859112},{"_id":"source/_posts/poi2008-blo.md","shasum":"60d3bdf871aedf1869912848eea175276493eff6","modified":1473332288939},{"_id":"source/_posts/poj-1737.md","shasum":"09c4fec6b5a83f1b9b7b8161b0aab0ac1b24cbc3","modified":1462959204450},{"_id":"source/_posts/poj-2728.md","shasum":"732694ea57c6eef6f36cb28708d0072913ef8f1e","modified":1462959204450},{"_id":"source/_posts/poj-3630.md","shasum":"ea594cc176ecbf8a9af0643bee8b1f4f4622b467","modified":1483326617944},{"_id":"source/_posts/poj-3461.md","shasum":"226bd4eac18f3439dc754c946c995894cb74d640","modified":1462959204450},{"_id":"source/_posts/rmq-template.md","shasum":"373e730b68daa4c8c75ba4b493c6fc8b173439d5","modified":1483235157252},{"_id":"source/_posts/scoi2003-fold.md","shasum":"3aa6ac1189749d23245e8d9aa80da44c17eecd51","modified":1477351878502},{"_id":"source/_posts/scoi2005-royal.md","shasum":"654ad9f1b238ea866ff1badedef6ad582903c1a7","modified":1483068824830},{"_id":"source/_posts/scoi2007-lizard.md","shasum":"bbe131ab41e3ad9d89f12e81969a7c251c3d358e","modified":1472910683260},{"_id":"source/_posts/scoi2007-repair.md","shasum":"e5cd2d95c22fd64d8f4362732d747292a4e17240","modified":1462959204450},{"_id":"source/_posts/scoi2009-cake.md","shasum":"8573193bdcfc4f2a85224fd1791b00d1b91af94e","modified":1478956661779},{"_id":"source/_posts/scoi2009-game.md","shasum":"dd4f8b3206e56636eb53b7507b3b7c8ba0994438","modified":1478998078148},{"_id":"source/_posts/scoi2009-paint.md","shasum":"6650628febe53de448522a2028b19752256ee9bb","modified":1477351841406},{"_id":"source/_posts/scoi2009-windy.md","shasum":"227dc0a7195a3a327f2e3f5788dee664da2a3d83","modified":1477351833902},{"_id":"source/_posts/scoi2010-game.md","shasum":"81be4ae0bb7c1120e220a5177bea4877d19780f3","modified":1462959204450},{"_id":"source/_posts/scoi2011-candy.md","shasum":"3037949e9f52b0faac3b2ca5b4d7f40e64147dad","modified":1462959204450},{"_id":"source/_posts/scoi2015-flag.md","shasum":"d2273c0aa7434ce104123d934eed5ebc76ce7874","modified":1462959204450},{"_id":"source/_posts/scoi2012-name.md","shasum":"56ed15710897916cb0855611a326acf53bc7bb96","modified":1475155718840},{"_id":"source/_posts/scoi2015-light.md","shasum":"6f50e8af86425d00844a560e71538656754f9f6f","modified":1477351887454},{"_id":"source/_posts/scoi2015-matrix.md","shasum":"81f28e7cad4caf2a53201684e2eebc1961e7e42e","modified":1462959204450},{"_id":"source/_posts/scoi2015-message.md","shasum":"eaba94296389b994b29a45744ad81674723c1e31","modified":1462959204450},{"_id":"source/_posts/scoi2015-password.md","shasum":"ba24fd5191837df620e52e49246f6481006b0610","modified":1462959204450},{"_id":"source/_posts/sdoi2008-cave.md","shasum":"0665e52de3f255cafac2bdc5b5c8f9ee23deee5c","modified":1462959204450},{"_id":"source/_posts/sdoi2008-interval.md","shasum":"6d7c73c685e299bcefb7bb93dd4efa340d1ac0c6","modified":1472823498227},{"_id":"source/_posts/sdoi2009-run.md","shasum":"239f7f7943172b90055db3a73dc898ba4a248a13","modified":1466511891867},{"_id":"source/_posts/sdoi2010-goblin.md","shasum":"88700569b1ba9e8abf8a695bd17b762252927cb3","modified":1466409035404},{"_id":"source/_posts/sdoi2010-starrace.md","shasum":"7cdfa2fbc6b5703175d491f81869e84382baf68c","modified":1462959204450},{"_id":"source/_posts/sdoi2011-calc.md","shasum":"8bc38c373e311a2ca92f3f7ce36654a436d31f21","modified":1465790863358},{"_id":"source/_posts/sdoi2013-rforest.md","shasum":"a16ac45bc3f7d66afd0d348d8c30f9c4776906e5","modified":1476869061064},{"_id":"source/_posts/sdoi2016-game/line.png","shasum":"30c24e553938d2c27b55779527825b2577088a7c","modified":1462955792590},{"_id":"source/_posts/sdoi2016-game/tree.png","shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86","modified":1462955792590},{"_id":"source/_posts/sdoi2014-journey.md","shasum":"2e11f80c5309333604309cd252acb87bcb39b70e","modified":1472823755641},{"_id":"source/_posts/sdoi2015-sequence.md","shasum":"2fe794b7d355bc493c80053ec8841812042c7acf","modified":1466170749686},{"_id":"source/_posts/sdoi2015-war.md","shasum":"4a6a234666ff45ea7c5069e6630519b646dac882","modified":1462959204460},{"_id":"source/_posts/sdoi2016-game.md","shasum":"f4688c431daa3a3b77b8ac3ec53c43f27ffb63de","modified":1462959204460},{"_id":"source/_posts/sdoi2016-incantation.md","shasum":"1152f86db800b686d790898d6b9193c7d8712bbe","modified":1462959204460},{"_id":"source/_posts/sdoi2016-journey.md","shasum":"9a67291ff2e3d19a6acb34043bd649423974380f","modified":1477351780335},{"_id":"source/_posts/sdoi2016-pair.md","shasum":"9a707c8f327534044dac4b013a285184edd7d349","modified":1462959204460},{"_id":"source/_posts/sdoi2016-permutation.md","shasum":"ac94de60fa9ed03ece26c466ef20698e935d6752","modified":1462959204460},{"_id":"source/_posts/sdoi2016-round1.md","shasum":"7e92ad517aff81a72afd6c6b393a7248ca7243d0","modified":1479656964533},{"_id":"source/_posts/sdoi2016-table.md","shasum":"4069652db069ab71e8a3b733a02022472201dad6","modified":1473486856729},{"_id":"source/_posts/shoi2007-tree.md","shasum":"408976b299bfef93fe74cfd816dc427929e313c2","modified":1466824073211},{"_id":"source/_posts/shoi2007-vote.md","shasum":"600f0630bbe939bdf9bbc2c5c7809382a204b070","modified":1466492665384},{"_id":"source/_posts/shoi2008-cactus.md","shasum":"865ec5c6af46e9aa3d97d2a0cf1871b06e2e5c85","modified":1477440165110},{"_id":"source/_posts/shoi2008-debt.md","shasum":"a270d590220f6e71746789e95b9d3acd767c82fe","modified":1476862555225},{"_id":"source/_posts/shoi2008-john.md","shasum":"49c7e0d140440d5228ceb897df0f2069fd83c12d","modified":1476863627059},{"_id":"source/_posts/shoi2008-traffic.md","shasum":"93cb98cb139e4fb449aa59256b5f6fee89ac2783","modified":1476858627266},{"_id":"source/_posts/splay-notes-1.md","shasum":"b16bea4ec04052dc118bc0ff0450825ee17f600c","modified":1482823752333},{"_id":"source/_posts/splay-notes-2.md","shasum":"b7c1615a96dfff66ea8c6337d06c966a9223f69e","modified":1462959204460},{"_id":"source/_posts/splay-notes-3.md","shasum":"c2bcc200273ea0ae8fdaccd19a253f1ea35b3fdf","modified":1482823760009},{"_id":"source/_posts/shoi2008-hannoi.md","shasum":"087cf760e04d33e7a17df8e17d40f105d28f287c","modified":1476861861733},{"_id":"source/_posts/splay-template.md","shasum":"b51720515a4e010b66a63b26b677fab25b9d5e62","modified":1483235099547},{"_id":"source/_posts/spoj-694.md","shasum":"4c02dff2a042a9c83e811f5f8536a361d53d798e","modified":1462959204460},{"_id":"source/_posts/stl-in-oi.md","shasum":"34b0cdda3523f9d31ebf2e404ddd59f27d146eaf","modified":1468498796795},{"_id":"source/_posts/system-of-difference-constraints-notes.md","shasum":"cda796649d3175c93146609b99ba4e753d04c995","modified":1462959204460},{"_id":"source/_posts/tarjan-bcc-notes.md","shasum":"126b12e82af1585be249327804f1e64777c063fe","modified":1483235108131},{"_id":"source/_posts/tarjan-cut-notes.md","shasum":"66e536a386baec6af66bf283422488d359b79810","modified":1483235120015},{"_id":"source/_posts/suffix-array-notes.md","shasum":"a14a772250ef5d85308f76c1d08deb2199a705a1","modified":1462959204460},{"_id":"source/_posts/tarjan-scc-notes.md","shasum":"6f64d3531832684226875728ab1bbc4b0995caa5","modified":1482286100826},{"_id":"source/_posts/the-ever-heart.md","shasum":"d47eba0859f7f36dc4052ee73e4d91d2ca9a5234","modified":1483160547733},{"_id":"source/_posts/tree-chain-split-notes/1.svg","shasum":"0cb9b692551b4a57c404a90123f7de48afb98f9a","modified":1482885237906},{"_id":"source/_posts/tjoi2013-lis.md","shasum":"85be6ae0b508baeb46540ffdd5ca250a522254ef","modified":1475883934938},{"_id":"source/_posts/tjoi2013-word.md","shasum":"03f1e85afbb5ba3e61596010715915b24de43fc8","modified":1475883942222},{"_id":"source/_posts/tjoi2015-chessboard.md","shasum":"4755bd1f5c721d893b8e31e3c8ce619ae45ea26f","modified":1477351756791},{"_id":"source/_posts/tree-chain-split-notes.md","shasum":"3364e054e39c199112cf81ca02fac0f5312d3878","modified":1483235130759},{"_id":"source/_posts/uva-10253.md","shasum":"af4062ce79c9b4f080fe3c35d3be71ef13d0b36d","modified":1462959204460},{"_id":"source/_posts/tyvj-3317.md","shasum":"229a79bbeb50f8efbcf84fea34aec24e3b27dccc","modified":1477351673532},{"_id":"source/_posts/uva-11021.md","shasum":"5c1c140b3d2a9dc0fa068195ae0ff3a51aaf3e4d","modified":1477351734763},{"_id":"source/_posts/uva-11375.md","shasum":"3ca8e6535aab2844777ae95ec8b8e10b2864f8f4","modified":1462959204460},{"_id":"source/_posts/uva-11538/cells.png","shasum":"3a162829c312a17639950c3620cd70799ed94a49","modified":1462955792600},{"_id":"source/_posts/uva-11137.md","shasum":"ab64769680e30fc5456f896dcd7413b5ec7474a2","modified":1477351709280},{"_id":"source/_posts/uva-11174.md","shasum":"343cb90133d9be62c263c27db889c0bf2945b918","modified":1462959204460},{"_id":"source/_posts/uva-11361.md","shasum":"4c2e014fa4d70f2eb75c75e8139fad18fe3c63d5","modified":1477351724619},{"_id":"source/_posts/uva-11538.md","shasum":"030938457fbe7ab2d5aec2148b7c03acfdf9513b","modified":1462959204460},{"_id":"source/_posts/uva-11806.md","shasum":"e7fe9a9f6f7bb8d32286243d4238f189b9d70734","modified":1462959204470},{"_id":"source/_posts/uva-1362.md","shasum":"6ed0875d87e133e428f77a35f3f4f075b29d3e37","modified":1477351694088},{"_id":"source/_posts/zjoi2004-swamp.md","shasum":"6a255e50f4f5448b3a92fe288954862926e5aa99","modified":1475881729487},{"_id":"source/_posts/virtualbox-archlinux.md","shasum":"920b51fe7f50d524a368c55db06a84cba0f3df1e","modified":1462959204470},{"_id":"source/_posts/zjoi2006-trans.md","shasum":"725146000e1f996a32a1e672e19cb60fc8d7c05f","modified":1464010935316},{"_id":"source/_posts/zjoi2007-chess.md","shasum":"5109dc27f895c80dda495b98392f2e9e51138dc4","modified":1481621022469},{"_id":"source/_posts/zjoi2007-semi.md","shasum":"34804692730f5a3da0032440deb294157e8f37e9","modified":1472946674898},{"_id":"source/_posts/zjoi2007-storage.md","shasum":"67989e9cadbec2172cf844d64d62fd421a57370e","modified":1477351684936},{"_id":"source/_posts/zjoi2008-antbuster.md","shasum":"31c4b1b566f5c4319586c929f4af12c72ea89a3d","modified":1464010030156},{"_id":"source/_posts/zjoi2008-bnb.md","shasum":"ac858ed7f59d732e10122e77ade78baa597169a1","modified":1479002028968},{"_id":"source/_posts/zjoi2008-party.md","shasum":"65c92b713af1a524097ff448a1df0ad004ebcc0b","modified":1479003183231},{"_id":"source/_posts/zjoi2009-ws.md","shasum":"a8570e70c6c8cbe1db3c9fcd61a57d73338e3305","modified":1466677416289},{"_id":"source/_posts/zjoi2014-force.md","shasum":"fc88dcd64579695a98932f026cacac9d956141d8","modified":1465695038354},{"_id":"source/about-me.md","shasum":"64fcf2735c0c1b62e25355489c4cf4fa6994a922","modified":1463747969758},{"_id":"source/friends.md","shasum":"1d4316c140821c23d82933c2cc4352c57ab61bcb","modified":1476539032349},{"_id":"source/_posts/zjoi2010-network.md","shasum":"48bcc635e268cf66d01d9c129388be804bcc8413","modified":1466470152142},{"_id":"source/images/zyz.png","shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5","modified":1483234068708},{"_id":"source/_posts/noip2014-bird.md","shasum":"76874bf8cf59797f6fd23a6c0dcfa3fc25d228c3","modified":1478606832691},{"_id":"source/_posts/noip2014-equation.md","shasum":"32741b3c9a8437f91b273e1ea4979fe4e6937319","modified":1476865586067},{"_id":"source/tags/index.md","shasum":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1473486143025},{"_id":"source/music/mzr/mzr.lrc","shasum":"25283ad79892beb5c83c43d981fdd32fbee30466","modified":1483160238246},{"_id":"source/_posts/geometry-notes/1.svg","shasum":"975b2287b4c1a2f034bd98d93b7676eb974103cc","modified":1483666174907},{"_id":"source/_posts/docker-sandbox-judger/image.svg","shasum":"6636e4b99b06e88091fecbf1f184ead8c7159475","modified":1481634563080},{"_id":"source/_posts/geometry-notes/2.svg","shasum":"a9e92363b3f901f6ebc2b9ca6316d42c038e0575","modified":1483668472683},{"_id":"source/_posts/geometry-notes/3.svg","shasum":"080c446dbf929c29e276207b0665f8a0dfd292ed","modified":1483670049915},{"_id":"source/_posts/geometry-notes/4.svg","shasum":"daa7364dd8c0c14481807f25ae5f051f31552a7f","modified":1483670736855},{"_id":"source/_posts/geometry-notes/5.svg","shasum":"5f407ad7db6976704949a6a62783f8c86e304e0c","modified":1483672867806},{"_id":"source/_posts/geometry-notes/6.svg","shasum":"c90aeef41c91b50d5e65019f0f686a617859af7f","modified":1483684733585},{"_id":"source/_posts/noi2008-candy/3.svg","shasum":"b23b45b08ec89efce951bb74993a3552785b2fb6","modified":1482480485177},{"_id":"source/_posts/noi2008-candy/4.svg","shasum":"f43da416f15c7ff2e1561e1a3bac7394a9a054fd","modified":1482481865556},{"_id":"source/_posts/noi2008-candy/6.svg","shasum":"4a8fc6c8636aa2eb311e7c4c87a5a165d7f4ea38","modified":1482484174887},{"_id":"source/_posts/noi2008-candy/7.svg","shasum":"249b838061bf13e3da200bd47bb42bd83c594799","modified":1482484231342},{"_id":"source/_posts/noi2008-candy/5.svg","shasum":"faf0ef012b9602fc7d191eefb46096c6703ed3c3","modified":1482482996268},{"_id":"source/_posts/virtualbox-archlinux/port.png","shasum":"bb684dd8b616413e3e0e27c5efce118249a54113","modified":1462955792600},{"_id":"themes/vno/LICENSE","shasum":"8c84b7a07cef17ed42b549a47eefd71bb97ae698","modified":1482498872106},{"_id":"themes/vno/README.md","shasum":"91538bc2b7ae1d0d8d8046020a5cee7fc8b7b087","modified":1482498872106},{"_id":"themes/vno/_config.yml","shasum":"a502619f85676ebdc941b355f55fd890e903c9fe","modified":1482544263701},{"_id":"themes/vno/layout/_partial/baidu_tongji.ejs","shasum":"95884538b96d25aa73856e2f064832eec09810bd","modified":1482498872106},{"_id":"themes/vno/layout/_partial/comments.ejs","shasum":"d7c4951e8ce9e03314cd809c4611f2637d12589b","modified":1482501390480},{"_id":"themes/vno/layout/_partial/date.ejs","shasum":"7acd28543c62c6a4cdd9a3e49bd1fb77f0e9ab78","modified":1482498872106},{"_id":"themes/vno/layout/_partial/footer.ejs","shasum":"3c4ea282363f11fe290e28708a6695416a46bd04","modified":1482502042236},{"_id":"themes/vno/layout/_partial/google_analytics.ejs","shasum":"eddc6b239bf82409856431d8f0bb5ad8d52ab464","modified":1482498872106},{"_id":"themes/vno/layout/_partial/head.ejs","shasum":"d3359c076ca17347dff55a7338843b6b1eb81002","modified":1483160415238},{"_id":"themes/vno/layout/_partial/read-more.ejs","shasum":"05d8dc3a01f8683d61127c73bf20ecb00aeacf33","modified":1483161088773},{"_id":"themes/vno/layout/_partial/search.ejs","shasum":"3ad5a4803ad303a9fe7e1575b05953cf5c2dd071","modified":1482545066731},{"_id":"themes/vno/layout/_partial/side-panel.ejs","shasum":"132dcac09cd07c75e43c8bd7e20830515c7a716a","modified":1482581529877},{"_id":"themes/vno/layout/_partial/social.ejs","shasum":"f323157fa9460cb0ec16a1e79ce3e5b6fd6f74bf","modified":1482544016110},{"_id":"themes/vno/layout/_partial/tags.ejs","shasum":"ffcc2844bf1fae8a766e807c316129774bd4ad43","modified":1482498872106},{"_id":"themes/vno/layout/index.ejs","shasum":"e9fb32f778c61145bb1d79fabc9649f876b9bac1","modified":1482499895830},{"_id":"themes/vno/layout/layout.ejs","shasum":"8786e69cf8d5b1b0eadb4637ff908d5ee89e41e9","modified":1482502057561},{"_id":"themes/vno/layout/page.ejs","shasum":"1953ea9eb7c6cb55b137b7d18c5a374f7489d333","modified":1482498872106},{"_id":"themes/vno/layout/post.ejs","shasum":"611286b31e724d59dbbc9723e034b55e3f392f83","modified":1482498872106},{"_id":"themes/vno/source/css/_partial/highlight.styl","shasum":"36eefe6332b86b66023a9884b754d305235846b4","modified":1482498872106},{"_id":"themes/vno/source/css/_variables.styl","shasum":"8d7e3e75cf2e2806ba2aacde9ef9c3626929e3e2","modified":1482498872106},{"_id":"themes/vno/source/css/_animate.styl","shasum":"a2f854fbdc52a5657dd5e2b95cc96c0da32f3ea2","modified":1482498872106},{"_id":"themes/vno/source/css/search.styl","shasum":"b7e15b4f28f46ff39b1bdbc7ed960135094c0cfd","modified":1482544454789},{"_id":"themes/vno/source/css/tomorrow.css","shasum":"5d7e34a8cf77a0e2ec66ce04139da68026fca564","modified":1482500054623},{"_id":"themes/vno/source/css/vno.styl","shasum":"ea3c987f04cd6cb96fe623d6fbc6e5875ecb31eb","modified":1483685870326},{"_id":"themes/vno/source/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1482498872106},{"_id":"themes/vno/source/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1482498872106},{"_id":"source/music/mzr/mzr.jpg","shasum":"501f497a8efb64ab462205f7e287e6082e31edb1","modified":1483160238246},{"_id":"themes/vno/source/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1482498872110},{"_id":"themes/vno/source/js/APlayer.min.js","shasum":"5d040dc50af42fec45538a10a7f826e739935278","modified":1482543668791},{"_id":"themes/vno/source/js/insight.js","shasum":"5c5a7ae896ea82682fab0c15405b0880bfa34eca","modified":1482544937012},{"_id":"themes/vno/source/js/main.js","shasum":"43e748aeb132037e27b27d8d1279a4b838d97b38","modified":1482498872118},{"_id":"themes/vno/source/js/embed.js","shasum":"6738e9ee67e520f907e337253beca62c8f0544f7","modified":1482498872118},{"_id":"source/_posts/bzoj-3196/lemon.png","shasum":"e62be8509a73535096deea0debc3c04ca6c39445","modified":1483340682862},{"_id":"themes/vno/source/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1482498872110},{"_id":"themes/vno/source/images/show/google-analytics.jpeg","shasum":"b10396a3162402ea2ff4b42b7b44b518450466e6","modified":1482498872114},{"_id":"themes/vno/source/images/background-cover.jpg","shasum":"0b04e9bf7e89377952702a0be54569596770f49c","modified":1482498872110},{"_id":"themes/vno/source/images/show/article.jpeg","shasum":"1156f794ea83eae2e5fa485ee5bd3b5b314c957a","modified":1482498872114},{"_id":"themes/vno/source/images/show/baidu_tongji.jpeg","shasum":"76ecad909b266c2c557daaff1f65f7e6ec2135d5","modified":1482498872114},{"_id":"source/_posts/virtualbox-archlinux/share.png","shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8","modified":1462955792610},{"_id":"themes/vno/source/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1482498872110},{"_id":"source/_posts/splay-notes-1/splay.png","shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13","modified":1462955792590},{"_id":"themes/vno/source/images/show/list.jpeg","shasum":"a49bee3ced7097084cee0b6cd67c935d3cb086ef","modified":1482498872118},{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426","modified":1462955792600},{"_id":"source/_posts/virtualbox-archlinux/network.png","shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2","modified":1462955792600},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426","modified":1462955792610},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d","modified":1462955792610},{"_id":"source/_posts/here-the-best-sight/2.jpg","shasum":"b557d0ca16ee0595cbd2731d629828e98fd9af7b","modified":1483311790395},{"_id":"themes/vno/source/images/avatar.png","shasum":"c85cb21d1859376a4178d0e5124a441345dd2ebd","modified":1482500250158},{"_id":"source/_posts/here-the-best-sight/3.jpg","shasum":"a00028f85e592bdae7f485279a7bca5c385c394d","modified":1483311812736},{"_id":"source/_posts/here-the-best-sight/1.jpg","shasum":"97aca77cc57d470bae56c2c8199a86af57b1c010","modified":1483311789311},{"_id":"themes/vno/source/images/show/home.png","shasum":"90bd2baeb8dfcfd9542cd689766d2bc88ef95ca1","modified":1482498872118},{"_id":"source/music/mzr/mzr.ogg","shasum":"44bf915b81c4f93e626182f05442af6ff7a95f52","modified":1483160238262},{"_id":"public/js/main.js","modified":1483685905903,"shasum":"43e748aeb132037e27b27d8d1279a4b838d97b38"},{"_id":"public/js/insight.js","modified":1483685905926,"shasum":"5c5a7ae896ea82682fab0c15405b0880bfa34eca"},{"_id":"public/js/embed.js","modified":1483685905930,"shasum":"6738e9ee67e520f907e337253beca62c8f0544f7"},{"_id":"public/js/APlayer.min.js","modified":1483685905932,"shasum":"5d040dc50af42fec45538a10a7f826e739935278"},{"_id":"public/images/show/list.jpeg","modified":1483685905941,"shasum":"a49bee3ced7097084cee0b6cd67c935d3cb086ef"},{"_id":"public/images/show/home.png","modified":1483685905949,"shasum":"90bd2baeb8dfcfd9542cd689766d2bc88ef95ca1"},{"_id":"public/images/show/google-analytics.jpeg","modified":1483685905961,"shasum":"b10396a3162402ea2ff4b42b7b44b518450466e6"},{"_id":"public/images/show/baidu_tongji.jpeg","modified":1483685905969,"shasum":"76ecad909b266c2c557daaff1f65f7e6ec2135d5"},{"_id":"public/images/show/article.jpeg","modified":1483685905979,"shasum":"1156f794ea83eae2e5fa485ee5bd3b5b314c957a"},{"_id":"public/images/background-cover.jpg","modified":1483685905998,"shasum":"0b04e9bf7e89377952702a0be54569596770f49c"},{"_id":"public/images/avatar.png","modified":1483685906011,"shasum":"c85cb21d1859376a4178d0e5124a441345dd2ebd"},{"_id":"public/fonts/fontawesome-webfont.woff","modified":1483685906019,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/fonts/fontawesome-webfont.ttf","modified":1483685906022,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/fonts/fontawesome-webfont.svg","modified":1483685906035,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/fonts/fontawesome-webfont.eot","modified":1483685906038,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/fonts/FontAwesome.otf","modified":1483685906044,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/css/vno.css","modified":1483685906855,"shasum":"7958cc03fd844d7f696c965e57c3ab93e687871d"},{"_id":"public/css/tomorrow.css","modified":1483685907028,"shasum":"5d7e34a8cf77a0e2ec66ce04139da68026fca564"},{"_id":"public/css/search.css","modified":1483685907066,"shasum":"ad0ccc87abd4fccb83275745cc9eff3d8a9fc508"},{"_id":"public/music/mzr/mzr.ogg","modified":1483685907095,"shasum":"44bf915b81c4f93e626182f05442af6ff7a95f52"},{"_id":"public/music/mzr/mzr.lrc","modified":1483685907109,"shasum":"25283ad79892beb5c83c43d981fdd32fbee30466"},{"_id":"public/music/mzr/mzr.jpg","modified":1483685907111,"shasum":"501f497a8efb64ab462205f7e287e6082e31edb1"},{"_id":"public/images/zyz.png","modified":1483685907113,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"public/virtualbox-archlinux/hotkey.png","modified":1483685907115,"shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426"},{"_id":"public/virtualbox-archlinux/network.png","modified":1483685907119,"shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2"},{"_id":"public/virtualbox-archlinux/port.png","modified":1483685907122,"shasum":"bb684dd8b616413e3e0e27c5efce118249a54113"},{"_id":"public/virtualbox-archlinux/screenfetch.png","modified":1483685907147,"shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d"},{"_id":"public/virtualbox-archlinux/share.png","modified":1483685907154,"shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8"},{"_id":"public/virtualbox-archlinux/terminal.png","modified":1483685907157,"shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426"},{"_id":"public/uva-11538/cells.png","modified":1483685907163,"shasum":"3a162829c312a17639950c3620cd70799ed94a49"},{"_id":"public/tree-chain-split-notes/1.svg","modified":1483685907165,"shasum":"0cb9b692551b4a57c404a90123f7de48afb98f9a"},{"_id":"public/splay-notes-1/splay.png","modified":1483685907171,"shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13"},{"_id":"public/sdoi2016-game/line.png","modified":1483685907180,"shasum":"30c24e553938d2c27b55779527825b2577088a7c"},{"_id":"public/sdoi2016-game/tree.png","modified":1483685907182,"shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86"},{"_id":"public/noip2016-running/linear-backward1.svg","modified":1483685907183,"shasum":"f11ad00d6b6d9c4a9dbcdd756a54ac9f98aae87c"},{"_id":"public/noip2016-running/linear-forward1.svg","modified":1483685907186,"shasum":"21d1e9f4c290ba36e95ca3d1a3f03108f7e7d08c"},{"_id":"public/noip2016-running/linear-forward2.svg","modified":1483685907188,"shasum":"d828849ead2a7f7a3ac34250ec3e468dd053fe4c"},{"_id":"public/noi2008-candy/1.svg","modified":1483685907191,"shasum":"487bedd4ee907b6af27bc2dff608d7084da67f46"},{"_id":"public/noi2008-candy/2.ggb","modified":1483685907195,"shasum":"b72de255a5a79e92a5a220da592cc30818579ca7"},{"_id":"public/noi2008-candy/2.svg","modified":1483685907197,"shasum":"84a22ca72f6e0ff90dfce05b56f44e7ab66f3cc9"},{"_id":"public/noi2008-candy/3.ggb","modified":1483685907204,"shasum":"7155350e293077d4fd36bd65715ea693ed339c80"},{"_id":"public/noi2008-candy/3.svg","modified":1483685907207,"shasum":"b23b45b08ec89efce951bb74993a3552785b2fb6"},{"_id":"public/noi2008-candy/4.ggb","modified":1483685907210,"shasum":"0c851a79d13d36a0bc06c1360ec5ca3b48e301a2"},{"_id":"public/noi2008-candy/4.svg","modified":1483685907211,"shasum":"f43da416f15c7ff2e1561e1a3bac7394a9a054fd"},{"_id":"public/noi2008-candy/5.ggb","modified":1483685907212,"shasum":"e80d5ff3511748769937e358ca9f213db78a3adc"},{"_id":"public/noi2008-candy/5.svg","modified":1483685907213,"shasum":"faf0ef012b9602fc7d191eefb46096c6703ed3c3"},{"_id":"public/noi2008-candy/6.ggb","modified":1483685907214,"shasum":"b968f70e6224debb5e16b9ea4a1e39ebc2de4834"},{"_id":"public/noi2008-candy/6.svg","modified":1483685907216,"shasum":"4a8fc6c8636aa2eb311e7c4c87a5a165d7f4ea38"},{"_id":"public/noi2008-candy/7.ggb","modified":1483685907217,"shasum":"fbf0ec7e19ee13b534e9aa66ded3170ec449261e"},{"_id":"public/noi2008-candy/7.svg","modified":1483685907219,"shasum":"249b838061bf13e3da200bd47bb42bd83c594799"},{"_id":"public/node-devide-notes/tree1.svg","modified":1483685907220,"shasum":"4de32d5e3b22eb531886d0f9f475f2a9982ee471"},{"_id":"public/node-devide-notes/tree2.svg","modified":1483685907225,"shasum":"407c61fdd3d63b87c5678d80c9b6213781d2cb1f"},{"_id":"public/manacher-notes/1.svg","modified":1483685907228,"shasum":"689f9a1a16fa6bebbe71921fe95a95791af6d03a"},{"_id":"public/manacher-notes/2.svg","modified":1483685907229,"shasum":"9846f2acbe071d16813087471c83561141070942"},{"_id":"public/manacher-notes/3.svg","modified":1483685907231,"shasum":"2c61c2f78699f473f9c9758f7ed9fe4984ee1b97"},{"_id":"public/here-the-best-sight/1.jpg","modified":1483685907241,"shasum":"97aca77cc57d470bae56c2c8199a86af57b1c010"},{"_id":"public/here-the-best-sight/2.jpg","modified":1483685907251,"shasum":"b557d0ca16ee0595cbd2731d629828e98fd9af7b"},{"_id":"public/here-the-best-sight/3.jpg","modified":1483685907262,"shasum":"a00028f85e592bdae7f485279a7bca5c385c394d"},{"_id":"public/haoi2006-sequence/1.svg","modified":1483685907266,"shasum":"0337ba40ba7e2733cc657b79636f5f06e5f7c9a3"},{"_id":"public/haoi2006-sequence/2.svg","modified":1483685907269,"shasum":"57a7cee258306ed3073e46a9e0e79f6485c8f100"},{"_id":"public/geometry-notes/1.ggb","modified":1483685907271,"shasum":"4e6d9a8a63ed9c440f40708c3d25a8b78eda515d"},{"_id":"public/geometry-notes/1.svg","modified":1483685907281,"shasum":"975b2287b4c1a2f034bd98d93b7676eb974103cc"},{"_id":"public/geometry-notes/2.ggb","modified":1483685907282,"shasum":"661074f4858099ec573c4f9b145331bf3a0220f0"},{"_id":"public/geometry-notes/2.svg","modified":1483685907284,"shasum":"a9e92363b3f901f6ebc2b9ca6316d42c038e0575"},{"_id":"public/geometry-notes/3.ggb","modified":1483685907285,"shasum":"0463664a0f02fc6736b06b234b660eb85e33c9e8"},{"_id":"public/geometry-notes/3.svg","modified":1483685907289,"shasum":"080c446dbf929c29e276207b0665f8a0dfd292ed"},{"_id":"public/geometry-notes/4.ggb","modified":1483685907297,"shasum":"e83654c63399e2af73b4d567a62ab55419c3b1d1"},{"_id":"public/geometry-notes/4.svg","modified":1483685907298,"shasum":"daa7364dd8c0c14481807f25ae5f051f31552a7f"},{"_id":"public/geometry-notes/5.ggb","modified":1483685907299,"shasum":"6c347a3c0dd1ef65cf4671cfefe6c8e4c9ec3c65"},{"_id":"public/geometry-notes/5.svg","modified":1483685907308,"shasum":"5f407ad7db6976704949a6a62783f8c86e304e0c"},{"_id":"public/geometry-notes/6.ggb","modified":1483692227135,"shasum":"4f8d2e7c8949a912625f9d6dfb1e375d6dbda0c9"},{"_id":"public/geometry-notes/6.svg","modified":1483685907315,"shasum":"c90aeef41c91b50d5e65019f0f686a617859af7f"},{"_id":"public/docker-sandbox-judger/image.svg","modified":1483685907317,"shasum":"6636e4b99b06e88091fecbf1f184ead8c7159475"},{"_id":"public/cf-716e/example.svg","modified":1483685907328,"shasum":"a1d6731f2ef7e43ae48e27345954c6cb24a216b0"},{"_id":"public/bzoj-3196/lemon.png","modified":1483685907331,"shasum":"e62be8509a73535096deea0debc3c04ca6c39445"},{"_id":"public/bzoj-2683/cdq.png","modified":1483685907335,"shasum":"a95d0b02b915f092df6656298add0f0fc9662341"},{"_id":"public/at-the-cross-of-time/mzr.lrc","modified":1483685907336,"shasum":"25283ad79892beb5c83c43d981fdd32fbee30466"},{"_id":"public/acam-notes/acam.svg","modified":1483685907338,"shasum":"443fe0f8ed15e6b9ef1aadeadef650b8ff57e031"},{"_id":"public/acam-notes/acam2.svg","modified":1483685907339,"shasum":"02f0702387bd40ee0980ea1da05b2eff5fd05ec8"},{"_id":"public/tags/index.html","modified":1483685907431,"shasum":"410b3ecf410fcc7ffca30836a378b80679730b02"},{"_id":"public/friends/index.html","modified":1483685907454,"shasum":"0540d625163c7f61deee5d60903ba56318da704b"},{"_id":"public/about-me/index.html","modified":1483685907488,"shasum":"868406c808128b3842553d53eab276ed589be081"},{"_id":"public/geometry-notes/index.html","modified":1483692227720,"shasum":"3ffa7f9d68e57efc15ef49c3537477f697cc868f"},{"_id":"public/apio2012-dispatching/index.html","modified":1483692227792,"shasum":"b8425f24d5b747dd276c72dc7ef6daaabdd07b30"},{"_id":"public/manacher-notes/index.html","modified":1483685907752,"shasum":"695c7100f043ceea76a7a8a3f7e76b2c3f84d9e2"},{"_id":"public/bzoj-2565/index.html","modified":1483685907815,"shasum":"ca9ddcade0b1f3a52285690839180fadc71044a1"},{"_id":"public/poj-3630/index.html","modified":1483685907844,"shasum":"2d026ea11f39f93b824d8c3b32ca32c1072e4169"},{"_id":"public/here-the-best-sight/index.html","modified":1483685907893,"shasum":"4b3c55a70bc136c6d95395bb3cd9c82520d640a3"},{"_id":"public/euler-circuit-notes/index.html","modified":1483685907946,"shasum":"d4f44df264e6e8c99eb8cbd75349f472e9a5d8ca"},{"_id":"public/bzoj-1718/index.html","modified":1483685907995,"shasum":"854eede5328136d411efb917b4266a067acaf85f"},{"_id":"public/tarjan-bcc-notes/index.html","modified":1483685908029,"shasum":"0b28c0da25868c992b52935cce58054f6a413edb"},{"_id":"public/the-ever-heart/index.html","modified":1483685908075,"shasum":"6cb16381efb42d52cdaf08668e34d32a0ad293b0"},{"_id":"public/scoi2005-royal/index.html","modified":1483685908115,"shasum":"982161e897c1b5a119b4351881f175f3e2f5e992"},{"_id":"public/ahoi2013-homework/index.html","modified":1483685908170,"shasum":"741a09539f9fe922307f4f3a234d5926496842c7"},{"_id":"public/bzoj-3289/index.html","modified":1483685908224,"shasum":"0fcca4eba15f1e2aafaea8008193266cc3b96731"},{"_id":"public/bzoj-2120/index.html","modified":1483685908274,"shasum":"9604662b888b2951ff70368c93ebde8eeb7de4ac"},{"_id":"public/rmq-template/index.html","modified":1483685908316,"shasum":"6a293f7e1e1e35077d47a901b09deb1542ac22d9"},{"_id":"public/splay-template/index.html","modified":1483685908377,"shasum":"d4aa9d1e9958e9cf2bb5d6f990c1154028b3e3d5"},{"_id":"public/noi2008-candy/index.html","modified":1483685908476,"shasum":"c9c11c93ca13412b115e880f204ca4748f1ce319"},{"_id":"public/docker-sandbox-judger/index.html","modified":1483685908499,"shasum":"dee22cba80deef5266b4e48570273b1c4b8ddf7b"},{"_id":"public/zjoi2007-chess/index.html","modified":1483685908561,"shasum":"408abd5b21865a333db9f788f0ec2ee29a9cb818"},{"_id":"public/haoi2008-rank/index.html","modified":1483685908613,"shasum":"6758c4accf028ed78fd2dcf3a6f1dc6fe6f88975"},{"_id":"public/haoi2008-move/index.html","modified":1483685908665,"shasum":"ba1c2bf85369c8b8253a1f602b83c4d0e362e6cc"},{"_id":"public/haoi2007-ant/index.html","modified":1483685908714,"shasum":"03422b1d629d950adcb264c6db98a21ad6800569"},{"_id":"public/haoi2007-cover/index.html","modified":1483685908759,"shasum":"7386aacc93dbb96abf7f78780f3d6345d2956f9b"},{"_id":"public/haoi2006-sequence/index.html","modified":1483685908834,"shasum":"65512e223619df0bbd490eac3b2504f6b49709db"},{"_id":"public/haoi2007-separation/index.html","modified":1483685908917,"shasum":"a39aab260cf6b767e9e73fee8a86dcad02175896"},{"_id":"public/haoi2007-square/index.html","modified":1483685908976,"shasum":"21dbd3a0659c6be6f2a1d4b5d356b0d2f629a554"},{"_id":"public/haoi2007-lis/index.html","modified":1483685909039,"shasum":"f6fc31b1a91db079fd90ca898005db94ef168f4e"},{"_id":"public/noip2016-angrybirds/index.html","modified":1483685909092,"shasum":"ff75d2de86dc8eff7c3fbd757c8d0210d961d409"},{"_id":"public/noip2016-earthworm/index.html","modified":1483685909150,"shasum":"d75aa75b6c8f0059b63a3d97039d85f9d3a725a7"},{"_id":"public/noip2016-problem/index.html","modified":1483685909201,"shasum":"6f37214a74ce1d16e1cf280a7a163d544db595fc"},{"_id":"public/noip2016-classroom/index.html","modified":1483685909273,"shasum":"fda5186b7ce8f9820d3dacc08bff6c6f5ab9d368"},{"_id":"public/noip2016-running/index.html","modified":1483685909375,"shasum":"3a28034db15237c0c207a0f54983d2d3a807e023"},{"_id":"public/noip2016-toy/index.html","modified":1483685909406,"shasum":"3e616b230e4054ab6672e57dc15234667c282205"},{"_id":"public/noip2016/index.html","modified":1483685909458,"shasum":"7ece4905815519bf7bd65db282416b51311fbbf9"},{"_id":"public/noip2012-blockade/index.html","modified":1483685909530,"shasum":"da97ad615673897e1e01f71fc4a545ebb53ba0ec"},{"_id":"public/noip2010-flow/index.html","modified":1483685909581,"shasum":"731b241c1b8b512d874aa57a75b622f324d6ea9f"},{"_id":"public/noip2012-drive/index.html","modified":1483685909656,"shasum":"8988bb225181c6b51d4a5fe1eae07c25e5a6d4a5"},{"_id":"public/noip2013-puzzle/index.html","modified":1483685909729,"shasum":"9ab0065cdc52942b010110d998033904971aebf4"},{"_id":"public/haoi2008-candy/index.html","modified":1483685909790,"shasum":"c877efdc61b6cb337afe702e2df9df0ebbbab633"},{"_id":"public/haoi2008-stick/index.html","modified":1483685909861,"shasum":"b00d4b9741170eaa1a6e700d796d16c73d58c40c"},{"_id":"public/haoi2008-coins/index.html","modified":1483685909913,"shasum":"f7f76c3c3db28e6a2fc47bcd698ebe16de89319d"},{"_id":"public/haoi2008-cir/index.html","modified":1483685909971,"shasum":"7392ced8b6af84b08ecc3a5faf516b0c7bc315b8"},{"_id":"public/zjoi2008-party/index.html","modified":1483685910004,"shasum":"4c4f8df892c348cab3171245aec3227b025bb748"},{"_id":"public/zjoi2008-bnb/index.html","modified":1483685910047,"shasum":"3e89e11bc1a9fd86bd3942ad6371c8a502d812c6"},{"_id":"public/jsoi2007-repair/index.html","modified":1483685910095,"shasum":"70c124070713dafee1f5d094282dac64c42a3d9c"},{"_id":"public/jsoi2007-mahjong/index.html","modified":1483685910142,"shasum":"9791f5ea69ed2f19ce3093639141801d5de518c2"},{"_id":"public/scoi2009-game/index.html","modified":1483685910201,"shasum":"1b98a6aca871b3d492227bf557fb8d99950bcb12"},{"_id":"public/scoi2009-cake/index.html","modified":1483685910258,"shasum":"397166f34576d41da11b6f68cdd1d02b7c7d5995"},{"_id":"public/shoi2008-cactus/index.html","modified":1483685910321,"shasum":"02ff778f519962728ed828c9f9d1db46a15b9941"},{"_id":"public/ioi2008-island/index.html","modified":1483685910418,"shasum":"6ed50adb26a69e14a369342a398f875af57d2e14"},{"_id":"public/noip2015-transport/index.html","modified":1483685910487,"shasum":"23d8c5a39141a34e5f6d5ef8ee588e145ad99cba"},{"_id":"public/noip2015-substring/index.html","modified":1483685910535,"shasum":"27186de46e75a0370338c692ab39ca99a30f1792"},{"_id":"public/noip2015-landlords/index.html","modified":1483685910611,"shasum":"7ca1178ddb8ec7bea6a7a2946b331a95bca8e15e"},{"_id":"public/noip2014-equation/index.html","modified":1483685910669,"shasum":"821162e63092de24136885ffb323edb064ca6933"},{"_id":"public/shoi2008-john/index.html","modified":1483685910713,"shasum":"e572b6862ae091b5cd3d20694db70250cb95a11e"},{"_id":"public/shoi2008-debt/index.html","modified":1483685910777,"shasum":"0dfdcd74c54c71ed18fc4816aa494c335bd05863"},{"_id":"public/shoi2008-hannoi/index.html","modified":1483685910838,"shasum":"e26d8ffbc2697b75c458dce4737d52bd951a13ab"},{"_id":"public/shoi2008-traffic/index.html","modified":1483685910900,"shasum":"311050117846dc94585bbafdae963465e95eab1d"},{"_id":"public/jsoi2008-award/index.html","modified":1483685910980,"shasum":"e839a59dc384be93329620f08e27634eecabdbbd"},{"_id":"public/jsoi2008-starwar/index.html","modified":1483685911028,"shasum":"7c785540d04bbabddc8bd8bc75ee9849f2474a64"},{"_id":"public/jsoi2008-prefix/index.html","modified":1483685911088,"shasum":"3453943359bfe9cd84daff7b617705eedd3211ec"},{"_id":"public/hnoi2008-kingdom/index.html","modified":1483685911127,"shasum":"fd14385fd5eb21cdf748bf1fae48afc27db751f2"},{"_id":"public/hnoi2008-cards/index.html","modified":1483685911175,"shasum":"da7d42bf823cdcfb4ed6989dc16f151761efdb11"},{"_id":"public/fjoi2007-wheel/index.html","modified":1483685911229,"shasum":"5a9e88d739f97d287b79f5585a92725698375922"},{"_id":"public/noip2013-flower/index.html","modified":1483685911276,"shasum":"b6471ecaa64a946ebb8aabecb18330eb313dae21"},{"_id":"public/noip2013-match/index.html","modified":1483685911333,"shasum":"669dbfec3d748ea2bb1c5204f3336e7765492383"},{"_id":"public/hnoi2008-tree/index.html","modified":1483685911386,"shasum":"a48cb814ffa31d3d2f2e4c0167e357b6e21d9185"},{"_id":"public/noip2014-bird/index.html","modified":1483685911460,"shasum":"510956965dd852543ab4b720f2e7e90c1c80e917"},{"_id":"public/noip2012-classrooms/index.html","modified":1483685911515,"shasum":"e1427f64e0b394aac304a08385e087051823e710"},{"_id":"public/tjoi2015-chessboard/index.html","modified":1483685911576,"shasum":"1c6f0509020dc8ccb84464d915ca8d768d9ad79b"},{"_id":"public/noi2012-random/index.html","modified":1483685911623,"shasum":"d5d9a2eef40b72e4691c0ebfda69177af357298a"},{"_id":"public/bzoj-1706/index.html","modified":1483685911678,"shasum":"f2bbbd17d958906b943664e71b90043dc9d895af"},{"_id":"public/zjoi2004-swamp/index.html","modified":1483685911734,"shasum":"e07a850f405d1bc23acaf04a4b0695937d5848ca"},{"_id":"public/hnoi2008-gt/index.html","modified":1483685911776,"shasum":"6b4d8919954962838f28f3a8a46e2e4527a6d5b0"},{"_id":"public/hdu-5906/index.html","modified":1483685911860,"shasum":"344cf7bdf2f4660673324af8eba2c398d077d98c"},{"_id":"public/bzoj-3796/index.html","modified":1483685911950,"shasum":"23645533c048c4befa83a0d3f6cdc15328c17c93"},{"_id":"public/bzoj-3277/index.html","modified":1483685912027,"shasum":"4bfbb79d8cafad29f08896211dbf35789968bf14"},{"_id":"public/bzoj-3230/index.html","modified":1483685912095,"shasum":"b2346aa764307adbcaa24cc2603b19d6f9870ba9"},{"_id":"public/bzoj-1692/index.html","modified":1483685912159,"shasum":"b6a180c27a1c13ca59113ce06bab97792e8e7a71"},{"_id":"public/scoi2012-name/index.html","modified":1483685912224,"shasum":"61eea3e4a4172c28877e34b674f677f2da4ee7cf"},{"_id":"public/ahoi2013-diff/index.html","modified":1483685912286,"shasum":"68d05a1e943963089f870ee16754b77ca92a0c13"},{"_id":"public/jsoi2007-cipher/index.html","modified":1483685912340,"shasum":"3962779e8401057b1607ea2aa9d1ff3536be76b9"},{"_id":"public/cf-716e/index.html","modified":1483685912403,"shasum":"9fe375e3769864017c19f7cab3a850dde49a5aa9"},{"_id":"public/acam-notes/index.html","modified":1483685912475,"shasum":"7aad9f8cffcd49fde6659cda1638a5ede9800956"},{"_id":"public/jsoi2009-game2/index.html","modified":1483685912560,"shasum":"4c38f3157cfcfb0251bfb3ae792a42c551501ae5"},{"_id":"public/bzoj-3881/index.html","modified":1483685912622,"shasum":"da8bc96479702f0942761a8a82e95b55d64a0f96"},{"_id":"public/bzoj-2580/index.html","modified":1483685912684,"shasum":"35fee2ce2ed10b1ce628f70474a5f4cb69307072"},{"_id":"public/bzoj-3940/index.html","modified":1483685912728,"shasum":"e743095619a3c5a42b4130812b5b973707433b08"},{"_id":"public/bzoj-2462/index.html","modified":1483685912785,"shasum":"56f9f57d3dc333af2aa936391fbed43db0ef7517"},{"_id":"public/poi2000-wir/index.html","modified":1483685912832,"shasum":"360831de33dfe9dd93e37a63aa19e23603e511a7"},{"_id":"public/hnoi2004-language/index.html","modified":1483685912882,"shasum":"058bfd7bb6d4b46bfb56d52de687ffb5399f3bfd"},{"_id":"public/noi2011-type/index.html","modified":1483685912942,"shasum":"f825d8e8c9c443fb1cc77b961d9acf72fb623c88"},{"_id":"public/jsoi2007-generator/index.html","modified":1483685913013,"shasum":"27f42fe7ee59e6ad0572ee8d9bd7938a41c5af43"},{"_id":"public/tjoi2013-word/index.html","modified":1483685913066,"shasum":"f0486330abf5cd70b46d0183a571be48bd8eeb28"},{"_id":"public/tarjan-cut-notes/index.html","modified":1483685913135,"shasum":"883c7ec67954462db84d0c98490ac63ea24f517b"},{"_id":"public/noi2016-grid/index.html","modified":1483685913215,"shasum":"802085464f26b9c300180e04ea4fb27f7ebf04b7"},{"_id":"public/poi2008-blo/index.html","modified":1483685913279,"shasum":"dfef5d98a7b6d23a87573c641f71290bea68e39b"},{"_id":"public/hnoi2012-mine/index.html","modified":1483685913333,"shasum":"bcade75ca60c06276d47f05e11d2e950a2f05512"},{"_id":"public/noi2016-excellent/index.html","modified":1483685913391,"shasum":"657b57eb3b8b3b4074831dcc82b5f5f9b515208f"},{"_id":"public/noi2016-interval/index.html","modified":1483685913444,"shasum":"4fc06624ff43cb889160b0479762a72d9dcb2696"},{"_id":"public/sdoi2013-rforest/index.html","modified":1483685913521,"shasum":"85a90ba531c861e1237b2571bec1f3db1cd9ea8e"},{"_id":"public/zjoi2007-semi/index.html","modified":1483685913605,"shasum":"f077564aaa0dd862a317d113868142e8ff85c5cf"},{"_id":"public/bzoj-3280/index.html","modified":1483685913662,"shasum":"b133c4c1ef181ec6facf31287a3b29b815fb8146"},{"_id":"public/scoi2007-lizard/index.html","modified":1483685913724,"shasum":"fbcad42dc155796064921d60c20fb937373a26f2"},{"_id":"public/sdoi2014-journey/index.html","modified":1483685913786,"shasum":"0a13a6f1ea43cbe3cb32898de9e085682bd3233a"},{"_id":"public/sdoi2008-interval/index.html","modified":1483685913839,"shasum":"0c1d7e5354fbef0af865854b353b5fedad82c70c"},{"_id":"public/at-the-cross-of-time/index.html","modified":1483685913893,"shasum":"9091cd6b0dae37ffdcd3b8e699c07a29f7ee1cb5"},{"_id":"public/noi2014-forest/index.html","modified":1483685913954,"shasum":"109c812a527dedab7545f35d12d21b9e1f6bb718"},{"_id":"public/noi2014-zoo/index.html","modified":1483685913996,"shasum":"0a07715c26080065bdddf1a11a17bcf9cc16f095"},{"_id":"public/bzoj-4145/index.html","modified":1483685914039,"shasum":"c9c44a2acbafd770ec0f67c1a2426e354db2e693"},{"_id":"public/bzoj-4247/index.html","modified":1483685914089,"shasum":"e624973e2c093ef9563410ef746efcdf102b5fd4"},{"_id":"public/jsoi2008-dotr/index.html","modified":1483685914150,"shasum":"858014b5062702a934e292cd6b844943504e31d1"},{"_id":"public/heoi2013-bag/index.html","modified":1483685914200,"shasum":"72452eb8c0171a2eb421d693d21618bde15b2546"},{"_id":"public/scoi2009-paint/index.html","modified":1483685914235,"shasum":"55d239cf64335f5593ea3acdfdc377420e34415d"},{"_id":"public/bzoj-1334/index.html","modified":1483685914277,"shasum":"c0f07df9482c94ec5e8ed6a0b8048692406ed801"},{"_id":"public/hnoi2010-chorus/index.html","modified":1483685914335,"shasum":"23cf92ad01a43ce80a24a1379bc10e9b4d3697b9"},{"_id":"public/scoi2003-fold/index.html","modified":1483685914376,"shasum":"159b3a958ad2049943dad8df0f7ff66472fa2548"},{"_id":"public/haoi2008-name/index.html","modified":1483685914421,"shasum":"525ea45247a8686f68f0c3ad81dbbbd10dc6fb79"},{"_id":"public/noi2015-dinner/index.html","modified":1483685914490,"shasum":"b263717a89a96ab772bdfdae31586d6a4e5a5de7"},{"_id":"public/noi2015-epic/index.html","modified":1483685914540,"shasum":"3b1df4ebd4b3944d20c7d71e665bc889dc6355dc"},{"_id":"public/noi2015-farm/index.html","modified":1483685914677,"shasum":"6c62137de0b70e6e22275a82998430da05a998c0"},{"_id":"public/noi2015-savour/index.html","modified":1483685914758,"shasum":"6ffa7e7cbe6ebb2ba41f6f7dcfbcac03739455ff"},{"_id":"public/bzoj-2438/index.html","modified":1483685914806,"shasum":"bd531cc4ccfe7cc6b9e3e799120e0d1c36860fb2"},{"_id":"public/bzoj-2716/index.html","modified":1483685914867,"shasum":"11c261802db2ffd3d5b33b5891155535da3b25a7"},{"_id":"public/shoi2007-tree/index.html","modified":1483685914909,"shasum":"7f167e9499f9f28debd855fd224db3a57d2c3042"},{"_id":"public/zjoi2009-ws/index.html","modified":1483685914964,"shasum":"faa24cbd4de0ddfbc4b2db7b956e56d5c479a03e"},{"_id":"public/bzoj-2132/index.html","modified":1483685915019,"shasum":"89e9b691ceed208356e36b9e14327afd4d20342e"},{"_id":"public/poi2005-kos/index.html","modified":1483685915074,"shasum":"0ae67510404b91f4a6af64ae9f7a5148feec8fa9"},{"_id":"public/poi2006-szk/index.html","modified":1483685915137,"shasum":"f1c8bcef3d0cc1c14dc4212bc230dde0b7c8bf87"},{"_id":"public/bzoj-1585/index.html","modified":1483685915209,"shasum":"2300926f1baf30cef859e7802a4da767ef491f45"},{"_id":"public/ceoi2008-order/index.html","modified":1483685915260,"shasum":"4c6d70f193530915d0f98300752764f9ca01964b"},{"_id":"public/bzoj-1711/index.html","modified":1483685915315,"shasum":"b948ab2e0afe6f971a06927773e7437f1c03d677"},{"_id":"public/sdoi2009-run/index.html","modified":1483685915364,"shasum":"4592810d0c1cc1b92d3092d300a0042aa723d18d"},{"_id":"public/bzoj-3894/index.html","modified":1483685915425,"shasum":"6a976e587873a4f770e897096e9e816c002b8ae5"},{"_id":"public/bzoj-2127/index.html","modified":1483685915485,"shasum":"bbf7a9adf63af6dfdae2260fbdacaee4b8e762ae"},{"_id":"public/bzoj-3438/index.html","modified":1483685915558,"shasum":"cd8fda3ceb01b596c2e4984dbf1107774cece3b1"},{"_id":"public/shoi2007-vote/index.html","modified":1483685915613,"shasum":"5b8bda00befd435db8686fa6f7bc6017bb47b8ff"},{"_id":"public/zjoi2010-network/index.html","modified":1483685915675,"shasum":"c4009ea95c0a287715b1e5051eaa0d670f6b8da9"},{"_id":"public/cqoi2011-inverse/index.html","modified":1483685915732,"shasum":"3dd8720aa2089ed898f0281827350418324047dc"},{"_id":"public/bzoj-1176/index.html","modified":1483685915789,"shasum":"fd2d282f105ab68c75a0fc3e6fb431cfb2c2e3d2"},{"_id":"public/sdoi2010-goblin/index.html","modified":1483685915838,"shasum":"dc9e64153470fa8006a4cedbe7b0279fb545aad1"},{"_id":"public/bzoj-3262/index.html","modified":1483685915896,"shasum":"9b8a2990ef8a013a1dbec32d3da5ce164714d837"},{"_id":"public/bzoj-3196/index.html","modified":1483685916005,"shasum":"cde4e7815a852c695352967f4a46aeddf71a32eb"},{"_id":"public/bzoj-2456/index.html","modified":1483685916050,"shasum":"546f6aa448e8ce3bf9180be002913caee106e983"},{"_id":"public/fft-to-ntt/index.html","modified":1483685916137,"shasum":"3cbc79e6c8def9f2c06597e89679d8acbd8c8608"},{"_id":"public/node-devide-notes/index.html","modified":1483685916203,"shasum":"f0ce788cd3b51b274e14d76f6af8273c1ea2efae"},{"_id":"public/ioi2011-race/index.html","modified":1483685916263,"shasum":"b7fac89903d87f994fa6d33d69dd864f43283368"},{"_id":"public/bzoj-3365/index.html","modified":1483685916317,"shasum":"78e9a5bdade5642ff159f345cf8ea77edb4f0219"},{"_id":"public/bzoj-3697/index.html","modified":1483685916375,"shasum":"ef974dd262dc7d3a77a55ece4792d82a82a09129"},{"_id":"public/bzoj-2152/index.html","modified":1483685916442,"shasum":"3e798bc47c1c5a82289efaf24169aff785e97bb8"},{"_id":"public/bzoj-1468/index.html","modified":1483685916498,"shasum":"938e2ec73034f8004ad73aa3602600f1413f220c"},{"_id":"public/sdoi2011-calc/index.html","modified":1483685916552,"shasum":"442ceb07d5040ac44dc72d4e287262dd11e2b3e1"},{"_id":"public/bsgs-notes/index.html","modified":1483685916621,"shasum":"00943eab5ce4e2e5d9883e463ab83b08aa1d3772"},{"_id":"public/sdoi2015-sequence/index.html","modified":1483685916700,"shasum":"3b72fd425a451b9a0a23c1d40b90eb441de467e1"},{"_id":"public/zjoi2014-force/index.html","modified":1483685916781,"shasum":"9cb4ab20697a481a2fe2b3a4d1f430808ae1bd11"},{"_id":"public/bzoj-2194/index.html","modified":1483685916839,"shasum":"13f57b0b170f081f868b55fe3a8ac770148657a1"},{"_id":"public/fft-notes/index.html","modified":1483685917003,"shasum":"40918ddfc95a6286efaeb7534da8804858601ae9"},{"_id":"public/uva-11021/index.html","modified":1483685917058,"shasum":"936c71ded1fc5233d5646feec9d69cd4dccb66fe"},{"_id":"public/bzoj-4318/index.html","modified":1483685917106,"shasum":"d3d658c3784c04535a220395cdfb2509e79ff667"},{"_id":"public/20160527-array/index.html","modified":1483685917164,"shasum":"09dc5303544bc0ee1c8bec67fd907c26850c9aa1"},{"_id":"public/bzoj-3275/index.html","modified":1483685917226,"shasum":"5f74e83bf7f5c953e769a82bab5729a18c79c971"},{"_id":"public/zjoi2006-trans/index.html","modified":1483685917281,"shasum":"d99ac6e826bb7a2c8c2a959113aa7ea5a08fec96"},{"_id":"public/zjoi2008-antbuster/index.html","modified":1483685917356,"shasum":"2bc76817d4c127a3e487cac4e774b9f1bafeed7f"},{"_id":"public/bzoj-3156/index.html","modified":1483685917419,"shasum":"ffd8f851d1ab154068b02e653616049eb2a346a0"},{"_id":"public/ceoi2004-two/index.html","modified":1483685917460,"shasum":"44a51deaf287517c8029bb3c8c5ff03c3cb02aab"},{"_id":"public/bzoj-1597/index.html","modified":1483685917523,"shasum":"bba0d88a7f6040fbb78ef1fc4ff9dd283e18158d"},{"_id":"public/zjoi2007-storage/index.html","modified":1483685917584,"shasum":"e35cd2655626931e29a5845a54a189dbc8cf74be"},{"_id":"public/apio2010-commando/index.html","modified":1483685917652,"shasum":"bd65669101a13987511df68e780b4b64949bbbb7"},{"_id":"public/hdu-5632/index.html","modified":1483685917704,"shasum":"8e1df5bf9331e79a0d95df9dbb0aa37e1bb7e43f"},{"_id":"public/scoi2009-windy/index.html","modified":1483685917762,"shasum":"414075638b67d6aabb60a773a87d315b68c33a85"},{"_id":"public/cf-628d/index.html","modified":1483685917835,"shasum":"d17f47932421d04679d3a82c03b7152a0efc963d"},{"_id":"public/hdu-2089/index.html","modified":1483685917884,"shasum":"5f7a03460c6c653ee11a31b398d04d600439e70b"},{"_id":"public/hdu-5642/index.html","modified":1483685917945,"shasum":"6a4e7e3ea4bbc6c1e2bb083d2c7f6bd1d9e5cd84"},{"_id":"public/chairman-tree-notes/index.html","modified":1483685918013,"shasum":"cf2288639633fdb37b520ea473c9359ee10d8e7a"},{"_id":"public/hnoi2016-tree/index.html","modified":1483685918102,"shasum":"f125b655df31894a7cca1c295f02b0331701a4b7"},{"_id":"public/hnoi2016-network/index.html","modified":1483685918188,"shasum":"42e47df7d588d62b758a442494a918d75221e7a1"},{"_id":"public/hnoi2016-multiple/index.html","modified":1483685918260,"shasum":"869522c782d167aa68a30fd225fbdfd22066dfc4"},{"_id":"public/ctsc-apio-2016/index.html","modified":1483685918303,"shasum":"6468d15d5df43d54e25182e0ad58493955b8eb72"},{"_id":"public/mo-algorithm-notes/index.html","modified":1483685918369,"shasum":"0bde484291252493e73461e708892d41431ca0c1"},{"_id":"public/hnoi2016-sequence/index.html","modified":1483685918481,"shasum":"fd678751feaf14511a9aaae14aee9588fe20c8fb"},{"_id":"public/haoi2016-chain/index.html","modified":1483685918537,"shasum":"d1106b0437251ddae511696abf02ae730500cb4e"},{"_id":"public/jsoi2009-game/index.html","modified":1483685918634,"shasum":"aec091d85ad8b5ebafffaa3f1d9d373bb8125b90"},{"_id":"public/hnoi2008-toy/index.html","modified":1483685918711,"shasum":"388433cb1203b0de5a12286286ae8769fb75d22a"},{"_id":"public/jsoi2016-flight/index.html","modified":1483685918803,"shasum":"d867689ba8ffe115f64dc02ae8b86a3914d5c670"},{"_id":"public/cqoi2016-number/index.html","modified":1483685918883,"shasum":"844b7a0e7515243c9d4f8523391c07336c269306"},{"_id":"public/cqoi2016-cuts/index.html","modified":1483685918972,"shasum":"bbf187091128be2d9213b83b803a89150e54efd5"},{"_id":"public/jsoi2016-light/index.html","modified":1483685919050,"shasum":"ca7fe55c4689aaaa901aa71a7f8d171603fb5cdd"},{"_id":"public/sdoi2016-table/index.html","modified":1483685919180,"shasum":"bfcff2f330ec7cd80ddaf7393a0d36256f227095"},{"_id":"public/sdoi2016-journey/index.html","modified":1483685919272,"shasum":"696dfa581e5162b907851cf9f7d319f809fb6a91"},{"_id":"public/sdoi2016-game/index.html","modified":1483685919425,"shasum":"200ce15f2a2cc5e2b538a4ccbce5214cc03a92d2"},{"_id":"public/derangement-number/index.html","modified":1483685919476,"shasum":"d80928d0c80627cfec2f1f1cf1a8a7b72bdbca7b"},{"_id":"public/mul-inverse/index.html","modified":1483685919597,"shasum":"a737cae832c239a8b32ba6eb6e326d6c454c529b"},{"_id":"public/sdoi2016-permutation/index.html","modified":1483685919661,"shasum":"9ad821723552105723d608f294961c9f7c75c15b"},{"_id":"public/sdoi2016-incantation/index.html","modified":1483685919728,"shasum":"2bbb5199db0fa5db5f861498cc2ac9617a025d3d"},{"_id":"public/spoj-694/index.html","modified":1483685919777,"shasum":"8e875d53a77c7bb16270e564f656621f51290e2e"},{"_id":"public/suffix-array-notes/index.html","modified":1483685919877,"shasum":"9ab22ce4107406e57ed2e83765c9438b148df9ca"},{"_id":"public/sdoi2016-round1/index.html","modified":1483685919912,"shasum":"f347c98f65f630d200d17e848beccd34c3a1d8dd"},{"_id":"public/poj-3461/index.html","modified":1483685919982,"shasum":"0de2560e06798a269f62b96ef5b8be0f5ba60b34"},{"_id":"public/sdoi2016-pair/index.html","modified":1483685920063,"shasum":"e739ac2e84da992d83c66ab9ab3f725c9c79524a"},{"_id":"public/bzoj-4403/index.html","modified":1483685920108,"shasum":"f182748116e91c727091cb2792523bdd85ae5c39"},{"_id":"public/ahoi2014-story/index.html","modified":1483685920166,"shasum":"141b409ff05a6b1e998954dbefe5df0a6c3a72e9"},{"_id":"public/non-recursion-dfs-with-stack/index.html","modified":1483685920215,"shasum":"3d5bb871a2430c6a4e43a5ee63d0fc182f3fb225"},{"_id":"public/euler-sieve/index.html","modified":1483685920287,"shasum":"a67c5962b34335a25f1899e41fa5d1cff33977c1"},{"_id":"public/haoi2011-problemb/index.html","modified":1483685920351,"shasum":"32f7f38696939cee8a84483ece5a015a392b2d9a"},{"_id":"public/bzoj-2820/index.html","modified":1483685920425,"shasum":"37d92135414a3728498b1ffd63259709631efa27"},{"_id":"public/bzoj-3511/index.html","modified":1483685920493,"shasum":"35c03fecbafe21273b4a04a02f1bc87a8fc217b7"},{"_id":"public/bzoj-1008/index.html","modified":1483685920532,"shasum":"4893d28979ca1bb65c00f5880037e4a51a2b2e5a"},{"_id":"public/20160404-theory/index.html","modified":1483685920618,"shasum":"678cf411fd557218f5a96f725dde89881ac9714f"},{"_id":"public/tjoi2013-lis/index.html","modified":1483685920667,"shasum":"5734c30d5b914a944110dc1accf6260fddd7d0bb"},{"_id":"public/bzoj-1001/index.html","modified":1483685920726,"shasum":"91bad0eaa01ae8ba50b9b912d7103b5c3ef41f2e"},{"_id":"public/noi2014-sleep/index.html","modified":1483685920771,"shasum":"eaa64f14c0b38b9c21d1c2a89ae91275f1bf5aae"},{"_id":"public/haoi2015-t2/index.html","modified":1483685920830,"shasum":"d7da5f1845d0d3c821bd446aaf00b4da54e0c4b3"},{"_id":"public/bzoj-2296/index.html","modified":1483685920863,"shasum":"91f71bc21effde1c3c62acb17f505994ce6ed91d"},{"_id":"public/bzoj-2038/index.html","modified":1483685920928,"shasum":"164e631a574b24dc5d90a79b73f93c0b49d89ff7"},{"_id":"public/20160331-naive/index.html","modified":1483685920991,"shasum":"ae132b0590223beb8582b81f6349f7b27eb6ec5f"},{"_id":"public/scoi2015-password/index.html","modified":1483685921059,"shasum":"dfe498484e4a4223b96d0cb79833b488aaacff09"},{"_id":"public/scoi2015-light/index.html","modified":1483685921124,"shasum":"ef0d8131f80d397a4a00449be392a45f5b625f0a"},{"_id":"public/bzoj-2143/index.html","modified":1483685921185,"shasum":"c1d4278c59b9bf787aecb9a0aa3717a1cd36200d"},{"_id":"public/scoi2015-flag/index.html","modified":1483685921240,"shasum":"3924bb4756eff80efe003c50b688ae018c701090"},{"_id":"public/scoi2015-message/index.html","modified":1483685921300,"shasum":"9c898792a34a8246feba93ecaa815bd831734fd0"},{"_id":"public/scoi2015-matrix/index.html","modified":1483685921351,"shasum":"ef9196f3d30dde48770a4bd03e5a860e4a89809f"},{"_id":"public/20160318-color/index.html","modified":1483685921420,"shasum":"813baffc75ecf4b84b5d94dc2ced53ec7f3ebc9b"},{"_id":"public/20160319-candy/index.html","modified":1483685921467,"shasum":"d4ed9bf0e0f5188184988b22088a9ebece606226"},{"_id":"public/20160319-set/index.html","modified":1483685921536,"shasum":"6a112490854b99aa54dbeddc0cbc4d194cc60d39"},{"_id":"public/sdoi2008-cave/index.html","modified":1483685921581,"shasum":"96c7aad0a59694eddc9314fd20ab3c0f6093d1db"},{"_id":"public/combinatorics-notes/index.html","modified":1483685921652,"shasum":"e4a7f1769d1251b04af2605585bc1f131e7fcecc"},{"_id":"public/uva-10253/index.html","modified":1483685921693,"shasum":"23e73adc469faf0a96a163b79be2ec59498a1ad0"},{"_id":"public/uva-11361/index.html","modified":1483685921755,"shasum":"cb70110f8d5b2b9da65acb610fc11fe5991f099d"},{"_id":"public/bigint-template/index.html","modified":1483685921800,"shasum":"4ffed62f67be074489bd227b597214bdc1e2d447"},{"_id":"public/uva-1362/index.html","modified":1483685921840,"shasum":"f9e9663d1d8d66cfc00efd9865e74f756d95f2b8"},{"_id":"public/poj-1737/index.html","modified":1483685921904,"shasum":"c76200acd4ca77df75096ebd5b00bf1399645b42"},{"_id":"public/uva-11174/index.html","modified":1483685921950,"shasum":"2917062136de17541273325be8861093fd199b4c"},{"_id":"public/uva-11137/index.html","modified":1483685921998,"shasum":"55bb702ebb08ecfe21a5c3fe21333dfd1507f14b"},{"_id":"public/uva-11375/index.html","modified":1483685922040,"shasum":"f3ca5b41cd1c036fbef8100e7b2f11e48b9f2cad"},{"_id":"public/uva-11538/index.html","modified":1483685922101,"shasum":"58a4553eff7993cec63e484bae59307bc6134fc2"},{"_id":"public/uva-11806/index.html","modified":1483685922149,"shasum":"124b001d7200c1c66fea03d47b0993f69227d229"},{"_id":"public/poj-2728/index.html","modified":1483685922198,"shasum":"d8b1e527de1a7c2d0120c1adf20906926ab36978"},{"_id":"public/apio2009-atm/index.html","modified":1483685922258,"shasum":"a118ac52e0cb47b08fd234cab713553159894645"},{"_id":"public/noi2006-profit/index.html","modified":1483685922312,"shasum":"2ed44578252a5df75242dbceede2376f2a086b44"},{"_id":"public/scoi2007-repair/index.html","modified":1483685922373,"shasum":"2dfb6c2f7b6d86bd5b89039f96963dc7acdbc69a"},{"_id":"public/ahoi2008-meet/index.html","modified":1483685922428,"shasum":"11b25cde51425577a4cbe80a5fe6f5fb7790a531"},{"_id":"public/scoi2010-game/index.html","modified":1483685922479,"shasum":"8dbd46bdc618cf17c9cb34802857cc75b9d00986"},{"_id":"public/virtualbox-archlinux/index.html","modified":1483685922508,"shasum":"62c9af694c37c7a8922ee515d5c4f554eab6dbcc"},{"_id":"public/noi2003-editor/index.html","modified":1483685922596,"shasum":"4b7ed7cb98354a1a512d01444b0d1cc35422d73c"},{"_id":"public/scoi2011-candy/index.html","modified":1483685922652,"shasum":"2d68397b1fb21b1f0266068851387b0143dc9b27"},{"_id":"public/haoi2006-cow/index.html","modified":1483685922704,"shasum":"535e4e63b3c270804185b98c5bc639aa9f1b1195"},{"_id":"public/codevs-2822/index.html","modified":1483685922749,"shasum":"c1e2ee7ecfde006a9477468afb89e4edf8b760d8"},{"_id":"public/tarjan-scc-notes/index.html","modified":1483685922815,"shasum":"1c92cae4765503d201cf2da6fcc980f28add76c0"},{"_id":"public/sdoi2010-starrace/index.html","modified":1483685922868,"shasum":"7067973c3c3164263a555e82f9f04b5c0eb89744"},{"_id":"public/sdoi2015-war/index.html","modified":1483685922924,"shasum":"d143d184cbefab21a07a565e4a05f5c38672ecc1"},{"_id":"public/cogs-741/index.html","modified":1483685922974,"shasum":"4e462a8d46acf30d2eba79524bdff53001246d86"},{"_id":"public/cogs-740/index.html","modified":1483685923028,"shasum":"58d12a5a6f8b747604c125bc0247612629311b7b"},{"_id":"public/ctsc1999-home/index.html","modified":1483685923073,"shasum":"7847dbff9fccf1dbafc4f489f807f8b95aa14d5a"},{"_id":"public/cogs-742/index.html","modified":1483685923133,"shasum":"2ec28349a095e3d6427849d6da669e6b51e31ebb"},{"_id":"public/cogs-739/index.html","modified":1483685923183,"shasum":"49d6fe3f18d37bfe467b60f714ed274050990114"},{"_id":"public/jsoi2008-maxnumber/index.html","modified":1483685923231,"shasum":"bc89b7c40afd2a4c1a64d39dfadc1cdb6d6c5f6e"},{"_id":"public/edmonds-karp-notes/index.html","modified":1483685923282,"shasum":"d643e07ae3b0fc5498c1d5d39a5ee4f1c3a425c7"},{"_id":"public/noip2010-prison/index.html","modified":1483685923325,"shasum":"b53efc325b64cd404dbbd04921bc0c100c706a42"},{"_id":"public/cogs-746/index.html","modified":1483685923378,"shasum":"14180f365d70262f611ca2accecef4b08685292c"},{"_id":"public/cogs-738/index.html","modified":1483685923433,"shasum":"140053547f98d2d4737566a582a0ebaf9e26689a"},{"_id":"public/cogs-734/index.html","modified":1483685923485,"shasum":"1963c29efe5c58d65f3128bd823cda0855a89039"},{"_id":"public/cogs-439/index.html","modified":1483685923532,"shasum":"c5f208b1e2e8c9e03e6b1c20960edc1e3c756bc4"},{"_id":"public/cogs-727/index.html","modified":1483685923596,"shasum":"d2d7420f27cd01a58b13b9a9cb87f253c82f18bc"},{"_id":"public/cogs-731/index.html","modified":1483685923658,"shasum":"41dd07e6faf29435671a81791e4ee42812b85946"},{"_id":"public/cogs-729/index.html","modified":1483685923709,"shasum":"63ab68028c211526f2376c35869a9169dcba0507"},{"_id":"public/cogs-396/index.html","modified":1483685923736,"shasum":"e8e4a94675ca392a66b57337e6cbf8172d517577"},{"_id":"public/cogs-728/index.html","modified":1483685923784,"shasum":"8c8aaee154217d9b8176a307eedd97b58e9a379a"},{"_id":"public/cogs-14/index.html","modified":1483685923840,"shasum":"c8071dc7daa839c06e7533a8a9b47949692d0fd9"},{"_id":"public/bzoj-2683/index.html","modified":1483685923888,"shasum":"0ef3a4e613af067b48c32df77796608fe653bdf2"},{"_id":"public/codevs-1563/index.html","modified":1483685923925,"shasum":"98bc64a3922b9f556dc2107321e188c6a8df452d"},{"_id":"public/gnu-debugger/index.html","modified":1483685923976,"shasum":"4cd024be756c5bb5d0eb899de78de2f952a39019"},{"_id":"public/dinic-notes/index.html","modified":1483685924018,"shasum":"8057b8669fe195079661db84354d059ca93c3040"},{"_id":"public/bzoj-1756/index.html","modified":1483685924074,"shasum":"adfd8486233e2a645799a9667f7bc527634e67f2"},{"_id":"public/noi2004-cashier/index.html","modified":1483685924128,"shasum":"b639f98b3224eb67e9e0c46bb91497268e5ed58f"},{"_id":"public/bzoj-1477/index.html","modified":1483685924190,"shasum":"dacc9cd3c070b0af0b13cf7dccfcfc83b26bfd43"},{"_id":"public/noi2015-manager/index.html","modified":1483685924245,"shasum":"992649ce8ac57e90613a95d5cf088afdf8e70419"},{"_id":"public/noi2015-prog/index.html","modified":1483685924299,"shasum":"78fa8ebcc31fe993a23e2e2536258597bf673ab9"},{"_id":"public/number-theory-notes-1/index.html","modified":1483685924363,"shasum":"de36553a9a2d9d4db6df63f9e13362cf5f579f1a"},{"_id":"public/noip2012-mod/index.html","modified":1483685924411,"shasum":"234458098cf4afcd4a35b98b183598fa0c2601fe"},{"_id":"public/link-cut-tree-notes/index.html","modified":1483685924465,"shasum":"1116d6500a7e419ab15f1901fe801478fbc38570"},{"_id":"public/splay-notes-3/index.html","modified":1483685924537,"shasum":"fe5a46a24ea07cd3f95974776b1f8f0c6afee736"},{"_id":"public/bzoj-1251/index.html","modified":1483685924594,"shasum":"b73379f078f5de4db21e98df69e87555843163d6"},{"_id":"public/noip2006-budget/index.html","modified":1483685924645,"shasum":"4050860a5925aca115aa2c08d6f2df51ba3e1211"},{"_id":"public/bzoj-2442/index.html","modified":1483685924694,"shasum":"282d17f0ed510285d77247bd182fbb65705c0e0c"},{"_id":"public/codevs-3269-monotone-queue/index.html","modified":1483685924754,"shasum":"40ccd5c95274427b15eea41c26bf135b402763b4"},{"_id":"public/monotone-queue-notes/index.html","modified":1483685924795,"shasum":"2af0468d5cf1ed86d0725a24c0223caad10ad9a4"},{"_id":"public/codevs-1345/index.html","modified":1483685924835,"shasum":"fb82fd76576b6df48d5f1bcb77e0b7589d10a0f9"},{"_id":"public/noip2003-game/index.html","modified":1483685924887,"shasum":"3d6d0d2482212d65a074f4ac70bcba69d7a05794"},{"_id":"public/noip2006-energy/index.html","modified":1483685924930,"shasum":"38bb3df8a278e228af287b2c40265cdd829a91f7"},{"_id":"public/tyvj-3317/index.html","modified":1483685924971,"shasum":"49025df4a66bdd02d924393cf856d13a36eb05d6"},{"_id":"public/codevs-2598/index.html","modified":1483685925017,"shasum":"5acaa3ee012c5f5b84c1b14636b187bf22d5345b"},{"_id":"public/noip2000-cheng-ji-zui-da/index.html","modified":1483685925052,"shasum":"2ecd113073b3139a21ab46b33f9b0c1187ba3486"},{"_id":"public/ctsc1997-course/index.html","modified":1483685925096,"shasum":"0a5d37508d467716abc8db5f61bfda0fbb14bc47"},{"_id":"public/codevs-3168-3162/index.html","modified":1483685925164,"shasum":"0b9644da27f7ae193b10b658e2c3589049aff3dc"},{"_id":"public/minimum-spanning-tree-notes/index.html","modified":1483685925241,"shasum":"baaffc4a9d92d2e6e7392623bc822e70afc3d025"},{"_id":"public/system-of-difference-constraints-notes/index.html","modified":1483685925283,"shasum":"19f60ca0b1ad7e92aa5a87e3a1086e50d64ce4ea"},{"_id":"public/kmp-notes/index.html","modified":1483685925331,"shasum":"ef69e3d4a698edd062a241c4585d8b1908c40350"},{"_id":"public/tree-chain-split-notes/index.html","modified":1483685925400,"shasum":"b1f15cb46cc55338fbd48025342a81fee873726f"},{"_id":"public/stl-in-oi/index.html","modified":1483685925465,"shasum":"cc839bb30687e0efe2a8ffddc847107f39647608"},{"_id":"public/splay-notes-2/index.html","modified":1483685925541,"shasum":"b36ec0669cc1403daac8e9d080223855e4524840"},{"_id":"public/splay-notes-1/index.html","modified":1483685925620,"shasum":"e2b159a3b9415a11d3b1d4a39675d17e797733c6"},{"_id":"public/hnoi2004-pet/index.html","modified":1483685925660,"shasum":"8dd1b00ed38f7dc0da875c6f5ff06c289fc26d44"},{"_id":"public/codevs-3269/index.html","modified":1483685925712,"shasum":"bceda8fedd8fa24f3d71d7c4a9a4e2c949ad7154"},{"_id":"public/noi2002-galaxy/index.html","modified":1483685925762,"shasum":"ba9580fa2c4a9c59b920c6aa5b50f1da3758af2b"},{"_id":"public/archives/index.html","modified":1483692242933,"shasum":"a82c6038465156c13dccbfc6cb041fcf33c57b67"},{"_id":"public/archives/page/2/index.html","modified":1483685925870,"shasum":"4ed40b6eaf361cdf8efc2b1cf9367159cc421e3b"},{"_id":"public/archives/page/3/index.html","modified":1483685925934,"shasum":"755bb4167ae55d5e8bff10330b594741ee2725df"},{"_id":"public/archives/page/4/index.html","modified":1483685926005,"shasum":"412c77592707c93a9946d47b76e9c456bd29a3bf"},{"_id":"public/archives/page/5/index.html","modified":1483685926056,"shasum":"114015069f3b91467c9749437bd77b221173eea5"},{"_id":"public/archives/page/6/index.html","modified":1483685926108,"shasum":"1b4c87777d6c58db99e8acd89eaa36300f86d8b4"},{"_id":"public/archives/page/7/index.html","modified":1483685926154,"shasum":"01800b222239fad3d295b3ac004861160af8282f"},{"_id":"public/archives/page/8/index.html","modified":1483685926214,"shasum":"5bae8ce4b05d83bdb0ce2a29a9e769f93fe6c528"},{"_id":"public/archives/page/9/index.html","modified":1483685926268,"shasum":"dd3833c6148950f2a9bae571b0091c1943bd0c11"},{"_id":"public/archives/page/10/index.html","modified":1483685926327,"shasum":"2bdfdbf854620e6be6e391a6980cea83b94ece8a"},{"_id":"public/archives/page/11/index.html","modified":1483685926394,"shasum":"0c20435cc0d0e48dace6b70ae43763743bfc51af"},{"_id":"public/archives/page/12/index.html","modified":1483685926436,"shasum":"ac350f0404d21d153123dab5c1ee2ccb7d3ee9d9"},{"_id":"public/archives/page/13/index.html","modified":1483685926501,"shasum":"fa51d6f8cc097d6484f5fde7bcbb4d58b44c506f"},{"_id":"public/archives/page/14/index.html","modified":1483685926554,"shasum":"10676d8d710fda3fc49c5a0164efc8d2fcae1352"},{"_id":"public/archives/page/15/index.html","modified":1483685926605,"shasum":"fccbcb1069b6c7f5e2c6eb5aee1d256f3c18a185"},{"_id":"public/archives/page/16/index.html","modified":1483685926662,"shasum":"f3cd0839e71bebae0b2d86ffe22b89c01f44f8c1"},{"_id":"public/archives/page/17/index.html","modified":1483685926720,"shasum":"25f1787309af285062b60db823e887eab2d1c57b"},{"_id":"public/archives/page/18/index.html","modified":1483685926776,"shasum":"65ff147c97a512946008d696386b2d7bca6720c4"},{"_id":"public/archives/page/19/index.html","modified":1483685926854,"shasum":"83ea1f56474347a89a1ad5370a32ebd833b31905"},{"_id":"public/archives/page/20/index.html","modified":1483685926904,"shasum":"31ca780de76768b6fa519e9577314372261d3f9c"},{"_id":"public/archives/page/21/index.html","modified":1483685926961,"shasum":"bf7a995f91cc6a6689d31af2f1f2e70511912fd4"},{"_id":"public/archives/page/22/index.html","modified":1483685927017,"shasum":"41bc73b1e022ba09e0ec8714f84d443da3f54f67"},{"_id":"public/archives/page/23/index.html","modified":1483685927069,"shasum":"0e38ead6e59208b3d60032ae998838831218de56"},{"_id":"public/archives/page/24/index.html","modified":1483685927113,"shasum":"658181c668fa5390e7d64c36f51865798e680251"},{"_id":"public/archives/page/25/index.html","modified":1483685927159,"shasum":"2a8fd808e28a84e73a81044411cdb85bee2b9982"},{"_id":"public/archives/page/26/index.html","modified":1483685927207,"shasum":"dfbe84de3bbe51f3c64587ac679f00a1ff5d2709"},{"_id":"public/archives/page/27/index.html","modified":1483685927244,"shasum":"d48d4654f78462a81fecb38def2ecd71f180d382"},{"_id":"public/archives/page/28/index.html","modified":1483685927286,"shasum":"3a9964d74f8044edf110f95506178a0b60fc24cd"},{"_id":"public/archives/page/29/index.html","modified":1483685927355,"shasum":"62ad3df17ca39aed0b09db5a7dcf084bc7b945b7"},{"_id":"public/archives/page/30/index.html","modified":1483685927390,"shasum":"ae67f4cc098ce4de44ddab0ba9d709174761f63e"},{"_id":"public/archives/page/31/index.html","modified":1483685927414,"shasum":"f1c6e14b1007d3bd8dea88cd370aec968ff69e4f"},{"_id":"public/archives/2015/index.html","modified":1483685927447,"shasum":"c9e7932ed245f3f36c7b05fd1a0f2e0a906221ca"},{"_id":"public/archives/2015/11/index.html","modified":1483685927476,"shasum":"cfc863b7692ee6fd91c83a956acf98339705a79a"},{"_id":"public/archives/2015/12/index.html","modified":1483685927502,"shasum":"90a7c07ad0e26cf63da63c5d26b7a34c589bcc44"},{"_id":"public/archives/2016/index.html","modified":1483685927551,"shasum":"ebf395cb3d1d85c657361e4af4ec83796eb23c7a"},{"_id":"public/archives/2016/page/2/index.html","modified":1483685927619,"shasum":"3b8b2aaa90decf382c3f3218e18ddcba9cd573f6"},{"_id":"public/archives/2016/page/3/index.html","modified":1483685927677,"shasum":"8a1cadab97b047d799ba75cfee91f6b362a0cebf"},{"_id":"public/archives/2016/page/4/index.html","modified":1483685927740,"shasum":"2b21e32cb26383bda0b96ec051aad47980ff4f96"},{"_id":"public/archives/2016/page/5/index.html","modified":1483685927781,"shasum":"4bd1880e6d0a10cacd9bbc33d119feae2d256462"},{"_id":"public/archives/2016/page/6/index.html","modified":1483685927851,"shasum":"8ca2c33cf4c0a05b8bc8649ab12c4fce47df24fa"},{"_id":"public/archives/2016/page/7/index.html","modified":1483685927907,"shasum":"e44c6450b29e4a3ab182de869fe01ef0c5741a54"},{"_id":"public/archives/2016/page/8/index.html","modified":1483685927966,"shasum":"bd81f6112641a4f16745402a22ec51070c5942e6"},{"_id":"public/archives/2016/page/9/index.html","modified":1483685928011,"shasum":"a7fe552379afcd38375da89c022ca31cc41dc234"},{"_id":"public/archives/2016/page/10/index.html","modified":1483685928077,"shasum":"68e22888da50c448b1a87e1450a370d145a409ab"},{"_id":"public/archives/2016/page/11/index.html","modified":1483685928118,"shasum":"19ed7ede5bbe4ec7ca1ba3f2524548460e7f7b9d"},{"_id":"public/archives/2016/page/12/index.html","modified":1483685928173,"shasum":"e000c36be8d9e82bbbc8d0d488f044228f70df78"},{"_id":"public/archives/2016/page/13/index.html","modified":1483685928231,"shasum":"4140536f1cfe971f25790d484a2ab87f3250cf0e"},{"_id":"public/archives/2016/page/14/index.html","modified":1483685928285,"shasum":"1cffadde42ad0865a8ce044f1fc52a8eb3674ce8"},{"_id":"public/archives/2016/page/15/index.html","modified":1483685928347,"shasum":"028d59e119135d5d4d84cee815d69518a7707bc2"},{"_id":"public/archives/2016/page/16/index.html","modified":1483685928404,"shasum":"529c62c1fb27c0869e671be49c58d6cf39f029e3"},{"_id":"public/archives/2016/page/17/index.html","modified":1483685928458,"shasum":"16d4e75c0d6451f5a89b1cb937f6258e65fb0fba"},{"_id":"public/archives/2016/page/18/index.html","modified":1483685928526,"shasum":"47c951393f5174a855c47efeedcf361f8844ab02"},{"_id":"public/archives/2016/page/19/index.html","modified":1483685928587,"shasum":"5e8d6ecd9e34aa65f4980b31249655bb3c2fef58"},{"_id":"public/archives/2016/page/20/index.html","modified":1483685928635,"shasum":"0f2d184a1c6b724f97889eb253dad597b293cfeb"},{"_id":"public/archives/2016/page/21/index.html","modified":1483685928705,"shasum":"e1af7cbf98e8e8e09ceecc91526625a5493a6658"},{"_id":"public/archives/2016/page/22/index.html","modified":1483685928745,"shasum":"f47d2c242dfe91cfde6c0fed4ba4d770fbd918e3"},{"_id":"public/archives/2016/page/23/index.html","modified":1483685928800,"shasum":"619cd3ac9aa00c93be2fe2b96276b9b76a89e8e5"},{"_id":"public/archives/2016/page/24/index.html","modified":1483685928852,"shasum":"a06a6947de9e34d5debebadd198c3a68066af092"},{"_id":"public/archives/2016/page/25/index.html","modified":1483685928897,"shasum":"f3d5238ca8c865016431625f8909daeecc754e07"},{"_id":"public/archives/2016/page/26/index.html","modified":1483685928963,"shasum":"e050fb4618ff6a503e64b720a6571c0181f29b5f"},{"_id":"public/archives/2016/page/27/index.html","modified":1483685929000,"shasum":"bfd581636ec21bee95ec5b86f9c92049c5fc2d1d"},{"_id":"public/archives/2016/page/28/index.html","modified":1483685929043,"shasum":"94cc38972e7881b6df05bc3b669599106a3264f1"},{"_id":"public/archives/2016/page/29/index.html","modified":1483685929087,"shasum":"85f91182cccca37cc9c94156bb8c1e70074bbe68"},{"_id":"public/archives/2016/01/index.html","modified":1483685929126,"shasum":"e7634eea08fec2a1f108a7bd2d90257f420e5c08"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1483685929162,"shasum":"fc7f3956f7d74ad0647c8d7c9132bccfc82480af"},{"_id":"public/archives/2016/01/page/3/index.html","modified":1483685929188,"shasum":"8f25e6a2187ca9be5cca0d4d35d42b4147e5db44"},{"_id":"public/archives/2016/02/index.html","modified":1483685929243,"shasum":"1dd1875fee8d1d35151275bfb94139cb1585af74"},{"_id":"public/archives/2016/02/page/2/index.html","modified":1483685929284,"shasum":"8d180e1211e5fd597539381c917502d6ccbbf9f7"},{"_id":"public/archives/2016/02/page/3/index.html","modified":1483685929311,"shasum":"c45507406bf35ffadebb3494d854f7d99b5eda03"},{"_id":"public/archives/2016/03/index.html","modified":1483685929371,"shasum":"3181d789b7debe1aa13ba388dfc5125bd18c8cf8"},{"_id":"public/archives/2016/03/page/2/index.html","modified":1483685929403,"shasum":"79c4a2709b4cbb7a92fdbf941aa1b00c81aaaf4b"},{"_id":"public/archives/2016/03/page/3/index.html","modified":1483685929468,"shasum":"1456da287e285d392ec664668a2037f441480735"},{"_id":"public/archives/2016/03/page/4/index.html","modified":1483685929487,"shasum":"83f69a7a1cec817142b300db6f51afe270977eb7"},{"_id":"public/archives/2016/04/index.html","modified":1483685929549,"shasum":"07e254a604e7f592c6c91e5008b15e4c6b5181a8"},{"_id":"public/archives/2016/04/page/2/index.html","modified":1483685929609,"shasum":"17ed40c03ed05baacb7c24b691c51354c7c5ce6d"},{"_id":"public/archives/2016/04/page/3/index.html","modified":1483685929660,"shasum":"f9a6d95af02dd249a0646798066c57e08f4a5d58"},{"_id":"public/archives/2016/04/page/4/index.html","modified":1483685929709,"shasum":"efd68c909c3dbe236211f90c4e917bdd08203294"},{"_id":"public/archives/2016/05/index.html","modified":1483685929760,"shasum":"9274f58901a25eff2da2c18ff781dce44f0a7e30"},{"_id":"public/archives/2016/05/page/2/index.html","modified":1483685929819,"shasum":"f73da9b69df99b0858a79e7dd233efe6e1bea4ea"},{"_id":"public/archives/2016/05/page/3/index.html","modified":1483685929834,"shasum":"d0d05d091fa7437e187f2209a8e55a329a4e202c"},{"_id":"public/archives/2016/06/index.html","modified":1483685929892,"shasum":"953c1f0448d5865535b9c6c651f04bd37eed5aae"},{"_id":"public/archives/2016/06/page/2/index.html","modified":1483685929962,"shasum":"a2c801b328f41294f09ff98efdd9f06b351b8905"},{"_id":"public/archives/2016/06/page/3/index.html","modified":1483685930022,"shasum":"216657d2bf18532fb0e9cc53f62fa5284f630ec2"},{"_id":"public/archives/2016/06/page/4/index.html","modified":1483685930079,"shasum":"45cb793493ab392e76dc357c50b9d110cd840722"},{"_id":"public/archives/2016/07/index.html","modified":1483685930124,"shasum":"f30de7cf0d74ad1c3a99c3d46ba5994077877fac"},{"_id":"public/archives/2016/07/page/2/index.html","modified":1483685930143,"shasum":"597b228b8533adb05cf08b90e7b7d89303db5ef9"},{"_id":"public/archives/2016/08/index.html","modified":1483685930177,"shasum":"17bdc1ae7ac17dafc827240f3c3c858d654bdc91"},{"_id":"public/archives/2016/09/index.html","modified":1483685930234,"shasum":"16f665725de5a55ec3bbc1caf1e46b491180e0a2"},{"_id":"public/archives/2016/09/page/2/index.html","modified":1483685930285,"shasum":"2d5296b842af65cf4c49706335993ed9da034bb1"},{"_id":"public/archives/2016/09/page/3/index.html","modified":1483685930349,"shasum":"dfec585900d0d9827f02f52c072faa54433fcb05"},{"_id":"public/archives/2016/09/page/4/index.html","modified":1483685930366,"shasum":"2add6eb9d82b5ba039c0f9e48a32589f83e6e00b"},{"_id":"public/archives/2016/10/index.html","modified":1483685930419,"shasum":"617018b9545bb56e31edc4ee55a506aa90feabc9"},{"_id":"public/archives/2016/10/page/2/index.html","modified":1483685930482,"shasum":"7af6c1d715aef280ef23229126743db4c108251a"},{"_id":"public/archives/2016/10/page/3/index.html","modified":1483685930522,"shasum":"50147deef5c18b6eb56a1355027d95b612c3ba8b"},{"_id":"public/archives/2016/11/index.html","modified":1483685930596,"shasum":"d842fef76b0ce7fcece5b7ca005f74214007ee55"},{"_id":"public/archives/2016/11/page/2/index.html","modified":1483685930656,"shasum":"32f9491ebcdd5f7c2ef2d90539661423c7c20715"},{"_id":"public/archives/2016/11/page/3/index.html","modified":1483685930669,"shasum":"7b53c79b9cfe8e50265761700cd5db9884fbb36c"},{"_id":"public/archives/2016/12/index.html","modified":1483685930720,"shasum":"d444b39d3c91b715f778685fb4093f40a03a0216"},{"_id":"public/archives/2016/12/page/2/index.html","modified":1483685930763,"shasum":"d52799d253900fdcecf280fc1a27f5cc4b5152fe"},{"_id":"public/archives/2017/index.html","modified":1483692246692,"shasum":"4e7082e5b76ee9b63c6cbc997509876c08d37fa0"},{"_id":"public/archives/2017/01/index.html","modified":1483692246721,"shasum":"4e7082e5b76ee9b63c6cbc997509876c08d37fa0"},{"_id":"public/categories/oi/index.html","modified":1483692246763,"shasum":"94e62f32203ddf7f44d8c738aa1766d8f763457b"},{"_id":"public/categories/oi/page/2/index.html","modified":1483685930950,"shasum":"a1b6c376d3e4e89a02851b0e812ed8d917420301"},{"_id":"public/categories/oi/page/3/index.html","modified":1483685931014,"shasum":"2bed0807fe4124bc81c49c5fe849be51b5d410c2"},{"_id":"public/categories/oi/page/4/index.html","modified":1483685931092,"shasum":"8b6b8fdd14c3966302ca6f0452e2cead1c5dd693"},{"_id":"public/categories/oi/page/5/index.html","modified":1483685931142,"shasum":"5df9d78aa0f0d8b99287a2a489c92341cc7f88e4"},{"_id":"public/categories/oi/page/6/index.html","modified":1483685931193,"shasum":"e025f42fe788f09531c7c44bcf966c0c2c3ee74a"},{"_id":"public/categories/oi/page/7/index.html","modified":1483685931248,"shasum":"28bb88c3606dd2c137af3c88c2bb9956f61f053d"},{"_id":"public/categories/oi/page/8/index.html","modified":1483685931297,"shasum":"47daf56e5453231bcbbbc0841f5e78f74586d2a4"},{"_id":"public/categories/oi/page/9/index.html","modified":1483685931358,"shasum":"60f548f816baeb888a1d3f0c9bd2069c9a16c9a1"},{"_id":"public/categories/oi/page/10/index.html","modified":1483685931418,"shasum":"af246fd0f45ac28e717ecddcdf75433a6c1dd299"},{"_id":"public/categories/oi/page/11/index.html","modified":1483685931475,"shasum":"699442f396b76b81d516145fc9246e62e4c6e69c"},{"_id":"public/categories/oi/page/12/index.html","modified":1483685931525,"shasum":"d5fa63d530865d37632d95b6d5950944f6e6029e"},{"_id":"public/categories/oi/page/13/index.html","modified":1483685931584,"shasum":"72da4b385229987290eec867d85017c3b55d8ed4"},{"_id":"public/categories/oi/page/14/index.html","modified":1483685931637,"shasum":"b0e1ff3cafb261eb01a0963ab84afaf4826581b2"},{"_id":"public/categories/oi/page/15/index.html","modified":1483685931692,"shasum":"7c16694b8104921788df0a70ec9a23c63b953e63"},{"_id":"public/categories/oi/page/16/index.html","modified":1483685931744,"shasum":"4884ba168a41c8690cf42092bbdc3beaaa79173c"},{"_id":"public/categories/oi/page/17/index.html","modified":1483685931800,"shasum":"4c0e4a9e1430a62e7a3a5b4c1029640f4ce63ba2"},{"_id":"public/categories/oi/page/18/index.html","modified":1483685931860,"shasum":"45ec9af2450ea787d62c338bfafe8c03fa60012d"},{"_id":"public/categories/oi/page/19/index.html","modified":1483685931925,"shasum":"753bf086d1d2ae146e7cbab270ff601caff62d9a"},{"_id":"public/categories/oi/page/20/index.html","modified":1483685931981,"shasum":"ff18edff13227e89e691426f5838e2f303883909"},{"_id":"public/categories/oi/page/21/index.html","modified":1483685932042,"shasum":"c5ec7eaf3daf16cf5ea8541d19332a45c9fafa78"},{"_id":"public/categories/oi/page/22/index.html","modified":1483685932101,"shasum":"7a14afdf291c3628cd6bfedf273f8a273c486efa"},{"_id":"public/categories/oi/page/23/index.html","modified":1483685932157,"shasum":"65b2d2014623fb48247a80353412d1afd3566e85"},{"_id":"public/categories/oi/page/24/index.html","modified":1483685932208,"shasum":"906c101cf8b5305bb9ab149925f96f1130f8174a"},{"_id":"public/categories/oi/page/25/index.html","modified":1483685932249,"shasum":"6b1a03f7cd9e132f2a3949ab37e5e2615733f239"},{"_id":"public/categories/oi/page/26/index.html","modified":1483685932298,"shasum":"eb06861a7213c717152fd3c3a2a56b7225b2bb29"},{"_id":"public/categories/oi/page/27/index.html","modified":1483685932342,"shasum":"901bea21ce13acdca42e294821589405e0286750"},{"_id":"public/categories/oi/page/28/index.html","modified":1483685932384,"shasum":"3928ba492e5e5a0d70245ee6a537d6123baac367"},{"_id":"public/categories/oi/page/29/index.html","modified":1483685932432,"shasum":"87fd4199b88c272d87b5ce529866c5f1010dc418"},{"_id":"public/categories/oi/page/30/index.html","modified":1483685932459,"shasum":"429c63cbf898d9abf616c7fa4a4a1f9e697572dd"},{"_id":"public/categories/geek/index.html","modified":1483685932483,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/categories/diary/index.html","modified":1483685932511,"shasum":"f00725f23009a2257e3a60a5eda6a1ec660f8c99"},{"_id":"public/atom.xml","modified":1483692249800,"shasum":"6038a86a7f395c232643837b1c29bafc6d27a9c4"},{"_id":"public/index.html","modified":1483692248449,"shasum":"873956b22dcad6bb5300635f8d703fa549115b20"},{"_id":"public/page/2/index.html","modified":1483685932645,"shasum":"a2cc90e45ddc316ca2e5fb9f018de023853bf49e"},{"_id":"public/page/3/index.html","modified":1483685932715,"shasum":"f241e980b405105c68112ab35c5ace74a7bd4534"},{"_id":"public/page/4/index.html","modified":1483685932782,"shasum":"ffa17743e97601850e93a69da5c8721644d3475d"},{"_id":"public/page/5/index.html","modified":1483685932833,"shasum":"6d71822f97b6edf76bb7509fed2cc112711d1178"},{"_id":"public/page/6/index.html","modified":1483685932885,"shasum":"d1720dfea77771abb2e8242169d7f76bd9b4e0a4"},{"_id":"public/page/7/index.html","modified":1483685932929,"shasum":"23bb32c9e089d6ba7d80e09bdad92df74f79b36a"},{"_id":"public/page/8/index.html","modified":1483685932984,"shasum":"18635cdaaa89d5f601edcfbe73e6945fdf58fdf9"},{"_id":"public/page/9/index.html","modified":1483685933030,"shasum":"d06c73dbdfe5bbd7c80cfc198b91ba7c4d8dfad6"},{"_id":"public/page/10/index.html","modified":1483685933091,"shasum":"09fd7b5b43835e44750492386bdbc165857cbc23"},{"_id":"public/page/11/index.html","modified":1483685933143,"shasum":"1c557f009285b8e91e273cba647c4858dfeee68a"},{"_id":"public/page/12/index.html","modified":1483685933205,"shasum":"39cd45995c10a6848d58f199babd86993deb6868"},{"_id":"public/page/13/index.html","modified":1483685933259,"shasum":"a718491eeb515ce1c774f10aa6f89d6d9500d174"},{"_id":"public/page/14/index.html","modified":1483685933316,"shasum":"9e417fed068e31c4e2457cadafb7b933eb220655"},{"_id":"public/page/15/index.html","modified":1483685933363,"shasum":"fc41c575fe1701c9b1f5c2e4a656f44e69beb19d"},{"_id":"public/page/16/index.html","modified":1483685933415,"shasum":"b668fe4e732e800635a17803be440553780b38bc"},{"_id":"public/page/17/index.html","modified":1483685933477,"shasum":"0485aabf4db54d236d155b93461fa206766968fc"},{"_id":"public/page/18/index.html","modified":1483685933533,"shasum":"26bfdd74addd417231e6adf72f4b7411f47a3e34"},{"_id":"public/page/19/index.html","modified":1483685933603,"shasum":"3f391462e301a757bbc98ed36e3d5716ee1e9728"},{"_id":"public/page/20/index.html","modified":1483685933648,"shasum":"01346edc6463c93f4b0e7eae83a8fecba9549f28"},{"_id":"public/page/21/index.html","modified":1483685933711,"shasum":"2cf8b257295a1a863bf9944ed81ef640bd583ed4"},{"_id":"public/page/22/index.html","modified":1483685933771,"shasum":"0b50d295fdc58e9986d12c599196cb685892b322"},{"_id":"public/page/23/index.html","modified":1483685933828,"shasum":"045130cd2f48e97ad7f9a06fbfae9737dff6c6a2"},{"_id":"public/page/24/index.html","modified":1483685933873,"shasum":"bd9847c7254040718c6f9d161f221ac8f7365bba"},{"_id":"public/page/25/index.html","modified":1483685933934,"shasum":"c8f0b496691c4e8f6b9ae8217c066575c2ad723d"},{"_id":"public/page/26/index.html","modified":1483685933974,"shasum":"dcf364262e80e7f78958ea448475f5ce4e1b4156"},{"_id":"public/page/27/index.html","modified":1483685934018,"shasum":"964eaaafe48d9afc8e6b53b562ac97a0d8223eef"},{"_id":"public/page/28/index.html","modified":1483685934067,"shasum":"f7f55a32a9bc1b7531562c651c00ba4f5db078c1"},{"_id":"public/page/29/index.html","modified":1483685934107,"shasum":"2b21b00a3a0048c6e76acdeaf650aa77a2714e9a"},{"_id":"public/page/30/index.html","modified":1483685934139,"shasum":"e6a1465170dbeb08a50dc94672e1ac51476f1f07"},{"_id":"public/page/31/index.html","modified":1483685934167,"shasum":"ec97cf2afc545773351693c562003bb916c88ac0"},{"_id":"public/content.json","modified":1483692249821,"shasum":"fc2190cbee645774a7a8dbf7b020da5399820c6a"},{"_id":"public/sitemap.xml","modified":1483692249833,"shasum":"9b32b357d4669bd99de57206b4cc370a13fc99d2"},{"_id":"public/tag//index.html","modified":1483685934274,"shasum":"5f58435b690bc9d3492c38a13cef9c169684f71a"},{"_id":"public/tag//page/2/index.html","modified":1483685934297,"shasum":"beea4828671a18f19504d6cea8a5f312cc6a043f"},{"_id":"public/tag//index.html","modified":1483685934363,"shasum":"b14e8e3b2a67b9736ab2de036118b51913542f85"},{"_id":"public/tag//page/2/index.html","modified":1483685934376,"shasum":"a11857621c4a59a216a20b608ebae8b7f4c2beb7"},{"_id":"public/tag//index.html","modified":1483685934434,"shasum":"69f08884747f46a06869ae1d39dd44e72eacb248"},{"_id":"public/tag//index.html","modified":1483685934485,"shasum":"d8a7a977255a8e4970b83bb9ce8cde0bf2921550"},{"_id":"public/tag//page/2/index.html","modified":1483685934542,"shasum":"b35c14ad6f39d732a24e88fd79b7730aafb57878"},{"_id":"public/tag//page/3/index.html","modified":1483685934599,"shasum":"2c51bbc9892e5a5994757b26a9b12cfc7be5285d"},{"_id":"public/tag//page/4/index.html","modified":1483685934643,"shasum":"6b1a8bd4a41ede5ef1d3f9a898d7eb8fa2e34f34"},{"_id":"public/tag//page/5/index.html","modified":1483685934660,"shasum":"a3ad6b72bbafcd1cefa5731ee11d3afa6c1a6b84"},{"_id":"public/tag//index.html","modified":1483685934718,"shasum":"e02a01459c60b28bcdf7584d0e1413bd8d64a8dd"},{"_id":"public/tag//page/2/index.html","modified":1483685934742,"shasum":"8dd9bcc0bffb082e9b81271ef1d9f10b7db58f9b"},{"_id":"public/tag/bzoj/index.html","modified":1483685934800,"shasum":"2b1946dd9c9e31241359636304a773fd4030c0ad"},{"_id":"public/tag/bzoj/page/2/index.html","modified":1483685934874,"shasum":"4ef14b66ee955cc6d3687050b005feeb9c4d7ca8"},{"_id":"public/tag/bzoj/page/3/index.html","modified":1483685934932,"shasum":"2ea169ffe7bcde40ad00e74c77e1a9b88c3d5966"},{"_id":"public/tag/bzoj/page/4/index.html","modified":1483685934995,"shasum":"227ebebeac21bfbda314424d4ddc3b5405abd6ad"},{"_id":"public/tag/bzoj/page/5/index.html","modified":1483685935050,"shasum":"ccc33cbd31be46abcf877c641b701c57d2cee199"},{"_id":"public/tag/bzoj/page/6/index.html","modified":1483685935108,"shasum":"e2f0122e9fb93250dd7e6140c5cdf6ff2b4c2600"},{"_id":"public/tag/bzoj/page/7/index.html","modified":1483685935177,"shasum":"f40131614430737577006035f596a773d08beb81"},{"_id":"public/tag/bzoj/page/8/index.html","modified":1483685935247,"shasum":"68460ebff5090ba216bad990ffe400bc9d79a0db"},{"_id":"public/tag/bzoj/page/9/index.html","modified":1483685935322,"shasum":"15ed6a1187b37219a3e0be211ed4434ee2ba82df"},{"_id":"public/tag/bzoj/page/10/index.html","modified":1483685935387,"shasum":"a2e29aca98974c28ce6502f51f86c5ee90b2ae7c"},{"_id":"public/tag/bzoj/page/11/index.html","modified":1483685935462,"shasum":"117efef84536a855a5438cc9fe5c4b0bd1d05fc1"},{"_id":"public/tag/bzoj/page/12/index.html","modified":1483685935527,"shasum":"98e35c082eb165b698495995773446c473d9572d"},{"_id":"public/tag/bzoj/page/13/index.html","modified":1483685935609,"shasum":"29eba364c559322a60b113c9e95416f4e5333df1"},{"_id":"public/tag/bzoj/page/14/index.html","modified":1483685935687,"shasum":"d1b0af5b56d29f88e0563de6f545f82863898319"},{"_id":"public/tag/bzoj/page/15/index.html","modified":1483685935782,"shasum":"3b2ea1e57ee327b79a7914b889904722e85e22a2"},{"_id":"public/tag/bzoj/page/16/index.html","modified":1483685935872,"shasum":"1db334bb47846fb720381d83c41942afce50645b"},{"_id":"public/tag/bzoj/page/17/index.html","modified":1483685935954,"shasum":"33b15519bd6d0010eb09203897d585c0f8b432c7"},{"_id":"public/tag/bzoj/page/18/index.html","modified":1483685936022,"shasum":"9f454a75d1d7ad2c9a128174b18113f61a71fccd"},{"_id":"public/tag/bzoj/page/19/index.html","modified":1483685936078,"shasum":"2a5407d3d6e54e058106885705b8efd5f835806a"},{"_id":"public/tag/zjoi/index.html","modified":1483685936157,"shasum":"813ee49ba031180c8b69bd35184f04b700137b04"},{"_id":"public/tag/zjoi/page/2/index.html","modified":1483685936182,"shasum":"574979e328d79b68e88abd5728af8b823db46334"},{"_id":"public/tag/fft/index.html","modified":1483685936245,"shasum":"71eb8470923c246ba2bdcd4cc034d3419111f4dc"},{"_id":"public/tag//index.html","modified":1483692251405,"shasum":"2a2177d6894e3166042b8b0555201cf5ef786366"},{"_id":"public/tag//page/2/index.html","modified":1483685936391,"shasum":"265145c88971b0521dc0c3d09c0dc57b313f5c93"},{"_id":"public/tag//page/3/index.html","modified":1483685936494,"shasum":"4d0f86012573fee5b898361592b966bb30ffcea1"},{"_id":"public/tag//page/4/index.html","modified":1483685936570,"shasum":"d598d47b11afade1cf2ab0bf9b299a44790af6d8"},{"_id":"public/tag//page/5/index.html","modified":1483685936587,"shasum":"993a46505e2316b26d32aca319ab94f42bd61f2c"},{"_id":"public/tag//index.html","modified":1483685936687,"shasum":"0051d8c18fbb9ca3aa442c13e1e212df3f88bdee"},{"_id":"public/tag//page/2/index.html","modified":1483685936832,"shasum":"e9bad10585de329b81e030722927d22c122a7dcc"},{"_id":"public/tag//page/3/index.html","modified":1483685936910,"shasum":"88c94ce494df25bdba624433e62ba2b0d96adfb0"},{"_id":"public/tag//page/4/index.html","modified":1483685936965,"shasum":"c89da73ec53c1579d0f8bbbfc18da5a70a752e0c"},{"_id":"public/tag//page/5/index.html","modified":1483685936996,"shasum":"62f7cdd373fd541afa1f10a6322906422a6a59d8"},{"_id":"public/tag/dinic/index.html","modified":1483685937048,"shasum":"3c61ed769dbd7d17938e667d500276191c1dfbac"},{"_id":"public/tag/dinic/page/2/index.html","modified":1483685937110,"shasum":"70d0336200615b0834ecd765609591456bb6a587"},{"_id":"public/tag/dinic/page/3/index.html","modified":1483685937159,"shasum":"727fc956545747c25ee52d3f99332ff0d5485e15"},{"_id":"public/tag/dinic/page/4/index.html","modified":1483685937179,"shasum":"311f259db5bc5ca33d12e17889d4b1dc9acdb6bf"},{"_id":"public/tag//index.html","modified":1483685937241,"shasum":"11ea6aaa7d227ac7aeb198ea1ee38783082cc474"},{"_id":"public/tag//page/2/index.html","modified":1483685937258,"shasum":"27a2f3d2f8da661d04346ecec27c0a290d7de608"},{"_id":"public/tag/edmonds-karp/index.html","modified":1483685937323,"shasum":"ba291313b5aa4cc8d33c56d2aa129cfab3511dd7"},{"_id":"public/tag/edmonds-karp/page/2/index.html","modified":1483685937341,"shasum":"27a2f3d2f8da661d04346ecec27c0a290d7de608"},{"_id":"public/tag//index.html","modified":1483685937410,"shasum":"b9a7ff1c9b7bc6de65d929349a812a462eb812bf"},{"_id":"public/tag//page/2/index.html","modified":1483685937455,"shasum":"c10e74d68b470c531474b0771509011aa1b345e8"},{"_id":"public/tag/dp/index.html","modified":1483685937514,"shasum":"e2d8fe5f87a937ccd7d2f5533d0439e200419bd2"},{"_id":"public/tag/dp/page/2/index.html","modified":1483685937587,"shasum":"86c033bf6660ba0c069d953d92c0f8a566b8a1ad"},{"_id":"public/tag/dp/page/3/index.html","modified":1483685937633,"shasum":"14a3fca6f2d7eca0daa6d5134dc95d49ddb5142d"},{"_id":"public/tag/dp/page/4/index.html","modified":1483685937691,"shasum":"3ee74a2b8b28d14b757036dabbf69001bbdc16bb"},{"_id":"public/tag/dp/page/5/index.html","modified":1483685937746,"shasum":"1ad5072fa7ec04813ca41785362f4a0a537c95ff"},{"_id":"public/tag/dp/page/6/index.html","modified":1483685937788,"shasum":"5026da19a01d0b16d5a626018213b2f5355c9ef1"},{"_id":"public/tag/dp/page/7/index.html","modified":1483685937833,"shasum":"b56a7e826079a376fa19867977a13d68ec978c69"},{"_id":"public/tag//index.html","modified":1483685937885,"shasum":"b88fe394f5f18456115e19b9879b030d17cf1ec8"},{"_id":"public/tag//page/2/index.html","modified":1483685937897,"shasum":"8febeadd742d484e06a00c7a8ed64eb8d22af476"},{"_id":"public/tag/cogs/index.html","modified":1483685937963,"shasum":"ee98537e6c5855eae6e0d11455577a08c9a3a035"},{"_id":"public/tag/cogs/page/2/index.html","modified":1483685938025,"shasum":"96c4b0763f0c8ff50edd57ed3e833659edef099b"},{"_id":"public/tag/cogs/page/3/index.html","modified":1483685938080,"shasum":"c844a23d12e6af4b14cab757cb85a290954196cc"},{"_id":"public/tag/cogs/page/4/index.html","modified":1483685938115,"shasum":"58f09590ce563f936aa603e3fb96f619d5498bf8"},{"_id":"public/tag//index.html","modified":1483685938138,"shasum":"23e2560a8cc824a39e7105166716f12d6b42d109"},{"_id":"public/tag//index.html","modified":1483685938151,"shasum":"f95af89f51e59d956a4d3148fe5685600d01c2a4"},{"_id":"public/tag//index.html","modified":1483685938204,"shasum":"85f0bd205cb86899c8c257cae47f81b6b3708816"},{"_id":"public/tag//index.html","modified":1483685938259,"shasum":"dd37ea86615313a54518067423a6e5b3777368be"},{"_id":"public/tag//page/2/index.html","modified":1483685938271,"shasum":"7b1f426df73fffe88a86fdaf686167fb5c72e1ef"},{"_id":"public/tag//index.html","modified":1483685938312,"shasum":"3654e8ab504f83cff5218b1fd0ca8719c24fc5cb"},{"_id":"public/tag/tarjan/index.html","modified":1483685938364,"shasum":"483eac283d9a65810cd5f02593d9d96e16e25a13"},{"_id":"public/tag/tarjan/page/2/index.html","modified":1483685938392,"shasum":"3b5226c35881143dea177572bd9853b73bd02d01"},{"_id":"public/tag//index.html","modified":1483685938446,"shasum":"e79aa0eceba7eb1ca291ca65abba964bbca2c39b"},{"_id":"public/tag//index.html","modified":1483685938458,"shasum":"189750cf640f2b2f568bc614bb0f93a1256e3801"},{"_id":"public/tag//index.html","modified":1483685938511,"shasum":"09bf83bc09a701088f4d56facecfb86178d09767"},{"_id":"public/tag//index.html","modified":1483685938545,"shasum":"e9e59a3dc5a0acdf9c511f726c23773a89402a31"},{"_id":"public/tag/os-x/index.html","modified":1483685938573,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/linux/index.html","modified":1483685938585,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/archlinux/index.html","modified":1483685938608,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/virtualbox/index.html","modified":1483685938619,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag//index.html","modified":1483685938641,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/ssh/index.html","modified":1483685938652,"shasum":"0e069c793f0ab311fe0bbdf741ca72782cd7c7b3"},{"_id":"public/tag/uva/index.html","modified":1483685938700,"shasum":"4e977cc8902a347211920af9fc8a7f19f2abf767"},{"_id":"public/tag/-dp/index.html","modified":1483685938720,"shasum":"02579bdc4e2c12fe2bfb8ed660cedaa1330b5203"},{"_id":"public/tag//index.html","modified":1483685938760,"shasum":"9519441d018012db4db5d0764f8f26ede15ac68a"},{"_id":"public/tag//index.html","modified":1483685938792,"shasum":"8b88b0a7b3f2b68955b9967a6791f35f37f34a09"},{"_id":"public/tag//index.html","modified":1483685938817,"shasum":"c34eac53ddf9134f075dc333b6ade28f9835e76d"},{"_id":"public/tag//index.html","modified":1483685938860,"shasum":"71aeb97f8512c40dfa9ff83dafc8589a1ea742b0"},{"_id":"public/tag//index.html","modified":1483685938883,"shasum":"e39d7ffd890dba6f906360190df199f043d037da"},{"_id":"public/tag/-dp/index.html","modified":1483685938924,"shasum":"103e322523445a4eb741a4d3ee09c847f60e01c5"},{"_id":"public/tag//index.html","modified":1483685938989,"shasum":"9f7293f51c522e3474a43f7e29ba1c328029bbe2"},{"_id":"public/tag//page/2/index.html","modified":1483685939013,"shasum":"8f2618a2e98ddd6fbb4085dc0e09d50913171909"},{"_id":"public/tag//index.html","modified":1483685939048,"shasum":"3d49ad662946db8083400e4961021b6bb81d3813"},{"_id":"public/tag//index.html","modified":1483685939066,"shasum":"afc073d4ce11398490cf26a8a2d085f5151d83cb"},{"_id":"public/tag/-dp/index.html","modified":1483685939127,"shasum":"c41a8d72b11e1c5c19bff23e3bb9df63a5586443"},{"_id":"public/tag/-dp/page/2/index.html","modified":1483685939143,"shasum":"81e7aa9bff8639659857306a5ce9233aea65cef7"},{"_id":"public/tag//index.html","modified":1483685939179,"shasum":"77c795b0ec5d468151dfebb9172944a796a00aba"},{"_id":"public/tag//index.html","modified":1483685939226,"shasum":"2c3aa6296271a5d5e04784f51dfc3be88a22d13c"},{"_id":"public/tag//index.html","modified":1483685939239,"shasum":"dd7b750ea4b04961bf8b2536af71d191fac94e54"},{"_id":"public/tag//index.html","modified":1483685939262,"shasum":"dd7b750ea4b04961bf8b2536af71d191fac94e54"},{"_id":"public/tag/codevs/index.html","modified":1483685939320,"shasum":"c855d9e4f5f7c1c1833e0f40a5e28aa9f3038c36"},{"_id":"public/tag/codevs/page/2/index.html","modified":1483685939380,"shasum":"f33158cea45a6e3e6b83ecd648f71038343491ab"},{"_id":"public/tag/codevs/page/3/index.html","modified":1483685939409,"shasum":"32fe931ec38673032bd4ef95d9588f6982ce7bbc"},{"_id":"public/tag/codevs/page/4/index.html","modified":1483685939474,"shasum":"37a9c03d9f12502d4ebc7f8f611691d3f70eae17"},{"_id":"public/tag/codevs/page/5/index.html","modified":1483685939493,"shasum":"b9b5224de9dfca39a0015feee6e2aaf8355ad31c"},{"_id":"public/tag/tyvj/index.html","modified":1483685939538,"shasum":"a9a6cbcd7684d4dd150a8fb4fb685ee084333c34"},{"_id":"public/tag/-dp/index.html","modified":1483685939566,"shasum":"16f4d17d57d9ab288bd17cb059915fb2aa4019ab"},{"_id":"public/tag//index.html","modified":1483692253811,"shasum":"144e7b76ed96ac1280fea2d115ee386105308d8b"},{"_id":"public/tag//page/2/index.html","modified":1483685939648,"shasum":"fc4ce4405655712d365462a17940ed117fceee0f"},{"_id":"public/tag//page/3/index.html","modified":1483685939677,"shasum":"666fea8dec323ae9c803aa92488dc54e55478a0f"},{"_id":"public/tag/tjoi/index.html","modified":1483685939708,"shasum":"b98f6b96cabcf2347c571d068d0ecdad0a63ceb0"},{"_id":"public/tag/-dp/index.html","modified":1483685939733,"shasum":"75a6d0a6a3956ed48a4ac6d284a0eb6ffec2831f"},{"_id":"public/tag//index.html","modified":1483685939786,"shasum":"9eea440938006f318adf1ed8cb21337c0a84ed53"},{"_id":"public/tag//page/2/index.html","modified":1483685939834,"shasum":"cb428b322d7390f6c9af577dc37cb7e0df82cb0d"},{"_id":"public/tag//page/3/index.html","modified":1483685939891,"shasum":"ad3a9ffa08ffcb3ca207048c0f4d1b74d2bf67eb"},{"_id":"public/tag//page/4/index.html","modified":1483685939905,"shasum":"cb0756c2102520a3b864bb55ac7524501acfab7f"},{"_id":"public/tag/ac-/index.html","modified":1483685939958,"shasum":"9cea2862a841bf2a94db788b16b48452bd3cd3a1"},{"_id":"public/tag/ac-/page/2/index.html","modified":1483685939972,"shasum":"d8ad219c3e2e4a097a4afec69aa4e02f07dc2f02"},{"_id":"public/tag//index.html","modified":1483685940016,"shasum":"016fce1f93f999298976b7f6e0c2563488531d9e"},{"_id":"public/tag/splay/index.html","modified":1483685940070,"shasum":"79d7d747c076cde4c0031279c540ff365e03901c"},{"_id":"public/tag/splay/page/2/index.html","modified":1483685940085,"shasum":"84bf1f6d4bf33476aadb203c9ec476ec1840fea2"},{"_id":"public/tag//index.html","modified":1483685940148,"shasum":"c7e0ab350d945d88c738352ab86069fba18003d3"},{"_id":"public/tag//page/2/index.html","modified":1483685940161,"shasum":"b010db9d13248e5040fd893bdb222233ef856d7a"},{"_id":"public/tag//index.html","modified":1483692254230,"shasum":"04d17185f1e6f950818f3681f29f9e1e97687f3e"},{"_id":"public/tag//page/2/index.html","modified":1483685940249,"shasum":"27c8bcf77189722eaf2f6dd848f9664bcc271d08"},{"_id":"public/tag//page/3/index.html","modified":1483685940291,"shasum":"b67e702566ef1a66d68f9f455c3f68c266ed77b0"},{"_id":"public/tag//index.html","modified":1483685940337,"shasum":"e9b96996f260a259ee7161e25f4c20fa23056060"},{"_id":"public/tag//page/2/index.html","modified":1483685940381,"shasum":"68c812bc42ab3dd2a39ebfab33059ee27f7e028b"},{"_id":"public/tag//page/3/index.html","modified":1483685940436,"shasum":"c4b1d300a5cb02135c4c52e5e0efc0517dae506f"},{"_id":"public/tag//page/4/index.html","modified":1483685940463,"shasum":"346497ac4f8f8a8c4773304bbd7155bfdd11607e"},{"_id":"public/tag//index.html","modified":1483685940498,"shasum":"840fcbe1fbfeb2780b5cd79ffa29a57592da7faf"},{"_id":"public/tag//index.html","modified":1483685940522,"shasum":"cb634887742bb595400a168202de21de92bfb4d0"},{"_id":"public/tag//index.html","modified":1483685940540,"shasum":"8474251a0845b684ed93b40a2abc23e4456e5b48"},{"_id":"public/tag//index.html","modified":1483685940576,"shasum":"a77ba0e0dd9cce1359e6cb14858ffda4b43ededd"},{"_id":"public/tag//index.html","modified":1483685940636,"shasum":"d801a355ec0e34b20fce184a5e7b91134a19d0cc"},{"_id":"public/tag//page/2/index.html","modified":1483685940650,"shasum":"054e39143ed6bddc4a11e83860f0a3ee93e273bf"},{"_id":"public/tag//index.html","modified":1483685940666,"shasum":"26d38fcf3575811c00b0e9a83dd3327068d99845"},{"_id":"public/tag/c/index.html","modified":1483685940686,"shasum":"1fad7df1628d8c1308b88a46a7626dbc14536948"},{"_id":"public/tag/stl/index.html","modified":1483685940717,"shasum":"f50e6eff40c18880739d338bd7b1e779c8c895b8"},{"_id":"public/tag/spoj/index.html","modified":1483685940733,"shasum":"baa5a6b0f6b1513f2dc9609ae304c65c62a5ead5"},{"_id":"public/tag/shoi/index.html","modified":1483685940771,"shasum":"53df0cd7d717d064929e77eda0764b0bb462b1c7"},{"_id":"public/tag//index.html","modified":1483685940789,"shasum":"21097c7afb2c5a4d34a4d61c0f947da2f8f8fd70"},{"_id":"public/tag//index.html","modified":1483685940805,"shasum":"53fd0f9629b5c04694a379090cc4f2267b1d0732"},{"_id":"public/tag/cdq/index.html","modified":1483685940850,"shasum":"91f1c39abf42c77454046c59076eb8222199b1ce"},{"_id":"public/tag//index.html","modified":1483685940894,"shasum":"68f77acf9380e8c5aca86fca6a740efc28c5bff1"},{"_id":"public/tag/sdoi/index.html","modified":1483685940950,"shasum":"0c38b9210afafacb1638992628982f1454f79c80"},{"_id":"public/tag/sdoi/page/2/index.html","modified":1483685941006,"shasum":"23695f900eea590e7c28218e1bd1292b28c25717"},{"_id":"public/tag//index.html","modified":1483685941031,"shasum":"3f2c8d01cbc894521eafceb1822dde3110f8b926"},{"_id":"public/tag//index.html","modified":1483685941052,"shasum":"3f2c8d01cbc894521eafceb1822dde3110f8b926"},{"_id":"public/tag//index.html","modified":1483685941082,"shasum":"70eec66492298319d9691c2965e3a5c7e9178b07"},{"_id":"public/tag//index.html","modified":1483685941119,"shasum":"1dbe02a85e44154406ce1ecec972b4b138b437a9"},{"_id":"public/tag//index.html","modified":1483685941149,"shasum":"cb90b55aa5616e1b16ae67b5637f71cfe243cb26"},{"_id":"public/tag//index.html","modified":1483685941183,"shasum":"167b30790f403904a370beb5ddf9526d2d8ed893"},{"_id":"public/tag//index.html","modified":1483685941232,"shasum":"27d6e3ae21567cf9d4ddf3394f43502290752b1a"},{"_id":"public/tag/rmq/index.html","modified":1483685941264,"shasum":"71018e897e83d33950bae1cdbd2df2ae666dc22f"},{"_id":"public/tag//index.html","modified":1483685941307,"shasum":"a9ca05181edbe18f5455e484cc35c51c0841874b"},{"_id":"public/tag//index.html","modified":1483685941338,"shasum":"7e1004df80c3992def22c47e3811838d82368e05"},{"_id":"public/tag/ntt/index.html","modified":1483685941375,"shasum":"1f790c27dcc94444cf3ff7f5cf262c1ef7e6f596"},{"_id":"public/tag//index.html","modified":1483685941413,"shasum":"1f790c27dcc94444cf3ff7f5cf262c1ef7e6f596"},{"_id":"public/tag//index.html","modified":1483685941449,"shasum":"b26d46102f4a18e501c16b49401084d67079b7ef"},{"_id":"public/tag//index.html","modified":1483685941481,"shasum":"ecff6d16b0d35ab8eee1fefbf5f29bdc070a0b71"},{"_id":"public/tag//index.html","modified":1483685941532,"shasum":"dd9af0391dd4bd215c42b4dd8cddd953ab988d7a"},{"_id":"public/tag//index.html","modified":1483685941561,"shasum":"1878cda2857935ca110a833f27d09ed416aee61f"},{"_id":"public/tag//index.html","modified":1483685941584,"shasum":"43e4a1809abe90b4baa89213da9f750e1976090f"},{"_id":"public/tag/exgcd/index.html","modified":1483685941605,"shasum":"061d80bb11e324802f8e857038a080e8ad1a6e82"},{"_id":"public/tag/bsgs/index.html","modified":1483685941653,"shasum":"07441a40bd3246276e19e25f1f6999bd911d02a8"},{"_id":"public/tag//index.html","modified":1483685941684,"shasum":"34c2946d64c32be95f758a3b624226ddf7076e41"},{"_id":"public/tag/link-cut-tree/index.html","modified":1483685941709,"shasum":"d15843ec388fa33965f6b391b1bd4011a4e7d8d7"},{"_id":"public/tag/scoi/index.html","modified":1483685941767,"shasum":"134955ae3b78ba83f09e73bc8389b2f4ba382de9"},{"_id":"public/tag/scoi/page/2/index.html","modified":1483685941811,"shasum":"4af1c3c8292c3f5399c886c467deb328baff7f45"},{"_id":"public/tag/set/index.html","modified":1483685941829,"shasum":"22c3ae9ec64154c6827ae22e9690d682aa7a1e93"},{"_id":"public/tag//index.html","modified":1483685941862,"shasum":"ccc6e294c65b2955a28fbd7a7912746cb1dc44f9"},{"_id":"public/tag//index.html","modified":1483685941896,"shasum":"99fa093fc24cfba681a1f9c6b72e0118a184a512"},{"_id":"public/tag/-dp/index.html","modified":1483685941933,"shasum":"591f823cf61b4fd4b244424aae2d2b38838850b4"},{"_id":"public/tag//index.html","modified":1483685941964,"shasum":"0b4bf641763f2ab020727c8c47c4c849ae1e59f5"},{"_id":"public/tag//index.html","modified":1483685941983,"shasum":"e93b625fa50faaeb605fcd933ccccfe7f8123cc2"},{"_id":"public/tag//index.html","modified":1483685942002,"shasum":"d79d1357db8aa78ff98add77be6d2e3d6968a76c"},{"_id":"public/tag//index.html","modified":1483685942022,"shasum":"aef74405a5caa9bd8600e9e5f69bb18ed07368e8"},{"_id":"public/tag//index.html","modified":1483685942047,"shasum":"4de6bf60ac40d5d246cccf3eabec6d3481999185"},{"_id":"public/tag//index.html","modified":1483685942110,"shasum":"a596ca49ac22663932fa38f282904d33eaf655e7"},{"_id":"public/tag/dfs/index.html","modified":1483685942137,"shasum":"2a42941cc13ae99b3851e2353a171dc31875dc41"},{"_id":"public/tag//index.html","modified":1483685942151,"shasum":"f0abf9c2df47b578bf5e25cafd0343caf1e482ea"},{"_id":"public/tag//index.html","modified":1483685942205,"shasum":"49d4aaa6c0e8f98bf5ab8eadd34a12753aed518b"},{"_id":"public/tag/poj/index.html","modified":1483685942244,"shasum":"fa524eee7c29f0172134b85a830324151ce86d3d"},{"_id":"public/tag/trie/index.html","modified":1483685942268,"shasum":"0b462c1a0c9bcc6638f19a2061a346224737db5b"},{"_id":"public/tag/kmp/index.html","modified":1483685942296,"shasum":"6ecaddf46f079e9dec410f20c86a821f9c707821"},{"_id":"public/tag/prim/index.html","modified":1483685942311,"shasum":"a982772555ac4e4fe2319d34a19440a58bd155c8"},{"_id":"public/tag//index.html","modified":1483685942333,"shasum":"0536163740b856f6bf8329ad8326de1202f56412"},{"_id":"public/tag//index.html","modified":1483685942365,"shasum":"0536163740b856f6bf8329ad8326de1202f56412"},{"_id":"public/tag/poi/index.html","modified":1483685942398,"shasum":"63e4d34284d8ff84e5be6ae9ebc1d107f27e3499"},{"_id":"public/tag/noip/index.html","modified":1483685942464,"shasum":"d77b5a1bff4893ebfe18f76dae47cf569b2ceb1b"},{"_id":"public/tag/noip/page/2/index.html","modified":1483685942527,"shasum":"f07bafadc0b94724d6b72ad06354e7246b58bb6e"},{"_id":"public/tag/noip/page/3/index.html","modified":1483685942549,"shasum":"1d488081d07668fad3ff9159df5c2035f43c93e5"},{"_id":"public/tag//index.html","modified":1483685942585,"shasum":"d40d1d8420e034273d8c4872fdb1632891f0a7da"},{"_id":"public/tag//index.html","modified":1483685942622,"shasum":"b3e7c0d3e166f3768c605e77193a321204994034"},{"_id":"public/tag/floyd/index.html","modified":1483685942654,"shasum":"8ab760e48b22e3e0aff9a5550c6eb016aea25221"},{"_id":"public/tag//index.html","modified":1483685942680,"shasum":"16be2f373f17dbbf056e90324cf274f127357df1"},{"_id":"public/tag/bfs/index.html","modified":1483685942726,"shasum":"90bb6a4c6951b72d34903127601cab359ab11f4c"},{"_id":"public/tag/hash/index.html","modified":1483685942762,"shasum":"035ed236af25d1be829c48ab8e2d04a7be53a24b"},{"_id":"public/tag/spfa/index.html","modified":1483685942788,"shasum":"e21a2a0232e8e8b3d34f07d617932d3d3d7b1060"},{"_id":"public/tag//index.html","modified":1483685942806,"shasum":"0c63acf46a9fa351a07a65cf326508fcb06d9b1d"},{"_id":"public/tag//index.html","modified":1483685942832,"shasum":"d0955287996e2fa526b4b4295f1157847a80c4e8"},{"_id":"public/tag//index.html","modified":1483685942857,"shasum":"7913e5f149506654603af1b3aeddb01b731aac8a"},{"_id":"public/tag/vijos/index.html","modified":1483685942874,"shasum":"9198a662d1cb35280f385c6bb48839d7758219de"},{"_id":"public/tag//index.html","modified":1483685942905,"shasum":"b274e5827e9cb7840080391f7ed4374f29d4ff66"},{"_id":"public/tag//index.html","modified":1483685942929,"shasum":"130688381acff964236ecb65853ceb2406a08d94"},{"_id":"public/tag/-dp/index.html","modified":1483685942954,"shasum":"6ebadf649f07b966f6efa43e0f96a24233705b7e"},{"_id":"public/tag/noi/index.html","modified":1483685943013,"shasum":"f4f509363bb306dc2cadaa9960dc6bdd6230e341"},{"_id":"public/tag/noi/page/2/index.html","modified":1483685943076,"shasum":"572c8635179586b908cc233d985b6b03fc391cc1"},{"_id":"public/tag//index.html","modified":1483685943092,"shasum":"d3db6035cb213f2d5c4afd0fb30b43821c68a252"},{"_id":"public/tag//index.html","modified":1483685943104,"shasum":"27aa027e1dab98268597b02fe90b1474ed30ea14"},{"_id":"public/tag/map/index.html","modified":1483685943135,"shasum":"5776e09eebc510cc53860a09d695d7aa161ebc80"},{"_id":"public/tag//index.html","modified":1483685943171,"shasum":"fa8d0661d6ee727bb4b50f27982fc3270f1e3b1b"},{"_id":"public/tag//index.html","modified":1483685943196,"shasum":"e052180b0b200b7856f9993726971a58d889744f"},{"_id":"public/tag//index.html","modified":1483685943219,"shasum":"e052180b0b200b7856f9993726971a58d889744f"},{"_id":"public/tag/lct/index.html","modified":1483685943241,"shasum":"39265bc35b5e1619e5f537fc2abfba2382354dc8"},{"_id":"public/tag//index.html","modified":1483685943272,"shasum":"d28c4ae73c9f2c7ec04a92cd3ac6b8945395cf45"},{"_id":"public/tag//index.html","modified":1483685943288,"shasum":"d28c4ae73c9f2c7ec04a92cd3ac6b8945395cf45"},{"_id":"public/tag//index.html","modified":1483685943345,"shasum":"d79a58347720871fe21770354f7b72717948f03d"},{"_id":"public/tag//index.html","modified":1483685943382,"shasum":"99f76d55738d69a678c1fe13890248a5b4358061"},{"_id":"public/tag//index.html","modified":1483685943421,"shasum":"7615782432a0ce79f7a8c7915048b6a46b9f08a9"},{"_id":"public/tag/kruskal/index.html","modified":1483685943433,"shasum":"6459a03343428a3998af8226feeca06efae15ab5"},{"_id":"public/tag//index.html","modified":1483685943466,"shasum":"2ef2bcc9175bc07a127573c4d0ff634cb580040f"},{"_id":"public/tag/manacher/index.html","modified":1483685943488,"shasum":"2e360bc100ead1f603e2feb99cdfcf01f4acfb31"},{"_id":"public/tag/jsoi/index.html","modified":1483685943534,"shasum":"1097533ea7f360c30f04ea3bd68d377c13909067"},{"_id":"public/tag/jsoi/page/2/index.html","modified":1483685943563,"shasum":"53c0e6e76931128ec08baec7eeaf81cb0b336527"},{"_id":"public/tag//index.html","modified":1483685943595,"shasum":"4eb389e071bd1bc2892ecc5c84529a519433817d"},{"_id":"public/tag//index.html","modified":1483685943612,"shasum":"4cc251649b6d3ef3d73ddd76bfe41beac7d1da88"},{"_id":"public/tag//index.html","modified":1483685943632,"shasum":"7ad9a4a8b8dbb7fb2a5db19962485c5a629f0911"},{"_id":"public/tag/ioi/index.html","modified":1483685943648,"shasum":"a8aeba768535fa5402f49c970a1731d3035c7895"},{"_id":"public/tag//index.html","modified":1483685943665,"shasum":"8c836b53da49442dc14c9ffb0377e12174c2f31e"},{"_id":"public/tag/hnoi/index.html","modified":1483685943713,"shasum":"825b8087d49b1626cefd078f9e0816a8de41e339"},{"_id":"public/tag/hnoi/page/2/index.html","modified":1483685943759,"shasum":"36b40f5b8885e0f1f86a7de0663dc70d528a6b69"},{"_id":"public/tag/dfs-/index.html","modified":1483685943776,"shasum":"b5b80bff237cf98ce369d89d76b0649626806002"},{"_id":"public/tag/prufer-/index.html","modified":1483685943792,"shasum":"b1aa289e181b2b399433552fdd6f58842ba8954e"},{"_id":"public/tag//index.html","modified":1483685943810,"shasum":"07d8f6e657293e57a8d750319fb4c16416392872"},{"_id":"public/tag//index.html","modified":1483685943823,"shasum":"07d8f6e657293e57a8d750319fb4c16416392872"},{"_id":"public/tag/burnside-/index.html","modified":1483685943849,"shasum":"14f6560c28bca2c9e8ed8c57b7c81699b6dff36d"},{"_id":"public/tag/heoi/index.html","modified":1483685943878,"shasum":"96c29b7ffa3be2cf0116891aed33518995a032e1"},{"_id":"public/tag/hdu/index.html","modified":1483685943904,"shasum":"edc6e18925e4a9c6e67ced827ad5dab2a281667d"},{"_id":"public/tag/bestcoder/index.html","modified":1483685943923,"shasum":"ce22709a8f3eff2deabab41fd755933ad8c9e14d"},{"_id":"public/tag/haoi/index.html","modified":1483685943979,"shasum":"4f394d40a353f8eba0d8c438b8116f4dd9e5fa4a"},{"_id":"public/tag/haoi/page/2/index.html","modified":1483685944026,"shasum":"1d3d6c5c53146239e44331ef5fd39bb3d4aa0d3d"},{"_id":"public/tag//index.html","modified":1483685944042,"shasum":"78a69b38c9cdf5e1b73f920af47de5e5ec28a644"},{"_id":"public/tag/gdb/index.html","modified":1483685944052,"shasum":"e7cb8f4e7bd974950f709c7fb42d271bd0900673"},{"_id":"public/tag//index.html","modified":1483685944073,"shasum":"e7cb8f4e7bd974950f709c7fb42d271bd0900673"},{"_id":"public/tag//index.html","modified":1483692256801,"shasum":"885f815179bb25055be006b4d3735bf9355d2a5b"},{"_id":"public/tag/fjoi/index.html","modified":1483685944113,"shasum":"48e35c94f8e4cfd47ee7199b5710fec82e126994"},{"_id":"public/tag//index.html","modified":1483685944133,"shasum":"a2cd2e5cc1334caede534007ed88e0a3e08674d9"},{"_id":"public/tag//index.html","modified":1483685944159,"shasum":"d703b8662a031d03d6376e0b024a30f11c7177ce"},{"_id":"public/tag/docker/index.html","modified":1483685944180,"shasum":"6b6a6c7584ed5e9512450fd000dcf2c97b2eef4e"},{"_id":"public/tag//index.html","modified":1483685944192,"shasum":"6b6a6c7584ed5e9512450fd000dcf2c97b2eef4e"},{"_id":"public/tag/ctsc/index.html","modified":1483685944215,"shasum":"d41eee9936e21e63aab7785870532933655843d6"},{"_id":"public/tag/-24-/index.html","modified":1483685944256,"shasum":"6a23dd62f3f6e4c7d7d6fff93e59765564821011"},{"_id":"public/tag/-24-/page/2/index.html","modified":1483685944299,"shasum":"421fb1bd83bc49c06211ab44276679c1ae4673dc"},{"_id":"public/tag/cqoi/index.html","modified":1483685944332,"shasum":"564f467d9efbdd3914bdf43db26f1dd494bb3cc6"},{"_id":"public/tag//index.html","modified":1483685944356,"shasum":"b8bb12c555897d061051e59d7cd4428693d0afaf"},{"_id":"public/tag//index.html","modified":1483685944377,"shasum":"ac948f3878b316ace63d160b9bada0a4dcf789af"},{"_id":"public/tag/usaco/index.html","modified":1483685944425,"shasum":"9e2fab0ba97735170dab52865aae2081a8247905"},{"_id":"public/tag/coci/index.html","modified":1483685944457,"shasum":"7a9c84077bf01c3a6c952f133742bb249575afbd"},{"_id":"public/tag//index.html","modified":1483685944481,"shasum":"7a9c84077bf01c3a6c952f133742bb249575afbd"},{"_id":"public/tag/codeforces/index.html","modified":1483685944507,"shasum":"e5178ea18c6fe7518f31e93077e078c9a82655f2"},{"_id":"public/tag/ceoi/index.html","modified":1483685944523,"shasum":"d2c014e5b222cfa4ecd977d16c47fba968d8f6f1"},{"_id":"public/tag/lucas-/index.html","modified":1483685944544,"shasum":"5ce385a91d2c5f1b35883444942961254be72259"},{"_id":"public/tag//index.html","modified":1483685944558,"shasum":"0e189446148943e1efc7a32b0d67431bfd6c2772"},{"_id":"public/tag//index.html","modified":1483685944577,"shasum":"4cfab61b0b9962c0fce8d6feff0d4ee079d8ee01"},{"_id":"public/tag//index.html","modified":1483685944600,"shasum":"0fbeed93bce146e96f44dcb07242cedbdcb4fc9c"},{"_id":"public/tag/dijkstra/index.html","modified":1483685944623,"shasum":"e198980356554d1075ba918732eb6d08598676c8"},{"_id":"public/tag//index.html","modified":1483685944635,"shasum":"c9293b2d42b7a9399260d3108d48d72c51c8a977"},{"_id":"public/tag//index.html","modified":1483685944653,"shasum":"c2dfc5584f2d6e37524dbcc35ba7398ceac2507c"},{"_id":"public/tag/apio/index.html","modified":1483685944684,"shasum":"32efe5cea670fd6c4b8d3b247b4757f915361a2a"},{"_id":"public/tag//index.html","modified":1483685944703,"shasum":"707525a087c9c5b4bcd8fde4dc4321312d88dfb5"},{"_id":"public/tag/dag/index.html","modified":1483685944731,"shasum":"c2e19ea4663cde9dcb7aa18bbd38708fff506321"},{"_id":"public/tag//index.html","modified":1483685944748,"shasum":"c2e19ea4663cde9dcb7aa18bbd38708fff506321"},{"_id":"public/tag/bellman-ford/index.html","modified":1483685944766,"shasum":"c2e19ea4663cde9dcb7aa18bbd38708fff506321"},{"_id":"public/tag/ahoi/index.html","modified":1483685944798,"shasum":"652ffd7955972725e090b3f27d229605972f5bbe"},{"_id":"public/tag//index.html","modified":1483685944825,"shasum":"01a608007570645975bcbc6bc4765a60749b68bc"},{"_id":"public/tag//index.html","modified":1483685944846,"shasum":"7685ef1b518b984d6c08f868d6cc1441a251f76e"},{"_id":"public/tag//index.html","modified":1483685944870,"shasum":"7685ef1b518b984d6c08f868d6cc1441a251f76e"},{"_id":"public/tag//index.html","modified":1483685944897,"shasum":"4cfa5bcb09f1ee97699ed4d805db916eecbb7aea"},{"_id":"public/tag//index.html","modified":1483685944910,"shasum":"b417cf2ad82a12cbb31c0dd6fb6a81f6986f2f72"},{"_id":"public/tag//index.html","modified":1483685944927,"shasum":"59b373fcda4eba4b95d33aae671e18d245086e77"},{"_id":"source/_posts/geometry-notes/7.ggb","shasum":"664cb26c185c2c0366f0e066d3bedb2c3fb5ef53","modified":1483689811124},{"_id":"source/_posts/geometry-notes/7.svg","shasum":"c4a8ffe9d179dfc720ab34a8981813efb8c11be9","modified":1483689815008},{"_id":"public/geometry-notes/7.ggb","modified":1483692227150,"shasum":"664cb26c185c2c0366f0e066d3bedb2c3fb5ef53"},{"_id":"public/geometry-notes/7.svg","modified":1483692227153,"shasum":"c4a8ffe9d179dfc720ab34a8981813efb8c11be9"}],"Category":[{"name":"OI","_id":"cixlg9r7c0001ooxleudrxue8"},{"name":"Geek","_id":"cixlg9r9h0035ooxlomt7421m"},{"name":"Diary","_id":"cixlg9rcd0070ooxlp5rw7pai"}],"Data":[],"Page":[{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2016-09-10T05:42:23.025Z","updated":"2016-09-10T05:42:23.025Z","path":"tags/index.html","comments":1,"_id":"cixlg9r7n000dooxl7j1j5chd"},{"title":"Friends","date":"2016-01-18T13:08:05.000Z","_content":"\n<table width=\"100%\" id=\"oier\" style=\"text-align: center; \">\n<thead>\n<tr class=\"header\">\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td>[sxb_201](http://blog.csdn.net/sxb_201)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Rapiz](https://www.zybuluo.com/rapiz/note/367932)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Platypus](http://platypuspro.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Franky](http://www.cnblogs.com/Franky-ln/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ShallWe](http://shallwe2000.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[frank_c1](http://www.acyume.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Krydom](http://krydom.com/)</td>\n<td><span></span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# LYOI 2016\n[Edge](http://blog.u-pt.pw) [ilern](http://ilern.coding.me/428/) [yqy](https://yqy.moe) [Sulfur6](http://sulfur6.top/) [Roller](http://roller.coding.me/heyheyhey/) [x_shuai](http://x_shuai.leanote.com/) [Gavin](http://gavin_blog.leanote.com/) [Grape](http://bbs.u-pt.pw)\n\n# \n\n[](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n\n[Dimpurr](http://im.dimpurr.com/)\n","source":"friends.md","raw":"title: Friends\npermalink: friends/\ndate: 2016-01-18 21:08:05\n---\n\n<table width=\"100%\" id=\"oier\" style=\"text-align: center; \">\n<thead>\n<tr class=\"header\">\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td>[sxb_201](http://blog.csdn.net/sxb_201)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Rapiz](https://www.zybuluo.com/rapiz/note/367932)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Platypus](http://platypuspro.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Franky](http://www.cnblogs.com/Franky-ln/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ShallWe](http://shallwe2000.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[frank_c1](http://www.acyume.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Krydom](http://krydom.com/)</td>\n<td><span></span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# LYOI 2016\n[Edge](http://blog.u-pt.pw) [ilern](http://ilern.coding.me/428/) [yqy](https://yqy.moe) [Sulfur6](http://sulfur6.top/) [Roller](http://roller.coding.me/heyheyhey/) [x_shuai](http://x_shuai.leanote.com/) [Gavin](http://gavin_blog.leanote.com/) [Grape](http://bbs.u-pt.pw)\n\n# \n\n[](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n\n[Dimpurr](http://im.dimpurr.com/)\n","updated":"2016-10-15T13:43:52.349Z","path":"friends/index.html","comments":1,"layout":"page","_id":"cixlg9r7r000eooxl2js6cb38"},{"title":"About Me","date":"2015-11-22T21:36:32.000Z","_content":"\n OI ~~~~~~~~\n\n 2015  8  OI\n\n\n\n<!--  NOI  -->\n\n> \n","source":"about-me.md","raw":"title: About Me\npermalink: about-me/\ndate: 2015-11-23 05:36:32\n---\n\n OI ~~~~~~~~\n\n 2015  8  OI\n\n\n\n<!--  NOI  -->\n\n> \n","updated":"2016-05-20T12:39:29.758Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"cixlg9r7t000fooxldkjaeodp"}],"Post":[{"title":" - ","date":"2016-03-20T15:07:32.000Z","_content":"\n $ n $  $ 0 $ \n\n1.  $ x $ \n2.  $ x $ \n\n<!-- more -->\n\n### \n $ sum $  $ count $\n\n u \n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n $ count(u) * d_i $  $ O(log ^ 2 n) $ \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","source":"_posts/20160318-color.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: 20160318-color\ndate: 2016-03-20 23:07:32\n---\n\n $ n $  $ 0 $ \n\n1.  $ x $ \n2.  $ x $ \n\n<!-- more -->\n\n### \n $ sum $  $ count $\n\n u \n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n $ count(u) * d_i $  $ O(log ^ 2 n) $ \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","slug":"20160318-color","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r760000ooxlll2vxp8k"},{"title":"ZJOI2014 - FFT","date":"2016-06-11T13:27:00.000Z","_content":"\n\n\n$$ E_i = \\frac{F_i}{q_i} $$\n\n$$ F_j = \\sum\\limits_{i < j} \\frac{q_i q_j}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i q_j}{(i - j) ^ 2}  $$\n\n $ E $\n\n<!-- more -->\n\n### \n[BZOJ 3527](http://www.lydsy.com/JudgeOnline/problem.php?id=3527)\n\n### \n\n\n$$ E_j = \\sum\\limits_{i < j} \\frac{q_i}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i}{(i - j) ^ 2} $$\n\n $ E_j = A_j - B_j $ \n\n$$ A_j = \\sum\\limits_{i = 1} ^ {j - 1} \\frac{q_j}{(i - j) ^ 2} $$\n\n\n\n$$\ng(i) = \\begin{cases} \\frac{1}{i ^ 2} & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n$$\nf(i) = \\begin{cases} q_i & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n\n\n$$ A_j = \\sum\\limits_{i = 0} ^ {j} f(i) g(j - i) $$\n\n~~~~ FFT \n\n\n\n$$ A_j = \\sum\\limits_{i = j + 1} ^ {n} \\frac{q_j}{(i - j) ^ 2} $$\n\n [BZOJ 2194](bzoj-2194)  $ A $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_EXTENDED = 262144;\nconst long double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<long double> omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<long double>(cosl(2 * PI / n * i), sinl(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<long double> *a, const int n, const std::complex<long double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[t], a[i]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<long double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<long double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid multiply(std::complex<long double> *a, std::complex<long double> *b, const int n) {\n\t\tint size = 1;\n\t\twhile (size < n * 2) size *= 2;\n\n\t\t/*\n\t\tstatic std::complex<long double> c[MAXN_EXTENDED];\n\t\tfor (int i = 0; i < n; i++) c[i] = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i <= j; i++) {\n\t\t\t\tc[j] += a[i] * b[j - i];\n\t\t\t}\n\t\t}\n\n\t\tstd::copy(c, c + n, a);\n\t\treturn;\n\t\t*/\n\n\t\tinit(size);\n\n\t\tdft(a, size);\n\t\tdft(b, size);\n\n\t\tfor (int i = 0; i < size; i++) a[i] *= b[i];\n\n\t\tidft(a, size);\n\t}\n} fft;\n\nint n;\nlong double q[MAXN + 1];\n\ninline void calc(const long double *q, long double *E) {\n\tstatic std::complex<long double> f[MAXN_EXTENDED], g[MAXN_EXTENDED];\n\tstd::fill(f, f + MAXN_EXTENDED, 0);\n\tstd::fill(g, g + MAXN_EXTENDED, 0);\n\tstd::copy(q, q + n + 1, f);\n\tf[0] = g[0] = std::complex<long double>(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[i] = std::complex<long double>(1.0 / pow(i, 2), 0);\n\t}\n\n\tfft.multiply(f, g, n + 1);\n\tfor (int i = 1; i <= n; i++) E[i] = f[i].real();\n\n\t/*\n\tfor (int i = 0; i < (n + 1) * 2; i++) printf(\"* %lf\\n\", static_cast<double>(f[i].real()));\n\tputchar('\\n');\n\n\treturn;\n\n\tstatic std::complex<long double> r[MAXN_EXTENDED];\n\tfor (int j = 0; j <= n; j++) {\n\t\tr[j] = 0;\n\t\tfor (int i = 0; i <= j; i++) {\n\t\t\tr[j] += f[i] * g[j - i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) printf(\"* %lf\\n\", static_cast<double>(r[i].real()));\n\tputchar('\\n');\n\n\tfor (int i = 1; i <= n; i++) E[i] = r[i].real();\n\t*/\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdouble x;\n\t\tscanf(\"%lf\", &x);\n\t\tq[i] = x;\n\t}\n\n\tstatic long double E1[MAXN + 1], E2[MAXN + 1];\n\tcalc(q, E1);\n\tstd::reverse(q + 1, q + n + 1);\n\tcalc(q, E2);\n\n\tfor (int i = 1; i <= n; i++) printf(\"%.3lf\\n\", static_cast<double>(E1[i] - E2[n - i + 1]));\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2014-force.md","raw":"title: ZJOI2014 - FFT\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - FFT\n  - \npermalink: zjoi2014-force\ndate: 2016-06-11 21:27:00\n---\n\n\n\n$$ E_i = \\frac{F_i}{q_i} $$\n\n$$ F_j = \\sum\\limits_{i < j} \\frac{q_i q_j}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i q_j}{(i - j) ^ 2}  $$\n\n $ E $\n\n<!-- more -->\n\n### \n[BZOJ 3527](http://www.lydsy.com/JudgeOnline/problem.php?id=3527)\n\n### \n\n\n$$ E_j = \\sum\\limits_{i < j} \\frac{q_i}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i}{(i - j) ^ 2} $$\n\n $ E_j = A_j - B_j $ \n\n$$ A_j = \\sum\\limits_{i = 1} ^ {j - 1} \\frac{q_j}{(i - j) ^ 2} $$\n\n\n\n$$\ng(i) = \\begin{cases} \\frac{1}{i ^ 2} & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n$$\nf(i) = \\begin{cases} q_i & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n\n\n$$ A_j = \\sum\\limits_{i = 0} ^ {j} f(i) g(j - i) $$\n\n~~~~ FFT \n\n\n\n$$ A_j = \\sum\\limits_{i = j + 1} ^ {n} \\frac{q_j}{(i - j) ^ 2} $$\n\n [BZOJ 2194](bzoj-2194)  $ A $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_EXTENDED = 262144;\nconst long double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<long double> omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<long double>(cosl(2 * PI / n * i), sinl(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<long double> *a, const int n, const std::complex<long double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[t], a[i]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<long double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<long double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid multiply(std::complex<long double> *a, std::complex<long double> *b, const int n) {\n\t\tint size = 1;\n\t\twhile (size < n * 2) size *= 2;\n\n\t\t/*\n\t\tstatic std::complex<long double> c[MAXN_EXTENDED];\n\t\tfor (int i = 0; i < n; i++) c[i] = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i <= j; i++) {\n\t\t\t\tc[j] += a[i] * b[j - i];\n\t\t\t}\n\t\t}\n\n\t\tstd::copy(c, c + n, a);\n\t\treturn;\n\t\t*/\n\n\t\tinit(size);\n\n\t\tdft(a, size);\n\t\tdft(b, size);\n\n\t\tfor (int i = 0; i < size; i++) a[i] *= b[i];\n\n\t\tidft(a, size);\n\t}\n} fft;\n\nint n;\nlong double q[MAXN + 1];\n\ninline void calc(const long double *q, long double *E) {\n\tstatic std::complex<long double> f[MAXN_EXTENDED], g[MAXN_EXTENDED];\n\tstd::fill(f, f + MAXN_EXTENDED, 0);\n\tstd::fill(g, g + MAXN_EXTENDED, 0);\n\tstd::copy(q, q + n + 1, f);\n\tf[0] = g[0] = std::complex<long double>(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[i] = std::complex<long double>(1.0 / pow(i, 2), 0);\n\t}\n\n\tfft.multiply(f, g, n + 1);\n\tfor (int i = 1; i <= n; i++) E[i] = f[i].real();\n\n\t/*\n\tfor (int i = 0; i < (n + 1) * 2; i++) printf(\"* %lf\\n\", static_cast<double>(f[i].real()));\n\tputchar('\\n');\n\n\treturn;\n\n\tstatic std::complex<long double> r[MAXN_EXTENDED];\n\tfor (int j = 0; j <= n; j++) {\n\t\tr[j] = 0;\n\t\tfor (int i = 0; i <= j; i++) {\n\t\t\tr[j] += f[i] * g[j - i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) printf(\"* %lf\\n\", static_cast<double>(r[i].real()));\n\tputchar('\\n');\n\n\tfor (int i = 1; i <= n; i++) E[i] = r[i].real();\n\t*/\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdouble x;\n\t\tscanf(\"%lf\", &x);\n\t\tq[i] = x;\n\t}\n\n\tstatic long double E1[MAXN + 1], E2[MAXN + 1];\n\tcalc(q, E1);\n\tstd::reverse(q + 1, q + n + 1);\n\tcalc(q, E2);\n\n\tfor (int i = 1; i <= n; i++) printf(\"%.3lf\\n\", static_cast<double>(E1[i] - E2[n - i + 1]));\n\n\treturn 0;\n}\n```\n","slug":"zjoi2014-force","published":1,"updated":"2016-06-12T01:30:38.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r7v000gooxlu86flrpb"},{"title":"ZJOI2010 -  + ","date":"2016-06-21T00:48:00.000Z","_content":"\n $ C $  $ W $ $ 1 $ \n\n1. $ 1 $  $ N $ \n2.  $ 1 $  $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 1834](http://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n### \n\n\n**** $ W $  \n $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 5000;\nconst int MAXK = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c, *in;\n\tint l, d, f;\n\tbool q;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\n\t\tq.push(&N[s]);\n\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->in = e;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tstatic struct Edge {\n\t\tint s, t, c, w;\n\t} E[MAXM];\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tscanf(\"%d %d %d %d\", &e.s, &e.t, &e.c, &e.w);\n\t\taddEdge(e.s, e.t, e.c, 0);\n\t}\n\n\tint maxFlow = dinic(1, n, n + 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\taddEdge(e.s, e.t, INT_MAX, e.w);\n\t}\n\n\taddEdge(0, 1, k, 0);\n\n\tint flow, cost;\n\tedmondskarp(0, n, n + 1, flow, cost);\n\tprintf(\"%d %d\\n\", maxFlow, cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2010-network.md","raw":"title: ZJOI2010 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Dinic\n  - \n  - Edmonds-Karp\npermalink: zjoi2010-network\ndate: 2016-06-21 08:48:00\n---\n\n $ C $  $ W $ $ 1 $ \n\n1. $ 1 $  $ N $ \n2.  $ 1 $  $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 1834](http://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n### \n\n\n**** $ W $  \n $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 5000;\nconst int MAXK = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c, *in;\n\tint l, d, f;\n\tbool q;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\n\t\tq.push(&N[s]);\n\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->in = e;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tstatic struct Edge {\n\t\tint s, t, c, w;\n\t} E[MAXM];\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tscanf(\"%d %d %d %d\", &e.s, &e.t, &e.c, &e.w);\n\t\taddEdge(e.s, e.t, e.c, 0);\n\t}\n\n\tint maxFlow = dinic(1, n, n + 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\taddEdge(e.s, e.t, INT_MAX, e.w);\n\t}\n\n\taddEdge(0, 1, k, 0);\n\n\tint flow, cost;\n\tedmondskarp(0, n, n + 1, flow, cost);\n\tprintf(\"%d %d\\n\", maxFlow, cost);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2010-network","published":1,"updated":"2016-06-21T00:49:12.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r80000qooxls99odt0h"},{"title":"ZJOI2009 - ","date":"2016-06-23T10:23:00.000Z","_content":"\nOrez  $ n \\times m $  Orez Orez \n\n<!-- more -->\n\n### \n[BZOJ 1412](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (x == 1) addEdge(s, id(i, j), INT_MAX);\n\t\t\telse if (x == 2) addEdge(id(i, j), t, INT_MAX);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), 1);\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), 1);\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), 1);\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), 1);\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2009-ws.md","raw":"title: ZJOI2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Dinic\n  - \npermalink: zjoi2009-ws\ndate: 2016-06-23 18:23:00\n---\n\nOrez  $ n \\times m $  Orez Orez \n\n<!-- more -->\n\n### \n[BZOJ 1412](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (x == 1) addEdge(s, id(i, j), INT_MAX);\n\t\t\telse if (x == 2) addEdge(id(i, j), t, INT_MAX);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), 1);\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), 1);\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), 1);\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), 1);\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2009-ws","published":1,"updated":"2016-06-23T10:23:36.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r880012ooxly9xlvj0j"},{"title":"ZJOI2008 - DP","date":"2016-11-13T02:00:00.000Z","_content":"\n $ k $ party  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1037](http://www.lydsy.com/JudgeOnline/problem.php?id=1037)\n\n### \n $ f(i, j, p, q) $  $ i $  $ j $  $ i $  $ p $  $ q $ \n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j + 1, p + 1, \\max(q - 1, 0)) $$\n\n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j, \\max(p - 1, 0), q + 1) $$\n\n $ \\sum\\limits_{p = 0} ^ k \\sum\\limits_{q = 0} ^ k f(n + m, n, p, q) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 150;\nconst int MAXK = 20;\nconst int MOD = 12345678;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t// f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q\n\tstatic int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2];\n\tf[0][0][0][0] = 1;\n\tfor (int i = 0; i < n + m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tfor (int q = 0; q <= k; q++) {\n\t\t\t\t\t// Add a boy\n\t\t\t\t\t(f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD;\n\t\t\t\t\t// Add a girl\n\t\t\t\t\t(f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int p = 0; p <= k; p++) for (int q = 0; q <= k; q++) (ans += f[n + m][n][p][q]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2008-party.md","raw":"title: ZJOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - DP\npermalink: zjoi2008-party\ndate: 2016-11-13 10:00:00\n---\n\n $ k $ party  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1037](http://www.lydsy.com/JudgeOnline/problem.php?id=1037)\n\n### \n $ f(i, j, p, q) $  $ i $  $ j $  $ i $  $ p $  $ q $ \n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j + 1, p + 1, \\max(q - 1, 0)) $$\n\n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j, \\max(p - 1, 0), q + 1) $$\n\n $ \\sum\\limits_{p = 0} ^ k \\sum\\limits_{q = 0} ^ k f(n + m, n, p, q) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 150;\nconst int MAXK = 20;\nconst int MOD = 12345678;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t// f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q\n\tstatic int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2];\n\tf[0][0][0][0] = 1;\n\tfor (int i = 0; i < n + m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tfor (int q = 0; q <= k; q++) {\n\t\t\t\t\t// Add a boy\n\t\t\t\t\t(f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD;\n\t\t\t\t\t// Add a girl\n\t\t\t\t\t(f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int p = 0; p <= k; p++) for (int q = 0; q <= k; q++) (ans += f[n + m][n][p][q]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"zjoi2008-party","published":1,"updated":"2016-11-13T02:13:03.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8b001aooxlsxcj7zkb"},{"title":"ZJOI2008 - ","date":"2016-11-13T01:53:00.000Z","_content":"\n $ n $  $ 2, 1, 0 $\n\n<!-- more -->\n\n### \n[BZOJ 1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034)\n\n### \n A  B  B  A  B \n\n\n\n### \n```c++\n#include <cstdio>\n#include <set>\n\nconst int MAXN = 100000;\n\nint n;\n\ninline int solve(const int *a, const int *b) {\n\tstd::multiset<int> sa, sb;\n\tfor (int i = 0; i < n; i++) sa.insert(a[i]), sb.insert(b[i]);\n\n\tint ans = 0;\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); ) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (target == sb.begin()) {\n\t\t\tit++;\n\t\t} else {\n\t\t\ttarget--;\n\t\t\tsb.erase(target);\n\t\t\tsa.erase(it++);\n\t\t\tans += 2;\n\t\t}\n\t}\n\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); it++) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (*target == *it) sb.erase(target), ans++;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\t/*\n\tstd::sort(a, a + n);\n\tstd::sort(b, b + n);\n\t*/\n\n\tprintf(\"%d %d\\n\", solve(a, b), n * 2 - solve(b, a));\n\t\n\treturn 0;\n}\n```","source":"_posts/zjoi2008-bnb.md","raw":"title: ZJOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \npermalink: zjoi2008-bnb\ndate: 2016-11-13 09:53:00\n---\n\n $ n $  $ 2, 1, 0 $\n\n<!-- more -->\n\n### \n[BZOJ 1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034)\n\n### \n A  B  B  A  B \n\n\n\n### \n```c++\n#include <cstdio>\n#include <set>\n\nconst int MAXN = 100000;\n\nint n;\n\ninline int solve(const int *a, const int *b) {\n\tstd::multiset<int> sa, sb;\n\tfor (int i = 0; i < n; i++) sa.insert(a[i]), sb.insert(b[i]);\n\n\tint ans = 0;\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); ) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (target == sb.begin()) {\n\t\t\tit++;\n\t\t} else {\n\t\t\ttarget--;\n\t\t\tsb.erase(target);\n\t\t\tsa.erase(it++);\n\t\t\tans += 2;\n\t\t}\n\t}\n\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); it++) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (*target == *it) sb.erase(target), ans++;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\t/*\n\tstd::sort(a, a + n);\n\tstd::sort(b, b + n);\n\t*/\n\n\tprintf(\"%d %d\\n\", solve(a, b), n * 2 - solve(b, a));\n\t\n\treturn 0;\n}\n```","slug":"zjoi2008-bnb","published":1,"updated":"2016-11-13T01:53:48.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8j001gooxl5xhuodpp"},{"title":"ZJOI2008 -  + ","date":"2016-05-23T13:26:00.000Z","_content":"\n[](https://www.zybuluo.com/Jerusalem/note/221811)\n\n<!-- more -->\n\n### \n[BZOJ 1033](http://www.lydsy.com/JudgeOnline/problem.php?id=1033)  \n[COGS 2048](http://cogs.top/cogs/problem/problem.php?pid=2048)\n\n### \n \n\n $ a $ $ b $ $ a $ $ b $\n\n\n\n$$\n\\begin{cases}\na \\leq r \\\\\nb \\gt r\n\\end{cases}\n$$\n\n\n\n\n\n**** \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <list>\n#include <algorithm>\n\ntypedef long double real;\n\nconst int MAXN = 8;\nconst int MAXM = 8;\nconst int MAXS = 20;\nconst int MAXT = 200000;\nconst real EPS = 1e-6;\n\nint n, m, s, d, r, t, time;\n\nstruct Map {\n\tint message;\n\tbool reachable;\n\n\tMap() : message(0), reachable(true) {}\n} map[MAXN + 1][MAXM + 1];\n\ntemplate <typename T>\nstruct Point {\n\tT x, y;\n\n\tPoint(const T x = 0, const T y = 0) : x(x), y(y) {}\n\n\tMap *operator->() const { return &map[static_cast<int>(x)][static_cast<int>(y)]; }\n\n\tPoint offset(const int id) const {\n\t\tswitch (id) {\n\t\t\tcase 0: return Point(x, y + 1);\n\t\t\tcase 1: return Point(x + 1, y);\n\t\t\tcase 2: return Point(x, y - 1);\n\t\t\tcase 3: return Point(x - 1, y);\n\t\t\tdefault: return *this;\n\t\t}\n\t}\n\n\tbool valid() const { return x >= 0 && x <= n && y >= 0 && y <= m; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\n\ninline bool dcmp(const real a) { return fabs(a) <= EPS; }\ninline bool dcmp(const real a, const real b) { return dcmp(a - b); }\n\ninline bool isnan(const real x) { return x != x; }\ninline bool isinf(const real x) { return !isnan(x) && isnan(x - x); }\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ntemplate <typename Ta, typename Tb>\ninline real distance(const Point<Ta> a, const Point<Tb> b) {\n\treturn sqrt(static_cast<real>(sqr(a.x - b.x) + sqr(a.y - b.y)));\n}\n\nstruct Ant {\n\tPoint<int> position, lastPosition;\n\tint level;\n\tint hpLimit, hp;\n\tbool hasCake;\n\tint spawnTime;\n\n\tAnt(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) {\n\t\t// printf(\"spawn Ant(%d)\\n\", level);\n\t\tposition->reachable = false;\n\t}\n\n\tinline void moveTo(const Point<int> &nextPosition) {\n\t\tlastPosition = position;\n\t\tposition = nextPosition;\n\t\tif (lastPosition == position) return;\n\t\t// printf(\"moveTo(): from [%d, %d] to [%d, %d]\\n\", lastPosition.x, lastPosition.y, position.x, position.y);\n\t\tlastPosition->reachable = true;\n\t\tposition->reachable = false;\n\t}\n\n\tinline int age() const {\n\t\treturn time - spawnTime;\n\t}\n\n\tinline bool attackable(const Point<int> &p) {\n\t\tconst real dist = distance(position, p);\n\t\treturn dist < r || dcmp(dist, r);\n\t}\n};\n\nstruct Line {\n\treal k, b;\n\n\t/*\n\t * k != nan: y = kx + b\n\t * k == nan: x = b\n\t */\n\n\tLine(const Point<int> &p1, const Point<int> &p2) {\n\t\tconst real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\t\tif (x1 == x2) {\n\t\t\tk = NAN;\n\t\t\tb = x1;\n\t\t} else {\n\t\t\tk = (y2 - y1) / (x2 - x1);\n\t\t\tb = y1 - k * x1;\n\t\t}\n\t}\n\n\tLine(const real k, const Point<int> &p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {}\n\n\tLine(const real k, const real b) : k(k), b(b) {}\n\n\tLine perpendicular(const Point<int> &p1) const {\n\t\tif (isnan(k)) return Line(0, p1.y);\n\t\telse return Line(-1.0 / k, p1);\n\t}\n};\n\nstruct Segment {\n\tPoint<int> p1, p2;\n\tLine line;\n\treal length;\n\n\tSegment(const Point<int> &p1, const Point<int> &p2) : p1(p1), p2(p2), line(p1, p2) {\n\t\tlength = distance(p1, p2);\n\t}\n};\n\nPoint<real> lineIntersection(const Line &a, const Line &b) {\n\tif (isnan(a.k) && isnan(b.k) || a.k == b.k) throw;\n\tif (isnan(a.k)) return Point<real>(a.b, a.b * b.k + b.b);\n\tif (isnan(b.k)) return Point<real>(b.b, b.b * a.k + a.b);\n\tconst real x = (b.b - a.b) / (a.k - b.k);\n\tconst real y = a.k * x + a.b;\n\treturn Point<real>(x, y);\n}\n\nbool pointOnSegment(const Point<real> &p, const Segment &s) {\n\treturn dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length);\n}\n\nbool segmentCircleIntersection(const Segment &s, const Point<int> &p, const real r) {\n\tLine v = s.line.perpendicular(p);\n\tPoint<real> is = lineIntersection(v, s.line);\n\treal min, max;\n\tif (pointOnSegment(is, s)) {\n\t\tmin = distance(is, p);\n\t\tmax = std::max(distance(is, s.p1), distance(is, s.p2));\n\t} else {\n\t\tmin = distance(p, s.p1);\n\t\tmax = distance(p, s.p2);\n\t\tif (min > max) std::swap(min, max);\n\t}\n\n\treturn (min < r || dcmp(min, r)) && (max > r || dcmp(max, r));\n}\n\nstd::list<Ant> ants;\nstd::list<Ant>::iterator cakeOwner = ants.end();\nPoint<int> towers[MAXS];\n\ninline void spawn() {\n\tif (ants.size() < 6) {\n\t\tif (map[0][0].reachable == false) return;\n\n\t\tstatic int cnt = -1;\n\t\tcnt++;\n\t\tants.push_back(Ant(cnt / 6 + 1));\n\t}\n}\n\ninline void incMessage() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tit->position->message += it->hasCake ? 5 : 2;\n\t}\n}\n\ninline void move() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"move(): _cnt = %d\\n\", _cnt);\n\n\t\tint id = -1;\n\t\t// printf(\"move(): lastPosition = [%d, %d]\\n\", it->lastPosition.x, it->lastPosition.y);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint<int> newPosition = it->position.offset(i);\n\n\t\t\tif (!newPosition.valid()) continue;\n\t\t\tif (newPosition == it->lastPosition) continue;\n\t\t\tif (!newPosition->reachable) continue;\n\n\t\t\tif (id == -1 || newPosition->message > it->position.offset(id)->message) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\n\t\t// if (id != -1) printf(\"move(): checking moving to [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\n\t\tif (id != -1 && (it->age() + 1) % 5 == 0) {\n\t\t\t// printf(\"move(): special, before = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t\tPoint<int> newPosition;\n\t\t\tdo {\n\t\t\t\tid = (id - 1 + 4) % 4;\n\t\t\t\tnewPosition = it->position.offset(id);\n\t\t\t} while (!newPosition.valid() || !newPosition->reachable || newPosition == it->lastPosition);\n\t\t\t// printf(\"move(): special, after = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t}\n\n\t\tit->moveTo(it->position.offset(id));\n\t}\n}\n\ninline void getCake() {\n\tif (cakeOwner != ants.end()) return;\n\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(n, m)) {\n\t\t\tcakeOwner = it;\n\t\t\tit->hasCake = true;\n\t\t\tit->hp = std::min(it->hpLimit, it->hp + it->hpLimit / 2);\n\t\t\t// puts(\"getCake(): got\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void attack() {\n\tfor (int i = 0; i < s; i++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"attack(): _cnt = %d\\n\", _cnt);\n\n\t\tstd::list<Ant>::iterator target = ants.end();\n\t\tif (cakeOwner != ants.end() && cakeOwner->attackable(towers[i])) {\n\t\t\ttarget = cakeOwner;\n\t\t}\n\n\t\tif (target == ants.end()) {\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\treal d = distance(it->position, towers[i]);\n\t\t\t\tif ((d < r || dcmp(d, r)) && (target == ants.end() || distance(it->position, towers[i]) < distance(target->position, towers[i]))) {\n\t\t\t\t\ttarget = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (target != ants.end()) {\n\t\t\ttarget->hp -= d;\n\t\t\tSegment s(towers[i], target->position);\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\tif (it != target && segmentCircleIntersection(s, it->position, 0.5)) {\n\t\t\t\t\t// printf(\"attack(): _cnt = %d, through [%d, %d]\\n\", _cnt, it->position.x, it->position.y);\n\t\t\t\t\tit->hp -= d;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if (it == target) printf(\"attack(): _cnt = %d, target [%d, %d]\\n\", _cnt, target->position.x, target->position.y);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void kill() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); ) {\n\t\tif (it->hp < 0) {\n\t\t\tit->position->reachable = true;\n\t\t\tif (it == cakeOwner) cakeOwner = ants.end();\n\t\t\tit = ants.erase(it);\n\t\t} else it++;\n\t}\n}\n\ninline bool check() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(0, 0) && it->hasCake) return false;\n\t}\n\n\treturn true;\n}\n\ninline void decMessage() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (map[i][j].message > 0) map[i][j].message--;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%d %d\\n%d %d %d\", &n, &m, &s, &d, &r);\n\tfor (int i = 0; i < s; i++) {\n\t\tscanf(\"%d %d\", &towers[i].x, &towers[i].y);\n\t\ttowers[i]->reachable = false;\n\t}\n\tscanf(\"%d\", &t);\n\n\ttime = 1;\n\tfor (; time <= t; time++) {\n\t\t// printf(\"main(): time = %d\\n\", time);\n\t\tspawn();\n\t\tincMessage();\n\t\tmove();\n\t\tgetCake();\n\t\tattack();\n\t\tkill();\n\t\tif (!check()) break;\n\t\tdecMessage();\n\n\t\t// for (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.y, it->position.x);\n\t\t// putchar('\\n');\n\t}\n\n\tif (time > t) puts(\"The game is going on\");\n\telse printf(\"Game over after %d seconds\\n\", time);\n\n\tprintf(\"%d\\n\", ants.size());\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.x, it->position.y);\n\n\tfclose(stdin);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2008-antbuster.md","raw":"title: ZJOI2008 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - \n  - \npermalink: zjoi2008-antbuster\ndate: 2016-05-23 21:26:00\n---\n\n[](https://www.zybuluo.com/Jerusalem/note/221811)\n\n<!-- more -->\n\n### \n[BZOJ 1033](http://www.lydsy.com/JudgeOnline/problem.php?id=1033)  \n[COGS 2048](http://cogs.top/cogs/problem/problem.php?pid=2048)\n\n### \n \n\n $ a $ $ b $ $ a $ $ b $\n\n\n\n$$\n\\begin{cases}\na \\leq r \\\\\nb \\gt r\n\\end{cases}\n$$\n\n\n\n\n\n**** \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <list>\n#include <algorithm>\n\ntypedef long double real;\n\nconst int MAXN = 8;\nconst int MAXM = 8;\nconst int MAXS = 20;\nconst int MAXT = 200000;\nconst real EPS = 1e-6;\n\nint n, m, s, d, r, t, time;\n\nstruct Map {\n\tint message;\n\tbool reachable;\n\n\tMap() : message(0), reachable(true) {}\n} map[MAXN + 1][MAXM + 1];\n\ntemplate <typename T>\nstruct Point {\n\tT x, y;\n\n\tPoint(const T x = 0, const T y = 0) : x(x), y(y) {}\n\n\tMap *operator->() const { return &map[static_cast<int>(x)][static_cast<int>(y)]; }\n\n\tPoint offset(const int id) const {\n\t\tswitch (id) {\n\t\t\tcase 0: return Point(x, y + 1);\n\t\t\tcase 1: return Point(x + 1, y);\n\t\t\tcase 2: return Point(x, y - 1);\n\t\t\tcase 3: return Point(x - 1, y);\n\t\t\tdefault: return *this;\n\t\t}\n\t}\n\n\tbool valid() const { return x >= 0 && x <= n && y >= 0 && y <= m; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\n\ninline bool dcmp(const real a) { return fabs(a) <= EPS; }\ninline bool dcmp(const real a, const real b) { return dcmp(a - b); }\n\ninline bool isnan(const real x) { return x != x; }\ninline bool isinf(const real x) { return !isnan(x) && isnan(x - x); }\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ntemplate <typename Ta, typename Tb>\ninline real distance(const Point<Ta> a, const Point<Tb> b) {\n\treturn sqrt(static_cast<real>(sqr(a.x - b.x) + sqr(a.y - b.y)));\n}\n\nstruct Ant {\n\tPoint<int> position, lastPosition;\n\tint level;\n\tint hpLimit, hp;\n\tbool hasCake;\n\tint spawnTime;\n\n\tAnt(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) {\n\t\t// printf(\"spawn Ant(%d)\\n\", level);\n\t\tposition->reachable = false;\n\t}\n\n\tinline void moveTo(const Point<int> &nextPosition) {\n\t\tlastPosition = position;\n\t\tposition = nextPosition;\n\t\tif (lastPosition == position) return;\n\t\t// printf(\"moveTo(): from [%d, %d] to [%d, %d]\\n\", lastPosition.x, lastPosition.y, position.x, position.y);\n\t\tlastPosition->reachable = true;\n\t\tposition->reachable = false;\n\t}\n\n\tinline int age() const {\n\t\treturn time - spawnTime;\n\t}\n\n\tinline bool attackable(const Point<int> &p) {\n\t\tconst real dist = distance(position, p);\n\t\treturn dist < r || dcmp(dist, r);\n\t}\n};\n\nstruct Line {\n\treal k, b;\n\n\t/*\n\t * k != nan: y = kx + b\n\t * k == nan: x = b\n\t */\n\n\tLine(const Point<int> &p1, const Point<int> &p2) {\n\t\tconst real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\t\tif (x1 == x2) {\n\t\t\tk = NAN;\n\t\t\tb = x1;\n\t\t} else {\n\t\t\tk = (y2 - y1) / (x2 - x1);\n\t\t\tb = y1 - k * x1;\n\t\t}\n\t}\n\n\tLine(const real k, const Point<int> &p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {}\n\n\tLine(const real k, const real b) : k(k), b(b) {}\n\n\tLine perpendicular(const Point<int> &p1) const {\n\t\tif (isnan(k)) return Line(0, p1.y);\n\t\telse return Line(-1.0 / k, p1);\n\t}\n};\n\nstruct Segment {\n\tPoint<int> p1, p2;\n\tLine line;\n\treal length;\n\n\tSegment(const Point<int> &p1, const Point<int> &p2) : p1(p1), p2(p2), line(p1, p2) {\n\t\tlength = distance(p1, p2);\n\t}\n};\n\nPoint<real> lineIntersection(const Line &a, const Line &b) {\n\tif (isnan(a.k) && isnan(b.k) || a.k == b.k) throw;\n\tif (isnan(a.k)) return Point<real>(a.b, a.b * b.k + b.b);\n\tif (isnan(b.k)) return Point<real>(b.b, b.b * a.k + a.b);\n\tconst real x = (b.b - a.b) / (a.k - b.k);\n\tconst real y = a.k * x + a.b;\n\treturn Point<real>(x, y);\n}\n\nbool pointOnSegment(const Point<real> &p, const Segment &s) {\n\treturn dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length);\n}\n\nbool segmentCircleIntersection(const Segment &s, const Point<int> &p, const real r) {\n\tLine v = s.line.perpendicular(p);\n\tPoint<real> is = lineIntersection(v, s.line);\n\treal min, max;\n\tif (pointOnSegment(is, s)) {\n\t\tmin = distance(is, p);\n\t\tmax = std::max(distance(is, s.p1), distance(is, s.p2));\n\t} else {\n\t\tmin = distance(p, s.p1);\n\t\tmax = distance(p, s.p2);\n\t\tif (min > max) std::swap(min, max);\n\t}\n\n\treturn (min < r || dcmp(min, r)) && (max > r || dcmp(max, r));\n}\n\nstd::list<Ant> ants;\nstd::list<Ant>::iterator cakeOwner = ants.end();\nPoint<int> towers[MAXS];\n\ninline void spawn() {\n\tif (ants.size() < 6) {\n\t\tif (map[0][0].reachable == false) return;\n\n\t\tstatic int cnt = -1;\n\t\tcnt++;\n\t\tants.push_back(Ant(cnt / 6 + 1));\n\t}\n}\n\ninline void incMessage() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tit->position->message += it->hasCake ? 5 : 2;\n\t}\n}\n\ninline void move() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"move(): _cnt = %d\\n\", _cnt);\n\n\t\tint id = -1;\n\t\t// printf(\"move(): lastPosition = [%d, %d]\\n\", it->lastPosition.x, it->lastPosition.y);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint<int> newPosition = it->position.offset(i);\n\n\t\t\tif (!newPosition.valid()) continue;\n\t\t\tif (newPosition == it->lastPosition) continue;\n\t\t\tif (!newPosition->reachable) continue;\n\n\t\t\tif (id == -1 || newPosition->message > it->position.offset(id)->message) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\n\t\t// if (id != -1) printf(\"move(): checking moving to [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\n\t\tif (id != -1 && (it->age() + 1) % 5 == 0) {\n\t\t\t// printf(\"move(): special, before = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t\tPoint<int> newPosition;\n\t\t\tdo {\n\t\t\t\tid = (id - 1 + 4) % 4;\n\t\t\t\tnewPosition = it->position.offset(id);\n\t\t\t} while (!newPosition.valid() || !newPosition->reachable || newPosition == it->lastPosition);\n\t\t\t// printf(\"move(): special, after = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t}\n\n\t\tit->moveTo(it->position.offset(id));\n\t}\n}\n\ninline void getCake() {\n\tif (cakeOwner != ants.end()) return;\n\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(n, m)) {\n\t\t\tcakeOwner = it;\n\t\t\tit->hasCake = true;\n\t\t\tit->hp = std::min(it->hpLimit, it->hp + it->hpLimit / 2);\n\t\t\t// puts(\"getCake(): got\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void attack() {\n\tfor (int i = 0; i < s; i++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"attack(): _cnt = %d\\n\", _cnt);\n\n\t\tstd::list<Ant>::iterator target = ants.end();\n\t\tif (cakeOwner != ants.end() && cakeOwner->attackable(towers[i])) {\n\t\t\ttarget = cakeOwner;\n\t\t}\n\n\t\tif (target == ants.end()) {\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\treal d = distance(it->position, towers[i]);\n\t\t\t\tif ((d < r || dcmp(d, r)) && (target == ants.end() || distance(it->position, towers[i]) < distance(target->position, towers[i]))) {\n\t\t\t\t\ttarget = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (target != ants.end()) {\n\t\t\ttarget->hp -= d;\n\t\t\tSegment s(towers[i], target->position);\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\tif (it != target && segmentCircleIntersection(s, it->position, 0.5)) {\n\t\t\t\t\t// printf(\"attack(): _cnt = %d, through [%d, %d]\\n\", _cnt, it->position.x, it->position.y);\n\t\t\t\t\tit->hp -= d;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if (it == target) printf(\"attack(): _cnt = %d, target [%d, %d]\\n\", _cnt, target->position.x, target->position.y);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void kill() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); ) {\n\t\tif (it->hp < 0) {\n\t\t\tit->position->reachable = true;\n\t\t\tif (it == cakeOwner) cakeOwner = ants.end();\n\t\t\tit = ants.erase(it);\n\t\t} else it++;\n\t}\n}\n\ninline bool check() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(0, 0) && it->hasCake) return false;\n\t}\n\n\treturn true;\n}\n\ninline void decMessage() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (map[i][j].message > 0) map[i][j].message--;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%d %d\\n%d %d %d\", &n, &m, &s, &d, &r);\n\tfor (int i = 0; i < s; i++) {\n\t\tscanf(\"%d %d\", &towers[i].x, &towers[i].y);\n\t\ttowers[i]->reachable = false;\n\t}\n\tscanf(\"%d\", &t);\n\n\ttime = 1;\n\tfor (; time <= t; time++) {\n\t\t// printf(\"main(): time = %d\\n\", time);\n\t\tspawn();\n\t\tincMessage();\n\t\tmove();\n\t\tgetCake();\n\t\tattack();\n\t\tkill();\n\t\tif (!check()) break;\n\t\tdecMessage();\n\n\t\t// for (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.y, it->position.x);\n\t\t// putchar('\\n');\n\t}\n\n\tif (time > t) puts(\"The game is going on\");\n\telse printf(\"Game over after %d seconds\\n\", time);\n\n\tprintf(\"%d\\n\", ants.size());\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.x, it->position.y);\n\n\tfclose(stdin);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2008-antbuster","published":1,"updated":"2016-05-23T13:27:10.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8o001mooxltmkb3fh1"},{"title":"ZJOI2007 -  DP","date":"2016-05-18T03:58:00.000Z","_content":"\n $ i $  $ P_i $  $ i $  $ C_i $ $ N $ $ 1 $  $ 1 $\n\n1.  $ i $  $ 1 $  $ x_i $ $ x_1 = 0 $\n2.  $ i $  $ p_i $\n3.  $ i $  $ c_i $\n\n + \n\n<!-- more -->\n\n### \n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### \n $ S(i) $  $ i $  $ 1 $ $ s(i) $  $ i $ \n\n $ f(i) $  i \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","source":"_posts/zjoi2007-storage.md","raw":"title: ZJOI2007 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - \n  - DP\npermalink: zjoi2007-storage\ndate: 2016-05-18 11:58:00\n---\n\n $ i $  $ P_i $  $ i $  $ C_i $ $ N $ $ 1 $  $ 1 $\n\n1.  $ i $  $ 1 $  $ x_i $ $ x_1 = 0 $\n2.  $ i $  $ p_i $\n3.  $ i $  $ c_i $\n\n + \n\n<!-- more -->\n\n### \n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### \n $ S(i) $  $ i $  $ 1 $ $ s(i) $  $ i $ \n\n $ f(i) $  i \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","slug":"zjoi2007-storage","published":1,"updated":"2016-10-24T23:28:04.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8t001xooxlf2d94gbw"},{"title":"ZJOI2007 - ","date":"2016-09-03T23:38:00.000Z","_content":"\n $ G = (V, E) $ Semi-Connected\n\n> $ \\forall u, v \\in V $ $ u \\rightarrow v $  $ v \\rightarrow u $ $ u $$ v $ $ u $  $ v $  $ v $  $ u $ \n\n $ G' = (V', E') $  $ V' \\subseteq V $$ E' $  $ E $  $ V' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G $ \n\n $ G $ $ G $  $ K $ $ C $ $ C $  $ C $  $ X $ \n\n<!-- more -->\n\n### \n[BZOJ 1093](http://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n### \n\n\n DAG  DP \n\n $ d(i) $  $ u \\rightarrow v $ $ d(v) = d(u) + s(v) $$ s(i) $  $ i $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst int MAXX = 100000000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tstruct SCC *s;\n\tNode *p;\n\tbool inStack, pushed, visited;\n\tint dfn, low, d, sum;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size, inDegree, in, len, sum;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, x;\n\ninline int tarjan() {\n\tint cnt = 0, ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\t\t\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tt.push(v);\n\t\t\t\tv->inStack = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->inStack) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tscc->v.s = scc;\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->s = scc;\n\t\t\t\t\t\tscc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tstd::tr1::unordered_set<unsigned long long> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tunsigned long long x = (static_cast<unsigned long long>(e->s->s - S) << 32) | static_cast<unsigned long long>(e->t->s - S);\n\t\t\tif (e->s->s != e->t->s && !s.count(x)) {\n\t\t\t\ts.insert(x);\n\t\t\t\t// printf(\"[%ld, %ld]\\n\", e->s->s - S + 1, e->t->s - S + 1);\n\t\t\t\te->s->s->v.e = new Edge(&e->s->s->v, &e->t->s->v);\n\t\t\t\te->t->s->inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dp(const int cnt) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"size[%d] = %d\\n\", i, S[i].size);\n\t\tif (S[i].inDegree == 0) q.push(&S[i].v);\n\t\tS[i].v.d = S[i].size;\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\te->t->d = std::max(e->t->d, v->d + e->t->s->size);\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d);\n\treturn ans;\n}\n\ninline int dpSum(const int cnt, const int d) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].inDegree == 0) {\n\t\t\tq.push(&S[i].v);\n\t\t\tS[i].v.sum = 1;\n\t\t}\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->d == v->d + e->t->s->size) (e->t->sum += v->sum) %= x;\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x;\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint d = dp(cnt);\n\n\tprintf(\"%d\\n\", d);\n\tprintf(\"%d\\n\", dpSum(cnt, d));\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2007-semi.md","raw":"title: ZJOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Tarjan\n  - \n  - DP\npermalink: zjoi2007-semi\ndate: 2016-09-04 07:38:00\n---\n\n $ G = (V, E) $ Semi-Connected\n\n> $ \\forall u, v \\in V $ $ u \\rightarrow v $  $ v \\rightarrow u $ $ u $$ v $ $ u $  $ v $  $ v $  $ u $ \n\n $ G' = (V', E') $  $ V' \\subseteq V $$ E' $  $ E $  $ V' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G $ \n\n $ G $ $ G $  $ K $ $ C $ $ C $  $ C $  $ X $ \n\n<!-- more -->\n\n### \n[BZOJ 1093](http://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n### \n\n\n DAG  DP \n\n $ d(i) $  $ u \\rightarrow v $ $ d(v) = d(u) + s(v) $$ s(i) $  $ i $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst int MAXX = 100000000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tstruct SCC *s;\n\tNode *p;\n\tbool inStack, pushed, visited;\n\tint dfn, low, d, sum;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size, inDegree, in, len, sum;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, x;\n\ninline int tarjan() {\n\tint cnt = 0, ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\t\t\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tt.push(v);\n\t\t\t\tv->inStack = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->inStack) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tscc->v.s = scc;\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->s = scc;\n\t\t\t\t\t\tscc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tstd::tr1::unordered_set<unsigned long long> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tunsigned long long x = (static_cast<unsigned long long>(e->s->s - S) << 32) | static_cast<unsigned long long>(e->t->s - S);\n\t\t\tif (e->s->s != e->t->s && !s.count(x)) {\n\t\t\t\ts.insert(x);\n\t\t\t\t// printf(\"[%ld, %ld]\\n\", e->s->s - S + 1, e->t->s - S + 1);\n\t\t\t\te->s->s->v.e = new Edge(&e->s->s->v, &e->t->s->v);\n\t\t\t\te->t->s->inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dp(const int cnt) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"size[%d] = %d\\n\", i, S[i].size);\n\t\tif (S[i].inDegree == 0) q.push(&S[i].v);\n\t\tS[i].v.d = S[i].size;\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\te->t->d = std::max(e->t->d, v->d + e->t->s->size);\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d);\n\treturn ans;\n}\n\ninline int dpSum(const int cnt, const int d) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].inDegree == 0) {\n\t\t\tq.push(&S[i].v);\n\t\t\tS[i].v.sum = 1;\n\t\t}\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->d == v->d + e->t->s->size) (e->t->sum += v->sum) %= x;\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x;\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint d = dp(cnt);\n\n\tprintf(\"%d\\n\", d);\n\tprintf(\"%d\\n\", dpSum(cnt, d));\n\n\treturn 0;\n}\n```","slug":"zjoi2007-semi","published":1,"updated":"2016-09-03T23:51:14.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r8x0027ooxl2z31ndqo"},{"title":"ZJOI2007 - ","date":"2016-12-13T09:23:00.000Z","_content":"\n $ N \\times M $  $ 01 $ \n\n<!-- more -->\n\n### \n[BZOJ 1057](http://www.lydsy.com/JudgeOnline/problem.php?id=1057)\n\n### \n\n\n\n\n\n\n $ O(nm) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\ninline int sqr(int x) {\n\treturn x * x;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= n; i++) f[i][0] = -1;\n\t// for (int j = 1; j <= m; j++) f[0][j] = -1;\n\n\tstatic int f[MAXN + 1][MAXN + 1], g[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (j == 1 ||  a[i][j] == a[i][j - 1]) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tf[i][j] = f[i][j - 1] + 1;\n\t\t\t}\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\t\t}\n\n\t\tfor (int j = m; j >= 1; j--) {\n\t\t\tif (j == m || a[i][j] == a[i][j + 1]) {\n\t\t\t\tg[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tg[i][j] = g[i][j + 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ansSquare = 1, ansRectangle = 1;\n\tfor (int j = 1; j <= m; j++) {\n\t\tint up = 0, left = 0, right = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i == 1 || a[i][j] == a[i - 1][j]) {\n\t\t\t\tup = 1;\n\t\t\t\tleft = f[i][j];\n\t\t\t\tright = g[i][j];\n\t\t\t} else {\n\t\t\t\tup++;\n\t\t\t\tleft = std::min(left, f[i][j]);\n\t\t\t\tright = std::min(right, g[i][j]);\n\t\t\t}\n\n\t\t\t// printf(\"up = %d, left = %d, right = %d\\n\", up, left, right);\n\t\t\tansRectangle = std::max(ansRectangle, up * (left + right - 1));\n\t\t\tansSquare = std::max(ansSquare, sqr(std::min(up, left + right - 1)));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansSquare, ansRectangle);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2007-chess.md","raw":"title: ZJOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \npermalink: zjoi2007-chess\ndate: 2016-12-13 17:23:00\n---\n\n $ N \\times M $  $ 01 $ \n\n<!-- more -->\n\n### \n[BZOJ 1057](http://www.lydsy.com/JudgeOnline/problem.php?id=1057)\n\n### \n\n\n\n\n\n\n $ O(nm) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\ninline int sqr(int x) {\n\treturn x * x;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= n; i++) f[i][0] = -1;\n\t// for (int j = 1; j <= m; j++) f[0][j] = -1;\n\n\tstatic int f[MAXN + 1][MAXN + 1], g[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (j == 1 ||  a[i][j] == a[i][j - 1]) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tf[i][j] = f[i][j - 1] + 1;\n\t\t\t}\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\t\t}\n\n\t\tfor (int j = m; j >= 1; j--) {\n\t\t\tif (j == m || a[i][j] == a[i][j + 1]) {\n\t\t\t\tg[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tg[i][j] = g[i][j + 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ansSquare = 1, ansRectangle = 1;\n\tfor (int j = 1; j <= m; j++) {\n\t\tint up = 0, left = 0, right = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i == 1 || a[i][j] == a[i - 1][j]) {\n\t\t\t\tup = 1;\n\t\t\t\tleft = f[i][j];\n\t\t\t\tright = g[i][j];\n\t\t\t} else {\n\t\t\t\tup++;\n\t\t\t\tleft = std::min(left, f[i][j]);\n\t\t\t\tright = std::min(right, g[i][j]);\n\t\t\t}\n\n\t\t\t// printf(\"up = %d, left = %d, right = %d\\n\", up, left, right);\n\t\t\tansRectangle = std::max(ansRectangle, up * (left + right - 1));\n\t\t\tansSquare = std::max(ansSquare, sqr(std::min(up, left + right - 1)));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansSquare, ansRectangle);\n\n\treturn 0;\n}\n```","slug":"zjoi2007-chess","published":1,"updated":"2016-12-13T09:23:42.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r92002iooxlczrdlyzt"},{"title":"ZJOI2006 -  + DP","date":"2016-05-23T13:41:00.000Z","_content":"\n $ A $  $ B $ $ n $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)  \n[COGS 1824](http://cogs.top/cogs/problem/problem.php?pid=1824)\n\n### \n\n\n $ c(l,\\ r) $  $ l $  $ r $  $ f(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + k + c(j + 1,\\ i) \\} $$\n\n $ c(j + 1,\\ i) $  $ j + 1 $  $ i $ \n\n $ f(n) - k $ $ O(n ^ 2 m \\log m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <utility>\n#include <functional>\n\nstruct Node;\nstruct Edge;\n\nconst int MAXN = 20;\nconst int MAXD = 100;\n\nstruct Node {\n\tEdge *e;\n\tint d;\n\tbool flag[MAXD], invalid;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const int w) {\n\tN[u].e = new Edge(&N[u], &N[v], w);\n\tN[v].e = new Edge(&N[v], &N[u], w);\n}\n\nint d, n, k, m, c[MAXD + 1][MAXD + 1];\nint f[MAXD + 1];\n\ninline int dijkstra(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].d = INT_MAX;\n\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tN[s].d = 0;\n\tq.push(std::make_pair(0, &N[s]));\n\n\twhile (!q.empty()) {\n\t\tconst std::pair<int, Node *> p = q.top();\n\t\tq.pop();\n\n\t\tNode *v = p.second;\n\n\t\tif (v->d != p.first) continue;\n\t\tif (v->d > N[t].d) break;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\n\t\t\tif (e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\tq.push(std::make_pair(e->t->d, e->t));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn N[t].d;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &d, &n, &k, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint u, l, r;\n\t\tscanf(\"%d %d %d\", &u, &l, &r), u--, l--, r--;\n\t\tstd::fill(N[u].flag + l, N[u].flag + r + 1, true);\n\t}\n\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = i; j <= d; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tN[k].invalid = false;\n\t\t\t\tfor (int l = i; l <= j; l++) {\n\t\t\t\t\tif (N[k].flag[l - 1]) {\n\t\t\t\t\t\tN[k].invalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc[i][j] = dijkstra(0, n - 1);\n\t\t\tif (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1);\n\t\t\t// printf(\"%d\\n\", c[i][j]);\n\t\t}\n\t}\n\n\tstd::fill(f, f + d + 1, INT_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (c[j + 1][i] != INT_MAX) {\n\t\t\t\tf[i] = std::min(f[i], f[j] + k + c[j + 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[d] - k);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2006-trans.md","raw":"title: ZJOI2006 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - DP\npermalink: zjoi2006-trans\ndate: 2016-05-23 21:41:00\n---\n\n $ A $  $ B $ $ n $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)  \n[COGS 1824](http://cogs.top/cogs/problem/problem.php?pid=1824)\n\n### \n\n\n $ c(l,\\ r) $  $ l $  $ r $  $ f(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + k + c(j + 1,\\ i) \\} $$\n\n $ c(j + 1,\\ i) $  $ j + 1 $  $ i $ \n\n $ f(n) - k $ $ O(n ^ 2 m \\log m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <utility>\n#include <functional>\n\nstruct Node;\nstruct Edge;\n\nconst int MAXN = 20;\nconst int MAXD = 100;\n\nstruct Node {\n\tEdge *e;\n\tint d;\n\tbool flag[MAXD], invalid;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const int w) {\n\tN[u].e = new Edge(&N[u], &N[v], w);\n\tN[v].e = new Edge(&N[v], &N[u], w);\n}\n\nint d, n, k, m, c[MAXD + 1][MAXD + 1];\nint f[MAXD + 1];\n\ninline int dijkstra(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].d = INT_MAX;\n\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tN[s].d = 0;\n\tq.push(std::make_pair(0, &N[s]));\n\n\twhile (!q.empty()) {\n\t\tconst std::pair<int, Node *> p = q.top();\n\t\tq.pop();\n\n\t\tNode *v = p.second;\n\n\t\tif (v->d != p.first) continue;\n\t\tif (v->d > N[t].d) break;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\n\t\t\tif (e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\tq.push(std::make_pair(e->t->d, e->t));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn N[t].d;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &d, &n, &k, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint u, l, r;\n\t\tscanf(\"%d %d %d\", &u, &l, &r), u--, l--, r--;\n\t\tstd::fill(N[u].flag + l, N[u].flag + r + 1, true);\n\t}\n\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = i; j <= d; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tN[k].invalid = false;\n\t\t\t\tfor (int l = i; l <= j; l++) {\n\t\t\t\t\tif (N[k].flag[l - 1]) {\n\t\t\t\t\t\tN[k].invalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc[i][j] = dijkstra(0, n - 1);\n\t\t\tif (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1);\n\t\t\t// printf(\"%d\\n\", c[i][j]);\n\t\t}\n\t}\n\n\tstd::fill(f, f + d + 1, INT_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (c[j + 1][i] != INT_MAX) {\n\t\t\t\tf[i] = std::min(f[i], f[j] + k + c[j + 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[d] - k);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2006-trans","published":1,"updated":"2016-05-23T13:42:15.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r95002oooxls8l15ust"},{"title":"ZJOI2004 - ","date":"2016-10-07T22:54:00.000Z","_content":"\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1898](www.lydsy.com/JudgeOnline/problem.php?id=1898)  \n[COGS 1469](http://cogs.pro/cogs/problem/problem.php?pid=1469)\n\n### \n $ k $  $ s $  $ t $ \n\n****\n\n $ \\mathrm{lcm}(2, 3, 4) = 12 $ $ 12 $  $ 12 $  $ k $  $ 12 $  $ 11 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 50;\nconst int MAXM = 20;\nconst long long MAXK = 2e9;\nconst int CYCLE_LCM = 12;\nconst int MOD = 10000;\n\nstruct Matrix {\n\tint a[MAXN][MAXN];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXN; i++) a[i][i] = 1;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res;\n\tfor (int i = 0; i < MAXN; i++) for (int j = 0; j < MAXN; j++) for (int k = 0; k < MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"swamp.in\", \"r\", stdin);\n\tfreopen(\"swamp.out\", \"w\", stdout);\n\n\tint n, m, st, ed, k;\n\tscanf(\"%d %d %d %d %d\", &n, &m, &st, &ed, &k);\n\n\tMatrix g;\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tg(u, v)++;\n\t\tg(v, u)++;\n\t}\n\n\tMatrix gs[CYCLE_LCM];\n\tfor (int i = 0; i < CYCLE_LCM; i++) gs[i] = g;\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint cycle;\n\t\tscanf(\"%d\", &cycle);\n\t\tfor (int i = 0; i < cycle; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfor (int j = i; j < CYCLE_LCM; j += cycle) {\n\t\t\t\tfor (int l = 0; l < n; l++) gs[j](x, l) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", g(i, j), j == n - 1 ? '\\n' : ' ');\n\tputs(\"-------------\");\n\tfor (int l = 0; l < CYCLE_LCM; l++) {\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", gs[l](i, j), j == n - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------\");\n\t}\n#endif\n\n#ifndef FORCE\n\tMatrix prod(true);\n\tfor (int i = 0; i < CYCLE_LCM; i++) prod = prod * gs[i];\n\n\tMatrix res = pow(prod, k / CYCLE_LCM);\n\tfor (int i = 0; i < k % CYCLE_LCM; i++) res = res * gs[i];\n#else\n\tMatrix res(true);\n\tfor (int i = 0; i < k; i++) res = res * gs[i % CYCLE_LCM];\n#endif\n\n\tprintf(\"%d\\n\", res(st, ed));\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", res(i, j), j == n - 1 ? '\\n' : ' ');\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2004-swamp.md","raw":"title: ZJOI2004 - \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - DP\npermalink: zjoi2004-swamp\ndate: 2016-10-08 06:54:00\n---\n\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1898](www.lydsy.com/JudgeOnline/problem.php?id=1898)  \n[COGS 1469](http://cogs.pro/cogs/problem/problem.php?pid=1469)\n\n### \n $ k $  $ s $  $ t $ \n\n****\n\n $ \\mathrm{lcm}(2, 3, 4) = 12 $ $ 12 $  $ 12 $  $ k $  $ 12 $  $ 11 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 50;\nconst int MAXM = 20;\nconst long long MAXK = 2e9;\nconst int CYCLE_LCM = 12;\nconst int MOD = 10000;\n\nstruct Matrix {\n\tint a[MAXN][MAXN];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXN; i++) a[i][i] = 1;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res;\n\tfor (int i = 0; i < MAXN; i++) for (int j = 0; j < MAXN; j++) for (int k = 0; k < MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"swamp.in\", \"r\", stdin);\n\tfreopen(\"swamp.out\", \"w\", stdout);\n\n\tint n, m, st, ed, k;\n\tscanf(\"%d %d %d %d %d\", &n, &m, &st, &ed, &k);\n\n\tMatrix g;\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tg(u, v)++;\n\t\tg(v, u)++;\n\t}\n\n\tMatrix gs[CYCLE_LCM];\n\tfor (int i = 0; i < CYCLE_LCM; i++) gs[i] = g;\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint cycle;\n\t\tscanf(\"%d\", &cycle);\n\t\tfor (int i = 0; i < cycle; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfor (int j = i; j < CYCLE_LCM; j += cycle) {\n\t\t\t\tfor (int l = 0; l < n; l++) gs[j](x, l) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", g(i, j), j == n - 1 ? '\\n' : ' ');\n\tputs(\"-------------\");\n\tfor (int l = 0; l < CYCLE_LCM; l++) {\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", gs[l](i, j), j == n - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------\");\n\t}\n#endif\n\n#ifndef FORCE\n\tMatrix prod(true);\n\tfor (int i = 0; i < CYCLE_LCM; i++) prod = prod * gs[i];\n\n\tMatrix res = pow(prod, k / CYCLE_LCM);\n\tfor (int i = 0; i < k % CYCLE_LCM; i++) res = res * gs[i];\n#else\n\tMatrix res(true);\n\tfor (int i = 0; i < k; i++) res = res * gs[i % CYCLE_LCM];\n#endif\n\n\tprintf(\"%d\\n\", res(st, ed));\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", res(i, j), j == n - 1 ? '\\n' : ' ');\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"zjoi2004-swamp","published":1,"updated":"2016-10-07T23:08:49.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r99002wooxlw9wlizgc"},{"title":"OS X  Linux ","date":"2016-03-07T01:04:27.000Z","_content":"\nOS X  GNU/Linux  GNU/Linux  OS X  OS X  GNU/Linux   \n\n `VirtualBox`  Archlinux  OS X \n\n<!-- more -->\n\n##  OpenSSH\n Arch Linux \n\n OpenSSH\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## \nNAT\n\n![](virtualbox-archlinux/network.png)\n\n\n\n![](virtualbox-archlinux/port.png)\n\n `22` `1000`  OS X  `root`  `1000` \n\n Terminal \n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## \n Virtualbox \n\n![](virtualbox-archlinux/share.png)\n\n\n\n### `rc.local` \n\nArchlinux  systemd  `rc.local` \n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n `rc.local` \n\n```bash\nsudo systemctl enable rc-local\n```\n\n### \n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n\n\n## SSH \n SSH \n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n `~/.ssh` \n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n\n\n SSH \n\n##  Terminal \nTerminal  `Command + N` SSH \n\n### \n Terminal BasicBasic Linux `Shell`  SSH Shell \n\n![](virtualbox-archlinux/terminal.png)\n\n\n\n### \n\n\n\n\n![](virtualbox-archlinux/hotkey.png)\n\n\n\n## \n Terminal  `Command + B`\n\n![](virtualbox-archlinux/screenfetch.png)\n\n `screenfetch`\n","source":"_posts/virtualbox-archlinux.md","raw":"title: OS X  Linux \ncategories: Geek\ntags: \n  - OS X\n  - Linux\n  - Archlinux\n  - VirtualBox\n  - \n  - SSH\npermalink: virtualbox-archlinux\ndate: 2016-03-07 09:04:27\n---\n\nOS X  GNU/Linux  GNU/Linux  OS X  OS X  GNU/Linux   \n\n `VirtualBox`  Archlinux  OS X \n\n<!-- more -->\n\n##  OpenSSH\n Arch Linux \n\n OpenSSH\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## \nNAT\n\n![](virtualbox-archlinux/network.png)\n\n\n\n![](virtualbox-archlinux/port.png)\n\n `22` `1000`  OS X  `root`  `1000` \n\n Terminal \n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## \n Virtualbox \n\n![](virtualbox-archlinux/share.png)\n\n\n\n### `rc.local` \n\nArchlinux  systemd  `rc.local` \n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n `rc.local` \n\n```bash\nsudo systemctl enable rc-local\n```\n\n### \n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n\n\n## SSH \n SSH \n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n `~/.ssh` \n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n\n\n SSH \n\n##  Terminal \nTerminal  `Command + N` SSH \n\n### \n Terminal BasicBasic Linux `Shell`  SSH Shell \n\n![](virtualbox-archlinux/terminal.png)\n\n\n\n### \n\n\n\n\n![](virtualbox-archlinux/hotkey.png)\n\n\n\n## \n Terminal  `Command + B`\n\n![](virtualbox-archlinux/screenfetch.png)\n\n `screenfetch`\n","slug":"virtualbox-archlinux","published":1,"updated":"2016-05-11T09:33:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9r9g0034ooxlb1zybm8l"},{"title":"UVa 1362Exploring Pyramids -  DP + ","date":"2016-03-14T08:32:16.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### \n $ f(i, j) $  $ S $  $ i $  $ j $ \n\n1.  $ i = j $ $ f(i, j) = 1 $\n2.  $ S(i) \\neq S(j) $ $ f(i, j) = 0 $\n\n $ k $ $ i = k = j $  $ (i, k) $  $ [k, j] $ \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","source":"_posts/uva-1362.md","raw":"title: UVa 1362Exploring Pyramids -  DP + \ncategories: OI\ntags: \n  - UVa\n  - \n  - DP\n  -  DP\n  - \npermalink: uva-1362\ndate: 2016-03-14 16:32:16\n---\n\n\n\n<!-- more -->\n\n### \n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### \n $ f(i, j) $  $ S $  $ i $  $ j $ \n\n1.  $ i = j $ $ f(i, j) = 1 $\n2.  $ S(i) \\neq S(j) $ $ f(i, j) = 0 $\n\n $ k $ $ i = k = j $  $ (i, k) $  $ [k, j] $ \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","slug":"uva-1362","published":1,"updated":"2016-10-24T23:28:14.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ra4003jooxlk639w24c"},{"title":"UVa 11806Cheerleaders -  + ","date":"2016-03-11T14:10:34.000Z","_content":"\n $ M * N $  $ K $  $ \nM $  $ N $ \n\n<!-- more -->\n\n### \n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### \n1.  $ A $$ C $  $ M $ \n****\n2.  $ B $$ D $  $ N $ \n****\n3.  $ S $  $ M * N $ **** $ K $ \n\n\n $ S $  $ A $$ B $$ C $$ D $ \n\n\n\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11806.md","raw":"title: UVa 11806Cheerleaders -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11806\ndate: 2016-03-11 22:10:34\n---\n\n $ M * N $  $ K $  $ \nM $  $ N $ \n\n<!-- more -->\n\n### \n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### \n1.  $ A $$ C $  $ M $ \n****\n2.  $ B $$ D $  $ N $ \n****\n3.  $ S $  $ M * N $ **** $ K $ \n\n\n $ S $  $ A $$ B $$ C $$ D $ \n\n\n\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11806","published":1,"updated":"2016-05-11T09:33:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9raa003tooxlpkd1wmj8"},{"title":"UVa 11538Chess Queen - ","date":"2016-03-12T02:47:13.000Z","_content":"\n $ N * M $ \n\n<!-- more -->\n\n### \n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### \n\n\n $ f(a, b) $  $ a $  $ b $  $ a = 1 $ $ b $  $ b - 1 $ \n\n$$ f(1, b) = b(b - 1) $$\n\n\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n\n\n $ m  n $ $ m - n + 1 $  $ n $ $ n - 1 $ \n\n![ \nLibreOffice Calc \n](uva-11538/cells.png)\n\n $ m - n + 1 $  $ n $ **** $ f(m - n + 1, n) $\n\n\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n$ O(n) $ \n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11538.md","raw":"title: UVa 11538Chess Queen - \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11538\ndate: 2016-03-12 10:47:13\n---\n\n $ N * M $ \n\n<!-- more -->\n\n### \n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### \n\n\n $ f(a, b) $  $ a $  $ b $  $ a = 1 $ $ b $  $ b - 1 $ \n\n$$ f(1, b) = b(b - 1) $$\n\n\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n\n\n $ m  n $ $ m - n + 1 $  $ n $ $ n - 1 $ \n\n![ \nLibreOffice Calc \n](uva-11538/cells.png)\n\n $ m - n + 1 $  $ n $ **** $ f(m - n + 1, n) $\n\n\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n$ O(n) $ \n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11538","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rac0041ooxl472q7ojl"},{"title":"UVa 11375Matches - ","date":"2016-03-13T03:07:45.000Z","_content":"\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### \n 0  $ f(i) $  $ i $  $ c(x) $  x \n\n 1 ~ 9 \n\n $ f(i) $  $ f(i + c(x)) $$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $ $ f(i) $  $ x $ \n\n $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $  $ n \\geq 6 $  0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11375.md","raw":"title: UVa 11375Matches - \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11375\ndate: 2016-03-13 11:07:45\n---\n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### \n 0  $ f(i) $  $ i $  $ c(x) $  x \n\n 1 ~ 9 \n\n $ f(i) $  $ f(i + c(x)) $$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $ $ f(i) $  $ x $ \n\n $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $  $ n \\geq 6 $  0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11375","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ran0047ooxl2b7e0xtc"},{"title":"UVa 11361Investigating Div-Sum Property -  DP","date":"2016-03-15T00:53:05.000Z","_content":"\n $ [a, b] $  $ x $ \n\n1. $ x $  $ k $ \n2. $ x $  $ k $ \n\n<!-- more -->\n\n### \n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### \n $ {\\rm sum}(x) $  $ x $ $ g(x, m_1, m_2) $  $ [0, x] $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ g(b, 0, 0) - g(a - 1, 0, 0) $\n\n $ f(n, m_1, m_2) $  $ n $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ f $  1 ~ 9\n\n$ g $  $ x $  $ t $ $ [0, t) $  $ f $  $ x $\n\n$ k $  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11361.md","raw":"title: UVa 11361Investigating Div-Sum Property -  DP\ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - DP\n  -  DP\npermalink: uva-11361\ndate: 2016-03-15 08:53:05\n---\n\n $ [a, b] $  $ x $ \n\n1. $ x $  $ k $ \n2. $ x $  $ k $ \n\n<!-- more -->\n\n### \n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### \n $ {\\rm sum}(x) $  $ x $ $ g(x, m_1, m_2) $  $ [0, x] $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ g(b, 0, 0) - g(a - 1, 0, 0) $\n\n $ f(n, m_1, m_2) $  $ n $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ f $  1 ~ 9\n\n$ g $  $ x $  $ t $ $ [0, t) $  $ f $  $ x $\n\n$ k $  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11361","published":1,"updated":"2016-10-24T23:28:44.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9raq004fooxlyk872vzc"},{"title":"UVa 11174Stand in a Line -  + ","date":"2016-03-13T09:20:34.000Z","_content":"\n $ N $$ N \\leq 40000 $\n\n<!-- more -->\n\n### \n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### \n\n\n $ f(i) $  $ i $  $ s(i) $  $ i $ \n\n$ i $ \n\n$ i $ ********\n\n\n\n $ c(i) $  $ i $ \n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11174.md","raw":"title: UVa 11174Stand in a Line -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: uva-11174\ndate: 2016-03-13 17:20:34\n---\n\n $ N $$ N \\leq 40000 $\n\n<!-- more -->\n\n### \n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### \n\n\n $ f(i) $  $ i $  $ s(i) $  $ i $ \n\n$ i $ \n\n$ i $ ********\n\n\n\n $ c(i) $  $ i $ \n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11174","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rat004nooxl0udxuz2r"},{"title":"UVa 11137Ingenuous Cubrency -  /  DP","date":"2016-03-13T03:56:43.000Z","_content":"\n $ N $$ N \\leq 1000 $ $ N $ \n\n<!-- more -->\n\n### \n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### \n $ f(i, j) $  $ i $  $ j $  i  j $ i^3 $  $ x $  $ j + xi^3 \\leq 1000 $ $ f(i - 1, j) $  $ f(i, j + xi^3) $ $ f(21, n) $ \n\n 1000 \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11137.md","raw":"title: UVa 11137Ingenuous Cubrency -  /  DP\ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - DP\n  -  DP\npermalink: uva-11137\ndate: 2016-03-13 11:56:43\n---\n\n $ N $$ N \\leq 1000 $ $ N $ \n\n<!-- more -->\n\n### \n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### \n $ f(i, j) $  $ i $  $ j $  i  j $ i^3 $  $ x $  $ j + xi^3 \\leq 1000 $ $ f(i - 1, j) $  $ f(i, j + xi^3) $ $ f(21, n) $ \n\n 1000 \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11137","published":1,"updated":"2016-10-24T23:28:29.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9raw004zooxlsfkm9zyy"},{"title":"UVa 11021Tribles - ","date":"2016-05-31T12:05:00.000Z","_content":"\n $ k $  Tribles Trible  Trible  $ p_i $  $ i $  Tribles $ m $  Tribles \n\n<!-- more -->\n\n### \n[UVa 11021](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=481&page=show_problem&problem=1962)  \n[COGS 1487](http://cogs.top/cogs/problem/problem.php?pid=1487)\n\n### \n $ f(i) $  Trible  $ i $  $ x $  Trible  $ i $  $ f(i) ^ x $\n\n Trible  $ n $  Tribles  $ i - 1 $ \n\n $ f(0) = 1 $\n\n$$ f(i) = \\sum\\limits_{j = 0} ^ {n - 1} f(i - 1) ^ j \\times p(j) $$\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXK = 1000;\nconst int MAXM = 1000;\n\nint main() {\n\tint t, n, k, m;\n\tscanf(\"%d\", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\tscanf(\"%d %d %d\", &n, &k, &m);\n\t\tstatic double p[MAXN], f[MAXK + 1];\n\t\tfor (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n\t\tstd::fill(f, f + m + 1, 0);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i] += p[j] * pow(f[i - 1], j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case #%d: %.7lf\\n\", i, pow(f[m], k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11021.md","raw":"title: UVa 11021Tribles - \ncategories: OI\ntags: \n  - UVa\n  - COGS\n  - DP\n  - \n  - \npermalink: uva-11021\ndate: 2016-05-31 20:05:00\n---\n\n $ k $  Tribles Trible  Trible  $ p_i $  $ i $  Tribles $ m $  Tribles \n\n<!-- more -->\n\n### \n[UVa 11021](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=481&page=show_problem&problem=1962)  \n[COGS 1487](http://cogs.top/cogs/problem/problem.php?pid=1487)\n\n### \n $ f(i) $  Trible  $ i $  $ x $  Trible  $ i $  $ f(i) ^ x $\n\n Trible  $ n $  Tribles  $ i - 1 $ \n\n $ f(0) = 1 $\n\n$$ f(i) = \\sum\\limits_{j = 0} ^ {n - 1} f(i - 1) ^ j \\times p(j) $$\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXK = 1000;\nconst int MAXM = 1000;\n\nint main() {\n\tint t, n, k, m;\n\tscanf(\"%d\", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\tscanf(\"%d %d %d\", &n, &k, &m);\n\t\tstatic double p[MAXN], f[MAXK + 1];\n\t\tfor (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n\t\tstd::fill(f, f + m + 1, 0);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i] += p[j] * pow(f[i - 1], j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case #%d: %.7lf\\n\", i, pow(f[m], k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11021","published":1,"updated":"2016-10-24T23:28:54.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rb10057ooxl45cl24ny"},{"title":"UVa 10253Series-Parallel Networks -  + ","date":"2016-03-15T07:35:55.000Z","_content":"\n\n\n1. \n2.  $ G1 $  $ G2 $ \n3.  $ G1 $  $ G2 $  $ G1 $  $ G2 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### \n\n\n $ N $  $ f(n) $    $ n $ ****\n\n $ k $  $ i $ $ k $  $ f(i) $  $ k $  $ \\binom{f(i) + k - 1}{k} $\n\n $ f(n) * 2 $ $ n = 1 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","source":"_posts/uva-10253.md","raw":"title: UVa 10253Series-Parallel Networks -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: uva-10253\ndate: 2016-03-15 15:35:55\n---\n\n\n\n1. \n2.  $ G1 $  $ G2 $ \n3.  $ G1 $  $ G2 $  $ G1 $  $ G2 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### \n\n\n $ N $  $ f(n) $    $ n $ ****\n\n $ k $  $ i $ $ k $  $ f(i) $  $ k $  $ \\binom{f(i) + k - 1}{k} $\n\n $ f(n) * 2 $ $ n = 1 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","slug":"uva-10253","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rb5005fooxl4xju7de7"},{"title":"Tyvj 3317 -  DP","id":"18","updated":"2016-01-19T13:05:08.000Z","date":"2016-01-11T21:29:30.000Z","_content":"\nn2  n  10000\n\n$$\\cases{0< XL1 & C1 \\\\ L1< XL2 & C2 \\\\ L2< XL3 & C3}$$\n\nL1L2L3C1C2C3($1  L1 < L2 < L3  10^9$, $1  C1 < C2 < C3  10^9$) L3\n\n\n\n\n\n<!-- more -->\n\n### \n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### \n $a[i]$ `0`  `i`  $f[i]$  `s`  `i` \n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]L3\\} $$\n\n\n\n$$ f[s] = 0 $$\n\n### \n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```\n","source":"_posts/tyvj-3317.md","raw":"title: Tyvj 3317 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  -  DP\npermalink: tyvj-3317\nid: 18\nupdated: '2016-01-19 21:05:08'\ndate: 2016-01-12 05:29:30\n---\n\nn2  n  10000\n\n$$\\cases{0< XL1 & C1 \\\\ L1< XL2 & C2 \\\\ L2< XL3 & C3}$$\n\nL1L2L3C1C2C3($1  L1 < L2 < L3  10^9$, $1  C1 < C2 < C3  10^9$) L3\n\n\n\n\n\n<!-- more -->\n\n### \n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### \n $a[i]$ `0`  `i`  $f[i]$  `s`  `i` \n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]L3\\} $$\n\n\n\n$$ f[s] = 0 $$\n\n### \n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```\n","slug":"tyvj-3317","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rbg005rooxlwmmodxef"},{"title":"","date":"2015-12-27T14:48:11.000Z","_content":"\n 2016  12  28 \n\n\n\n![zyz ](images/zyz.png)\n\n<!-- more -->\n\n### \n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n****\n\n### \n![](tree-chain-split-notes/1.svg)\n\n********\n\n****  $ O(\\log n) $\n\n### \n```c++\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;  // \n    // maxChild \n\tNode *fa, *maxChild; \n    // size \n    // pos \n\tint size, dfn, pos, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top; // \n    // \n    int len;\n\n\tChain(Node *top) : top(top), len(0) {}\n};\n```\n\n $ v $$ \\text{depth}(v) $ $ \\text{size}(v) $ $ \\text{max-child}(v) $ \n\n $ c $  $ \\text{top}(c) $$ \\text{pos}(v) $  $ v $  $ \\text{pos} $  $ 1 $ $ \\text{pos}(\\text{top}(c)) = 1 $\n\n### \n```c++\ninline void split()\n{\n\tN[1].depth = 1; //  1\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n```\n\n DFS  DFS  $ v $  $ \\text{size}(v) $  $ \\text{max-child}(v) $\n\n```c++\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1; //  1\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n\t\tif (!e->to->vis)\n        {\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n            \n\t\t\tdfs1(e->to);\n            \n            // \n\t\t\tv->size += e->to->size;\n            \n            // \n            // \n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n```\n\n DFS\n\n$ \\text{max-child} $\n\n DFS  $ \\text{dfn}(v) $ DFS  DFS  $ \\text{max-child} $\n\n```c++\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0; // \n\tv->dfn = ++ts;     //  DFS \n\n\t// \n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain; // \n\n\t// \n    //  DFS \n\tif (v->maxChild) dfs2(v->maxChild); \n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n    \t// // \n\t\tif (e->to->fa == v && e->to != v->maxChild)\n        {\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n```\n\n### \n DFS \n\n```c++\nsegt = SegmentTree::build(1, n);\n```\n\n### \n DFS \n\n DFS \n\n```cpp\ninline void update(int u, int x) {\n\tsegt->update(N[u].dfn, x);\n}\n```\n\n### \n $ u $  $ v $ \n\n1.  $ u $  $ v $  $ u $ **** $ u $ $ \\text{top}(\\text{chain}(u)) $ $ u $  $ u $ ****\n2.  $ u $  $ v $ \n\n DFS \n\n```cpp\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n    {\n    \t//  u \n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN; // \n\twhile (u->chain != v->chain)\n    {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n```\n\n### \n LCA\n\n```c++\ninline Node *lca(Node *u, Node *v)\n{\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->fa;\n\t}\n\t\n\tif (u->depth > v->depth) std::swap(u, v);\n\treturn u;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;\n\tNode *fa, *maxChild;\n\tint size, dfn, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top;\n\n\tChain(Node *top) : top(top) {}\n};\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n}\n\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n\t\t\tdfs1(e->to);\n\t\t\tv->size += e->to->size;\n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = ++ts;\n\n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain;\n\n\tif (v->maxChild) dfs2(v->maxChild);\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->to->fa == v && e->to != v->maxChild)\n\t\t{\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n\ninline void split()\n{\n\tN[1].depth = 1;\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n\nstruct SegmentTree\n{\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint sum, max;\n\n\tSegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), sum(0), max(INT_MIN) {}\n\n\tvoid maintain()\n\t{\n\t\tsum = lc->sum + rc->sum;\n\t\tmax = std::max(lc->max, rc->max);\n\t}\n\n\tvoid update(int pos, int x)\n\t{\n\t\tif (l == r) sum = max = x;\n\t\telse\n\t\t{\n\t\t\tif (pos <= mid) lc->update(pos, x);\n\t\t\telse rc->update(pos, x);\n\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tint querySum(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return lc->querySum(l, r) + rc->querySum(l, r);\n\t}\n\n\tint queryMax(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc->queryMax(l, r), rc->queryMax(l, r));\n\t}\n\n\tstatic SegmentTree *build(int l, int r)\n\t{\n\t\tif (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse\n\t\t{\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\ninline void update(int u, int x)\n{\n\tsegt->update(N[u].dfn, x);\n}\n\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsplit();\n\n\tsegt = SegmentTree::build(1, n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tupdate(i, x);\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tchar cmd[sizeof(\"CHANGE\")];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", cmd, &a, &b);\n\n\t\tif (cmd[1] == 'H')\n\t\t{\n\t\t\tupdate(a, b);\n\t\t}\n\t\telse if (cmd[1] == 'S')\n\t\t{\n\t\t\tprintf(\"%d\\n\", querySum(a, b));\n\t\t}\n\t\telse if (cmd[1] == 'M')\n\t\t{\n\t\t\tprintf(\"%d\\n\", queryMax(a, b));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tree-chain-split-notes.md","raw":"title: \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  -   \npermalink: tree-chain-split-notes\ndate: 2015-12-27 22:48:11\n---\n\n 2016  12  28 \n\n\n\n![zyz ](images/zyz.png)\n\n<!-- more -->\n\n### \n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n****\n\n### \n![](tree-chain-split-notes/1.svg)\n\n********\n\n****  $ O(\\log n) $\n\n### \n```c++\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;  // \n    // maxChild \n\tNode *fa, *maxChild; \n    // size \n    // pos \n\tint size, dfn, pos, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top; // \n    // \n    int len;\n\n\tChain(Node *top) : top(top), len(0) {}\n};\n```\n\n $ v $$ \\text{depth}(v) $ $ \\text{size}(v) $ $ \\text{max-child}(v) $ \n\n $ c $  $ \\text{top}(c) $$ \\text{pos}(v) $  $ v $  $ \\text{pos} $  $ 1 $ $ \\text{pos}(\\text{top}(c)) = 1 $\n\n### \n```c++\ninline void split()\n{\n\tN[1].depth = 1; //  1\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n```\n\n DFS  DFS  $ v $  $ \\text{size}(v) $  $ \\text{max-child}(v) $\n\n```c++\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1; //  1\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n\t\tif (!e->to->vis)\n        {\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n            \n\t\t\tdfs1(e->to);\n            \n            // \n\t\t\tv->size += e->to->size;\n            \n            // \n            // \n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n```\n\n DFS\n\n$ \\text{max-child} $\n\n DFS  $ \\text{dfn}(v) $ DFS  DFS  $ \\text{max-child} $\n\n```c++\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0; // \n\tv->dfn = ++ts;     //  DFS \n\n\t// \n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain; // \n\n\t// \n    //  DFS \n\tif (v->maxChild) dfs2(v->maxChild); \n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n    \t// // \n\t\tif (e->to->fa == v && e->to != v->maxChild)\n        {\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n```\n\n### \n DFS \n\n```c++\nsegt = SegmentTree::build(1, n);\n```\n\n### \n DFS \n\n DFS \n\n```cpp\ninline void update(int u, int x) {\n\tsegt->update(N[u].dfn, x);\n}\n```\n\n### \n $ u $  $ v $ \n\n1.  $ u $  $ v $  $ u $ **** $ u $ $ \\text{top}(\\text{chain}(u)) $ $ u $  $ u $ ****\n2.  $ u $  $ v $ \n\n DFS \n\n```cpp\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n    {\n    \t//  u \n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN; // \n\twhile (u->chain != v->chain)\n    {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n```\n\n### \n LCA\n\n```c++\ninline Node *lca(Node *u, Node *v)\n{\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->fa;\n\t}\n\t\n\tif (u->depth > v->depth) std::swap(u, v);\n\treturn u;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;\n\tNode *fa, *maxChild;\n\tint size, dfn, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top;\n\n\tChain(Node *top) : top(top) {}\n};\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n}\n\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n\t\t\tdfs1(e->to);\n\t\t\tv->size += e->to->size;\n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = ++ts;\n\n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain;\n\n\tif (v->maxChild) dfs2(v->maxChild);\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->to->fa == v && e->to != v->maxChild)\n\t\t{\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n\ninline void split()\n{\n\tN[1].depth = 1;\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n\nstruct SegmentTree\n{\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint sum, max;\n\n\tSegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), sum(0), max(INT_MIN) {}\n\n\tvoid maintain()\n\t{\n\t\tsum = lc->sum + rc->sum;\n\t\tmax = std::max(lc->max, rc->max);\n\t}\n\n\tvoid update(int pos, int x)\n\t{\n\t\tif (l == r) sum = max = x;\n\t\telse\n\t\t{\n\t\t\tif (pos <= mid) lc->update(pos, x);\n\t\t\telse rc->update(pos, x);\n\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tint querySum(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return lc->querySum(l, r) + rc->querySum(l, r);\n\t}\n\n\tint queryMax(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc->queryMax(l, r), rc->queryMax(l, r));\n\t}\n\n\tstatic SegmentTree *build(int l, int r)\n\t{\n\t\tif (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse\n\t\t{\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\ninline void update(int u, int x)\n{\n\tsegt->update(N[u].dfn, x);\n}\n\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsplit();\n\n\tsegt = SegmentTree::build(1, n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tupdate(i, x);\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tchar cmd[sizeof(\"CHANGE\")];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", cmd, &a, &b);\n\n\t\tif (cmd[1] == 'H')\n\t\t{\n\t\t\tupdate(a, b);\n\t\t}\n\t\telse if (cmd[1] == 'S')\n\t\t{\n\t\t\tprintf(\"%d\\n\", querySum(a, b));\n\t\t}\n\t\telse if (cmd[1] == 'M')\n\t\t{\n\t\t\tprintf(\"%d\\n\", queryMax(a, b));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tree-chain-split-notes","published":1,"updated":"2017-01-01T01:45:30.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rbn0060ooxlf67buek0"},{"title":"TJOI2015 -  DP + ","date":"2016-10-07T23:39:00.000Z","_content":"\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4000](http://www.lydsy.com/JudgeOnline/problem.php?id=4000)  \n[COGS 1979](http://cogs.pro/cogs/problem/problem.php?pid=1979)\n\n### \n\n\n $ f(i, j) $  $ i $  $ i $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\nconst int MAXM = 6;\nconst int MAXSTATUS = 1 << 6;\n\nstruct Matrix {\n\tunsigned int a[MAXSTATUS][MAXSTATUS];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXSTATUS; i++) a[i][i] = true;\n\t}\n\n\tunsigned int &operator()(const int i, const int j) { return a[i][j]; }\n\tconst unsigned int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) for (int k = 0; k < MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j);\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\n#ifdef DBG\ninline void print(const int x, const int m) {\n\tfor (int i = 0; i < m; i++) putchar((x & (1 << i)) ? '1' : '0');\n\t// putchar('\\n');\n}\n#endif\n\nint m, w, pos;\n\ninline void apply(const bool *tpl, const int j, bool *target) {\n\tfor (int k = 0; k < w; k++) {\n\t\tif (j - pos + k >= 0 && j - pos + k < m && tpl[k]) target[j - pos + k] = true;\n\t}\n}\n\nint main() {\n\tfreopen(\"tjoi2015_board.in\", \"r\", stdin);\n\tfreopen(\"tjoi2015_board.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d %d %d %d\", &n, &m, &w, &pos);\n\n\tstatic bool attack[3][MAXM];\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < w; j++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tattack[i][j] = x;\n\t}\n\tattack[1][pos] = false;\n\n\tstatic bool valid[MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tstatic bool tmp[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmp[k] = false;\n\t\tvalid[i] = true;\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j)) apply(attack[1], j, tmp);\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j) && tmp[j]) {\n\t\t\tvalid[i] = false;\n\t\t\tbreak;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(valid[i] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar('\\n');\n#endif\n\t}\n\n\tstatic bool near[MAXSTATUS][MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) for (int j = 0; j < (1 << m); j++) {\n\t\tif (!valid[i] || !valid[j]) {\n\t\t\tnear[i][j] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnear[i][j] = true;\n\t\tstatic bool tmpA[MAXM], tmpB[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmpA[k] = tmpB[k] = false;\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(i & (1 << k))) continue;\n\t\t\tapply(attack[2], k, tmpB);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(j & (1 << k))) continue;\n\t\t\tapply(attack[0], k, tmpA);\n\t\t}\n\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (((i & (1 << k)) && tmpA[k]) || ((j & (1 << k)) && tmpB[k])) {\n\t\t\t\tnear[i][j] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(near[i][j] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar(' ');\n\t\tprint(j, m);\n\t\tputchar('\\n');\n\n\t\tif (valid[i] && valid[j]) printf(\"near[%d][%d] = %d\\n\", i, j, static_cast<int>(near[i][j]));\n#endif\n\t}\n\n#ifdef DBG\n\tstatic unsigned int f[MAXN + 1][MAXSTATUS];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tif (!valid[j]) continue;\n\t\t\tfor (int k = 0; k < (1 << m); k++) {\n\t\t\t\tif (!valid[k]) continue;\n\t\t\t\tif (near[k][j]) f[i][j] += f[i - 1][k];\n\t\t\t}\n\n\t\t\tprintf(\"f(%d, [\", i);\n\t\t\tprint(j, m);\n\t\t\tprintf(\"] = %u\\n\", f[i][j]);\n\t\t}\n\t}\n\n\tunsigned int ansCheck = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ansCheck += f[n][i];\n#endif\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tif (valid[i]) {\n\t\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\t\tif (valid[j]) {\n\t\t\t\t\tif (near[j][i]) {\n\t\t\t\t\t\tshift(j, i) = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\n#ifndef FORCE\n\tMatrix res = pow(shift, n) * init;\n#else\n\tMatrix res(true);\n\tfor (int i = 1; i <= n; i++) {\n\t\tres = res * shift;\n#ifdef DBG\n\t\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) printf(\"%d%c\", res(i, j), j == MAXSTATUS - 1 ? '\\n' : ' ');\n#endif\n\t}\n\tres = res * init;\n#endif\n\n\tunsigned int ans = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ans += res(i, 0);\n\tprintf(\"%u\\n\", ans);\n\n#ifdef DBG\n\tprintf(\"ansCheck = %u\\n\", ansCheck);\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2015-chessboard.md","raw":"title: TJOI2015 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  -  DP\n  - \npermalink: tjoi2015-chessboard\ndate: 2016-10-08 07:39:00\n---\n\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4000](http://www.lydsy.com/JudgeOnline/problem.php?id=4000)  \n[COGS 1979](http://cogs.pro/cogs/problem/problem.php?pid=1979)\n\n### \n\n\n $ f(i, j) $  $ i $  $ i $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\nconst int MAXM = 6;\nconst int MAXSTATUS = 1 << 6;\n\nstruct Matrix {\n\tunsigned int a[MAXSTATUS][MAXSTATUS];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXSTATUS; i++) a[i][i] = true;\n\t}\n\n\tunsigned int &operator()(const int i, const int j) { return a[i][j]; }\n\tconst unsigned int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) for (int k = 0; k < MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j);\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\n#ifdef DBG\ninline void print(const int x, const int m) {\n\tfor (int i = 0; i < m; i++) putchar((x & (1 << i)) ? '1' : '0');\n\t// putchar('\\n');\n}\n#endif\n\nint m, w, pos;\n\ninline void apply(const bool *tpl, const int j, bool *target) {\n\tfor (int k = 0; k < w; k++) {\n\t\tif (j - pos + k >= 0 && j - pos + k < m && tpl[k]) target[j - pos + k] = true;\n\t}\n}\n\nint main() {\n\tfreopen(\"tjoi2015_board.in\", \"r\", stdin);\n\tfreopen(\"tjoi2015_board.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d %d %d %d\", &n, &m, &w, &pos);\n\n\tstatic bool attack[3][MAXM];\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < w; j++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tattack[i][j] = x;\n\t}\n\tattack[1][pos] = false;\n\n\tstatic bool valid[MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tstatic bool tmp[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmp[k] = false;\n\t\tvalid[i] = true;\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j)) apply(attack[1], j, tmp);\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j) && tmp[j]) {\n\t\t\tvalid[i] = false;\n\t\t\tbreak;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(valid[i] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar('\\n');\n#endif\n\t}\n\n\tstatic bool near[MAXSTATUS][MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) for (int j = 0; j < (1 << m); j++) {\n\t\tif (!valid[i] || !valid[j]) {\n\t\t\tnear[i][j] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnear[i][j] = true;\n\t\tstatic bool tmpA[MAXM], tmpB[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmpA[k] = tmpB[k] = false;\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(i & (1 << k))) continue;\n\t\t\tapply(attack[2], k, tmpB);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(j & (1 << k))) continue;\n\t\t\tapply(attack[0], k, tmpA);\n\t\t}\n\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (((i & (1 << k)) && tmpA[k]) || ((j & (1 << k)) && tmpB[k])) {\n\t\t\t\tnear[i][j] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(near[i][j] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar(' ');\n\t\tprint(j, m);\n\t\tputchar('\\n');\n\n\t\tif (valid[i] && valid[j]) printf(\"near[%d][%d] = %d\\n\", i, j, static_cast<int>(near[i][j]));\n#endif\n\t}\n\n#ifdef DBG\n\tstatic unsigned int f[MAXN + 1][MAXSTATUS];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tif (!valid[j]) continue;\n\t\t\tfor (int k = 0; k < (1 << m); k++) {\n\t\t\t\tif (!valid[k]) continue;\n\t\t\t\tif (near[k][j]) f[i][j] += f[i - 1][k];\n\t\t\t}\n\n\t\t\tprintf(\"f(%d, [\", i);\n\t\t\tprint(j, m);\n\t\t\tprintf(\"] = %u\\n\", f[i][j]);\n\t\t}\n\t}\n\n\tunsigned int ansCheck = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ansCheck += f[n][i];\n#endif\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tif (valid[i]) {\n\t\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\t\tif (valid[j]) {\n\t\t\t\t\tif (near[j][i]) {\n\t\t\t\t\t\tshift(j, i) = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\n#ifndef FORCE\n\tMatrix res = pow(shift, n) * init;\n#else\n\tMatrix res(true);\n\tfor (int i = 1; i <= n; i++) {\n\t\tres = res * shift;\n#ifdef DBG\n\t\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) printf(\"%d%c\", res(i, j), j == MAXSTATUS - 1 ? '\\n' : ' ');\n#endif\n\t}\n\tres = res * init;\n#endif\n\n\tunsigned int ans = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ans += res(i, 0);\n\tprintf(\"%u\\n\", ans);\n\n#ifdef DBG\n\tprintf(\"ansCheck = %u\\n\", ansCheck);\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"tjoi2015-chessboard","published":1,"updated":"2016-10-24T23:29:16.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rbw0069ooxlmf2loxri"},{"title":"TJOI2013 - AC ","date":"2016-09-11T23:07:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 3172](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n### \nAC  AC  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1e6 + 200;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst char BASE_CHAR = '`';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n#ifdef DBG\n\t\tchar ch;\n#endif\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n#ifdef DBG\n\t\tv = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = &(*v)->c[*p];\n\t\t\t(*v)->ch = *p + 'a';\n\t\t}\n#endif\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\tchar *p = s;\n\n\tstatic Trie::Node *node[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n\t\t*p++ = 0;\n\t\tnode[i] = t.insert(s, s + len);\n\t}\n\n\t*--p = 0;\n\t// for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR);\n\n\tt.build();\n\tt.exec(s, p);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", node[i]->ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-word.md","raw":"title: TJOI2013 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - \n  - AC \npermalink: tjoi2013-word\ndate: 2016-09-12 07:07:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3172](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n### \nAC  AC  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1e6 + 200;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst char BASE_CHAR = '`';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n#ifdef DBG\n\t\tchar ch;\n#endif\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n#ifdef DBG\n\t\tv = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = &(*v)->c[*p];\n\t\t\t(*v)->ch = *p + 'a';\n\t\t}\n#endif\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\tchar *p = s;\n\n\tstatic Trie::Node *node[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n\t\t*p++ = 0;\n\t\tnode[i] = t.insert(s, s + len);\n\t}\n\n\t*--p = 0;\n\t// for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR);\n\n\tt.build();\n\tt.exec(s, p);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", node[i]->ans);\n\n\treturn 0;\n}\n```\n","slug":"tjoi2013-word","published":1,"updated":"2016-10-07T23:45:42.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rc1006hooxlvjp7qzfs"},{"title":"TJOI2013 -  + ","date":"2016-04-03T14:49:33.000Z","_content":"\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-lis.md","raw":"title: TJOI2013 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - \n  - Splay\n  - \npermalink: tjoi2013-lis\ndate: 2016-04-03 22:49:33\n---\n\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tjoi2013-lis","published":1,"updated":"2016-10-07T23:45:34.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rc6006pooxlzn7qpvcm"},{"title":"","date":"2016-12-31T04:41:00.000Z","_content":"\n\n\n<!-- more -->\n\n   \n   \n \n\n\n\n         \n \n\n  \n  \n\n\n\n\n\n\n   \n   \n \n\n\n\n OI   \n  \n\n\n  \n\n\n\n\n  \n  \n  \n\n\n  \n \n","source":"_posts/the-ever-heart.md","raw":"title: \ncategories: \n  - Diary\npermalink: the-ever-heart\ndate: 2016-12-31 12:41:00\n---\n\n\n\n<!-- more -->\n\n   \n   \n \n\n\n\n         \n \n\n  \n  \n\n\n\n\n\n\n   \n   \n \n\n\n\n OI   \n  \n\n\n  \n\n\n\n\n  \n  \n  \n\n\n  \n \n","slug":"the-ever-heart","published":1,"updated":"2016-12-31T05:02:27.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcc006zooxl7j0zh7n1"},{"title":"Tarjan ","date":"2016-03-03T13:12:23.000Z","_content":"\n********************\n\nTarjan  $ O(n + m) $ \n\n<!-- more -->\n\n### \nTarjan  DFS\n\n\n\n$ {\\rm dfn}(u) $  $ u $ \n\n$ {\\rm low}(u) $  $ u $  $ u $  $ {\\rm dfn} $  $ {\\rm dfn} $\n\n### \n1.  DFS\n2.  $ {\\rm dfn} $  $ {\\rm low} $ \n3.  $ v $ \n4.  $ u $  $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $\n5.  $ u $  $ u $  DFS $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $\n6.  $ {\\rm low}(v) = {\\rm dfn}(v) $ $ v $ \n\n### \n $ v $  $ u $ \n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n $ v $  $ u $  $ v $ \n\n $ u $  $ u $  DFS\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n $ u $  $ v $  $ {\\rm low}(u) $  $ v $  $ u $  $ v $ \n\n\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n\n\n $ {\\rm low} $ $ {\\rm low} $ \n\n### \n DFS `s` Tarjan  `t`\n\n\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","source":"_posts/tarjan-scc-notes.md","raw":"title: Tarjan \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Tarjan\n  - \npermalink: tarjan-scc-notes\ndate: 2016-03-03 21:12:23\n---\n\n********************\n\nTarjan  $ O(n + m) $ \n\n<!-- more -->\n\n### \nTarjan  DFS\n\n\n\n$ {\\rm dfn}(u) $  $ u $ \n\n$ {\\rm low}(u) $  $ u $  $ u $  $ {\\rm dfn} $  $ {\\rm dfn} $\n\n### \n1.  DFS\n2.  $ {\\rm dfn} $  $ {\\rm low} $ \n3.  $ v $ \n4.  $ u $  $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $\n5.  $ u $  $ u $  DFS $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $\n6.  $ {\\rm low}(v) = {\\rm dfn}(v) $ $ v $ \n\n### \n $ v $  $ u $ \n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n $ v $  $ u $  $ v $ \n\n $ u $  $ u $  DFS\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n $ u $  $ v $  $ {\\rm low}(u) $  $ v $  $ u $  $ v $ \n\n\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n\n\n $ {\\rm low} $ $ {\\rm low} $ \n\n### \n DFS `s` Tarjan  `t`\n\n\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","slug":"tarjan-scc-notes","published":1,"updated":"2016-12-21T02:08:20.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcj0072ooxl3m66k49j"},{"title":"Tarjan ","date":"2016-09-08T11:45:00.000Z","_content":"\n $ v $  $ v $ ****\n\n<!-- more -->\n\n### \n$ \\mathrm{dfn}(u) $  $ u $ \n\n$ \\mathrm{low}(u) $  $ u $  $ u $  $ \\mathrm{dfn} $  $ \\mathrm{dfn} $\n\n### \n Tarjan \n\n1.  DFS\n2.  $ \\mathrm{dfn} $  $ \\mathrm{low} $ \n3.  $ v $ \n4.  $ u $  $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{dfn}(u)) $\n5.  $ u $  $ u $  DFS $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{low(u)}) $\n6.  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n7. \n\n### \n> \n\n\n\n>  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n\n$ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ v $  $ u $ \n\n### \nCodeVS 5524\n\n 2016  12  29 \n\n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tNode *fa;\n\tint dfn, low;\n\tbool vis, isCut;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].firstEdge = new Edge(&N[s], &N[t]);\n\tN[t].firstEdge = new Edge(&N[t], &N[s]);\n}\n\ninline int tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint res = 0, childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\tres += tarjan(e->to);\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (v->fa)\n\t\t\t{\n\t\t\t\t//  v\n\t\t\t\tif (e->to->low >= v->dfn) v->isCut = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// \n\t\t\t\t// \n\t\t\t\tif (++childCnt == 2) v->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//  DFS \n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (v->isCut) res++;\n\n\treturn res;\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis) ans += tarjan(&N[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\tN[i].vis = N[i].isCut = false;\n\t\tN[i].dfn = N[i].low = 0;\n\t\tN[i].fa = NULL;\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n```c++\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n```\n","source":"_posts/tarjan-cut-notes.md","raw":"title: Tarjan \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Tarjan\n  - \npermalink: tarjan-cut-notes\ndate: 2016-09-08 19:45:00\n---\n\n $ v $  $ v $ ****\n\n<!-- more -->\n\n### \n$ \\mathrm{dfn}(u) $  $ u $ \n\n$ \\mathrm{low}(u) $  $ u $  $ u $  $ \\mathrm{dfn} $  $ \\mathrm{dfn} $\n\n### \n Tarjan \n\n1.  DFS\n2.  $ \\mathrm{dfn} $  $ \\mathrm{low} $ \n3.  $ v $ \n4.  $ u $  $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{dfn}(u)) $\n5.  $ u $  $ u $  DFS $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{low(u)}) $\n6.  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n7. \n\n### \n> \n\n\n\n>  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n\n$ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ v $  $ u $ \n\n### \nCodeVS 5524\n\n 2016  12  29 \n\n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tNode *fa;\n\tint dfn, low;\n\tbool vis, isCut;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].firstEdge = new Edge(&N[s], &N[t]);\n\tN[t].firstEdge = new Edge(&N[t], &N[s]);\n}\n\ninline int tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint res = 0, childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\tres += tarjan(e->to);\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (v->fa)\n\t\t\t{\n\t\t\t\t//  v\n\t\t\t\tif (e->to->low >= v->dfn) v->isCut = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// \n\t\t\t\t// \n\t\t\t\tif (++childCnt == 2) v->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//  DFS \n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (v->isCut) res++;\n\n\treturn res;\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis) ans += tarjan(&N[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\tN[i].vis = N[i].isCut = false;\n\t\tN[i].dfn = N[i].low = 0;\n\t\tN[i].fa = NULL;\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n```c++\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n```\n","slug":"tarjan-cut-notes","published":1,"updated":"2017-01-01T01:45:20.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcq007cooxll7931685"},{"title":"Tarjan ","date":"2017-01-01T00:09:00.000Z","_content":"\n\n\n<!-- more -->\n\n### POJ 1523\n![zyz ](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge, *inEdge;\n\tint dfn, low;\n\tbool vis, isCut;\n\tNode *fa;\n\tstd::vector<struct BCC *> inBCC; // \n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next, *revEdge; // \n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct BCC\n{\n\tstd::vector<Node *> nodes; // \n} bccs[MAXN + 1];\n\nint cnt;\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n\n\tN[from].firstEdge->revEdge = N[to].firstEdge;\n\tN[to].firstEdge->revEdge = N[from].firstEdge;\n}\n\ninline void tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tstatic std::stack<Edge *> s;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->revEdge == v->inEdge) continue; // \n\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\ts.push(e); // \n\n\t\t\tchildCnt++;\n\n\t\t\te->to->fa = v;\n\t\t\te->to->inEdge = e; // \n\t\t\ttarjan(e->to);\n\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (e->to->low >= v->dfn) // \n\t\t\t{\n\t\t\t\tv->isCut = true;      // \n\n\t\t\t\t// \n\t\t\t\tEdge *tmp;\n\t\t\t\tBCC *bcc = &bccs[++cnt];\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\ttmp = s.top();\n\t\t\t\t\ts.pop();\n\n\t\t\t\t\t//  bcc\n\t\t\t\t\t// \n\t\t\t\t\tif (tmp->from->inBCC.empty() || tmp->from->inBCC.back() != bcc)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp->from->inBCC.push_back(bcc);\n\t\t\t\t\t\tbcc->nodes.push_back(tmp->from);\n\t\t\t\t\t}\n\n\t\t\t\t\t// \n\t\t\t\t\tif (tmp->to->inBCC.empty() || tmp->to->inBCC.back() != bcc)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp->to->inBCC.push_back(bcc);\n\t\t\t\t\t\tbcc->nodes.push_back(tmp->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (tmp != e); // \n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts.push(e); // \n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (!v->fa && childCnt < 2) v->isCut = false; //  2\n}\n\nint main() {\n\tint T = 0;\n\twhile (1)\n\t{\n\t\t++T;\n\n\t\tint n = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(\"%d\", &u);\n\n\t\t\tif (u == 0) break;\n\n\t\t\tscanf(\"%d\", &v);\n\n\t\t\tn = std::max(n, u);\n\t\t\tn = std::max(n, v);\n\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (!N[i].vis) tarjan(&N[i]);\n\t\t}\n\n\t\tif (T != 1) putchar('\\n');\n\t\tprintf(\"Network #%d\\n\", T);\n\n\t\tbool flag = false;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].isCut)\n\t\t\t{\n\t\t\t\tprintf(\"  SPF node %d leaves %d subnets\\n\", i, int(N[i].inBCC.size()));\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!flag) puts(\"  No SPF nodes\");\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].isCut = N[i].vis = false;\n\t\t\tN[i].fa = NULL;\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].inBCC.clear();\n\t\t}\n\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tbccs[i].nodes.clear();\n\t\t}\n\n\t\tcnt = 0;\n\n\t\tif (n == 0) break;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tarjan-bcc-notes.md","raw":"title: Tarjan \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Tarjan\n  - \npermalink: tarjan-bcc-notes\ndate: 2017-01-01 08:09:00\n---\n\n\n\n<!-- more -->\n\n### POJ 1523\n![zyz ](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge, *inEdge;\n\tint dfn, low;\n\tbool vis, isCut;\n\tNode *fa;\n\tstd::vector<struct BCC *> inBCC; // \n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next, *revEdge; // \n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct BCC\n{\n\tstd::vector<Node *> nodes; // \n} bccs[MAXN + 1];\n\nint cnt;\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n\n\tN[from].firstEdge->revEdge = N[to].firstEdge;\n\tN[to].firstEdge->revEdge = N[from].firstEdge;\n}\n\ninline void tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tstatic std::stack<Edge *> s;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->revEdge == v->inEdge) continue; // \n\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\ts.push(e); // \n\n\t\t\tchildCnt++;\n\n\t\t\te->to->fa = v;\n\t\t\te->to->inEdge = e; // \n\t\t\ttarjan(e->to);\n\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (e->to->low >= v->dfn) // \n\t\t\t{\n\t\t\t\tv->isCut = true;      // \n\n\t\t\t\t// \n\t\t\t\tEdge *tmp;\n\t\t\t\tBCC *bcc = &bccs[++cnt];\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\ttmp = s.top();\n\t\t\t\t\ts.pop();\n\n\t\t\t\t\t//  bcc\n\t\t\t\t\t// \n\t\t\t\t\tif (tmp->from->inBCC.empty() || tmp->from->inBCC.back() != bcc)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp->from->inBCC.push_back(bcc);\n\t\t\t\t\t\tbcc->nodes.push_back(tmp->from);\n\t\t\t\t\t}\n\n\t\t\t\t\t// \n\t\t\t\t\tif (tmp->to->inBCC.empty() || tmp->to->inBCC.back() != bcc)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp->to->inBCC.push_back(bcc);\n\t\t\t\t\t\tbcc->nodes.push_back(tmp->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (tmp != e); // \n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts.push(e); // \n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (!v->fa && childCnt < 2) v->isCut = false; //  2\n}\n\nint main() {\n\tint T = 0;\n\twhile (1)\n\t{\n\t\t++T;\n\n\t\tint n = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(\"%d\", &u);\n\n\t\t\tif (u == 0) break;\n\n\t\t\tscanf(\"%d\", &v);\n\n\t\t\tn = std::max(n, u);\n\t\t\tn = std::max(n, v);\n\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\tif (n == 0) break;\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (!N[i].vis) tarjan(&N[i]);\n\t\t}\n\n\t\tif (T != 1) putchar('\\n');\n\t\tprintf(\"Network #%d\\n\", T);\n\n\t\tbool flag = false;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].isCut)\n\t\t\t{\n\t\t\t\tprintf(\"  SPF node %d leaves %d subnets\\n\", i, int(N[i].inBCC.size()));\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!flag) puts(\"  No SPF nodes\");\n\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].isCut = N[i].vis = false;\n\t\t\tN[i].fa = NULL;\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].inBCC.clear();\n\t\t}\n\n\t\tfor (int i = 1; i <= cnt; i++)\n\t\t{\n\t\t\tbccs[i].nodes.clear();\n\t\t}\n\n\t\tcnt = 0;\n\n\t\tif (n == 0) break;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tarjan-bcc-notes","published":1,"updated":"2017-01-01T01:45:08.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcu007kooxl669tzoxp"},{"title":"","date":"2016-01-01T16:18:34.000Z","_content":"\n $x_i-x_j>=d$ \n\n<!-- more -->\n\n### \n\n\n `from``to` `$` \n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n\n\n```php\n$to - $from >= w\n```\n\n********\n\n****\n\n### \n $x_i-x_j>=d$ `j`  `i`  `d`\n\n $x_i-x_j>=d$ `-1` $x_j-x_i<=-d$ `i`  `j`  `-d`\n\n `dist`  `0` `dist`  `dist` \n\n Bellman-Ford  Bellman-Ford  `n - 1` ****\n\n Bellman-Ford  `n` ****\n\n### \n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF \n\n `n`  $x_i-x_j<=d$  $x_i-x_j>=d$  $x_1$  $x_n$  `-1` $x_1$  $x_n$  `-2`\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/system-of-difference-constraints-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: system-of-difference-constraints-notes\ndate: 2016-01-02 00:18:34\n---\n\n $x_i-x_j>=d$ \n\n<!-- more -->\n\n### \n\n\n `from``to` `$` \n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n\n\n```php\n$to - $from >= w\n```\n\n********\n\n****\n\n### \n $x_i-x_j>=d$ `j`  `i`  `d`\n\n $x_i-x_j>=d$ `-1` $x_j-x_i<=-d$ `i`  `j`  `-d`\n\n `dist`  `0` `dist`  `dist` \n\n Bellman-Ford  Bellman-Ford  `n - 1` ****\n\n Bellman-Ford  `n` ****\n\n### \n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF \n\n `n`  $x_i-x_j<=d$  $x_i-x_j>=d$  $x_1$  $x_n$  `-1` $x_1$  $x_n$  `-2`\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"system-of-difference-constraints-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rcx007sooxl0re9kkbg"},{"title":"","date":"2016-04-12T11:29:14.000Z","_content":"\n OI   \n\n<!-- more -->\n\n### \n $ s $  $ 0 $  $ {\\rm length}(s) $\n\n$ {\\rm suffix}(i) $  $ s $  $ i $  $ s[i] $ ~ $ s[n - 1] $ \n\n  \n ASCII  ASCII   \n  \n\n\n****\n\n$ {\\rm SA}[] $  $ s $ $ {\\rm SA}[i] $  $ i $ \n\n$ {\\rm rank}[] $  $ {\\rm SA}[] $ $ {\\rm rank}[i] $  $ {\\rm suffix}(i) $  $ {\\rm rank}[{\\rm SA}[i]] = i $ $ i $  $ i $\n\n$ {\\rm height}[] $ Longest Common PrefixLCP\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n $ {\\rm height}[i] $  $ x $ $ k \\in [0, x) $  $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $\n\n### \n#### \n $ O(n ^ 2 \\log n) $\n\n**** $ O(n) $  $ O(n) $ \n\n#####  Hash \n Hash BKDRHash  $ O(n) $  $ O(1) $  Hash \n\n LCP  $ O(n \\log n \\log n) $\n\n Hash  `std::set` Hash \n\n#### \n**** $ i $  $ 2 ^ k $ \n\n `\"heheda\"` $ 2 ^ 0 = 1 $ \n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n $ 2 ^ 1 = 2 $  $ i $  $ 2 ^ 0 = 1 $  $ i $ **** $ i + 2 ^ 0 = i + 1 $  $ 2 ^ 0 = 1 $  $ i $ ****\n\n $ i + 2 ^ 0 \\geq n $  $ -1 $\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n $ 2 ^ 2 = 4 $ \n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n $ {\\rm rank}[] $  $ O(\\log n) $  $ {\\rm rank}[] $ \n\n $ O(n \\log n \\log n) $ Hash  $ [-1, n) $  $ O(n) $  $ O(n \\log n) $\n\n##### \n\n $ [0, n) $ \n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir`  `sec` `buc`  $ [-1, n) $\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n $ O(\\log n) $ \n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n$ {\\rm tmp}[i] $  $ i $ ****\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n $ {\\rm tmp}[] $  $ {\\rm tmp}[] $ \n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n $ {\\rm SA}[] $  $ {\\rm rank}[] $\n\n1.  $ 0 $\n2. \n3.  $ + 1 $\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n DC3\n\n### \n $ {\\rm height}[] $  $ {\\rm height}[] $ $ O(n ^ 2) $\n\n#### \n $ h(i) $  $ i $  $ {\\rm rank}[i] > 0 $ \n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n $ h(i) $\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n $ h(i - 1) < 1 $  $ h(i - 1) \\geq 1 $ \n\n $ u = {\\rm suffix}(i) $$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $ $ i $   \n $ u' = {\\rm suffix}(i - 1) $$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $ $ i - 1 $ \n\n $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $\n\n `\"heheheda\"` \n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n $ h(i - 1) \\geq 1 $ $ u' $  $ v' $  $ {\\rm LCP}(u', v') - 1 $ $ u $  $ v $\t $ u $  $ v $ $ {\\rm LCP}(u, v) $ \n\n#### \n $ {\\rm height}[{\\rm SA}[i]] $   \n $ k = {\\rm height}[{\\rm rank}[i - 1]] $ $ h(i - 1) $ $ {\\rm height}[{\\rm rank}[i]] $ $ k $  $ 1 $ $ n $ $ O(n) $  \n $ O(n \\log n) $ \n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n$ {\\rm height}[0] $ \n\n### \n $ {\\rm height}[] $\n\n************\n\n $ {\\rm height} $ \n\nRange Minimum/Maximum QueryRMQSparse TableST $ O(n \\log n) $  $ O(1) $ \n\n#### \n $ {\\rm st}[i][t] $  $ [i, i + 2 ^ t] $  $ {\\rm LCP}(i, i + 2 ^ t) $\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### \n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","source":"_posts/suffix-array-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: suffix-array-notes\ndate: 2016-04-12 19:29:14\n---\n\n OI   \n\n<!-- more -->\n\n### \n $ s $  $ 0 $  $ {\\rm length}(s) $\n\n$ {\\rm suffix}(i) $  $ s $  $ i $  $ s[i] $ ~ $ s[n - 1] $ \n\n  \n ASCII  ASCII   \n  \n\n\n****\n\n$ {\\rm SA}[] $  $ s $ $ {\\rm SA}[i] $  $ i $ \n\n$ {\\rm rank}[] $  $ {\\rm SA}[] $ $ {\\rm rank}[i] $  $ {\\rm suffix}(i) $  $ {\\rm rank}[{\\rm SA}[i]] = i $ $ i $  $ i $\n\n$ {\\rm height}[] $ Longest Common PrefixLCP\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n $ {\\rm height}[i] $  $ x $ $ k \\in [0, x) $  $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $\n\n### \n#### \n $ O(n ^ 2 \\log n) $\n\n**** $ O(n) $  $ O(n) $ \n\n#####  Hash \n Hash BKDRHash  $ O(n) $  $ O(1) $  Hash \n\n LCP  $ O(n \\log n \\log n) $\n\n Hash  `std::set` Hash \n\n#### \n**** $ i $  $ 2 ^ k $ \n\n `\"heheda\"` $ 2 ^ 0 = 1 $ \n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n $ 2 ^ 1 = 2 $  $ i $  $ 2 ^ 0 = 1 $  $ i $ **** $ i + 2 ^ 0 = i + 1 $  $ 2 ^ 0 = 1 $  $ i $ ****\n\n $ i + 2 ^ 0 \\geq n $  $ -1 $\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n $ 2 ^ 2 = 4 $ \n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n $ {\\rm rank}[] $  $ O(\\log n) $  $ {\\rm rank}[] $ \n\n $ O(n \\log n \\log n) $ Hash  $ [-1, n) $  $ O(n) $  $ O(n \\log n) $\n\n##### \n\n $ [0, n) $ \n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir`  `sec` `buc`  $ [-1, n) $\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n $ O(\\log n) $ \n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n$ {\\rm tmp}[i] $  $ i $ ****\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n $ {\\rm tmp}[] $  $ {\\rm tmp}[] $ \n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n $ {\\rm SA}[] $  $ {\\rm rank}[] $\n\n1.  $ 0 $\n2. \n3.  $ + 1 $\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n DC3\n\n### \n $ {\\rm height}[] $  $ {\\rm height}[] $ $ O(n ^ 2) $\n\n#### \n $ h(i) $  $ i $  $ {\\rm rank}[i] > 0 $ \n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n $ h(i) $\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n $ h(i - 1) < 1 $  $ h(i - 1) \\geq 1 $ \n\n $ u = {\\rm suffix}(i) $$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $ $ i $   \n $ u' = {\\rm suffix}(i - 1) $$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $ $ i - 1 $ \n\n $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $\n\n `\"heheheda\"` \n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n $ h(i - 1) \\geq 1 $ $ u' $  $ v' $  $ {\\rm LCP}(u', v') - 1 $ $ u $  $ v $\t $ u $  $ v $ $ {\\rm LCP}(u, v) $ \n\n#### \n $ {\\rm height}[{\\rm SA}[i]] $   \n $ k = {\\rm height}[{\\rm rank}[i - 1]] $ $ h(i - 1) $ $ {\\rm height}[{\\rm rank}[i]] $ $ k $  $ 1 $ $ n $ $ O(n) $  \n $ O(n \\log n) $ \n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n$ {\\rm height}[0] $ \n\n### \n $ {\\rm height}[] $\n\n************\n\n $ {\\rm height} $ \n\nRange Minimum/Maximum QueryRMQSparse TableST $ O(n \\log n) $  $ O(1) $ \n\n#### \n $ {\\rm st}[i][t] $  $ [i, i + 2 ^ t] $  $ {\\rm LCP}(i, i + 2 ^ t) $\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### \n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","slug":"suffix-array-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rd10080ooxlz7juhd5t"},{"title":"STL  OI ","id":"8","updated":"2016-02-17T02:35:37.000Z","date":"2015-12-23T21:43:15.000Z","_content":"\n OI  C++CPascal C++   Standard Template Library STLSTL  STLNOI  2011  C++  STL STL C++ \n\n<!-- more -->\n\n### \n> STL containersiteratorsallocatoradaptersalgorithmsfunctors\n\n\n\n### \nnamespace C++  Menci  Fuxey  `work()`  `Menci::work()`  `Fuxey::work()`\n\nSTL  `std` \n\n STL  `sort` \n\n```cpp\nstd::sort(a, a + n);\n```\n\n `std::sort`  `sort(a, a + n)`   \n `using` \n\n```cpp\nusing std::sort;\n```\n\n `max`  STL  `max`   \n `using namespace` \n\n```cpp\nusing namespace std;\n```\n\n### \nSTL  `<algorithm>` \n\n##### \nSTL  `sort`  `stable_sort``sort`  $O(n {\\log} n)$`stable_sort`  $O(n {\\log} n)$\n\n`sort` `stable_sort`  `sort`\n\n `sort` `stable_sort` \n\n [l, r)  `sort(l, r)` l  r ********\n\n****STL  a  n  [a, a + n) a  0a + n  n ****\n\n`sort` \n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n nn <= 100000****\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n****************\n\n********\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n `operator<`   \n `compare` ********\n\n `const`  `&` \n\n##### \n\n `unique`  `sort`  `unique` \n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` \n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n nn <= 100000\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### \n\n `max`  `min` \n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); //  890\ny = std::min(a, b); //  -1\n```\n\n##### \n\nSTL `lower_bound``upper_bound``binary_search` `lower_bound` \n\n`lower_bound` ********\n\n`upper_bound` ********\n\n`binary_search`  `true`  `false`\n\n$O({\\log}n)$\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1  a  4  a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2  a  5  a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3  a  7  a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n a  8  *p4 \n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false  a  3\n```\n\n##### \n `swap` \n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### \n STL \n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n `p` `CONTAINER`  `vector``set` `T` \n\n `begin()` **** `end()` ******** `[begin(), end())`**** `end()``end()`  `end()` \n\n STL \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n**** `vector[i]`  `vector.begin() + i` `set` \n\n `++`  `--` \n\n `p` `*p`  `->` \n\n\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### \n\n#####  vector\nSTL  `<vector>` **** `vector`\n\n `vector` `int` 0\n\n```cpp\nstd::vector<int> v;\n```\n\n `vector` `int` n\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector`  `begin()`  `end()`********\n\n v \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n `size()`  `vector`  `resize()`  `vector` \n\n `push_back()`  `pop_back()`  `vector` ****$O(1)$\n\n `insert()` $O(n)$\n\n `erase()` $O(n)$\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n//  1234523333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n `vector`  `vector`  $O(n)$ \n\n#####  set\nSTL  `<set>` **** `set`**** `set` ****\n\n `int` \n\n```cpp\nstd::set<int> s;\n```\n\n `insert()` $O({\\log}n)$\n\n `erase()` ********$O({\\log}n)$\n\n`set`  `lower_bound()`  `find()` \n\n `set` ****`set`  `set<T>::iterator` `T` \n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // \ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end() 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n//  -123333\n```\n\n STL \n\n#####  string\nSTL  `<string>`  `string` \n\n `cin`  `cout` \n\n `find()`  0 \n\n `c_str()`  `string`  `const char *`  C \n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos 23333\n\npos = s.find(\"ci\");\n// pos = 3 4 \n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n//  Menci\n```\n\n#####  queue\nSTL  `<queue>` FIFO `queue`\n\n `push()` \n\n `front()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n//  2333366666\n```\n\n#####  stack\nSTL  `<stack>` LIFO `stack`\n\n `push()` \n\n `top()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n//  6666623333\n```\n\n#####  priority_queue\nSTL  `<queue>`  `priority_queue`****\n\n `push()` $O({\\log}n)$\n\n `top()` ****$O(1)$\n\n `pop()` ****$O({\\log}n)$\n\n `empty()` \n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n//  6666623333-1\n```\n\n`priority_queue` **** `priority_queue` ****\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n `T`  `int``std::greater<T>`  `>>` \n","source":"_posts/stl-in-oi.md","raw":"title: STL  OI \ncategories: OI\ntags: \n  - C++\n  - STL\npermalink: stl-in-oi\nid: 8\nupdated: '2016-02-17 10:35:37'\ndate: 2015-12-24 05:43:15\n---\n\n OI  C++CPascal C++   Standard Template Library STLSTL  STLNOI  2011  C++  STL STL C++ \n\n<!-- more -->\n\n### \n> STL containersiteratorsallocatoradaptersalgorithmsfunctors\n\n\n\n### \nnamespace C++  Menci  Fuxey  `work()`  `Menci::work()`  `Fuxey::work()`\n\nSTL  `std` \n\n STL  `sort` \n\n```cpp\nstd::sort(a, a + n);\n```\n\n `std::sort`  `sort(a, a + n)`   \n `using` \n\n```cpp\nusing std::sort;\n```\n\n `max`  STL  `max`   \n `using namespace` \n\n```cpp\nusing namespace std;\n```\n\n### \nSTL  `<algorithm>` \n\n##### \nSTL  `sort`  `stable_sort``sort`  $O(n {\\log} n)$`stable_sort`  $O(n {\\log} n)$\n\n`sort` `stable_sort`  `sort`\n\n `sort` `stable_sort` \n\n [l, r)  `sort(l, r)` l  r ********\n\n****STL  a  n  [a, a + n) a  0a + n  n ****\n\n`sort` \n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n nn <= 100000****\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n****************\n\n********\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n `operator<`   \n `compare` ********\n\n `const`  `&` \n\n##### \n\n `unique`  `sort`  `unique` \n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` \n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n nn <= 100000\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### \n\n `max`  `min` \n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); //  890\ny = std::min(a, b); //  -1\n```\n\n##### \n\nSTL `lower_bound``upper_bound``binary_search` `lower_bound` \n\n`lower_bound` ********\n\n`upper_bound` ********\n\n`binary_search`  `true`  `false`\n\n$O({\\log}n)$\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1  a  4  a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2  a  5  a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3  a  7  a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n a  8  *p4 \n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false  a  3\n```\n\n##### \n `swap` \n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### \n STL \n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n `p` `CONTAINER`  `vector``set` `T` \n\n `begin()` **** `end()` ******** `[begin(), end())`**** `end()``end()`  `end()` \n\n STL \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n**** `vector[i]`  `vector.begin() + i` `set` \n\n `++`  `--` \n\n `p` `*p`  `->` \n\n\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### \n\n#####  vector\nSTL  `<vector>` **** `vector`\n\n `vector` `int` 0\n\n```cpp\nstd::vector<int> v;\n```\n\n `vector` `int` n\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector`  `begin()`  `end()`********\n\n v \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n `size()`  `vector`  `resize()`  `vector` \n\n `push_back()`  `pop_back()`  `vector` ****$O(1)$\n\n `insert()` $O(n)$\n\n `erase()` $O(n)$\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n//  1234523333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n `vector`  `vector`  $O(n)$ \n\n#####  set\nSTL  `<set>` **** `set`**** `set` ****\n\n `int` \n\n```cpp\nstd::set<int> s;\n```\n\n `insert()` $O({\\log}n)$\n\n `erase()` ********$O({\\log}n)$\n\n`set`  `lower_bound()`  `find()` \n\n `set` ****`set`  `set<T>::iterator` `T` \n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // \ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end() 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n//  -123333\n```\n\n STL \n\n#####  string\nSTL  `<string>`  `string` \n\n `cin`  `cout` \n\n `find()`  0 \n\n `c_str()`  `string`  `const char *`  C \n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos 23333\n\npos = s.find(\"ci\");\n// pos = 3 4 \n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n//  Menci\n```\n\n#####  queue\nSTL  `<queue>` FIFO `queue`\n\n `push()` \n\n `front()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n//  2333366666\n```\n\n#####  stack\nSTL  `<stack>` LIFO `stack`\n\n `push()` \n\n `top()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n//  6666623333\n```\n\n#####  priority_queue\nSTL  `<queue>`  `priority_queue`****\n\n `push()` $O({\\log}n)$\n\n `top()` ****$O(1)$\n\n `pop()` ****$O({\\log}n)$\n\n `empty()` \n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n//  6666623333-1\n```\n\n`priority_queue` **** `priority_queue` ****\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n `T`  `int``std::greater<T>`  `>>` \n","slug":"stl-in-oi","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rd70089ooxleh439i2r"},{"title":"SPOJ 694Distinct Substrings - ","date":"2016-04-12T13:40:06.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### \n $ i $  $ i - 1 $  $ {\\rm height}[i] $ \n\n 1 \n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/spoj-694.md","raw":"title: SPOJ 694Distinct Substrings - \ncategories: OI\ntags: \n  - SPOJ\n  - \n  - \npermalink: spoj-694\ndate: 2016-04-12 21:40:06\n---\n\n\n\n<!-- more -->\n\n### \n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### \n $ i $  $ i - 1 $  $ {\\rm height}[i] $ \n\n 1 \n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"spoj-694","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdb008fooxlmuqr73ki"},{"title":"Splay  + ","date":"2016-12-23T12:13:00.000Z","_content":"\n\n\n\n\n![zyz ](images/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <climits>\n\nstruct Splay\n{\n\tstruct Node\n\t{\n\t\t// root \n\t\tNode *fa, *ch[2], **root;\n\t\t// x \n\t\t// size \n\t\t// cnt  x \n\t\tint x, size, cnt;\n\n\t\tNode(Node **root, Node *fa, int x) : root(root), fa(fa), x(x), cnt(1), size(1)\n\t\t{\n\t\t\tch[0] = ch[1] = NULL; // \n\t\t}\n\n\t\t//  0  1\n\t\tint relation()\n\t\t{\n\t\t\treturn this == fa->ch[0] ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain()\n\t\t{\n\t\t\tsize = cnt;\n\t\t\tif (ch[0]) size += ch[0]->size;\n\t\t\tif (ch[1]) size += ch[1]->size;\n\t\t}\n\n\t\tvoid rotate()\n\t\t{\n\t\t\t// \n\t\t\tNode *old = fa;\n\t\t\t// \n\t\t\tint r = relation();\n\n\t\t\t//  <--> \n\t\t\tfa = old->fa;\n\t\t\tif (old->fa)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\told->fa->ch[old->relation()] = this;\n\t\t\t}\n\n\t\t\t//  <--> \n\t\t\tif (ch[r ^ 1])\n\t\t\t{\n\t\t\t\tch[r ^ 1]->fa = old;\n\t\t\t}\n\t\t\told->ch[r] = ch[r ^ 1]; //  ch[r ^ 1]  this->ch[r ^ 1]\n\n\t\t\t//  \n\t\t\told->fa = this;\n\t\t\tch[r ^ 1] = old;\n\n\t\t\t// \n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\t// \n\t\t\tif (fa == NULL)\n\t\t\t{\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\t// target  NULL\n\t\tvoid splay(Node *target = NULL)\n\t\t{\n\t\t\twhile (fa != target) // while ()\n\t\t\t{\n\t\t\t\tif (fa->fa == target) // \n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse if (fa->relation() == relation()) // \n\t\t\t\t{\n\t\t\t\t\tfa->rotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//  precursor  predecessor\n\t\tNode *pred()\n\t\t{\n\t\t\t// \n\t\t\tNode *v = ch[0];\n\t\t\twhile (v->ch[1]) v = v->ch[1];\n\t\t\treturn v;\n\t\t}\n\n\t\t//  successor\n\t\tNode *succ()\n\t\t{\n\t\t\t// \n\t\t\tNode *v = ch[1];\n\t\t\twhile (v->ch[0]) v = v->ch[0];\n\t\t\treturn v;\n\t\t}\n\n\t\t// \n\t\tint rank()\n\t\t{\n\t\t\treturn ch[0] ? ch[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL)\n\t{\n\t\tinsert(INT_MAX);\n\t\tinsert(INT_MIN);\n\t}\n\n\tNode *insert(int x)\n\t{\n\t\t// v \n\t\t// \n\t\t//  v \n\t\t// \n\t\t//\n\t\t// fa \n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v != NULL && (*v)->x != x) //  x \n\t\t{\n\t\t\tfa = *v;    //  v \n\t\t\tfa->size++; // \n\t\t\t\n\t\t\t// \n\t\t\tif (x < fa->x)\n\t\t\t{\n\t\t\t\tv = &fa->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = &fa->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (*v != NULL)\n\t\t{\n\t\t\t(*v)->cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*v) = new Node(&root, fa, x);\n\t\t}\n\n\t\t(*v)->splay();\n\n\t\t// *v  v \n\t\t// \n\t\treturn root;\n\t}\n\n\tNode *find(int x)\n\t{\n\t\t// \n\t\tNode *v = root;\n\t\twhile (v != NULL && v->x != x)\n\t\t{\n\t\t\tif (x < v->x)\n\t\t\t{\n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\t// \n\tvoid erase(Node *v)\n\t{\n\t\tNode *pred = v->pred(), *succ = v->succ();\n\t\tpred->splay();\n\t\tsucc->splay(pred); // \n\n\t\t//  v v \n\t\t\n\t\tif (v->size > 1)\n\t\t{\n\t\t\t//  x\n\t\t\tv->size--;\n\t\t\tv->cnt--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete succ->ch[0]; //  delete new  delete  new \n\t\t\tsucc->ch[0] = NULL; // \n\t\t}\n\n\t\t// \n\t\tsucc->size--;\n\t\tpred->size--;\n\t}\n\n\t// \n\tvoid erase(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (!v) return; // \n\t\t\n\t\terase(v);\n\t}\n\n\t// \n\tint pred(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->pred()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->pred()->x;\n\t\t}\n\t}\n\n\t// \n\tint succ(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->succ()->x;\n\t\t}\n\t}\n\n\t// \n\tint rank(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\t//  v \n\t\t\tint res = v->rank(); //  +1\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//  v \n\t\t\treturn v->rank();\n\t\t}\n\t}\n\n\t//  k \n\tint select(int k)\n\t{\n\t\tNode *v = root;\n\t\twhile (!(k >= v->rank() && k < v->rank() + v->cnt))\n\t\t{\n\t\t\tif (k < v->rank())\n\t\t\t{\n\t\t\t\t//  k \n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk -= v->rank() + v->cnt;\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v->x;\n\t}\n} splay;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tint opt, x;\n\t\tscanf(\"%d %d\", &opt, &x);\n\t\tif (opt == 1)\n\t\t{\n\t\t\tsplay.insert(x);\n\t\t}\n\t\telse if (opt == 2)\n\t\t{\n\t\t\tsplay.erase(x);\n\t\t}\n\t\telse if (opt == 3)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t}\n\t\telse if (opt == 4)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t}\n\t\telse if (opt == 5)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t}\n\t\telse if (opt == 6)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/splay-template.md","raw":"title: Splay  + \ncategories: OI\ntags: \n  - Splay\n  - \n  - \n  - \npermalink: splay-template\ndate: 2016-12-23 20:13:00\n---\n\n\n\n\n\n![zyz ](images/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <climits>\n\nstruct Splay\n{\n\tstruct Node\n\t{\n\t\t// root \n\t\tNode *fa, *ch[2], **root;\n\t\t// x \n\t\t// size \n\t\t// cnt  x \n\t\tint x, size, cnt;\n\n\t\tNode(Node **root, Node *fa, int x) : root(root), fa(fa), x(x), cnt(1), size(1)\n\t\t{\n\t\t\tch[0] = ch[1] = NULL; // \n\t\t}\n\n\t\t//  0  1\n\t\tint relation()\n\t\t{\n\t\t\treturn this == fa->ch[0] ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain()\n\t\t{\n\t\t\tsize = cnt;\n\t\t\tif (ch[0]) size += ch[0]->size;\n\t\t\tif (ch[1]) size += ch[1]->size;\n\t\t}\n\n\t\tvoid rotate()\n\t\t{\n\t\t\t// \n\t\t\tNode *old = fa;\n\t\t\t// \n\t\t\tint r = relation();\n\n\t\t\t//  <--> \n\t\t\tfa = old->fa;\n\t\t\tif (old->fa)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\told->fa->ch[old->relation()] = this;\n\t\t\t}\n\n\t\t\t//  <--> \n\t\t\tif (ch[r ^ 1])\n\t\t\t{\n\t\t\t\tch[r ^ 1]->fa = old;\n\t\t\t}\n\t\t\told->ch[r] = ch[r ^ 1]; //  ch[r ^ 1]  this->ch[r ^ 1]\n\n\t\t\t//  \n\t\t\told->fa = this;\n\t\t\tch[r ^ 1] = old;\n\n\t\t\t// \n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\t// \n\t\t\tif (fa == NULL)\n\t\t\t{\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\t// target  NULL\n\t\tvoid splay(Node *target = NULL)\n\t\t{\n\t\t\twhile (fa != target) // while ()\n\t\t\t{\n\t\t\t\tif (fa->fa == target) // \n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse if (fa->relation() == relation()) // \n\t\t\t\t{\n\t\t\t\t\tfa->rotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//  precursor  predecessor\n\t\tNode *pred()\n\t\t{\n\t\t\t// \n\t\t\tNode *v = ch[0];\n\t\t\twhile (v->ch[1]) v = v->ch[1];\n\t\t\treturn v;\n\t\t}\n\n\t\t//  successor\n\t\tNode *succ()\n\t\t{\n\t\t\t// \n\t\t\tNode *v = ch[1];\n\t\t\twhile (v->ch[0]) v = v->ch[0];\n\t\t\treturn v;\n\t\t}\n\n\t\t// \n\t\tint rank()\n\t\t{\n\t\t\treturn ch[0] ? ch[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL)\n\t{\n\t\tinsert(INT_MAX);\n\t\tinsert(INT_MIN);\n\t}\n\n\tNode *insert(int x)\n\t{\n\t\t// v \n\t\t// \n\t\t//  v \n\t\t// \n\t\t//\n\t\t// fa \n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v != NULL && (*v)->x != x) //  x \n\t\t{\n\t\t\tfa = *v;    //  v \n\t\t\tfa->size++; // \n\t\t\t\n\t\t\t// \n\t\t\tif (x < fa->x)\n\t\t\t{\n\t\t\t\tv = &fa->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = &fa->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (*v != NULL)\n\t\t{\n\t\t\t(*v)->cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*v) = new Node(&root, fa, x);\n\t\t}\n\n\t\t(*v)->splay();\n\n\t\t// *v  v \n\t\t// \n\t\treturn root;\n\t}\n\n\tNode *find(int x)\n\t{\n\t\t// \n\t\tNode *v = root;\n\t\twhile (v != NULL && v->x != x)\n\t\t{\n\t\t\tif (x < v->x)\n\t\t\t{\n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\t// \n\tvoid erase(Node *v)\n\t{\n\t\tNode *pred = v->pred(), *succ = v->succ();\n\t\tpred->splay();\n\t\tsucc->splay(pred); // \n\n\t\t//  v v \n\t\t\n\t\tif (v->size > 1)\n\t\t{\n\t\t\t//  x\n\t\t\tv->size--;\n\t\t\tv->cnt--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete succ->ch[0]; //  delete new  delete  new \n\t\t\tsucc->ch[0] = NULL; // \n\t\t}\n\n\t\t// \n\t\tsucc->size--;\n\t\tpred->size--;\n\t}\n\n\t// \n\tvoid erase(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (!v) return; // \n\t\t\n\t\terase(v);\n\t}\n\n\t// \n\tint pred(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->pred()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->pred()->x;\n\t\t}\n\t}\n\n\t// \n\tint succ(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->succ()->x;\n\t\t}\n\t}\n\n\t// \n\tint rank(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\t//  v \n\t\t\tint res = v->rank(); //  +1\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//  v \n\t\t\treturn v->rank();\n\t\t}\n\t}\n\n\t//  k \n\tint select(int k)\n\t{\n\t\tNode *v = root;\n\t\twhile (!(k >= v->rank() && k < v->rank() + v->cnt))\n\t\t{\n\t\t\tif (k < v->rank())\n\t\t\t{\n\t\t\t\t//  k \n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk -= v->rank() + v->cnt;\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v->x;\n\t}\n} splay;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tint opt, x;\n\t\tscanf(\"%d %d\", &opt, &x);\n\t\tif (opt == 1)\n\t\t{\n\t\t\tsplay.insert(x);\n\t\t}\n\t\telse if (opt == 2)\n\t\t{\n\t\t\tsplay.erase(x);\n\t\t}\n\t\telse if (opt == 3)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t}\n\t\telse if (opt == 4)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t}\n\t\telse if (opt == 5)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t}\n\t\telse if (opt == 6)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","slug":"splay-template","published":1,"updated":"2017-01-01T01:44:59.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdj008looxlpanbg3cl"},{"title":"Splay ","date":"2016-01-19T12:02:00.000Z","_content":"\nSplay  Splay  Splay \n\n[Splay  + ](/splay-template)\n\n<!-- more -->\n\n### \n0 1 \n\n `count` \n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay \n `NULL` \n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n###  / \n `Splay` \n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### \n `k` **`k`  `[rank + 1, rank + count]`**\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-3.md","raw":"title: Splay \ncategories: OI\ntags: \n  - Splay\n  - \n  - \n  - \npermalink: splay-notes-3\ndate: 2016-01-19 20:02:00\n---\n\nSplay  Splay  Splay \n\n[Splay  + ](/splay-template)\n\n<!-- more -->\n\n### \n0 1 \n\n `count` \n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay \n `NULL` \n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n###  / \n `Splay` \n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### \n `k` **`k`  `[rank + 1, rank + count]`**\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-3","published":1,"updated":"2016-12-27T07:29:20.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdn008rooxl40ma1v0r"},{"title":"Splay ","id":"7","updated":"2016-01-19T13:07:35.000Z","date":"2015-12-22T21:44:41.000Z","_content":"\n Splay  Splay  /  Splay \n\n<!-- more -->\n\n### \nSplay  Splay  Splay **** Splay\n\n Splay **** `lazy-tag` \n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n `reversed`  Splay`bound`  Splay  `MIN`  `MAX` \n\n### de\n Splay `build()`********\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n****\n\n****Splay ****** Splay ** Splay \n\n### de\n `lazy-tag`  Splay \n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n`^= 1` \n\n### de\n `select()`  Splay  `k` \n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n****`while`  `node->lsize()`  `node` ****\n\n### de\n `select()` ****\n\n Splay \n\n1.  `Splay` ****\n2.  `Splay` ****\n3. \n\n********\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### de\n\n\n\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### de\n `fetch()` \n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n `pushdown()` \n\n### \n****\n\n `pushdown()`** `relation()`**\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay`  `pushdown()` `relation()`\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n `select()`  `dfs()`  `pushdown()`\n\n### Tyvj / BZOJ \n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n Splay  Splay ","source":"_posts/splay-notes-2.md","raw":"title: Splay \ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - \n  - \n  - \npermalink: splay-notes-2\nid: 7\nupdated: '2016-01-19 21:07:35'\ndate: 2015-12-23 05:44:41\n---\n\n Splay  Splay  /  Splay \n\n<!-- more -->\n\n### \nSplay  Splay  Splay **** Splay\n\n Splay **** `lazy-tag` \n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n `reversed`  Splay`bound`  Splay  `MIN`  `MAX` \n\n### de\n Splay `build()`********\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n****\n\n****Splay ****** Splay ** Splay \n\n### de\n `lazy-tag`  Splay \n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n`^= 1` \n\n### de\n `select()`  Splay  `k` \n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n****`while`  `node->lsize()`  `node` ****\n\n### de\n `select()` ****\n\n Splay \n\n1.  `Splay` ****\n2.  `Splay` ****\n3. \n\n********\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### de\n\n\n\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### de\n `fetch()` \n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n `pushdown()` \n\n### \n****\n\n `pushdown()`** `relation()`**\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay`  `pushdown()` `relation()`\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n `select()`  `dfs()`  `pushdown()`\n\n### Tyvj / BZOJ \n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n Splay  Splay ","slug":"splay-notes-2","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdq008xooxlfaz16hdw"},{"title":"Splay ","date":"2015-12-19T21:36:24.000Z","_content":"\n Splay FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n\n[Splay  + ](/splay-template)\n\n<!-- more -->\n\n### Splay ?\nSplay Tree$O({\\log} n)$ Splay\n\n### \nSplay  Splay <  <  Splay \n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n `root` **** Splay `size`  Splay  `size`\n\n### \n `node_t` \n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n `node_t` \n\n `0` `1``relation()`  `child()`  `x` ****\n\n`maintain()`  Splay ****\n\n### \n Splay  `rotate()` ****\n\n1.  Splay \n2.  `size` \n3. `*root`  Splay \n\n\n\n1. ****\n2. ********\n3. ****\n4.  `*root`\n\n FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n![splay](splay-notes-1/splay.png)\n\n\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay \nSplay \n\n `Splay` `Splay` \n\n1. \n2. ********\n3. \n\n\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### \n\n\n `target` `target`  `target`  `target`  `NULL`\n\n `Splay` \n\n\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n**** Splay ****\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### \n `NULL`\n\n********\n\n `Splay` \n\n\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### \n****\n\n Splay  `Splay`  `size + 1`  `1` \n\n `1`  `0`\n\n\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### \n**** `k` \n\nSplay \n\n1. \n2. ** Splay ** `k - 1`\n3.  `k`  `k` ********\n\n `Splay` \n\n\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n###  / \n********\n\n Splay \n\n1.  `Splay` \n2. ****************\n3.  1\n\n `Splay` \n\n\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n###  / \n `x`  `x`  `x`  `x` \n\n\n\n1. \n2.  1 \n\n\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n###  / \nSplay \n\nSplay \n\n1.  `Splay` \n2.  `Splay` ****\n3. ****\n4.  `size`\n\n\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### Tyvj / BZOJ / CodeVS \n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-1.md","raw":"title: Splay \ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - \n  - \n  - \npermalink: splay-notes-1\ndate: 2015-12-20 05:36:24\n---\n\n Splay FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n\n[Splay  + ](/splay-template)\n\n<!-- more -->\n\n### Splay ?\nSplay Tree$O({\\log} n)$ Splay\n\n### \nSplay  Splay <  <  Splay \n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n `root` **** Splay `size`  Splay  `size`\n\n### \n `node_t` \n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n `node_t` \n\n `0` `1``relation()`  `child()`  `x` ****\n\n`maintain()`  Splay ****\n\n### \n Splay  `rotate()` ****\n\n1.  Splay \n2.  `size` \n3. `*root`  Splay \n\n\n\n1. ****\n2. ********\n3. ****\n4.  `*root`\n\n FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n![splay](splay-notes-1/splay.png)\n\n\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay \nSplay \n\n `Splay` `Splay` \n\n1. \n2. ********\n3. \n\n\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### \n\n\n `target` `target`  `target`  `target`  `NULL`\n\n `Splay` \n\n\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n**** Splay ****\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### \n `NULL`\n\n********\n\n `Splay` \n\n\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### \n****\n\n Splay  `Splay`  `size + 1`  `1` \n\n `1`  `0`\n\n\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### \n**** `k` \n\nSplay \n\n1. \n2. ** Splay ** `k - 1`\n3.  `k`  `k` ********\n\n `Splay` \n\n\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n###  / \n********\n\n Splay \n\n1.  `Splay` \n2. ****************\n3.  1\n\n `Splay` \n\n\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n###  / \n `x`  `x`  `x`  `x` \n\n\n\n1. \n2.  1 \n\n\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n###  / \nSplay \n\nSplay \n\n1.  `Splay` \n2.  `Splay` ****\n3. ****\n4.  `size`\n\n\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### Tyvj / BZOJ / CodeVS \n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-1","published":1,"updated":"2016-12-27T07:29:12.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rds0094ooxlo8t6v8ua"},{"title":"SHOI2008 - ","date":"2016-10-19T06:30:00.000Z","_content":"\n $ 2 $  $ C $  $ 2C $  $ 3C - 2 $ \n\n\n1. `Close r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n2. `Open r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n3. `Ask r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n\n<!-- more -->\n\n### \n[BZOJ 1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018)\n\n### \n $ (i, 0) $  $ (i, 1) $  $ i $ \n\n $ [l, r] $  $ (l, 0), (l, 1) $  $ (r, 0), (r, 1) $ \n\n $ i $  $ [l = i, r = i] $  $ (l, 0) $  $ (r, 1) $$ (l, 1) $  $ (r, 0) $ \n\n $ [l, m] $  $ [m + 1, r] $  $ m \\leftrightarrow m + 1 $ \n\n $ [l, r] $  $ l $  $ l' $  $ r $  $ r' $ $ [l', r'] $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nbool right[MAXN][2], middle[MAXN + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(const bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\nConnectivity merge(Connectivity a, Connectivity b, const int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tConnectivity conn;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {}\n\n\tvoid update(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tconn(0, 0) = conn(1, 1) = true;\n\t\t\tconn(0, 1) = conn(1, 0) = middle[mid];\n\t\t\treturn;\n\t\t} else if (!(l <= this->l && r >= this->r)) {\n\t\t\tlc->update(l, r);\n\t\t\trc->update(l, r);\n\t\t} else if (this->l == this->r - 1) lc->update(l, r), rc->update(l, r);\n\t\tconn = merge(lc->conn, rc->conn, mid);\n\t}\n\n\tConnectivity query(const int l, const int r) {\n\t\tif (l <= this->l && r >= this->r) return conn;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\ninline void update(int r1, int c1, int r2, int c2, const bool val) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = val;\n\t} else {\n\t\tmiddle[c1] = val;\n\t}\n\tsegment->update(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tConnectivity res = segment->query(mid, c1);\n\t\tif (res(0, r1) || res(1, r1)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lconn = segment->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segment->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rconn = segment->query(c2, rpos);\n\n\tConnectivity conn = segment->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lconn(i, r1) && rconn(r2, j) && conn(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegment = SegmentTree::build(1, n);\n\n\tchar cmd[5];\n\twhile (~scanf(\"%s\", cmd)) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse if (cmd[0] == 'O') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, true);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, false);\n\t\t} else if (cmd[0] == 'A') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tif (c1 > c2) std::swap(c1, c2), std::swap(r1, r2);\n\t\t\tputs(query(r1 - 1, c1, r2 - 1, c2) ? \"Y\" : \"N\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-traffic.md","raw":"title: SHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \npermalink: shoi2008-traffic\ndate: 2016-10-19 14:30:00\n---\n\n $ 2 $  $ C $  $ 2C $  $ 3C - 2 $ \n\n\n1. `Close r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n2. `Open r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n3. `Ask r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n\n<!-- more -->\n\n### \n[BZOJ 1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018)\n\n### \n $ (i, 0) $  $ (i, 1) $  $ i $ \n\n $ [l, r] $  $ (l, 0), (l, 1) $  $ (r, 0), (r, 1) $ \n\n $ i $  $ [l = i, r = i] $  $ (l, 0) $  $ (r, 1) $$ (l, 1) $  $ (r, 0) $ \n\n $ [l, m] $  $ [m + 1, r] $  $ m \\leftrightarrow m + 1 $ \n\n $ [l, r] $  $ l $  $ l' $  $ r $  $ r' $ $ [l', r'] $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nbool right[MAXN][2], middle[MAXN + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(const bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\nConnectivity merge(Connectivity a, Connectivity b, const int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tConnectivity conn;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {}\n\n\tvoid update(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tconn(0, 0) = conn(1, 1) = true;\n\t\t\tconn(0, 1) = conn(1, 0) = middle[mid];\n\t\t\treturn;\n\t\t} else if (!(l <= this->l && r >= this->r)) {\n\t\t\tlc->update(l, r);\n\t\t\trc->update(l, r);\n\t\t} else if (this->l == this->r - 1) lc->update(l, r), rc->update(l, r);\n\t\tconn = merge(lc->conn, rc->conn, mid);\n\t}\n\n\tConnectivity query(const int l, const int r) {\n\t\tif (l <= this->l && r >= this->r) return conn;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\ninline void update(int r1, int c1, int r2, int c2, const bool val) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = val;\n\t} else {\n\t\tmiddle[c1] = val;\n\t}\n\tsegment->update(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tConnectivity res = segment->query(mid, c1);\n\t\tif (res(0, r1) || res(1, r1)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lconn = segment->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segment->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rconn = segment->query(c2, rpos);\n\n\tConnectivity conn = segment->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lconn(i, r1) && rconn(r2, j) && conn(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegment = SegmentTree::build(1, n);\n\n\tchar cmd[5];\n\twhile (~scanf(\"%s\", cmd)) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse if (cmd[0] == 'O') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, true);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, false);\n\t\t} else if (cmd[0] == 'A') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tif (c1 > c2) std::swap(c1, c2), std::swap(r1, r2);\n\t\t\tputs(query(r1 - 1, c1, r2 - 1, c2) ? \"Y\" : \"N\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"shoi2008-traffic","published":1,"updated":"2016-10-19T06:30:27.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rdx009booxlch8h998g"},{"title":"SHOI2008 - ","date":"2016-10-19T07:53:00.000Z","_content":"\n $ n $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1022](http://www.lydsy.com/JudgeOnline/problem.php?id=1022)\n\n### \n\n\n****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint s = 0;\n\t\tbool flag = false;\n\t\twhile (n--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ts ^= x;\n\t\t\tif (x > 1) flag = true;\n\t\t}\n\n\t\tputs(((!flag && s == 0) || (flag && s != 0)) ? \"John\" : \"Brother\");\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-john.md","raw":"title: SHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - \npermalink: shoi2008-john\ndate: 2016-10-19 15:53:00\n---\n\n $ n $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1022](http://www.lydsy.com/JudgeOnline/problem.php?id=1022)\n\n### \n\n\n****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint s = 0;\n\t\tbool flag = false;\n\t\twhile (n--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ts ^= x;\n\t\t\tif (x > 1) flag = true;\n\t\t}\n\n\t\tputs(((!flag && s == 0) || (flag && s != 0)) ? \"John\" : \"Brother\");\n\t}\n\n\treturn 0;\n}\n```","slug":"shoi2008-john","published":1,"updated":"2016-10-19T07:53:47.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9re0009hooxl4o7msif9"},{"title":"SHOI2008 - DP","date":"2016-10-19T07:24:00.000Z","_content":"\nABACBABCCA  CB A \n\n1. \n2. \n\n  \n\n\n<!-- more -->\n\n### \n[BZOJ 1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019)\n\n### \n $ f(j, i) $  $ i $  $ j $  $ g(j, i) $ \n\n $ j - 1 $  $ f(j - 1, i) $  $ g(j - 1, i) $  $ a = g(j - 1, i) $ $ b = 3 - a - i $ $ j $  $ b $ \n\n $ a $  $ j - 1 $  $ g(j - 1, a) $  $ g(j - 1, a) = b $ $ b $  $ j $  $ b $  $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) $$ g(j, i) = b $\n\n $ g(j - 1, a) = i $  $ j - 1 $  $ i $  $ a $  $ j - 1 $  $ a $  $ g(j - 1, i) = a $ $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) $$ g(j, i) = a $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 30;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int g[MAXN + 1][3];\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tint a = s[0] - 'A', b = s[1] - 'A';\n\t\tif (g[1][a] == -1) g[1][a] = b;\n\t}\n\n\tstatic long long f[MAXN + 1][3];\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-hannoi.md","raw":"title: SHOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\npermalink: shoi2008-hannoi\ndate: 2016-10-19 15:24:00\n---\n\nABACBABCCA  CB A \n\n1. \n2. \n\n  \n\n\n<!-- more -->\n\n### \n[BZOJ 1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019)\n\n### \n $ f(j, i) $  $ i $  $ j $  $ g(j, i) $ \n\n $ j - 1 $  $ f(j - 1, i) $  $ g(j - 1, i) $  $ a = g(j - 1, i) $ $ b = 3 - a - i $ $ j $  $ b $ \n\n $ a $  $ j - 1 $  $ g(j - 1, a) $  $ g(j - 1, a) = b $ $ b $  $ j $  $ b $  $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) $$ g(j, i) = b $\n\n $ g(j - 1, a) = i $  $ j - 1 $  $ i $  $ a $  $ j - 1 $  $ a $  $ g(j - 1, i) = a $ $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) $$ g(j, i) = a $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 30;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int g[MAXN + 1][3];\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tint a = s[0] - 'A', b = s[1] - 'A';\n\t\tif (g[1][a] == -1) g[1][a] = b;\n\t}\n\n\tstatic long long f[MAXN + 1][3];\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\n\treturn 0;\n}\n```","slug":"shoi2008-hannoi","published":1,"updated":"2016-10-19T07:24:21.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9re3009oooxl9oqc1j4j"},{"title":"SHOI2008 - DP","date":"2016-10-19T07:35:00.000Z","_content":"\nABC  $ 1, 5, 10, 20, 50, 100 $ \n\n<!-- more -->\n\n### \n[BZOJ 1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)\n\n### \n $ f(i, a, b) $  $ i $  A  $ a $ B  $ b $ \n\n****\n\n* $ a \\rightarrow b, c $\n* $ b \\rightarrow a, c $\n* $ c \\rightarrow a, b $\n* $ a, b \\rightarrow c $\n* $ a, c \\rightarrow b $\n* $ b, c \\rightarrow a $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tconst int min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c < 0) {\n\t\tconst int max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tint has[3][6 + 1];\n\tint sum = 0, sums[3] = { 0, 0, 0 };\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &has[i][6 - j]);\n\t\t\tsums[i] += has[i][6 - j] * VAL[6 - j];\n#ifdef DBG\n\t\t\tfor (int k = 0; k < has[i][6 - j]; k++) printf(\"%d\\n\", VAL[6 - j]);\n#endif\n\t\t}\n\t\tsum += sums[i];\n#ifdef DBG\n\t\tputchar('\\n');\n#endif\n\t}\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", sums[0], sums[1], sums[2]);\n#endif\n\n\tstatic int f[6 + 1][MAXN + 1][MAXN + 1];\n\tfor (int i = 0; i <= 6; i++) for (int j = 0; j <= MAXN; j++) for (int k = 0; k <= MAXN; k++) f[i][j][k] = INT_MAX;\n\n\tf[0][sums[0]][sums[1]] = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= sum; a++) {\n\t\t\tfor (int b = 0; b <= sum - a; b++) {\n\t\t\t\tconst int c = sum - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= has[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= has[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= has[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= has[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tif (_a < 0 || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tif (_a > sum || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef DBG\n\t\t\t\tif (f[i + 1][a][b] != INT_MAX) printf(\"f(%d, %d, %d) = %d\\n\", i + 1, a, b, f[i + 1][a][b]);\n#endif\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b;\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", resA, resB, resC);\n#endif\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-debt.md","raw":"title: SHOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\npermalink: shoi2008-debt\ndate: 2016-10-19 15:35:00\n---\n\nABC  $ 1, 5, 10, 20, 50, 100 $ \n\n<!-- more -->\n\n### \n[BZOJ 1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)\n\n### \n $ f(i, a, b) $  $ i $  A  $ a $ B  $ b $ \n\n****\n\n* $ a \\rightarrow b, c $\n* $ b \\rightarrow a, c $\n* $ c \\rightarrow a, b $\n* $ a, b \\rightarrow c $\n* $ a, c \\rightarrow b $\n* $ b, c \\rightarrow a $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tconst int min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c < 0) {\n\t\tconst int max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tint has[3][6 + 1];\n\tint sum = 0, sums[3] = { 0, 0, 0 };\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &has[i][6 - j]);\n\t\t\tsums[i] += has[i][6 - j] * VAL[6 - j];\n#ifdef DBG\n\t\t\tfor (int k = 0; k < has[i][6 - j]; k++) printf(\"%d\\n\", VAL[6 - j]);\n#endif\n\t\t}\n\t\tsum += sums[i];\n#ifdef DBG\n\t\tputchar('\\n');\n#endif\n\t}\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", sums[0], sums[1], sums[2]);\n#endif\n\n\tstatic int f[6 + 1][MAXN + 1][MAXN + 1];\n\tfor (int i = 0; i <= 6; i++) for (int j = 0; j <= MAXN; j++) for (int k = 0; k <= MAXN; k++) f[i][j][k] = INT_MAX;\n\n\tf[0][sums[0]][sums[1]] = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= sum; a++) {\n\t\t\tfor (int b = 0; b <= sum - a; b++) {\n\t\t\t\tconst int c = sum - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= has[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= has[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= has[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= has[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tif (_a < 0 || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tif (_a > sum || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef DBG\n\t\t\t\tif (f[i + 1][a][b] != INT_MAX) printf(\"f(%d, %d, %d) = %d\\n\", i + 1, a, b, f[i + 1][a][b]);\n#endif\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b;\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", resA, resB, resC);\n#endif\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","slug":"shoi2008-debt","published":1,"updated":"2016-10-19T07:35:55.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9re6009tooxlxwkgks62"},{"title":"SHOI2008 -  DP","date":"2016-10-26T00:02:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023)\n\n### \nDFS  $ f(i) $  **DFS  $ i $ ** $ i $ \n\n DP DP **** $ f(i) $  $ i $ \n\n DFS  $ \\mathrm{dfn}(i) $  $ \\mathrm{low}(i) $ $ i $  $ j $$ j $  $ i $  $ \\mathrm{low}(j) > \\mathrm{dfn}(i) $ $ j $  $ i $  $ f(j) $  $ f(i) $ $ j $  $ i $  $ \\mathrm{dfn}(j) > \\mathrm{dfn}(i) $ $ i $  $ j $ \n\n**** $ i $ $ f(i) $  $ i $  $ f(i) $  $ j $$ f(i) $  $ f(j) + \\mathrm{dist}(j) $ \n\n $ f(i) + f(j) + \\mathrm{dist}(i, j) $  $ s(i) $  $ i $ $ f'(i) $  $ i $  $ f $  $ f'(i) + f'(j) + s(i) - s(j) $  $ f'(j) - s(j) $  $ s(i) - s(j) $  $ f $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 50000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tint dfn, low, len;\n\tbool visited, pushed;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nint n;\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void updateCircle(Node *top, Node *u, int &ans) {\n#ifdef DBG\n\tprintf(\"updateCircle(%lu, %lu)\\n\", top - N + 1, u - N + 1);\n#endif\n\tstatic Node *v[MAXN * 2];\n\tint cnt = 0;\n\twhile (1) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->parent;\n\t}\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAXN * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\t// ans = max{ f[i] + f[j] + i - j }\n\t// maintain the max of f[j] - j\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n#ifdef DBG\n\t\tprintf(\"updateCircle: ans <- %d\\n\", v[*l]->len + v[i]->len + i - *l);\n#endif\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\t// printf(\"updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\\n\", top - N + 1, u - N + 1, v[i] - N + 1, v[i]->len, i, cnt - i);\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n#ifdef CHECK\n\tprintf(\"updateCircle(%lu, %lu) = %d\\n\", top - N + 1, u - N + 1, res);\n#endif\n\n\ttop->len = std::max(top->len, res);\n}\n\ninline int tarjan() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].pushed = true;\n\n\tint ts = 0, ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->dfn = v->low = ++ts;\n\t\t}\n\n\t\tif (v->c && v->c->t == v->parent) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\tif (e->t->dfn) {\n\t\t\t\tv->low = std::min(v->low, e->t->dfn);\n\t\t\t} else {\n\t\t\t\te->t->pushed = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t == v->parent) continue;\n\n\t\t\t\tif (e->t->low > v->dfn) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: ans <- (f[%lu] = %d) + (f[%lu] = %d) + 1\\n\", v - N + 1, v->len, e->t - N + 1, e->t->len);\n#endif\n\t\t\t\t\tans = std::max(ans, v->len + e->t->len + 1);\n\t\t\t\t\tv->len = std::max(v->len, e->t->len + 1);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e->t->parent != v && e->t->dfn > v->dfn) {\n\t\t\t\t\tupdateCircle(v, e->t, ans);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d (from circle)\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->parent) v->parent->low = std::min(v->parent->low, v->low);\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u), u--, k--;\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v), v--;\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", tarjan());\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-cactus.md","raw":"title: SHOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\n  - \n  - Tarjan\npermalink: shoi2008-cactus\ndate: 2016-10-26 08:02:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023)\n\n### \nDFS  $ f(i) $  **DFS  $ i $ ** $ i $ \n\n DP DP **** $ f(i) $  $ i $ \n\n DFS  $ \\mathrm{dfn}(i) $  $ \\mathrm{low}(i) $ $ i $  $ j $$ j $  $ i $  $ \\mathrm{low}(j) > \\mathrm{dfn}(i) $ $ j $  $ i $  $ f(j) $  $ f(i) $ $ j $  $ i $  $ \\mathrm{dfn}(j) > \\mathrm{dfn}(i) $ $ i $  $ j $ \n\n**** $ i $ $ f(i) $  $ i $  $ f(i) $  $ j $$ f(i) $  $ f(j) + \\mathrm{dist}(j) $ \n\n $ f(i) + f(j) + \\mathrm{dist}(i, j) $  $ s(i) $  $ i $ $ f'(i) $  $ i $  $ f $  $ f'(i) + f'(j) + s(i) - s(j) $  $ f'(j) - s(j) $  $ s(i) - s(j) $  $ f $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 50000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tint dfn, low, len;\n\tbool visited, pushed;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nint n;\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void updateCircle(Node *top, Node *u, int &ans) {\n#ifdef DBG\n\tprintf(\"updateCircle(%lu, %lu)\\n\", top - N + 1, u - N + 1);\n#endif\n\tstatic Node *v[MAXN * 2];\n\tint cnt = 0;\n\twhile (1) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->parent;\n\t}\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAXN * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\t// ans = max{ f[i] + f[j] + i - j }\n\t// maintain the max of f[j] - j\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n#ifdef DBG\n\t\tprintf(\"updateCircle: ans <- %d\\n\", v[*l]->len + v[i]->len + i - *l);\n#endif\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\t// printf(\"updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\\n\", top - N + 1, u - N + 1, v[i] - N + 1, v[i]->len, i, cnt - i);\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n#ifdef CHECK\n\tprintf(\"updateCircle(%lu, %lu) = %d\\n\", top - N + 1, u - N + 1, res);\n#endif\n\n\ttop->len = std::max(top->len, res);\n}\n\ninline int tarjan() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].pushed = true;\n\n\tint ts = 0, ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->dfn = v->low = ++ts;\n\t\t}\n\n\t\tif (v->c && v->c->t == v->parent) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\tif (e->t->dfn) {\n\t\t\t\tv->low = std::min(v->low, e->t->dfn);\n\t\t\t} else {\n\t\t\t\te->t->pushed = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t == v->parent) continue;\n\n\t\t\t\tif (e->t->low > v->dfn) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: ans <- (f[%lu] = %d) + (f[%lu] = %d) + 1\\n\", v - N + 1, v->len, e->t - N + 1, e->t->len);\n#endif\n\t\t\t\t\tans = std::max(ans, v->len + e->t->len + 1);\n\t\t\t\t\tv->len = std::max(v->len, e->t->len + 1);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e->t->parent != v && e->t->dfn > v->dfn) {\n\t\t\t\t\tupdateCircle(v, e->t, ans);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d (from circle)\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->parent) v->parent->low = std::min(v->parent->low, v->low);\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u), u--, k--;\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v), v--;\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", tarjan());\n\n\treturn 0;\n}\n```","slug":"shoi2008-cactus","published":1,"updated":"2016-10-26T00:02:45.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9re9009yooxl765qsyac"},{"title":"SHOI2007 - ","date":"2016-06-21T07:04:00.000Z","_content":"\n $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1934](http://www.lydsy.com/JudgeOnline/problem.php?id=1934)\n\n### \n $ 1 $\n\n $ S - u - v - T $$ u $ $ v $  $ u - v $  $ u $  $ v $  $ +1 $ $ S - u $  $ v - T $ $ u $  $ v $  $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->e; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\t// printf(\"[%d, %d, %d, %d]\\n\", s, t, c, rc);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) {\n\t\t\taddEdge(s, i, 1);\n\t\t} else {\n\t\t\taddEdge(i, t, 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v, 1, 1);\n\t}\n\n\tint maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/shoi2007-vote.md","raw":"title: SHOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - Dinic\n  - \npermalink: shoi2007-vote\ndate: 2016-06-21 15:04:00\n---\n\n $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1934](http://www.lydsy.com/JudgeOnline/problem.php?id=1934)\n\n### \n $ 1 $\n\n $ S - u - v - T $$ u $ $ v $  $ u - v $  $ u $  $ v $  $ +1 $ $ S - u $  $ v - T $ $ u $  $ v $  $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->e; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\t// printf(\"[%d, %d, %d, %d]\\n\", s, t, c, rc);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) {\n\t\t\taddEdge(s, i, 1);\n\t\t} else {\n\t\t\taddEdge(i, t, 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v, 1, 1);\n\t}\n\n\tint maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"shoi2007-vote","published":1,"updated":"2016-06-21T07:04:25.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9red00a6ooxldbfoe8ph"},{"title":"SHOI2007 - CDQ","date":"2016-06-25T02:54:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1935](http://www.lydsy.com/JudgeOnline/problem.php?id=1935)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 10000000;\n\nstruct Triple {\n\tint x, y, *ans, k;\n\n\tTriple() {}\n\tTriple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {}\n} a[MAXN + MAXM * 4];\n\nint max = 0;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t// printf(\"sum[1, %d] = %d\\n\", x, ans);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\t// printf(\"a[%d] += %d\\n\", x, delta);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\t// printf(\"a[%d] = 0\\n\", x);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\nvoid cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM * 4];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\t// printf(\"ans += %d\\n\", bit.query(q->y) * q->k);\n\t\t\tif (q->ans) *q->ans += bit.query(q->y) * q->k;\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y), a[i].x += 2, a[i].y += 2;\n\t\tmax = std::max(max, a[i].y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint cnt = n;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2;\n\t\tint *p = &ans[i];\n\n\t\ta[cnt++] = Triple(x2, y2, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y2, p, -1);\n\t\ta[cnt++] = Triple(x2, y1 - 1, p, -1);\n\n\t\tmax = std::max(max, y1);\n\t\tmax = std::max(max, y2);\n\t}\n\n\t// for (int i = 0; i < cnt; i++) {\n\t// \tif (a[i].ans) printf(\"Query [%d, %d] for ans[%ld]\\n\", a[i].x, a[i].y, a[i].ans - ans);\n\t// \telse printf(\"Update [%d, %d] = 1\\n\", a[i].x, a[i].y);\n\t// }\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/shoi2007-tree.md","raw":"title: SHOI2007 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - CDQ\n  - \n  - \npermalink: shoi2007-tree\ndate: 2016-06-25 10:54:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1935](http://www.lydsy.com/JudgeOnline/problem.php?id=1935)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 10000000;\n\nstruct Triple {\n\tint x, y, *ans, k;\n\n\tTriple() {}\n\tTriple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {}\n} a[MAXN + MAXM * 4];\n\nint max = 0;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t// printf(\"sum[1, %d] = %d\\n\", x, ans);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\t// printf(\"a[%d] += %d\\n\", x, delta);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\t// printf(\"a[%d] = 0\\n\", x);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\nvoid cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM * 4];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\t// printf(\"ans += %d\\n\", bit.query(q->y) * q->k);\n\t\t\tif (q->ans) *q->ans += bit.query(q->y) * q->k;\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y), a[i].x += 2, a[i].y += 2;\n\t\tmax = std::max(max, a[i].y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint cnt = n;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2;\n\t\tint *p = &ans[i];\n\n\t\ta[cnt++] = Triple(x2, y2, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y2, p, -1);\n\t\ta[cnt++] = Triple(x2, y1 - 1, p, -1);\n\n\t\tmax = std::max(max, y1);\n\t\tmax = std::max(max, y2);\n\t}\n\n\t// for (int i = 0; i < cnt; i++) {\n\t// \tif (a[i].ans) printf(\"Query [%d, %d] for ans[%ld]\\n\", a[i].x, a[i].y, a[i].ans - ans);\n\t// \telse printf(\"Update [%d, %d] = 1\\n\", a[i].x, a[i].y);\n\t// }\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"shoi2007-tree","published":1,"updated":"2016-06-25T03:07:53.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9reh00adooxl81or26s2"},{"title":"SDOI2016 - ","date":"2016-04-18T09:06:53.000Z","_content":"\n $ n $  $ m $  $ 0 $  $ n - 1 $  $ 0 $  $ m - 1 $   \n $ i $  $ j $  $ (i \\ {\\rm xor} \\ j) $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n $ 1 $ $ 0 $   \n$ k $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n $ k $   \n $ p $ \n\n<!-- more -->\n\n### \n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### \n DP   \n\n\n\n $ x < 2 ^ N $$ y < 2 ^ N $ $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n>  $ N $  $ 0 $ $ 1 $\n\n $ x \\neq y $ $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n>  $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $ $ x \\ {\\rm xor} \\ a = z $$ y \\ {\\rm xor} \\ a = z $ $ x = y $\n\n $ x < 2 ^ N $$ [0, 2 ^ N - 1] $  $ x $  $ [0, 2 ^ N - 1] $ \n\n>  2  $ N $  $ 2 ^ N $ $ 2 ^ N - 1 $  $ [0, 2 ^ N - 1] $ \n\n $ n > m $$ n $ $ m $ \n\n $ k $ $ n = m = 2 ^ N $$ N = 3 $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ \n\n $ N = \\lfloor \\log_2 n \\rfloor $$ M = \\lfloor \\log_2 m \\rfloor $ $ N = M $ \n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n $ [2 ^ N, 2 ^ N + 2 ^ M - 1] $ \n\n $ n $  $ m $ \n\n $ N > M $ $ n > m $  $ N < M $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ $ 2 ^ N $ $ 2 ^ N $  $ N = M $  $ 2 ^ N $ \n\n $ k $  $ 0, 1, 2, 3,  n $  $ \\leq k $  $ 0 $ $ k $ $ 1 $  $ n - k $ \n\n $ k $  $ n $  $ k $ \n\n $ n $  $ 1 $ $ O(T \\log (\\max(n, m))) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-table.md","raw":"title: SDOI2016 - \ndate: 2016-04-18 17:06:53\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \npermalink: sdoi2016-table\n---\n\n $ n $  $ m $  $ 0 $  $ n - 1 $  $ 0 $  $ m - 1 $   \n $ i $  $ j $  $ (i \\ {\\rm xor} \\ j) $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n $ 1 $ $ 0 $   \n$ k $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n $ k $   \n $ p $ \n\n<!-- more -->\n\n### \n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### \n DP   \n\n\n\n $ x < 2 ^ N $$ y < 2 ^ N $ $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n>  $ N $  $ 0 $ $ 1 $\n\n $ x \\neq y $ $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n>  $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $ $ x \\ {\\rm xor} \\ a = z $$ y \\ {\\rm xor} \\ a = z $ $ x = y $\n\n $ x < 2 ^ N $$ [0, 2 ^ N - 1] $  $ x $  $ [0, 2 ^ N - 1] $ \n\n>  2  $ N $  $ 2 ^ N $ $ 2 ^ N - 1 $  $ [0, 2 ^ N - 1] $ \n\n $ n > m $$ n $ $ m $ \n\n $ k $ $ n = m = 2 ^ N $$ N = 3 $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ \n\n $ N = \\lfloor \\log_2 n \\rfloor $$ M = \\lfloor \\log_2 m \\rfloor $ $ N = M $ \n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n $ [2 ^ N, 2 ^ N + 2 ^ M - 1] $ \n\n $ n $  $ m $ \n\n $ N > M $ $ n > m $  $ N < M $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ $ 2 ^ N $ $ 2 ^ N $  $ N = M $  $ 2 ^ N $ \n\n $ k $  $ 0, 1, 2, 3,  n $  $ \\leq k $  $ 0 $ $ k $ $ 1 $  $ n - k $ \n\n $ k $  $ n $  $ k $ \n\n $ n $  $ 1 $ $ O(T \\log (\\max(n, m))) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-table","published":1,"updated":"2016-09-10T05:54:16.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rem00anooxl0p5xvvaj"},{"title":"SDOI2016 Round1 ","date":"2016-04-09T13:59:32.000Z","_content":"\n \n\n<!-- more -->\n\n### Day 0\n     \n\n   \n\n  **** \n\n \n\n EK  \n\n \n\n QwQ \n\n yts1999 %%%\n\n Blog  \n\n### Day 1\n   \n XP  Windows    \n7:59  WC  \n\n \n\n   DP   \n30min    \n  20  \n\n    Miller  Rabin    \n +    \n  \npapapa  $ 1000 \\times 1000 $    $ O((n + m) ^ 3) $   \n     EK    \n   \n   \n  \n $ b_i $    \n   \n`Wrong Answer on Test #7`md     \n`Wrong Answer on Test #13`md     \n `Accepted`    \n\n  \n     SegmentTree Beats    \n BFS    \n $ a = 0 $    \n  \n      \n`Wrong Answer on Test #18`     \n`Wrong Answer on Test #32`       \nmd      \nmd  `size`    \n`s.top()`  `s.pop()`   \n 12:40    \n\n T2  maya      \nT2  $ O( $  $ ) $    $ n = 200 $    \n 1.5s   \n   \nT  T    \n\n140rank9 \n\nheheda AK   \nstd rank2\n\n\n\n     KMP   \n\nDay1   \n Day2 \n\n### Day 2\n  7:50 \n\nwow  \n\n7:57  \n\n \n\nmaya 60  60   \n 30 `std::set< std::vector<int> >`    \n\nmaya        \n     \n 10   $ O(n!) $  \n\n DP10 $ O(n ^ 3) $  DP  30    \n\n   `std::sort`    \n `height`   `height`    \n\n $ O(n ^ 2 \\log n + n ^ 2) $  \n\n \n\n1.5h  `height`  \n\n \n\n$ O(n ^ 2) $  `height`    \n `height` `height + 1` 0   \n `\"heheda\"`    \n   \n   \n\n\n\n     \n   \n `std::sort` \n\n $ O(n \\log n \\log n + n) $ \n\n    \n   \n `height`   \n   \n   \nmaya  \n\n   \n\n\n $ O(n \\log n \\log n + n ^ 2) $   \n `height`      \n\n  \n       \n\n 30  DP  12:40    \nmaya   \n  maya   \n   \n `double`    \n     \n\n12:50       \nmaya   \n\n13:00    \n\n \n\nDay1 T1 DP  \nT2      \nT3  Orz\n\nDay2 T1   \n   \nT2 maya 60    \nT3      \n\n  90    60  \n\n Day1  Flag \n\n \n","source":"_posts/sdoi2016-round1.md","raw":"title: SDOI2016 Round1 \ncategories: \n  - Diary\npermalink: sdoi2016-round1\ndate: 2016-04-09 21:59:32\n---\n\n \n\n<!-- more -->\n\n### Day 0\n     \n\n   \n\n  **** \n\n \n\n EK  \n\n \n\n QwQ \n\n yts1999 %%%\n\n Blog  \n\n### Day 1\n   \n XP  Windows    \n7:59  WC  \n\n \n\n   DP   \n30min    \n  20  \n\n    Miller  Rabin    \n +    \n  \npapapa  $ 1000 \\times 1000 $    $ O((n + m) ^ 3) $   \n     EK    \n   \n   \n  \n $ b_i $    \n   \n`Wrong Answer on Test #7`md     \n`Wrong Answer on Test #13`md     \n `Accepted`    \n\n  \n     SegmentTree Beats    \n BFS    \n $ a = 0 $    \n  \n      \n`Wrong Answer on Test #18`     \n`Wrong Answer on Test #32`       \nmd      \nmd  `size`    \n`s.top()`  `s.pop()`   \n 12:40    \n\n T2  maya      \nT2  $ O( $  $ ) $    $ n = 200 $    \n 1.5s   \n   \nT  T    \n\n140rank9 \n\nheheda AK   \nstd rank2\n\n\n\n     KMP   \n\nDay1   \n Day2 \n\n### Day 2\n  7:50 \n\nwow  \n\n7:57  \n\n \n\nmaya 60  60   \n 30 `std::set< std::vector<int> >`    \n\nmaya        \n     \n 10   $ O(n!) $  \n\n DP10 $ O(n ^ 3) $  DP  30    \n\n   `std::sort`    \n `height`   `height`    \n\n $ O(n ^ 2 \\log n + n ^ 2) $  \n\n \n\n1.5h  `height`  \n\n \n\n$ O(n ^ 2) $  `height`    \n `height` `height + 1` 0   \n `\"heheda\"`    \n   \n   \n\n\n\n     \n   \n `std::sort` \n\n $ O(n \\log n \\log n + n) $ \n\n    \n   \n `height`   \n   \n   \nmaya  \n\n   \n\n\n $ O(n \\log n \\log n + n ^ 2) $   \n `height`      \n\n  \n       \n\n 30  DP  12:40    \nmaya   \n  maya   \n   \n `double`    \n     \n\n12:50       \nmaya   \n\n13:00    \n\n \n\nDay1 T1 DP  \nT2      \nT3  Orz\n\nDay2 T1   \n   \nT2 maya 60    \nT3      \n\n  90    60  \n\n Day1  Flag \n\n \n","slug":"sdoi2016-round1","published":1,"updated":"2016-11-20T15:49:24.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9req00azooxln3o0605f"},{"title":"SDOI2016 -  + ","date":"2016-04-13T03:45:13.000Z","_content":"\n $ n $  $ A $\n\n* $ 1 $ ~ $ n $  $ n $ \n*  $ i $  $ A[i] $  $ i $ $ i $  $ m $ \n\n $ 10 ^ 9 + 7 $ \n\n<!-- more -->\n\n### \n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### \n\n\n $ n $  $ m $  $ n - m $ \n\n $ f(i) $  i \n\n$$ C(n, m) * f(n - m) $$\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-permutation.md","raw":"title: SDOI2016 -  + \ndate: 2016-04-13 11:45:13\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \n  - \npermalink: sdoi2016-permutation\n---\n\n $ n $  $ A $\n\n* $ 1 $ ~ $ n $  $ n $ \n*  $ i $  $ A[i] $  $ i $ $ i $  $ m $ \n\n $ 10 ^ 9 + 7 $ \n\n<!-- more -->\n\n### \n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### \n\n\n $ n $  $ m $  $ n - m $ \n\n $ f(i) $  i \n\n$$ C(n, m) * f(n - m) $$\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-permutation","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9res00b1ooxl1tynortw"},{"title":"SDOI2016 - ","date":"2016-04-09T10:06:43.000Z","_content":"\n $ n $  $ i $  $ a_i $ $ b_i $  $ c_i $\n\n $ a_i $$ a_j $ $ a_i $  $ a_j $  $ \\frac{a_i}{a_j} $  $ c_i \\times c_j $ \n\n  \n $ 0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### \n $ 10 ^ 6 $ \n\n $ X $  $ b_i $  $ 0 $ $ Y $  $ b_i $  $ 0 $ $ X $  $ Y $  $ -(c_i \\times c_j) $\n\n $ \\leq 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-pair.md","raw":"title: SDOI2016 - \ndate: 2016-04-09 18:06:43\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - Edmonds-Karp\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: sdoi2016-pair\n---\n\n $ n $  $ i $  $ a_i $ $ b_i $  $ c_i $\n\n $ a_i $$ a_j $ $ a_i $  $ a_j $  $ \\frac{a_i}{a_j} $  $ c_i \\times c_j $ \n\n  \n $ 0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### \n $ 10 ^ 6 $ \n\n $ X $  $ b_i $  $ 0 $ $ Y $  $ b_i $  $ 0 $ $ X $  $ Y $  $ -(c_i \\times c_j) $\n\n $ \\leq 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-pair","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rev00bbooxlauiqllaa"},{"title":"SDOI2016 -  DP","date":"2016-04-17T14:46:04.000Z","_content":"\nPine  $ S $  $ T $   \n $ S $  $ T $  $ n $   \nPine  $ m $  $ T $  $ m $  Pine   \nPine   \n Pine \n\n $ v $$ v \\times m ^ 2 $  $ v \\times m ^ 2 $\n\n<!-- more -->\n\n### \n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### \n $ a_i $ $ S = \\sum\\limits_{i = 1} ^ n a_i $\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n $ m $ $ S ^ 2 $ \n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n\n\n $ f[j][i] $  $ i $  $ j $ \n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\nDP $ O(nm) $ $ O(nm ^ 2) $ 60 \n\n $ g(i) = f[j - 1][i] $ $ k $  $ k = a $  $ k = b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n\n\n1. \n2.  $ a $  $ b $ $ a > b $ $ 2 s_i $ $ a $ \n\n 2 \n\n $ i $ $ k $ 2 $ k $  1  $ O(1) $ $ O(nm) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-journey.md","raw":"title: SDOI2016 -  DP\ndate: 2016-04-17 22:46:04\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - DP\n  - \n  - \npermalink: sdoi2016-journey\n---\n\nPine  $ S $  $ T $   \n $ S $  $ T $  $ n $   \nPine  $ m $  $ T $  $ m $  Pine   \nPine   \n Pine \n\n $ v $$ v \\times m ^ 2 $  $ v \\times m ^ 2 $\n\n<!-- more -->\n\n### \n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### \n $ a_i $ $ S = \\sum\\limits_{i = 1} ^ n a_i $\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n $ m $ $ S ^ 2 $ \n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n\n\n $ f[j][i] $  $ i $  $ j $ \n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\nDP $ O(nm) $ $ O(nm ^ 2) $ 60 \n\n $ g(i) = f[j - 1][i] $ $ k $  $ k = a $  $ k = b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n\n\n1. \n2.  $ a $  $ b $ $ a > b $ $ 2 s_i $ $ a $ \n\n 2 \n\n $ i $ $ k $ 2 $ k $  1  $ O(1) $ $ O(nm) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-journey","published":1,"updated":"2016-10-24T23:29:40.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rf000bqooxlxoy869wq"},{"title":"SDOI2016 - ","date":"2016-04-12T13:57:57.000Z","_content":"\n $ 1 $$ 2 $  $ [1, 2] $  \n $ S $  $ S $   \n $ S = [1, 2, 1] $  $ [1] $$ [2] $$ [1, 2] $$ [2, 1] $$ [1, 2, 1] $ $ S = [1, 1, 1] $  $ [1] $$ [1, 1] $$ [1, 1, 1] $   \n $ S $  $ n $  $ S $  $ S $ \n\n<!-- more -->\n\n### \n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### \n $ {\\rm height} $ \n\n\n\n `std::set` \n\n $ i $ $ pred $$ succ $\n\n$ pred $$ succ $ $ pred $$ succ $  $ i $ \n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n $ i $ \n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-incantation.md","raw":"title: SDOI2016 - \ndate: 2016-04-12 21:57:57\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - RMQ\npermalink: sdoi2016-incantation\n---\n\n $ 1 $$ 2 $  $ [1, 2] $  \n $ S $  $ S $   \n $ S = [1, 2, 1] $  $ [1] $$ [2] $$ [1, 2] $$ [2, 1] $$ [1, 2, 1] $ $ S = [1, 1, 1] $  $ [1] $$ [1, 1] $$ [1, 1, 1] $   \n $ S $  $ n $  $ S $  $ S $ \n\n<!-- more -->\n\n### \n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### \n $ {\\rm height} $ \n\n\n\n `std::set` \n\n $ i $ $ pred $$ succ $\n\n$ pred $$ succ $ $ pred $$ succ $  $ i $ \n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n $ i $ \n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-incantation","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rf400byooxl5qvktlmq"},{"title":"SDOI2016 - ","date":"2016-04-15T14:25:55.000Z","_content":"\nAlice  Bob   \n $ n $  $ 123456789123456789 $  \nAlice  $ s $  $ t $  $ r $ $ r $  $ s $  $ dis $ Alice  $ r $  $ a \\times dis + b $  \nBob  $ s $  $ t $   \nBob  Bob Bob \n\n<!-- more -->\n\n### \n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### \n\n\n $ p = {\\rm LCA}(s, t) $  $ s \\rightarrow p $$ p \\rightarrow t $\n\n![Tree](sdoi2016-game/tree.png)\n\n $ {\\rm dist}(u, v) $  uv \n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n $ a \\times {\\rm dist}(s, root) + b $ \n\n\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ \n\n $ x $  $ y $ \n\n\n\n1. \n2.  `mid` \n\n `mid` \n\n\n\n****\n\n\n\n\n\n\n\n![Line](sdoi2016-game/line.png)\n\n****\n\n\n\n $ O(\\log n) $  $ O(\\log n) $  $ O(\\log n) $  $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-game.md","raw":"title: SDOI2016 - \ndate: 2016-04-15 22:25:55\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \n  - \n  - \npermalink: sdoi2016-game\n---\n\nAlice  Bob   \n $ n $  $ 123456789123456789 $  \nAlice  $ s $  $ t $  $ r $ $ r $  $ s $  $ dis $ Alice  $ r $  $ a \\times dis + b $  \nBob  $ s $  $ t $   \nBob  Bob Bob \n\n<!-- more -->\n\n### \n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### \n\n\n $ p = {\\rm LCA}(s, t) $  $ s \\rightarrow p $$ p \\rightarrow t $\n\n![Tree](sdoi2016-game/tree.png)\n\n $ {\\rm dist}(u, v) $  uv \n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n $ a \\times {\\rm dist}(s, root) + b $ \n\n\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ \n\n $ x $  $ y $ \n\n\n\n1. \n2.  `mid` \n\n `mid` \n\n\n\n****\n\n\n\n\n\n\n\n![Line](sdoi2016-game/line.png)\n\n****\n\n\n\n $ O(\\log n) $  $ O(\\log n) $  $ O(\\log n) $  $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-game","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rf800c7ooxlwt64odd7"},{"title":"SDOI2015 - ","date":"2016-02-29T07:42:11.000Z","_content":"\nY  $ N $  X  $ i $  $ A_i $ 0 X  $ M $  $ i $  $ B_i $ Y  X  Y \n\n<!-- more -->\n\n### \n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### \n\n\n1.   \n2. \n3. \n\nw \n\n Dinic \n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n\ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble flow = dinic(s, t, n + m + 2);\n\n\tcleanUp(n + m + 2);\n\n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n\ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", dichotomy());\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-war.md","raw":"title: SDOI2015 - \ndate: 2016-02-29 15:42:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Dinic\n  - \n  - \n  - \n  - \npermalink: sdoi2015-war\n---\n\nY  $ N $  X  $ i $  $ A_i $ 0 X  $ M $  $ i $  $ B_i $ Y  X  Y \n\n<!-- more -->\n\n### \n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### \n\n\n1.   \n2. \n3. \n\nw \n\n Dinic \n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n\ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble flow = dinic(s, t, n + m + 2);\n\n\tcleanUp(n + m + 2);\n\n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n\ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", dichotomy());\n\n\treturn 0;\n}\n```\n","slug":"sdoi2015-war","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rfj00ciooxlhm5cby1n"},{"title":"SDOI2015 -  + NTT","date":"2016-06-12T01:27:00.000Z","_content":"\n C  $ S $ $ M $  $ N $  $ S $\n\n C  C  $ x $ $ \\bmod M $  $ x $  C  $ \\{ A_i \\} $  $ \\{B_i\\} $  $ i $ $ A_i \\neq B_i $ C  $ \\bmod 1004535809 $ \n\n<!-- more -->\n\n### \n[BZOJ 3992](http://www.lydsy.com/JudgeOnline/problem.php?id=3992)\n\n### \n $ x $  $ S_i $  $ x $  $ M $  $ \\log S_i $  $ \\log x $ \n\n $ M $  $ 0 $ $ M - 2 $  $ [1,\\ M - 1] $  $ [0,\\ M - 2] $ $ g ^ {M - 1} \\equiv g ^ 0 \\equiv 1 \\pmod {M} $\n\n\n\n$$ A(x) = \\sum\\limits_{i = 0} ^ {\\infty} a_i x ^ i $$\n\n $ S_i $ $ a_{\\log S_i} = 1 $ $ a_{\\log S_i} = 0 $\n\n $ A ^ N(x) $  $ \\log x $  NTT\n\n $ \\bmod {M - 1} $  $ \\log x $ $ \\bmod {M - 1} $  $ i $  $ i $ \n\n $ O(M \\sqrt M + M \\log M \\log N) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXM = 8000;\nconst int MAXM_EXTENDED = 16384;\nconst long long MOD = 1004535809;\n\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\t// printf(\"root(%lld) = %d\\n\", p, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nint m;\nlong long log[MAXM];\n\ninline void prepare() {\n\tlong long t = 1, r = root(m);\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tlog[t] = i;\n\t\t// printf(\"log(%lld) = %d\\n\", t, i);\n\t\tt = t * r % m;\n\t}\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t\t// printf(\"omega[%d] = %lld\\n\", i, omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t\tassert(t < MAXM_EXTENDED);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tassert(n / l * i < MAXM_EXTENDED);\n\t\t\t\t\tassert(p - a + i < MAXM_EXTENDED);\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\t// printf(\"use omega = %lld\\n\", omega[n / l * i]);\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n\n\tvoid operator()(long long *a, long long *b, const int n) {\n\t\tassert(n <= MAXM_EXTENDED);\n\t\t/*\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tprintf(\" * \");\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tdft(a, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tif (a != b) dft(b, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;\n\n\t\tidft(a, n);\n\t\tif (a != b) idft(b, n);\n\t}\n} ntt;\n\ninline void pow(const long long *a, const int m, const int n, long long *res) {\n\tint size = 1;\n\twhile (size < m + m) size *= 2;\n\tntt.init(size);\n\t// printf(\"size = %d, m = %d\\n\", size, m);\n\n\tstatic long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED];\n\tstd::copy(a, a + m, buf);\n\tstd::copy(a, a + m, res);\n\tint tmp = n - 1;\n\n\t/*\n\tfor (int i = 0; i < tmp; i++) {\n\t\tntt(res, buf, size);\n\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t}\n\treturn;\n\t*/\n\n\tassert(size <= MAXM_EXTENDED);\n\n\twhile (tmp) {\n\t\tif (tmp & 1) {\n\t\t\tntt.dft(res, size);\n\t\t\tstd::copy(buf, buf + size, bufDft);\n\t\t\tntt.dft(bufDft, size);\n\t\t\tfor (int i = 0; i < size; i++) (res[i] *= bufDft[i]) %= MOD;\n\t\t\tntt.idft(res, size);\n\t\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t\t}\n\t\ttmp >>= 1;\n\n\t\tntt.dft(buf, size);\n\t\tfor (int i = 0; i < size; i++) (buf[i] *= buf[i]) %= MOD;\n\t\tntt.idft(buf, size);\n\t\tfor (int i = m; i < size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0;\n\t}\n}\n\nint main() {\n\tlong long n;\n\tint x, s;\n\tstatic long long a[MAXM];\n\n\tscanf(\"%lld %d %d %d\", &n, &m, &x, &s);\n\tfor (int i = 0; i < s; i++) scanf(\"%lld\", &a[i]);\n\n\tprepare();\n\n\tstatic long long f[MAXM_EXTENDED];\n\tfor (int i = 0; i < s; i++) {\n\t\tif (a[i] == 0) continue;\n\t\tf[log[a[i] % m]]++;\n\t}\n\n\tstatic long long res[MAXM_EXTENDED];\n\tpow(f, m - 1, n, res);\n\n\tassert(log[x] < MAXM_EXTENDED);\n\n\tlong long ans = res[log[x]];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-sequence.md","raw":"title: SDOI2015 -  + NTT\ndate: 2016-06-12 09:27:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - FFT\n  - NTT\n  - \n  - \n  - \n  - \npermalink: sdoi2015-sequence\n---\n\n C  $ S $ $ M $  $ N $  $ S $\n\n C  C  $ x $ $ \\bmod M $  $ x $  C  $ \\{ A_i \\} $  $ \\{B_i\\} $  $ i $ $ A_i \\neq B_i $ C  $ \\bmod 1004535809 $ \n\n<!-- more -->\n\n### \n[BZOJ 3992](http://www.lydsy.com/JudgeOnline/problem.php?id=3992)\n\n### \n $ x $  $ S_i $  $ x $  $ M $  $ \\log S_i $  $ \\log x $ \n\n $ M $  $ 0 $ $ M - 2 $  $ [1,\\ M - 1] $  $ [0,\\ M - 2] $ $ g ^ {M - 1} \\equiv g ^ 0 \\equiv 1 \\pmod {M} $\n\n\n\n$$ A(x) = \\sum\\limits_{i = 0} ^ {\\infty} a_i x ^ i $$\n\n $ S_i $ $ a_{\\log S_i} = 1 $ $ a_{\\log S_i} = 0 $\n\n $ A ^ N(x) $  $ \\log x $  NTT\n\n $ \\bmod {M - 1} $  $ \\log x $ $ \\bmod {M - 1} $  $ i $  $ i $ \n\n $ O(M \\sqrt M + M \\log M \\log N) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXM = 8000;\nconst int MAXM_EXTENDED = 16384;\nconst long long MOD = 1004535809;\n\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\t// printf(\"root(%lld) = %d\\n\", p, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nint m;\nlong long log[MAXM];\n\ninline void prepare() {\n\tlong long t = 1, r = root(m);\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tlog[t] = i;\n\t\t// printf(\"log(%lld) = %d\\n\", t, i);\n\t\tt = t * r % m;\n\t}\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t\t// printf(\"omega[%d] = %lld\\n\", i, omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t\tassert(t < MAXM_EXTENDED);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tassert(n / l * i < MAXM_EXTENDED);\n\t\t\t\t\tassert(p - a + i < MAXM_EXTENDED);\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\t// printf(\"use omega = %lld\\n\", omega[n / l * i]);\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n\n\tvoid operator()(long long *a, long long *b, const int n) {\n\t\tassert(n <= MAXM_EXTENDED);\n\t\t/*\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tprintf(\" * \");\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tdft(a, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tif (a != b) dft(b, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;\n\n\t\tidft(a, n);\n\t\tif (a != b) idft(b, n);\n\t}\n} ntt;\n\ninline void pow(const long long *a, const int m, const int n, long long *res) {\n\tint size = 1;\n\twhile (size < m + m) size *= 2;\n\tntt.init(size);\n\t// printf(\"size = %d, m = %d\\n\", size, m);\n\n\tstatic long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED];\n\tstd::copy(a, a + m, buf);\n\tstd::copy(a, a + m, res);\n\tint tmp = n - 1;\n\n\t/*\n\tfor (int i = 0; i < tmp; i++) {\n\t\tntt(res, buf, size);\n\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t}\n\treturn;\n\t*/\n\n\tassert(size <= MAXM_EXTENDED);\n\n\twhile (tmp) {\n\t\tif (tmp & 1) {\n\t\t\tntt.dft(res, size);\n\t\t\tstd::copy(buf, buf + size, bufDft);\n\t\t\tntt.dft(bufDft, size);\n\t\t\tfor (int i = 0; i < size; i++) (res[i] *= bufDft[i]) %= MOD;\n\t\t\tntt.idft(res, size);\n\t\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t\t}\n\t\ttmp >>= 1;\n\n\t\tntt.dft(buf, size);\n\t\tfor (int i = 0; i < size; i++) (buf[i] *= buf[i]) %= MOD;\n\t\tntt.idft(buf, size);\n\t\tfor (int i = m; i < size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0;\n\t}\n}\n\nint main() {\n\tlong long n;\n\tint x, s;\n\tstatic long long a[MAXM];\n\n\tscanf(\"%lld %d %d %d\", &n, &m, &x, &s);\n\tfor (int i = 0; i < s; i++) scanf(\"%lld\", &a[i]);\n\n\tprepare();\n\n\tstatic long long f[MAXM_EXTENDED];\n\tfor (int i = 0; i < s; i++) {\n\t\tif (a[i] == 0) continue;\n\t\tf[log[a[i] % m]]++;\n\t}\n\n\tstatic long long res[MAXM_EXTENDED];\n\tpow(f, m - 1, n, res);\n\n\tassert(log[x] < MAXM_EXTENDED);\n\n\tlong long ans = res[log[x]];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2015-sequence","published":1,"updated":"2016-06-17T13:39:09.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rfo00csooxlhfez3dbn"},{"title":"SDOI2014 - ","date":"2016-09-02T13:39:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 3531](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)\n\n### \n $ O(n \\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 1e5;\nconst int MAXQ = 1e5;\nconst int MAXC = 1e5;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint max, sum;\n\n\tSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {}\n\n\tvoid update(const int pos, const int val) {\n\t\tif (l != r) {\n\t\t\tSegmentTree *&c = pos <= mid ? lc : rc;\n\t\t\tif (!c) c = (pos <= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r);\n\t\t\tc->update(pos, val);\n\t\t\tif (val == 0 && !c->lc && !c->rc) delete c, c = NULL;\n\t\t\tmax = sum = 0;\n\t\t\tif (lc) max = std::max(max, lc->max), sum += lc->sum;\n\t\t\tif (rc) max = std::max(max, rc->max), sum += rc->sum;\n\t\t} else sum = max = val;\n\t}\n\n\tint querySum(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return (lc ? lc->querySum(l, r) : 0) + (rc ? rc->querySum(l, r) : 0);\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc ? lc->queryMax(l, r) : 0, rc ? rc->queryMax(l, r) : 0);\n\t}\n} *seg[MAXC];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i;\n\tbool f;\n\tNode *p, *c, *t;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, q, f[MAXN], v[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].d = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->f) {\n\t\t\tv->f = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n\t\t\t\te->t->d = v->d + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->s = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->s += e->t->s;\n\t\t\t\tif (!v->c || v->c->s < e->t->s) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\ts.push(&N[0]);\n\tint i = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (v->f) {\n\t\t\tv->f = false;\n\t\t\tv->i = i++;\n\t\t\tif (!v->p || v != v->p->c) v->t = v;\n\t\t\telse v->t = v->p->t;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else s.pop();\n\t}\n}\n\ninline int querySum(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans += seg->querySum(a->t->i, a->i);\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn ans + seg->querySum(a->i, b->i);\n}\n\ninline int queryMax(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans = std::max(ans, seg->queryMax(a->t->i, a->i));\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn std::max(ans, seg->queryMax(a->i, b->i));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (int i = 0; i < MAXC; i++) seg[i] = new SegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &v[i], &f[i]);\n\t\tf[i]--;\n\t\t// printf(\"seg[%d]->update(%d, %d)\\n\", f[i], i, v[i]);\n\t\t// seg[f[i]]->update(i, v[i]);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < n; i++) seg[f[i]]->update(N[i].i, v[i]);\n\n\twhile (q-- ) {\n\t\tchar s[3];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", s, &a, &b);\n\t\t\n\t\tif (s[1] == 'C') {\n\t\t\ta--, b--;\n\t\t\tseg[f[a]]->update(N[a].i, 0);\n\t\t\tseg[b]->update(N[a].i, v[a]);\n\t\t\tf[a] = b;\n\t\t} else if (s[1] == 'W') {\n\t\t\ta--;\n\t\t\tseg[f[a]]->update(N[a].i, b);\n\t\t\tv[a] = b;\n\t\t} else if (s[1] == 'S') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", querySum(a, b, seg[f[a]]));\n\t\t} else if (s[1] == 'M') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", queryMax(a, b, seg[f[a]]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/sdoi2014-journey.md","raw":"title: SDOI2014 - \ndate: 2016-09-02 21:39:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \npermalink: sdoi2014-journey\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3531](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)\n\n### \n $ O(n \\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 1e5;\nconst int MAXQ = 1e5;\nconst int MAXC = 1e5;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint max, sum;\n\n\tSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {}\n\n\tvoid update(const int pos, const int val) {\n\t\tif (l != r) {\n\t\t\tSegmentTree *&c = pos <= mid ? lc : rc;\n\t\t\tif (!c) c = (pos <= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r);\n\t\t\tc->update(pos, val);\n\t\t\tif (val == 0 && !c->lc && !c->rc) delete c, c = NULL;\n\t\t\tmax = sum = 0;\n\t\t\tif (lc) max = std::max(max, lc->max), sum += lc->sum;\n\t\t\tif (rc) max = std::max(max, rc->max), sum += rc->sum;\n\t\t} else sum = max = val;\n\t}\n\n\tint querySum(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return (lc ? lc->querySum(l, r) : 0) + (rc ? rc->querySum(l, r) : 0);\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc ? lc->queryMax(l, r) : 0, rc ? rc->queryMax(l, r) : 0);\n\t}\n} *seg[MAXC];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i;\n\tbool f;\n\tNode *p, *c, *t;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, q, f[MAXN], v[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].d = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->f) {\n\t\t\tv->f = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n\t\t\t\te->t->d = v->d + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->s = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->s += e->t->s;\n\t\t\t\tif (!v->c || v->c->s < e->t->s) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\ts.push(&N[0]);\n\tint i = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (v->f) {\n\t\t\tv->f = false;\n\t\t\tv->i = i++;\n\t\t\tif (!v->p || v != v->p->c) v->t = v;\n\t\t\telse v->t = v->p->t;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else s.pop();\n\t}\n}\n\ninline int querySum(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans += seg->querySum(a->t->i, a->i);\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn ans + seg->querySum(a->i, b->i);\n}\n\ninline int queryMax(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans = std::max(ans, seg->queryMax(a->t->i, a->i));\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn std::max(ans, seg->queryMax(a->i, b->i));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (int i = 0; i < MAXC; i++) seg[i] = new SegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &v[i], &f[i]);\n\t\tf[i]--;\n\t\t// printf(\"seg[%d]->update(%d, %d)\\n\", f[i], i, v[i]);\n\t\t// seg[f[i]]->update(i, v[i]);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < n; i++) seg[f[i]]->update(N[i].i, v[i]);\n\n\twhile (q-- ) {\n\t\tchar s[3];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", s, &a, &b);\n\t\t\n\t\tif (s[1] == 'C') {\n\t\t\ta--, b--;\n\t\t\tseg[f[a]]->update(N[a].i, 0);\n\t\t\tseg[b]->update(N[a].i, v[a]);\n\t\t\tf[a] = b;\n\t\t} else if (s[1] == 'W') {\n\t\t\ta--;\n\t\t\tseg[f[a]]->update(N[a].i, b);\n\t\t\tv[a] = b;\n\t\t} else if (s[1] == 'S') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", querySum(a, b, seg[f[a]]));\n\t\t} else if (s[1] == 'M') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", queryMax(a, b, seg[f[a]]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"sdoi2014-journey","published":1,"updated":"2016-09-02T13:42:35.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rft00d6ooxlm2ytmtoh"},{"title":"SDOI2013 - LCA +  + ","date":"2016-09-05T13:49:00.000Z","_content":"\n $ n $ $ m $  $ T $ \n\n1.  $ k $ \n2. \n\n<!-- more -->\n\n### \n[BZOJ 3123](http://www.lydsy.com/JudgeOnline/problem.php?id=3123)\n\n### \n $ k $ \n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 80000;\nconst int MAXN_LOG = 17;\n\nstruct UnionFindSet {\n\tint a[MAXN], s[MAXN];\n\n\tinline void init(const int n) { for (register int i = 0; i < n; i++) a[i] = i, s[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tinline int getSize(const int x) { return s[find(x)]; }\n\n\tinline void merge(const int x, const int y) {\n\t\tconst register int p = find(x), q = find(y);\n\t\ta[p] = q;\n\t\ts[q] += s[p];\n\t}\n} ufs;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint cnt, refCnt;\n\n\tinline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {}\n\n\tinline static SegmentTree *newNode();\n\tinline static void deleteNode(SegmentTree *v);\n\n\t~SegmentTree() {\n\t\tif (r - l < 600) return;\n\t\tif (lc && lc->unref()) deleteNode(lc);\n\t\tif (rc && rc->unref()) deleteNode(rc);\n\t}\n\n\tinline SegmentTree *buildChild(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x <= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0);\n\t\telse return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0);\n\t}\n\n\tSegmentTree *insertSelf(const int x) {\n\t\tcnt++;\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return this;\n\t\telse if (x <= mid) return (lc = buildChild(x))->insertSelf(x), this;\n\t\telse return (rc = buildChild(x))->insertSelf(x), this;\n\t}\n\n\tSegmentTree *insert(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1);\n\t\telse if (x <= mid) return new (newNode()) SegmentTree(l, r, lc ? lc->insert(x) : buildChild(x)->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\telse return new (newNode()) SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : buildChild(x)->insertSelf(x), cnt + 1);\n\t}\n\n\tinline SegmentTree *ref() {\n\t\trefCnt++;\n\t\treturn this;\n\t}\n\n\tinline bool unref() {\n\t\treturn !--refCnt;\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse return lc->query(l, r) + rc->query(l, r);\n\t}\n\n\tinline int rank() {\n\t\treturn lc ? lc->cnt : 0;\n\t}\n} *segRoot;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[sizeof(T) * SIZE], *p;\n\tT *recycle[SIZE], **pr;\n\t\n\tinline MemoryPool() : p(buf), pr(recycle) {}\n\n\tinline T *alloc() {\n\t\tif (p == buf + sizeof(T) * SIZE) {\n\t\t\tif (pr <= recycle) throw std::bad_alloc();\n\t\t\telse return *--pr;\n\t\t} else {\n\t\t\tregister char *res = p;\n\t\t\tp += sizeof(T);\n\t\t\treturn reinterpret_cast<T *>(res);\n\t\t}\n\t}\n\n\tinline void free(T *p) {\n\t\t*pr++ = p;\n\t}\n};\n\nMemoryPool<SegmentTree, MAXN * MAXN_LOG * 10> pool;\ninline SegmentTree *SegmentTree::newNode() {\n\treturn pool.alloc();\n}\n\ninline void SegmentTree::deleteNode(SegmentTree *p) {\n\tp->~SegmentTree();\n\tpool.free(p);\n}\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *p;\n\tint w, ts, d;\n\tbool v;\n\tSegmentTree *seg;\n\tNode *f[MAXN_LOG + 1];\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {};\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nint n, ts, logn = 0;\n\ninline void bfs(Node *start, const bool init = true) {\n\t++ts;\n\tstd::queue<Node *> q;\n\tstart->ts = ts;\n\tif (init) {\n\t\tstart->p = start->f[0] = start;\n\t\tstart->seg = segRoot->insert(start->w);\n\t\tstart->d = 0;\n\t}\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (register int j = 1; j <= logn; j++) {\n\t\t\tv->f[j] = v->f[j - 1]->f[j - 1];\n\t\t}\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->ts != ts && (init || e->t != start->p)) {\n\t\t\te->t->ts = ts;\n\t\t\te->t->p = e->t->f[0] = v;\n\t\t\tif (e->t->seg) SegmentTree::deleteNode(e->t->seg);\n\t\t\te->t->seg = v->seg->insert(e->t->w);\n\t\t\te->t->d = v->d + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void bfs() {\n\tfor (register int i = 0; i < n; i++) if (N[i].ts == 0) bfs(&N[i]);\n}\n\ninline void link(int u, int v) {\n\tconst register int su = ufs.getSize(u), sv = ufs.getSize(v);\n\tif (su > sv) std::swap(u, v);\n\n\taddEdge(u, v);\n\tN[u].p = N[u].f[0] = &N[v];\n\tSegmentTree::deleteNode(N[u].seg);\n\tN[u].seg = N[v].seg->insert(N[u].w);\n\tN[u].d = N[v].d + 1;\n\tbfs(&N[u], false);\n\n\tufs.merge(u, v);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\tif (u->d < v->d) std::swap(u, v);\n\tif (u->d != v->d) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i]->d >= v->d) u = u->f[i];\n\t}\n\tif (u != v) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n\t\treturn u->p;\n\t}\n\treturn u;\n}\n\ninline int query(Node *u, Node *v, int k) {\n\tNode *p = lca(u, v);\n\tregister int min = 0, max = n - 1;\n\tSegmentTree *sa = u->seg, *sb = v->seg, *sc = p->seg, *sd = p->p != p ? p->p->seg : segRoot;\n\twhile (min != max) {\n\t\tconst register int mid = min + (max - min) / 2;\n\t\tregister int t = 0;\n\t\tif (sa) t += sa->rank();\n\t\tif (sb) t += sb->rank();\n\t\tif (sc) t -= sc->rank();\n\t\tif (sd) t -= sd->rank();\n\t\tif (k <= t) {\n\t\t\tif (sa) sa = sa->lc;\n\t\t\tif (sb) sb = sb->lc;\n\t\t\tif (sc) sc = sc->lc;\n\t\t\tif (sd) sd = sd->lc;\n\t\t\tmax = mid;\n\t\t} else {\n\t\t\tif (sa) sa = sa->rc;\n\t\t\tif (sb) sb = sb->rc;\n\t\t\tif (sc) sc = sc->rc;\n\t\t\tif (sd) sd = sd->rc;\n\t\t\tk -= t, min = mid + 1;\n\t\t}\n\t}\n\treturn min;\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tint m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tufs.init(n);\n\tfor (; (1 << (logn + 1)) <= n; logn++);\n\n\tfor (register int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\tstatic int set[MAXN];\n\tfor (register int i = 0; i < n; i++) set[i] = N[i].w;\n\tstd::sort(set, set + n);\n\tregister int *end = std::unique(set, set + n);\n\tfor (register int i = 0; i < n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set;\n\n\tsegRoot = new SegmentTree(0, n - 1);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbfs();\n\n\tregister int lastAns = 0;\n\twhile (t--) {\n\t\tchar cmd[2];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", cmd, &u, &v), u ^= lastAns, v ^= lastAns, u--, v--;\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tk ^= lastAns;\n\t\t\tprintf(\"%d\\n\", lastAns = set[query(&N[u], &N[v], k)]);\n\t\t} else {\n\t\t\tlink(u, v);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2013-rforest.md","raw":"title: SDOI2013 - LCA +  + \ndate: 2016-09-05 21:49:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \n  - \n  - \npermalink: sdoi2013-rforest\n---\n\n $ n $ $ m $  $ T $ \n\n1.  $ k $ \n2. \n\n<!-- more -->\n\n### \n[BZOJ 3123](http://www.lydsy.com/JudgeOnline/problem.php?id=3123)\n\n### \n $ k $ \n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 80000;\nconst int MAXN_LOG = 17;\n\nstruct UnionFindSet {\n\tint a[MAXN], s[MAXN];\n\n\tinline void init(const int n) { for (register int i = 0; i < n; i++) a[i] = i, s[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tinline int getSize(const int x) { return s[find(x)]; }\n\n\tinline void merge(const int x, const int y) {\n\t\tconst register int p = find(x), q = find(y);\n\t\ta[p] = q;\n\t\ts[q] += s[p];\n\t}\n} ufs;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint cnt, refCnt;\n\n\tinline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {}\n\n\tinline static SegmentTree *newNode();\n\tinline static void deleteNode(SegmentTree *v);\n\n\t~SegmentTree() {\n\t\tif (r - l < 600) return;\n\t\tif (lc && lc->unref()) deleteNode(lc);\n\t\tif (rc && rc->unref()) deleteNode(rc);\n\t}\n\n\tinline SegmentTree *buildChild(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x <= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0);\n\t\telse return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0);\n\t}\n\n\tSegmentTree *insertSelf(const int x) {\n\t\tcnt++;\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return this;\n\t\telse if (x <= mid) return (lc = buildChild(x))->insertSelf(x), this;\n\t\telse return (rc = buildChild(x))->insertSelf(x), this;\n\t}\n\n\tSegmentTree *insert(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1);\n\t\telse if (x <= mid) return new (newNode()) SegmentTree(l, r, lc ? lc->insert(x) : buildChild(x)->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\telse return new (newNode()) SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : buildChild(x)->insertSelf(x), cnt + 1);\n\t}\n\n\tinline SegmentTree *ref() {\n\t\trefCnt++;\n\t\treturn this;\n\t}\n\n\tinline bool unref() {\n\t\treturn !--refCnt;\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse return lc->query(l, r) + rc->query(l, r);\n\t}\n\n\tinline int rank() {\n\t\treturn lc ? lc->cnt : 0;\n\t}\n} *segRoot;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[sizeof(T) * SIZE], *p;\n\tT *recycle[SIZE], **pr;\n\t\n\tinline MemoryPool() : p(buf), pr(recycle) {}\n\n\tinline T *alloc() {\n\t\tif (p == buf + sizeof(T) * SIZE) {\n\t\t\tif (pr <= recycle) throw std::bad_alloc();\n\t\t\telse return *--pr;\n\t\t} else {\n\t\t\tregister char *res = p;\n\t\t\tp += sizeof(T);\n\t\t\treturn reinterpret_cast<T *>(res);\n\t\t}\n\t}\n\n\tinline void free(T *p) {\n\t\t*pr++ = p;\n\t}\n};\n\nMemoryPool<SegmentTree, MAXN * MAXN_LOG * 10> pool;\ninline SegmentTree *SegmentTree::newNode() {\n\treturn pool.alloc();\n}\n\ninline void SegmentTree::deleteNode(SegmentTree *p) {\n\tp->~SegmentTree();\n\tpool.free(p);\n}\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *p;\n\tint w, ts, d;\n\tbool v;\n\tSegmentTree *seg;\n\tNode *f[MAXN_LOG + 1];\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {};\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nint n, ts, logn = 0;\n\ninline void bfs(Node *start, const bool init = true) {\n\t++ts;\n\tstd::queue<Node *> q;\n\tstart->ts = ts;\n\tif (init) {\n\t\tstart->p = start->f[0] = start;\n\t\tstart->seg = segRoot->insert(start->w);\n\t\tstart->d = 0;\n\t}\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (register int j = 1; j <= logn; j++) {\n\t\t\tv->f[j] = v->f[j - 1]->f[j - 1];\n\t\t}\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->ts != ts && (init || e->t != start->p)) {\n\t\t\te->t->ts = ts;\n\t\t\te->t->p = e->t->f[0] = v;\n\t\t\tif (e->t->seg) SegmentTree::deleteNode(e->t->seg);\n\t\t\te->t->seg = v->seg->insert(e->t->w);\n\t\t\te->t->d = v->d + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void bfs() {\n\tfor (register int i = 0; i < n; i++) if (N[i].ts == 0) bfs(&N[i]);\n}\n\ninline void link(int u, int v) {\n\tconst register int su = ufs.getSize(u), sv = ufs.getSize(v);\n\tif (su > sv) std::swap(u, v);\n\n\taddEdge(u, v);\n\tN[u].p = N[u].f[0] = &N[v];\n\tSegmentTree::deleteNode(N[u].seg);\n\tN[u].seg = N[v].seg->insert(N[u].w);\n\tN[u].d = N[v].d + 1;\n\tbfs(&N[u], false);\n\n\tufs.merge(u, v);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\tif (u->d < v->d) std::swap(u, v);\n\tif (u->d != v->d) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i]->d >= v->d) u = u->f[i];\n\t}\n\tif (u != v) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n\t\treturn u->p;\n\t}\n\treturn u;\n}\n\ninline int query(Node *u, Node *v, int k) {\n\tNode *p = lca(u, v);\n\tregister int min = 0, max = n - 1;\n\tSegmentTree *sa = u->seg, *sb = v->seg, *sc = p->seg, *sd = p->p != p ? p->p->seg : segRoot;\n\twhile (min != max) {\n\t\tconst register int mid = min + (max - min) / 2;\n\t\tregister int t = 0;\n\t\tif (sa) t += sa->rank();\n\t\tif (sb) t += sb->rank();\n\t\tif (sc) t -= sc->rank();\n\t\tif (sd) t -= sd->rank();\n\t\tif (k <= t) {\n\t\t\tif (sa) sa = sa->lc;\n\t\t\tif (sb) sb = sb->lc;\n\t\t\tif (sc) sc = sc->lc;\n\t\t\tif (sd) sd = sd->lc;\n\t\t\tmax = mid;\n\t\t} else {\n\t\t\tif (sa) sa = sa->rc;\n\t\t\tif (sb) sb = sb->rc;\n\t\t\tif (sc) sc = sc->rc;\n\t\t\tif (sd) sd = sd->rc;\n\t\t\tk -= t, min = mid + 1;\n\t\t}\n\t}\n\treturn min;\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tint m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tufs.init(n);\n\tfor (; (1 << (logn + 1)) <= n; logn++);\n\n\tfor (register int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\tstatic int set[MAXN];\n\tfor (register int i = 0; i < n; i++) set[i] = N[i].w;\n\tstd::sort(set, set + n);\n\tregister int *end = std::unique(set, set + n);\n\tfor (register int i = 0; i < n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set;\n\n\tsegRoot = new SegmentTree(0, n - 1);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbfs();\n\n\tregister int lastAns = 0;\n\twhile (t--) {\n\t\tchar cmd[2];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", cmd, &u, &v), u ^= lastAns, v ^= lastAns, u--, v--;\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tk ^= lastAns;\n\t\t\tprintf(\"%d\\n\", lastAns = set[query(&N[u], &N[v], k)]);\n\t\t} else {\n\t\t\tlink(u, v);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"sdoi2013-rforest","published":1,"updated":"2016-10-19T09:24:21.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rfw00dcooxlt9lyjj2q"},{"title":"SDOI2011 -  + EXGCD + BSGS","date":"2016-06-13T04:07:00.000Z","_content":"\n\n\n1.  $ y $$ z $$ p $ $ y ^ z \\bmod p $ \n2.  $ y $$ z $$ p $ $ xy \\equiv z \\pmod p $  $ x $\n3.  $ y $$ z $$ p $ $ y ^ x \\equiv z \\pmod p $ $ x $\n\n<!-- more -->\n\n### \n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242)\n\n### \n\n\n $ y \\equiv 0 \\pmod p $  $ z \\not \\equiv 0 \\pmod p $   \n $ z \\equiv 0 \\pmod p $  $ 0 $\n\n $ y $  $ p $ \n\n$$ x \\equiv z \\times y ^ {-1} \\pmod p $$\n\nEXGCD \n\nBSGS \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <tr1/unordered_map>\n\ntemplate <typename T>\ninline T pow(const T a, const T n, const T p) {\n\tT ans = 1;\n\tfor (T x = a, tmp = n; tmp; tmp >>= 1, x = x * x % p) if (tmp & 1) ans = ans * x % p;\n\treturn ans;\n}\n\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tif (a == 0) {\n\t\treturn b == 0 ? 1 : -1;\n\t}\n\n\tstd::tr1::unordered_map<T, T> map;\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT r = b, k = inv(t, p) % p;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(r)) return map[r] + i * m;\n\t\tr = r * k % p;\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\twhile (t--) {\n\t\tlong long a, b, p;\n\t\tscanf(\"%lld %lld %lld\", &a, &b, &p);\n\t\tif (k == 1) {\n\t\t\tprintf(\"%lld\\n\", pow(a, b, p));\n\t\t} else if (k == 2) {\n\t\t\tif (a > p && a % p == 0) puts(\"Orz, I cannot find x!\");\n\t\t\telse {\n\t\t\t\tlong long t = inv(a, p);\n\t\t\t\tprintf(\"%lld\\n\", b * t % p);\n\t\t\t}\n\t\t} else if (k == 3) {\n\t\t\tlong long ans = bsgs(a % p, b % p, p);\n\t\t\tif (ans == -1) puts(\"Orz, I cannot find x!\");\n\t\t\telse printf(\"%lld\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2011-calc.md","raw":"title: SDOI2011 -  + EXGCD + BSGS\ndate: 2016-06-13 12:07:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - EXGCD\n  - \n  - BSGS\npermalink: sdoi2011-calc\n---\n\n\n\n1.  $ y $$ z $$ p $ $ y ^ z \\bmod p $ \n2.  $ y $$ z $$ p $ $ xy \\equiv z \\pmod p $  $ x $\n3.  $ y $$ z $$ p $ $ y ^ x \\equiv z \\pmod p $ $ x $\n\n<!-- more -->\n\n### \n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242)\n\n### \n\n\n $ y \\equiv 0 \\pmod p $  $ z \\not \\equiv 0 \\pmod p $   \n $ z \\equiv 0 \\pmod p $  $ 0 $\n\n $ y $  $ p $ \n\n$$ x \\equiv z \\times y ^ {-1} \\pmod p $$\n\nEXGCD \n\nBSGS \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <tr1/unordered_map>\n\ntemplate <typename T>\ninline T pow(const T a, const T n, const T p) {\n\tT ans = 1;\n\tfor (T x = a, tmp = n; tmp; tmp >>= 1, x = x * x % p) if (tmp & 1) ans = ans * x % p;\n\treturn ans;\n}\n\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tif (a == 0) {\n\t\treturn b == 0 ? 1 : -1;\n\t}\n\n\tstd::tr1::unordered_map<T, T> map;\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT r = b, k = inv(t, p) % p;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(r)) return map[r] + i * m;\n\t\tr = r * k % p;\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\twhile (t--) {\n\t\tlong long a, b, p;\n\t\tscanf(\"%lld %lld %lld\", &a, &b, &p);\n\t\tif (k == 1) {\n\t\t\tprintf(\"%lld\\n\", pow(a, b, p));\n\t\t} else if (k == 2) {\n\t\t\tif (a > p && a % p == 0) puts(\"Orz, I cannot find x!\");\n\t\t\telse {\n\t\t\t\tlong long t = inv(a, p);\n\t\t\t\tprintf(\"%lld\\n\", b * t % p);\n\t\t\t}\n\t\t} else if (k == 3) {\n\t\t\tlong long ans = bsgs(a % p, b % p, p);\n\t\t\tif (ans == -1) puts(\"Orz, I cannot find x!\");\n\t\t\telse printf(\"%lld\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"sdoi2011-calc","published":1,"updated":"2016-06-13T04:07:43.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rg100dnooxloxhb1gg3"},{"title":"SDOI2010 - ","date":"2016-02-29T13:30:11.000Z","_content":"\n $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### \n  \n\n****\n\n1.  1\n2.  1 \n3.  1 \n4.  1 \n5.  1  0  1 \n\n   \n\n  \n\n\n\n****\n\n1. \n2.  1 \n3.  1 \n4.  1 \n5. **** 1 \n\n  \n\n  \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-starrace.md","raw":"title: SDOI2010 -  \ndate: 2016-02-29 21:30:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Edmonds-Karp\n  - \n  - \n  - \npermalink: sdoi2010-starrace\n---\n\n $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### \n  \n\n****\n\n1.  1\n2.  1 \n3.  1 \n4.  1 \n5.  1  0  1 \n\n   \n\n  \n\n\n\n****\n\n1. \n2.  1 \n3.  1 \n4.  1 \n5. **** 1 \n\n  \n\n  \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-starrace","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rg500dxooxl2qhyge5n"},{"title":"SDOI2010 - DP","date":"2016-06-20T07:49:00.000Z","_content":"\n\n\n $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1925](http://www.lydsy.com/JudgeOnline/problem.php?id=1925)\n\n### \n $ 0 $ ~ $ n - 1 $ \n\n $ f(i,\\ j) $  $ 0 $ ~ $ i $  $ j $$ j \\leq i $****\n\n**** $ j - 1 $  $ j - 1 $  $ f(i,\\ j - 1) $  \n**** $ j - 1 $  $ 0 $ ~ $ i - 1 $ **** $ x $  $ (i - 1) - x $ $ f(i - 1,\\ (i - 1) - (j - 1)) $\n\n $ f(i,\\ j) = f(i,\\ j - 1) + f(i - 1, i - j) $\n\n $ 2 \\sum\\limits_{i = 0} ^ {n - 1} f(n - 1,\\ i) $**** $ 2 $\n\n### \n 30M+ \n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\nint _f[MAXN * (MAXN + 1) / 2];\nint *f[MAXN + 1];\n\ninline void init() {\n\tint *curr = _f;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i] = curr;\n\t\tcurr += i + 1;\n\t}\n\t// printf(\"%ld %d\\n\", curr - _f, n * (n + 1) / 2);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\tinit();\n\n\tf[1][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p;\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[n - 1][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\n\tstatic int f[2][MAXN];\n\tf[1 % 2][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[(n - 1) % 2][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-goblin.md","raw":"title: SDOI2010 - DP\ndate: 2016-06-20 15:49:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - DP\npermalink: sdoi2010-goblin\n---\n\n\n\n $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1925](http://www.lydsy.com/JudgeOnline/problem.php?id=1925)\n\n### \n $ 0 $ ~ $ n - 1 $ \n\n $ f(i,\\ j) $  $ 0 $ ~ $ i $  $ j $$ j \\leq i $****\n\n**** $ j - 1 $  $ j - 1 $  $ f(i,\\ j - 1) $  \n**** $ j - 1 $  $ 0 $ ~ $ i - 1 $ **** $ x $  $ (i - 1) - x $ $ f(i - 1,\\ (i - 1) - (j - 1)) $\n\n $ f(i,\\ j) = f(i,\\ j - 1) + f(i - 1, i - j) $\n\n $ 2 \\sum\\limits_{i = 0} ^ {n - 1} f(n - 1,\\ i) $**** $ 2 $\n\n### \n 30M+ \n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\nint _f[MAXN * (MAXN + 1) / 2];\nint *f[MAXN + 1];\n\ninline void init() {\n\tint *curr = _f;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i] = curr;\n\t\tcurr += i + 1;\n\t}\n\t// printf(\"%ld %d\\n\", curr - _f, n * (n + 1) / 2);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\tinit();\n\n\tf[1][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p;\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[n - 1][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\n\tstatic int f[2][MAXN];\n\tf[1 % 2][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[(n - 1) % 2][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-goblin","published":1,"updated":"2016-06-20T07:50:35.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rg800e5ooxlwalebfg2"},{"title":"SDOI2009 - ","date":"2016-06-21T12:24:00.000Z","_content":"\n $ N $  $ M $ Elaxia Elaxia  $ 1 $ $ N $ Elaxia   \n\n\n<!-- more -->\n\n### \n[BZOJ 1877](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)\n\n### \n $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\t// printf(\"%d %d\\n\", f, c);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->d > v->d + e->w && e->f < e->c) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\t// printf(\"[%ld, %ld]\\n\", e->s - N, e->t - N);\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1, 0);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\taddEdge(u + n, v, 1, w);\n\t}\n\n\taddEdge(s, 1 + n, INT_MAX, 0);\n\taddEdge(n, t, INT_MAX, 0);\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tprintf(\"%d %d\\n\", f, c);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2009-run.md","raw":"title: SDOI2009 - \ndate: 2016-06-21 20:24:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \n  - Edmonds-Karp\npermalink: sdoi2009-run\n---\n\n $ N $  $ M $ Elaxia Elaxia  $ 1 $ $ N $ Elaxia   \n\n\n<!-- more -->\n\n### \n[BZOJ 1877](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)\n\n### \n $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\t// printf(\"%d %d\\n\", f, c);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->d > v->d + e->w && e->f < e->c) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\t// printf(\"[%ld, %ld]\\n\", e->s - N, e->t - N);\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1, 0);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\taddEdge(u + n, v, 1, w);\n\t}\n\n\taddEdge(s, 1 + n, INT_MAX, 0);\n\taddEdge(n, t, INT_MAX, 0);\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tprintf(\"%d %d\\n\", f, c);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2009-run","published":1,"updated":"2016-06-21T12:24:51.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgb00eaooxla477j5s2"},{"title":"SDOI2008 - ","date":"2016-09-02T13:07:00.000Z","_content":"\nA  $ 5 $  $ S $$ S $ $ S $  \n\n$ 5 $ \n\n1. $ A = A \\cup B $\n2. $ A = A \\cap B $\n3. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} $\n4. $ A = \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n5. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} \\cup \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n\n<!-- more -->\n\n### \n[BZOJ 3226](http://www.lydsy.com/JudgeOnline/problem.php?id=3226)\n\n### \n $ (a, b) $ $ [a + 0.5, b - 0.5] $ $ \\times 2 $ $ [2a + 1, 2b - 1] $\n\n\n\n1.  $ B $  $ 1 $\n2.  $ B $  $ 0 $\n3.  $ B $  $ 0 $\n4.  $ B $  $ 0 $\n5.  $ B $ \n\n $ 0 $  $ 1 $  $ 0 $  $ 1 $ $ 1 $  $ 0 $\n\n $ 0 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 65535;\nconst int MAXM = 70000;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tenum TagType {\n\t\tZero, One, Reverse, None\n\t} tag;\n\tbool val;\n\n\tSegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {}\n\n\tvoid setTag(const TagType t) {\n\t\tif (t == Reverse) {\n\t\t\tif (l == r) val ^= 1;\n\t\t\telse {\n\t\t\t\tif (tag == Reverse) tag = None;\n\t\t\t\telse if (tag == Zero) tag = One;\n\t\t\t\telse if (tag == One) tag = Zero;\n\t\t\t\telse tag = Reverse;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l == r) val = t == One;\n\t\t\telse tag = t;\n\t\t}\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag != None) {\n\t\t\tlc->setTag(tag);\n\t\t\trc->setTag(tag);\n\t\t\ttag = None;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const TagType t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) setTag(t);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, t);\n\t\t\trc->update(l, r, t);\n\t\t}\n\t}\n\n\tbool query(const int pos) {\n\t\tSegmentTree *v = this;\n\t\tbool rev = false;\n\t\twhile (!(v->l == v->r || v->tag == Zero || v->tag == One)) {\n\t\t\tif (v->tag == Reverse) rev ^= 1;\n\t\t\tv = (pos <= v->mid) ? v->lc : v->rc;\n\t\t}\n\t\tif (v->tag == Zero) v->val = false;\n\t\telse if (v->tag == One) v->val = true;\n\t\treturn rev ? v->val ^ 1 : v->val;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, l, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\t/*\n\tstatic bool a[MAXN * 2 + 1];\n\n\tstatic void update(const int l, const int r, const TagType t) {\n\t\tif (l > r) return;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (t == Zero) a[i] = false;\n\t\t\telse if (t == One) a[i] = true;\n\t\t\telse if (t == Reverse) a[i] ^= 1;\n\t\t}\n\t}\n\n\tstatic bool query(const int pos) { return a[pos]; }\n\n\tstatic SegmentTree *build(const int l, const int r) { return NULL; }\n\t*/\n} *segment;\n\n// bool SegmentTree::a[MAXN * 2 + 1];\n\ninline void parse(char *s, int &l, int &r) {\n\tchar ch;\n\tbool fl = false;\n\tch = *s++;\n\tif (ch == '(') fl = true;\n\tl = 0;\n\twhile ((ch = *s++) != ',') l = l * 10 + ch - '0';\n\tl *= 2;\n\tif (fl) l++;\n\tr = 0;\n\twhile ((ch = *s++), (ch >= '0' && ch <= '9')) r = r * 10 + ch - '0';\n\tr *= 2;\n\tif (ch == ')') r--;\n}\n\ninline void print() {\n\tint l = -1;\n\tbool flag = false;\n\tfor (int i = 0; i <= MAXN * 2; i++) {\n\t\tbool val = segment->query(i);\n\t\tif (l == -1 && val) {\n\t\t\tl = i;\n\t\t} else if (l != -1 && !val) {\n\t\t\tprintf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')');\n\t\t\tflag = true;\n\t\t\tl = -1;\n\t\t}\n\t}\n\tif (l != -1) printf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true;\n\tif (!flag) printf(\"empty set\");\n\tputchar('\\n');\n}\n\nint main() {\n\tsegment = SegmentTree::build(0, MAXN * 2);\n\tchar cmd[2], s[100];\n\twhile (~scanf(\"%s %s\", cmd, s)) {\n\t\tint l, r;\n\t\tparse(s, l, r);\n\t\t// printf(\"read: [%d, %d]\\n\", l, r);\n\n\t\tif (cmd[0] == 'U') {\n\t\t\tsegment->update(l, r, SegmentTree::One);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'D') {\n\t\t\tsegment->update(l, r, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tsegment->update(0, MAXN * 2, SegmentTree::Reverse);\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'S') {\n\t\t\tsegment->update(l, r, SegmentTree::Reverse);\n\t\t}\n\n\t\t// print();\n\t}\n\n\tprint();\n\n\treturn 0;\n}\n```","source":"_posts/sdoi2008-interval.md","raw":"title: SDOI2008 - \ndate: 2016-09-02 21:07:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \npermalink: sdoi2008-interval\n---\n\nA  $ 5 $  $ S $$ S $ $ S $  \n\n$ 5 $ \n\n1. $ A = A \\cup B $\n2. $ A = A \\cap B $\n3. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} $\n4. $ A = \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n5. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} \\cup \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n\n<!-- more -->\n\n### \n[BZOJ 3226](http://www.lydsy.com/JudgeOnline/problem.php?id=3226)\n\n### \n $ (a, b) $ $ [a + 0.5, b - 0.5] $ $ \\times 2 $ $ [2a + 1, 2b - 1] $\n\n\n\n1.  $ B $  $ 1 $\n2.  $ B $  $ 0 $\n3.  $ B $  $ 0 $\n4.  $ B $  $ 0 $\n5.  $ B $ \n\n $ 0 $  $ 1 $  $ 0 $  $ 1 $ $ 1 $  $ 0 $\n\n $ 0 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 65535;\nconst int MAXM = 70000;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tenum TagType {\n\t\tZero, One, Reverse, None\n\t} tag;\n\tbool val;\n\n\tSegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {}\n\n\tvoid setTag(const TagType t) {\n\t\tif (t == Reverse) {\n\t\t\tif (l == r) val ^= 1;\n\t\t\telse {\n\t\t\t\tif (tag == Reverse) tag = None;\n\t\t\t\telse if (tag == Zero) tag = One;\n\t\t\t\telse if (tag == One) tag = Zero;\n\t\t\t\telse tag = Reverse;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l == r) val = t == One;\n\t\t\telse tag = t;\n\t\t}\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag != None) {\n\t\t\tlc->setTag(tag);\n\t\t\trc->setTag(tag);\n\t\t\ttag = None;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const TagType t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) setTag(t);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, t);\n\t\t\trc->update(l, r, t);\n\t\t}\n\t}\n\n\tbool query(const int pos) {\n\t\tSegmentTree *v = this;\n\t\tbool rev = false;\n\t\twhile (!(v->l == v->r || v->tag == Zero || v->tag == One)) {\n\t\t\tif (v->tag == Reverse) rev ^= 1;\n\t\t\tv = (pos <= v->mid) ? v->lc : v->rc;\n\t\t}\n\t\tif (v->tag == Zero) v->val = false;\n\t\telse if (v->tag == One) v->val = true;\n\t\treturn rev ? v->val ^ 1 : v->val;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, l, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\t/*\n\tstatic bool a[MAXN * 2 + 1];\n\n\tstatic void update(const int l, const int r, const TagType t) {\n\t\tif (l > r) return;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (t == Zero) a[i] = false;\n\t\t\telse if (t == One) a[i] = true;\n\t\t\telse if (t == Reverse) a[i] ^= 1;\n\t\t}\n\t}\n\n\tstatic bool query(const int pos) { return a[pos]; }\n\n\tstatic SegmentTree *build(const int l, const int r) { return NULL; }\n\t*/\n} *segment;\n\n// bool SegmentTree::a[MAXN * 2 + 1];\n\ninline void parse(char *s, int &l, int &r) {\n\tchar ch;\n\tbool fl = false;\n\tch = *s++;\n\tif (ch == '(') fl = true;\n\tl = 0;\n\twhile ((ch = *s++) != ',') l = l * 10 + ch - '0';\n\tl *= 2;\n\tif (fl) l++;\n\tr = 0;\n\twhile ((ch = *s++), (ch >= '0' && ch <= '9')) r = r * 10 + ch - '0';\n\tr *= 2;\n\tif (ch == ')') r--;\n}\n\ninline void print() {\n\tint l = -1;\n\tbool flag = false;\n\tfor (int i = 0; i <= MAXN * 2; i++) {\n\t\tbool val = segment->query(i);\n\t\tif (l == -1 && val) {\n\t\t\tl = i;\n\t\t} else if (l != -1 && !val) {\n\t\t\tprintf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')');\n\t\t\tflag = true;\n\t\t\tl = -1;\n\t\t}\n\t}\n\tif (l != -1) printf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true;\n\tif (!flag) printf(\"empty set\");\n\tputchar('\\n');\n}\n\nint main() {\n\tsegment = SegmentTree::build(0, MAXN * 2);\n\tchar cmd[2], s[100];\n\twhile (~scanf(\"%s %s\", cmd, s)) {\n\t\tint l, r;\n\t\tparse(s, l, r);\n\t\t// printf(\"read: [%d, %d]\\n\", l, r);\n\n\t\tif (cmd[0] == 'U') {\n\t\t\tsegment->update(l, r, SegmentTree::One);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'D') {\n\t\t\tsegment->update(l, r, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tsegment->update(0, MAXN * 2, SegmentTree::Reverse);\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'S') {\n\t\t\tsegment->update(l, r, SegmentTree::Reverse);\n\t\t}\n\n\t\t// print();\n\t}\n\n\tprint();\n\n\treturn 0;\n}\n```","slug":"sdoi2008-interval","published":1,"updated":"2016-09-02T13:38:18.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rge00ehooxlqzn0kp06"},{"title":"SDOI2008 - Link-Cut Tree","date":"2016-03-15T12:06:34.000Z","_content":"\n $ u $  $ v $  `Connect u v` $ u $  $ v $  `Destroy u v` `Query u v` $ u $  $ v $ \n\n<!-- more -->\n\n### \n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### \n Link-Cut Tree \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/sdoi2008-cave.md","raw":"title: SDOI2008 - Link-Cut Tree \ndate: 2016-03-15 20:06:34\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - CodeVS\n  - \n  - \n  - \n  - Link-Cut Tree\npermalink: sdoi2008-cave\n---\n\n $ u $  $ v $  `Connect u v` $ u $  $ v $  `Destroy u v` `Query u v` $ u $  $ v $ \n\n<!-- more -->\n\n### \n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### \n Link-Cut Tree \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"sdoi2008-cave","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgi00enooxlb04gdz9k"},{"title":"SCOI2015 - set","date":"2016-03-25T00:53:27.000Z","_content":"\n $ A $  $ C $ $ B $\n\n1. $ B_0 = A_0 $\n2.  $ C_x = + $ $ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $\n3.  $ C_x = * $ $ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $\n\n $ A $  $ C $  $ B $  $ B $  $ B_0 $  $ B_0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### \n B $ B_0 = A_0 $ $ B_i $  $ B_{i + 1} $\n\n\n\n `set`  \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-password.md","raw":"title: SCOI2015 - set\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - set\n  - \npermalink: scoi2015-password\ndate: 2016-03-25 08:53:27\n---\n\n $ A $  $ C $ $ B $\n\n1. $ B_0 = A_0 $\n2.  $ C_x = + $ $ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $\n3.  $ C_x = * $ $ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $\n\n $ A $  $ C $  $ B $  $ B $  $ B_0 $  $ B_0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### \n B $ B_0 = A_0 $ $ B_i $  $ B_{i + 1} $\n\n\n\n `set`  \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-password","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgn00eyooxl34o2j4rb"},{"title":"SCOI2015 -  + Link-Cut Tree","date":"2016-03-22T10:09:12.000Z","_content":"\n $ n $  1  $ n - 1 $  1 \n\n\n1.  $ T $ \n2.  $ X $  $ Y $ \n\n 0 1  0 2  1\n\n $ C $ $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### \n Link-Cut Tree \n\n 30 \n\n30 ~ 60  $ C = 0 $ 1 1 \n\n 40  $ C + 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-message.md","raw":"title: SCOI2015 -  + Link-Cut Tree\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - Link-Cut Tree\n  - \n  - \npermalink: scoi2015-message\ndate: 2016-03-22 18:09:12\n---\n\n $ n $  1  $ n - 1 $  1 \n\n\n1.  $ T $ \n2.  $ X $  $ Y $ \n\n 0 1  0 2  1\n\n $ C $ $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### \n Link-Cut Tree \n\n 30 \n\n30 ~ 60  $ C = 0 $ 1 1 \n\n 40  $ C + 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-message","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgu00f8ooxlekr1ehvn"},{"title":"SCOI2015 - ","date":"2016-03-22T09:56:34.000Z","_content":"\n $ N * M $$ N \\leq M $ $ A $ $ N $ $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### \n $ K $  $ N - K + 1 $\n\n $ K $  $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-matrix.md","raw":"title: SCOI2015 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \n  - \n  - Dinic\npermalink: scoi2015-matrix\ndate: 2016-03-22 17:56:34\n---\n\n $ N * M $$ N \\leq M $ $ A $ $ N $ $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### \n $ K $  $ N - K + 1 $\n\n $ K $  $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-matrix","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rgy00fhooxl3k6h71qd"},{"title":"SCOI2015 -  DP","date":"2016-03-23T15:16:05.000Z","_content":"\n $ n $  $ A_i $ $ B_i $ $ 1 $  $ 1 $  $ V $  $ U $  $ V $  $ D_{u, v} $ $ A_v $\n\n<!-- more -->\n\n### \n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### \n $ f_{x, i} $  $ x $  $ i $ \n\n\n $ x $ \n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n DP$ g_{x, i} $  $ x $  $ i $ \n\n $ x $ \n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n\n$ i = 0 $  $ {\\rm dist} $  $ 0 $  $ 0 $\n\n $ g_{1, 0} $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-light.md","raw":"title: SCOI2015 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - DP\n  -  DP\npermalink: scoi2015-light\ndate: 2016-03-23 23:16:05\n---\n\n $ n $  $ A_i $ $ B_i $ $ 1 $  $ 1 $  $ V $  $ U $  $ V $  $ D_{u, v} $ $ A_v $\n\n<!-- more -->\n\n### \n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### \n $ f_{x, i} $  $ x $  $ i $ \n\n\n $ x $ \n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n DP$ g_{x, i} $  $ x $  $ i $ \n\n $ x $ \n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n\n$ i = 0 $  $ {\\rm dist} $  $ 0 $  $ 0 $\n\n $ g_{1, 0} $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-light","published":1,"updated":"2016-10-24T23:31:27.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rh300frooxlgpbhevex"},{"title":"SCOI2015 -  + ","date":"2016-03-22T10:25:14.000Z","_content":"\nA  $ M $  $ 1 $  $ M $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### \n\n\n\n\n40  $ O(n ^ 2) $\n\n70  $ O(n \\log n) $ `std::upper_bound` -1 \n\n100  $ O(n \\log n) $  $ next_{i, j} $  $ i $  $ 2 ^ j $  $ O(\\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-flag.md","raw":"title: SCOI2015 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \npermalink: scoi2015-flag\ndate: 2016-03-22 18:25:14\n---\n\nA  $ M $  $ 1 $  $ M $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### \n\n\n\n\n40  $ O(n ^ 2) $\n\n70  $ O(n \\log n) $ `std::upper_bound` -1 \n\n100  $ O(n \\log n) $  $ next_{i, j} $  $ i $  $ 2 ^ j $  $ O(\\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-flag","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rh800fzooxlezmphpdp"},{"title":"SCOI2012 - AC ","date":"2016-09-29T13:26:00.000Z","_content":"\n $ N $  $ M $ \n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 2754](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n\n### \n AC \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","source":"_posts/scoi2012-name.md","raw":"title: SCOI2012 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - AC \npermalink: scoi2012-name\ndate: 2016-09-29 21:26:00\n---\n\n $ N $  $ M $ \n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 2754](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n\n### \n AC \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","slug":"scoi2012-name","published":1,"updated":"2016-09-29T13:28:38.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhb00g7ooxlkn1pigrh"},{"title":"SCOI2011 -  + ","date":"2016-03-04T13:32:23.000Z","_content":"\n $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### \n\n\n Tarjan  Tarjan\n\n 0 1 1\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2011-candy.md","raw":"title: SCOI2011 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - Tarjan\n  - \n  - \n  - \npermalink: scoi2011-candy\ndate: 2016-03-04 21:32:23\n---\n\n $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### \n\n\n Tarjan  Tarjan\n\n 0 1 1\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","slug":"scoi2011-candy","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhe00gdooxlfqdkhbdw"},{"title":"SCOI2010 - ","date":"2016-03-07T01:43:18.000Z","_content":"\n $ [1, 10000] $   BOSS  $ 1 $  BOSS  $ 1 $  BOSS $ 2 $  BOSS $ 3 $  BOSS   BOSS \n\n<!-- more -->\n\n### \n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### \n $ N  1000000 $ $ O(n) $  $ O(n) $  \n\n\n\n\n\n $ 1 $  $ 1 $  $ X $  $ \\{X, Y\\} $  $ X $ $ Y $ $ Y < X $\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2010-game.md","raw":"title: SCOI2010 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \n  - \npermalink: scoi2010-game\ndate: 2016-03-07 09:43:18\n---\n\n $ [1, 10000] $   BOSS  $ 1 $  BOSS  $ 1 $  BOSS $ 2 $  BOSS $ 3 $  BOSS   BOSS \n\n<!-- more -->\n\n### \n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### \n $ N  1000000 $ $ O(n) $  $ O(n) $  \n\n\n\n\n\n $ 1 $  $ 1 $  $ X $  $ \\{X, Y\\} $  $ X $ $ Y $ $ Y < X $\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","slug":"scoi2010-game","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhn00gnooxl5rbwdn1f"},{"title":"SCOI2009windy  -  DP","date":"2016-05-12T09:25:00.000Z","_content":"\nwindy  windy  $ 2 $  windy \n\nwindy  $ A $  $ B $  $ A $  $ B $ windy \n\n<!-- more -->\n\n### \n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### \n DP\n\n$$ f[n][last][notZero][limited] $$\n\n $ n $  $ n $  $ last $\n\nPS\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","source":"_posts/scoi2009-windy.md","raw":"title: SCOI2009windy  -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  -  DP\n  - DP\npermalink: scoi2009-windy\ndate: 2016-05-12 17:25:00\n---\n\nwindy  windy  $ 2 $  windy \n\nwindy  $ A $  $ B $  $ A $  $ B $ windy \n\n<!-- more -->\n\n### \n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### \n DP\n\n$$ f[n][last][notZero][limited] $$\n\n $ n $  $ n $  $ last $\n\nPS\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","slug":"scoi2009-windy","published":1,"updated":"2016-10-24T23:30:33.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhs00gxooxlkf7c3f5g"},{"title":"SCOI2009 -  DP","date":"2016-07-11T14:59:00.000Z","_content":"\nwindy  $ N $  $ M $   windy  windy  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1296](http://www.lydsy.com/JudgeOnline/problem.php?id=1296)\n\n### \n $ f(j, k) $  $ j $  $ k $ \n\n $ w(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXT = 2500;\n\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\n\tstatic int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tstatic char s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\tint cnt[2] = { 0, 0 };\n\t\t\t\tfor (int l = j - 1; l >= k - 1; l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tf[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1]));\n\t\t\t\t\tw[i][k] = std::max(w[i][k], f[j][k]);\n\t\t\t\t}\n\t\t\t\t// printf(\"f[%d][%d][%d] = %d\\n\", i, j, k, f[j][k]);\n\t\t\t}\n\t\t}\n\n\t\t// for (int j = 1; j <= m; j++) printf(\"w[%d][%d] = %d\\n\", i, j, w[i][j]);\n\t}\n\n\tstatic int g[MAXT + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = t; j >= 0; j--) {\n\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\tif (k <= j) g[j] = std::max(g[j], g[j - k] + w[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[t]);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2009-paint.md","raw":"title: SCOI2009 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - DP\n  -  DP\npermalink: scoi2009-paint\ndate: 2016-07-11 22:59:00\n---\n\nwindy  $ N $  $ M $   windy  windy  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1296](http://www.lydsy.com/JudgeOnline/problem.php?id=1296)\n\n### \n $ f(j, k) $  $ j $  $ k $ \n\n $ w(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXT = 2500;\n\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\n\tstatic int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tstatic char s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\tint cnt[2] = { 0, 0 };\n\t\t\t\tfor (int l = j - 1; l >= k - 1; l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tf[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1]));\n\t\t\t\t\tw[i][k] = std::max(w[i][k], f[j][k]);\n\t\t\t\t}\n\t\t\t\t// printf(\"f[%d][%d][%d] = %d\\n\", i, j, k, f[j][k]);\n\t\t\t}\n\t\t}\n\n\t\t// for (int j = 1; j <= m; j++) printf(\"w[%d][%d] = %d\\n\", i, j, w[i][j]);\n\t}\n\n\tstatic int g[MAXT + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = t; j >= 0; j--) {\n\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\tif (k <= j) g[j] = std::max(g[j], g[j - k] + w[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[t]);\n\n\treturn 0;\n}\n```\n","slug":"scoi2009-paint","published":1,"updated":"2016-10-24T23:30:41.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rhv00h3ooxl3lmr2y96"},{"title":"SCOI2009 -  +  DP","date":"2016-11-13T00:24:00.000Z","_content":"\nwindy  $ 1 $  $ N $  $ N $  $ 1 $  $ N $  windy  $ 1, 2, 3, \\ldots, N $  $ 1, 2, 3, \\ldots, N $\n\n$ 1, 2, 3, 4, 5, 6 $ \n\n$$\n\\begin{cases}\n1 \\rightarrow 2 \\\\\n2 \\rightarrow 3 \\\\\n3 \\rightarrow 1 \\\\\n4 \\rightarrow 5 \\\\\n5 \\rightarrow 4 \\\\\n6 \\rightarrow 6\n\\end{cases}\n$$\n\nwindy \n\n$$\n\\begin{gather}\n1, 2, 3, 4, 5, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 5, 4, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 4, 5, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 5, 4, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 4, 5, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 5, 4, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 4, 5, 6\n\\end{gather}\n$$\n\n $ 1 $  $ N $  $ 7 $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025)\n\n### \n\n\n$$ \\{ x_1, x_2, \\ldots, x_m \\} $$\n\n $ x_k $  $ p $ $ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) $  $ p $  $ x_k $  $ x_i $ \n\n $ x_i $  $ x_i = 1 $ \n\n$$\n\\begin{cases}\nx_1 = p_1 ^ {k_1} \\\\\nx_2 = p_2 ^ {k_2} \\\\\n\\cdots \\\\\nx_m = p_m ^ {k_m}\n\\end{cases}\n$$\n\n$ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) = x_1 \\times x_2 \\times \\ldots \\times x_m $ $ \\{ x_1. x_2, \\ldots, x_m \\} $  $ x_1 + x_2 + \\ldots + x_m = n $ $ 1 $  $ x_1 + x_2 + \\ldots + x_m \\leq n $ \n\n $ p_i $ $ p_i ^ {k_i} $ $ \\leq n $   $ i $  $ p_i ^ 1, p_i ^ 2, \\ldots p_i ^ {k_i} $$ p_i ^ {k_i} \\leq n $ $ n $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\n\nint primes[MAXN], isNotPrime[MAXN + 1], cnt;\n\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * primes[j] <= MAXN; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n\t// for (int i = 0; i < cnt; i++) printf(\"%d\\n\", primes[i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tgetPrimes();\n\n\tstatic long long f[MAXN + 1][MAXN + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int k = 0; k <= n; k++) f[i][k] = f[i - 1][k];\n\t\tfor (int p = primes[i]; p <= n; p *= primes[i]) {\n\t\t\tfor (int k = p; k <= n; k++) {\n\t\t\t\tf[i][k] += f[i - 1][k - p];\n\t\t\t}\n\t\t}\n\t\t// for (int k = 0; k <= n; k++) printf(\"f[%d][%d] = %d\\n\", i, k, f[i][k]);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) ans += f[cnt][i];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2009-game.md","raw":"title: SCOI2009 -  +  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  -  DP\n  - DP\npermalink: scoi2009-game\ndate: 2016-11-13 08:24:00\n---\n\nwindy  $ 1 $  $ N $  $ N $  $ 1 $  $ N $  windy  $ 1, 2, 3, \\ldots, N $  $ 1, 2, 3, \\ldots, N $\n\n$ 1, 2, 3, 4, 5, 6 $ \n\n$$\n\\begin{cases}\n1 \\rightarrow 2 \\\\\n2 \\rightarrow 3 \\\\\n3 \\rightarrow 1 \\\\\n4 \\rightarrow 5 \\\\\n5 \\rightarrow 4 \\\\\n6 \\rightarrow 6\n\\end{cases}\n$$\n\nwindy \n\n$$\n\\begin{gather}\n1, 2, 3, 4, 5, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 5, 4, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 4, 5, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 5, 4, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 4, 5, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 5, 4, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 4, 5, 6\n\\end{gather}\n$$\n\n $ 1 $  $ N $  $ 7 $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025)\n\n### \n\n\n$$ \\{ x_1, x_2, \\ldots, x_m \\} $$\n\n $ x_k $  $ p $ $ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) $  $ p $  $ x_k $  $ x_i $ \n\n $ x_i $  $ x_i = 1 $ \n\n$$\n\\begin{cases}\nx_1 = p_1 ^ {k_1} \\\\\nx_2 = p_2 ^ {k_2} \\\\\n\\cdots \\\\\nx_m = p_m ^ {k_m}\n\\end{cases}\n$$\n\n$ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) = x_1 \\times x_2 \\times \\ldots \\times x_m $ $ \\{ x_1. x_2, \\ldots, x_m \\} $  $ x_1 + x_2 + \\ldots + x_m = n $ $ 1 $  $ x_1 + x_2 + \\ldots + x_m \\leq n $ \n\n $ p_i $ $ p_i ^ {k_i} $ $ \\leq n $   $ i $  $ p_i ^ 1, p_i ^ 2, \\ldots p_i ^ {k_i} $$ p_i ^ {k_i} \\leq n $ $ n $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\n\nint primes[MAXN], isNotPrime[MAXN + 1], cnt;\n\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * primes[j] <= MAXN; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n\t// for (int i = 0; i < cnt; i++) printf(\"%d\\n\", primes[i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tgetPrimes();\n\n\tstatic long long f[MAXN + 1][MAXN + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int k = 0; k <= n; k++) f[i][k] = f[i - 1][k];\n\t\tfor (int p = primes[i]; p <= n; p *= primes[i]) {\n\t\t\tfor (int k = p; k <= n; k++) {\n\t\t\t\tf[i][k] += f[i - 1][k - p];\n\t\t\t}\n\t\t}\n\t\t// for (int k = 0; k <= n; k++) printf(\"f[%d][%d] = %d\\n\", i, k, f[i][k]);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) ans += f[cnt][i];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"scoi2009-game","published":1,"updated":"2016-11-13T00:47:58.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ri000h9ooxloxq9cuyx"},{"title":"SCOI2009 - ","date":"2016-11-12T13:17:00.000Z","_content":"\nwindy  $ X $  $ Y $  windy $ N $ windy  $ N $ windy  $ N - 1 $  $ N $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024)\n\n### \n**** $ k \\over n $ $ k $ \n\nDFS \n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 10;\n\ndouble dfs(const int n, const double x, const double y) {\n\tif (n == 1) {\n\t\treturn std::max(x, y) / std::min(x, y);\n\t}\n\n\tdouble res1 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y)));\n\t}\n\n\tdouble res2 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n)));\n\t}\n\n\treturn std::min(res1, res2);\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(n, x, y));\n\treturn 0;\n}\n```","source":"_posts/scoi2009-cake.md","raw":"title: SCOI2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - DFS\npermalink: scoi2009-cake\ndate: 2016-11-12 21:17:00\n---\n\nwindy  $ X $  $ Y $  windy $ N $ windy  $ N $ windy  $ N - 1 $  $ N $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024)\n\n### \n**** $ k \\over n $ $ k $ \n\nDFS \n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 10;\n\ndouble dfs(const int n, const double x, const double y) {\n\tif (n == 1) {\n\t\treturn std::max(x, y) / std::min(x, y);\n\t}\n\n\tdouble res1 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y)));\n\t}\n\n\tdouble res2 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n)));\n\t}\n\n\treturn std::min(res1, res2);\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(n, x, y));\n\treturn 0;\n}\n```","slug":"scoi2009-cake","published":1,"updated":"2016-11-12T13:17:41.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ri400hiooxlr5ux6do7"},{"title":"SCOI2007 - ","date":"2016-03-09T01:52:35.000Z","_content":"\n $ N $  $ M $  $ M $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### \n****\n\n $ i $  $ j $  $ t_{i, j} $ $ i $  $ v_i $ $ i $  $ k $  $ k $  $ v_{j, k} $$ k {\\in} [1, n] $\n\n 1 0 $ v_i $  $ v_{j, k} $  1 $ t_{i, j} * k $ $ v_{j, k} $  1 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### \n $ n $$ m $  \n\n EK  \n\nhehe\n","source":"_posts/scoi2007-repair.md","raw":"title: SCOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - SCOI\n  - \n  - \n  - \n  - Edmonds-Karp\npermalink: scoi2007-repair\ndate: 2016-03-09 09:52:35\n---\n\n $ N $  $ M $  $ M $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### \n****\n\n $ i $  $ j $  $ t_{i, j} $ $ i $  $ v_i $ $ i $  $ k $  $ k $  $ v_{j, k} $$ k {\\in} [1, n] $\n\n 1 0 $ v_i $  $ v_{j, k} $  1 $ t_{i, j} * k $ $ v_{j, k} $  1 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### \n $ n $$ m $  \n\n EK  \n\nhehe\n","slug":"scoi2007-repair","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ri800hqooxl0br8tnkk"},{"title":"SCOI2007 - ","date":"2016-09-03T13:47:00.000Z","_content":"\n $ r $  $ c $ \n\n $ 1 $ $ d $**** $ d $ \n\n $ 1 $ $ 1 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1066](http://www.lydsy.com/JudgeOnline/problem.php?id=1066)\n\n### \n $ d $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXD = 4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"addEdge(%d, %d, %d)\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j, const int l) {\n\treturn l * n * m + i * m + j + 1;\n}\n\nint main() {\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &d);\n\n\t/*\n\tprintf(\"%d -> %d\\n\", id(2, 2, 1), id(2, 2, 0));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 0), id(2, 2, 2));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 2), id(2, 1, 1));\n\tprintf(\"%d -> %d\\n\", id(2, 1, 1), id(3, 1, 0));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 0), id(3, 1, 2));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 2), id(3, 0, 1));\n\t*/\n\t/*\n\tfor (int h = 0; h <= d; h++) for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%d\\n\", id(i, j, h));\n\tprintf(\"t = %d\\n\", n * m * (d + 1) + 1);\n\treturn 0;\n\t*/\n\n\tconst int s = 0, t = n * m * 2 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\taddEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0');\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\tif (abs(i - k) + abs(j - l) <= d) {\n\t\t\t\t\t\taddEdge(id(i, j, 1), id(k, l, 0), INT_MAX);\n\t\t\t\t\t\taddEdge(id(k, l, 1), id(i, j, 0), INT_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < d || i > n - d - 1 || j < d || j > m - d - 1) addEdge(id(i, j, 1), t, INT_MAX);\n\t\t}\n\t}\n\n\tint ans = dinic(s, t, n * m * 2 + 2);\n\tprintf(\"%d\\n\", cnt - ans);\n\n\treturn 0;\n}\n```","source":"_posts/scoi2007-lizard.md","raw":"title: SCOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - Dinic\npermalink: scoi2007-lizard\ndate: 2016-09-03 21:47:00\n---\n\n $ r $  $ c $ \n\n $ 1 $ $ d $**** $ d $ \n\n $ 1 $ $ 1 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1066](http://www.lydsy.com/JudgeOnline/problem.php?id=1066)\n\n### \n $ d $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXD = 4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"addEdge(%d, %d, %d)\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j, const int l) {\n\treturn l * n * m + i * m + j + 1;\n}\n\nint main() {\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &d);\n\n\t/*\n\tprintf(\"%d -> %d\\n\", id(2, 2, 1), id(2, 2, 0));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 0), id(2, 2, 2));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 2), id(2, 1, 1));\n\tprintf(\"%d -> %d\\n\", id(2, 1, 1), id(3, 1, 0));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 0), id(3, 1, 2));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 2), id(3, 0, 1));\n\t*/\n\t/*\n\tfor (int h = 0; h <= d; h++) for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%d\\n\", id(i, j, h));\n\tprintf(\"t = %d\\n\", n * m * (d + 1) + 1);\n\treturn 0;\n\t*/\n\n\tconst int s = 0, t = n * m * 2 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\taddEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0');\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\tif (abs(i - k) + abs(j - l) <= d) {\n\t\t\t\t\t\taddEdge(id(i, j, 1), id(k, l, 0), INT_MAX);\n\t\t\t\t\t\taddEdge(id(k, l, 1), id(i, j, 0), INT_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < d || i > n - d - 1 || j < d || j > m - d - 1) addEdge(id(i, j, 1), t, INT_MAX);\n\t\t}\n\t}\n\n\tint ans = dinic(s, t, n * m * 2 + 2);\n\tprintf(\"%d\\n\", cnt - ans);\n\n\treturn 0;\n}\n```","slug":"scoi2007-lizard","published":1,"updated":"2016-09-03T13:51:23.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ric00hzooxlglirxi4t"},{"title":"SCOI2005 - ","date":"2016-12-30T03:10:00.000Z","_content":"\n $ n $  $ 1 \\ldots n $\n\n $ B $  $ 3B $ \n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1086](http://www.lydsy.com/JudgeOnline/problem.php?id=1086)\n\n### \nDFS \n\n $ u $  $ v $ $ S $  $ B $ $ S $  $ u $  $ S $ \n\n $ u $  $ S $ $ S $ $ S $  $ B $$ B - 1 $  $ u $ \n\n DFS  $ 2B - 1 $\n\nDFS  $ S $  $ B $ DFS  $ 3B - 1 $\n\n $ S $ ******** $ S $\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 1000;\n\nstruct Node {\n\tstruct Edge *e;\n\tstruct Block *block;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Block {\n\tNode *top;\n} blocks[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, b, blockCount;\nstd::stack<Node *> s;\n\ninline void dfs(Node *v, Node *fa) {\n\tsize_t status = s.size();\n\n\tfor (Edge *e = v->e; e; e = e->next) {\n\t\tif (e->t != fa) {\n\t\t\tdfs(e->t, v);\n\n\t\t\tif (int(s.size() - status) >= b) {\n\t\t\t\tblocks[++blockCount].top = v;\n\t\t\t\twhile (s.size() != status) {\n\t\t\t\t\tNode *u = s.top();\n\t\t\t\t\ts.pop();\n\t\t\t\t\tu->block = &blocks[blockCount];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ts.push(v);\n}\n\ninline void solve() {\n\tdfs(&N[1], NULL);\n\twhile (!s.empty()) {\n\t\tNode *u = s.top();\n\t\ts.pop();\n\t\tu->block = &blocks[blockCount];\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &b);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsolve();\n\n\tprintf(\"%d\\n\", blockCount);\n\tfor (int i = 1; i <= n; i++) printf(\"%lu%c\", N[i].block - blocks, i == n ? '\\n' : ' ');\n\tfor (int i = 1; i <= blockCount; i++) printf(\"%lu%c\", blocks[i].top - N, i == blockCount ? '\\n' : ' ');\n\n\treturn 0;\n}\n```","source":"_posts/scoi2005-royal.md","raw":"title: SCOI2005 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \npermalink: scoi2005-royal\ndate: 2016-12-30 11:10:00\n---\n\n $ n $  $ 1 \\ldots n $\n\n $ B $  $ 3B $ \n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1086](http://www.lydsy.com/JudgeOnline/problem.php?id=1086)\n\n### \nDFS \n\n $ u $  $ v $ $ S $  $ B $ $ S $  $ u $  $ S $ \n\n $ u $  $ S $ $ S $ $ S $  $ B $$ B - 1 $  $ u $ \n\n DFS  $ 2B - 1 $\n\nDFS  $ S $  $ B $ DFS  $ 3B - 1 $\n\n $ S $ ******** $ S $\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 1000;\n\nstruct Node {\n\tstruct Edge *e;\n\tstruct Block *block;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Block {\n\tNode *top;\n} blocks[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, b, blockCount;\nstd::stack<Node *> s;\n\ninline void dfs(Node *v, Node *fa) {\n\tsize_t status = s.size();\n\n\tfor (Edge *e = v->e; e; e = e->next) {\n\t\tif (e->t != fa) {\n\t\t\tdfs(e->t, v);\n\n\t\t\tif (int(s.size() - status) >= b) {\n\t\t\t\tblocks[++blockCount].top = v;\n\t\t\t\twhile (s.size() != status) {\n\t\t\t\t\tNode *u = s.top();\n\t\t\t\t\ts.pop();\n\t\t\t\t\tu->block = &blocks[blockCount];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ts.push(v);\n}\n\ninline void solve() {\n\tdfs(&N[1], NULL);\n\twhile (!s.empty()) {\n\t\tNode *u = s.top();\n\t\ts.pop();\n\t\tu->block = &blocks[blockCount];\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &b);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsolve();\n\n\tprintf(\"%d\\n\", blockCount);\n\tfor (int i = 1; i <= n; i++) printf(\"%lu%c\", N[i].block - blocks, i == n ? '\\n' : ' ');\n\tfor (int i = 1; i <= blockCount; i++) printf(\"%lu%c\", blocks[i].top - N, i == blockCount ? '\\n' : ' ');\n\n\treturn 0;\n}\n```","slug":"scoi2005-royal","published":1,"updated":"2016-12-30T03:33:44.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rif00i5ooxl84oy73ga"},{"title":"SCOI2003 -  DP","date":"2016-07-06T03:54:00.000Z","_content":"\n\n\n1. \n2. $ X(S) $  $ X(X > 1) $  $ S $ \n3.  $ A $  $ A $ $ B $  $ B $  $ AB $  $ AB $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1090](http://www.lydsy.com/JudgeOnline/problem.php?id=1090)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n\n\n1.  $ r - l + 1 $\n2. \n3. \n4. \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nint n;\nchar s[MAXN + 1];\n\ninline int numberLength(int x) {\n\tint res = 0;\n\tdo res++; while (x /= 10);\n\treturn res;\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1;\n\telse if (l > r) return ans = 0;\n\n\tans = r - l + 1;\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(l, l + i - 1);\n\t\tint pos = l + i, cnt = 1;\n\t\twhile (pos + i - 1 <= r && strncmp(s + l, s + pos, i) == 0) pos += i, cnt++;\n\t\tans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(r - i + 1, r);\n\t\tint pos = r - i - i + 1, cnt = 1;\n\t\twhile (pos >= l && strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++;\n\t\tans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1 - 1; i++) {\n\t\tans = std::min(ans, dp(l, i) + dp(i + 1, r));\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tprintf(\"%d\\n\", dp(0, n - 1));\n\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/scoi2003-fold.md","raw":"title: SCOI2003 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - DP\n  -  DP\npermalink: scoi2003-fold\ndate: 2016-07-06 11:54:00\n---\n\n\n\n1. \n2. $ X(S) $  $ X(X > 1) $  $ S $ \n3.  $ A $  $ A $ $ B $  $ B $  $ AB $  $ AB $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1090](http://www.lydsy.com/JudgeOnline/problem.php?id=1090)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n\n\n1.  $ r - l + 1 $\n2. \n3. \n4. \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nint n;\nchar s[MAXN + 1];\n\ninline int numberLength(int x) {\n\tint res = 0;\n\tdo res++; while (x /= 10);\n\treturn res;\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1;\n\telse if (l > r) return ans = 0;\n\n\tans = r - l + 1;\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(l, l + i - 1);\n\t\tint pos = l + i, cnt = 1;\n\t\twhile (pos + i - 1 <= r && strncmp(s + l, s + pos, i) == 0) pos += i, cnt++;\n\t\tans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(r - i + 1, r);\n\t\tint pos = r - i - i + 1, cnt = 1;\n\t\twhile (pos >= l && strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++;\n\t\tans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1 - 1; i++) {\n\t\tans = std::min(ans, dp(l, i) + dp(i + 1, r));\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tprintf(\"%d\\n\", dp(0, n - 1));\n\n\treturn 0;\n}\n```\n\n\n\n","slug":"scoi2003-fold","published":1,"updated":"2016-10-24T23:31:18.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rik00ieooxlposk45jc"},{"title":"RMQ ","date":"2016-12-30T01:18:00.000Z","_content":"\nRMQ Sparse Table\n\n![zyz ](images/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\n\nint n, a[MAXN + 1], st[MAXN + 1][MAXN_LOG + 1], logx[MAXN + 1]; //  log\n\ninline void sparseTable()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint t = 0;\n\t\twhile ((1 << (t + 1)) <= i) t++;\n\t\tlogx[i] = t;\n\t}\n\n\tfor (int i = 1; i <= n; i++) st[i][0] = a[i]; //  2 ^ 0 = 1 \n\n\tfor (int j = 1; j <= logx[n]; j++)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\t// \n\t\t\tif (i + (1 << (j - 1)) <= n) st[i][j] = std::max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n}\n\ninline int rmq(int l, int r)\n{\n\tint t = logx[r - l];\n\treturn std::max(st[l][t], st[r - (1 << t) + 1][t]); // \n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tprintf(\"%d\\n\", rmq(l, r));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/rmq-template.md","raw":"title: RMQ \ncategories: OI\ntags: \n  - RMQ\n  - \n  - \npermalink: rmq-template\ndate: 2016-12-30 09:18:00\n---\n\nRMQ Sparse Table\n\n![zyz ](images/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\n\nint n, a[MAXN + 1], st[MAXN + 1][MAXN_LOG + 1], logx[MAXN + 1]; //  log\n\ninline void sparseTable()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint t = 0;\n\t\twhile ((1 << (t + 1)) <= i) t++;\n\t\tlogx[i] = t;\n\t}\n\n\tfor (int i = 1; i <= n; i++) st[i][0] = a[i]; //  2 ^ 0 = 1 \n\n\tfor (int j = 1; j <= logx[n]; j++)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\t// \n\t\t\tif (i + (1 << (j - 1)) <= n) st[i][j] = std::max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n}\n\ninline int rmq(int l, int r)\n{\n\tint t = logx[r - l];\n\treturn std::max(st[l][t], st[r - (1 << t) + 1][t]); // \n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tprintf(\"%d\\n\", rmq(l, r));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"rmq-template","published":1,"updated":"2017-01-01T01:45:57.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rio00ikooxllp2j80bd"},{"title":"POJ 3630Phone List - Trie","date":"2017-01-02T03:05:00.000Z","_content":"\n $ n $ \n\n<!-- more -->\n\n### \n[POJ 3630](http://poj.org/problem?id=3630)\n\n### \n Trie\n\n\n\n\n\n TLE\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int MAXN = 10000;\n\nstruct Node {\n\tNode *ch[10];\n\tbool isWord;\n\n\tNode(bool isWord = false) : isWord(isWord) {\n\t\tfor (int i = 0; i < 10; i++) ch[i] = NULL;\n\t}\n} *root, _pool[MAXN * 10], *_curr;\n\nbool insert(char *begin, char *end) {\n\tNode **v = &root;\n\tbool res = false;\n\tfor (char *p = begin; p != end; p++) {\n\t\tif (!*v) *v = new (_curr++) Node(false);\n\t\telse if ((*v)->isWord) res = true;\n\n\t\tv = &(*v)->ch[*p];\n\t}\n\tif (!*v) *v = new (_curr++) Node(true);\n\telse res = true;\n\n\treturn res;\n}\n\nvoid init() {\n\troot = NULL;\n\t_curr = _pool;\n}\n\nint main() {\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tinit();\n\n\t\tbool ans = false;\n\t\twhile (n--) {\n\t\t\tstatic char s[10 + 2];\n\t\t\tscanf(\"%s\", s + 1);\n\n\t\t\tint len = strlen(s + 1);\n\t\t\tfor (int i = 1; i <= len; i++) s[i] -= '0';\n\n\t\t\tif (insert(s + 1, s + len + 1)) ans = true;\n\t\t}\n\n\t\tputs(ans ? \"NO\" : \"YES\");\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-3630.md","raw":"title: POJ 3630Phone List - Trie\ncategories: OI\ntags: \n  - POJ\n  - Trie\n  - \npermalink: poj-3630\ndate: 2017-01-02 11:05:00\n---\n\n $ n $ \n\n<!-- more -->\n\n### \n[POJ 3630](http://poj.org/problem?id=3630)\n\n### \n Trie\n\n\n\n\n\n TLE\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int MAXN = 10000;\n\nstruct Node {\n\tNode *ch[10];\n\tbool isWord;\n\n\tNode(bool isWord = false) : isWord(isWord) {\n\t\tfor (int i = 0; i < 10; i++) ch[i] = NULL;\n\t}\n} *root, _pool[MAXN * 10], *_curr;\n\nbool insert(char *begin, char *end) {\n\tNode **v = &root;\n\tbool res = false;\n\tfor (char *p = begin; p != end; p++) {\n\t\tif (!*v) *v = new (_curr++) Node(false);\n\t\telse if ((*v)->isWord) res = true;\n\n\t\tv = &(*v)->ch[*p];\n\t}\n\tif (!*v) *v = new (_curr++) Node(true);\n\telse res = true;\n\n\treturn res;\n}\n\nvoid init() {\n\troot = NULL;\n\t_curr = _pool;\n}\n\nint main() {\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tinit();\n\n\t\tbool ans = false;\n\t\twhile (n--) {\n\t\t\tstatic char s[10 + 2];\n\t\t\tscanf(\"%s\", s + 1);\n\n\t\t\tint len = strlen(s + 1);\n\t\t\tfor (int i = 1; i <= len; i++) s[i] -= '0';\n\n\t\t\tif (insert(s + 1, s + len + 1)) ans = true;\n\t\t}\n\n\t\tputs(ans ? \"NO\" : \"YES\");\n\t}\n\n\treturn 0;\n}\n```\n","slug":"poj-3630","published":1,"updated":"2017-01-02T03:10:17.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rir00ipooxlk35f67ay"},{"title":"POJ 3461Oulipo - KMP","date":"2016-04-09T13:36:23.000Z","_content":"\n\n\n<!-- more -->\n\n### \nKMP  \n\n `next`  `char`  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/poj-3461.md","raw":"title: POJ 3461Oulipo - KMP\ncategories: OI\ntags: \n  - POJ\n  - KMP\n  - \n  - \npermalink: poj-3461\ndate: 2016-04-09 21:36:23\n---\n\n\n\n<!-- more -->\n\n### \nKMP  \n\n `next`  `char`  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","slug":"poj-3461","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9riw00iwooxlq7cnrzba"},{"title":"POJ 2728Desert King - 01 ","date":"2016-03-11T01:33:14.000Z","_content":"\n $ N $  $ (x, y) $  $ z $ $ N $ \n\n<!-- more -->\n\n### \n[POJ 2728](http://poj.org/problem?id=2728)\n\n### \n01   Orz\n\nPS WA  TLE G++  VC++  AC  \n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-2728.md","raw":"title: POJ 2728Desert King - 01 \ncategories: OI\ntags: \n  - POJ\n  - Prim\n  - \n  - \n  - \n  - \npermalink: poj-2728\ndate: 2016-03-11 09:33:14\n---\n\n $ N $  $ (x, y) $  $ z $ $ N $ \n\n<!-- more -->\n\n### \n[POJ 2728](http://poj.org/problem?id=2728)\n\n### \n01   Orz\n\nPS WA  TLE G++  VC++  AC  \n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","slug":"poj-2728","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rj000j3ooxl2ngxiemi"},{"title":"POJ 1737Connected Graph -  +  + ","date":"2016-03-14T04:12:45.000Z","_content":"\n $ N $$ N \\leq 50 $\n\n<!-- more -->\n\n### \n[POJ 1737](http://poj.org/problem?id=1737)\n\n### \n N  N **** $ \\frac{N(N - 1)}{2} $  $ 2 ^ {\\frac{N(N - 1)}{2}} $ \n\n $ N $  $ v $ $ K $$ 1 \\leq K \\leq N - 1 $**** $ v $  $ K - 1 $  $ \\binom{N - 1}{K - 1} $**** $ N - K $ \n\n $ n $  $ f(n) $ $ g(n) $ $ h(n) $ $ f(n) $ \n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-1737.md","raw":"title: POJ 1737Connected Graph -  +  + \ncategories: OI\ntags: \n  - POJ\n  - \n  - \n  - \n  - \n  - \npermalink: poj-1737\ndate: 2016-03-14 12:12:45\n---\n\n $ N $$ N \\leq 50 $\n\n<!-- more -->\n\n### \n[POJ 1737](http://poj.org/problem?id=1737)\n\n### \n N  N **** $ \\frac{N(N - 1)}{2} $  $ 2 ^ {\\frac{N(N - 1)}{2}} $ \n\n $ N $  $ v $ $ K $$ 1 \\leq K \\leq N - 1 $**** $ v $  $ K - 1 $  $ \\binom{N - 1}{K - 1} $**** $ N - K $ \n\n $ n $  $ f(n) $ $ g(n) $ $ h(n) $ $ f(n) $ \n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"poj-1737","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rj600jeooxll009vlfm"},{"title":"POI2008BLO - ","date":"2016-09-08T10:37:00.000Z","_content":"\nByteotia  $ n $  towns$ m $  roads road  towns road towns \n\n******** $ (u, v) $ \n\n<!-- more -->\n\n### \n[BZOJ 1123](http://www.lydsy.com/JudgeOnline/problem.php?id=1123)\n\n### \n $ 2 \\times (n - 1) $\n\n\n\nDFS  DFS  $ u $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $  $ v $  $ u $ \n\n $ x_1, x_2, \\ldots, x_k $$ s = \\sum\\limits_{i = 1} ^ k x_i $\n\n$$\n\\begin{aligned}\n& x_1x_2 + x_1x_3 + \\ldots + x_1x_k + \\ldots + x_kx_{k - 1} \\\\\n= & x_1(x_2 + x_3 + \\ldots + x_k) + x_2(x_1 + x_3 + \\ldots + x_k) + \\ldots + x_k(x_1 + x_2 + \\ldots + x_{k - 1}) \\\\\n= & \\sum\\limits_{i = 1} ^ k x_i \\times (s - x_i)\n\\end{aligned}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low, size;\n\tlong long ans;\n\tbool flag, pushed, v;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline long long calc(const std::vector<long long> &vec) {\n\tlong long s = 0, ans = 0;\n\tfor (size_t i = 0; i < vec.size(); i++) s += vec[i];\n\tfor (size_t i = 0; i < vec.size(); i++) ans += (s - vec[i]) * vec[i];\n\treturn ans;\n}\n\ninline void tarjan() {\n\tint ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::stack<Node *> s;\n\t\tN[i].pushed = true;\n\t\ts.push(&N[i]);\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\t\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->size = 1;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tstd::vector<long long> vec;\n\t\t\t\tif (v != &N[i]) {\n\t\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\t\tif (e->t->p != v) continue;\n\t\t\t\t\t\tif (e->t->low >= v->dfn) {\n\t\t\t\t\t\t\tv->flag = true;\n\t\t\t\t\t\t\tvec.push_back(e->t->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->size += e->t->size;\n\t\t\t\t\t}\n\t\t\t\t\tint t = n - 1;\n\t\t\t\t\tfor (size_t i = 0; i < vec.size(); i++) t -= vec[i];\n\t\t\t\t\tvec.push_back(t);\n\t\t\t\t\tif (v->flag) v->ans = calc(vec);\n\t\t\t\t\t// if (v->flag) printf(\"tarjan(): found %lu\\n\", v - N + 1);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<long long> vec;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) vec.push_back(e->t->size);\n\t\tif (vec.size() >= 2) N[i].ans = calc(vec), N[i].flag = true;\n\t\t// if (N[i].flag) printf(\"tarjan(): found %d\\n\", i + 1);\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\ttarjan();\n\n\tfor (int i = 0; i < n; i++) printf(\"%lld\\n\", N[i].ans + (n - 1) * 2);\n\n\treturn 0;\n}\n```","source":"_posts/poi2008-blo.md","raw":"title: POI2008BLO - \ncategories: OI\ntags: \n  - BZOJ\n  - POI\n  - Tarjan\n  - \n  - \npermalink: poi2008-blo\ndate: 2016-09-08 18:37:00\n---\n\nByteotia  $ n $  towns$ m $  roads road  towns road towns \n\n******** $ (u, v) $ \n\n<!-- more -->\n\n### \n[BZOJ 1123](http://www.lydsy.com/JudgeOnline/problem.php?id=1123)\n\n### \n $ 2 \\times (n - 1) $\n\n\n\nDFS  DFS  $ u $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $  $ v $  $ u $ \n\n $ x_1, x_2, \\ldots, x_k $$ s = \\sum\\limits_{i = 1} ^ k x_i $\n\n$$\n\\begin{aligned}\n& x_1x_2 + x_1x_3 + \\ldots + x_1x_k + \\ldots + x_kx_{k - 1} \\\\\n= & x_1(x_2 + x_3 + \\ldots + x_k) + x_2(x_1 + x_3 + \\ldots + x_k) + \\ldots + x_k(x_1 + x_2 + \\ldots + x_{k - 1}) \\\\\n= & \\sum\\limits_{i = 1} ^ k x_i \\times (s - x_i)\n\\end{aligned}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low, size;\n\tlong long ans;\n\tbool flag, pushed, v;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline long long calc(const std::vector<long long> &vec) {\n\tlong long s = 0, ans = 0;\n\tfor (size_t i = 0; i < vec.size(); i++) s += vec[i];\n\tfor (size_t i = 0; i < vec.size(); i++) ans += (s - vec[i]) * vec[i];\n\treturn ans;\n}\n\ninline void tarjan() {\n\tint ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::stack<Node *> s;\n\t\tN[i].pushed = true;\n\t\ts.push(&N[i]);\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\t\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->size = 1;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tstd::vector<long long> vec;\n\t\t\t\tif (v != &N[i]) {\n\t\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\t\tif (e->t->p != v) continue;\n\t\t\t\t\t\tif (e->t->low >= v->dfn) {\n\t\t\t\t\t\t\tv->flag = true;\n\t\t\t\t\t\t\tvec.push_back(e->t->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->size += e->t->size;\n\t\t\t\t\t}\n\t\t\t\t\tint t = n - 1;\n\t\t\t\t\tfor (size_t i = 0; i < vec.size(); i++) t -= vec[i];\n\t\t\t\t\tvec.push_back(t);\n\t\t\t\t\tif (v->flag) v->ans = calc(vec);\n\t\t\t\t\t// if (v->flag) printf(\"tarjan(): found %lu\\n\", v - N + 1);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<long long> vec;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) vec.push_back(e->t->size);\n\t\tif (vec.size() >= 2) N[i].ans = calc(vec), N[i].flag = true;\n\t\t// if (N[i].flag) printf(\"tarjan(): found %d\\n\", i + 1);\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\ttarjan();\n\n\tfor (int i = 0; i < n; i++) printf(\"%lld\\n\", N[i].ans + (n - 1) * 2);\n\n\treturn 0;\n}\n```","slug":"poi2008-blo","published":1,"updated":"2016-09-08T10:58:08.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rj900jmooxls9vrr6cg"},{"title":"POI2006Szk-Schools - ","date":"2016-06-22T10:20:00.000Z","_content":"\n $ n $  $ a_i $ $ [1,\\ n] $  $ n $ \n\n1. $ a_i $  $ [l_i,\\ r_i] $ \n2. $ a_i $  $ x $  $ k \\times | a_i - x | $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1520](http://www.lydsy.com/JudgeOnline/problem.php?id=1520)\n\n### \n $ i $  $ [l_i,\\ r_i] $  $ 1 $\n\n $ 1 $ $ 1 $\n\n $ n $ \n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint d, f;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint m, l, r, k;\n\t\tscanf(\"%d %d %d %d\", &m, &l, &r, &k);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\n\t\tfor (int j = l; j <= r; j++) {\n\t\t\taddEdge(i, n + j, 1, k * abs(j - m));\n\t\t}\n\t}\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tif (f != n) puts(\"NIE\");\n\telse printf(\"%d\\n\", c);\n\n\treturn 0;\n}\n```\n","source":"_posts/poi2006-szk.md","raw":"title: POI2006Szk-Schools - \ndate: 2016-06-22 18:20:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - \n  - Edmonds-Karp\npermalink: poi2006-szk\n---\n\n $ n $  $ a_i $ $ [1,\\ n] $  $ n $ \n\n1. $ a_i $  $ [l_i,\\ r_i] $ \n2. $ a_i $  $ x $  $ k \\times | a_i - x | $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1520](http://www.lydsy.com/JudgeOnline/problem.php?id=1520)\n\n### \n $ i $  $ [l_i,\\ r_i] $  $ 1 $\n\n $ 1 $ $ 1 $\n\n $ n $ \n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint d, f;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint m, l, r, k;\n\t\tscanf(\"%d %d %d %d\", &m, &l, &r, &k);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\n\t\tfor (int j = l; j <= r; j++) {\n\t\t\taddEdge(i, n + j, 1, k * abs(j - m));\n\t\t}\n\t}\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tif (f != n) puts(\"NIE\");\n\telse printf(\"%d\\n\", c);\n\n\treturn 0;\n}\n```\n","slug":"poi2006-szk","published":1,"updated":"2016-06-22T10:20:59.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rjd00juooxlptjla394"},{"title":"POI2005Kos-Dicing -  + ","date":"2016-06-22T10:25:00.000Z","_content":"\nDicing \n\n<!-- more -->\n\n### \n[BZOJ 1532](http://www.lydsy.com/JudgeOnline/problem.php?id=1532)\n\n### \n $ x $ $ x $ $ 1 $ $ 1 $ $ m $ \n\n $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c > e->f) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c > e->f) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\t// printf(\"dinic() = %d\\n\", res);\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\nEdge *E[MAXN];\n\ninline void reset(const int c) {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tif (i < n) E[i]->c = c;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n\t}\n}\n\ninline int solve(const int s, const int t, const int n) {\n\tint l = 0, r = m;\n\twhile (l < r) {\n\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\tint mid = l + (r - l) / 2;\n\n\t\treset(mid);\n\n\t\tif (dinic(s, t, n) < m) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) E[i - 1] = addEdge(s, i, 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\taddEdge(a, n + i, 1);\n\t\taddEdge(b, n + i, 1);\n\n\t\taddEdge(n + i, t, 1);\n\t}\n\n\tprintf(\"%d\\n\", solve(s, t, n + m + 2));\n\n\treturn 0;\n}\n```\n","source":"_posts/poi2005-kos.md","raw":"title: POI2005Kos-Dicing -  + \ndate: 2016-06-22 18:25:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - Dinic\n  - \npermalink: poi2005-kos\n---\n\nDicing \n\n<!-- more -->\n\n### \n[BZOJ 1532](http://www.lydsy.com/JudgeOnline/problem.php?id=1532)\n\n### \n $ x $ $ x $ $ 1 $ $ 1 $ $ m $ \n\n $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c > e->f) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c > e->f) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\t// printf(\"dinic() = %d\\n\", res);\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\nEdge *E[MAXN];\n\ninline void reset(const int c) {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tif (i < n) E[i]->c = c;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n\t}\n}\n\ninline int solve(const int s, const int t, const int n) {\n\tint l = 0, r = m;\n\twhile (l < r) {\n\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\tint mid = l + (r - l) / 2;\n\n\t\treset(mid);\n\n\t\tif (dinic(s, t, n) < m) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) E[i - 1] = addEdge(s, i, 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\taddEdge(a, n + i, 1);\n\t\taddEdge(b, n + i, 1);\n\n\t\taddEdge(n + i, t, 1);\n\t}\n\n\tprintf(\"%d\\n\", solve(s, t, n + m + 2));\n\n\treturn 0;\n}\n```\n","slug":"poi2005-kos","published":1,"updated":"2016-06-22T10:25:54.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rjh00k1ooxltud1xze2"},{"title":"POI2000 - AC  + ","date":"2016-09-12T23:46:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 2938](http://www.lydsy.com/JudgeOnline/problem.php?id=2938)\n\n### \n AC \n\n AC  $ 0 $  $ 1 $  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\nconst int MAXN = 30000;\n\nint n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) {\n\t\t\tthis->id = n++;\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint inDegree;\n\tbool invalid, flag, visited;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\t// printf(\"Edge(%d, %d)\\n\", s, t);\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].inDegree++;\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) N[v->id].invalid = true;\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *u = v;\n\t\t\twhile (u != t.root && !u->c[i]) u = u->fail;\n\t\t\tif (u->c[i]) {\n\t\t\t\tif (!v->isWord && !v->next && !u->c[i]->isWord) addEdge(v->id, u->c[i]->id);\n\t\t\t} else {\n\t\t\t\tif (!v->isWord && !v->next) addEdge(v->id, t.root->id);\n\t\t\t}\n\n\t\t\tif (!v->c[i]) continue;\n\t\t\tv->c[i]->visited = true;\n\t\t\tq.push(v->c[i]);\n\t\t}\n\t}\n}\n\ninline bool solve() {\n\tstd::queue<Node *> q;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!N[i].inDegree && !N[i].invalid) {\n\t\tq.push(&N[i]);\n\t\tcnt++;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt--;\n\t\tv->flag = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\t\t\tif (!--e->t->inDegree) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cnt) return false;\n\n\tq.push(&N[0]);\n\tN[0].visited = true;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tif (!v->flag) return true;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->visited && !e->t->invalid) e->t->visited = true, q.push(e->t);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\n\tputs(solve() ? \"TAK\" : \"NIE\");\n\n\treturn 0;\n}\n```","source":"_posts/poi2000-wir.md","raw":"title: POI2000 - AC  + \ndate: 2016-09-13 07:46:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - AC \n  - \npermalink: poi2000-wir\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2938](http://www.lydsy.com/JudgeOnline/problem.php?id=2938)\n\n### \n AC \n\n AC  $ 0 $  $ 1 $  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\nconst int MAXN = 30000;\n\nint n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) {\n\t\t\tthis->id = n++;\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint inDegree;\n\tbool invalid, flag, visited;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\t// printf(\"Edge(%d, %d)\\n\", s, t);\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].inDegree++;\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) N[v->id].invalid = true;\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *u = v;\n\t\t\twhile (u != t.root && !u->c[i]) u = u->fail;\n\t\t\tif (u->c[i]) {\n\t\t\t\tif (!v->isWord && !v->next && !u->c[i]->isWord) addEdge(v->id, u->c[i]->id);\n\t\t\t} else {\n\t\t\t\tif (!v->isWord && !v->next) addEdge(v->id, t.root->id);\n\t\t\t}\n\n\t\t\tif (!v->c[i]) continue;\n\t\t\tv->c[i]->visited = true;\n\t\t\tq.push(v->c[i]);\n\t\t}\n\t}\n}\n\ninline bool solve() {\n\tstd::queue<Node *> q;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!N[i].inDegree && !N[i].invalid) {\n\t\tq.push(&N[i]);\n\t\tcnt++;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt--;\n\t\tv->flag = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\t\t\tif (!--e->t->inDegree) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cnt) return false;\n\n\tq.push(&N[0]);\n\tN[0].visited = true;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tif (!v->flag) return true;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->visited && !e->t->invalid) e->t->visited = true, q.push(e->t);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\n\tputs(solve() ? \"TAK\" : \"NIE\");\n\n\treturn 0;\n}\n```","slug":"poi2000-wir","published":1,"updated":"2016-09-12T23:51:54.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rjk00k8ooxl6ttbs39a"},{"title":"","date":"2016-01-19T13:48:24.000Z","_content":"\n OI \n\n<!-- more -->\n\n### \n OI \n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b  0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### \n `exgcd`  $\\gcd(a,b)$  $ax+by=\\gcd(a,b)$\n\n $\\gcd(47,30)$ \n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n $\\gcd(47,30)=1$ \n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n $x=-7,y=11$\n\n `x`  `y` `y`  `x` \n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes \n\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n\n1.  $i^2$  $i$  $i'$$i*i'$  $i'$ \n2.  $[2,\\sqrt{n}]$  $p>\\sqrt{n}$ $k$  $p=k*k'$  $k< \\sqrt{n}$ $p$  $k$ \n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### \n $n$  $k$  $i$  $a_i$\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n $n$  $p_i$   \n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n $n$ $p$  $p-1$ \n\n $n$\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // \n\treturn ans;\n}\n```\n\n \n","source":"_posts/number-theory-notes-1.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  -   \npermalink: number-theory-notes-1\ndate: 2016-01-19 21:48:24\n---\n\n OI \n\n<!-- more -->\n\n### \n OI \n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b  0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### \n `exgcd`  $\\gcd(a,b)$  $ax+by=\\gcd(a,b)$\n\n $\\gcd(47,30)$ \n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n $\\gcd(47,30)=1$ \n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n $x=-7,y=11$\n\n `x`  `y` `y`  `x` \n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes \n\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n\n1.  $i^2$  $i$  $i'$$i*i'$  $i'$ \n2.  $[2,\\sqrt{n}]$  $p>\\sqrt{n}$ $k$  $p=k*k'$  $k< \\sqrt{n}$ $p$  $k$ \n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### \n $n$  $k$  $i$  $a_i$\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n $n$  $p_i$   \n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n $n$ $p$  $p-1$ \n\n $n$\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // \n\treturn ans;\n}\n```\n\n \n","slug":"number-theory-notes-1","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rjo00kfooxlcesjwb8f"},{"title":" std::stack  DFS","date":"2016-04-08T06:30:21.000Z","_content":"\n Windows  Windows  1M DFS  DFS\n\n<!-- more -->\n\n### \n DFS\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n\n\n DFS \n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan \n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### \n DFS \n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","source":"_posts/non-recursion-dfs-with-stack.md","raw":"title:  std::stack  DFS\ncategories: OI\ntags: \n  - STL\n  - DFS\n  - \n  - Tarjan\n  - \n  - \npermalink: non-recursion-dfs-with-stack\ndate: 2016-04-08 14:30:21\n---\n\n Windows  Windows  1M DFS  DFS\n\n<!-- more -->\n\n### \n DFS\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n\n\n DFS \n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan \n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### \n DFS \n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","slug":"non-recursion-dfs-with-stack","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rk300klooxl9kn22g9j"},{"title":"NOIP2016 ","date":"2016-11-20T15:47:00.000Z","_content":"\n NOIP  \n NOIP\n\n<!-- more -->\n\n### Day0\n\n\n lwyz  %  10  \n\n zyzwjh  xzy  Erii\n\nDev-C++  VC6 Linux root  sda3  Windows  \n\n### Day1\nlyx  \n\n\n\n   DFS      + $ S_i = 1 $ \n\n Floyd $ m = 0 $  $ m = 1 $ $ m = 2 $  $ k = 1 $    DP \n\n zyz T2   T3  DP    \n\n     \n\n zyz \n\n### Day2\n\n\n Pascal  +  $ O(2000 ^ 2 + Tn) $ lyx  lyh    QAQ\n\n +  CCF   \n\n GDB  Windows  BugDFS  $ T = 5, n = 18 $  T BFS  $ O(T \\times (2 ^ n n ^ 2)) $ \n\n---\n\n\n\nDay1 Day2 \n\n   \n\n---\n\n>  \n  \n> \n\n> ","source":"_posts/noip2016.md","raw":"title: NOIP2016 \ncategories: Diary\npermalink: noip2016\ndate: 2016-11-20 23:47:00\n---\n\n NOIP  \n NOIP\n\n<!-- more -->\n\n### Day0\n\n\n lwyz  %  10  \n\n zyzwjh  xzy  Erii\n\nDev-C++  VC6 Linux root  sda3  Windows  \n\n### Day1\nlyx  \n\n\n\n   DFS      + $ S_i = 1 $ \n\n Floyd $ m = 0 $  $ m = 1 $ $ m = 2 $  $ k = 1 $    DP \n\n zyz T2   T3  DP    \n\n     \n\n zyz \n\n### Day2\n\n\n Pascal  +  $ O(2000 ^ 2 + Tn) $ lyx  lyh    QAQ\n\n +  CCF   \n\n GDB  Windows  BugDFS  $ T = 5, n = 18 $  T BFS  $ O(T \\times (2 ^ n n ^ 2)) $ \n\n---\n\n\n\nDay1 Day2 \n\n   \n\n---\n\n>  \n  \n> \n\n> ","slug":"noip2016","published":1,"updated":"2016-11-20T15:48:34.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rk700ktooxl6g2yf5hl"},{"title":"NOIP2016 - ","date":"2016-11-29T03:25:00.000Z","_content":"\n\n\n\n\n `singer`  $ 3 $  $ 1 $  $ 2 $ \n\n \n\n\n\n`singer`  $ 3 $  `archer`  \n`archer`  $ 1 $  `thinker`  \n`thinker`  $ 2 $  `writer`\n\n `writer` \n\n\n\n $ n $  $ 1 $  $ m $  $ i $ / $ s_i $ \n\n<!-- more -->\n\n### \n[Luogu 1563](https://www.luogu.org/problem/show?pid=1563)  \n[LYOI #99](https://ly.men.ci/problem/99)\n\n### \n $ n $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 1e5 + 10;\n\nint main() {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic struct Node {\n\t\tchar name[10 + 1];\n\t\tint opposite;\n\t} a[MAXN];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &a[i].opposite, a[i].name);\n\t}\n\n\tint curr = 0;\n\twhile (m--) {\n\t\t// printf(\"%d: %s\\n\", curr, a[curr].name);\n\n\t\tint k, s;\n\t\tscanf(\"%d %d\", &k, &s);\n\n\t\tint d = (k ^ a[curr].opposite) ? 1 : -1;\n\n\t\t(((curr += d * s) %= n) += n) %= n;\n\t}\n\n\tprintf(\"%s\\n\", a[curr].name);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-toy.md","raw":"title: NOIP2016 - \ncategories: OI\ntags: \n  - NOIP\n  - \npermalink: noip2016-toy\ndate: 2016-11-29 11:25:00\n---\n\n\n\n\n\n `singer`  $ 3 $  $ 1 $  $ 2 $ \n\n \n\n\n\n`singer`  $ 3 $  `archer`  \n`archer`  $ 1 $  `thinker`  \n`thinker`  $ 2 $  `writer`\n\n `writer` \n\n\n\n $ n $  $ 1 $  $ m $  $ i $ / $ s_i $ \n\n<!-- more -->\n\n### \n[Luogu 1563](https://www.luogu.org/problem/show?pid=1563)  \n[LYOI #99](https://ly.men.ci/problem/99)\n\n### \n $ n $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 1e5 + 10;\n\nint main() {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic struct Node {\n\t\tchar name[10 + 1];\n\t\tint opposite;\n\t} a[MAXN];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &a[i].opposite, a[i].name);\n\t}\n\n\tint curr = 0;\n\twhile (m--) {\n\t\t// printf(\"%d: %s\\n\", curr, a[curr].name);\n\n\t\tint k, s;\n\t\tscanf(\"%d %d\", &k, &s);\n\n\t\tint d = (k ^ a[curr].opposite) ? 1 : -1;\n\n\t\t(((curr += d * s) %= n) += n) %= n;\n\t}\n\n\tprintf(\"%s\\n\", a[curr].name);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-toy","published":1,"updated":"2016-11-29T07:36:08.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rk900kvooxl5hjzokqa"},{"title":"NOIP2016 -  + ","date":"2016-11-29T07:10:00.000Z","_content":"\n C \n\n $ n $  $ n - 1 $  $ 1 $  $ n $ \n\n $ m $  $ i $  $ S_i $ $ T_i $ $ 0 $  \n\n C  $ j $  $ W_j $  $ W_j $  $ j $ C \n\n $ j $  $ W_j $  $ j $  $ W_j $  $ j $ \n\n<!-- more -->\n\n### \n[Luogu 1600](https://www.luogu.org/problem/show?pid=1600)  \n[LYOI #100](https://ly.men.ci/problem/100)\n\n### \n $ L $  $ [0, L) $  $ S_j $  $ T_j $$ S_j < T_j $ $ i $  $ W_i = i - S_j $\n\n![](noip2016-running/linear-forward1.svg)\n\n $ S_j < 0 $ \n\n![](noip2016-running/linear-forward2.svg)\n\n $ S_j > T_j $  $ W_i = S_j - i $\n\n![](noip2016-running/linear-backward1.svg)\n\n$ S_j > L $ \n\n $ S_j < T_j $ $ S_j = i - W_i $ $ i $  $ X_i = i - W_i $\n\n1.  $ [S_j, T_j] $ \n2.  $ i $ $ X_i $\n\n $ S_j > T_j $ $ S_j = W_i + i $ $ X_i = i + W_i $ \n\n $ S_j $  $ T_j $  $ j $ $ j $\n\n $ O(n) $  $ O(\\log n) $  $ 0 $ $ S_j < T_j $  $ S_j > T_j $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 299998;\n\nstruct Tag {\n#ifdef FORCE\n\tint s, t, x;\n\n\tTag(int s, int t, int x) : s(s), t(t), x(x) {\n#ifdef DBG\n\t\tprintf(\"Tag(%d, %d, %d)\\n\", s, t, x);\n#endif\n\t}\n#else\n\tint x;\n\tbool remove;\n\n\tTag(int x, bool remove) : x(x), remove(remove) {}\n#endif\n};\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent, *child;\n\tint depth, size, w, index, x, ans;\n\tbool visited;\n\tstruct Chain *chain;\n#ifndef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Chain {\n\tNode *top, *bottom;\n\tstd::vector<Node *> nodes;\n#ifdef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n\tint len;\n} chains[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, chainCnt;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->depth) {\n\t\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\t\te->t->parent = v;\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->child || v->child->size < e->t->size) v->child = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].visited = false;\n\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\n\t\t\tif (!v->parent || v != v->parent->child) {\n\t\t\t\tv->chain = &chains[++chainCnt];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->index = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->parent->chain;\n\t\t\t\tv->index = v->parent->index + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bottom = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->parent == v) {\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= chainCnt; i++) chains[i].len = chains[i].nodes.size();\n\n#ifdef DBG\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tprintf(\"chains[%d]: top = %lu, bottom = %lu, nodes = [\", i, chains[i].top - N, chains[i].bottom - N);\n\t\tfor (int j = 0; j < chains[i].len; j++) {\n\t\t\tprintf(\"%lu%s\", chains[i].nodes[j] - N, j == chains[i].len - 1 ? \"]\\n\" : \", \");\n\t\t}\n\t}\n#endif\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->parent;\n\t}\n\tif (u->depth > v->depth) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->depth + v->depth - p->depth * 2;\n}\n\ninline void addTag(bool forward, Chain *chain, int s, int t, int x) {\n#ifdef FORCE\n\tif (forward) {\n\t\tchain->tagsForward.push_back(Tag(s, t, x));\n\t} else {\n\t\tchain->tagsBackward.push_back(Tag(s, t, x));\n\t}\n#else\n\tif (forward) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->tagsForward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsForward.push_back(Tag(x, true));\n\t} else {\n\t\tif (t > s) return;\n\t\tchain->nodes[s]->tagsBackward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsBackward.push_back(Tag(x, true));\n\t}\n#ifdef DBG\n\tprintf(\"addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\\n\", forward, chain - chains, s, t, x);\n#endif\n#endif\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n#ifdef DBG\n\tprintf(\"play(s = %lu, t = %lu, p = %lu)\\n\", s - N, t - N, p - N);\n#endif\n\n\tif (p != s) {\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\t// S -> P, backward on chain\n\t\twhile (u->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\t\taddTag(false, u->chain, u->index, 0, s->depth - u->chain->bottom->depth);\n\t\t\tu = u->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\taddTag(false, u->chain, u->index, p->index + 1, s->depth - u->chain->bottom->depth);\n\t}\n\n\tif (p != t) {\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\t// P -> T, forward on chain\n\t\twhile (v->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\t\taddTag(true, v->chain, 0, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t\t\tv = v->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\taddTag(true, v->chain, p->index + 1, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t}\n}\n\ninline void solve() {\n#ifdef FORCE\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) {\n\t\t\tfor (int j = it->s; j <= it->t; j++) {\n\t\t\t\tif (chain.nodes[j]->w - j == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) {\n\t\t\tfor (int j = it->s; j >= it->t; j--) {\n\t\t\t\tif (chain.nodes[j]->w - chain.len + j + 1 == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#else\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n\t\tstatic int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN;\n\t\t\n\t\t// forward\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - j], chain.nodes[j]->w - j);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// backward\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - chain.len + j + 1];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - chain.len + j + 1], chain.nodes[j]->w - chain.len + j + 1);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].w);\n\t}\n\n\tsplit();\n\n\twhile (m--) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tplay(&N[s], &N[t]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-running.md","raw":"title: NOIP2016 -  + \ncategories: OI\ntags: \n  - NOIP\n  - \n  - \npermalink: noip2016-running\ndate: 2016-11-29 15:10:00\n---\n\n C \n\n $ n $  $ n - 1 $  $ 1 $  $ n $ \n\n $ m $  $ i $  $ S_i $ $ T_i $ $ 0 $  \n\n C  $ j $  $ W_j $  $ W_j $  $ j $ C \n\n $ j $  $ W_j $  $ j $  $ W_j $  $ j $ \n\n<!-- more -->\n\n### \n[Luogu 1600](https://www.luogu.org/problem/show?pid=1600)  \n[LYOI #100](https://ly.men.ci/problem/100)\n\n### \n $ L $  $ [0, L) $  $ S_j $  $ T_j $$ S_j < T_j $ $ i $  $ W_i = i - S_j $\n\n![](noip2016-running/linear-forward1.svg)\n\n $ S_j < 0 $ \n\n![](noip2016-running/linear-forward2.svg)\n\n $ S_j > T_j $  $ W_i = S_j - i $\n\n![](noip2016-running/linear-backward1.svg)\n\n$ S_j > L $ \n\n $ S_j < T_j $ $ S_j = i - W_i $ $ i $  $ X_i = i - W_i $\n\n1.  $ [S_j, T_j] $ \n2.  $ i $ $ X_i $\n\n $ S_j > T_j $ $ S_j = W_i + i $ $ X_i = i + W_i $ \n\n $ S_j $  $ T_j $  $ j $ $ j $\n\n $ O(n) $  $ O(\\log n) $  $ 0 $ $ S_j < T_j $  $ S_j > T_j $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 299998;\n\nstruct Tag {\n#ifdef FORCE\n\tint s, t, x;\n\n\tTag(int s, int t, int x) : s(s), t(t), x(x) {\n#ifdef DBG\n\t\tprintf(\"Tag(%d, %d, %d)\\n\", s, t, x);\n#endif\n\t}\n#else\n\tint x;\n\tbool remove;\n\n\tTag(int x, bool remove) : x(x), remove(remove) {}\n#endif\n};\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent, *child;\n\tint depth, size, w, index, x, ans;\n\tbool visited;\n\tstruct Chain *chain;\n#ifndef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Chain {\n\tNode *top, *bottom;\n\tstd::vector<Node *> nodes;\n#ifdef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n\tint len;\n} chains[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, chainCnt;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->depth) {\n\t\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\t\te->t->parent = v;\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->child || v->child->size < e->t->size) v->child = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].visited = false;\n\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\n\t\t\tif (!v->parent || v != v->parent->child) {\n\t\t\t\tv->chain = &chains[++chainCnt];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->index = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->parent->chain;\n\t\t\t\tv->index = v->parent->index + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bottom = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->parent == v) {\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= chainCnt; i++) chains[i].len = chains[i].nodes.size();\n\n#ifdef DBG\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tprintf(\"chains[%d]: top = %lu, bottom = %lu, nodes = [\", i, chains[i].top - N, chains[i].bottom - N);\n\t\tfor (int j = 0; j < chains[i].len; j++) {\n\t\t\tprintf(\"%lu%s\", chains[i].nodes[j] - N, j == chains[i].len - 1 ? \"]\\n\" : \", \");\n\t\t}\n\t}\n#endif\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->parent;\n\t}\n\tif (u->depth > v->depth) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->depth + v->depth - p->depth * 2;\n}\n\ninline void addTag(bool forward, Chain *chain, int s, int t, int x) {\n#ifdef FORCE\n\tif (forward) {\n\t\tchain->tagsForward.push_back(Tag(s, t, x));\n\t} else {\n\t\tchain->tagsBackward.push_back(Tag(s, t, x));\n\t}\n#else\n\tif (forward) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->tagsForward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsForward.push_back(Tag(x, true));\n\t} else {\n\t\tif (t > s) return;\n\t\tchain->nodes[s]->tagsBackward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsBackward.push_back(Tag(x, true));\n\t}\n#ifdef DBG\n\tprintf(\"addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\\n\", forward, chain - chains, s, t, x);\n#endif\n#endif\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n#ifdef DBG\n\tprintf(\"play(s = %lu, t = %lu, p = %lu)\\n\", s - N, t - N, p - N);\n#endif\n\n\tif (p != s) {\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\t// S -> P, backward on chain\n\t\twhile (u->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\t\taddTag(false, u->chain, u->index, 0, s->depth - u->chain->bottom->depth);\n\t\t\tu = u->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\taddTag(false, u->chain, u->index, p->index + 1, s->depth - u->chain->bottom->depth);\n\t}\n\n\tif (p != t) {\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\t// P -> T, forward on chain\n\t\twhile (v->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\t\taddTag(true, v->chain, 0, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t\t\tv = v->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\taddTag(true, v->chain, p->index + 1, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t}\n}\n\ninline void solve() {\n#ifdef FORCE\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) {\n\t\t\tfor (int j = it->s; j <= it->t; j++) {\n\t\t\t\tif (chain.nodes[j]->w - j == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) {\n\t\t\tfor (int j = it->s; j >= it->t; j--) {\n\t\t\t\tif (chain.nodes[j]->w - chain.len + j + 1 == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#else\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n\t\tstatic int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN;\n\t\t\n\t\t// forward\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - j], chain.nodes[j]->w - j);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// backward\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - chain.len + j + 1];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - chain.len + j + 1], chain.nodes[j]->w - chain.len + j + 1);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].w);\n\t}\n\n\tsplit();\n\n\twhile (m--) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tplay(&N[s], &N[t]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-running","published":1,"updated":"2016-11-29T07:36:19.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rkc00l0ooxl3gg8o7tc"},{"title":"NOIP2016 -  + ","date":"2016-11-29T12:54:00.000Z","_content":"\n $ n $  $ m $  $ (1, 2, 3) $  $ (1, 2) $$ (1, 3) $$ (2, 3) $ \n\n\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n $ n! = 1 \\times 2 \\times \\cdots \\times n $\n\n $ n $$ m $  $ k $ $ 0 \\leq i \\leq n $$ 0 \\leq j \\leq \\min(i, m) $  $ (i, j) $  $ k $ \n\n<!-- more -->\n\n### \n[Luogu 2822](https://www.luogu.org/problem/show?pid=2822)  \n[LYOI #102](https://ly.men.ci/problem/102)\n\n### \n Pascal \n\n$$ C_n ^ m = C_{n - 1} ^ {m - 1} + C_{n - 1} ^ {m} $$\n\n $ C_i ^ j \\bmod k $ $ s(u, i) $  $ 1 \\leq j \\leq i $ $ C_u ^ j \\bmod k = 0 $ $ O(n) $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000 + 10;\n\nint C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1];\n\nint main() {\n\tfreopen(\"problem.in\", \"r\", stdin);\n\tfreopen(\"problem.out\", \"w\", stdout);\n\t\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\t\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcnt[i][j] = cnt[i][j - 1];\n\t\t\tif (C[i][j] == 0) cnt[i][j]++;\n\t\t}\n\t}\n\t\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += cnt[i][std::min(i, m)];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-problem.md","raw":"title: NOIP2016 -  + \ncategories: OI\ntags: \n  - NOIP\n  - \n  - \n  - \npermalink: noip2016-problem\ndate: 2016-11-29 20:54:00\n---\n\n $ n $  $ m $  $ (1, 2, 3) $  $ (1, 2) $$ (1, 3) $$ (2, 3) $ \n\n\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n $ n! = 1 \\times 2 \\times \\cdots \\times n $\n\n $ n $$ m $  $ k $ $ 0 \\leq i \\leq n $$ 0 \\leq j \\leq \\min(i, m) $  $ (i, j) $  $ k $ \n\n<!-- more -->\n\n### \n[Luogu 2822](https://www.luogu.org/problem/show?pid=2822)  \n[LYOI #102](https://ly.men.ci/problem/102)\n\n### \n Pascal \n\n$$ C_n ^ m = C_{n - 1} ^ {m - 1} + C_{n - 1} ^ {m} $$\n\n $ C_i ^ j \\bmod k $ $ s(u, i) $  $ 1 \\leq j \\leq i $ $ C_u ^ j \\bmod k = 0 $ $ O(n) $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000 + 10;\n\nint C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1];\n\nint main() {\n\tfreopen(\"problem.in\", \"r\", stdin);\n\tfreopen(\"problem.out\", \"w\", stdout);\n\t\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\t\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcnt[i][j] = cnt[i][j - 1];\n\t\t\tif (C[i][j] == 0) cnt[i][j]++;\n\t\t}\n\t}\n\t\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += cnt[i][std::min(i, m)];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"noip2016-problem","published":1,"updated":"2016-11-29T13:12:22.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rks00l6ooxlzwyn17nd"},{"title":"NOIP2016 - ","date":"2016-11-29T13:10:00.000Z","_content":"\n $ \\lfloor c \\rfloor $  $ c $ $ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $\n\n\n\n $ n $ $ n $  $ i $  $ a_i $$ i = 1, 2, \\ldots , n $ $ 0 $ \n\n $ p $ $ 0 < p < 1 $  $ x $ $ \\lfloor px \\rfloor $  $ x - \\lfloor px \\rfloor $  $ 0 $ $ 0 $  $ q $\n\n $ m $  $ m $ \n\n $ m $ \n\n* $ m $  $ m $ \n* $ m $  $ n + m $ \n\n \n\n<!-- more -->\n\n### \n[Luogu 2827](https://www.luogu.org/problem/show?pid=2827)  \n[LYOI #103](https://ly.men.ci/problem/103)\n\n### \n $ q = 0 $ \n\n $ q \\neq 0 $ \n\n $ O(n \\log n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 7000000;\n\ntemplate <typename T>\nstruct Queue {\n    T a[MAXN + MAXM], *l, *r;\n\n    Queue() : l(a), r(a - 1) {}\n\n    void push(const T &x) { *++r = x; }\n    void pop() { ++l; }\n    T &front() { return *l; }\n    bool empty() const { return l > r; }\n};\n\n#ifdef DBG\nstd::queue<int> q[3];\n#else\nQueue<int> q[3];\n#endif\n\ninline int getMax() {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\n#ifdef DBG\ninline void printAll(int d) {\n    std::vector<int> v;\n    for (int i = 0; i < 3; i++) {\n        std::queue<int> a = ::q[i];\n        while (!a.empty()) v.push_back(a.front()), a.pop();\n    }\n    std::sort(v.begin(), v.end());\n    printf(\"%lu: \", v.size());\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) printf(\"%d%c\", *it, it == --v.end() ? '\\n' : ' ');\n}\n#endif\n\nint main() {\n    freopen(\"earthworm.in\", \"r\", stdin);\n    freopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n    static int a[MAXN + 1];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    std::sort(a + 1, a + n + 1);\n\n    for (int i = n; i >= 1; i--) q[0].push(a[i]);\n\n    int d = 0;\n    for (int i = 1; i <= m; i++) {\n        int j = getMax();\n\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n\n        int a = static_cast<long long>(x) * u / v, b = x - a;\n\n        d += k;\n        a -= d, b -= d;\n\n        q[1].push(a), q[2].push(b);\n    }\n\n    putchar('\\n');\n\n    for (int i = 1; i <= n + m; i++) {\n        int j = getMax();\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n    }\n\n    putchar('\\n');\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","source":"_posts/noip2016-earthworm.md","raw":"title: NOIP2016 - \ncategories: OI\ntags: \n  - NOIP\n  - \npermalink: noip2016-earthworm\ndate: 2016-11-29 21:10:00\n---\n\n $ \\lfloor c \\rfloor $  $ c $ $ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $\n\n\n\n $ n $ $ n $  $ i $  $ a_i $$ i = 1, 2, \\ldots , n $ $ 0 $ \n\n $ p $ $ 0 < p < 1 $  $ x $ $ \\lfloor px \\rfloor $  $ x - \\lfloor px \\rfloor $  $ 0 $ $ 0 $  $ q $\n\n $ m $  $ m $ \n\n $ m $ \n\n* $ m $  $ m $ \n* $ m $  $ n + m $ \n\n \n\n<!-- more -->\n\n### \n[Luogu 2827](https://www.luogu.org/problem/show?pid=2827)  \n[LYOI #103](https://ly.men.ci/problem/103)\n\n### \n $ q = 0 $ \n\n $ q \\neq 0 $ \n\n $ O(n \\log n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 7000000;\n\ntemplate <typename T>\nstruct Queue {\n    T a[MAXN + MAXM], *l, *r;\n\n    Queue() : l(a), r(a - 1) {}\n\n    void push(const T &x) { *++r = x; }\n    void pop() { ++l; }\n    T &front() { return *l; }\n    bool empty() const { return l > r; }\n};\n\n#ifdef DBG\nstd::queue<int> q[3];\n#else\nQueue<int> q[3];\n#endif\n\ninline int getMax() {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\n#ifdef DBG\ninline void printAll(int d) {\n    std::vector<int> v;\n    for (int i = 0; i < 3; i++) {\n        std::queue<int> a = ::q[i];\n        while (!a.empty()) v.push_back(a.front()), a.pop();\n    }\n    std::sort(v.begin(), v.end());\n    printf(\"%lu: \", v.size());\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) printf(\"%d%c\", *it, it == --v.end() ? '\\n' : ' ');\n}\n#endif\n\nint main() {\n    freopen(\"earthworm.in\", \"r\", stdin);\n    freopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n    static int a[MAXN + 1];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    std::sort(a + 1, a + n + 1);\n\n    for (int i = n; i >= 1; i--) q[0].push(a[i]);\n\n    int d = 0;\n    for (int i = 1; i <= m; i++) {\n        int j = getMax();\n\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n\n        int a = static_cast<long long>(x) * u / v, b = x - a;\n\n        d += k;\n        a -= d, b -= d;\n\n        q[1].push(a), q[2].push(b);\n    }\n\n    putchar('\\n');\n\n    for (int i = 1; i <= n + m; i++) {\n        int j = getMax();\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n    }\n\n    putchar('\\n');\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","slug":"noip2016-earthworm","published":1,"updated":"2016-11-29T13:11:22.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rkv00lcooxls72wclbx"},{"title":"NOIP2016 - Floyd + DP + ","date":"2016-11-29T07:35:00.000Z","_content":"\n\n\n $ 2n $  $ n $  $ i $ $ 1 \\leq  i \\leq n $ $ c_i $  $ d_i $ \n\n $ n $ i $ i $  $ d_i $  $ c_i $ \n\n $ i $  $ k_i $\n\n $ m $  $ m $  $ m $ \n\n\n\n $ v $  $ e $  $ i $$ 1 \\leq i \\leq n - 1 $\n\n\n\n<!-- more -->\n\n### \n[Luogu 1850](https://www.luogu.org/problem/show?pid=1850)  \n[LYOI #101](https://ly.men.ci/problem/101)\n\n### \n Floyd  $ f(i, j, k) $  $ i $  $ j $ $ k \\in \\{ 0, 1 \\} $  $ i $ \n\n $ f(i, j, 0) $ \n\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i, j, 1) $ \n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n $ O(v ^ 3 + nm) $\n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <climits>\n#include <algorithm>\n\nconst int MAXCNT = 2000;\nconst int MAXN = 300;\n\nint cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1];\ndouble k[MAXCNT + 1];\n\nint main() {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d %d %d\", &cnt, &max, &n, &m);\n\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[u][v] = g[v][u] = std::min(g[u][v], w);\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (g[i][k] != INT_MAX && g[k][j] != INT_MAX && g[i][j] > g[i][k] + g[k][j]) {\n\t\t\t\t\tg[i][j] = g[i][k] + g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) g[i][i] = 0;\n\n\tstatic double f[MAXCNT + 1][MAXCNT + 1][2];\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\n\tfor (int i = 2; i <= cnt; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= max; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tfor (int j = 0; j <= max; j++) {\n\t\t\tprintf(\"f[%d][%d][0] = %.4lf\\n\", i, j, f[i][j][0]);\n\t\t\tprintf(\"f[%d][%d][1] = %.4lf\\n\", i, j, f[i][j][1]);\n\t\t}\n#endif\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor (int i = 0; i <= max; i++) {\n\t\tans = std::min(ans, f[cnt][i][0]);\n\t\tans = std::min(ans, f[cnt][i][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-classroom.md","raw":"title: NOIP2016 - Floyd + DP + \ncategories: OI\ntags: \n  - NOIP\n  - DP\n  - Floyd\n  - \npermalink: noip2016-classroom\ndate: 2016-11-29 15:35:00\n---\n\n\n\n $ 2n $  $ n $  $ i $ $ 1 \\leq  i \\leq n $ $ c_i $  $ d_i $ \n\n $ n $ i $ i $  $ d_i $  $ c_i $ \n\n $ i $  $ k_i $\n\n $ m $  $ m $  $ m $ \n\n\n\n $ v $  $ e $  $ i $$ 1 \\leq i \\leq n - 1 $\n\n\n\n<!-- more -->\n\n### \n[Luogu 1850](https://www.luogu.org/problem/show?pid=1850)  \n[LYOI #101](https://ly.men.ci/problem/101)\n\n### \n Floyd  $ f(i, j, k) $  $ i $  $ j $ $ k \\in \\{ 0, 1 \\} $  $ i $ \n\n $ f(i, j, 0) $ \n\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i, j, 1) $ \n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n $ O(v ^ 3 + nm) $\n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <climits>\n#include <algorithm>\n\nconst int MAXCNT = 2000;\nconst int MAXN = 300;\n\nint cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1];\ndouble k[MAXCNT + 1];\n\nint main() {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d %d %d\", &cnt, &max, &n, &m);\n\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[u][v] = g[v][u] = std::min(g[u][v], w);\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (g[i][k] != INT_MAX && g[k][j] != INT_MAX && g[i][j] > g[i][k] + g[k][j]) {\n\t\t\t\t\tg[i][j] = g[i][k] + g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) g[i][i] = 0;\n\n\tstatic double f[MAXCNT + 1][MAXCNT + 1][2];\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\n\tfor (int i = 2; i <= cnt; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= max; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tfor (int j = 0; j <= max; j++) {\n\t\t\tprintf(\"f[%d][%d][0] = %.4lf\\n\", i, j, f[i][j][0]);\n\t\t\tprintf(\"f[%d][%d][1] = %.4lf\\n\", i, j, f[i][j][1]);\n\t\t}\n#endif\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor (int i = 0; i <= max; i++) {\n\t\tans = std::min(ans, f[cnt][i][0]);\n\t\tans = std::min(ans, f[cnt][i][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-classroom","published":1,"updated":"2016-11-29T07:36:33.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rkz00lhooxldw6ys8ng"},{"title":"NOIP2016 -  + BFS","date":"2016-11-29T13:21:00.000Z","_content":"\nKiana \n\n\n\n $ (0, 0) $  Kiana  $ y = ax ^ 2 + bx $  $ a $$ b $  Kiana  $ a < 0 $\n\n $ x $ \n\n $ n $  $ i $  $ (x_i, y_i) $\n\n$ (x_i, y_i) $ $ i $ \n\n$ (x_i, y_i) $ $ i $ \n\n $ (1, 3) $  $ (3, 3) $Kiana  $ y = -x ^ 2 + 4x $ \n\n\n\n Kiana  Kiana \n\n $ T $  Kiana \n\n<!-- more -->\n\n### \n[Luogu 2831](https://www.luogu.org/problem/show?pid=2831)  \n[LYOI #104](https://ly.men.ci/problem/104)\n\n### \n $ y = ax ^ 2 + bx + c $  $ c $  $ a \\leq 0 $  $ O(n ^ 2) $ \n\nBFS \n\n $ O(2 ^ n n ^ 2) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 18 + 3;\nconst int MAXSTATUS = (1 << (MAXN + 1));\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    \n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp(double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp(double x, double y) {\n    return dcmp(x - y);\n}\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n    \n    Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {}\n    \n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n    \n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool visited;\n    int dist;\n} N[MAXSTATUS];\n\nint n, cmd, limit, lineCnt;\n\n/*\n#ifdef DBG\ninline void print(int s) {\n    for (int i = 0; i < n; i++) putchar((s & (1u << i)) ? '1' : '0');\n}\n#endif\n*/\n\ninline int bfs(int status) {\n    if (!status) return 0;\n    \n    std::queue<int> q;\n    q.push(status);\n    N[status].visited = true;\n    N[status].dist = 0;\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        if (N[v].dist == limit) continue;\n        \n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill;\n                \n                if (!N[u].visited) {\n                    N[u].visited = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    \n    return n;\n}\n\n/*\ninline void massert(bool x) {\n    if (!x) {\n        int b = 0;\n        b = 1;\n        b = 2;\n    }\n}\n*/\n\ninline Line getLine(const Point &a, const Point &b) {\n    Line l;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n    // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2)\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    // b = (y1 - a * x1 ^ 2) / x1\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n//    if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) {\n//        printf(\"ERROR: %lf %lf\\n\", l.b, (b.y - l.a * b.x * b.x) / b.x);\n//    }\n    return l;\n}\n\ninline bool onLine(const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve() {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n            \n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n        /*\n#ifdef DBG\n        printf(\"[a = %lf, b = %lf]: \", lines[i].a, lines[i].b);\n        print(lines[i].kill);\n        putchar('\\n');\n#endif\n        */\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1));\n        }\n    }\n        \n    std::sort(lines + 1, lines + lineCnt + 1);\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            }\n        }\n    }\n    \n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].visited = false;\n    }\n    \n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n    \n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n        \n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    fclose(stdin);\n    fclose(stdout);\n}\n```","source":"_posts/noip2016-angrybirds.md","raw":"title: NOIP2016 -  + BFS\ncategories: OI\ntags: \n  - NOIP\n  - \n  - \n  - BFS\npermalink: noip2016-angrybirds\ndate: 2016-11-29 21:21:00\n---\n\nKiana \n\n\n\n $ (0, 0) $  Kiana  $ y = ax ^ 2 + bx $  $ a $$ b $  Kiana  $ a < 0 $\n\n $ x $ \n\n $ n $  $ i $  $ (x_i, y_i) $\n\n$ (x_i, y_i) $ $ i $ \n\n$ (x_i, y_i) $ $ i $ \n\n $ (1, 3) $  $ (3, 3) $Kiana  $ y = -x ^ 2 + 4x $ \n\n\n\n Kiana  Kiana \n\n $ T $  Kiana \n\n<!-- more -->\n\n### \n[Luogu 2831](https://www.luogu.org/problem/show?pid=2831)  \n[LYOI #104](https://ly.men.ci/problem/104)\n\n### \n $ y = ax ^ 2 + bx + c $  $ c $  $ a \\leq 0 $  $ O(n ^ 2) $ \n\nBFS \n\n $ O(2 ^ n n ^ 2) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 18 + 3;\nconst int MAXSTATUS = (1 << (MAXN + 1));\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    \n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp(double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp(double x, double y) {\n    return dcmp(x - y);\n}\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n    \n    Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {}\n    \n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n    \n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool visited;\n    int dist;\n} N[MAXSTATUS];\n\nint n, cmd, limit, lineCnt;\n\n/*\n#ifdef DBG\ninline void print(int s) {\n    for (int i = 0; i < n; i++) putchar((s & (1u << i)) ? '1' : '0');\n}\n#endif\n*/\n\ninline int bfs(int status) {\n    if (!status) return 0;\n    \n    std::queue<int> q;\n    q.push(status);\n    N[status].visited = true;\n    N[status].dist = 0;\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        if (N[v].dist == limit) continue;\n        \n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill;\n                \n                if (!N[u].visited) {\n                    N[u].visited = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    \n    return n;\n}\n\n/*\ninline void massert(bool x) {\n    if (!x) {\n        int b = 0;\n        b = 1;\n        b = 2;\n    }\n}\n*/\n\ninline Line getLine(const Point &a, const Point &b) {\n    Line l;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n    // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2)\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    // b = (y1 - a * x1 ^ 2) / x1\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n//    if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) {\n//        printf(\"ERROR: %lf %lf\\n\", l.b, (b.y - l.a * b.x * b.x) / b.x);\n//    }\n    return l;\n}\n\ninline bool onLine(const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve() {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n            \n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n        /*\n#ifdef DBG\n        printf(\"[a = %lf, b = %lf]: \", lines[i].a, lines[i].b);\n        print(lines[i].kill);\n        putchar('\\n');\n#endif\n        */\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1));\n        }\n    }\n        \n    std::sort(lines + 1, lines + lineCnt + 1);\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            }\n        }\n    }\n    \n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].visited = false;\n    }\n    \n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n    \n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n        \n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    fclose(stdin);\n    fclose(stdout);\n}\n```","slug":"noip2016-angrybirds","published":1,"updated":"2016-11-29T13:22:13.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rl400loooxl33swj2te"},{"title":"NOIP2015 -  +  + ","date":"2016-10-19T09:19:00.000Z","_content":"\n $ m $  $ u_i \\leftrightarrow v_i $ $ 0 $ $ m $ \n\n<!-- more -->\n\n### \n[CodeVS 4632](http://codevs.cn/problem/4632/)  \n[CodeVS 5440](http://codevs.cn/problem/5440/)  \n[BZOJ 4326](http://www.lydsy.com/JudgeOnline/problem.php?id=4326)  \n\n### \n $ x $ $ > x $  $ \\leq x $ $ x $ \n\n**** $ u_i \\leftrightarrow v_i $ $ p_i = \\mathrm{lca}(u_i, v_i) $ $ u_i $  $ v_i $  $ +1 $  $ p_i $  $ -2 $ \n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <new>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 300000;\nconst int MAXM = 300000;\nconst int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tbool visited;\n\tint pos, depth, cover, dist;\n} N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w, cover;\n\tEdge *next;\n\n\tEdge() {}\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n} mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1];\n\nstruct Path {\n\tNode *u, *v, *p;\n\tint dist;\n} a[MAXM];\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new (pEdge++) Edge(&N[s], &N[t], w);\n\tN[t].e = new (pEdge++) Edge(&N[t], &N[s], w);\n}\n\nint n, m, log[MAXN * 2 + 1], max, eulerTourLen;\n\ninline void dfs() {\n\tstatic Node *s[MAXN];\n\tNode **top = s;\n\t*s = &N[0];\n\tN[0].depth = 1;\n\n\tint ts = 0;\n\twhile (top >= s) {\n\t\tNode *v = *top;\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->pos = eulerTourLen;\n\t\t\tdfsSequence[ts++] = v;\n\t\t}\n\n\t\teulerTour[eulerTourLen++] = v;\n\n\t\twhile (v->c && v->c->t->depth) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tif (!v->c->t->depth) {\n\t\t\t\tv->c->t->depth = v->depth + 1;\n\t\t\t\tv->c->t->dist = v->dist + v->c->w;\n\t\t\t\tv->c->t->in = v->c;\n\t\t\t\t*++top = v->c->t;\n\t\t\t}\n\t\t\tv->c = v->c->next;\n\t\t} else {\n\t\t\ttop--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) E[i - 1] = N[i].in;\n}\n\ninline Node *min(Node *a, Node *b) {\n\treturn a->depth < b->depth ? a : b;\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < eulerTourLen; i++) st[i][0] = eulerTour[i];\n\tfor (int j = 1; (1 << j) <= eulerTourLen; j++) {\n\t\tfor (int i = 0; i < eulerTourLen; i++) {\n\t\t\tif (i + (1 << (j - 1)) < eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= eulerTourLen; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t}\n}\n\ninline Node *rmq(const int l, const int r) {\n\tif (l == r) return st[l][0];\n\telse {\n\t\tconst int t = log[r - l];\n\t\treturn min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n}\n\ninline Node *lca(Node *u, Node *v) {\n\treturn rmq(std::min(u->pos, v->pos), std::max(u->pos, v->pos));\n}\n\ninline int distance(Node *u, Node *v, Node *p) {\n\treturn u->dist + v->dist - p->dist * 2;\n}\n\ninline bool check(const int limit) {\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[i].dist > limit) {\n\t\t\ta[i].p->cover -= 2;\n\t\t\ta[i].u->cover++;\n\t\t\ta[i].v->cover++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (dfsSequence[i]->in) {\n\t\t\tdfsSequence[i]->in->cover = dfsSequence[i]->cover;\n\t\t\tdfsSequence[i]->in->s->cover += dfsSequence[i]->cover;\n\t\t}\n\t\tdfsSequence[i]->cover = 0;\n\t}\n\n\tEdge *maxEdge = NULL;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (E[i]->cover == cnt && (!maxEdge || E[i]->w > maxEdge->w)) maxEdge = E[i];\n\t}\n\n\treturn maxEdge && max - maxEdge->w <= limit;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tdfs();\n\tsparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v), u--, v--;\n\t\ta[i].u = &N[u], a[i].v = &N[v];\n\t\ta[i].p = lca(a[i].u, a[i].v);\n\t\ta[i].dist = distance(a[i].u, a[i].v, a[i].p);\n\t\tmax = std::max(max, a[i].dist);\n\t\t// printf(\"lca(%lu, %lu) = %lu\\n\", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1);\n\t}\n\n\tint l = 0, r = max;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\t// check(11);\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2015-transport.md","raw":"title: NOIP2015 -  +  + \ncategories: OI\ntags: \n  - NOIP\n  - BZOJ\n  - CodeVS\n  - \npermalink: noip2015-transport\ndate: 2016-10-19 17:19:00\n---\n\n $ m $  $ u_i \\leftrightarrow v_i $ $ 0 $ $ m $ \n\n<!-- more -->\n\n### \n[CodeVS 4632](http://codevs.cn/problem/4632/)  \n[CodeVS 5440](http://codevs.cn/problem/5440/)  \n[BZOJ 4326](http://www.lydsy.com/JudgeOnline/problem.php?id=4326)  \n\n### \n $ x $ $ > x $  $ \\leq x $ $ x $ \n\n**** $ u_i \\leftrightarrow v_i $ $ p_i = \\mathrm{lca}(u_i, v_i) $ $ u_i $  $ v_i $  $ +1 $  $ p_i $  $ -2 $ \n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <new>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 300000;\nconst int MAXM = 300000;\nconst int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tbool visited;\n\tint pos, depth, cover, dist;\n} N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w, cover;\n\tEdge *next;\n\n\tEdge() {}\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n} mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1];\n\nstruct Path {\n\tNode *u, *v, *p;\n\tint dist;\n} a[MAXM];\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new (pEdge++) Edge(&N[s], &N[t], w);\n\tN[t].e = new (pEdge++) Edge(&N[t], &N[s], w);\n}\n\nint n, m, log[MAXN * 2 + 1], max, eulerTourLen;\n\ninline void dfs() {\n\tstatic Node *s[MAXN];\n\tNode **top = s;\n\t*s = &N[0];\n\tN[0].depth = 1;\n\n\tint ts = 0;\n\twhile (top >= s) {\n\t\tNode *v = *top;\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->pos = eulerTourLen;\n\t\t\tdfsSequence[ts++] = v;\n\t\t}\n\n\t\teulerTour[eulerTourLen++] = v;\n\n\t\twhile (v->c && v->c->t->depth) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tif (!v->c->t->depth) {\n\t\t\t\tv->c->t->depth = v->depth + 1;\n\t\t\t\tv->c->t->dist = v->dist + v->c->w;\n\t\t\t\tv->c->t->in = v->c;\n\t\t\t\t*++top = v->c->t;\n\t\t\t}\n\t\t\tv->c = v->c->next;\n\t\t} else {\n\t\t\ttop--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) E[i - 1] = N[i].in;\n}\n\ninline Node *min(Node *a, Node *b) {\n\treturn a->depth < b->depth ? a : b;\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < eulerTourLen; i++) st[i][0] = eulerTour[i];\n\tfor (int j = 1; (1 << j) <= eulerTourLen; j++) {\n\t\tfor (int i = 0; i < eulerTourLen; i++) {\n\t\t\tif (i + (1 << (j - 1)) < eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= eulerTourLen; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t}\n}\n\ninline Node *rmq(const int l, const int r) {\n\tif (l == r) return st[l][0];\n\telse {\n\t\tconst int t = log[r - l];\n\t\treturn min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n}\n\ninline Node *lca(Node *u, Node *v) {\n\treturn rmq(std::min(u->pos, v->pos), std::max(u->pos, v->pos));\n}\n\ninline int distance(Node *u, Node *v, Node *p) {\n\treturn u->dist + v->dist - p->dist * 2;\n}\n\ninline bool check(const int limit) {\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[i].dist > limit) {\n\t\t\ta[i].p->cover -= 2;\n\t\t\ta[i].u->cover++;\n\t\t\ta[i].v->cover++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (dfsSequence[i]->in) {\n\t\t\tdfsSequence[i]->in->cover = dfsSequence[i]->cover;\n\t\t\tdfsSequence[i]->in->s->cover += dfsSequence[i]->cover;\n\t\t}\n\t\tdfsSequence[i]->cover = 0;\n\t}\n\n\tEdge *maxEdge = NULL;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (E[i]->cover == cnt && (!maxEdge || E[i]->w > maxEdge->w)) maxEdge = E[i];\n\t}\n\n\treturn maxEdge && max - maxEdge->w <= limit;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tdfs();\n\tsparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v), u--, v--;\n\t\ta[i].u = &N[u], a[i].v = &N[v];\n\t\ta[i].p = lca(a[i].u, a[i].v);\n\t\ta[i].dist = distance(a[i].u, a[i].v, a[i].p);\n\t\tmax = std::max(max, a[i].dist);\n\t\t// printf(\"lca(%lu, %lu) = %lu\\n\", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1);\n\t}\n\n\tint l = 0, r = max;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\t// check(11);\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```\n","slug":"noip2015-transport","published":1,"updated":"2016-10-19T13:07:29.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rld00lwooxllsb6x8v1"},{"title":"NOIP2015 - DP","date":"2016-10-19T08:48:00.000Z","_content":"\n $ A $  $ B $ $ A $  $ k $  $ k $  $ A $  $ B $   \n\n\n<!-- more -->\n\n### \n[CodeVS 4560](http://codevs.cn/problem/4560/)\n\n### \n $ f(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ $ g(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ \n\n $ f(i, j, t) $ \n\n$$\nf(i, j, t) =\n\\begin{cases}\nf(i - 1, j - 1, t) + g(i - 1, j - 1, t - 1) & A_i = B_j \\\\\n0 & A_i \\neq B_j\n\\end{cases}\n$$\n\n$ g(i, j, t) $ \n\n$$\ng(i, j, t) =\n\\begin{cases}\ng(i - 1, j, t) + f(i, j, t) & A_i = B_j \\\\\ng(i - 1, j, t) & A_i \\neq B_j\n\\end{cases}\n$$\n\n $ f(i, 0, 0) = g(i, 0, 0) = 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char a[MAXN + 1], b[MAXM + 1];\n\tscanf(\"%s\\n%s\", a, b);\n\n\tstatic int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1];\n\tg[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int curr = i % 2, prev = !curr;\n\t\tmemset(f[curr], 0, sizeof(f[curr]));\n\t\tmemset(g[curr], 0, sizeof(g[curr]));\n\n\t\tg[curr][0][0] = f[curr][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= std::min(j, k); t++) {\n\t\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\t\tf[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD;\n\t\t\t\t\tg[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD;\n#ifdef DBG\n\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\", i, j, t, g[curr][j][t]);\n\t\t\t\t\tprintf(\"f[%d][%d][%d] = %d\\n\", i, j, t, f[curr][j][t]);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tf[curr][j][t] = 0;\n\t\t\t\t\tg[curr][j][t] = g[prev][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2015-substring.md","raw":"title: NOIP2015 - DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - DP\npermalink: noip2015-substring\ndate: 2016-10-19 16:48:00\n---\n\n $ A $  $ B $ $ A $  $ k $  $ k $  $ A $  $ B $   \n\n\n<!-- more -->\n\n### \n[CodeVS 4560](http://codevs.cn/problem/4560/)\n\n### \n $ f(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ $ g(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ \n\n $ f(i, j, t) $ \n\n$$\nf(i, j, t) =\n\\begin{cases}\nf(i - 1, j - 1, t) + g(i - 1, j - 1, t - 1) & A_i = B_j \\\\\n0 & A_i \\neq B_j\n\\end{cases}\n$$\n\n$ g(i, j, t) $ \n\n$$\ng(i, j, t) =\n\\begin{cases}\ng(i - 1, j, t) + f(i, j, t) & A_i = B_j \\\\\ng(i - 1, j, t) & A_i \\neq B_j\n\\end{cases}\n$$\n\n $ f(i, 0, 0) = g(i, 0, 0) = 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char a[MAXN + 1], b[MAXM + 1];\n\tscanf(\"%s\\n%s\", a, b);\n\n\tstatic int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1];\n\tg[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int curr = i % 2, prev = !curr;\n\t\tmemset(f[curr], 0, sizeof(f[curr]));\n\t\tmemset(g[curr], 0, sizeof(g[curr]));\n\n\t\tg[curr][0][0] = f[curr][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= std::min(j, k); t++) {\n\t\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\t\tf[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD;\n\t\t\t\t\tg[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD;\n#ifdef DBG\n\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\", i, j, t, g[curr][j][t]);\n\t\t\t\t\tprintf(\"f[%d][%d][%d] = %d\\n\", i, j, t, f[curr][j][t]);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tf[curr][j][t] = 0;\n\t\t\t\t\tg[curr][j][t] = g[prev][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n```\n","slug":"noip2015-substring","published":1,"updated":"2016-11-02T06:50:28.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rlj00m2ooxlr531mhw2"},{"title":"NOIP2015 - ","date":"2016-10-19T08:30:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 4325](http://www.lydsy.com/JudgeOnline/problem.php?id=4325)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n 64 \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 13;\n\nconst int CARD_JOKER = 0;\nconst int CARD_2 = 1;\nconst int CARD_3 = 2;\nconst int CARD_4 = 3;\nconst int CARD_5 = 4;\nconst int CARD_6 = 5;\nconst int CARD_7 = 6;\nconst int CARD_8 = 7;\nconst int CARD_9 = 8;\nconst int CARD_10 = 9;\nconst int CARD_J = 10;\nconst int CARD_Q = 11;\nconst int CARD_K = 12;\nconst int CARD_A = 13;\n\ntypedef unsigned long long Status;\n\ninline int id(const int x) {\n\tif (x == 1) return 13;\n\treturn (x >= 2 && x <= 13) ? (x - 1) : x;\n}\n\ninline int get(const Status &s, const int index) {\n\treturn (s >> (index << 2)) & 15ll;\n}\n\n#ifdef DBG\ninline void print(const Status &s, const bool newLine = true) {\n\t// for (int i = 0; i < 64; i++) putchar((s & (1ll << i)) ? '1' : '0');\n\tfor (int i = 0; i < 14; i++) printf(\"%d \", get(s, i));\n\tif (newLine) putchar('\\n');\n}\n#endif\n\ninline void set(Status &s, const int index, const int val) {\n\t/*\n\tif (val < 0) {\n\t\tputs(\"???\");\n\t}\n\t*/\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"=> \");\n#endif\n\ts &= ~(15ll << (index << 2));\n\ts |= (val & 15ll) << (index << 2);\n#ifdef DBG\n\tprint(s);\n#endif\n}\n\ninline void change(Status &s, const int index, const int delta) {\n\tset(s, index, get(s, index) + delta);\n}\n\nint n, ans;\n// std::tr1::unordered_map<Status, int> map;\n\nstruct HashMap {\n\tconst static int HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tStatus key;\n\t\tint val, time;\n\t} N[HASH_SIZE];\n\n\tint time;\n\n\tHashMap() : time(1) {}\n\n\tint locate(const Status &key) {\n\t\tint i;\n\t\tfor (i = key % HASH_SIZE; N[i].time == time && N[i].key != key; (i < HASH_SIZE - 1) ? (i++) : (i = 0));\n\t\tif (N[i].time != time) {\n\t\t\tN[i].time = time;\n\t\t\tN[i].key = key;\n\t\t\tN[i].val = INT_MAX;\n\t\t}\n\t\treturn i;\n\t}\n\n\tint &operator[](const Status &key) {\n\t\treturn N[locate(key)].val;\n\t}\n\n\tvoid clear() {\n\t\ttime++;\n\t}\n} map;\n\ninline void search(const Status &s, const int step = 0) {\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"[%d, %d]\\n\", step, ans);\n#endif\n\tif (step >= ans) return;\n\n\tint &x = map[s];\n\tif (step >= x) return;\n\tx = step;\n\n\t/*\n\tstd::tr1::unordered_map<Status, int>::iterator it = map.find(s);\n\tif (it != map.end() && step >= it->second) return;\n\tmap[s] = step;\n\t*/\n\n\tif (!s) {\n\t\tans = step;\n\t\treturn;\n\t}\n\n\t// 333 444\n\tfor (int i = CARD_3; i <= CARD_K; i++) {\n\t\tStatus next = s;\n\t\tint x = get(next, i);\n\t\tif (x < 3) {\n\t\t\tcontinue;\n\t\t} else set(next, i, x - 3);\n\n\t\tfor (int j = i + 1; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 3) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 3);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 33 44 55\n\tfor (int i = CARD_3; i <= CARD_Q; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 2; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 2);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 2; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3 4 5 6 7\n\tfor (int i = CARD_3; i <= CARD_10; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 4; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 1);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 4; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::vector<int> four, three, two, one;\n\tfor (int i = CARD_JOKER; i <= CARD_A; i++) {\n\t\tint x = get(s, i);\n\t\tif (x == 4) four.push_back(i);\n\t\telse if (x == 3) three.push_back(i);\n\t\telse if (x == 2) two.push_back(i);\n\t\telse if (x == 1) one.push_back(i);\n\t}\n\n\t// 2222 [3 4] / 2222 [33 44]\n\tfor (std::vector<int>::const_iterator it = four.begin(); it != four.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) continue;\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != two.end(); b++) {\n\t\t\t\tif (*b == 0) continue;\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -2);\n\t\t\t\tchange(next, *b, -2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = four.begin(); a != four.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != one.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -1);\n\t\t\t\tchange(next, *b, -1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 222 [3] / 222 [33]\n\tfor (std::vector<int>::const_iterator it = three.begin(); it != three.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = three.begin(); a != three.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) {\n\t\t\t\t// Take only one joker\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 22\n\tfor (std::vector<int>::const_iterator it = two.begin(); it != two.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n\n\t// 2\n\tfor (std::vector<int>::const_iterator it = one.begin(); it != one.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d %d\", &t, &n);\n\twhile (t--) {\n\t\tStatus init = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tchange(init, id(a), 1);\n\t\t}\n\n\t\tmap.clear();\n\t\tans = INT_MAX;\n\t\tsearch(init);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2015-landlords.md","raw":"title: NOIP2015 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BZOJ\n  - \npermalink: noip2015-landlords\ndate: 2016-10-19 16:30:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4325](http://www.lydsy.com/JudgeOnline/problem.php?id=4325)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n 64 \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 13;\n\nconst int CARD_JOKER = 0;\nconst int CARD_2 = 1;\nconst int CARD_3 = 2;\nconst int CARD_4 = 3;\nconst int CARD_5 = 4;\nconst int CARD_6 = 5;\nconst int CARD_7 = 6;\nconst int CARD_8 = 7;\nconst int CARD_9 = 8;\nconst int CARD_10 = 9;\nconst int CARD_J = 10;\nconst int CARD_Q = 11;\nconst int CARD_K = 12;\nconst int CARD_A = 13;\n\ntypedef unsigned long long Status;\n\ninline int id(const int x) {\n\tif (x == 1) return 13;\n\treturn (x >= 2 && x <= 13) ? (x - 1) : x;\n}\n\ninline int get(const Status &s, const int index) {\n\treturn (s >> (index << 2)) & 15ll;\n}\n\n#ifdef DBG\ninline void print(const Status &s, const bool newLine = true) {\n\t// for (int i = 0; i < 64; i++) putchar((s & (1ll << i)) ? '1' : '0');\n\tfor (int i = 0; i < 14; i++) printf(\"%d \", get(s, i));\n\tif (newLine) putchar('\\n');\n}\n#endif\n\ninline void set(Status &s, const int index, const int val) {\n\t/*\n\tif (val < 0) {\n\t\tputs(\"???\");\n\t}\n\t*/\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"=> \");\n#endif\n\ts &= ~(15ll << (index << 2));\n\ts |= (val & 15ll) << (index << 2);\n#ifdef DBG\n\tprint(s);\n#endif\n}\n\ninline void change(Status &s, const int index, const int delta) {\n\tset(s, index, get(s, index) + delta);\n}\n\nint n, ans;\n// std::tr1::unordered_map<Status, int> map;\n\nstruct HashMap {\n\tconst static int HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tStatus key;\n\t\tint val, time;\n\t} N[HASH_SIZE];\n\n\tint time;\n\n\tHashMap() : time(1) {}\n\n\tint locate(const Status &key) {\n\t\tint i;\n\t\tfor (i = key % HASH_SIZE; N[i].time == time && N[i].key != key; (i < HASH_SIZE - 1) ? (i++) : (i = 0));\n\t\tif (N[i].time != time) {\n\t\t\tN[i].time = time;\n\t\t\tN[i].key = key;\n\t\t\tN[i].val = INT_MAX;\n\t\t}\n\t\treturn i;\n\t}\n\n\tint &operator[](const Status &key) {\n\t\treturn N[locate(key)].val;\n\t}\n\n\tvoid clear() {\n\t\ttime++;\n\t}\n} map;\n\ninline void search(const Status &s, const int step = 0) {\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"[%d, %d]\\n\", step, ans);\n#endif\n\tif (step >= ans) return;\n\n\tint &x = map[s];\n\tif (step >= x) return;\n\tx = step;\n\n\t/*\n\tstd::tr1::unordered_map<Status, int>::iterator it = map.find(s);\n\tif (it != map.end() && step >= it->second) return;\n\tmap[s] = step;\n\t*/\n\n\tif (!s) {\n\t\tans = step;\n\t\treturn;\n\t}\n\n\t// 333 444\n\tfor (int i = CARD_3; i <= CARD_K; i++) {\n\t\tStatus next = s;\n\t\tint x = get(next, i);\n\t\tif (x < 3) {\n\t\t\tcontinue;\n\t\t} else set(next, i, x - 3);\n\n\t\tfor (int j = i + 1; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 3) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 3);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 33 44 55\n\tfor (int i = CARD_3; i <= CARD_Q; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 2; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 2);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 2; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3 4 5 6 7\n\tfor (int i = CARD_3; i <= CARD_10; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 4; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 1);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 4; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::vector<int> four, three, two, one;\n\tfor (int i = CARD_JOKER; i <= CARD_A; i++) {\n\t\tint x = get(s, i);\n\t\tif (x == 4) four.push_back(i);\n\t\telse if (x == 3) three.push_back(i);\n\t\telse if (x == 2) two.push_back(i);\n\t\telse if (x == 1) one.push_back(i);\n\t}\n\n\t// 2222 [3 4] / 2222 [33 44]\n\tfor (std::vector<int>::const_iterator it = four.begin(); it != four.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) continue;\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != two.end(); b++) {\n\t\t\t\tif (*b == 0) continue;\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -2);\n\t\t\t\tchange(next, *b, -2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = four.begin(); a != four.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != one.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -1);\n\t\t\t\tchange(next, *b, -1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 222 [3] / 222 [33]\n\tfor (std::vector<int>::const_iterator it = three.begin(); it != three.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = three.begin(); a != three.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) {\n\t\t\t\t// Take only one joker\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 22\n\tfor (std::vector<int>::const_iterator it = two.begin(); it != two.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n\n\t// 2\n\tfor (std::vector<int>::const_iterator it = one.begin(); it != one.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d %d\", &t, &n);\n\twhile (t--) {\n\t\tStatus init = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tchange(init, id(a), 1);\n\t\t}\n\n\t\tmap.clear();\n\t\tans = INT_MAX;\n\t\tsearch(init);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2015-landlords","published":1,"updated":"2016-10-19T08:32:59.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rlm00m7ooxlo7pfy78d"},{"title":"NOIP2014 - Hash","date":"2016-10-19T08:25:00.000Z","_content":"\n\n\n$$ a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $$\n\n $ [1, m] $ \n\n<!-- more -->\n\n### \n[BZOJ 3751](http://www.lydsy.com/JudgeOnline/problem.php?id=3751)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n $ f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $ $ p $  $ f(x) = 0 $ $ f(x) \\bmod p = 0 $\n\n $ f(x) \\bmod p = 0 $  $ x $ $ n $  $ x' = x + kp \\leq m $  $ p' $  $ f(x') \\bmod p' = 0 $ $ x' $ \n\n $ O(np + n \\frac{nm}{p}) $ $ p \\approx \\sqrt {nm} $  $ O(n \\sqrt{nm}) $\n\n### \n```c++\n#include <cstdio>\n#include <list>\n\nconst int MAXN = 100;\nconst int MAXLEN = 10000 + 1;\nconst int MAXM = 1000000;\nconst int MOD = 21893;\nconst int MOD2 = 18341629;\n\nint parse(const char *s, const int mod) {\n\tint res = 0, sgn = 1;\n\tif (*s == '-') s++, sgn = -1;\n\tfor (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod;\n\treturn res * sgn;\n}\n\nint main() {\n\tstatic char s[MAXN + 1][MAXLEN + 1];\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 0; i <= n; i++) a[i] = parse(s[i], MOD);\n\n\tstd::list<int> roots;\n\tfor (int i = 1; i < MOD; i++) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD;\n\t\t\tpow = pow * i % MOD;\n\t\t}\n\t\t\n\t\tif (val == 0) {\n\t\t\tfor (int j = i; j <= m; j += MOD) roots.push_back(j);\n\t\t}\n\t}\n\n\tfor (int j = 0; j <= n; j++) a[j] = parse(s[j], MOD2);\n\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD2;\n\t\t\tpow = pow * *it % MOD2;\n\t\t}\n\n\t\tif (val != 0) it = roots.erase(it);\n\t\telse it++;\n\t}\n\n\tprintf(\"%lu\\n\", roots.size());\n\troots.sort();\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","source":"_posts/noip2014-equation.md","raw":"title: NOIP2014 - Hash\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BZOJ\n  - Hash\n  - \npermalink: noip2014-equation\ndate: 2016-10-19 16:25:00\n---\n\n\n\n$$ a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $$\n\n $ [1, m] $ \n\n<!-- more -->\n\n### \n[BZOJ 3751](http://www.lydsy.com/JudgeOnline/problem.php?id=3751)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n $ f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $ $ p $  $ f(x) = 0 $ $ f(x) \\bmod p = 0 $\n\n $ f(x) \\bmod p = 0 $  $ x $ $ n $  $ x' = x + kp \\leq m $  $ p' $  $ f(x') \\bmod p' = 0 $ $ x' $ \n\n $ O(np + n \\frac{nm}{p}) $ $ p \\approx \\sqrt {nm} $  $ O(n \\sqrt{nm}) $\n\n### \n```c++\n#include <cstdio>\n#include <list>\n\nconst int MAXN = 100;\nconst int MAXLEN = 10000 + 1;\nconst int MAXM = 1000000;\nconst int MOD = 21893;\nconst int MOD2 = 18341629;\n\nint parse(const char *s, const int mod) {\n\tint res = 0, sgn = 1;\n\tif (*s == '-') s++, sgn = -1;\n\tfor (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod;\n\treturn res * sgn;\n}\n\nint main() {\n\tstatic char s[MAXN + 1][MAXLEN + 1];\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 0; i <= n; i++) a[i] = parse(s[i], MOD);\n\n\tstd::list<int> roots;\n\tfor (int i = 1; i < MOD; i++) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD;\n\t\t\tpow = pow * i % MOD;\n\t\t}\n\t\t\n\t\tif (val == 0) {\n\t\t\tfor (int j = i; j <= m; j += MOD) roots.push_back(j);\n\t\t}\n\t}\n\n\tfor (int j = 0; j <= n; j++) a[j] = parse(s[j], MOD2);\n\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD2;\n\t\t\tpow = pow * *it % MOD2;\n\t\t}\n\n\t\tif (val != 0) it = roots.erase(it);\n\t\telse it++;\n\t}\n\n\tprintf(\"%lu\\n\", roots.size());\n\troots.sort();\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","slug":"noip2014-equation","published":1,"updated":"2016-10-19T08:26:26.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rlp00mdooxln4fgznoz"},{"title":"NOIP2014 -  DP","date":"2016-10-08T09:06:00.000Z","_content":"\n*  $ n $ $ m $  $ k $ \n* \n*  $ 1 $ $ X $ $ Y $ $ X $  $ Y $ \n*  $ 0 $  $ m $ \n\n,\n\n<!-- more -->\n\n### \n[COGS 1805](http://cogs.pro/cogs/problem/problem.php?pid=1805)  \n[CodeVS 3729](http://codevs.cn/problem/3729/)\n\n### \n $ f(i, j) $  $ i $ $ j $ \n\n   $ i - 1 $  $ k $  $ k \\times X $  $ Y $  $ k $\n\n$$\nf(i, j) = \\min(\\min\\limits_k \\{ f(i - 1, j - kX) \\} + k, f(i - 1, j + Y))\n$$\n\n $ O(m) $ $ O(nm ^ 2) $\n\n $ k $  $ k - 1 $  $ k $  $ j $ $ k - 1 $  $ j - X $\n\n$$ f(i, j) = \\min(f(i - 1, j - X) + 1, f(i, j - X) + 1) $$\n\n\n\n   $ k - 1 $  $ k $  $ k $  $ k - 1 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n\tbool exist;\n\tint top, bottom;\n} a[MAXN + 1];\n\nint n, m, k, up[MAXN + 1], down[MAXN + 1];\n\ntemplate <typename T> bool cmin(T &a, const T &b) {\n\treturn (a > b) ? (a = b, true) : false;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &up[i], &down[i]);\n\t}\n\n\twhile (k--) {\n\t\tint i;\n\t\tscanf(\"%d\", &i);\n\t\tscanf(\"%d %d\", &a[i].bottom, &a[i].top);\n\t\ta[i].exist = true;\n\t}\n\n\tstatic int f[MAXN + 1][MAXM + 1];\n\t// for (int i = 1; i <= m; i++) f[0][i] = 0;\n\tf[0][0] = INT_MAX;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = INT_MAX;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tf[i][j] = INT_MAX;\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\n\t\t\tif (j >= up[i - 1]) {\n\t\t\t\tif (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1);\n\t\t\t\tif (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (j <= m - down[i - 1]) {\n\t\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t\t}\n\t\t\t*/\n\n#ifdef DBG\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n#endif\n\t\t}\n\n\t\tfor (int j = 1; j <= m - down[i - 1]; j++) {\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t}\n\n\t\tf[i][m] = INT_MAX;\n\t\t// if (a[i].exist) continue;\n\t\tfor (int k = m - up[i - 1]; k <= m; k++) {\n\t\t\tif (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n\t\t\tif (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n\t\t}\n\n\t\tif (a[i].exist) for (int j = 1; j <= m; j++) if (j <= a[i].bottom || j >= a[i].top) f[i][j] = INT_MAX;\n\t}\n\n\tint clicks = INT_MAX;\n\tfor (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n\n\tif (clicks != INT_MAX) {\n\t\tprintf(\"1\\n%d\\n\", clicks);\n\t} else {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (f[i][j] != INT_MAX) {\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos != -1) break;\n\t\t}\n\n\t\tint pipeCnt = 0;\n\t\tfor (int i = 1; i <= pos; i++) if (a[i].exist) pipeCnt++;\n\n\t\tprintf(\"0\\n%d\\n\", pipeCnt);\n\t}\n\n\treturn 0;\n}\n```\t\n","source":"_posts/noip2014-bird.md","raw":"title: NOIP2014 -  DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - COGS\n  - DP\n  -  DP\npermalink: noip2014-bird\ndate: 2016-10-08 17:06:00\n---\n\n*  $ n $ $ m $  $ k $ \n* \n*  $ 1 $ $ X $ $ Y $ $ X $  $ Y $ \n*  $ 0 $  $ m $ \n\n,\n\n<!-- more -->\n\n### \n[COGS 1805](http://cogs.pro/cogs/problem/problem.php?pid=1805)  \n[CodeVS 3729](http://codevs.cn/problem/3729/)\n\n### \n $ f(i, j) $  $ i $ $ j $ \n\n   $ i - 1 $  $ k $  $ k \\times X $  $ Y $  $ k $\n\n$$\nf(i, j) = \\min(\\min\\limits_k \\{ f(i - 1, j - kX) \\} + k, f(i - 1, j + Y))\n$$\n\n $ O(m) $ $ O(nm ^ 2) $\n\n $ k $  $ k - 1 $  $ k $  $ j $ $ k - 1 $  $ j - X $\n\n$$ f(i, j) = \\min(f(i - 1, j - X) + 1, f(i, j - X) + 1) $$\n\n\n\n   $ k - 1 $  $ k $  $ k $  $ k - 1 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n\tbool exist;\n\tint top, bottom;\n} a[MAXN + 1];\n\nint n, m, k, up[MAXN + 1], down[MAXN + 1];\n\ntemplate <typename T> bool cmin(T &a, const T &b) {\n\treturn (a > b) ? (a = b, true) : false;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &up[i], &down[i]);\n\t}\n\n\twhile (k--) {\n\t\tint i;\n\t\tscanf(\"%d\", &i);\n\t\tscanf(\"%d %d\", &a[i].bottom, &a[i].top);\n\t\ta[i].exist = true;\n\t}\n\n\tstatic int f[MAXN + 1][MAXM + 1];\n\t// for (int i = 1; i <= m; i++) f[0][i] = 0;\n\tf[0][0] = INT_MAX;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = INT_MAX;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tf[i][j] = INT_MAX;\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\n\t\t\tif (j >= up[i - 1]) {\n\t\t\t\tif (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1);\n\t\t\t\tif (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (j <= m - down[i - 1]) {\n\t\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t\t}\n\t\t\t*/\n\n#ifdef DBG\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n#endif\n\t\t}\n\n\t\tfor (int j = 1; j <= m - down[i - 1]; j++) {\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t}\n\n\t\tf[i][m] = INT_MAX;\n\t\t// if (a[i].exist) continue;\n\t\tfor (int k = m - up[i - 1]; k <= m; k++) {\n\t\t\tif (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n\t\t\tif (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n\t\t}\n\n\t\tif (a[i].exist) for (int j = 1; j <= m; j++) if (j <= a[i].bottom || j >= a[i].top) f[i][j] = INT_MAX;\n\t}\n\n\tint clicks = INT_MAX;\n\tfor (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n\n\tif (clicks != INT_MAX) {\n\t\tprintf(\"1\\n%d\\n\", clicks);\n\t} else {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (f[i][j] != INT_MAX) {\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos != -1) break;\n\t\t}\n\n\t\tint pipeCnt = 0;\n\t\tfor (int i = 1; i <= pos; i++) if (a[i].exist) pipeCnt++;\n\n\t\tprintf(\"0\\n%d\\n\", pipeCnt);\n\t}\n\n\treturn 0;\n}\n```\t\n","slug":"noip2014-bird","published":1,"updated":"2016-11-08T12:07:12.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rlu00mlooxlgdr1hbkg"},{"title":"NOIP2013 - BFS + SPFA","date":"2016-11-13T09:00:00.000Z","_content":"\n1.  $ n \\times m $  $ n\\times m $  $ n \\times m - 1 $  $ 1 \\times 1 $ \n2. \n3. \n\n $ q $  $ i $  $ EX_i $  $ EY_i $  $ SX_i $  $ SY_i $  $ TX_i $  $ TY_i $ \n\n B  B \n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n  \n\n $ f(i, j, a, b) $  $ (i, j) $ $ a $  $ b $ \n\n\n\n1. \n2. \n\n $ (i, j, k) $    $ (i, j) $  $ k $  $ f(i, j, a, b) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXQ = 500;\nconst int di[] = { 1, 0, 0, -1 };\nconst int dj[] = { 0, 1, -1, 0 };\n\nint n, m;\n\nstruct Node {\n\tbool invalid;\n\tint cost[4][4];\n\tint dist;    // BFS prepare\n\tstruct {\n\t\tint dist;\n\t\tbool inq;\n\t} v[4];      // SPFA\n} map[MAXN + 1][MAXN + 1];\n\nstruct Point {\n\tint i, j;\n\n\tPoint() {}\n\tPoint(int i, int j) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n\n\tbool valid() const {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tbool operator==(const Point &other) const {\n\t\treturn i == other.i && j == other.j;\n\t}\n};\n\nstruct Status {\n\tPoint p;\n\tint d;\n\n\tStatus(Point p, int d) : p(p), d(d) {}\n};\n\ninline int bfs(Point s, Point t, Point p) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmap[i][j].dist = INT_MAX;\n\t\t}\n\t}\n\n\tstd::queue<Point> q;\n\ts->dist = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return v->dist;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\n\t\t\tif (u->invalid || u == p) continue;\n\n\t\t\tif (u->dist > v->dist + 1) {\n\t\t\t\tu->dist = v->dist + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (map[i][j].invalid) continue;\n\n\t\t\tPoint v(i, j);\n\t\t\tfor (int s = 0; s < 4; s++) {\n\t\t\t\tPoint ps = v.move(s);\n\n\t\t\t\tfor (int t = s + 1; t < 4; t++) {\n\t\t\t\t\tPoint pt = v.move(t);\n\n\t\t\t\t\tif (!ps.valid() || ps->invalid || !pt.valid() || pt->invalid) v->cost[s][t] = v->cost[t][s] = INT_MAX;\n\t\t\t\t\telse v->cost[s][t] = v->cost[t][s] = bfs(ps, pt, v);\n\n#ifdef DBG\n\t\t\t\t\tprintf(\"[%d, %d] %d => %d = %d\\n\", v.i, v.j, s, t, v->cost[s][t]);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int spfa(Status s, Point t) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmap[i][j].v[k].dist = INT_MAX;\n\t\t\t\tmap[i][j].v[k].inq = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::queue<Status> q;\n\tq.push(s);\n\ts.p->v[s.d].dist = 0;\n\n\twhile (!q.empty()) {\n\t\tStatus status = q.front();\n\t\tq.pop();\n\n\t\tPoint &v = status.p;\n\t\tint &d = status.d;\n\n\t\tv->v[d].inq = false;\n\n\t\t// Move the empty block\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i == d || v->cost[d][i] == INT_MAX) continue;\n\n\t\t\tif (v->v[i].dist > v->v[d].dist + v->cost[d][i]) {\n\t\t\t\tv->v[i].dist = v->v[d].dist + v->cost[d][i];\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d]->v[%d]->dist = %d\\n\", v.i, v.j, i, v->v[i].dist);\n#endif\n\t\t\t\tif (!v->v[i].inq) {\n\t\t\t\t\tv->v[i].inq = true;\n\t\t\t\t\tq.push(Status(v, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap\n\t\tif (v->v[d].dist != INT_MAX) {\n\t\t\tPoint u = v.move(d);\n\t\t\tint t = 3 - d;\n\t\t\tif (u->v[t].dist > v->v[d].dist + 1) {\n\t\t\t\tu->v[t].dist = v->v[d].dist + 1;\n\t\t\t\tif (!u->v[t].inq) {\n\t\t\t\t\tu->v[t].inq = true;\n\t\t\t\t\tq.push(Status(u, t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INT_MAX;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = std::min(res, t->v[i].dist);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmap[i][j].invalid = (x == 0);\n\t\t}\n\t}\n\n\tprepare();\n\n\twhile (q--) {\n\t\tPoint empty, s, t;\n\t\tscanf(\"%d %d %d %d %d %d\", &empty.i, &empty.j, &s.i, &s.j, &t.i, &t.j);\n\n\t\tif (s == t) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v = s.move(i);\n\t\t\tif (!v.valid()) continue;\n\n\t\t\tint d1 = bfs(empty, v, s);\n\t\t\tif (d1 == INT_MAX) continue;\n\n\t\t\tint d2 = spfa(Status(s, i), t);\n\t\t\tif (d2 == INT_MAX) continue;\n\n\t\t\tans = std::min(ans, d1 + d2);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2013-puzzle.md","raw":"title: NOIP2013 - BFS + SPFA\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \n  - SPFA\n  - BFS\npermalink: noip2013-puzzle\ndate: 2016-11-13 17:00:00\n---\n\n1.  $ n \\times m $  $ n\\times m $  $ n \\times m - 1 $  $ 1 \\times 1 $ \n2. \n3. \n\n $ q $  $ i $  $ EX_i $  $ EY_i $  $ SX_i $  $ SY_i $  $ TX_i $  $ TY_i $ \n\n B  B \n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n  \n\n $ f(i, j, a, b) $  $ (i, j) $ $ a $  $ b $ \n\n\n\n1. \n2. \n\n $ (i, j, k) $    $ (i, j) $  $ k $  $ f(i, j, a, b) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXQ = 500;\nconst int di[] = { 1, 0, 0, -1 };\nconst int dj[] = { 0, 1, -1, 0 };\n\nint n, m;\n\nstruct Node {\n\tbool invalid;\n\tint cost[4][4];\n\tint dist;    // BFS prepare\n\tstruct {\n\t\tint dist;\n\t\tbool inq;\n\t} v[4];      // SPFA\n} map[MAXN + 1][MAXN + 1];\n\nstruct Point {\n\tint i, j;\n\n\tPoint() {}\n\tPoint(int i, int j) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n\n\tbool valid() const {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tbool operator==(const Point &other) const {\n\t\treturn i == other.i && j == other.j;\n\t}\n};\n\nstruct Status {\n\tPoint p;\n\tint d;\n\n\tStatus(Point p, int d) : p(p), d(d) {}\n};\n\ninline int bfs(Point s, Point t, Point p) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmap[i][j].dist = INT_MAX;\n\t\t}\n\t}\n\n\tstd::queue<Point> q;\n\ts->dist = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return v->dist;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\n\t\t\tif (u->invalid || u == p) continue;\n\n\t\t\tif (u->dist > v->dist + 1) {\n\t\t\t\tu->dist = v->dist + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (map[i][j].invalid) continue;\n\n\t\t\tPoint v(i, j);\n\t\t\tfor (int s = 0; s < 4; s++) {\n\t\t\t\tPoint ps = v.move(s);\n\n\t\t\t\tfor (int t = s + 1; t < 4; t++) {\n\t\t\t\t\tPoint pt = v.move(t);\n\n\t\t\t\t\tif (!ps.valid() || ps->invalid || !pt.valid() || pt->invalid) v->cost[s][t] = v->cost[t][s] = INT_MAX;\n\t\t\t\t\telse v->cost[s][t] = v->cost[t][s] = bfs(ps, pt, v);\n\n#ifdef DBG\n\t\t\t\t\tprintf(\"[%d, %d] %d => %d = %d\\n\", v.i, v.j, s, t, v->cost[s][t]);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int spfa(Status s, Point t) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmap[i][j].v[k].dist = INT_MAX;\n\t\t\t\tmap[i][j].v[k].inq = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::queue<Status> q;\n\tq.push(s);\n\ts.p->v[s.d].dist = 0;\n\n\twhile (!q.empty()) {\n\t\tStatus status = q.front();\n\t\tq.pop();\n\n\t\tPoint &v = status.p;\n\t\tint &d = status.d;\n\n\t\tv->v[d].inq = false;\n\n\t\t// Move the empty block\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i == d || v->cost[d][i] == INT_MAX) continue;\n\n\t\t\tif (v->v[i].dist > v->v[d].dist + v->cost[d][i]) {\n\t\t\t\tv->v[i].dist = v->v[d].dist + v->cost[d][i];\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d]->v[%d]->dist = %d\\n\", v.i, v.j, i, v->v[i].dist);\n#endif\n\t\t\t\tif (!v->v[i].inq) {\n\t\t\t\t\tv->v[i].inq = true;\n\t\t\t\t\tq.push(Status(v, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap\n\t\tif (v->v[d].dist != INT_MAX) {\n\t\t\tPoint u = v.move(d);\n\t\t\tint t = 3 - d;\n\t\t\tif (u->v[t].dist > v->v[d].dist + 1) {\n\t\t\t\tu->v[t].dist = v->v[d].dist + 1;\n\t\t\t\tif (!u->v[t].inq) {\n\t\t\t\t\tu->v[t].inq = true;\n\t\t\t\t\tq.push(Status(u, t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INT_MAX;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = std::min(res, t->v[i].dist);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmap[i][j].invalid = (x == 0);\n\t\t}\n\t}\n\n\tprepare();\n\n\twhile (q--) {\n\t\tPoint empty, s, t;\n\t\tscanf(\"%d %d %d %d %d %d\", &empty.i, &empty.j, &s.i, &s.j, &t.i, &t.j);\n\n\t\tif (s == t) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v = s.move(i);\n\t\t\tif (!v.valid()) continue;\n\n\t\t\tint d1 = bfs(empty, v, s);\n\t\t\tif (d1 == INT_MAX) continue;\n\n\t\t\tint d2 = spfa(Status(s, i), t);\n\t\t\tif (d2 == INT_MAX) continue;\n\n\t\t\tans = std::min(ans, d1 + d2);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noip2013-puzzle","published":1,"updated":"2016-11-13T10:35:58.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rly00msooxlf3pyicvr"},{"title":"NOIP2013 - ","date":"2016-10-13T08:15:00.000Z","_content":"\n $ n $ \n\n$$ \\sum\\limits_{i = 1} ^ n (a_i - b_i) ^ 2 $$\n\n $ a_i $  $ i $ $ b_i $  $ i $ \n\n\n\n<!-- more -->\n\n### \n[CodeVS 3286](http://codevs.cn/problem/3286/)\n\n### \n $ k \\in [1, n] $ $ k $  $ k $ \n\n $ a $ $ i $  $ k $  $ k $  $ j $  $ a[i] = j $ $ a $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Match {\n\tint index, rank, value, w;\n} a[MAXN + 1], b[MAXN + 1];\n\nint n;\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n} bit;\n\ninline bool byVal(const Match &a, const Match &b) {\n\treturn a.value < b.value;\n}\n\ninline bool byID(const Match &a, const Match &b) {\n\treturn a.index < b.index;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].value), a[i].index = i;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &b[i].value), b[i].index = i;\n\n\tstd::sort(a + 1, a + n + 1, &byVal);\n\tstd::sort(b + 1, b + n + 1, &byVal);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].rank = b[i].rank = i;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i].w = a[i].index;\n\t}\n\n\tstd::sort(b + 1, b + n + 1, &byID);\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d\\n\", b[i].w);\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += bit.query(b[i].w + 1, n);\n\t\tbit.update(b[i].w, 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans % MOD);\n\n\treturn 0;\n}\n```","source":"_posts/noip2013-match.md","raw":"title: NOIP2013 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \npermalink: noip2013-match\ndate: 2016-10-13 16:15:00\n---\n\n $ n $ \n\n$$ \\sum\\limits_{i = 1} ^ n (a_i - b_i) ^ 2 $$\n\n $ a_i $  $ i $ $ b_i $  $ i $ \n\n\n\n<!-- more -->\n\n### \n[CodeVS 3286](http://codevs.cn/problem/3286/)\n\n### \n $ k \\in [1, n] $ $ k $  $ k $ \n\n $ a $ $ i $  $ k $  $ k $  $ j $  $ a[i] = j $ $ a $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Match {\n\tint index, rank, value, w;\n} a[MAXN + 1], b[MAXN + 1];\n\nint n;\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n} bit;\n\ninline bool byVal(const Match &a, const Match &b) {\n\treturn a.value < b.value;\n}\n\ninline bool byID(const Match &a, const Match &b) {\n\treturn a.index < b.index;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].value), a[i].index = i;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &b[i].value), b[i].index = i;\n\n\tstd::sort(a + 1, a + n + 1, &byVal);\n\tstd::sort(b + 1, b + n + 1, &byVal);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].rank = b[i].rank = i;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i].w = a[i].index;\n\t}\n\n\tstd::sort(b + 1, b + n + 1, &byID);\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d\\n\", b[i].w);\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += bit.query(b[i].w + 1, n);\n\t\tbit.update(b[i].w, 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans % MOD);\n\n\treturn 0;\n}\n```","slug":"noip2013-match","published":1,"updated":"2016-11-13T08:15:38.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rm500n1ooxlmjs77nnl"},{"title":"NOIP2013 - ","date":"2016-10-13T08:42:00.000Z","_content":"\n\n\n $ h_1, h_2, \\ldots, h_n $ $ g_1, g_2, \\ldots, g_m $\n\n A $ 1 < i < \\frac{m}{2} $$ g_{2i} > g_{2i - 1} $  $ g_{2i} > g_{2i + 1} $  \n B $ 1 < i < \\frac{m}{2} $$ g_{2i} < g_{2i - 1} $  $ g_{2i} < g_{2i + 1} $\n\n $ m = 1 $  $ m > 1 $   \n\n\n<!-- more -->\n\n### \n[CodeVS 3289](http://codevs.cn/problem/3289/)\n\n### \n\n\n $ x $  $ y $ $ z $ \n\n $ x < y $  $ y > z $$ x > y $  $ y < z $ $ z $  $ + 1 $\n\n $ x < y $  $ y < z $$ x > y $  $ y > z $ $ z $  $ y $ $ z $  $ k < y < z $  $ k $  $ z $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint prev, curr, ans = 1;\n\tscanf(\"%d\", &curr);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (x == curr) continue;\n\n\t\tif (ans == 1 || (prev < curr) != (curr < x)) {\n\t\t\tans++;\n\t\t\tprev = curr;\n\t\t\tcurr = x;\n\t\t} else {\n\t\t\tif (prev < curr) curr = std::max(curr, x);\n\t\t\telse curr = std::min(curr, x);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/noip2013-flower.md","raw":"title: NOIP2013 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \npermalink: noip2013-flower\ndate: 2016-10-13 16:42:00\n---\n\n\n\n $ h_1, h_2, \\ldots, h_n $ $ g_1, g_2, \\ldots, g_m $\n\n A $ 1 < i < \\frac{m}{2} $$ g_{2i} > g_{2i - 1} $  $ g_{2i} > g_{2i + 1} $  \n B $ 1 < i < \\frac{m}{2} $$ g_{2i} < g_{2i - 1} $  $ g_{2i} < g_{2i + 1} $\n\n $ m = 1 $  $ m > 1 $   \n\n\n<!-- more -->\n\n### \n[CodeVS 3289](http://codevs.cn/problem/3289/)\n\n### \n\n\n $ x $  $ y $ $ z $ \n\n $ x < y $  $ y > z $$ x > y $  $ y < z $ $ z $  $ + 1 $\n\n $ x < y $  $ y < z $$ x > y $  $ y > z $ $ z $  $ y $ $ z $  $ k < y < z $  $ k $  $ z $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint prev, curr, ans = 1;\n\tscanf(\"%d\", &curr);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (x == curr) continue;\n\n\t\tif (ans == 1 || (prev < curr) != (curr < x)) {\n\t\t\tans++;\n\t\t\tprev = curr;\n\t\t\tcurr = x;\n\t\t} else {\n\t\t\tif (prev < curr) curr = std::max(curr, x);\n\t\t\telse curr = std::min(curr, x);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"noip2013-flower","published":1,"updated":"2016-11-13T08:42:45.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rm900n8ooxltf4y1ddn"},{"title":"NOIP2012 - ","date":"2016-01-19T13:20:19.000Z","_content":"\n `x`  $ax  1 ({\\rm mod} \\ b)$ \n\n<!-- more -->\n\n### \n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### \n `x`  `b` `b` \n\n### \n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-mod.md","raw":"title: NOIP2012 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Tyvj\n  - \n  - EXGCD\n  - \npermalink: noip2012-mod\ndate: 2016-01-19 21:20:19\n---\n\n `x`  $ax  1 ({\\rm mod} \\ b)$ \n\n<!-- more -->\n\n### \n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### \n `x`  `b` `b` \n\n### \n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","slug":"noip2012-mod","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rmc00ndooxlkjffopq1"},{"title":"NOIP2012 - ","date":"2016-11-13T09:14:00.000Z","_content":"\n A  B  $ 1 $  $ N $  $ i $  $ H_i $ $ i $  $ j $  $ d(i, j) $  $ d(i, j) = |H_i  H_j| $\n\n A  B  A  $ S $  $ X $  A  B  B  A  $ X $ \n\n A \n\n1.  $ X = X_0 $ A  B  B  $ 0 $ A  B \n2.  $ X = X_i $  $ S_i $ A  B \n\n<!-- more -->\n\n### \n[CodeVS 1199](http://codevs.cn/problem/1199/)\n\n### \n +  A  B \n\n $ f(k, i, j) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $ $ g(k, i, j, l) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $  A$ l = 0 $ B$ l = 1 $ $ l = 2 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\nconst int MAXM = 10000;\n\nstruct Node {\n\tlong long x;\n\tNode *nextA, *nextB;\n\tstd::list<Node *>::iterator it;\n} N[MAXN + 1];\n\nint n, logn, f[2][MAXN + 1][MAXN_LOG + 1];\nlong long g[2][MAXN + 1][MAXN_LOG + 1][3];\n\ninline bool compareNode(Node *a, Node *b) {\n\treturn a->x < b->x;\n}\n\ninline bool comparePair(const std::pair<long long, Node *> &a, const std::pair<long long, Node *> &b) {\n\tif (a.first == b.first) return a.second->x < b.second->x;\n\telse return a.first < b.first;\n}\n\ninline void prepare() {\n\tstd::list<Node *> list;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlist.push_back(&N[i]);\n\t\tN[i].it = --list.end();\n\t}\n\n\tlist.sort(&compareNode);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tstd::vector< std::pair<long long, Node *> > vec;\n\n\t\tstd::list<Node *>::iterator near;\n\t\tnear = N[i].it, near++;\n\n\t\tif (near != list.end()) {\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (++near != list.end()) {\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tnear = N[i].it;\n\t\tif (near != list.begin()) {\n\t\t\tnear--;\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (near != list.begin()) {\n\t\t\t\tnear--;\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(vec.begin(), vec.end(), comparePair);\n\n\t\tif (vec.size() >= 2) {\n\t\t\tN[i].nextA = vec[1].second;\n#ifdef DBG\n\t\t\tprintf(\"nextA(%lld) = %lld\\n\", N[i].x, N[i].nextA->x);\n#endif\n\t\t} else N[i].nextA = &N[0];\n\n\t\tif (vec.size() >= 1) {\n\t\t\tN[i].nextB = vec[0].second;\n#ifdef DBG\n\t\t\tprintf(\"nextB(%lld) = %lld\\n\", N[i].x, N[i].nextB->x);\n#endif\n\t\t} else N[i].nextB = &N[0];\n\n\t\tlist.erase(N[i].it);\n\t}\n\tN[0].nextA = N[0].nextB = &N[0];\n\n\t// Build graph\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[0][i][0] = N[i].nextA - N;\n\t\tf[0][i][1] = N[i].nextA->nextB - N;\n\t\t\n\t\tf[1][i][0] = N[i].nextB - N;\n\t\tf[1][i][1] = N[i].nextB->nextA - N;\n\n\t\tg[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &N[0] ? 0 : llabs(N[i].x - N[i].nextA->x);\n\t\tg[0][i][0][1] = 0;\n\n\t\tg[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &N[0] ? 0 : llabs(N[i].x - N[i].nextB->x);\n\t\tg[1][i][0][0] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[0][i][1][0] = g[0][i][0][0];\n\t\tg[0][i][1][1] = g[1][N[i].nextA - N][0][1];\n\t\tg[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1];\n\n\t\tg[1][i][1][1] = g[1][i][0][1];\n\t\tg[1][i][1][0] = g[0][N[i].nextB - N][0][0];\n\t\tg[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0];\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 2; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tg[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l];\n\t\t\t\t}\n\t\t\t\tf[k][i][j] = f[k][f[k][i][j - 1]][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int j = 0; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tprintf(\"f(%d, %d, %d) = %d [%lld]\\n\\n\", k, i, j, f[k][i][j], N[f[k][i][j]].x);\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tprintf(\"g(%d, %d, %d, %d) = %lld\\n\", k, i, j, l, g[k][i][j][l]);\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\ninline long long solve(int start, long long limit, long long &sumA, long long &sumB) {\n\tint curr = start;\n\tlong long sum = sumA = sumB = 0;\n\tfor (int i = logn; i >= 1 && curr != 0; i--) {\n\t\twhile (curr && limit >= sum + g[0][curr][i][2]) {\n\t\t\tsum += g[0][curr][i][2];\n\t\t\tsumA += g[0][curr][i][0];\n\t\t\tsumB += g[0][curr][i][1];\n\t\t\tcurr = f[0][curr][i];\n\t\t}\n\t}\n\n\tif (curr && limit >= sum + g[0][curr][0][0]) {\n\t\tsumA += g[0][curr][0][0];\n\t\tsum += g[0][curr][0][0];\n\t}\n\n\treturn sum;\n}\n\ninline int solve(long long limit) {\n\tint ans = 0;\n\tdouble k = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long tmpA, tmpB;\n\t\tsolve(i, limit, tmpA, tmpB);\n\t\tdouble t = static_cast<double>(tmpA) / static_cast<double>(tmpB);\n\t\tif (k == -1 || t < k || (t == k && N[i].x > N[ans].x)) {\n\t\t\tk = t;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].x);\n\n\tprepare();\n\n\tlong long limit;\n\tscanf(\"%lld\", &limit);\n\tprintf(\"%d\\n\", solve(limit));\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint start;\n\t\tlong long limit;\n\t\tscanf(\"%d %lld\", &start, &limit);\n\t\tlong long sumA, sumB;\n\t\tsolve(start, limit, sumA, sumB);\n\t\tprintf(\"%lld %lld\\n\", sumA, sumB);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-drive.md","raw":"title: NOIP2012 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \npermalink: noip2012-drive\ndate: 2016-11-13 17:14:00\n---\n\n A  B  $ 1 $  $ N $  $ i $  $ H_i $ $ i $  $ j $  $ d(i, j) $  $ d(i, j) = |H_i  H_j| $\n\n A  B  A  $ S $  $ X $  A  B  B  A  $ X $ \n\n A \n\n1.  $ X = X_0 $ A  B  B  $ 0 $ A  B \n2.  $ X = X_i $  $ S_i $ A  B \n\n<!-- more -->\n\n### \n[CodeVS 1199](http://codevs.cn/problem/1199/)\n\n### \n +  A  B \n\n $ f(k, i, j) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $ $ g(k, i, j, l) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $  A$ l = 0 $ B$ l = 1 $ $ l = 2 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\nconst int MAXM = 10000;\n\nstruct Node {\n\tlong long x;\n\tNode *nextA, *nextB;\n\tstd::list<Node *>::iterator it;\n} N[MAXN + 1];\n\nint n, logn, f[2][MAXN + 1][MAXN_LOG + 1];\nlong long g[2][MAXN + 1][MAXN_LOG + 1][3];\n\ninline bool compareNode(Node *a, Node *b) {\n\treturn a->x < b->x;\n}\n\ninline bool comparePair(const std::pair<long long, Node *> &a, const std::pair<long long, Node *> &b) {\n\tif (a.first == b.first) return a.second->x < b.second->x;\n\telse return a.first < b.first;\n}\n\ninline void prepare() {\n\tstd::list<Node *> list;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlist.push_back(&N[i]);\n\t\tN[i].it = --list.end();\n\t}\n\n\tlist.sort(&compareNode);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tstd::vector< std::pair<long long, Node *> > vec;\n\n\t\tstd::list<Node *>::iterator near;\n\t\tnear = N[i].it, near++;\n\n\t\tif (near != list.end()) {\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (++near != list.end()) {\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tnear = N[i].it;\n\t\tif (near != list.begin()) {\n\t\t\tnear--;\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (near != list.begin()) {\n\t\t\t\tnear--;\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(vec.begin(), vec.end(), comparePair);\n\n\t\tif (vec.size() >= 2) {\n\t\t\tN[i].nextA = vec[1].second;\n#ifdef DBG\n\t\t\tprintf(\"nextA(%lld) = %lld\\n\", N[i].x, N[i].nextA->x);\n#endif\n\t\t} else N[i].nextA = &N[0];\n\n\t\tif (vec.size() >= 1) {\n\t\t\tN[i].nextB = vec[0].second;\n#ifdef DBG\n\t\t\tprintf(\"nextB(%lld) = %lld\\n\", N[i].x, N[i].nextB->x);\n#endif\n\t\t} else N[i].nextB = &N[0];\n\n\t\tlist.erase(N[i].it);\n\t}\n\tN[0].nextA = N[0].nextB = &N[0];\n\n\t// Build graph\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[0][i][0] = N[i].nextA - N;\n\t\tf[0][i][1] = N[i].nextA->nextB - N;\n\t\t\n\t\tf[1][i][0] = N[i].nextB - N;\n\t\tf[1][i][1] = N[i].nextB->nextA - N;\n\n\t\tg[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &N[0] ? 0 : llabs(N[i].x - N[i].nextA->x);\n\t\tg[0][i][0][1] = 0;\n\n\t\tg[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &N[0] ? 0 : llabs(N[i].x - N[i].nextB->x);\n\t\tg[1][i][0][0] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[0][i][1][0] = g[0][i][0][0];\n\t\tg[0][i][1][1] = g[1][N[i].nextA - N][0][1];\n\t\tg[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1];\n\n\t\tg[1][i][1][1] = g[1][i][0][1];\n\t\tg[1][i][1][0] = g[0][N[i].nextB - N][0][0];\n\t\tg[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0];\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 2; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tg[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l];\n\t\t\t\t}\n\t\t\t\tf[k][i][j] = f[k][f[k][i][j - 1]][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int j = 0; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tprintf(\"f(%d, %d, %d) = %d [%lld]\\n\\n\", k, i, j, f[k][i][j], N[f[k][i][j]].x);\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tprintf(\"g(%d, %d, %d, %d) = %lld\\n\", k, i, j, l, g[k][i][j][l]);\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\ninline long long solve(int start, long long limit, long long &sumA, long long &sumB) {\n\tint curr = start;\n\tlong long sum = sumA = sumB = 0;\n\tfor (int i = logn; i >= 1 && curr != 0; i--) {\n\t\twhile (curr && limit >= sum + g[0][curr][i][2]) {\n\t\t\tsum += g[0][curr][i][2];\n\t\t\tsumA += g[0][curr][i][0];\n\t\t\tsumB += g[0][curr][i][1];\n\t\t\tcurr = f[0][curr][i];\n\t\t}\n\t}\n\n\tif (curr && limit >= sum + g[0][curr][0][0]) {\n\t\tsumA += g[0][curr][0][0];\n\t\tsum += g[0][curr][0][0];\n\t}\n\n\treturn sum;\n}\n\ninline int solve(long long limit) {\n\tint ans = 0;\n\tdouble k = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long tmpA, tmpB;\n\t\tsolve(i, limit, tmpA, tmpB);\n\t\tdouble t = static_cast<double>(tmpA) / static_cast<double>(tmpB);\n\t\tif (k == -1 || t < k || (t == k && N[i].x > N[ans].x)) {\n\t\t\tk = t;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].x);\n\n\tprepare();\n\n\tlong long limit;\n\tscanf(\"%lld\", &limit);\n\tprintf(\"%d\\n\", solve(limit));\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint start;\n\t\tlong long limit;\n\t\tscanf(\"%d %lld\", &start, &limit);\n\t\tlong long sumA, sumB;\n\t\tsolve(start, limit, sumA, sumB);\n\t\tprintf(\"%lld %lld\\n\", sumA, sumB);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noip2012-drive","published":1,"updated":"2016-11-13T09:14:22.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rmh00nlooxl1idgmfrv"},{"title":"NOIP2012 -  / ","date":"2016-10-08T08:56:00.000Z","_content":"\n $ n $  $ i $  $ r_i $  $ m $  $ d_j, s_j, t_j $ $ s_j $  $ t_j $  $ s_j $  $ t_j $  $ d_j $  \n\n\n\n<!-- more -->\n\n### \n[COGS 1266](http://cogs.pro/cogs/problem/problem.php?pid=1266)  \n[CodeVS 1217](http://codevs.cn/problem/1217/)\n\n### \n#### \n\n\n 100 ** 95 **\n\n#### \n $ x $ +  $ x $ \n\n 100  100 \n\n### \nTLE\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 1000000;\nconst int MAXR = 1000000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar a[SIZE * sizeof(T)];\n\tT *p;\n\n\tMemoryPool() : p((T *)a) {}\n\n\tT *alloc() {\n\t\treturn p++;\n\t}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, min, lazy;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (lchild) lchild->value += lazy, lchild->min += lazy, lchild->lazy += lazy;\n\t\t\t\tif (rchild) rchild->value += lazy, rchild->min += lazy, rchild->lazy += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tint queryMin(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\t\telse if (l <= this->l && r >= this->r) return min;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tif (lchild) ans = std::min(ans, lchild->queryMin(l, r));\n\t\t\t\tif (rchild) ans = std::min(ans, rchild->queryMin(l, r));\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) value += x, min += x, lazy += x;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tif (lchild) lchild->update(l, r, x);\n\t\t\t\tif (rchild) rchild->update(l, r, x);\n\n\t\t\t\tmin = INT_MAX;\n\t\t\t\tif (lchild) min = std::min(min, lchild->min);\n\t\t\t\tif (rchild) min = std::min(min, rchild->min);\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tstatic MemoryPool<Node, MAXN * 2> pool;\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL);\n\t\telse return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tint queryMin(int l, int r) {\n\t\treturn root->queryMin(l, r);\n\t}\n\n\tvoid update(int l, int r, int x) {\n\t\troot->update(l, r, x);\n\t}\n};\n\nint n, m;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nint main() {\n\tread(n), read(m);\n\n\tSegmentTree segmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tread(x);\n\n\t\tsegmentTree.update(i, i, x);\n\t}\n\n\tint day = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, l, r;\n\t\tread(x), read(l), read(r);\n\n\t\tsegmentTree.update(l, r, -x);\n\t\tif (segmentTree.queryMin(1, n) < 0) {\n\t\t\tday = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (day != 0) printf(\"-1\\n%d\\n\", day);\n\telse puts(\"0\");\n\n\treturn 0;\n}\n```\n\nAC\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e6;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int available[MAXN];\n\tstatic struct Request {\n\t\tint l, r, cnt;\n\t} req[MAXN];\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &available[i]);\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d\", &req[i].cnt, &req[i].l, &req[i].r), req[i].l--, req[i].r--;\n\n\tint l = -1, r = m - 1;\n\tstatic int used[MAXN];\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tbool valid = true;\n\n\t\tfor (int i = 0; i < n; i++) used[i] = 0;\n\t\tfor (int i = 0; i <= mid; i++) {\n\t\t\tused[req[i].l] += req[i].cnt;\n\t\t\tif (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) used[i] += used[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] > available[i]) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"[%d, %d] => %d\\n\", l, r, mid);\n#endif\n\n\t\tif (valid) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\n\tif (l == m - 1) puts(\"0\");\n\telse printf(\"-1\\n%d\\n\", l + 1 + 1);\n\n\treturn 0;\n}\n```","source":"_posts/noip2012-classrooms.md","raw":"title: NOIP2012 -  / \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - COGS\n  - \n  - \n  - \npermalink: noip2012-classrooms\ndate: 2016-10-08 16:56:00\n---\n\n $ n $  $ i $  $ r_i $  $ m $  $ d_j, s_j, t_j $ $ s_j $  $ t_j $  $ s_j $  $ t_j $  $ d_j $  \n\n\n\n<!-- more -->\n\n### \n[COGS 1266](http://cogs.pro/cogs/problem/problem.php?pid=1266)  \n[CodeVS 1217](http://codevs.cn/problem/1217/)\n\n### \n#### \n\n\n 100 ** 95 **\n\n#### \n $ x $ +  $ x $ \n\n 100  100 \n\n### \nTLE\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 1000000;\nconst int MAXR = 1000000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar a[SIZE * sizeof(T)];\n\tT *p;\n\n\tMemoryPool() : p((T *)a) {}\n\n\tT *alloc() {\n\t\treturn p++;\n\t}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, min, lazy;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (lchild) lchild->value += lazy, lchild->min += lazy, lchild->lazy += lazy;\n\t\t\t\tif (rchild) rchild->value += lazy, rchild->min += lazy, rchild->lazy += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tint queryMin(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\t\telse if (l <= this->l && r >= this->r) return min;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tif (lchild) ans = std::min(ans, lchild->queryMin(l, r));\n\t\t\t\tif (rchild) ans = std::min(ans, rchild->queryMin(l, r));\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) value += x, min += x, lazy += x;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tif (lchild) lchild->update(l, r, x);\n\t\t\t\tif (rchild) rchild->update(l, r, x);\n\n\t\t\t\tmin = INT_MAX;\n\t\t\t\tif (lchild) min = std::min(min, lchild->min);\n\t\t\t\tif (rchild) min = std::min(min, rchild->min);\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tstatic MemoryPool<Node, MAXN * 2> pool;\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL);\n\t\telse return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tint queryMin(int l, int r) {\n\t\treturn root->queryMin(l, r);\n\t}\n\n\tvoid update(int l, int r, int x) {\n\t\troot->update(l, r, x);\n\t}\n};\n\nint n, m;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nint main() {\n\tread(n), read(m);\n\n\tSegmentTree segmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tread(x);\n\n\t\tsegmentTree.update(i, i, x);\n\t}\n\n\tint day = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, l, r;\n\t\tread(x), read(l), read(r);\n\n\t\tsegmentTree.update(l, r, -x);\n\t\tif (segmentTree.queryMin(1, n) < 0) {\n\t\t\tday = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (day != 0) printf(\"-1\\n%d\\n\", day);\n\telse puts(\"0\");\n\n\treturn 0;\n}\n```\n\nAC\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e6;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int available[MAXN];\n\tstatic struct Request {\n\t\tint l, r, cnt;\n\t} req[MAXN];\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &available[i]);\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d\", &req[i].cnt, &req[i].l, &req[i].r), req[i].l--, req[i].r--;\n\n\tint l = -1, r = m - 1;\n\tstatic int used[MAXN];\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tbool valid = true;\n\n\t\tfor (int i = 0; i < n; i++) used[i] = 0;\n\t\tfor (int i = 0; i <= mid; i++) {\n\t\t\tused[req[i].l] += req[i].cnt;\n\t\t\tif (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) used[i] += used[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] > available[i]) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"[%d, %d] => %d\\n\", l, r, mid);\n#endif\n\n\t\tif (valid) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\n\tif (l == m - 1) puts(\"0\");\n\telse printf(\"-1\\n%d\\n\", l + 1 + 1);\n\n\treturn 0;\n}\n```","slug":"noip2012-classrooms","published":1,"updated":"2016-10-08T09:04:11.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rml00nqooxlq0mqpsh5"},{"title":"NOIP2012 -  +  + ","date":"2016-11-13T09:44:00.000Z","_content":"\nH  $ n $  $ n $  $ n - 1 $ $ 1 $ \n\nH \n\n H \n\n\n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n $ t $ $ t $ \n\n****\n\n $ X $  $ Y $ \n\n $ X $  $ Y $ $ X $  $ Y $  $ X $  $ Y $ \n\n $ X $  $ Y $  $ X $  $ Y $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <list>\n\nconst int MAXN = 50000;\nconst int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tbool visited, settled, childSettled;\n\tstd::vector<int> arrived;\n} N[MAXN + 1], *seq[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tint w;\n\tbool visited;\n\tstd::list<Edge *>::iterator it;\n\n\tEdge(Node *s, Node *t, int w) : s(s), t(t), next(s->e), w(w) {}\n};\n\ninline void addEdge(int s, int t, int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, m, a[MAXN + 1], logn;\n\nint f[MAXN + 1][MAXN_LOG + 1];\nlong long g[MAXN + 1][MAXN_LOG + 1];\n\ninline void prepare() {\n\tstd::queue<Node *> q;\n\n\tN[1].visited = true;\n\tf[1][0] = 1;\n\tg[1][0] = 0;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\tf[e->t - N][0] = v - N;\n\t\t\t\tg[e->t - N][0] = e->w;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n}\n\ninline bool compare(Edge *a, Edge *b) {\n\treturn a->w < b->w;\n}\n\ninline bool check(long long limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].arrived.clear();\n\t\tN[i].settled = false;\n\t\tN[i].childSettled = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = a[i];\n\n\t\tlong long dist = 0;\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (dist + g[u][j] <= limit && f[u][j] != 1) {\n\t\t\t\tdist += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\n\t\tN[u].arrived.push_back(limit - dist);\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (seq[i]->e->next || i == 1) { // It's not a leaf\n\t\t\tseq[i]->childSettled = true;\n\t\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\t\tif (e->t == seq[i]->parent) continue;\n\n\t\t\t\tif (!e->t->settled) {\n\t\t\t\t\tseq[i]->childSettled = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d, settled = %d\\n\", seq[i] - N, seq[i]->childSettled, seq[i]->settled);\n#endif\n\n\t\tseq[i]->settled = seq[i]->childSettled;\n\n\t\tif (seq[i]->arrived.size()) {\n\t\t\tseq[i]->settled = true;\n\t\t}\n\t}\n\n\tif (N[1].settled) return true;\n\n\tstd::list< std::pair<int, Edge *> > atRoot;\n\tstd::list<Edge *> needSettle;\n\tfor (Edge *e = N[1].e; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d\\n\", e->t - N, e->t->childSettled);\n#endif\n\n\t\tstd::vector<int> &vec = e->t->arrived;\n\t\tstd::sort(vec.begin(), vec.end());\n\n\t\tbool remain = e->t->childSettled;\n\t\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i] >= e->w) atRoot.push_back(std::make_pair(vec[i] - e->w, e));\n\t\t\telse remain = true;\n\t\t}\n\n\t\tif (remain) {\n\t\t\te->visited = true;\n\t\t} else {\n\t\t\tneedSettle.push_back(e);\n\t\t\te->it = --needSettle.end();\n\t\t\te->visited = false;\n\t\t}\n\t}\n\n\tatRoot.sort();\n\tneedSettle.sort(&compare);\n\n#ifdef DBG\n\tstd::vector< std::pair<int, Edge *> > _atRoot(atRoot.begin(), atRoot.end());\n\tstd::vector<Edge *> _needSettle(needSettle.begin(), needSettle.end());\n#endif\n\t// std::sort(needSettle.begin(), needSettle.end(), &compare);\n\n\tfor (std::list< std::pair<int, Edge *> >::iterator it = atRoot.begin(); it != atRoot.end(); it++) {\n\t\tif (needSettle.empty()) break;\n\t\tif (!it->second->visited) {\n\t\t\tit->second->visited = true;\n\t\t\tneedSettle.erase(it->second->it);\n\t\t} else {\n\t\t\tif (needSettle.front()->w <= it->first) {\n\t\t\t\tneedSettle.front()->visited = true;\n\t\t\t\tneedSettle.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSettle.empty();\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\tsum += w;\n\t\taddEdge(u, v, w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (Edge *e = N[1].e; e; e = e->next) cnt++;\n\n\tif (cnt > m) puts(\"-1\");\n\telse {\n\t\tint l = 0, r = sum;\n\t\twhile (l < r) {\n\t\t\tint mid = l + (r - l) / 2;\n#ifdef DBG\n\t\t\tprintf(\"[%d, %d], mid = %d\\n\", l, r, mid);\n#endif\n\t\t\tif (check(mid)) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2012-blockade.md","raw":"title: NOIP2012 -  +  + \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \n  - \npermalink: noip2012-blockade\ndate: 2016-11-13 17:44:00\n---\n\nH  $ n $  $ n $  $ n - 1 $ $ 1 $ \n\nH \n\n H \n\n\n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n $ t $ $ t $ \n\n****\n\n $ X $  $ Y $ \n\n $ X $  $ Y $ $ X $  $ Y $  $ X $  $ Y $ \n\n $ X $  $ Y $  $ X $  $ Y $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <list>\n\nconst int MAXN = 50000;\nconst int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tbool visited, settled, childSettled;\n\tstd::vector<int> arrived;\n} N[MAXN + 1], *seq[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tint w;\n\tbool visited;\n\tstd::list<Edge *>::iterator it;\n\n\tEdge(Node *s, Node *t, int w) : s(s), t(t), next(s->e), w(w) {}\n};\n\ninline void addEdge(int s, int t, int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, m, a[MAXN + 1], logn;\n\nint f[MAXN + 1][MAXN_LOG + 1];\nlong long g[MAXN + 1][MAXN_LOG + 1];\n\ninline void prepare() {\n\tstd::queue<Node *> q;\n\n\tN[1].visited = true;\n\tf[1][0] = 1;\n\tg[1][0] = 0;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\tf[e->t - N][0] = v - N;\n\t\t\t\tg[e->t - N][0] = e->w;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n}\n\ninline bool compare(Edge *a, Edge *b) {\n\treturn a->w < b->w;\n}\n\ninline bool check(long long limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].arrived.clear();\n\t\tN[i].settled = false;\n\t\tN[i].childSettled = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = a[i];\n\n\t\tlong long dist = 0;\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (dist + g[u][j] <= limit && f[u][j] != 1) {\n\t\t\t\tdist += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\n\t\tN[u].arrived.push_back(limit - dist);\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (seq[i]->e->next || i == 1) { // It's not a leaf\n\t\t\tseq[i]->childSettled = true;\n\t\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\t\tif (e->t == seq[i]->parent) continue;\n\n\t\t\t\tif (!e->t->settled) {\n\t\t\t\t\tseq[i]->childSettled = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d, settled = %d\\n\", seq[i] - N, seq[i]->childSettled, seq[i]->settled);\n#endif\n\n\t\tseq[i]->settled = seq[i]->childSettled;\n\n\t\tif (seq[i]->arrived.size()) {\n\t\t\tseq[i]->settled = true;\n\t\t}\n\t}\n\n\tif (N[1].settled) return true;\n\n\tstd::list< std::pair<int, Edge *> > atRoot;\n\tstd::list<Edge *> needSettle;\n\tfor (Edge *e = N[1].e; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d\\n\", e->t - N, e->t->childSettled);\n#endif\n\n\t\tstd::vector<int> &vec = e->t->arrived;\n\t\tstd::sort(vec.begin(), vec.end());\n\n\t\tbool remain = e->t->childSettled;\n\t\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i] >= e->w) atRoot.push_back(std::make_pair(vec[i] - e->w, e));\n\t\t\telse remain = true;\n\t\t}\n\n\t\tif (remain) {\n\t\t\te->visited = true;\n\t\t} else {\n\t\t\tneedSettle.push_back(e);\n\t\t\te->it = --needSettle.end();\n\t\t\te->visited = false;\n\t\t}\n\t}\n\n\tatRoot.sort();\n\tneedSettle.sort(&compare);\n\n#ifdef DBG\n\tstd::vector< std::pair<int, Edge *> > _atRoot(atRoot.begin(), atRoot.end());\n\tstd::vector<Edge *> _needSettle(needSettle.begin(), needSettle.end());\n#endif\n\t// std::sort(needSettle.begin(), needSettle.end(), &compare);\n\n\tfor (std::list< std::pair<int, Edge *> >::iterator it = atRoot.begin(); it != atRoot.end(); it++) {\n\t\tif (needSettle.empty()) break;\n\t\tif (!it->second->visited) {\n\t\t\tit->second->visited = true;\n\t\t\tneedSettle.erase(it->second->it);\n\t\t} else {\n\t\t\tif (needSettle.front()->w <= it->first) {\n\t\t\t\tneedSettle.front()->visited = true;\n\t\t\t\tneedSettle.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSettle.empty();\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\tsum += w;\n\t\taddEdge(u, v, w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (Edge *e = N[1].e; e; e = e->next) cnt++;\n\n\tif (cnt > m) puts(\"-1\");\n\telse {\n\t\tint l = 0, r = sum;\n\t\twhile (l < r) {\n\t\t\tint mid = l + (r - l) / 2;\n#ifdef DBG\n\t\t\tprintf(\"[%d, %d], mid = %d\\n\", l, r, mid);\n#endif\n\t\t\tif (check(mid)) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2012-blockade","published":1,"updated":"2016-11-13T09:44:18.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rmt00o0ooxlss0g7dh7"},{"title":"NOIP2010 - ","id":"54","updated":"2016-02-19T08:06:06.000Z","date":"2016-02-19T08:00:26.000Z","_content":"\nS  `N`  `1 ~ N` Z  Z \n\n<!-- more -->\n\n### \n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[ 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### \n `x`  `x` \n\n BFS\n\n $ O(n{log}n) $ 100%  Tyvj  TLE \n\n  qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-prison.md","raw":"title: NOIP2010 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Vijos\n  - \n  - \n  - \n  - \npermalink: noip2010-prison\nid: 54\nupdated: '2016-02-19 16:06:06'\ndate: 2016-02-19 16:00:26\n---\n\nS  `N`  `1 ~ N` Z  Z \n\n<!-- more -->\n\n### \n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[ 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### \n `x`  `x` \n\n BFS\n\n $ O(n{log}n) $ 100%  Tyvj  TLE \n\n  qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","slug":"noip2010-prison","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rmy00o7ooxly56ie22t"},{"title":"NOIP2010 - BFS + DP","date":"2016-11-13T09:23:00.000Z","_content":"\n $ N $  $ M $ \n\n $ 1 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[CodeVS 1066](http://codevs.cn/problem/1066/)\n\n### \n Floodfill\n\n Floodfill $ m $    DP \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 500;\n\nconst int di[] = { 0, 1, 0, -1 };\nconst int dj[] = { -1, 0, 1, 0 };\n\nstruct Node {\n\tint height;\n\tbool visited;\n} map[MAXN + 2][MAXN + 2];\n\nint n, m;\n\nstruct Point {\n\tint i, j;\n\t\n\tPoint(int i = 0, int j = 0) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tbool valid() {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n};\n\nstruct Interval {\n\tint l, r;\n\n\tInterval(int l = 0, int r = 0) : l(l), r(r) {}\n\n\tbool operator<(const Interval &other) const {\n\t\treturn (l == other.l) ? (r < other.r) : (l < other.l);\n\t}\n};\n\ninline int bfs(Point start, Interval &interval) {\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) map[i][j].visited = false;\n\n\tstd::queue<Point> q;\n\tif (start.i == 0 && start.j == 0) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap[1][i].visited = true;\n\t\t\tq.push(Point(1, i));\n\t\t}\n\t} else {\n\t\tq.push(start);\n\t\tstart->visited = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\t\t\tif (!u.valid()) continue;\n\n\t\t\tif (u->height < v->height && !u->visited) {\n\t\t\t\tu->visited = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start.i == 0 && start.j == 0) {\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) if (!map[n][i].visited) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool flag = false;\n#ifdef DBG\n\tprintf(\"%d:\", start.j);\n#endif\n\tfor (int i = 1; i <= m + 1; i++) {\n#ifdef DBG\n\t\tif (map[n][i].visited) {\n\t\t\tprintf(\" %d\", i);\n\t\t}\n#endif\n\t\tif (!flag && map[n][i].visited) {\n\t\t\tinterval.l = i;\n\t\t\tflag = true;\n\t\t} else if (flag && !map[n][i].visited) {\n\t\t\tinterval.r = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\" = [%d, %d]\\n\", interval.l, interval.r);\n#endif\n\n\treturn flag;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf(\"%d\", &map[i][j].height);\n\n\tInterval tmp;\n\tint cnt = bfs(Point(0, 0), tmp);\n\n\tif (cnt) {\n\t\tprintf(\"0\\n%d\\n\", cnt);\n\t} else {\n\t\tstatic Interval a[MAXN + 1];\n\t\tint k  = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tInterval interval;\n\t\t\tif (bfs(Point(1, i), interval)) {\n\t\t\t\ta[++k] = interval;\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(a + 1, a + k+ 1);\n\n\t\tstatic int f[MAXN + 1];\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tf[i] = INT_MAX;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[j].r >= a[i].l - 1) {\n\t\t\t\t\tf[i] = std::min(f[i], f[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i].r == m) ans = std::min(ans, f[i]);\n\t\t}\n\n\t\tprintf(\"1\\n%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-flow.md","raw":"title: NOIP2010 - BFS + DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BFS\n  - DP\n  -  DP\npermalink: noip2010-flow\ndate: 2016-11-13 17:23:00\n---\n\n $ N $  $ M $ \n\n $ 1 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[CodeVS 1066](http://codevs.cn/problem/1066/)\n\n### \n Floodfill\n\n Floodfill $ m $    DP \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 500;\n\nconst int di[] = { 0, 1, 0, -1 };\nconst int dj[] = { -1, 0, 1, 0 };\n\nstruct Node {\n\tint height;\n\tbool visited;\n} map[MAXN + 2][MAXN + 2];\n\nint n, m;\n\nstruct Point {\n\tint i, j;\n\t\n\tPoint(int i = 0, int j = 0) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tbool valid() {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n};\n\nstruct Interval {\n\tint l, r;\n\n\tInterval(int l = 0, int r = 0) : l(l), r(r) {}\n\n\tbool operator<(const Interval &other) const {\n\t\treturn (l == other.l) ? (r < other.r) : (l < other.l);\n\t}\n};\n\ninline int bfs(Point start, Interval &interval) {\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) map[i][j].visited = false;\n\n\tstd::queue<Point> q;\n\tif (start.i == 0 && start.j == 0) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap[1][i].visited = true;\n\t\t\tq.push(Point(1, i));\n\t\t}\n\t} else {\n\t\tq.push(start);\n\t\tstart->visited = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\t\t\tif (!u.valid()) continue;\n\n\t\t\tif (u->height < v->height && !u->visited) {\n\t\t\t\tu->visited = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start.i == 0 && start.j == 0) {\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) if (!map[n][i].visited) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool flag = false;\n#ifdef DBG\n\tprintf(\"%d:\", start.j);\n#endif\n\tfor (int i = 1; i <= m + 1; i++) {\n#ifdef DBG\n\t\tif (map[n][i].visited) {\n\t\t\tprintf(\" %d\", i);\n\t\t}\n#endif\n\t\tif (!flag && map[n][i].visited) {\n\t\t\tinterval.l = i;\n\t\t\tflag = true;\n\t\t} else if (flag && !map[n][i].visited) {\n\t\t\tinterval.r = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\" = [%d, %d]\\n\", interval.l, interval.r);\n#endif\n\n\treturn flag;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf(\"%d\", &map[i][j].height);\n\n\tInterval tmp;\n\tint cnt = bfs(Point(0, 0), tmp);\n\n\tif (cnt) {\n\t\tprintf(\"0\\n%d\\n\", cnt);\n\t} else {\n\t\tstatic Interval a[MAXN + 1];\n\t\tint k  = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tInterval interval;\n\t\t\tif (bfs(Point(1, i), interval)) {\n\t\t\t\ta[++k] = interval;\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(a + 1, a + k+ 1);\n\n\t\tstatic int f[MAXN + 1];\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tf[i] = INT_MAX;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[j].r >= a[i].l - 1) {\n\t\t\t\t\tf[i] = std::min(f[i], f[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i].r == m) ans = std::min(ans, f[i]);\n\t\t}\n\n\t\tprintf(\"1\\n%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2010-flow","published":1,"updated":"2016-11-13T09:23:38.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rn600ojooxl1ilaowdd"},{"title":"NOIP2006 -  DP","id":"19","updated":"2016-01-19T13:04:41.000Z","date":"2016-01-12T21:19:28.000Z","_content":"\nMarsMarsNMarsmrrn$m*r*n$Marsmn\nMars\n\n<!-- more -->\n\n### \n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### \n\n\nDP $a[i]$  `i`  `i + 1`  $f[i][j]$  `i`  `j`  `k` `k` \n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n\n\n $O(n^4)$ $n=100$  TvT\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2006-energy.md","raw":"title: NOIP2006 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - Tyvj\n  -  DP\npermalink: noip2006-energy\nid: 19\nupdated: '2016-01-19 21:04:41'\ndate: 2016-01-13 05:19:28\n---\n\nMarsMarsNMarsmrrn$m*r*n$Marsmn\nMars\n\n<!-- more -->\n\n### \n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### \n\n\nDP $a[i]$  `i`  `i + 1`  $f[i][j]$  `i`  `j`  `k` `k` \n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n\n\n $O(n^4)$ $n=100$  TvT\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noip2006-energy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnb00orooxl4qu3u03v"},{"title":"NOIP2006 -  DP +  DP","id":"25","updated":"2016-01-19T13:02:58.000Z","date":"2016-01-16T22:11:03.000Z","_content":"\nN\n\n012N51~5510NN\n\n<!-- more -->\n\n### \n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[ 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### \n DP \n\n 01 \n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n 01 \n\n `0`  `0` \n\n~~~~\n\nPS TLE  `10`  `10` \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2006-budget.md","raw":"title: NOIP2006 -  DP +  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - Vijos\n  -  DP\n  - \n  -  DP\npermalink: noip2006-budget\nid: 25\nupdated: '2016-01-19 21:02:58'\ndate: 2016-01-17 06:11:03\n---\n\nN\n\n012N51~5510NN\n\n<!-- more -->\n\n### \n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[ 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### \n DP \n\n 01 \n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n 01 \n\n `0`  `0` \n\n~~~~\n\nPS TLE  `10`  `10` \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```\n","slug":"noip2006-budget","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rng00oyooxl1q61w30r"},{"title":"NOIP2003 -  DP","id":"20","updated":"2016-01-19T13:04:15.000Z","date":"2016-01-13T20:23:38.000Z","_content":"\n `n` 50 `m` 9 `m`  10  `k` `k` \n\n<!-- more -->\n\n### \n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[ 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### \n DP  ** `10` **\n\n $ f[i][j] $  `i`  `j` \n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2003-game.md","raw":"title: NOIP2003 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  -  DP\n  - \n  - Tyvj\npermalink: noip2003-game\nid: 20\nupdated: '2016-01-19 21:04:15'\ndate: 2016-01-14 04:23:38\n---\n\n `n` 50 `m` 9 `m`  10  `k` `k` \n\n<!-- more -->\n\n### \n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[ 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### \n DP  ** `10` **\n\n $ f[i][j] $  `i`  `j` \n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```\n","slug":"noip2003-game","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnm00p7ooxlnvt9fmv4"},{"title":"NOIP2000 -  DP","id":"16","updated":"2016-01-19T13:05:38.000Z","date":"2016-01-08T21:10:45.000Z","_content":"\n `N`<= 400 `K`<= 6\n\n<!-- more -->\n\n### \n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### \n DP `f[n][k]`  `n`  `k`  `a[i][j]`  `i`  `j` \n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n `long long` \n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```\n","source":"_posts/noip2000-cheng-ji-zui-da.md","raw":"title: NOIP2000 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  -  DP\npermalink: noip2000-cheng-ji-zui-da\nid: 16\nupdated: '2016-01-19 21:05:38'\ndate: 2016-01-09 05:10:45\n---\n\n `N`<= 400 `K`<= 6\n\n<!-- more -->\n\n### \n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### \n DP `f[n][k]`  `n`  `k`  `a[i][j]`  `i`  `j` \n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n `long long` \n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```\n","slug":"noip2000-cheng-ji-zui-da","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnq00pfooxlzh4qesq9"},{"title":"NOI2016 - ","date":"2016-09-05T23:19:00.000Z","_content":"\n $ n $  $ [l_1, r_1], [l_2, r_2] , \\ldots, [l_n, r_n] $ $ m $  $ m $  $ x $ $ [l_i, r_i] $ $ l_i \\leq x \\leq r_i $\n\n $ [l_i, r_i] $  $ r_i  l_i $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4653](http://www.lydsy.com/JudgeOnline/problem.php?id=4653)\n\n### \n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint val, tag;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {}\n\n\tvoid cover(const int delta) {\n\t\tval += delta;\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, delta);\n\t\t\trc->update(l, r, delta);\n\t\t\tval = std::max(lc->val, rc->val);\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return val;\n\t\telse {\n\t\t\tpushDown();\n\t\t\treturn std::max(lc->query(l, r), rc->query(l, r));\n\t\t}\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\nstruct Interval {\n\tint l, r, len;\n\n\tbool operator<(const Interval &other) const { return len < other.len; }\n} a[MAXN];\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].l, &a[i].r), a[i].len = a[i].r - a[i].l;\n\n\tstatic int set[MAXN * 2];\n\tint cnt = 0, max = 0;\n\tfor (int i = 0; i < n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r;\n\tstd::sort(set, set + n * 2);\n\tint *end = std::unique(set, set + n * 2);\n\tfor (int i = 0; i < n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r);\n\n\tstd::sort(a, a + n);\n\n\tsegment = SegmentTree::build(0, max);\n\n\tint ans = INT_MAX;\n\tfor (Interval *l = a, *r = a; r != a + n; r++) {\n\t\tsegment->update(r->l, r->r, 1);\n\t\twhile (l <= r && segment->query(0, max) >= m) {\n\t\t\tans = std::min(ans, r->len - l->len);\n\t\t\tsegment->update(l->l, l->r, -1);\n\t\t\tl++;\n\t\t}\n\t}\n\n\tif (ans == INT_MAX) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2016-interval.md","raw":"title: NOI2016 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \npermalink: noi2016-interval\ndate: 2016-09-06 07:19:00\n---\n\n $ n $  $ [l_1, r_1], [l_2, r_2] , \\ldots, [l_n, r_n] $ $ m $  $ m $  $ x $ $ [l_i, r_i] $ $ l_i \\leq x \\leq r_i $\n\n $ [l_i, r_i] $  $ r_i  l_i $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4653](http://www.lydsy.com/JudgeOnline/problem.php?id=4653)\n\n### \n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint val, tag;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {}\n\n\tvoid cover(const int delta) {\n\t\tval += delta;\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, delta);\n\t\t\trc->update(l, r, delta);\n\t\t\tval = std::max(lc->val, rc->val);\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return val;\n\t\telse {\n\t\t\tpushDown();\n\t\t\treturn std::max(lc->query(l, r), rc->query(l, r));\n\t\t}\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\nstruct Interval {\n\tint l, r, len;\n\n\tbool operator<(const Interval &other) const { return len < other.len; }\n} a[MAXN];\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].l, &a[i].r), a[i].len = a[i].r - a[i].l;\n\n\tstatic int set[MAXN * 2];\n\tint cnt = 0, max = 0;\n\tfor (int i = 0; i < n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r;\n\tstd::sort(set, set + n * 2);\n\tint *end = std::unique(set, set + n * 2);\n\tfor (int i = 0; i < n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r);\n\n\tstd::sort(a, a + n);\n\n\tsegment = SegmentTree::build(0, max);\n\n\tint ans = INT_MAX;\n\tfor (Interval *l = a, *r = a; r != a + n; r++) {\n\t\tsegment->update(r->l, r->r, 1);\n\t\twhile (l <= r && segment->query(0, max) >= m) {\n\t\t\tans = std::min(ans, r->len - l->len);\n\t\t\tsegment->update(l->l, l->r, -1);\n\t\t\tl++;\n\t\t}\n\t}\n\n\tif (ans == INT_MAX) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2016-interval","published":1,"updated":"2016-09-05T23:39:11.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnu00plooxlun40oh7g"},{"title":"NOI2016 - ","date":"2016-09-08T11:40:00.000Z","_content":"\n $ n \\times m $  $ c $ \n\n<!-- more -->\n\n### \n[BZOJ 4651](http://www.lydsy.com/JudgeOnline/problem.php?id=4651)  \n[UOJ #220](http://uoj.ac/problem/220)\n\n### \n $ 2 $$ -1 $$ 0 $$ 1 $ \n\n#### \n\n\n1. \n2. \n\n $ n \\times m = c $  $ n $  $ m $ $ n \\times m = c + 2 $ $ | x_1 - x_2 | + | y_1 - y_2 | = 1 $ \n\n####  $ 0 $\n $ 0 $ ****\n\n FloodFill $ O(c) $ \n\n  ****\n\n FloodFill**** $ 0 $\n\n####  $ 1 $\n $ 1 $ ****\n\n\n\n\n\n```plain\n.......\n...111.\n...1*1.\n.11111.\n.1*1...\n.111...\n.......\n```\n\n $ 1 $   \n\n****\n\n```plain\n..22222\n..21112\n2221*12\n2111112\n21*1222\n21112..\n22222..\n```\n\n** $ 1 $ **\n\n#### \n $ 1 $\n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define HASH(x, y) (static_cast<unsigned long long>(x) << 32) | static_cast<unsigned long long>(y)\n#define inline inline __attribute__((always_inline))\n\nconst int MAXC = 100000;\nconst int MAXN = MAXC * 24;\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\ntemplate <typename Tk, typename Tv>\nstruct HashMap {\n\tconst static size_t HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tstruct Pair {\n\t\t\tTk first;\n\t\t\tTv second;\n\t\t} p;\n\t\tint time;\n\t} N[HASH_SIZE];\n\n\ttypedef typename Node::Pair *iterator;\n\n\tint time;\n\n\tinline HashMap() : time(1) {}\n\n\tinline int hash(const Tk &k) {\n\t\treturn k % HASH_SIZE;\n\t}\n\n\tinline Node *locate(const Tk &k) {\n\t\tregister int i;\n\t\tfor (i = hash(k); N[i].time == time && N[i].p.first != k; (++i == HASH_SIZE) && (i = 0));\n\t\treturn &N[i];\n\t}\n\n\tinline iterator find(const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) return end();\n\t\treturn &v->p;\n\t}\n\n\tinline Tv &operator[](const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) {\n\t\t\tv->time = time, v->p.first = k, v->p.second = Tv();\n\t\t}\n\t\treturn v->p.second;\n\t}\n\n\tinline void clear() { time++; }\n\n\tinline iterator end() const { return NULL; }\n};\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint type, dfn, low;\n\tbool v, pushed, flag;\n\tint x, y;\n} N[MAXN], *p = N;\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tinline Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(Node *s, Node *t) {\n\ts->e = new Edge(s, t);\n}\n\nint n, m, c;\nstruct Point {\n\tint x, y;\n\n\tinline Point(const int x = 0, const int y = 0) : x(x), y(y) {}\n\n\tinline bool operator<(const Point &other) const {\n\t\treturn y < other.y;\n\t}\n} a[MAXN];\n\nHashMap<unsigned long long, Node *> map;\n\ninline Node *clear(Node *p) {\n\tfor (Edge *&e = p->e, *next; e; next = e->next, delete e, e = next);\n\tmemset(p, 0, sizeof(Node));\n\treturn p;\n}\n\n#ifdef DBG\nchar str[1000][1000];\n#endif\n\ninline void getNodes(const int x, const int y, const bool second = false) {\n\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(x + fx < 1 || x + fx > n || y + fy < 1 || y + fy > m)) {\n\t\tregister int nx = x + fx, ny = y + fy;\n\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx, ny));\n\t\tif (it == map.end() || it->second != NULL) {\n\t\t\tNode *v;\n\t\t\tif (it == map.end()) {\n\t\t\t\tv = map[HASH(nx, ny)] = clear(p++);\n\t\t\t\tv->x = nx, v->y = ny;\n\t\t\t} else v = it->second;\n\t\t\tv->type = 1;\n#ifdef DBG\n\t\t\tstr[v->x][v->y] = 'A';\n#endif\n\t\t\tif (second) for (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(nx + fx < 1 || nx + fx > n || ny + fy < 1 || ny + fy > m)) {\n\t\t\t\tregister int nx2 = nx + fx, ny2 = ny + fy;\n\t\t\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx2, ny2));\n\t\t\t\tif (it == map.end()) {\n\t\t\t\t\tclear(p);\n\t\t\t\t\tp->type = 2;\n\t\t\t\t\tp->x = nx2, p->y = ny2;\n#ifdef DBG\n\t\t\t\t\tstr[p->x][p->y] = 'B';\n#endif\n\t\t\t\t\tmap[HASH(nx2, ny2)] = p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void addEdges() {\n\t// for (HashMap<unsigned long long, Node *>::iterator it = map.begin(); it != map.end(); it++) if (it->second) {\n\tfor (Node *v = N; v != p; v++) {\n\t\tregister int &x = v->x, &y = v->y;\n\t\tfor (register int i = 0; i < 4; i++) if (!(x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m)) {\n\t\t\tregister int nx = x + dx[i], ny = y + dy[i];\n\t\t\tregister HashMap<unsigned long long, Node *>::iterator it2 = map.find(HASH(nx, ny));\n\t\t\tif (it2 != map.end() && it2->second) {\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d] -> [%d, %d]\\n\", v->x, v->y, it2->second->x, it2->second->y);\n#endif\n\t\t\t\taddEdge(v, it2->second);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int tarjan() {\n\tregister int ts = 0, cnt = 0;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\n\t\tstatic Node *s[MAXN];\n\t\tNode **top = s;\n\t\tstart->pushed = true;\n\t\t*top = start;\n\n\t\twhile (top != s - 1) {\n\t\t\tNode *v = *top;\n\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v && e->t != v->p) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) *++top = e->t, e->t->pushed = true, e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != start) for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t->low >= v->dfn) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v->flag && v->type == 1) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ttop--;\n\t\t\t}\n\t\t}\n\n\t\tint ch = 0;\n\t\tfor (Edge *e = start->e; e; e = e->next) if (e->t->p == start) ch++;\n\t\tstart->flag = ch >= 2;\n\t\tif (start->flag && start->type == 1) cnt++;\n\t}\n\n\treturn cnt;\n}\n\ninline bool isOne() {\n\tfor (register int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tmap[HASH(x, y)] = NULL;\n\t}\n\n\tp = N;\n\n\tfor (register int i = 0; i < c; i++) {\n\t\tgetNodes(a[i].x, a[i].y, true);\n\t}\n\n\taddEdges();\n\n\treturn tarjan() != 0;\n}\n\ninline bool bfsCount() {\n\tbool flag = false;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\t\tif (flag) return true;\n\t\tflag = true;\n\n\t\tstatic Node *q[MAXN];\n\t\tNode **l = q, **r = q;\n\t\tstart->v = true;\n\t\t*l = start;\n\n\t\twhile (l <= r) {\n\t\t\tNode *v = *l++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->v) {\n\t\t\t\te->t->v = true;\n\t\t\t\t*++r = e->t;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline bool isZero() {\n\tstatic HashMap<unsigned long long, bool> map2;\n\tmap2.clear();\n\tfor (register int i = 0; i < c; i++) {\n\t\tmap2[HASH(a[i].x, a[i].y)] = false;\n\t}\n\tbool ans = false;\n#ifdef DBG\n\tint id = 0;\n#endif\n\tfor (int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tregister bool &f = map2[HASH(x, y)];\n\t\tif (f) continue;\n\t\tf = true;\n\n#ifdef DBG\n\t\tid++;\n#endif\n\n\t\tstatic Point vec[MAXC];\n\t\tint cnt = 0;\n\n\t\tmap.clear();\n\t\tp = N;\n\n\t\tstatic Point q[MAXC];\n\t\tPoint *l = q, *r = q;\n\t\t*l = Point(x, y);\n\t\twhile (l <= r) {\n\t\t\tPoint p = *l++;\n\n#ifdef DBG\n\t\t\tstr[p.x][p.y] = id + '0';\n#endif\n\n\t\t\tmap[HASH(p.x, p.y)] = NULL;\n\t\t\tvec[cnt++] = p;\n\n\t\t\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(p.x + fx < 1 || p.x + fx > n || p.y + fy < 1 || p.y + fy > m)) {\n\t\t\t\tregister int nx = p.x + fx, ny = p.y + fy;\n\t\t\t\tHashMap<unsigned long long, bool>::iterator it = map2.find(HASH(nx, ny));\n\t\t\t\tif (it != map2.end() && it->second == false) {\n\t\t\t\t\tit->second = true;\n\t\t\t\t\t*++r = Point(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) getNodes(vec[i].x, vec[i].y);\n\t\taddEdges();\n\t\tif (bfsCount()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmap.clear();\n\treturn ans;\n}\n\ninline bool isInvalid() {\n\tconst unsigned long long r = static_cast<unsigned long long>(n) * m - c;\n\tif (r < 2) return true;\n\telse if (r == 2) {\n\t\tstatic bool flag[MAXC];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tflag[(a[i].x - 1) * m + a[i].y - 1] = true;\n\t\t}\n\n\t\tPoint pts[2];\n\t\tfor (int i = 0, cnt = 0; i < n; i++) for (int j = 0; j < m; j++) {\n\t\t\tif (!flag[i * m + j]) pts[cnt++] = Point(i, j);\n\t\t\tflag[i * m + j] = false;\n\t\t}\n\n\t\treturn abs(pts[0].x - pts[1].x) + abs(pts[0].y - pts[1].y) == 1;\n\t} else return false;\n}\n\ninline const char *special() {\n\tstd::sort(a, a + c);\n\tint last = 0, cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (a[i].y != last + 1) {\n\t\t\tcnt++;\n\t\t}\n\t\tlast = a[i].y;\n\t}\n\tif (last != m) cnt++;\n\treturn cnt == 1 ? \"1\" : \"0\";\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar_unlocked(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar_unlocked(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tint t;\n\tread(t);\n\twhile (t--) {\n\t\tread(n), read(m), read(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tread(a[i].x), read(a[i].y);\n\t\t\tif (n > m) std::swap(a[i].x, a[i].y);\n\t\t}\n\n\t\tif (n > m) std::swap(n, m);\n\n\t\tif (isInvalid()) puts(\"-1\");\n\t\telse if (n == 1) puts(special());\n\t\telse if (isZero()) puts(\"0\");\n\t\telse if (isOne()) puts(\"1\");\n\t\telse puts(\"2\");\n\n#ifdef DBG\n\t\tfor (Node *v = N; v != p; v++) {\n\t\t\tprintf(\"[%d, %d] => %d\\n\", v->x, v->y, v->type);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tHashMap<unsigned long long, Node *>::iterator it = map.find(HASH(i, j));\n\t\t\t\tif (it == map.end()) putchar('-');\n\t\t\t\telse if (!it->second) putchar('X');\n\t\t\t\telse putchar('0' + it->second->type);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tputchar(str[i][j] ? str[i][j] : '-');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n#endif\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2016-grid.md","raw":"title: NOI2016 - \ncategories: OI\ntags: \n  - BZOJ\n  - NOI\n  - Tarjan\n  - \n  - \npermalink: noi2016-grid\ndate: 2016-09-08 19:40:00\n---\n\n $ n \\times m $  $ c $ \n\n<!-- more -->\n\n### \n[BZOJ 4651](http://www.lydsy.com/JudgeOnline/problem.php?id=4651)  \n[UOJ #220](http://uoj.ac/problem/220)\n\n### \n $ 2 $$ -1 $$ 0 $$ 1 $ \n\n#### \n\n\n1. \n2. \n\n $ n \\times m = c $  $ n $  $ m $ $ n \\times m = c + 2 $ $ | x_1 - x_2 | + | y_1 - y_2 | = 1 $ \n\n####  $ 0 $\n $ 0 $ ****\n\n FloodFill $ O(c) $ \n\n  ****\n\n FloodFill**** $ 0 $\n\n####  $ 1 $\n $ 1 $ ****\n\n\n\n\n\n```plain\n.......\n...111.\n...1*1.\n.11111.\n.1*1...\n.111...\n.......\n```\n\n $ 1 $   \n\n****\n\n```plain\n..22222\n..21112\n2221*12\n2111112\n21*1222\n21112..\n22222..\n```\n\n** $ 1 $ **\n\n#### \n $ 1 $\n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define HASH(x, y) (static_cast<unsigned long long>(x) << 32) | static_cast<unsigned long long>(y)\n#define inline inline __attribute__((always_inline))\n\nconst int MAXC = 100000;\nconst int MAXN = MAXC * 24;\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\ntemplate <typename Tk, typename Tv>\nstruct HashMap {\n\tconst static size_t HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tstruct Pair {\n\t\t\tTk first;\n\t\t\tTv second;\n\t\t} p;\n\t\tint time;\n\t} N[HASH_SIZE];\n\n\ttypedef typename Node::Pair *iterator;\n\n\tint time;\n\n\tinline HashMap() : time(1) {}\n\n\tinline int hash(const Tk &k) {\n\t\treturn k % HASH_SIZE;\n\t}\n\n\tinline Node *locate(const Tk &k) {\n\t\tregister int i;\n\t\tfor (i = hash(k); N[i].time == time && N[i].p.first != k; (++i == HASH_SIZE) && (i = 0));\n\t\treturn &N[i];\n\t}\n\n\tinline iterator find(const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) return end();\n\t\treturn &v->p;\n\t}\n\n\tinline Tv &operator[](const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) {\n\t\t\tv->time = time, v->p.first = k, v->p.second = Tv();\n\t\t}\n\t\treturn v->p.second;\n\t}\n\n\tinline void clear() { time++; }\n\n\tinline iterator end() const { return NULL; }\n};\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint type, dfn, low;\n\tbool v, pushed, flag;\n\tint x, y;\n} N[MAXN], *p = N;\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tinline Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(Node *s, Node *t) {\n\ts->e = new Edge(s, t);\n}\n\nint n, m, c;\nstruct Point {\n\tint x, y;\n\n\tinline Point(const int x = 0, const int y = 0) : x(x), y(y) {}\n\n\tinline bool operator<(const Point &other) const {\n\t\treturn y < other.y;\n\t}\n} a[MAXN];\n\nHashMap<unsigned long long, Node *> map;\n\ninline Node *clear(Node *p) {\n\tfor (Edge *&e = p->e, *next; e; next = e->next, delete e, e = next);\n\tmemset(p, 0, sizeof(Node));\n\treturn p;\n}\n\n#ifdef DBG\nchar str[1000][1000];\n#endif\n\ninline void getNodes(const int x, const int y, const bool second = false) {\n\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(x + fx < 1 || x + fx > n || y + fy < 1 || y + fy > m)) {\n\t\tregister int nx = x + fx, ny = y + fy;\n\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx, ny));\n\t\tif (it == map.end() || it->second != NULL) {\n\t\t\tNode *v;\n\t\t\tif (it == map.end()) {\n\t\t\t\tv = map[HASH(nx, ny)] = clear(p++);\n\t\t\t\tv->x = nx, v->y = ny;\n\t\t\t} else v = it->second;\n\t\t\tv->type = 1;\n#ifdef DBG\n\t\t\tstr[v->x][v->y] = 'A';\n#endif\n\t\t\tif (second) for (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(nx + fx < 1 || nx + fx > n || ny + fy < 1 || ny + fy > m)) {\n\t\t\t\tregister int nx2 = nx + fx, ny2 = ny + fy;\n\t\t\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx2, ny2));\n\t\t\t\tif (it == map.end()) {\n\t\t\t\t\tclear(p);\n\t\t\t\t\tp->type = 2;\n\t\t\t\t\tp->x = nx2, p->y = ny2;\n#ifdef DBG\n\t\t\t\t\tstr[p->x][p->y] = 'B';\n#endif\n\t\t\t\t\tmap[HASH(nx2, ny2)] = p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void addEdges() {\n\t// for (HashMap<unsigned long long, Node *>::iterator it = map.begin(); it != map.end(); it++) if (it->second) {\n\tfor (Node *v = N; v != p; v++) {\n\t\tregister int &x = v->x, &y = v->y;\n\t\tfor (register int i = 0; i < 4; i++) if (!(x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m)) {\n\t\t\tregister int nx = x + dx[i], ny = y + dy[i];\n\t\t\tregister HashMap<unsigned long long, Node *>::iterator it2 = map.find(HASH(nx, ny));\n\t\t\tif (it2 != map.end() && it2->second) {\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d] -> [%d, %d]\\n\", v->x, v->y, it2->second->x, it2->second->y);\n#endif\n\t\t\t\taddEdge(v, it2->second);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int tarjan() {\n\tregister int ts = 0, cnt = 0;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\n\t\tstatic Node *s[MAXN];\n\t\tNode **top = s;\n\t\tstart->pushed = true;\n\t\t*top = start;\n\n\t\twhile (top != s - 1) {\n\t\t\tNode *v = *top;\n\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v && e->t != v->p) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) *++top = e->t, e->t->pushed = true, e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != start) for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t->low >= v->dfn) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v->flag && v->type == 1) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ttop--;\n\t\t\t}\n\t\t}\n\n\t\tint ch = 0;\n\t\tfor (Edge *e = start->e; e; e = e->next) if (e->t->p == start) ch++;\n\t\tstart->flag = ch >= 2;\n\t\tif (start->flag && start->type == 1) cnt++;\n\t}\n\n\treturn cnt;\n}\n\ninline bool isOne() {\n\tfor (register int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tmap[HASH(x, y)] = NULL;\n\t}\n\n\tp = N;\n\n\tfor (register int i = 0; i < c; i++) {\n\t\tgetNodes(a[i].x, a[i].y, true);\n\t}\n\n\taddEdges();\n\n\treturn tarjan() != 0;\n}\n\ninline bool bfsCount() {\n\tbool flag = false;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\t\tif (flag) return true;\n\t\tflag = true;\n\n\t\tstatic Node *q[MAXN];\n\t\tNode **l = q, **r = q;\n\t\tstart->v = true;\n\t\t*l = start;\n\n\t\twhile (l <= r) {\n\t\t\tNode *v = *l++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->v) {\n\t\t\t\te->t->v = true;\n\t\t\t\t*++r = e->t;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline bool isZero() {\n\tstatic HashMap<unsigned long long, bool> map2;\n\tmap2.clear();\n\tfor (register int i = 0; i < c; i++) {\n\t\tmap2[HASH(a[i].x, a[i].y)] = false;\n\t}\n\tbool ans = false;\n#ifdef DBG\n\tint id = 0;\n#endif\n\tfor (int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tregister bool &f = map2[HASH(x, y)];\n\t\tif (f) continue;\n\t\tf = true;\n\n#ifdef DBG\n\t\tid++;\n#endif\n\n\t\tstatic Point vec[MAXC];\n\t\tint cnt = 0;\n\n\t\tmap.clear();\n\t\tp = N;\n\n\t\tstatic Point q[MAXC];\n\t\tPoint *l = q, *r = q;\n\t\t*l = Point(x, y);\n\t\twhile (l <= r) {\n\t\t\tPoint p = *l++;\n\n#ifdef DBG\n\t\t\tstr[p.x][p.y] = id + '0';\n#endif\n\n\t\t\tmap[HASH(p.x, p.y)] = NULL;\n\t\t\tvec[cnt++] = p;\n\n\t\t\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(p.x + fx < 1 || p.x + fx > n || p.y + fy < 1 || p.y + fy > m)) {\n\t\t\t\tregister int nx = p.x + fx, ny = p.y + fy;\n\t\t\t\tHashMap<unsigned long long, bool>::iterator it = map2.find(HASH(nx, ny));\n\t\t\t\tif (it != map2.end() && it->second == false) {\n\t\t\t\t\tit->second = true;\n\t\t\t\t\t*++r = Point(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) getNodes(vec[i].x, vec[i].y);\n\t\taddEdges();\n\t\tif (bfsCount()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmap.clear();\n\treturn ans;\n}\n\ninline bool isInvalid() {\n\tconst unsigned long long r = static_cast<unsigned long long>(n) * m - c;\n\tif (r < 2) return true;\n\telse if (r == 2) {\n\t\tstatic bool flag[MAXC];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tflag[(a[i].x - 1) * m + a[i].y - 1] = true;\n\t\t}\n\n\t\tPoint pts[2];\n\t\tfor (int i = 0, cnt = 0; i < n; i++) for (int j = 0; j < m; j++) {\n\t\t\tif (!flag[i * m + j]) pts[cnt++] = Point(i, j);\n\t\t\tflag[i * m + j] = false;\n\t\t}\n\n\t\treturn abs(pts[0].x - pts[1].x) + abs(pts[0].y - pts[1].y) == 1;\n\t} else return false;\n}\n\ninline const char *special() {\n\tstd::sort(a, a + c);\n\tint last = 0, cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (a[i].y != last + 1) {\n\t\t\tcnt++;\n\t\t}\n\t\tlast = a[i].y;\n\t}\n\tif (last != m) cnt++;\n\treturn cnt == 1 ? \"1\" : \"0\";\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar_unlocked(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar_unlocked(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tint t;\n\tread(t);\n\twhile (t--) {\n\t\tread(n), read(m), read(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tread(a[i].x), read(a[i].y);\n\t\t\tif (n > m) std::swap(a[i].x, a[i].y);\n\t\t}\n\n\t\tif (n > m) std::swap(n, m);\n\n\t\tif (isInvalid()) puts(\"-1\");\n\t\telse if (n == 1) puts(special());\n\t\telse if (isZero()) puts(\"0\");\n\t\telse if (isOne()) puts(\"1\");\n\t\telse puts(\"2\");\n\n#ifdef DBG\n\t\tfor (Node *v = N; v != p; v++) {\n\t\t\tprintf(\"[%d, %d] => %d\\n\", v->x, v->y, v->type);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tHashMap<unsigned long long, Node *>::iterator it = map.find(HASH(i, j));\n\t\t\t\tif (it == map.end()) putchar('-');\n\t\t\t\telse if (!it->second) putchar('X');\n\t\t\t\telse putchar('0' + it->second->type);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tputchar(str[i][j] ? str[i][j] : '-');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n#endif\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2016-grid","published":1,"updated":"2016-09-11T23:54:29.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rnz00prooxl7q1qk4o8"},{"title":"NOI2016 - Hash","date":"2016-09-05T23:34:00.000Z","_content":"\n `AABB`  $ A $  $ B $ \n\n `aabaabaa` $ A = \\texttt{aab}, B = \\texttt{a} $ `AABB` \n\n $ A = \\texttt{a}, B = \\texttt{baa} $ `AABB`  `abaabaa` \n\n $ n $  $ S $\n\n<!-- more -->\n\n### \n[](https://blog.sengxian.com/solutions/bzoj-4650)\n\n### \nHash T  \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\ntypedef unsigned __int128 hash1_t;\n\nconst int MAXN = 30000;\nconst hash1_t BASE1 = 233;\n// const hash2_t BASE2 = 233;\n// const hash3_t BASE3 = 53;\n\nchar s[MAXN];\nint n;\nlong long forward[MAXN + 1], backward[MAXN + 1];\n\nhash1_t hash1[MAXN], base1[MAXN + 1];\n// hash2_t hash2[MAXN], base2[MAXN + 1];\n// hash3_t hash3[MAXN], base3[MAXN + 1];\n\ninline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) {\n\treturn hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len];\n\t\t// && hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len]\n\t\t// && hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len];\n\t// register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len];\n\t// register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len];\n\t// const bool res = h1 == h2;\n\t// assert(res == (memcmp(&s[a], &s[b], len) == 0));\n\t// return h1 == h2;\n\t// return memcmp(&s[a], &s[b], len) == 0;\n}\n\ninline __attribute__((always_inline)) int lcp(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = n - b;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a, b, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\ninline __attribute__((always_inline)) int lcs(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = a + 1;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a - m + 1, b - m + 1, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\t// base1[0] = base2[0] = base3[0] = 1;\n\tbase1[0] = 1;\n\t// for (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE % MOD;\n\tfor (register int i = 1; i <= MAXN; i++) {\n\t\tbase1[i] = base1[i - 1] * BASE1;\n\t\t// base2[i] = base2[i - 1] * BASE2;\n\t\t// base3[i] = base3[i - 1] * BASE3;\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tfor (register int i = 0; i < n; i++) s[i] -= 'a' - 1;\n\n\t\t// hash1[0] = hash2[0] = hash3[0] = s[0];\n\t\thash1[0] = s[0];\n\t\t// for (int i = 1; i < n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD;\n\t\tfor (register int i = 1; i < n; i++) {\n\t\t\thash1[i] = (hash1[i - 1] * BASE1 + s[i]);\n\t\t\t// hash2[i] = (hash2[i - 1] * BASE2 + s[i]);\n\t\t\t// hash3[i] = (hash3[i - 1] * BASE3 + s[i]);\n\t\t}\n\n\t\tfor (register int k = 1; k <= n / 2; k++) {\n\t\t\t// printf(\"k = %d\\n\", k);\n\t\t\tfor (register int i = 0; i < n; i += k) {\n\t\t\t\tconst register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k);\n\t\t\t\t// printf(\"lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\\n\", i, i + k, a, i, i + k, b);\n\t\t\t\tif (a + b >= k) {\n\t\t\t\t\tregister int l, r;\n\t\t\t\t\tl = i + k + k - a - 1, r = l + (a + b - k);\n\t\t\t\t\t// l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1);\n\t\t\t\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\t\t\t\t// for (int i = l; i <= r; i++) backward[i]++;\n\t\t\t\t\tbackward[l]++, backward[r + 1]--;\n\t\t\t\t\tr = r - 2 * k + 1, l = l - 2 * k + 1;\n\t\t\t\t\t// for (int i = l; i <= r; i++) forward[i]++;\n\t\t\t\t\tforward[l]++, forward[r + 1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (register int i = 1; i < n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1];\n\n\t\tregister long long ans = 0;\n\t\tfor (register int i = 1; i < n; i++) ans += backward[i - 1] * forward[i];\n\n\t\tfor (register int i = 0; i < n; i++) {\n\t\t\thash1[i] = 0;\n\t\t\t// hash2[i] = 0;\n\t\t\t// hash3[i] = 0;\n\t\t\tbackward[i] = forward[i] = 0;\n\t\t}\n\t\tforward[n] = backward[n] = 0;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2016-excellent.md","raw":"title: NOI2016 - Hash\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - Hash\npermalink: noi2016-excellent\ndate: 2016-09-06 07:34:00\n---\n\n `AABB`  $ A $  $ B $ \n\n `aabaabaa` $ A = \\texttt{aab}, B = \\texttt{a} $ `AABB` \n\n $ A = \\texttt{a}, B = \\texttt{baa} $ `AABB`  `abaabaa` \n\n $ n $  $ S $\n\n<!-- more -->\n\n### \n[](https://blog.sengxian.com/solutions/bzoj-4650)\n\n### \nHash T  \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\ntypedef unsigned __int128 hash1_t;\n\nconst int MAXN = 30000;\nconst hash1_t BASE1 = 233;\n// const hash2_t BASE2 = 233;\n// const hash3_t BASE3 = 53;\n\nchar s[MAXN];\nint n;\nlong long forward[MAXN + 1], backward[MAXN + 1];\n\nhash1_t hash1[MAXN], base1[MAXN + 1];\n// hash2_t hash2[MAXN], base2[MAXN + 1];\n// hash3_t hash3[MAXN], base3[MAXN + 1];\n\ninline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) {\n\treturn hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len];\n\t\t// && hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len]\n\t\t// && hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len];\n\t// register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len];\n\t// register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len];\n\t// const bool res = h1 == h2;\n\t// assert(res == (memcmp(&s[a], &s[b], len) == 0));\n\t// return h1 == h2;\n\t// return memcmp(&s[a], &s[b], len) == 0;\n}\n\ninline __attribute__((always_inline)) int lcp(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = n - b;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a, b, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\ninline __attribute__((always_inline)) int lcs(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = a + 1;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a - m + 1, b - m + 1, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\t// base1[0] = base2[0] = base3[0] = 1;\n\tbase1[0] = 1;\n\t// for (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE % MOD;\n\tfor (register int i = 1; i <= MAXN; i++) {\n\t\tbase1[i] = base1[i - 1] * BASE1;\n\t\t// base2[i] = base2[i - 1] * BASE2;\n\t\t// base3[i] = base3[i - 1] * BASE3;\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tfor (register int i = 0; i < n; i++) s[i] -= 'a' - 1;\n\n\t\t// hash1[0] = hash2[0] = hash3[0] = s[0];\n\t\thash1[0] = s[0];\n\t\t// for (int i = 1; i < n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD;\n\t\tfor (register int i = 1; i < n; i++) {\n\t\t\thash1[i] = (hash1[i - 1] * BASE1 + s[i]);\n\t\t\t// hash2[i] = (hash2[i - 1] * BASE2 + s[i]);\n\t\t\t// hash3[i] = (hash3[i - 1] * BASE3 + s[i]);\n\t\t}\n\n\t\tfor (register int k = 1; k <= n / 2; k++) {\n\t\t\t// printf(\"k = %d\\n\", k);\n\t\t\tfor (register int i = 0; i < n; i += k) {\n\t\t\t\tconst register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k);\n\t\t\t\t// printf(\"lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\\n\", i, i + k, a, i, i + k, b);\n\t\t\t\tif (a + b >= k) {\n\t\t\t\t\tregister int l, r;\n\t\t\t\t\tl = i + k + k - a - 1, r = l + (a + b - k);\n\t\t\t\t\t// l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1);\n\t\t\t\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\t\t\t\t// for (int i = l; i <= r; i++) backward[i]++;\n\t\t\t\t\tbackward[l]++, backward[r + 1]--;\n\t\t\t\t\tr = r - 2 * k + 1, l = l - 2 * k + 1;\n\t\t\t\t\t// for (int i = l; i <= r; i++) forward[i]++;\n\t\t\t\t\tforward[l]++, forward[r + 1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (register int i = 1; i < n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1];\n\n\t\tregister long long ans = 0;\n\t\tfor (register int i = 1; i < n; i++) ans += backward[i - 1] * forward[i];\n\n\t\tfor (register int i = 0; i < n; i++) {\n\t\t\thash1[i] = 0;\n\t\t\t// hash2[i] = 0;\n\t\t\t// hash3[i] = 0;\n\t\t\tbackward[i] = forward[i] = 0;\n\t\t}\n\t\tforward[n] = backward[n] = 0;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2016-excellent","published":1,"updated":"2016-09-05T23:42:03.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ro300pyooxlz2chxlgs"},{"title":"NOI2015 -  + ","date":"2016-06-26T10:14:00.000Z","_content":"\n $ S $  $ f(i) $ $ r \\in [0,\\ n - 1] $\n\n1.  $ \\mathrm {LCP}(\\mathrm{suffix}(i),\\ \\mathrm{suffix}(j)) \\geq r $  $ (i,\\ j) $ \n2.  $ (i, j) $  $ f(i) \\times f(j) $ \n\n<!-- more -->\n\n### \n[BZOJ 4199](http://www.lydsy.com/JudgeOnline/problem.php?id=4199)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n LCP LCP  $ \\geq r $**** $ x $  $ \\frac{x (x + 1)}{2} $\n\n $ f(i) $  $ f(i) $ \n\n\n\n $ r $  $ r $  $ \\mathrm{height}(i) $ $ \\mathrm{height} $ ****\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 300000;\n\nchar s[MAXN + 1];\nint a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\t\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%3d %2d %s\\n\", ::a[sa[i]], ht[i], &s[sa[i]]);\n\tputs(\"----------------\");\n#endif\n}\n\nstruct UnionFindSet {\n\tint f[MAXN], size[MAXN];\n\tint max[MAXN], max2[MAXN], min[MAXN], min2[MAXN];\n#ifdef DBG\n\tbool invalid[MAXN];\n\tint top[MAXN], bottom[MAXN];\n#endif\n\n\tvoid init() {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ti[f] = i;\n\t\t\ti[size] = 1;\n\t\t\tif (A[i] > A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1;\n\t\t\telse i[max] = i[min2] = i - 1, i[min] = i[max2] = i;\n#ifdef DBG\n\t\t\ti[top] = i[bottom] = i;\n\t\t\ti[invalid] = false;\n#endif\n\t\t}\n\t}\n\n\ttemplate <typename T>\n\tvoid updateMinMax(int &m, int &m2, const int x, T compare) {\n\t\tif (compare(A[x], A[m])) m2 = m, m = x;\n\t\telse if (x != m && compare(A[x], A[m2])) m2 = x;\n\t}\n\n\tvoid addTo(const int a, const int b) {\n#ifdef DBG\n\t\ta[invalid] = true;\n\t\tb[top] = std::min(b[top], a[top]);\n\t\tb[bottom] = std::max(b[bottom], a[bottom]);\n#endif\n\t\tb[size] = a[size] + b[size];\n\t\ta[size] = 0;\n\n\t\tupdateMinMax(b[max], b[max2], a[max], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[max2], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min2], std::greater<int>());\n\n\t\tupdateMinMax(b[min], b[min2], a[min], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[min2], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max2], std::less<int>());\n\t}\n\n\tint find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) {\n\t\tint res = x;\n\t\twhile (res[f] != res) res = res[f];\n\t\tfor (int i = x, tmp; i != res; ) {\n\t\t\ttmp = i[f];\n\t\t\taddTo(i, res);\n\t\t\ti[f] = res;\n\t\t\ti = tmp;\n\t\t}\n\n\t\tif (size) *size = this->size[res];\n\t\tif (max) *max = A[this->max[res]];\n\t\tif (max2) *max2 = A[this->max2[res]];\n\t\tif (min) *min = A[this->min[res]];\n\t\tif (min2) *min2 = A[this->min2[res]];\n\n\t\treturn res;\n\t}\n\n\tbool test(const int a, const int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(const int a, const int b) {\n\t\t// printf(\"merge(%d, %d)\\n\", a, b);\n\t\tint x = find(a), y = find(b);\n\t\t// printf(\"-- merge(%d, %d)\\n\", x, y);\n\t\tassert(x != y);\n\t\taddTo(x, y);\n\t\tx[f] = y;\n\t}\n\n#ifdef DBG\n\tvoid print() {\n\t\tfor (int i = 1; i < n; i++) find(i);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (invalid[i]) continue;\n\t\t\tprintf(\"[%d]: \", i);\n\t\t\tif (f[i] == i) printf(\"root, \");\n\t\t\telse printf(\"f = %d, \", f[i]);\n\n\t\t\tprintf(\"[%d, %d], size = %d, max = [%d] -> %d, max2 = [%d] -> %d, min = [%d] -> %d, min2 = [%d] -> %d\\n\", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]);\n\t\t}\n\t}\n#endif\n} ufs;\n\ninline long long calcCnt(const int x) {\n\tint size;\n\tufs.find(x, &size);\n\tlong long cnt = static_cast<long long>(size) * (size + 1) / 2;\n\t// printf(\"cnt(%d) = %d\\n\", x, cnt);\n\treturn cnt;\n}\n\ninline long long calcMax(const int x) {\n\tint max, max2, min, min2;\n\tufs.find(x, NULL, &max, &max2, &min, &min2);\n\treturn std::max(static_cast<long long>(max) * max2, static_cast<long long>(min) * min2);\n}\n\nint main() {\n\tscanf(\"%d\\n%s\", &n, s);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) A[i] = a[sa[i]];\n\n\tufs.init();\n\n\tstd::vector<int> v[MAXN];\n\tfor (int i = 1; i < n; i++) v[ht[i]].push_back(i);\n\n\tlong long cnt = 0, max = LLONG_MIN;\n\tstd::stack< std::pair<long long, long long> > stack;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t// printf(\"ht[%d] = %d\\n\", *it, ht[*it]);\n\n\t\t\tif (!(it != v[i].end() - 1 && ufs.test(*(it + 1), *it + 1))) {\n\t\t\t\tif (*it != n - 1) {\n\t\t\t\t\tif (ht[*it + 1] >= ht[*it] && !ufs.test(*it + 1, *it)) {\n\t\t\t\t\t\t// puts(\"------- + 1\");\n\t\t\t\t\t\tcnt -= calcCnt(*it + 1);\n\t\t\t\t\t\tufs.merge(*it, *it + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*it != 1 && ht[*it - 1] >= ht[*it] && !ufs.test(*it - 1, *it)) {\n\t\t\t\t// puts(\"------- - 1\");\n\t\t\t\tcnt -= calcCnt(*it - 1);\n\t\t\t\tufs.merge(*it, *it - 1);\n\t\t\t}\n\n\t\t\t// puts(\"+++++++\");\n\t\t\tcnt += calcCnt(*it);\n\t\t\tmax = std::max(max, calcMax(*it));\n#ifdef DBG\n\t\t\tprintf(\"calcMax(%d) = %lld\\n\", *it, calcMax(*it));\n#endif\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", cnt, max == LLONG_MIN ? 0 : max);\n\t\tif (cnt != 0) ufs.print();\n#else\n\t\tstack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max));\n#endif\n\t}\n\n#ifndef DBG\n\twhile (!stack.empty()) {\n\t\tprintf(\"%lld %lld\\n\", stack.top().first, stack.top().second);\n\t\tstack.pop();\n\t}\n#endif\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-savour.md","raw":"title: NOI2015 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-savour\ndate: 2016-06-26 18:14:00\n---\n\n $ S $  $ f(i) $ $ r \\in [0,\\ n - 1] $\n\n1.  $ \\mathrm {LCP}(\\mathrm{suffix}(i),\\ \\mathrm{suffix}(j)) \\geq r $  $ (i,\\ j) $ \n2.  $ (i, j) $  $ f(i) \\times f(j) $ \n\n<!-- more -->\n\n### \n[BZOJ 4199](http://www.lydsy.com/JudgeOnline/problem.php?id=4199)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n LCP LCP  $ \\geq r $**** $ x $  $ \\frac{x (x + 1)}{2} $\n\n $ f(i) $  $ f(i) $ \n\n\n\n $ r $  $ r $  $ \\mathrm{height}(i) $ $ \\mathrm{height} $ ****\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 300000;\n\nchar s[MAXN + 1];\nint a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\t\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%3d %2d %s\\n\", ::a[sa[i]], ht[i], &s[sa[i]]);\n\tputs(\"----------------\");\n#endif\n}\n\nstruct UnionFindSet {\n\tint f[MAXN], size[MAXN];\n\tint max[MAXN], max2[MAXN], min[MAXN], min2[MAXN];\n#ifdef DBG\n\tbool invalid[MAXN];\n\tint top[MAXN], bottom[MAXN];\n#endif\n\n\tvoid init() {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ti[f] = i;\n\t\t\ti[size] = 1;\n\t\t\tif (A[i] > A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1;\n\t\t\telse i[max] = i[min2] = i - 1, i[min] = i[max2] = i;\n#ifdef DBG\n\t\t\ti[top] = i[bottom] = i;\n\t\t\ti[invalid] = false;\n#endif\n\t\t}\n\t}\n\n\ttemplate <typename T>\n\tvoid updateMinMax(int &m, int &m2, const int x, T compare) {\n\t\tif (compare(A[x], A[m])) m2 = m, m = x;\n\t\telse if (x != m && compare(A[x], A[m2])) m2 = x;\n\t}\n\n\tvoid addTo(const int a, const int b) {\n#ifdef DBG\n\t\ta[invalid] = true;\n\t\tb[top] = std::min(b[top], a[top]);\n\t\tb[bottom] = std::max(b[bottom], a[bottom]);\n#endif\n\t\tb[size] = a[size] + b[size];\n\t\ta[size] = 0;\n\n\t\tupdateMinMax(b[max], b[max2], a[max], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[max2], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min2], std::greater<int>());\n\n\t\tupdateMinMax(b[min], b[min2], a[min], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[min2], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max2], std::less<int>());\n\t}\n\n\tint find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) {\n\t\tint res = x;\n\t\twhile (res[f] != res) res = res[f];\n\t\tfor (int i = x, tmp; i != res; ) {\n\t\t\ttmp = i[f];\n\t\t\taddTo(i, res);\n\t\t\ti[f] = res;\n\t\t\ti = tmp;\n\t\t}\n\n\t\tif (size) *size = this->size[res];\n\t\tif (max) *max = A[this->max[res]];\n\t\tif (max2) *max2 = A[this->max2[res]];\n\t\tif (min) *min = A[this->min[res]];\n\t\tif (min2) *min2 = A[this->min2[res]];\n\n\t\treturn res;\n\t}\n\n\tbool test(const int a, const int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(const int a, const int b) {\n\t\t// printf(\"merge(%d, %d)\\n\", a, b);\n\t\tint x = find(a), y = find(b);\n\t\t// printf(\"-- merge(%d, %d)\\n\", x, y);\n\t\tassert(x != y);\n\t\taddTo(x, y);\n\t\tx[f] = y;\n\t}\n\n#ifdef DBG\n\tvoid print() {\n\t\tfor (int i = 1; i < n; i++) find(i);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (invalid[i]) continue;\n\t\t\tprintf(\"[%d]: \", i);\n\t\t\tif (f[i] == i) printf(\"root, \");\n\t\t\telse printf(\"f = %d, \", f[i]);\n\n\t\t\tprintf(\"[%d, %d], size = %d, max = [%d] -> %d, max2 = [%d] -> %d, min = [%d] -> %d, min2 = [%d] -> %d\\n\", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]);\n\t\t}\n\t}\n#endif\n} ufs;\n\ninline long long calcCnt(const int x) {\n\tint size;\n\tufs.find(x, &size);\n\tlong long cnt = static_cast<long long>(size) * (size + 1) / 2;\n\t// printf(\"cnt(%d) = %d\\n\", x, cnt);\n\treturn cnt;\n}\n\ninline long long calcMax(const int x) {\n\tint max, max2, min, min2;\n\tufs.find(x, NULL, &max, &max2, &min, &min2);\n\treturn std::max(static_cast<long long>(max) * max2, static_cast<long long>(min) * min2);\n}\n\nint main() {\n\tscanf(\"%d\\n%s\", &n, s);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) A[i] = a[sa[i]];\n\n\tufs.init();\n\n\tstd::vector<int> v[MAXN];\n\tfor (int i = 1; i < n; i++) v[ht[i]].push_back(i);\n\n\tlong long cnt = 0, max = LLONG_MIN;\n\tstd::stack< std::pair<long long, long long> > stack;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t// printf(\"ht[%d] = %d\\n\", *it, ht[*it]);\n\n\t\t\tif (!(it != v[i].end() - 1 && ufs.test(*(it + 1), *it + 1))) {\n\t\t\t\tif (*it != n - 1) {\n\t\t\t\t\tif (ht[*it + 1] >= ht[*it] && !ufs.test(*it + 1, *it)) {\n\t\t\t\t\t\t// puts(\"------- + 1\");\n\t\t\t\t\t\tcnt -= calcCnt(*it + 1);\n\t\t\t\t\t\tufs.merge(*it, *it + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*it != 1 && ht[*it - 1] >= ht[*it] && !ufs.test(*it - 1, *it)) {\n\t\t\t\t// puts(\"------- - 1\");\n\t\t\t\tcnt -= calcCnt(*it - 1);\n\t\t\t\tufs.merge(*it, *it - 1);\n\t\t\t}\n\n\t\t\t// puts(\"+++++++\");\n\t\t\tcnt += calcCnt(*it);\n\t\t\tmax = std::max(max, calcMax(*it));\n#ifdef DBG\n\t\t\tprintf(\"calcMax(%d) = %lld\\n\", *it, calcMax(*it));\n#endif\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", cnt, max == LLONG_MIN ? 0 : max);\n\t\tif (cnt != 0) ufs.print();\n#else\n\t\tstack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max));\n#endif\n\t}\n\n#ifndef DBG\n\twhile (!stack.empty()) {\n\t\tprintf(\"%lld %lld\\n\", stack.top().first, stack.top().second);\n\t\tstack.pop();\n\t}\n#endif\n\n\treturn 0;\n}\n```\n","slug":"noi2015-savour","published":1,"updated":"2016-07-01T01:28:39.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ro700q4ooxl1wfasfhv"},{"title":"NOI2015 -  + ","id":"34","updated":"2016-01-21T13:36:13.000Z","date":"2016-01-21T13:32:49.000Z","_content":"\n `n` $x_i=x_j$$x_ix_j$ / \n\n<!-- more -->\n\n### \n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### \n`x` \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-prog.md","raw":"title: NOI2015 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  - map\npermalink: noi2015-prog\nid: 34\nupdated: '2016-01-21 21:36:13'\ndate: 2016-01-21 21:32:49\n---\n\n `n` $x_i=x_j$$x_ix_j$ / \n\n<!-- more -->\n\n### \n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### \n`x` \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2015-prog","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rob00qbooxle38fb1mx"},{"title":"NOI2015 - ","id":"35","updated":"2016-01-29T00:22:32.000Z","date":"2016-01-23T02:10:12.000Z","_content":"\n A  B A  B BA 0  0 \n\n<!-- more -->\n\n### \n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### \n\n\n1. \n2. \n3. \n4. \n\n DFS DFS  DFS  DFS  DFS  DFS \n\n### \n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2015-manager.md","raw":"title: NOI2015 - \ncategories: OI\ntags: \n  - NOI\n  - CodeVS\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-manager\nid: 35\nupdated: '2016-01-29 08:22:32'\ndate: 2016-01-23 10:10:12\n---\n\n A  B A  B BA 0  0 \n\n<!-- more -->\n\n### \n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### \n\n\n1. \n2. \n3. \n4. \n\n DFS DFS  DFS  DFS  DFS  DFS \n\n### \n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2015-manager","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9roi00qnooxl0d6iws72"},{"title":"NOI2015 - DP + ","date":"2016-06-29T10:33:00.000Z","_content":"\n $ n $ \n\n1.  $ 45 ^ \\circ $ $ 45 ^ \\circ $ ********\n2.  (1) \n3.  (1) **** $ 45 ^ \\circ $ $ 45 ^ \\circ $  DAG DAG \n\n<!-- more -->\n\n### \n[BZOJ 4200](http://www.lydsy.com/JudgeOnline/problem.php?id=4200)  \n[UOJ #132](http://uoj.ac/problem/132)\n\n### \n#### \n $ (x_1, y_1) $  $ (x_2, y_2) $ $ y_1 = y_2 $ $ x_1 + y_1 = x_2 + y_2 $  $ x_1 - y_1 = x_2 - y_2 $\n\n\n\n\n\n1. \n2. \n\n  \n\n $ a $$ b $$ a $  $ b $  $ a $  $ b $  $ a $  $ a $  $ b $\n\n $ a $  $ b $  $ a $  $ 1 $  $ b $ \n\n|   | 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 5 | 0 | 1 | 2 | 3 | 4 |\n| 5 | 4 | 0 | 2 | 3 | 4 |\n| 5 | 4 | 3 | 0 | 3 | 4 |\n| 5 | 4 | 3 | 2 | 0 | 4 |\n| 5 | 4 | 3 | 2 | 1 | 0 |\n\n $ b $  $ b $  $ O(\\log n) $ \n\n $ O(n \\log n) $\n\n#### \n\n\n\n\n#### \n\n\n $ 1 $ $ +\\infty $ \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <tr1/functional>\n\nconst int MAXN = 50000 + 1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, in;\n} N[MAXN + 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f;\n\t\t\t\te->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"dinic(%d, %d, %d) = %d\\n\", s, t, n, res);\n#endif\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n#ifdef DBG\n\tprintf(\"E(%d, %d, %d)\\n\", s, t, c);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void addEdge(const int s, const int t, const int l, const int r) {\n\tN[s].in -= l;\n\tN[t].in += l;\n\taddEdge(s, t, r - l);\n}\n\ninline int minFlow(const int s, const int t, const int n) {\n\tconst int S = n, T = n + 1;\n\tint full = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].in > 0) addEdge(S, i, N[i].in), full += N[i].in;\n\t\telse if (N[i].in < 0) addEdge(i, T, -N[i].in);\n\t}\n\tEdge *e = addEdge(t, s, INT_MAX);\n\n\tassert(dinic(S, T, n + 2) == full);\n\n\tint f = e->f;\n\n\te->c = e->r->c = 0;\n\tfor (e = N[s].e; e; e = e->next) e->c = e->r->c = 0;\n\tfor (e = N[t].e; e; e = e->next) e->c = e->r->c = 0;\n\n\treturn f - dinic(t, s, n);\n}\n\nstruct DPValue;\nstruct Point;\n\nstruct DPValue {\n\tPoint *prec;\n\tint x;\n\n\tDPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {}\n\n\tDPValue extend(Point &p, const int delta) { return DPValue(&p, x + delta); }\n\n\toperator int() const { return x; }\n};\n\nstruct Point {\n\tint id, x, y, lineIndex;\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator itX, itDiagonal1, itDiagonal2;\n\tDPValue dpUp, dpInline;\n\tbool flagUp, flagInline;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorY() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorX() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal1() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal2() const;\n};\n\nbool compareByY(const Point &a, const Point &b) { return a.y > b.y; }\nbool compareByX(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal1(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal2(const Point &a, const Point &b) { return a.x < b.x; }\n\nint n, lineCnt;\nPoint a[MAXN];\nstd::vector< std::tr1::reference_wrapper<Point> > lines[MAXN];\nstd::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > > mapX, mapDiagonal1, mapDiagonal2;\n\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorY() const { return lines[lineIndex]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorX() const { return mapX[x]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; }\n\ninline void dpUp(const int lineIndex) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = v.begin(); it != v.end(); it++) {\n\t\tPoint &p = it->get();\n\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\tif (p.itX != p.getVectorX().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itX - 1)->get().dpInline.extend((p.itX - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)->get().dpInline.extend((p.itDiagonal1 - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)->get().dpInline.extend((p.itDiagonal2 - 1)->get(), 1));\n\t\t}\n\t}\n}\n\ninline void dpInline(const int lineIndex) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\n\tsegment = SegmentTree::build(0, v.size() - 1);\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), i));\n\t}\n\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i].get().dpInline = segment->query();\n\t\tif (i < v.size() - 1) {\n\t\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1));\n\t\t\tsegment->update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0));\n\t\t}\n\t}\n\n\tdelete segment;\n}\n\ninline void dp() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != 0) dpUp(i);\n\t\tdpInline(i);\n\t}\n}\n\ninline void getInlinePath(std::vector<Point *> &v, Point *s, Point *t) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &line = s->getVectorY();\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator a = std::lower_bound(line.begin(), line.end(), *s, &compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &compareByX);\n\n\tassert(&a->get() == s);\n\tassert(&b->get() == t);\n\n#ifdef DBG\n\tprintf(\"getInlinePath(%d(%d, %d), %d(%d, %d))\\n\", s->id, s->x, s->y, t->id, t->x, t->y);\n#endif\n\n\tif (a < b) {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= line.begin(); it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it <= b; it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t} else {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it != line.end(); it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= b; it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t}\n}\n\ninline void getPath(std::vector<Point *> &v) {\n\tPoint *p = &a[n - 1];\n\tbool flag = false;\n\twhile (p->dpUp.x || (!flag && p->dpInline.x && p->dpInline.prec != p)) {\n\t\tif (flag || p->dpInline.prec == p || p->dpInline.x <= p->dpUp.x) {\n#ifdef DBG\n\t\t\tprintf(\"%d(%d, %d) -> %d(%d, %d)\\n\", p->id, p->x, p->y, p->dpUp.prec->id, p->dpUp.prec->x, p->dpUp.prec->y);\n#endif\n\t\t\tp = p->dpUp.prec;\n\t\t\tv.push_back(p);\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tgetInlinePath(v, p, p->dpInline.prec);\n\t\t\tp = p->dpInline.prec;\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\ninline void getEdges(std::vector< std::pair<Point *, Point *> > &E) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\t\tbool flag;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (flag) pushDown();\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (flag) {\n\t\t\t\tif (lc || rc) {\n\t\t\t\t\tif (val.x == lc->val.x) lc->flag = true;\n\t\t\t\t\tif (val.x == rc->val.x) rc->flag = true;\n\t\t\t\t} else {\n\t\t\t\t\tval.prec->flagInline = true;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tpushDown();\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tvoid mark() { flag = true; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\ta[n - 1].flagUp = true;\n\n\tfor (int i = lineCnt - 1; i >= 0; i--) {\n\t\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[i];\n\t\tsegment = SegmentTree::build(0, v.size() - 1);\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), j));\n\t\t}\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagUp) {\n\t\t\t\tsegment->mark();\n\t\t\t}\n\n\t\t\tif (j < v.size() - 1) {\n\t\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1));\n\t\t\t\tsegment->update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0));\n\t\t\t}\n\t\t}\n\n\t\tdelete segment;\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagInline) {\n\t\t\t\tPoint &p = v[j].get();\n\t\t\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\t\t\tif (p.itX != p.getVectorX().begin() && p.dpUp.x == (p.itX - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itX - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itX - 1)->get().x, (p.itX - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itX - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin() && p.dpUp.x == (p.itDiagonal1 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal1 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal1 - 1)->get().x, (p.itDiagonal1 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal1 - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin() && p.dpUp.x == (p.itDiagonal2 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal2 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal2 - 1)->get().x, (p.itDiagonal2 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal2 - 1)->get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void sort() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tstd::sort(lines[i].begin(), lines[i].end(), &compareByX);\n\t}\n\t\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByY);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itX = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal2);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal1 = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal1);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal2 = it2;\n\t\t}\n\t}\n}\n\n#ifdef DBG\ninline void debugPrint() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tprintf(\"lines[%d] = { \", i);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) {\n\t\t\tconst Point &p = *it;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it + 1 == lines[i].end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tprintf(\"x[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tprintf(\"diagonal1[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tprintf(\"diagonal2[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"(%d, %d): \", a[i].x, a[i].y);\n\t\tif (a[i].dpUp.prec) printf(\"dpUp[%d] = { (%d, %d), %d }, \", i, a[i].dpUp.prec->x, a[i].dpUp.prec->y, a[i].dpUp.x);\n\t\telse printf(\"dpUp[%d] = { nullptr, %d }, \", i, a[i].dpUp.x);\n\t\tif (a[i].dpInline.prec) printf(\"dpInline[%d] = { (%d, %d), %d }\\n\", i, a[i].dpInline.prec->x, a[i].dpInline.prec->y, a[i].dpInline.x);\n\t\telse printf(\"dpInline[%d] = { nullptr, %d }\\n\", i, a[i].dpInline.x);\n\t}\n}\n#endif\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t\ta[i].id = i;\n\t}\n\ta[n].x = 0, a[n].y = 0, a[n].id = n, n++;\n\n\tstd::sort(a, a + n, &compareByY);\n\n\tfor (int i = 0, last; i < n; i++) {\n\t\tPoint &p = a[i];\n\n\t\tif (!i || p.y != a[last].y) ++lineCnt;\n\t\tlines[lineCnt - 1].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tp.lineIndex = lineCnt - 1;\n\n\t\tmapX[p.x].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\n\t\tlast = i;\n\t}\n\n\tsort();\n\n\n#ifdef DBG\n\tdebugPrint();\n#endif\n\t\n\tdp();\n\n\tint cnt = a[n - 1].dpInline.x;\n\tprintf(\"%d\\n\", cnt);\n\n\tstd::vector<Point *> v;\n\tgetPath(v);\n#ifdef DBG\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d: (%d, %d)\\n\", v[i]->id + 1, v[i]->x, v[i]->y);\n#else\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d%c\", v[i]->id + 1, i == v.size() - 1 ? '\\n' : ' ');\n#endif\n\n\tstd::vector< std::pair<Point *, Point *> > E;\n\tgetEdges(E);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX);\n\tfor (std::vector< std::pair<Point *, Point *> >::const_iterator it = E.begin(); it != E.end(); it++) {\n\t\taddEdge(it->first->id + 1, it->second->id + 1, 1, INT_MAX);\n\t}\n\n\tprintf(\"%d\\n\", minFlow(s, t, n + 2));\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-farm.md","raw":"title: NOI2015 - DP + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - DP\n  - \n  - \n  - Dinic\npermalink: noi2015-farm\ndate: 2016-06-29 18:33:00\n---\n\n $ n $ \n\n1.  $ 45 ^ \\circ $ $ 45 ^ \\circ $ ********\n2.  (1) \n3.  (1) **** $ 45 ^ \\circ $ $ 45 ^ \\circ $  DAG DAG \n\n<!-- more -->\n\n### \n[BZOJ 4200](http://www.lydsy.com/JudgeOnline/problem.php?id=4200)  \n[UOJ #132](http://uoj.ac/problem/132)\n\n### \n#### \n $ (x_1, y_1) $  $ (x_2, y_2) $ $ y_1 = y_2 $ $ x_1 + y_1 = x_2 + y_2 $  $ x_1 - y_1 = x_2 - y_2 $\n\n\n\n\n\n1. \n2. \n\n  \n\n $ a $$ b $$ a $  $ b $  $ a $  $ b $  $ a $  $ a $  $ b $\n\n $ a $  $ b $  $ a $  $ 1 $  $ b $ \n\n|   | 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 5 | 0 | 1 | 2 | 3 | 4 |\n| 5 | 4 | 0 | 2 | 3 | 4 |\n| 5 | 4 | 3 | 0 | 3 | 4 |\n| 5 | 4 | 3 | 2 | 0 | 4 |\n| 5 | 4 | 3 | 2 | 1 | 0 |\n\n $ b $  $ b $  $ O(\\log n) $ \n\n $ O(n \\log n) $\n\n#### \n\n\n\n\n#### \n\n\n $ 1 $ $ +\\infty $ \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <tr1/functional>\n\nconst int MAXN = 50000 + 1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, in;\n} N[MAXN + 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f;\n\t\t\t\te->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"dinic(%d, %d, %d) = %d\\n\", s, t, n, res);\n#endif\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n#ifdef DBG\n\tprintf(\"E(%d, %d, %d)\\n\", s, t, c);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void addEdge(const int s, const int t, const int l, const int r) {\n\tN[s].in -= l;\n\tN[t].in += l;\n\taddEdge(s, t, r - l);\n}\n\ninline int minFlow(const int s, const int t, const int n) {\n\tconst int S = n, T = n + 1;\n\tint full = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].in > 0) addEdge(S, i, N[i].in), full += N[i].in;\n\t\telse if (N[i].in < 0) addEdge(i, T, -N[i].in);\n\t}\n\tEdge *e = addEdge(t, s, INT_MAX);\n\n\tassert(dinic(S, T, n + 2) == full);\n\n\tint f = e->f;\n\n\te->c = e->r->c = 0;\n\tfor (e = N[s].e; e; e = e->next) e->c = e->r->c = 0;\n\tfor (e = N[t].e; e; e = e->next) e->c = e->r->c = 0;\n\n\treturn f - dinic(t, s, n);\n}\n\nstruct DPValue;\nstruct Point;\n\nstruct DPValue {\n\tPoint *prec;\n\tint x;\n\n\tDPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {}\n\n\tDPValue extend(Point &p, const int delta) { return DPValue(&p, x + delta); }\n\n\toperator int() const { return x; }\n};\n\nstruct Point {\n\tint id, x, y, lineIndex;\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator itX, itDiagonal1, itDiagonal2;\n\tDPValue dpUp, dpInline;\n\tbool flagUp, flagInline;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorY() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorX() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal1() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal2() const;\n};\n\nbool compareByY(const Point &a, const Point &b) { return a.y > b.y; }\nbool compareByX(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal1(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal2(const Point &a, const Point &b) { return a.x < b.x; }\n\nint n, lineCnt;\nPoint a[MAXN];\nstd::vector< std::tr1::reference_wrapper<Point> > lines[MAXN];\nstd::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > > mapX, mapDiagonal1, mapDiagonal2;\n\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorY() const { return lines[lineIndex]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorX() const { return mapX[x]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; }\n\ninline void dpUp(const int lineIndex) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = v.begin(); it != v.end(); it++) {\n\t\tPoint &p = it->get();\n\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\tif (p.itX != p.getVectorX().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itX - 1)->get().dpInline.extend((p.itX - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)->get().dpInline.extend((p.itDiagonal1 - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)->get().dpInline.extend((p.itDiagonal2 - 1)->get(), 1));\n\t\t}\n\t}\n}\n\ninline void dpInline(const int lineIndex) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\n\tsegment = SegmentTree::build(0, v.size() - 1);\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), i));\n\t}\n\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i].get().dpInline = segment->query();\n\t\tif (i < v.size() - 1) {\n\t\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1));\n\t\t\tsegment->update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0));\n\t\t}\n\t}\n\n\tdelete segment;\n}\n\ninline void dp() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != 0) dpUp(i);\n\t\tdpInline(i);\n\t}\n}\n\ninline void getInlinePath(std::vector<Point *> &v, Point *s, Point *t) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &line = s->getVectorY();\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator a = std::lower_bound(line.begin(), line.end(), *s, &compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &compareByX);\n\n\tassert(&a->get() == s);\n\tassert(&b->get() == t);\n\n#ifdef DBG\n\tprintf(\"getInlinePath(%d(%d, %d), %d(%d, %d))\\n\", s->id, s->x, s->y, t->id, t->x, t->y);\n#endif\n\n\tif (a < b) {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= line.begin(); it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it <= b; it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t} else {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it != line.end(); it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= b; it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t}\n}\n\ninline void getPath(std::vector<Point *> &v) {\n\tPoint *p = &a[n - 1];\n\tbool flag = false;\n\twhile (p->dpUp.x || (!flag && p->dpInline.x && p->dpInline.prec != p)) {\n\t\tif (flag || p->dpInline.prec == p || p->dpInline.x <= p->dpUp.x) {\n#ifdef DBG\n\t\t\tprintf(\"%d(%d, %d) -> %d(%d, %d)\\n\", p->id, p->x, p->y, p->dpUp.prec->id, p->dpUp.prec->x, p->dpUp.prec->y);\n#endif\n\t\t\tp = p->dpUp.prec;\n\t\t\tv.push_back(p);\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tgetInlinePath(v, p, p->dpInline.prec);\n\t\t\tp = p->dpInline.prec;\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\ninline void getEdges(std::vector< std::pair<Point *, Point *> > &E) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\t\tbool flag;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (flag) pushDown();\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (flag) {\n\t\t\t\tif (lc || rc) {\n\t\t\t\t\tif (val.x == lc->val.x) lc->flag = true;\n\t\t\t\t\tif (val.x == rc->val.x) rc->flag = true;\n\t\t\t\t} else {\n\t\t\t\t\tval.prec->flagInline = true;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tpushDown();\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tvoid mark() { flag = true; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\ta[n - 1].flagUp = true;\n\n\tfor (int i = lineCnt - 1; i >= 0; i--) {\n\t\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[i];\n\t\tsegment = SegmentTree::build(0, v.size() - 1);\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), j));\n\t\t}\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagUp) {\n\t\t\t\tsegment->mark();\n\t\t\t}\n\n\t\t\tif (j < v.size() - 1) {\n\t\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1));\n\t\t\t\tsegment->update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0));\n\t\t\t}\n\t\t}\n\n\t\tdelete segment;\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagInline) {\n\t\t\t\tPoint &p = v[j].get();\n\t\t\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\t\t\tif (p.itX != p.getVectorX().begin() && p.dpUp.x == (p.itX - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itX - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itX - 1)->get().x, (p.itX - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itX - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin() && p.dpUp.x == (p.itDiagonal1 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal1 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal1 - 1)->get().x, (p.itDiagonal1 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal1 - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin() && p.dpUp.x == (p.itDiagonal2 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal2 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal2 - 1)->get().x, (p.itDiagonal2 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal2 - 1)->get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void sort() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tstd::sort(lines[i].begin(), lines[i].end(), &compareByX);\n\t}\n\t\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByY);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itX = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal2);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal1 = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal1);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal2 = it2;\n\t\t}\n\t}\n}\n\n#ifdef DBG\ninline void debugPrint() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tprintf(\"lines[%d] = { \", i);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) {\n\t\t\tconst Point &p = *it;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it + 1 == lines[i].end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tprintf(\"x[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tprintf(\"diagonal1[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tprintf(\"diagonal2[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"(%d, %d): \", a[i].x, a[i].y);\n\t\tif (a[i].dpUp.prec) printf(\"dpUp[%d] = { (%d, %d), %d }, \", i, a[i].dpUp.prec->x, a[i].dpUp.prec->y, a[i].dpUp.x);\n\t\telse printf(\"dpUp[%d] = { nullptr, %d }, \", i, a[i].dpUp.x);\n\t\tif (a[i].dpInline.prec) printf(\"dpInline[%d] = { (%d, %d), %d }\\n\", i, a[i].dpInline.prec->x, a[i].dpInline.prec->y, a[i].dpInline.x);\n\t\telse printf(\"dpInline[%d] = { nullptr, %d }\\n\", i, a[i].dpInline.x);\n\t}\n}\n#endif\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t\ta[i].id = i;\n\t}\n\ta[n].x = 0, a[n].y = 0, a[n].id = n, n++;\n\n\tstd::sort(a, a + n, &compareByY);\n\n\tfor (int i = 0, last; i < n; i++) {\n\t\tPoint &p = a[i];\n\n\t\tif (!i || p.y != a[last].y) ++lineCnt;\n\t\tlines[lineCnt - 1].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tp.lineIndex = lineCnt - 1;\n\n\t\tmapX[p.x].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\n\t\tlast = i;\n\t}\n\n\tsort();\n\n\n#ifdef DBG\n\tdebugPrint();\n#endif\n\t\n\tdp();\n\n\tint cnt = a[n - 1].dpInline.x;\n\tprintf(\"%d\\n\", cnt);\n\n\tstd::vector<Point *> v;\n\tgetPath(v);\n#ifdef DBG\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d: (%d, %d)\\n\", v[i]->id + 1, v[i]->x, v[i]->y);\n#else\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d%c\", v[i]->id + 1, i == v.size() - 1 ? '\\n' : ' ');\n#endif\n\n\tstd::vector< std::pair<Point *, Point *> > E;\n\tgetEdges(E);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX);\n\tfor (std::vector< std::pair<Point *, Point *> >::const_iterator it = E.begin(); it != E.end(); it++) {\n\t\taddEdge(it->first->id + 1, it->second->id + 1, 1, INT_MAX);\n\t}\n\n\tprintf(\"%d\\n\", minFlow(s, t, n + 2));\n\n\treturn 0;\n}\n```\n","slug":"noi2015-farm","published":1,"updated":"2016-11-01T11:59:21.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ron00qvooxltvmba5m0"},{"title":"NOI2015 - ","date":"2016-07-01T01:27:00.000Z","_content":"\n $ n $  $ 1 $  $ n $  $ i $  $ W_i $ $ k $  $ S_i $  $ i $  $ 1 \\leq i,j \\leq n,\\ i \\neq j $$ S_i $  $ S_j $ \n\n1. \n2.  $ S_i $ \n\n<!-- more -->\n\n### \n[BZOJ 4198](http://www.lydsy.com/JudgeOnline/problem.php?id=4198)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n $ k = 2 $ \n\n$ k \\neq 2 $ $ k $ \n\n $ S_i $  $ S_i $ \n\n $ k $  $ 1 $  $ k $  $ k - 1 $  $ n - 1 $   $ W_i = 0 $ $ (n - 1) \\bmod (k - 1) = 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100000;\nconst int MAXK = 9;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tstd::priority_queue< std::pair<long long, int>, std::vector< std::pair<long long, int> >, std::greater< std::pair<long long, int> > > q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long x;\n\t\tscanf(\"%lld\", &x);\n\t\tq.push(std::make_pair(x, 0));\n\t}\n\n\twhile ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0));\n\n\tlong long ans = 0;\n\twhile (q.size() > 1) {\n\t\tstd::pair<long long, int> newNode;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstd::pair<long long, int> p = q.top();\n\t\t\tq.pop();\n\t\t\tans += p.first;\n\t\t\tnewNode.first += p.first;\n\t\t\tnewNode.second = std::max(newNode.second, p.second);\n\t\t}\n\n\t\tnewNode.second++;\n\n\t\tq.push(newNode);\n\t}\n\n\tstd::pair<long long, int> p = q.top();\n\tprintf(\"%lld\\n%d\\n\", ans, p.second);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-epic.md","raw":"title: NOI2015 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-epic\ndate: 2016-07-01 09:27:00\n---\n\n $ n $  $ 1 $  $ n $  $ i $  $ W_i $ $ k $  $ S_i $  $ i $  $ 1 \\leq i,j \\leq n,\\ i \\neq j $$ S_i $  $ S_j $ \n\n1. \n2.  $ S_i $ \n\n<!-- more -->\n\n### \n[BZOJ 4198](http://www.lydsy.com/JudgeOnline/problem.php?id=4198)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n $ k = 2 $ \n\n$ k \\neq 2 $ $ k $ \n\n $ S_i $  $ S_i $ \n\n $ k $  $ 1 $  $ k $  $ k - 1 $  $ n - 1 $   $ W_i = 0 $ $ (n - 1) \\bmod (k - 1) = 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100000;\nconst int MAXK = 9;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tstd::priority_queue< std::pair<long long, int>, std::vector< std::pair<long long, int> >, std::greater< std::pair<long long, int> > > q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long x;\n\t\tscanf(\"%lld\", &x);\n\t\tq.push(std::make_pair(x, 0));\n\t}\n\n\twhile ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0));\n\n\tlong long ans = 0;\n\twhile (q.size() > 1) {\n\t\tstd::pair<long long, int> newNode;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstd::pair<long long, int> p = q.top();\n\t\t\tq.pop();\n\t\t\tans += p.first;\n\t\t\tnewNode.first += p.first;\n\t\t\tnewNode.second = std::max(newNode.second, p.second);\n\t\t}\n\n\t\tnewNode.second++;\n\n\t\tq.push(newNode);\n\t}\n\n\tstd::pair<long long, int> p = q.top();\n\tprintf(\"%lld\\n%d\\n\", ans, p.second);\n\n\treturn 0;\n}\n```\n","slug":"noi2015-epic","published":1,"updated":"2016-07-01T01:28:31.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rou00r4ooxl3cv5u0r4"},{"title":"NOI2015 -  DP","date":"2016-07-01T05:23:00.000Z","_content":"\n $ 2 $ ~ $ n $  $ n - 1 $  $ a $  $ b $ $ \\gcd(a, b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 4197](http://www.lydsy.com/JudgeOnline/problem.php?id=4197)  \n[UOJ #129](http://uoj.ac/problem/129)\n\n### \n $ f(a, b) $$ a $$ b $  $ a $ $ b $ \n\n $ x $  $ \\sqrt x $  $ 8 $   $ 2, 3, 5, 7, 11, 13, 17, 19 $\n\n $ z $ $ z $  $ z $ \n\n $ z $  $ i $  $ S_i $\n\n $ f(a, b) $ **** $ a $ $ b $ \n\n $ g(i, k, a, b) $  $ i $  $ k $  $ a $ $ b $ \n\n $ x $ $ g(i - 1, 0) $  $ g(i - 1, 1) $  $ g(i, 0) $  $ g(i, 1) $\n\n$$\n\\begin{aligned}\ng(i, 0, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap b \\neq \\emptyset \\\\\n  \\sum\\limits_{a' \\cup S_i = a} g(i - 1, a', b) + f(a, b) & S_i \\cap b = \\emptyset\n  \\end{cases} \\\\\ng(i, 1, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap a \\neq \\emptyset \\\\\n  \\sum\\limits_{b' \\cup S_i = b} g(i - 1, a, b') + f(a, b) & S_i \\cap a = \\emptyset\n  \\end{cases}\n\\end{aligned}\n$$\n\n $ a' $  $ b' $  $ a' $  $ b' $  $ a $  $ b $  $ a' \\leq a $$ b' \\leq b $ $ i $ $ a $  $ b $ $ g(0) $  $ g(1) $\n\n$$\n\\mathrm {for \\ each} \\ i.\\ a = U \\to \\emptyset,\\ b = U \\to \\emptyset \\\\\n\\begin{aligned}\ng(0, a \\cup S_i, b) \\leftarrow g(0, a \\cup S_i, b) + g(0, a, b) && S_i \\cap b = \\emptyset \\\\\ng(0, a, b \\cup S_i) \\leftarrow g(0, a, b \\cup S_i) + g(0, a, b) && S_i \\cap a = \\emptyset \\\\\n\\end{aligned}\n$$\n\n $ \\sqrt x $  $ x $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 500;\nconst int MAXK = 8;\nconst int MAXSTAT = 1 << 8;\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };\n\nint main() {\n\tint n, p;\n\tscanf(\"%d %d\", &n, &p);\n\n\tstd::vector< std::vector<int> > v;\n\tstd::vector< std::pair<int, int> > tmp;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x = i, t = 0;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (x % PRIMES[j] == 0) {\n\t\t\t\twhile (x % PRIMES[j] == 0) x /= PRIMES[j];\n\t\t\t\tt |= 1 << j;\n\t\t\t}\n\t\t}\n\n\t\ttmp.push_back(std::make_pair(x, t));\n\t}\n\n\tstd::sort(tmp.begin(), tmp.end());\n\n\tfor (std::vector< std::pair<int, int> >::const_iterator it = tmp.begin(); it != tmp.end(); it++) {\n\t\tif (it == tmp.begin() || it->first == 1 || it->first != (it - 1)->first) {\n\t\t\tv.resize(v.size() + 1);\n\t\t}\n\t\tv.back().push_back(it->second);\n\t}\n\n\tstatic int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT];\n\tf[0][0] = 1;\n\tfor (std::vector< std::vector<int> >::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tmemcpy(g[0], f, sizeof(f));\n\t\tmemcpy(g[1], f, sizeof(f));\n\n\t\t// puts(\"new\");\n\t\tfor (std::vector<int>::const_iterator it2 = it->begin(); it2 != it->end(); it2++) {\n\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\t\t// printf(\"%d %d\\n\", a, b);\n\t\t\t\t\tif (!(b & *it2)) /* printf(\"[0] += %d\\n\", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p;\n\t\t\t\t\tif (!(a & *it2)) /* printf(\"[1] += %d\\n\", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p;\n\t\t\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\t\t\t// printf(\"%d %d\\n\", g[0][a][b], g[1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\tf[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\tif (!(a & b)) (ans += f[a][b]) %= p;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-dinner.md","raw":"title: NOI2015 -  DP\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - DP\n  -  DP\n  -  DP\npermalink: noi2015-dinner\ndate: 2016-07-01 13:23:00\n---\n\n $ 2 $ ~ $ n $  $ n - 1 $  $ a $  $ b $ $ \\gcd(a, b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 4197](http://www.lydsy.com/JudgeOnline/problem.php?id=4197)  \n[UOJ #129](http://uoj.ac/problem/129)\n\n### \n $ f(a, b) $$ a $$ b $  $ a $ $ b $ \n\n $ x $  $ \\sqrt x $  $ 8 $   $ 2, 3, 5, 7, 11, 13, 17, 19 $\n\n $ z $ $ z $  $ z $ \n\n $ z $  $ i $  $ S_i $\n\n $ f(a, b) $ **** $ a $ $ b $ \n\n $ g(i, k, a, b) $  $ i $  $ k $  $ a $ $ b $ \n\n $ x $ $ g(i - 1, 0) $  $ g(i - 1, 1) $  $ g(i, 0) $  $ g(i, 1) $\n\n$$\n\\begin{aligned}\ng(i, 0, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap b \\neq \\emptyset \\\\\n  \\sum\\limits_{a' \\cup S_i = a} g(i - 1, a', b) + f(a, b) & S_i \\cap b = \\emptyset\n  \\end{cases} \\\\\ng(i, 1, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap a \\neq \\emptyset \\\\\n  \\sum\\limits_{b' \\cup S_i = b} g(i - 1, a, b') + f(a, b) & S_i \\cap a = \\emptyset\n  \\end{cases}\n\\end{aligned}\n$$\n\n $ a' $  $ b' $  $ a' $  $ b' $  $ a $  $ b $  $ a' \\leq a $$ b' \\leq b $ $ i $ $ a $  $ b $ $ g(0) $  $ g(1) $\n\n$$\n\\mathrm {for \\ each} \\ i.\\ a = U \\to \\emptyset,\\ b = U \\to \\emptyset \\\\\n\\begin{aligned}\ng(0, a \\cup S_i, b) \\leftarrow g(0, a \\cup S_i, b) + g(0, a, b) && S_i \\cap b = \\emptyset \\\\\ng(0, a, b \\cup S_i) \\leftarrow g(0, a, b \\cup S_i) + g(0, a, b) && S_i \\cap a = \\emptyset \\\\\n\\end{aligned}\n$$\n\n $ \\sqrt x $  $ x $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 500;\nconst int MAXK = 8;\nconst int MAXSTAT = 1 << 8;\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };\n\nint main() {\n\tint n, p;\n\tscanf(\"%d %d\", &n, &p);\n\n\tstd::vector< std::vector<int> > v;\n\tstd::vector< std::pair<int, int> > tmp;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x = i, t = 0;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (x % PRIMES[j] == 0) {\n\t\t\t\twhile (x % PRIMES[j] == 0) x /= PRIMES[j];\n\t\t\t\tt |= 1 << j;\n\t\t\t}\n\t\t}\n\n\t\ttmp.push_back(std::make_pair(x, t));\n\t}\n\n\tstd::sort(tmp.begin(), tmp.end());\n\n\tfor (std::vector< std::pair<int, int> >::const_iterator it = tmp.begin(); it != tmp.end(); it++) {\n\t\tif (it == tmp.begin() || it->first == 1 || it->first != (it - 1)->first) {\n\t\t\tv.resize(v.size() + 1);\n\t\t}\n\t\tv.back().push_back(it->second);\n\t}\n\n\tstatic int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT];\n\tf[0][0] = 1;\n\tfor (std::vector< std::vector<int> >::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tmemcpy(g[0], f, sizeof(f));\n\t\tmemcpy(g[1], f, sizeof(f));\n\n\t\t// puts(\"new\");\n\t\tfor (std::vector<int>::const_iterator it2 = it->begin(); it2 != it->end(); it2++) {\n\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\t\t// printf(\"%d %d\\n\", a, b);\n\t\t\t\t\tif (!(b & *it2)) /* printf(\"[0] += %d\\n\", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p;\n\t\t\t\t\tif (!(a & *it2)) /* printf(\"[1] += %d\\n\", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p;\n\t\t\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\t\t\t// printf(\"%d %d\\n\", g[0][a][b], g[1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\tf[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\tif (!(a & b)) (ans += f[a][b]) %= p;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2015-dinner","published":1,"updated":"2016-10-24T23:37:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rp300rdooxlqbidw1i1"},{"title":"NOI2014 - KMP","date":"2016-07-11T15:41:00.000Z","_content":"\n $ S $  $ i $  $ \\mathrm {num}(i) $\n\n$$\n\\prod\\limits_{i = 1} ^ n (\\mathrm{num}(i) + 1) \\pmod {1000000007}\n$$\n\n<!-- more -->\n\n### \n[BZOJ 3670](http://www.lydsy.com/JudgeOnline/problem.php?id=3670)  \n[UOJ #5](http://uoj.ac/problem/5)\n\n### \n DP  $ \\mathrm{num}(i) = \\mathrm{num}(\\mathrm{next}(i)) + 1 $\n\n   $ \\mathrm{next} $  $ \\mathrm{next2} $ $ \\mathrm{num} $ $ \\mathrm{num2} $ $ \\mathrm{num2}(i) = \\mathrm{num2}(\\mathrm{next2}(i)) + 1 $ \n\n$$ \\mathrm{num2}(i) = \\mathrm{num}(\\mathrm{next2}(i)) + 1 $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 5;\nconst int MAXN = 1000000;\nconst unsigned long long MOD = 1000000007;\n\nint n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1];\nchar s[MAXN + 1];\n\ninline unsigned long long kmp() {\n\tnext[0] = next[1] = num[0] = num[1] = 0;\n\tfor (int i = 2, t = 0, k = 0; i <= n; i++) {\n\t\twhile (t && s[t] != s[i - 1]) t = next[t];\n\t\twhile ((k && s[k] != s[i - 1]) || k >= i / 2) k = next[k];\n\n\t\tif (s[k] == s[i - 1]) num2[i] = num[++k] + 1;\n\t\telse num2[i] = 0;\n\n\t\tif (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1;\n\t\telse next[i] = num[i] = 0;\n\t}\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", f[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num2[i], i == n ? '\\n' : ' ');\n\n\tunsigned long long ans = 1;\n\tfor (int i = 1; i <= n; i++) (ans *= (num2[i] + 1)) %= MOD;\n\treturn ans;\n}\n\nint main() {\n\tint t = 1;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\n\t\tprintf(\"%llu\\n\", kmp());\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-zoo.md","raw":"title: NOI2014 - KMP\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - KMP\n  - \npermalink: noi2014-zoo\ndate: 2016-07-11 23:41:00\n---\n\n $ S $  $ i $  $ \\mathrm {num}(i) $\n\n$$\n\\prod\\limits_{i = 1} ^ n (\\mathrm{num}(i) + 1) \\pmod {1000000007}\n$$\n\n<!-- more -->\n\n### \n[BZOJ 3670](http://www.lydsy.com/JudgeOnline/problem.php?id=3670)  \n[UOJ #5](http://uoj.ac/problem/5)\n\n### \n DP  $ \\mathrm{num}(i) = \\mathrm{num}(\\mathrm{next}(i)) + 1 $\n\n   $ \\mathrm{next} $  $ \\mathrm{next2} $ $ \\mathrm{num} $ $ \\mathrm{num2} $ $ \\mathrm{num2}(i) = \\mathrm{num2}(\\mathrm{next2}(i)) + 1 $ \n\n$$ \\mathrm{num2}(i) = \\mathrm{num}(\\mathrm{next2}(i)) + 1 $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 5;\nconst int MAXN = 1000000;\nconst unsigned long long MOD = 1000000007;\n\nint n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1];\nchar s[MAXN + 1];\n\ninline unsigned long long kmp() {\n\tnext[0] = next[1] = num[0] = num[1] = 0;\n\tfor (int i = 2, t = 0, k = 0; i <= n; i++) {\n\t\twhile (t && s[t] != s[i - 1]) t = next[t];\n\t\twhile ((k && s[k] != s[i - 1]) || k >= i / 2) k = next[k];\n\n\t\tif (s[k] == s[i - 1]) num2[i] = num[++k] + 1;\n\t\telse num2[i] = 0;\n\n\t\tif (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1;\n\t\telse next[i] = num[i] = 0;\n\t}\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", f[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num2[i], i == n ? '\\n' : ' ');\n\n\tunsigned long long ans = 1;\n\tfor (int i = 1; i <= n; i++) (ans *= (num2[i] + 1)) %= MOD;\n\treturn ans;\n}\n\nint main() {\n\tint t = 1;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\n\t\tprintf(\"%llu\\n\", kmp());\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2014-zoo","published":1,"updated":"2016-07-11T15:41:47.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rp900rkooxl4329aiu2"},{"title":"NOI2014 -  + ","date":"2016-04-03T14:39:31.000Z","_content":"\ndrd drd  $ n $  $ \\rm op $  $ t $ $ \\rm OR $$ \\rm XOR $$ \\rm AND $  $ x $ $ x ~ {\\rm op} ~ t $ drd  $ x $  $ n $ \n atm  $ 0 $  $ m $  $ 0 $$ 1 $$  $$ m $  $ m $  drd \n\n<!-- more -->\n\n### \n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### \n $ 0 $  $ 1 $ $ 1 $ $ 1 $  $ 1 $\n\n `unsigned int`\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-sleep.md","raw":"title: NOI2014 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \npermalink: noi2014-sleep\ndate: 2016-04-03 22:39:31\n---\n\ndrd drd  $ n $  $ \\rm op $  $ t $ $ \\rm OR $$ \\rm XOR $$ \\rm AND $  $ x $ $ x ~ {\\rm op} ~ t $ drd  $ x $  $ n $ \n atm  $ 0 $  $ m $  $ 0 $$ 1 $$  $$ m $  $ m $  drd \n\n<!-- more -->\n\n### \n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### \n $ 0 $  $ 1 $ $ 1 $ $ 1 $  $ 1 $\n\n `unsigned int`\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-sleep","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rpe00rqooxltmjb81r9"},{"title":"NOI2014 - LCT","date":"2016-07-11T15:50:00.000Z","_content":"\n $ N $  $ M $  $ 1 \\ldots N $ $ 1 \\ldots M $ E  $ 1 $ $ N $\n\n $ E_i $  $ A_i $  $ B_i $ A  $ A_i $ B  $ B_i $\n\n E \n\n<!-- more -->\n\n### \n[BZOJ 3669](http://www.lydsy.com/JudgeOnline/problem.php?id=3669)  \n[UOJ #3](http://uoj.ac/problem/3)\n\n### \n $ A_i $  $ B_i $  LCT  $ B_i $  $ 1 $  $ n $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *p, *pp, *max;\n\t\tint w;\n\t\tbool rev;\n\n\t\tNode() : p(NULL), pp(NULL), max(this), w(0) {}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid maintain() {\n\t\t\tmax = this;\n\t\t\tif (c[0] && c[0]->max->w > max->w) max = c[0]->max;\n\t\t\tif (c[1] && c[1]->max->w > max->w) max = c[1]->max;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pp, p->pp);\n\t\t\tint r = relation();\n\t\t\tNode *o = p;\n\t\t\t\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[r] = c[r ^ 1];\n\t\t\tif (c[r ^ 1]) c[r ^ 1]->p = o;\n\n\t\t\tc[r ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (p) {\n\t\t\t\tif (p->p) p->p->pushDown();\n\t\t\t\tp->pushDown(), pushDown();\n\n\t\t\t\tif (!p->p) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->p, c[1]->pp);\n\t\t\t\tc[1] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pp) return false;\n\t\t\tpp->expose();\n\t\t\tpp->c[1] = this;\n\t\t\tpp->maintain();\n\t\t\tstd::swap(p, pp);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\trev ^= 1;\n\t\t}\n\t} N[MAXN], E[MAXM], *a[MAXM][2];\n\n\tvoid link(Node *u, Node *v) {\n\t\t// printf(\"Linking %ld as %ld's parent.\\n\", u - N + 1, v - N + 1);\n\t\tv->evert();\n\t\tu->expose();\n\t\tv->pp = u;\n\t}\n\n\tvoid link(const int u, const int v, const int i, const int w) {\n\t\tE[i].w = w;\n\t\ta[i][0] = &N[u];\n\t\ta[i][1] = &N[v];\n\t\tlink(&N[u], &E[i]);\n\t\tlink(&E[i], &N[v]);\n\t}\n\n\tvoid cut(Node *u, Node *v) {\n\t\tv->evert();\n\t\tv->expose();\n\t\tu->splay();\n\t\tu->pp = NULL;\n\t}\n\n\tvoid cut(const int i) {\n\t\tcut(a[i][0], &E[i]);\n\t\tcut(&E[i], a[i][1]);\n\t}\n\n\tNode *find(const int u) {\n\t\tNode *v = &N[u];\n\t\tv->access();\n\t\tv->splay();\n\t\tif (!v->c[0]) {\n\t\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\t\treturn v;\n\t\t}\n\t\twhile (v->c[0]) v = v->c[0];\n\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\treturn v;\n\t}\n\n\tbool test(const int u, const int v) {\n\t\treturn find(u) == find(v);\n\t}\n\n\tint queryMax(const int u, const int v) {\n\t\tN[u].evert();\n\t\tN[v].access();\n\t\tN[v].splay();\n\t\tassert(N[v].max >= E);\n\t\treturn N[v].max - E;\n\t}\n} lct;\n\nstruct Edge {\n\tint u, v, a, b;\n\n\tbool operator<(const Edge &other) const { return a < other.a; }\n} E[MAXM];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b), E[i].u--, E[i].v--;\n\tstd::sort(E, E + m);\n\n\tint ans = INT_MAX;\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tif (e.u == e.v) continue;\n\t\tif (lct.test(e.u, e.v)) {\n\t\t\t// printf(\"[%d, %d, %d, %d] will lead to a circle!\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tint max = lct.queryMax(e.u, e.v);\n\t\t\t// printf(\"max = %d\\n\", max);\n\t\t\tif (E[max].b > e.b) {\n\t\t\t\tlct.cut(max);\n\t\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t\t}\n\t\t} else {\n\t\t\t// printf(\"Connecting [%d, %d, %d, %d] ...\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t}\n\n\t\tif (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b);\n\t}\n\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-forest.md","raw":"title: NOI2014 - LCT\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - LCT\n  - \npermalink: noi2014-forest\ndate: 2016-07-11 23:50:00\n---\n\n $ N $  $ M $  $ 1 \\ldots N $ $ 1 \\ldots M $ E  $ 1 $ $ N $\n\n $ E_i $  $ A_i $  $ B_i $ A  $ A_i $ B  $ B_i $\n\n E \n\n<!-- more -->\n\n### \n[BZOJ 3669](http://www.lydsy.com/JudgeOnline/problem.php?id=3669)  \n[UOJ #3](http://uoj.ac/problem/3)\n\n### \n $ A_i $  $ B_i $  LCT  $ B_i $  $ 1 $  $ n $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *p, *pp, *max;\n\t\tint w;\n\t\tbool rev;\n\n\t\tNode() : p(NULL), pp(NULL), max(this), w(0) {}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid maintain() {\n\t\t\tmax = this;\n\t\t\tif (c[0] && c[0]->max->w > max->w) max = c[0]->max;\n\t\t\tif (c[1] && c[1]->max->w > max->w) max = c[1]->max;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pp, p->pp);\n\t\t\tint r = relation();\n\t\t\tNode *o = p;\n\t\t\t\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[r] = c[r ^ 1];\n\t\t\tif (c[r ^ 1]) c[r ^ 1]->p = o;\n\n\t\t\tc[r ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (p) {\n\t\t\t\tif (p->p) p->p->pushDown();\n\t\t\t\tp->pushDown(), pushDown();\n\n\t\t\t\tif (!p->p) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->p, c[1]->pp);\n\t\t\t\tc[1] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pp) return false;\n\t\t\tpp->expose();\n\t\t\tpp->c[1] = this;\n\t\t\tpp->maintain();\n\t\t\tstd::swap(p, pp);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\trev ^= 1;\n\t\t}\n\t} N[MAXN], E[MAXM], *a[MAXM][2];\n\n\tvoid link(Node *u, Node *v) {\n\t\t// printf(\"Linking %ld as %ld's parent.\\n\", u - N + 1, v - N + 1);\n\t\tv->evert();\n\t\tu->expose();\n\t\tv->pp = u;\n\t}\n\n\tvoid link(const int u, const int v, const int i, const int w) {\n\t\tE[i].w = w;\n\t\ta[i][0] = &N[u];\n\t\ta[i][1] = &N[v];\n\t\tlink(&N[u], &E[i]);\n\t\tlink(&E[i], &N[v]);\n\t}\n\n\tvoid cut(Node *u, Node *v) {\n\t\tv->evert();\n\t\tv->expose();\n\t\tu->splay();\n\t\tu->pp = NULL;\n\t}\n\n\tvoid cut(const int i) {\n\t\tcut(a[i][0], &E[i]);\n\t\tcut(&E[i], a[i][1]);\n\t}\n\n\tNode *find(const int u) {\n\t\tNode *v = &N[u];\n\t\tv->access();\n\t\tv->splay();\n\t\tif (!v->c[0]) {\n\t\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\t\treturn v;\n\t\t}\n\t\twhile (v->c[0]) v = v->c[0];\n\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\treturn v;\n\t}\n\n\tbool test(const int u, const int v) {\n\t\treturn find(u) == find(v);\n\t}\n\n\tint queryMax(const int u, const int v) {\n\t\tN[u].evert();\n\t\tN[v].access();\n\t\tN[v].splay();\n\t\tassert(N[v].max >= E);\n\t\treturn N[v].max - E;\n\t}\n} lct;\n\nstruct Edge {\n\tint u, v, a, b;\n\n\tbool operator<(const Edge &other) const { return a < other.a; }\n} E[MAXM];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b), E[i].u--, E[i].v--;\n\tstd::sort(E, E + m);\n\n\tint ans = INT_MAX;\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tif (e.u == e.v) continue;\n\t\tif (lct.test(e.u, e.v)) {\n\t\t\t// printf(\"[%d, %d, %d, %d] will lead to a circle!\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tint max = lct.queryMax(e.u, e.v);\n\t\t\t// printf(\"max = %d\\n\", max);\n\t\t\tif (E[max].b > e.b) {\n\t\t\t\tlct.cut(max);\n\t\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t\t}\n\t\t} else {\n\t\t\t// printf(\"Connecting [%d, %d, %d, %d] ...\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t}\n\n\t\tif (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b);\n\t}\n\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-forest","published":1,"updated":"2016-07-11T15:54:43.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rpi00rwooxll1nhr5tg"},{"title":"NOI2012 - ","date":"2016-10-07T23:29:00.000Z","_content":"\n\n\n$$ x_{n + 1} = (a x_n + c) \\bmod m $$\n\n $ m, a, c, x_0, n, g $ $ x_n \\bmod g $\n\n<!-- more -->\n\n### \n[BZOJ 2875](www.lydsy.com/JudgeOnline/problem.php?id=2875)  \n[COGS 963](http://cogs.pro/cogs/problem/problem.php?pid=963)\n\n### \n\n\n $ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst long long MAXN = 1e18;\nconst long long MAXG = 1e8;\n\nlong long mod;\n\nstruct Matrix {\n\tlong long a[2][2];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\n\tlong long &operator()(const int i, const int j) { return a[i][j]; }\n\tconst long long &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"randoma.in\", \"r\", stdin);\n\tfreopen(\"randoma.out\", \"w\", stdout);\n\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld %lld %lld %lld %lld %lld\", &mod, &a, &c, &x, &n, &g);\n\t// mod = 1e9 + 7;\n\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\n\tMatrix shift(false);\n\tshift(0, 0) = a, shift(0, 1) = 1;\n\tshift(1, 0) = 0, shift(1, 1) = 1;\n\n#ifdef FORCE\n\tMatrix res = init;\n\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\tputs(\"----------------------\");\n\tfor (int i = 0; i < n; i++) {\n\t\tres = shift * res;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\t\tputs(\"----------------------\");\n\t}\n#else\n\tMatrix res = pow(shift, n) * init;\n#endif\n\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/noi2012-random.md","raw":"title: NOI2012 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - COGS\n  - \npermalink: noi2012-random\ndate: 2016-10-08 07:29:00\n---\n\n\n\n$$ x_{n + 1} = (a x_n + c) \\bmod m $$\n\n $ m, a, c, x_0, n, g $ $ x_n \\bmod g $\n\n<!-- more -->\n\n### \n[BZOJ 2875](www.lydsy.com/JudgeOnline/problem.php?id=2875)  \n[COGS 963](http://cogs.pro/cogs/problem/problem.php?pid=963)\n\n### \n\n\n $ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst long long MAXN = 1e18;\nconst long long MAXG = 1e8;\n\nlong long mod;\n\nstruct Matrix {\n\tlong long a[2][2];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\n\tlong long &operator()(const int i, const int j) { return a[i][j]; }\n\tconst long long &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"randoma.in\", \"r\", stdin);\n\tfreopen(\"randoma.out\", \"w\", stdout);\n\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld %lld %lld %lld %lld %lld\", &mod, &a, &c, &x, &n, &g);\n\t// mod = 1e9 + 7;\n\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\n\tMatrix shift(false);\n\tshift(0, 0) = a, shift(0, 1) = 1;\n\tshift(1, 0) = 0, shift(1, 1) = 1;\n\n#ifdef FORCE\n\tMatrix res = init;\n\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\tputs(\"----------------------\");\n\tfor (int i = 0; i < n; i++) {\n\t\tres = shift * res;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\t\tputs(\"----------------------\");\n\t}\n#else\n\tMatrix res = pow(shift, n) * init;\n#endif\n\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"noi2012-random","published":1,"updated":"2016-10-07T23:36:47.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rpn00s3ooxllpwfew4u"},{"title":"NOI2011 - AC ","date":"2016-09-11T23:38:00.000Z","_content":"\n $ 28 $  $ 26 $  `B``P` \n\n\n\n* \n*  `B` \n*  `P` \n\n $ 1 $  $ n $ $ (x, y) $ $ 1 \\leq x, y \\leq n $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2434](http://www.lydsy.com/JudgeOnline/problem.php?id=2434)\n\n### \n Trie  Trie \n\n AC  $ y $  $ x $ $ y $  `fail`  $ x $ AC  $ y $  `fail`  $ x $\n\n `fail`  Fail  Fail  AC  `fail` AC  $ y $  Fail  $ x $ \n\n   AC  $ y $ Fail  $ 1 $ $ y $  $ x $ $ x $  Fail \n\n DFS  +  AC  Fail  $ 1 $ $ 0 $ $ y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next, *p;\n\t\tint id;\n\t\tbool isWord;\n\t\tstruct Query {\n\t\t\tNode *x;\n\t\t\tint *ans;\n\n\t\t\tQuery(Node *x, int *ans) : x(x), ans(ans) {}\n\t\t};\n\t\tstd::vector<Query> q;\n\n\t\tNode(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tint init(const char *s, std::vector<Node *> &vec) {\n\t\tint cnt = 0;\n\t\tNode *v = root = new Node(NULL, false, cnt++);\n\t\tfor (const char *p = s; *p; p++) {\n\t\t\tassert(*p == 'P' || *p == 'B' || (*p >= 'a' && *p <= 'z'));\n\t\t\tif (*p == 'P') v->isWord = true, vec.push_back(v);\n\t\t\telse if (*p == 'B') v = v->p;\n\t\t\telse {\n\t\t\t\tif (!v->c[*p - BASE_CHAR]) v->c[*p - BASE_CHAR] = new Node(v, false, cnt++);\n\t\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root, root->next = NULL;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tassert(v->q.size() < MAXN);\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t\tassert(v->q.size() < MAXN);\n\t\t\t\tassert(c->q.size() < MAXN);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tNode *p, *c, *next;\n\tint l, r;\n\tbool v;\n} N[MAXN];\n\nint n;\n\ninline void addEdge(const int p, const int c) {\n\t// printf(\"addEdge(%d, %d)\\n\", p, c);\n\tN[c].next = N[p].c;\n\tN[p].c = &N[c];\n\tN[c].p = &N[p];\n}\n\ninline void buildFailTree() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *&c = v->c[i];\n\t\t\tif (!c) continue;\n\t\t\taddEdge(c->fail->id, c->id);\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void dfs() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->v) {\n\t\t\tv->v = true;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Node *c = v->c; c; c = c->next) s.push(c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint query(const int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) ans += a[i];\n\t\treturn ans;\n\t}\n} bit;\n\nchar op[MAXN + 1];\ninline void solve() {\n\tbit.init(n);\n\tTrie::Node *y = t.root;\n\tfor (const char *p = op; *p; p++) {\n\t\tif (*p == 'P') {\n\t\t\tfor (std::vector<Trie::Node::Query>::iterator it = y->q.begin(); it != y->q.end(); it++) {\n\t\t\t\t*it->ans = bit.query(N[it->x->id].r) - bit.query(N[it->x->id].l - 1);\n\t\t\t}\n\t\t} else if (*p == 'B') {\n\t\t\tbit.update(N[y->id].l, -1);\n\t\t\ty = y->p;\n\t\t} else {\n\t\t\ty = y->c[*p - BASE_CHAR];\n\t\t\tbit.update(N[y->id].l, 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", op);\n\n\tstd::vector<Trie::Node *> vec;\n\tn = t.init(op, vec);\n\tt.build();\n\n\tbuildFailTree();\n\tdfs();\n\n\tint m;\n\tstatic int ans[MAXN];\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\t\tvec[y]->q.push_back(Trie::Node::Query(vec[x], &ans[i]));\n\t}\n\n\tsolve();\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","source":"_posts/noi2011-type.md","raw":"title: NOI2011 - AC \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - AC \npermalink: noi2011-type\ndate: 2016-09-12 07:38:00\n---\n\n $ 28 $  $ 26 $  `B``P` \n\n\n\n* \n*  `B` \n*  `P` \n\n $ 1 $  $ n $ $ (x, y) $ $ 1 \\leq x, y \\leq n $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2434](http://www.lydsy.com/JudgeOnline/problem.php?id=2434)\n\n### \n Trie  Trie \n\n AC  $ y $  $ x $ $ y $  `fail`  $ x $ AC  $ y $  `fail`  $ x $\n\n `fail`  Fail  Fail  AC  `fail` AC  $ y $  Fail  $ x $ \n\n   AC  $ y $ Fail  $ 1 $ $ y $  $ x $ $ x $  Fail \n\n DFS  +  AC  Fail  $ 1 $ $ 0 $ $ y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next, *p;\n\t\tint id;\n\t\tbool isWord;\n\t\tstruct Query {\n\t\t\tNode *x;\n\t\t\tint *ans;\n\n\t\t\tQuery(Node *x, int *ans) : x(x), ans(ans) {}\n\t\t};\n\t\tstd::vector<Query> q;\n\n\t\tNode(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tint init(const char *s, std::vector<Node *> &vec) {\n\t\tint cnt = 0;\n\t\tNode *v = root = new Node(NULL, false, cnt++);\n\t\tfor (const char *p = s; *p; p++) {\n\t\t\tassert(*p == 'P' || *p == 'B' || (*p >= 'a' && *p <= 'z'));\n\t\t\tif (*p == 'P') v->isWord = true, vec.push_back(v);\n\t\t\telse if (*p == 'B') v = v->p;\n\t\t\telse {\n\t\t\t\tif (!v->c[*p - BASE_CHAR]) v->c[*p - BASE_CHAR] = new Node(v, false, cnt++);\n\t\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root, root->next = NULL;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tassert(v->q.size() < MAXN);\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t\tassert(v->q.size() < MAXN);\n\t\t\t\tassert(c->q.size() < MAXN);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tNode *p, *c, *next;\n\tint l, r;\n\tbool v;\n} N[MAXN];\n\nint n;\n\ninline void addEdge(const int p, const int c) {\n\t// printf(\"addEdge(%d, %d)\\n\", p, c);\n\tN[c].next = N[p].c;\n\tN[p].c = &N[c];\n\tN[c].p = &N[p];\n}\n\ninline void buildFailTree() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *&c = v->c[i];\n\t\t\tif (!c) continue;\n\t\t\taddEdge(c->fail->id, c->id);\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void dfs() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->v) {\n\t\t\tv->v = true;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Node *c = v->c; c; c = c->next) s.push(c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint query(const int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) ans += a[i];\n\t\treturn ans;\n\t}\n} bit;\n\nchar op[MAXN + 1];\ninline void solve() {\n\tbit.init(n);\n\tTrie::Node *y = t.root;\n\tfor (const char *p = op; *p; p++) {\n\t\tif (*p == 'P') {\n\t\t\tfor (std::vector<Trie::Node::Query>::iterator it = y->q.begin(); it != y->q.end(); it++) {\n\t\t\t\t*it->ans = bit.query(N[it->x->id].r) - bit.query(N[it->x->id].l - 1);\n\t\t\t}\n\t\t} else if (*p == 'B') {\n\t\t\tbit.update(N[y->id].l, -1);\n\t\t\ty = y->p;\n\t\t} else {\n\t\t\ty = y->c[*p - BASE_CHAR];\n\t\t\tbit.update(N[y->id].l, 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", op);\n\n\tstd::vector<Trie::Node *> vec;\n\tn = t.init(op, vec);\n\tt.build();\n\n\tbuildFailTree();\n\tdfs();\n\n\tint m;\n\tstatic int ans[MAXN];\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\t\tvec[y]->q.push_back(Trie::Node::Query(vec[x], &ans[i]));\n\t}\n\n\tsolve();\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","slug":"noi2011-type","published":1,"updated":"2016-09-11T23:53:53.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rpt00s9ooxl7iak3jm3"},{"title":"NOI2008 -  + ","date":"2016-12-23T10:00:00.000Z","_content":"\n $ \\mathrm{len} $ \n\n1.  $ t $  $ [l, r] $\n2.  $ t $  $ [l, r] $ \n3.  $ t $ \n\n $ 0 $**** $ 0 $ **** $ \\mathrm{len} $ \n\n<!-- more -->\n\n### \n[BZOJ 1062](http://www.lydsy.com/JudgeOnline/problem.php?id=1062)\n\n### \n $ [0, 2\\mathrm{len}] $ $ 2\\mathrm{len} $ $ 0 $  $ 2\\mathrm{len} $ \n\n![ 2len ](noi2008-candy/1.svg?)\n\n $ t $  $ [l, r] $ $ 0 $  $ 2\\mathrm{len} $  $ x $$ x \\in [0, 2\\mathrm{len}) $ $ x \\equiv t - l \\pmod {2\\mathrm{len}} $ $ x \\equiv t + l \\pmod {2\\mathrm{len}} $ $ y = r - l $ $ (x, y) $ \n\n $ t $  $ [l, r] $  $ t = 0 $  $ 0 $  $ [0, \\mathrm{len}] $ \n\n*  $ 0 $  $ 0 $  $ l $\n*  $ -1 $  $ 0 $  $ -1 $  $ 2 \\mathrm{len} - 1 $  $ 0 $  $ 0 $  $ 1 $  $ l - 1 $\n*  $ -2 $  $ l - 2 $\n* \n*  $ -l $  $ 0 $\n* \n*  $ -r $  $ 0 $\n*  $ -r - 1 $  $ 0 $  $ r + 1 $ \n\n\n\n![](noi2008-candy/2.svg)\n\n $ A $  $ 1 $  $ 0 $  $ B $  $ 0 $  $ 0 $ $ A $  $ B $ $ B $ $ B $  $ A $ $ A $  $ B $ \n\n $ A $  $ 1 $  $ 0 $  $ 2\\mathrm{len} - 1 $  $ 2\\mathrm{len} - 1 $  $ 1 $  $ A $  $ l - 1 $ \n\n\n\n*  $ 0 $  $ 2 $  $ l - 2 $\n* \n*  $ l $  $ 0 $\n* \n*  $ r $  $ 0 $\n*  $ r + 1 $  $ 0 $  $ r + 1 $ \n\n\n\n![](noi2008-candy/3.svg)\n\n $ t \\neq 0 $ $ t \\in [0, 2\\mathrm{len}) $ $ 1 $  $ 1 $  $ 0 $   \n\n $ 1 $  $ 2\\mathrm{len} $  $ 2\\mathrm{len} $ \n\n![](noi2008-candy/4.svg)\n\n**** $ t \\neq 0 $  $ [0, 2\\mathrm{len}) $  $ 0 $  $ [0, 2\\mathrm{len}) $  $ [2\\mathrm{len}, 4\\mathrm{len}) $\n\n $ r = \\mathrm{len} $ \n\n![](noi2008-candy/5.svg)\n\n $ +1 $\n\n $ l = r = 0 $ \n\n\n\n   $ y $  $ 1 $  $ -1 $\n\n![](noi2008-candy/6.svg)\n\n $ 2\\mathrm{len} $\n\n![](noi2008-candy/7.svg)\n\n $ 4\\mathrm{len} $  $ 4\\mathrm{len} $\n\n\n\n  \n\n $ O(n \\log ^ 2 \\mathrm{len}) $ $ O(\\mathrm{len} ^ 2) $ $ 32 $ \n\n### \n\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n\t\treturn res;\n\t}\n} bit1, bit2;\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n\ninline void transform(int &x, int &y, int i) {\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n}\n\ninline void add(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\n#ifndef FORCE\nstruct BinaryIndexedTree;\nBinaryIndexedTree *_bit1, *_bit2;\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n#ifdef DBG_BIT\n\t\tprintf(\"init(%d, %d)\\n\", n, m);\n#endif\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n#ifdef DBG_BIT\n\t\tprintf(\"update(%d, %d, %d, %d)\\n\", this == ::_bit1 ? 1 : 2, x, y, delta);\n#endif\n\t\tassert(x >= 0);\n\t\tassert(y >= 0);\n#ifdef FORCE_BIT\n\t\ta[x][y] += delta;\n#else\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n#ifdef FORCE_BIT\n\t\tfor (int i = x; i >= 0; i--) {\n\t\t\tfor (int j = y; j >= 0; j--) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n#endif\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n#ifdef FORCE_BIT\n\t\tint res = 0;\n\t\tfor (int i = x1; i <= x2; i++) {\n\t\t\tfor (int j = y1; j <= y2; j++) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n#endif\n#ifdef DBG_BIT\n\t\tprintf(\"query(%d, %d, %d, %d, %d) = %d\\n\", this == ::_bit1 ? 1 : 2, x1, y1, x2, y2, res);\n#endif\n\t\treturn res;\n\t}\n} bit1, bit2;\n#endif\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n#ifdef FORCE\nint a[MAXLEN * 4 + 5][MAXLEN * 2 + 5];\n#endif\n\ninline void transform(int &x, int &y, int i) {\n#ifdef DBG\n\tprintf(\"transform(%d, %d, %d) = \", x, y, i);\n#endif\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n#ifdef DBG\n\tprintf(\"(%d, %d)\\n\", x, y);\n#endif\n}\n\ninline void add(int x, int y) {\n\t// printf(\"add(%d, %d)\\n\", x, y);\n#ifdef FORCE\n\ta[x][y]++;\n\t// a[x + len * 2][y]++;\n#else\n#ifdef DBG\n\tprintf(\"add(%d, %d)\\n\", x, y);\n#endif\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\t/*\n\tbit1.update(x, y + x, 1);\n\tbit2.update(x, y + (len * 2 - x), 1);\n\n\tbit1.update(x + len * 2, y + x, 1);\n\tbit2.update(x + len * 2, y + (len * 2 - x), 1);\n\t*/\n#endif\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n#ifdef FORCE\n\ta[x][y]--;\n\t// a[x + len * 2][y]--;\n#else\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n#endif\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n#ifdef FORCE\n\t// printf(\"query(%d, %d, %d)\\n\", t, l, r);\n\tstatic bool added[MAXLEN * 2 + 5][MAXLEN + 5];\n\tmemset(added, 0, sizeof(added));\n\tint ans = 0;\n\tfor (int i = 0, start = l; i <= r; i++, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = len * 2, start = l; i >= len * 2 - r; i--, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n#else\n#ifdef DBG\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r, //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r);  //\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r,   //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r);//\n#endif\n\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n#endif\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n#ifndef FORCE_BIT\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\t_bit1 = &bit1, _bit2 = &bit2;\n#endif\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2008-candy.md","raw":"title: NOI2008 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - NOI\n  - \n  - \n  - \npermalink: noi2008-candy\ndate: 2016-12-23 18:00:00\n---\n\n $ \\mathrm{len} $ \n\n1.  $ t $  $ [l, r] $\n2.  $ t $  $ [l, r] $ \n3.  $ t $ \n\n $ 0 $**** $ 0 $ **** $ \\mathrm{len} $ \n\n<!-- more -->\n\n### \n[BZOJ 1062](http://www.lydsy.com/JudgeOnline/problem.php?id=1062)\n\n### \n $ [0, 2\\mathrm{len}] $ $ 2\\mathrm{len} $ $ 0 $  $ 2\\mathrm{len} $ \n\n![ 2len ](noi2008-candy/1.svg?)\n\n $ t $  $ [l, r] $ $ 0 $  $ 2\\mathrm{len} $  $ x $$ x \\in [0, 2\\mathrm{len}) $ $ x \\equiv t - l \\pmod {2\\mathrm{len}} $ $ x \\equiv t + l \\pmod {2\\mathrm{len}} $ $ y = r - l $ $ (x, y) $ \n\n $ t $  $ [l, r] $  $ t = 0 $  $ 0 $  $ [0, \\mathrm{len}] $ \n\n*  $ 0 $  $ 0 $  $ l $\n*  $ -1 $  $ 0 $  $ -1 $  $ 2 \\mathrm{len} - 1 $  $ 0 $  $ 0 $  $ 1 $  $ l - 1 $\n*  $ -2 $  $ l - 2 $\n* \n*  $ -l $  $ 0 $\n* \n*  $ -r $  $ 0 $\n*  $ -r - 1 $  $ 0 $  $ r + 1 $ \n\n\n\n![](noi2008-candy/2.svg)\n\n $ A $  $ 1 $  $ 0 $  $ B $  $ 0 $  $ 0 $ $ A $  $ B $ $ B $ $ B $  $ A $ $ A $  $ B $ \n\n $ A $  $ 1 $  $ 0 $  $ 2\\mathrm{len} - 1 $  $ 2\\mathrm{len} - 1 $  $ 1 $  $ A $  $ l - 1 $ \n\n\n\n*  $ 0 $  $ 2 $  $ l - 2 $\n* \n*  $ l $  $ 0 $\n* \n*  $ r $  $ 0 $\n*  $ r + 1 $  $ 0 $  $ r + 1 $ \n\n\n\n![](noi2008-candy/3.svg)\n\n $ t \\neq 0 $ $ t \\in [0, 2\\mathrm{len}) $ $ 1 $  $ 1 $  $ 0 $   \n\n $ 1 $  $ 2\\mathrm{len} $  $ 2\\mathrm{len} $ \n\n![](noi2008-candy/4.svg)\n\n**** $ t \\neq 0 $  $ [0, 2\\mathrm{len}) $  $ 0 $  $ [0, 2\\mathrm{len}) $  $ [2\\mathrm{len}, 4\\mathrm{len}) $\n\n $ r = \\mathrm{len} $ \n\n![](noi2008-candy/5.svg)\n\n $ +1 $\n\n $ l = r = 0 $ \n\n\n\n   $ y $  $ 1 $  $ -1 $\n\n![](noi2008-candy/6.svg)\n\n $ 2\\mathrm{len} $\n\n![](noi2008-candy/7.svg)\n\n $ 4\\mathrm{len} $  $ 4\\mathrm{len} $\n\n\n\n  \n\n $ O(n \\log ^ 2 \\mathrm{len}) $ $ O(\\mathrm{len} ^ 2) $ $ 32 $ \n\n### \n\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n\t\treturn res;\n\t}\n} bit1, bit2;\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n\ninline void transform(int &x, int &y, int i) {\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n}\n\ninline void add(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\n#ifndef FORCE\nstruct BinaryIndexedTree;\nBinaryIndexedTree *_bit1, *_bit2;\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n#ifdef DBG_BIT\n\t\tprintf(\"init(%d, %d)\\n\", n, m);\n#endif\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n#ifdef DBG_BIT\n\t\tprintf(\"update(%d, %d, %d, %d)\\n\", this == ::_bit1 ? 1 : 2, x, y, delta);\n#endif\n\t\tassert(x >= 0);\n\t\tassert(y >= 0);\n#ifdef FORCE_BIT\n\t\ta[x][y] += delta;\n#else\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n#ifdef FORCE_BIT\n\t\tfor (int i = x; i >= 0; i--) {\n\t\t\tfor (int j = y; j >= 0; j--) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n#endif\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n#ifdef FORCE_BIT\n\t\tint res = 0;\n\t\tfor (int i = x1; i <= x2; i++) {\n\t\t\tfor (int j = y1; j <= y2; j++) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n#endif\n#ifdef DBG_BIT\n\t\tprintf(\"query(%d, %d, %d, %d, %d) = %d\\n\", this == ::_bit1 ? 1 : 2, x1, y1, x2, y2, res);\n#endif\n\t\treturn res;\n\t}\n} bit1, bit2;\n#endif\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n#ifdef FORCE\nint a[MAXLEN * 4 + 5][MAXLEN * 2 + 5];\n#endif\n\ninline void transform(int &x, int &y, int i) {\n#ifdef DBG\n\tprintf(\"transform(%d, %d, %d) = \", x, y, i);\n#endif\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n#ifdef DBG\n\tprintf(\"(%d, %d)\\n\", x, y);\n#endif\n}\n\ninline void add(int x, int y) {\n\t// printf(\"add(%d, %d)\\n\", x, y);\n#ifdef FORCE\n\ta[x][y]++;\n\t// a[x + len * 2][y]++;\n#else\n#ifdef DBG\n\tprintf(\"add(%d, %d)\\n\", x, y);\n#endif\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\t/*\n\tbit1.update(x, y + x, 1);\n\tbit2.update(x, y + (len * 2 - x), 1);\n\n\tbit1.update(x + len * 2, y + x, 1);\n\tbit2.update(x + len * 2, y + (len * 2 - x), 1);\n\t*/\n#endif\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n#ifdef FORCE\n\ta[x][y]--;\n\t// a[x + len * 2][y]--;\n#else\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n#endif\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n#ifdef FORCE\n\t// printf(\"query(%d, %d, %d)\\n\", t, l, r);\n\tstatic bool added[MAXLEN * 2 + 5][MAXLEN + 5];\n\tmemset(added, 0, sizeof(added));\n\tint ans = 0;\n\tfor (int i = 0, start = l; i <= r; i++, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = len * 2, start = l; i >= len * 2 - r; i--, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n#else\n#ifdef DBG\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r, //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r);  //\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r,   //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r);//\n#endif\n\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n#endif\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n#ifndef FORCE_BIT\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\t_bit1 = &bit1, _bit2 = &bit2;\n#endif\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2008-candy","published":1,"updated":"2016-12-23T10:00:56.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rq200sfooxly4o781l4"},{"title":"NOI2006 - ","date":"2016-03-10T11:33:42.000Z","_content":"\n $ N $  $ i $  $ Pi $$ 1  i  N $ $ M $  $ i $  $ Ai $, $ Bi $  $ Ci $ $ Ai $  $ Bi $  $ Ci $$ 1  i  M $$ 1  Ai $$ Bi  N $\n\n<!-- more -->\n\n### \n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2006-profit.md","raw":"title: NOI2006 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  - \n  - Dinic\npermalink: noi2006-profit\ndate: 2016-03-10 19:33:42\n---\n\n $ N $  $ i $  $ Pi $$ 1  i  N $ $ M $  $ i $  $ Ai $, $ Bi $  $ Ci $ $ Ai $  $ Bi $  $ Ci $$ 1  i  M $$ 1  Ai $$ Bi  N $\n\n<!-- more -->\n\n### \n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"noi2006-profit","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rqx00soooxllb590yw9"},{"title":"NOI2004 - Splay","id":"37","updated":"2016-01-24T15:11:06.000Z","date":"2016-01-24T15:09:03.000Z","_content":"\n `k` \n\n<!-- more -->\n\n### \n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### \n Splay \n\n $[-{\\infty}+1,min-1]$ \n\n\n\n Splay\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","source":"_posts/noi2004-cashier.md","raw":"title: NOI2004 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - Splay\n  - \n  - \npermalink: noi2004-cashier\nid: 37\nupdated: '2016-01-24 23:11:06'\ndate: 2016-01-24 23:09:03\n---\n\n `k` \n\n<!-- more -->\n\n### \n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### \n Splay \n\n $[-{\\infty}+1,min-1]$ \n\n\n\n Splay\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","slug":"noi2004-cashier","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rr500szooxl5spvxvdd"},{"title":"NOI2003 - Splay","date":"2016-03-06T11:49:35.000Z","_content":"\n|                |  |  |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         |  $ k $  $ k=0 $ |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     |  $ n $  $ s $$ n  1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       |  $ n $ $ n  1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          |  $ n $ $ n  1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | \n| $ {\\rm NEXT}() $       | `Next`           | \n\n<!-- more -->\n\n### \n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### \n Splay w\n\n `build`  $ \\log $\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2003-editor.md","raw":"title: NOI2003 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - Splay\n  - \n  - \npermalink: noi2003-editor\ndate: 2016-03-06 19:49:35\n---\n\n|                |  |  |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         |  $ k $  $ k=0 $ |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     |  $ n $  $ s $$ n  1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       |  $ n $ $ n  1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          |  $ n $ $ n  1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | \n| $ {\\rm NEXT}() $       | `Next`           | \n\n<!-- more -->\n\n### \n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### \n Splay w\n\n `build`  $ \\log $\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2003-editor","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rrk00t7ooxlvthp0h3z"},{"title":"NOI2002 - ","id":"2","updated":"2016-01-19T13:08:24.000Z","date":"2015-11-22T17:14:53.000Z","_content":"\n 30000 \n\n1. `x`  `y`   \n2. `x`  `y`  `x`  `y` \n\n 500,000 \n\n<!-- more -->\n\n### \n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### \n  \n****\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)`  `head`  `find_head(x)`  `x`  `x` \n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n $O(nm)$  \n  Boom  \n\n `x`  `head[x]`  `prefix[x]`  \n `find(x)`  `pre(x)`  `prefix[x]`  `pre(head[x])`** `x` **  \n\n  \n 1.** `prefix[x]` **  \n 2.** `head[x] == x` **0  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn prefix[x];\n}\n```\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### \n NOI2002   \n    \n A ","source":"_posts/noi2002-galaxy.md","raw":"title: NOI2002 - \ncategories: OI\ntags: \n  - CodeVS\n  - NOI\n  - \npermalink: noi2002-galaxy\nid: 2\nupdated: '2016-01-19 21:08:24'\ndate: 2015-11-23 01:14:53\n---\n\n 30000 \n\n1. `x`  `y`   \n2. `x`  `y`  `x`  `y` \n\n 500,000 \n\n<!-- more -->\n\n### \n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### \n  \n****\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)`  `head`  `find_head(x)`  `x`  `x` \n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n $O(nm)$  \n  Boom  \n\n `x`  `head[x]`  `prefix[x]`  \n `find(x)`  `pre(x)`  `prefix[x]`  `pre(head[x])`** `x` **  \n\n  \n 1.** `prefix[x]` **  \n 2.** `head[x] == x` **0  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn prefix[x];\n}\n```\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### \n NOI2002   \n    \n A ","slug":"noi2002-galaxy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rrp00teooxlvdm3u5f0"},{"title":"","date":"2016-06-17T08:36:00.000Z","_content":"\n\n\n<!-- more -->\n\n****\n\n![](node-devide-notes/tree1.svg)\n\n $ 1 $  $ 1 $ \n\n $ n $ $ n $  $ 1 $ \n\n $ O(n) $  $ O(n ^ 2) $\n\n $ 5 $    $ 5 $  $ 1 $ \n\n### \n********\n\n> \n\n  \n $ n \\over 2 $ $ n + 2 $ \n\n DFS    DFS $ {\\rm size}(i) = \\sum\\limits_{j \\in {\\rm child}(i)} {\\rm size}(j) + 1 $ $ {\\rm max}(i) = \\max\\limits_{j \\in {\\rm child}(i)} \\{ {\\rm size}(j) \\} $ $ \\max \\{ \\max(i),\\ n - \\max(i) \\} $  $ i $ \n\n\n\n$$ T(n) = 2 T(\\frac{n}{2}) + O(n) = O(n \\log n) $$\n\n\n\n![](node-devide-notes/tree2.svg)\n\n### \n `solved` $ n $ \n\n```c++\ninline Node *center(Node *start) {\n    std::stack<Node *> s;\n    s.push(start);\n    start->parent = NULL;\n    start->visited = false;\n\n    static Node *a[MAXN];\n    int cnt = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            a[cnt++] = v;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n                e->t->parent = v;\n                e->t->visited = false;\n                s.push(e->t);\n            }\n        } else {\n            v->size = 1;\n            v->max = 0;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n                v->size += e->t->size;\n                v->max = std::max(v->max, e->t->size);\n            }\n            s.pop();\n        }\n    }\n\n\n    Node *res = NULL;\n    for (int i = 0; i < cnt; i++) {\n        a[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n\n    return res;\n}\n\ninline int solve() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    int ans = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        s.pop();\n\n        Node *root = center(v);\n        root->solved = true;\n\n        ans += calc(root);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n            s.push(e->t);\n        }\n    }\n\n    return ans;\n}\n```\n","source":"_posts/node-devide-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: node-devide-notes\ndate: 2016-06-17 16:36:00\n---\n\n\n\n<!-- more -->\n\n****\n\n![](node-devide-notes/tree1.svg)\n\n $ 1 $  $ 1 $ \n\n $ n $ $ n $  $ 1 $ \n\n $ O(n) $  $ O(n ^ 2) $\n\n $ 5 $    $ 5 $  $ 1 $ \n\n### \n********\n\n> \n\n  \n $ n \\over 2 $ $ n + 2 $ \n\n DFS    DFS $ {\\rm size}(i) = \\sum\\limits_{j \\in {\\rm child}(i)} {\\rm size}(j) + 1 $ $ {\\rm max}(i) = \\max\\limits_{j \\in {\\rm child}(i)} \\{ {\\rm size}(j) \\} $ $ \\max \\{ \\max(i),\\ n - \\max(i) \\} $  $ i $ \n\n\n\n$$ T(n) = 2 T(\\frac{n}{2}) + O(n) = O(n \\log n) $$\n\n\n\n![](node-devide-notes/tree2.svg)\n\n### \n `solved` $ n $ \n\n```c++\ninline Node *center(Node *start) {\n    std::stack<Node *> s;\n    s.push(start);\n    start->parent = NULL;\n    start->visited = false;\n\n    static Node *a[MAXN];\n    int cnt = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            a[cnt++] = v;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n                e->t->parent = v;\n                e->t->visited = false;\n                s.push(e->t);\n            }\n        } else {\n            v->size = 1;\n            v->max = 0;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n                v->size += e->t->size;\n                v->max = std::max(v->max, e->t->size);\n            }\n            s.pop();\n        }\n    }\n\n\n    Node *res = NULL;\n    for (int i = 0; i < cnt; i++) {\n        a[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n\n    return res;\n}\n\ninline int solve() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    int ans = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        s.pop();\n\n        Node *root = center(v);\n        root->solved = true;\n\n        ans += calc(root);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n            s.push(e->t);\n        }\n    }\n\n    return ans;\n}\n```\n","slug":"node-devide-notes","published":1,"updated":"2016-06-17T08:37:21.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rrt00tjooxl26si2srg"},{"title":"","date":"2016-04-13T04:11:17.000Z","_content":"\n OI \n\n\n\n<!-- more -->\n\n### \n $ {\\rm mod} \\ p $  $ x $  $ x ^ {-1} $  \n\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### \n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ p $ \n\n\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n$ a ^ {p - 2} $  $ a $ \n\n $ a ^ {p - 2} $ $ O(\\log a) $\n\n#### \n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### \nEXGCD $ O(\\log \\max(a, b)) $  $ x $$ y $ \n\n\n$$ ax + by = \\gcd(a, b) $$\n\n\n\n $ b $ $ \\gcd(a, b) = 1 $\n\n$$ ax \\equiv 1 \\pmod b $$\n\n $ O(\\log a) $\n\n#### \n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### \n $ p = k \\times i + r $$ r < i $$ 1 < i < p $\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n $ r ^ {-1} + i ^ {-1} $\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n $ 1 ^ {-1} \\equiv 1 \\pmod p $ $ O(n) $\n\n#### \n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","source":"_posts/mul-inverse.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: mul-inverse\ndate: 2016-04-13 12:11:17\n---\n\n OI \n\n\n\n<!-- more -->\n\n### \n $ {\\rm mod} \\ p $  $ x $  $ x ^ {-1} $  \n\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### \n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ p $ \n\n\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n$ a ^ {p - 2} $  $ a $ \n\n $ a ^ {p - 2} $ $ O(\\log a) $\n\n#### \n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### \nEXGCD $ O(\\log \\max(a, b)) $  $ x $$ y $ \n\n\n$$ ax + by = \\gcd(a, b) $$\n\n\n\n $ b $ $ \\gcd(a, b) = 1 $\n\n$$ ax \\equiv 1 \\pmod b $$\n\n $ O(\\log a) $\n\n#### \n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### \n $ p = k \\times i + r $$ r < i $$ 1 < i < p $\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n $ r ^ {-1} + i ^ {-1} $\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n $ 1 ^ {-1} \\equiv 1 \\pmod p $ $ O(n) $\n\n#### \n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","slug":"mul-inverse","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rs100tqooxl5k76m1y3"},{"title":"","date":"2016-01-14T21:44:45.000Z","_content":"\n DP \n\n<!-- more -->\n\n### \n\n\n `priority_queue`  $O(1)$  $O({\\log}n)$  `set` $\\log$  TLE \n\n $O(1)$ \n\n### \n `Q` `M` `M`  `Q` \n\n `Q`  `x`  `M`  `M`  ** `x` ** `x`  `x` ** `x` **\n\n `Q`  `M`  `M` **** `M`  `Q`  `M`  `M`  `Q` \n\n### \n $f[x]=\\max\\{g(k)\\}+w[x]$ \n\n### \n `deque`  `queue`\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","source":"_posts/monotone-queue-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  -   \npermalink: monotone-queue-notes\ndate: 2016-01-15 05:44:45\n---\n\n DP \n\n<!-- more -->\n\n### \n\n\n `priority_queue`  $O(1)$  $O({\\log}n)$  `set` $\\log$  TLE \n\n $O(1)$ \n\n### \n `Q` `M` `M`  `Q` \n\n `Q`  `x`  `M`  `M`  ** `x` ** `x`  `x` ** `x` **\n\n `Q`  `M`  `M` **** `M`  `Q`  `M`  `M`  `Q` \n\n### \n $f[x]=\\max\\{g(k)\\}+w[x]$ \n\n### \n `deque`  `queue`\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","slug":"monotone-queue-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rs700txooxlxitu2z26"},{"title":"","date":"2016-05-01T00:14:50.000Z","_content":"\n $ [1,\\ n] $ $ [l,\\ r] $ \n\n<!-- more -->\n\n $ [l,\\ r] $  $ [l,\\ r + 1] $$ [l,\\ r - 1] $$ [l - 1,\\ r] $$ [l + 1,\\ r] $  $ O(1) $ $ O(n) $  $ O(n ^ 2) $\n\n $ \\sqrt n $  $ \\sqrt n $********\n\n $ O(\\sqrt n) $  $ O(\\sqrt n) $  $ O((\\sqrt n) ^ 2) = O(n) $ $ O(\\sqrt n) $ $ O((\\sqrt n) ^ 2) = O(n) $  $ O(n) $  $ O(\\sqrt n) $ $ O(n \\sqrt n) $\n\n\n","source":"_posts/mo-algorithm-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \npermalink: mo-algorithm-notes\ndate: 2016-05-01 08:14:50\n---\n\n $ [1,\\ n] $ $ [l,\\ r] $ \n\n<!-- more -->\n\n $ [l,\\ r] $  $ [l,\\ r + 1] $$ [l,\\ r - 1] $$ [l - 1,\\ r] $$ [l + 1,\\ r] $  $ O(1) $ $ O(n) $  $ O(n ^ 2) $\n\n $ \\sqrt n $  $ \\sqrt n $********\n\n $ O(\\sqrt n) $  $ O(\\sqrt n) $  $ O((\\sqrt n) ^ 2) = O(n) $ $ O(\\sqrt n) $ $ O((\\sqrt n) ^ 2) = O(n) $  $ O(n) $  $ O(\\sqrt n) $ $ O(n \\sqrt n) $\n\n\n","slug":"mo-algorithm-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rsc00u4ooxlj8ab512z"},{"title":" && ","date":"2016-01-01T22:08:50.000Z","_content":"\n\n\n ~\n\n<!-- more -->\n\n### \n\n#### Kruskal \n****\n\n\n\n $O(m{\\log}m)$ `m` \n\n\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim \nPrim  Kruskal ****\n\n Prim  Dijkstra \n\n\n\n $O(m{\\log}n)$ `n` `m`   \n $O(n^2)$ `n` \n\n\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### \n********\n\n****\n\n#### \n\n\n**** `(u, v, w)` `u`  `v` ****\n\n\n\n#### POJ 1679\n[POJ 1679](http://poj.org/problem?id=1679)\n\n\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/minimum-spanning-tree-notes.md","raw":"title: ' && '\ncategories: OI\ntags: \n  - Kruskal\n  - POJ\n  - Prim\n  - \n  - \n  - \n  - \n  - \n  -   \npermalink: minimum-spanning-tree-notes\ndate: 2016-01-02 06:08:50\n---\n\n\n\n ~\n\n<!-- more -->\n\n### \n\n#### Kruskal \n****\n\n\n\n $O(m{\\log}m)$ `m` \n\n\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim \nPrim  Kruskal ****\n\n Prim  Dijkstra \n\n\n\n $O(m{\\log}n)$ `n` `m`   \n $O(n^2)$ `n` \n\n\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### \n********\n\n****\n\n#### \n\n\n**** `(u, v, w)` `u`  `v` ****\n\n\n\n#### POJ 1679\n[POJ 1679](http://poj.org/problem?id=1679)\n\n\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"minimum-spanning-tree-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rsg00uaooxljndn1qui"},{"title":"Manacher ","date":"2017-01-02T12:14:00.000Z","_content":"\nManacher  $ O(n) $ ****\n\n<!-- more -->\n\n `@`  `\\0` `$`\n\n $ \\max $  $ p $$ p $ $ \\max $ \n\n $ r(i) $  $ i $  $ i $  $ i $ \n\n $ j $  $ i $  $ p $  $ j = 2p - i $\n\n![](manacher-notes/1.svg)\n\n$ \\max < i $ $ i $ $ r(i) \\geq 1 $\n\n![](manacher-notes/2.svg)\n\n$ \\max \\geq i $  $ \\max - i \\geq r(j) $ $ i $ $ j $  $ i $  $ r(i) = r(j) $ $ r(i) \\geq r(j) $\n\n![](manacher-notes/3.svg)\n\n$ \\max \\geq i $  $ \\max - i \\geq r(j) $ $ i $ $ j $  $ r(i) $  $ r(i) \\geq \\max - i $\n\n### [POJ 3974](http://poj.org/problem?id=3974)\n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\n// s1 s2 \nchar s1[MAXN + 2], s2[MAXN * 2 + 3];\nint n, len, r[MAXN * 2 + 3];\n\ninline void prepare()\n{\n\tn = strlen(s1);\n\n\ts2[++len] = '@'; // \n\ts2[++len] = '$';\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ts2[++len] = s1[i];\n\t\ts2[++len] = '$';\n\t}\n\n\ts2[len + 1] = '\\0'; //  0 \n}\n\ninline void manacher()\n{\n\t//  '@' '\\0' '$'\n\tint right = 0, mid = 0; // right mid  right \n\tfor (int i = 1; i <= len; i++)\n\t{\n\t\tint x;\n\t\tif (right < i) x = 1;\n\t\telse x = std::min(r[mid * 2 - i], right - i);\n\n\t\t// \n\t\twhile (s2[i + x] == s2[i - x]) ++x;\n\n\t\t// \n\t\tif (i + x > right)\n\t\t{\n\t\t\tright = i + x;\n\t\t\tmid = i;\n\t\t}\n\n\t\tr[i] = x;\n\t}\n}\n\nint main() {\n\tint T = 0;\n\twhile (scanf(\"%s\", s1), memcmp(s1, \"END\", 4) != 0)\n\t{\n\t\tprepare();\n\t\tmanacher();\n\n\t\t// printf(\"%s\\n\", s2 + 1);\n\t\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", r[i], i == len ? '\\n' : ' ');\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= len; i++) ans = std::max(ans, r[i] - 1);\n\t\tprintf(\"Case %d: %d\\n\", ++T, ans);\n\n\t\tlen = 0;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/manacher-notes.md","raw":"title: Manacher \ncategories: OI\ntags: \n  - \n  - \n  - Manacher\n  - \npermalink: manacher-notes\ndate: 2017-01-02 20:14:00\n---\n\nManacher  $ O(n) $ ****\n\n<!-- more -->\n\n `@`  `\\0` `$`\n\n $ \\max $  $ p $$ p $ $ \\max $ \n\n $ r(i) $  $ i $  $ i $  $ i $ \n\n $ j $  $ i $  $ p $  $ j = 2p - i $\n\n![](manacher-notes/1.svg)\n\n$ \\max < i $ $ i $ $ r(i) \\geq 1 $\n\n![](manacher-notes/2.svg)\n\n$ \\max \\geq i $  $ \\max - i \\geq r(j) $ $ i $ $ j $  $ i $  $ r(i) = r(j) $ $ r(i) \\geq r(j) $\n\n![](manacher-notes/3.svg)\n\n$ \\max \\geq i $  $ \\max - i \\geq r(j) $ $ i $ $ j $  $ r(i) $  $ r(i) \\geq \\max - i $\n\n### [POJ 3974](http://poj.org/problem?id=3974)\n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\n// s1 s2 \nchar s1[MAXN + 2], s2[MAXN * 2 + 3];\nint n, len, r[MAXN * 2 + 3];\n\ninline void prepare()\n{\n\tn = strlen(s1);\n\n\ts2[++len] = '@'; // \n\ts2[++len] = '$';\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ts2[++len] = s1[i];\n\t\ts2[++len] = '$';\n\t}\n\n\ts2[len + 1] = '\\0'; //  0 \n}\n\ninline void manacher()\n{\n\t//  '@' '\\0' '$'\n\tint right = 0, mid = 0; // right mid  right \n\tfor (int i = 1; i <= len; i++)\n\t{\n\t\tint x;\n\t\tif (right < i) x = 1;\n\t\telse x = std::min(r[mid * 2 - i], right - i);\n\n\t\t// \n\t\twhile (s2[i + x] == s2[i - x]) ++x;\n\n\t\t// \n\t\tif (i + x > right)\n\t\t{\n\t\t\tright = i + x;\n\t\t\tmid = i;\n\t\t}\n\n\t\tr[i] = x;\n\t}\n}\n\nint main() {\n\tint T = 0;\n\twhile (scanf(\"%s\", s1), memcmp(s1, \"END\", 4) != 0)\n\t{\n\t\tprepare();\n\t\tmanacher();\n\n\t\t// printf(\"%s\\n\", s2 + 1);\n\t\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", r[i], i == len ? '\\n' : ' ');\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= len; i++) ans = std::max(ans, r[i] - 1);\n\t\tprintf(\"Case %d: %d\\n\", ++T, ans);\n\n\t\tlen = 0;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"manacher-notes","published":1,"updated":"2017-01-02T12:15:15.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rso00unooxlniigyuwv"},{"title":"Link-Cut Tree ","date":"2016-01-19T12:50:40.000Z","_content":"\nLink-Cut Tree  Splay Link-Cut Tree  $O({\\log}n)$\n\n<!-- more -->\n\n### \n Link-Cut Tree ********\n\n Splay \n\n Splay Splay  `Path Parent` Splay **** Splay  `Path Parent`  Splay  `Path Parent` \n\n`value` `sum`  `max` `reversed`  Splay \n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### \nLink-Cut Tree \n\n1. `Access(u)` `u`\n2. `Evert(u)` `u` \n3. `Link(u, v)` `u`  `v`  `u`  `v` \n4. `Cut(u, v)` `u`  `v`  `v` \n5. `FindRoot(u)` `u` \n6. `MakeTree()`\n\n### `Access` \n#### `Expose` \n `Access`  `Expose` \n\n1.  `Splay`  Splay \n2. \n\n\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` \n `Splice` ********\n\n1.  `Splay`  Splay \n2.  `Path Parent` `Splice` \n3.  `Path Parent`  `Expose` \n4.  `Path Parent`  `Path Parent` \n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` \n `Expose`  `Splice``Access` `Expose`  `Splice` \n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` \n `Access`\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` \n `v`  `Path Parent`  `u` \n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` \n`Cut` \n\n1.  `u`  `v`  `u` \n2.  `v`  `Access`  `v`  `u` \n3.  `v`  `Splay`  `v` ** Splay **\n4.  `v` \n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query`  `Update` \n `QueryMax(u, v)`  `Node`  `max`  `Maintain()` \n\n `Access(u)` `Splay`  Splay  `u`  `max`  `u` \n\n `Evert` \n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n `Splay`  Splay \n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` \n\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n###  & \n1.  `Splay`  `Rotate` \n2. `Rotate`  `Path Parent`  `Path Parent`  `Path Parent`  Splay \n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/link-cut-tree-notes.md","raw":"title: Link-Cut Tree \ncategories: OI\ntags: \n  - Link-Cut Tree\n  - \n  - Splay\n  - \n  - \n  -   \npermalink: link-cut-tree-notes\ndate: 2016-01-19 20:50:40\n---\n\nLink-Cut Tree  Splay Link-Cut Tree  $O({\\log}n)$\n\n<!-- more -->\n\n### \n Link-Cut Tree ********\n\n Splay \n\n Splay Splay  `Path Parent` Splay **** Splay  `Path Parent`  Splay  `Path Parent` \n\n`value` `sum`  `max` `reversed`  Splay \n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### \nLink-Cut Tree \n\n1. `Access(u)` `u`\n2. `Evert(u)` `u` \n3. `Link(u, v)` `u`  `v`  `u`  `v` \n4. `Cut(u, v)` `u`  `v`  `v` \n5. `FindRoot(u)` `u` \n6. `MakeTree()`\n\n### `Access` \n#### `Expose` \n `Access`  `Expose` \n\n1.  `Splay`  Splay \n2. \n\n\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` \n `Splice` ********\n\n1.  `Splay`  Splay \n2.  `Path Parent` `Splice` \n3.  `Path Parent`  `Expose` \n4.  `Path Parent`  `Path Parent` \n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` \n `Expose`  `Splice``Access` `Expose`  `Splice` \n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` \n `Access`\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` \n `v`  `Path Parent`  `u` \n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` \n`Cut` \n\n1.  `u`  `v`  `u` \n2.  `v`  `Access`  `v`  `u` \n3.  `v`  `Splay`  `v` ** Splay **\n4.  `v` \n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query`  `Update` \n `QueryMax(u, v)`  `Node`  `max`  `Maintain()` \n\n `Access(u)` `Splay`  Splay  `u`  `max`  `u` \n\n `Evert` \n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n `Splay`  Splay \n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` \n\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n###  & \n1.  `Splay`  `Rotate` \n2. `Rotate`  `Path Parent`  `Path Parent`  `Path Parent`  Splay \n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"link-cut-tree-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rsx00uuooxlshkbqrni"},{"title":"KMP ","date":"2015-12-29T20:19:36.000Z","_content":"\nKMPKnuth-Morris-Pratt\n\n<!-- more -->\n\n### \n `pattern`  `\"utqqutnu\"` `target`  `\"utqlwutqqutnu`\"`\"-\"` `\"|\"` \n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `'l'` \n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n \n\n `\"ut\"` \n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n `'t'`  `'l'` \n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP ****\n\n### \n************************\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `\"utqqut\"` `\"ut\"` `\"ut\"`  `\"ut\"` \n\n `\"ttitty\"` `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n `\"ttitt\"` `\"tt\"`  `\"t\"` `\"t\"` \n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n `'t'` \n\n `\"tt\"` \n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n\n\n****\n\n### \nKMP ********\n\n `fail`  `i`  `i` ****\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nfail  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n `fail[i]` \n\n1.  `fail[i - 1]`  0 `i`  `fail[i - 1] +`  `fail[i]`  `fail[i - 1] + 1`\n2.  `fail[i - 1]`  0 `i`  `fail[i] = 1` `fail[i] = 0`\n3.  `fail[i - 1]`  0 `i`  `fail[i - 1] +` **** `i`  `fail[fail[i - 1]] + 1`  0\n\n*agct*agc**a**gct*agct*\n\n `'a'`  `'t'`  `\"agctagc\"`  `'c'` **** `'t'` `\"agct\"` \n\n### \n `fail` \n\n1. \n2. ****\n3. ****************\n\n### POJ 3461\n 2016  12  26 \n\n![zyz ](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\n\ninline int kmp(char *a, char *b) //  a  b\n{\n\t// \n\tint na = strlen(a + 1), nb = strlen(b + 1);\n\tstatic int fail[MAXN + 1];\n\n\tfail[1] = 0;\n\tfor (int i = 2; i <= nb; i++)\n\t{\n\t\t//  fail \n\t\tint j = fail[i - 1];\n\t\t//  fail  0 \n\t\twhile (j != 0 && b[j + 1] != b[i]) j = fail[j];\n\n\t\t//  fail \n\t\tif (b[j + 1] == b[i]) fail[i] = j + 1;\n\t\telse fail[i] = 0; // \n\t}\n\n\tint res = 0; // \n\tfor (int i = 1, j = 0; i <= na; i++)\n\t{\n\t\t//  fail \n\t\twhile (j != 0 && b[j + 1] != a[i]) j = fail[j];\n\n\t\t// \n\t\tif (b[j + 1] == a[i]) j++;\n\n\t\t// \n\t\tif (j == nb)\n\t\t{\n\t\t\tres++;\n\t\t\tj = fail[j]; // \n\t\t\t// j = 0 // \n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tstatic char a[MAXN + 2], b[MAXN + 2];\n\t\t//  1 \n\t\tscanf(\"%s %s\", a + 1, b + 1);\n\t\tprintf(\"%d\\n\", kmp(b, a));\n\t}\n\treturn 0;\n}\n```\n\n<!--\n### CodeVS 1204\n C++  `0` \n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint fail[MAXN] = { 0 };\n\n\tfail[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = fail[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = fail[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tfail[i] = k + 1;\n\t\t} else {\n\t\t\tfail[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << fail[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = fail[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n-->\n","source":"_posts/kmp-notes.md","raw":"title: KMP \ncategories: OI\ntags: \n  - CodeVS\n  - KMP\n  - \n  - \n  -   \npermalink: kmp-notes\ndate: 2015-12-30 04:19:36\n---\n\nKMPKnuth-Morris-Pratt\n\n<!-- more -->\n\n### \n `pattern`  `\"utqqutnu\"` `target`  `\"utqlwutqqutnu`\"`\"-\"` `\"|\"` \n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `'l'` \n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n \n\n `\"ut\"` \n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n `'t'`  `'l'` \n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP ****\n\n### \n************************\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `\"utqqut\"` `\"ut\"` `\"ut\"`  `\"ut\"` \n\n `\"ttitty\"` `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n `\"ttitt\"` `\"tt\"`  `\"t\"` `\"t\"` \n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n `'t'` \n\n `\"tt\"` \n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n\n\n****\n\n### \nKMP ********\n\n `fail`  `i`  `i` ****\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nfail  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n `fail[i]` \n\n1.  `fail[i - 1]`  0 `i`  `fail[i - 1] +`  `fail[i]`  `fail[i - 1] + 1`\n2.  `fail[i - 1]`  0 `i`  `fail[i] = 1` `fail[i] = 0`\n3.  `fail[i - 1]`  0 `i`  `fail[i - 1] +` **** `i`  `fail[fail[i - 1]] + 1`  0\n\n*agct*agc**a**gct*agct*\n\n `'a'`  `'t'`  `\"agctagc\"`  `'c'` **** `'t'` `\"agct\"` \n\n### \n `fail` \n\n1. \n2. ****\n3. ****************\n\n### POJ 3461\n 2016  12  26 \n\n![zyz ](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\n\ninline int kmp(char *a, char *b) //  a  b\n{\n\t// \n\tint na = strlen(a + 1), nb = strlen(b + 1);\n\tstatic int fail[MAXN + 1];\n\n\tfail[1] = 0;\n\tfor (int i = 2; i <= nb; i++)\n\t{\n\t\t//  fail \n\t\tint j = fail[i - 1];\n\t\t//  fail  0 \n\t\twhile (j != 0 && b[j + 1] != b[i]) j = fail[j];\n\n\t\t//  fail \n\t\tif (b[j + 1] == b[i]) fail[i] = j + 1;\n\t\telse fail[i] = 0; // \n\t}\n\n\tint res = 0; // \n\tfor (int i = 1, j = 0; i <= na; i++)\n\t{\n\t\t//  fail \n\t\twhile (j != 0 && b[j + 1] != a[i]) j = fail[j];\n\n\t\t// \n\t\tif (b[j + 1] == a[i]) j++;\n\n\t\t// \n\t\tif (j == nb)\n\t\t{\n\t\t\tres++;\n\t\t\tj = fail[j]; // \n\t\t\t// j = 0 // \n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tstatic char a[MAXN + 2], b[MAXN + 2];\n\t\t//  1 \n\t\tscanf(\"%s %s\", a + 1, b + 1);\n\t\tprintf(\"%d\\n\", kmp(b, a));\n\t}\n\treturn 0;\n}\n```\n\n<!--\n### CodeVS 1204\n C++  `0` \n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint fail[MAXN] = { 0 };\n\n\tfail[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = fail[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = fail[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tfail[i] = k + 1;\n\t\t} else {\n\t\t\tfail[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << fail[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = fail[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n-->\n","slug":"kmp-notes","published":1,"updated":"2017-01-01T01:44:17.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rt500v2ooxlyhxrer1o"},{"title":"JSOI2016 -  + RMQ","date":"2016-04-20T14:56:35.000Z","_content":"\nJSOI  $ N $  $ i $  $ h_i $ $ N $ \n\n $ i $  $ p \\ (p \\geq 0) $ JYY  $ j $ \n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI JYY  JYY \n\n<!-- more -->\n\n### \n\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ O(\\sqrt{n}) $ $ j $ \n\n $ j $  $ p_i $  $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  $ j $  $ p_j $ \n\n i $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  RMQ \n\n $ O(n \\log n + n \\sqrt n) $ 3s \n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-light.md","raw":"title: JSOI2016 -  + RMQ\ncategories: OI\ntags: \n  - JSOI\n  - \n  - \n  - RMQ\npermalink: jsoi2016-light\ndate: 2016-04-20 22:56:35\n---\n\nJSOI  $ N $  $ i $  $ h_i $ $ N $ \n\n $ i $  $ p \\ (p \\geq 0) $ JYY  $ j $ \n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI JYY  JYY \n\n<!-- more -->\n\n### \n\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ O(\\sqrt{n}) $ $ j $ \n\n $ j $  $ p_i $  $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  $ j $  $ p_j $ \n\n i $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  RMQ \n\n $ O(n \\log n + n \\sqrt n) $ 3s \n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-light","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rta00v9ooxl9eodp9pp"},{"title":"JSOI2016 -  + ","date":"2016-04-23T16:41:33.000Z","_content":"\nJSOI  $ N $  $ 1 $  $ N $ $ i $  $ j $  $ T_{i, j} $ $ T_{i, j} $  $ T_{j, i} $ \n\n $ k $  $ P_k $ \n\nJS Airways  $ M $  $ i $  $ D_i $  $ X_i $  $ Y_i $ \n\n JS Airway  $ 0 $  JS Airways \n\nJYY  JS Airways  $ M $ \n\n<!-- more -->\n\n### \n $ i $  $ k $  $ j $  $ i $$ j $  $ T[i][k] + P[k] + T[k][j] $ Floyd \n\n $ A $  $ B $ $ A $  $ B $\n\n1. $ A $  $ B $  $ A $  $ B $ \n2. $ A $  $ A $  $ B $  $ B $ \n\n$ A \\Rightarrow B $  $ A $  $ B $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-flight.md","raw":"title: JSOI2016 -  + \ncategories: OI\ntags: \n  - JSOI\n  - \n  - Dinic\n  - \n  - Floyd\npermalink: jsoi2016-flight\ndate: 2016-04-24 00:41:33\n---\n\nJSOI  $ N $  $ 1 $  $ N $ $ i $  $ j $  $ T_{i, j} $ $ T_{i, j} $  $ T_{j, i} $ \n\n $ k $  $ P_k $ \n\nJS Airways  $ M $  $ i $  $ D_i $  $ X_i $  $ Y_i $ \n\n JS Airway  $ 0 $  JS Airways \n\nJYY  JS Airways  $ M $ \n\n<!-- more -->\n\n### \n $ i $  $ k $  $ j $  $ i $$ j $  $ T[i][k] + P[k] + T[k][j] $ Floyd \n\n $ A $  $ B $ $ A $  $ B $\n\n1. $ A $  $ B $  $ A $  $ B $ \n2. $ A $  $ A $  $ B $  $ B $ \n\n$ A \\Rightarrow B $  $ A $  $ B $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-flight","published":1,"updated":"2016-05-11T09:33:58.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rtf00vgooxlnbkd5can"},{"title":"JSOI2009 - AC  + ","date":"2016-09-18T09:29:00.000Z","_content":"\n $ n $  $ m $  $ i $  $ {p_i \\over q_i} (0 \\leq p_i \\leq q_i) $$ T $  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1444](http://www.lydsy.com/JudgeOnline/problem.php?id=1444)\n\n### \n AC  AC  AC \n\n $ p(i) = \\frac{p_i}{q_i} $ $ u $  $ v $  $ \\{ c_i \\} $ $ u $  $ v $  $ P(u, v) = \\sum p(c_i) $\n\n AC **** $ i $  $ x_i $\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= 0 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= 0 \\\\\n\\end{aligned}\n$$\n\n $ 1 $ \n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) + 1 \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= -1 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= -1 \\\\\n\\end{aligned}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst int BASE_CHAR = 'A';\nconst double EPS = 0.005;\n\nint charsetSize, n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < charsetSize; i++) c[i] = NULL;\n\t\t\tthis->id = n++;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\t// c = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\ndouble p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1];\n\ninline void buildMatrix() {\n\tfor (int i = 1; i < n; i++) matrix[i][i] = -1;\n\tmatrix[0][0] = -1, matrix[0][n] = -1;\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) continue;\n\n\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t// printf(\"%d -> %d\\n\", v->id, v->c[i]->id);\n\t\t\tmatrix[v->c[i]->id][v->id] += p[i];\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void gauss() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (fabs(matrix[i][i]) < EPS) {\n\t\t\tfor (int j = i + 1; j < n; j++) if (matrix[j][i] >= EPS) {\n\t\t\t\tstd::swap(matrix[i], matrix[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for (int j = i + 1; j < n; j++) if (max == -1 || fabs(matrix[j][i]) > fabs(matrix[max][i])) max = j;\n\t\t// if (max != i) std::swap(matrix[max], matrix[i]);\n\n\t\tdouble t = matrix[i][i];\n\t\tfor (int j = 0; j < n + 1; j++) matrix[i][j] /= t;\n\n\t\tfor (int j = 0; j < n; j++) if (j != i) {\n\t\t\tdouble t = matrix[j][i];\n\t\t\tfor (int k = i; k < n + 1; k++) matrix[j][k] -= t * matrix[i][k];\n\t\t}\n\t}\n}\n\nbool gauss_jordan() {\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = 0; j < n; ++j) if (fabs(matrix[j][i]) > fabs(matrix[idx][i])) idx = j;\n        // if (fabs(matrix[idx][i]) <= eps) return false;\n        if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j <= n; ++j) std::swap(matrix[i][j], matrix[idx][j]);\n        for (int j = 0; j < n; ++j) if (i != j) {\n            double tmp = matrix[j][i] / matrix[i][i];\n            for (int k = n; k >= i; --k) matrix[j][k] -= matrix[i][k] * tmp;\n        }\n    }\n    return true;\n}\n\nint main() {\n\tint m, l;\n\tscanf(\"%d %d %d\", &m, &l, &charsetSize);\n\tfor (int i = 0; i < charsetSize; i++) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf %lf\", &a, &b);\n\t\tp[i] = a / b;\n\t}\n\n\tstatic Trie::Node *a[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tchar s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\ts[i] -= BASE_CHAR;\n\t\t\tif (p[s[i]] == 0) cnt++;\n\t\t}\n\t\ta[i] = t.insert(s, s + l);\n\t}\n\n\t/*\n\tif (cnt == m) {\n\t\tfor (int i = 0; i < m; i++) puts(\"0.00\");\n\t\treturn 0;\n\t}\n\t*/\n\n\tt.build();\n\n\tbuildMatrix();\n\t// for (int i = 0; i <= n; i++) matrix[0][i] = -matrix[0][i];\n\tgauss();\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) printf(\"%.2lf%c\", matrix[i][j], j == n ? '\\n' : ' ');\n\t}\n\t*/\n\n\tfor (int i = 0; i < m; i++) printf(\"%.2lf\\n\", matrix[a[i]->id][n] < EPS ? 0.0f : matrix[a[i]->id][n]);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2009-game2.md","raw":"title: JSOI2009 - AC  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - AC \n  - \n  - \n  - \npermalink: jsoi2009-game2\ndate: 2016-09-18 17:29:00\n---\n\n $ n $  $ m $  $ i $  $ {p_i \\over q_i} (0 \\leq p_i \\leq q_i) $$ T $  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1444](http://www.lydsy.com/JudgeOnline/problem.php?id=1444)\n\n### \n AC  AC  AC \n\n $ p(i) = \\frac{p_i}{q_i} $ $ u $  $ v $  $ \\{ c_i \\} $ $ u $  $ v $  $ P(u, v) = \\sum p(c_i) $\n\n AC **** $ i $  $ x_i $\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= 0 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= 0 \\\\\n\\end{aligned}\n$$\n\n $ 1 $ \n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) + 1 \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= -1 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= -1 \\\\\n\\end{aligned}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst int BASE_CHAR = 'A';\nconst double EPS = 0.005;\n\nint charsetSize, n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < charsetSize; i++) c[i] = NULL;\n\t\t\tthis->id = n++;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\t// c = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\ndouble p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1];\n\ninline void buildMatrix() {\n\tfor (int i = 1; i < n; i++) matrix[i][i] = -1;\n\tmatrix[0][0] = -1, matrix[0][n] = -1;\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) continue;\n\n\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t// printf(\"%d -> %d\\n\", v->id, v->c[i]->id);\n\t\t\tmatrix[v->c[i]->id][v->id] += p[i];\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void gauss() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (fabs(matrix[i][i]) < EPS) {\n\t\t\tfor (int j = i + 1; j < n; j++) if (matrix[j][i] >= EPS) {\n\t\t\t\tstd::swap(matrix[i], matrix[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for (int j = i + 1; j < n; j++) if (max == -1 || fabs(matrix[j][i]) > fabs(matrix[max][i])) max = j;\n\t\t// if (max != i) std::swap(matrix[max], matrix[i]);\n\n\t\tdouble t = matrix[i][i];\n\t\tfor (int j = 0; j < n + 1; j++) matrix[i][j] /= t;\n\n\t\tfor (int j = 0; j < n; j++) if (j != i) {\n\t\t\tdouble t = matrix[j][i];\n\t\t\tfor (int k = i; k < n + 1; k++) matrix[j][k] -= t * matrix[i][k];\n\t\t}\n\t}\n}\n\nbool gauss_jordan() {\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = 0; j < n; ++j) if (fabs(matrix[j][i]) > fabs(matrix[idx][i])) idx = j;\n        // if (fabs(matrix[idx][i]) <= eps) return false;\n        if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j <= n; ++j) std::swap(matrix[i][j], matrix[idx][j]);\n        for (int j = 0; j < n; ++j) if (i != j) {\n            double tmp = matrix[j][i] / matrix[i][i];\n            for (int k = n; k >= i; --k) matrix[j][k] -= matrix[i][k] * tmp;\n        }\n    }\n    return true;\n}\n\nint main() {\n\tint m, l;\n\tscanf(\"%d %d %d\", &m, &l, &charsetSize);\n\tfor (int i = 0; i < charsetSize; i++) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf %lf\", &a, &b);\n\t\tp[i] = a / b;\n\t}\n\n\tstatic Trie::Node *a[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tchar s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\ts[i] -= BASE_CHAR;\n\t\t\tif (p[s[i]] == 0) cnt++;\n\t\t}\n\t\ta[i] = t.insert(s, s + l);\n\t}\n\n\t/*\n\tif (cnt == m) {\n\t\tfor (int i = 0; i < m; i++) puts(\"0.00\");\n\t\treturn 0;\n\t}\n\t*/\n\n\tt.build();\n\n\tbuildMatrix();\n\t// for (int i = 0; i <= n; i++) matrix[0][i] = -matrix[0][i];\n\tgauss();\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) printf(\"%.2lf%c\", matrix[i][j], j == n ? '\\n' : ' ');\n\t}\n\t*/\n\n\tfor (int i = 0; i < m; i++) printf(\"%.2lf\\n\", matrix[a[i]->id][n] < EPS ? 0.0f : matrix[a[i]->id][n]);\n\n\treturn 0;\n}\n```","slug":"jsoi2009-game2","published":1,"updated":"2016-09-18T09:30:31.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rtk00vnooxl69lpu6t0"},{"title":"JSOI2009 -  + ","date":"2016-04-28T14:10:42.000Z","_content":"\n $ N \\times M $ AA YY  AA \n\n\n\n AA \n\n<!-- more -->\n\n### \n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### \n AA  AA  AA \n\n\n\n YY  YY ******** AA  YY \n\n\n\n -  -  -   \n\n****\n\n Dinic  BFS********\n\n************ -  -  -   \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","source":"_posts/jsoi2009-game.md","raw":"title: JSOI2009 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \n  - \n  - Dinic\npermalink: jsoi2009-game\ndate: 2016-04-28 22:10:42\n---\n\n $ N \\times M $ AA YY  AA \n\n\n\n AA \n\n<!-- more -->\n\n### \n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### \n AA  AA  AA \n\n\n\n YY  YY ******** AA  YY \n\n\n\n -  -  -   \n\n****\n\n Dinic  BFS********\n\n************ -  -  -   \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","slug":"jsoi2009-game","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rtq00vxooxl8iv12hvc"},{"title":"JSOI2008 -  + ","date":"2016-10-18T13:14:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXM = 200000;\nconst int MAXN = 2 * MAXM;\n\nstruct UnionFindSet {\n\tint a[MAXN], rk[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i, rk[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n\n\tvoid merge(const int x, const int y) {\n\t\tconst int p = find(x), q = find(y);\n\t\tif (p == q) return;\n\t\tif (rk[p] > rk[q]) a[q] = p;\n\t\telse if (rk[q] > rk[p]) a[p] = q;\n\t\telse a[p] = q, rk[q]++;\n\t}\n} ufs;\n\nstruct Edge {\n\tbool added;\n\tint u, v;\n} E[MAXM];\n\nstruct Node {\n\tstd::vector<Edge *> e;\n\tbool added;\n\tbool willDelete;\n} N[MAXN];\n\ninline void addAllEdge(Node *v, int &ans) {\n\tans++;\n\tfor (std::vector<Edge *>::const_iterator it = v->e.begin(); it != v->e.end(); it++) {\n\t\tEdge *const &e = *it;\n\t\tif (!e->added && N[e->u].added && N[e->v].added && !ufs.test(e->u, e->v)) {\n\t\t\tufs.merge(e->u, e->v);\n\t\t\t// printf(\"merge(%d, %d)\\n\", e->u, e->v);\n\t\t\tans--;\n\t\t\te->added = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k, ans;\n\tstatic int a[MAXN];\n\tscanf(\"%d %d\", &n, &m), ans = 0;\n\n\tufs.init(n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v), N[E[i].u].e.push_back(&E[i]), N[E[i].v].e.push_back(&E[i]);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = k - 1; i >= 0; i--) scanf(\"%d\", &a[i]), N[a[i]].willDelete = true;\n\n\tfor (int i = 0; i < n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&N[i], ans);\n\n\tstd::vector<int> anses;\n\tanses.push_back(ans);\n\t\n\tfor (int i = 0; i < k; i++) {\n\t\t// printf(\"before %d\\n\", a[i]);\n\t\tNode *v = &N[a[i]];\n\t\tv->added = true;\n\t\taddAllEdge(v, ans);\n\t\tanses.push_back(ans);\n\t}\n\n\tfor (std::vector<int>::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-starwar.md","raw":"title: JSOI2008 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2008-starwar\ndate: 2016-10-18 21:14:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXM = 200000;\nconst int MAXN = 2 * MAXM;\n\nstruct UnionFindSet {\n\tint a[MAXN], rk[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i, rk[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n\n\tvoid merge(const int x, const int y) {\n\t\tconst int p = find(x), q = find(y);\n\t\tif (p == q) return;\n\t\tif (rk[p] > rk[q]) a[q] = p;\n\t\telse if (rk[q] > rk[p]) a[p] = q;\n\t\telse a[p] = q, rk[q]++;\n\t}\n} ufs;\n\nstruct Edge {\n\tbool added;\n\tint u, v;\n} E[MAXM];\n\nstruct Node {\n\tstd::vector<Edge *> e;\n\tbool added;\n\tbool willDelete;\n} N[MAXN];\n\ninline void addAllEdge(Node *v, int &ans) {\n\tans++;\n\tfor (std::vector<Edge *>::const_iterator it = v->e.begin(); it != v->e.end(); it++) {\n\t\tEdge *const &e = *it;\n\t\tif (!e->added && N[e->u].added && N[e->v].added && !ufs.test(e->u, e->v)) {\n\t\t\tufs.merge(e->u, e->v);\n\t\t\t// printf(\"merge(%d, %d)\\n\", e->u, e->v);\n\t\t\tans--;\n\t\t\te->added = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k, ans;\n\tstatic int a[MAXN];\n\tscanf(\"%d %d\", &n, &m), ans = 0;\n\n\tufs.init(n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v), N[E[i].u].e.push_back(&E[i]), N[E[i].v].e.push_back(&E[i]);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = k - 1; i >= 0; i--) scanf(\"%d\", &a[i]), N[a[i]].willDelete = true;\n\n\tfor (int i = 0; i < n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&N[i], ans);\n\n\tstd::vector<int> anses;\n\tanses.push_back(ans);\n\t\n\tfor (int i = 0; i < k; i++) {\n\t\t// printf(\"before %d\\n\", a[i]);\n\t\tNode *v = &N[a[i]];\n\t\tv->added = true;\n\t\taddAllEdge(v, ans);\n\t\tanses.push_back(ans);\n\t}\n\n\tfor (std::vector<int>::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","slug":"jsoi2008-starwar","published":1,"updated":"2016-10-18T13:20:00.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rtw00w6ooxlkgx27f4e"},{"title":"JSOI2008 - Splay + Hash","date":"2016-10-18T12:16:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1014](http://www.lydsy.com/JudgeOnline/problem.php?id=1014)\n\n### \n Splay  Hash Hash  Hash  Hash \n\n LCP \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid rotate() {\n\t\t\tNode *o = p;\n\t\t\tint x = relation();\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (relation() == p->relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = 1;\n\t\t\tif (c[0]) size += c[0]->size;\n\t\t\tif (c[1]) size += c[1]->size;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() { return c[0] ? c[0]->size : 0; }\n\n\t\tvoid print(const int depth = 0) {\n\t\t\tif (c[1]) c[1]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\tprintf(\"%c\\n\", val == 0 ? ' ' : val);\n\t\t\tif (c[0]) c[0]->print(depth + 1);\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {}\n\n\tNode *build(const char *first, const char *last, Node *p) {\n\t\tif (first > last) return NULL;\n\t\tif (first == last) return new Node(p, &r, *first);\n\t\telse {\n\t\t\tconst char *mid = first + (last - first) / 2;\n\t\t\tNode *v = new Node(p, &r, *mid);\n\t\t\tv->c[0] = build(first, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, last, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBounds(const int x) {\n\t\tNode *v = r;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &r, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->p;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *first, const char *last) {\n\t\tr = build(first, last, NULL);\n\t\tbuildBounds(0);\n\t\tbuildBounds(1);\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x < v->lsize() + 1) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(const int l, const int r) {\n\t\tNode *a = select(l - 1), *b = select(r + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\treturn b->c[0];\n\t}\n\n\tNode *insert(const int pos, const char ch) {\n\t\tNode *a = select(pos), *b = select(pos + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\tb->c[0] = new Node(b, &r, ch);\n\t\tNode *v = b->c[0];\n\t\tdo {\n\t\t\tv->maintain();\n\t\t\tv = v->p;\n\t\t} while (v);\n\t\treturn b->c[0]->splay();\n\t}\n\n\tvoid update(const int pos, const char ch) {\n\t\tNode *v = select(pos);\n\t\tv->val = ch;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(const int l, const int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() { return r->size - 2; }\n} splay;\n\ninline void print() {\n\tsplay.r->print();\n\tputs(\"------------------------\");\n}\n\ninline int lcp(const int a, const int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE;\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.update(pos, ch[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.insert(pos, ch[0]);\n\t\t}\n\n\t\t// print();\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-prefix.md","raw":"title: JSOI2008 - Splay + Hash\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - Hash\n  - \npermalink: jsoi2008-prefix\ndate: 2016-10-18 20:16:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1014](http://www.lydsy.com/JudgeOnline/problem.php?id=1014)\n\n### \n Splay  Hash Hash  Hash  Hash \n\n LCP \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid rotate() {\n\t\t\tNode *o = p;\n\t\t\tint x = relation();\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (relation() == p->relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = 1;\n\t\t\tif (c[0]) size += c[0]->size;\n\t\t\tif (c[1]) size += c[1]->size;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() { return c[0] ? c[0]->size : 0; }\n\n\t\tvoid print(const int depth = 0) {\n\t\t\tif (c[1]) c[1]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\tprintf(\"%c\\n\", val == 0 ? ' ' : val);\n\t\t\tif (c[0]) c[0]->print(depth + 1);\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {}\n\n\tNode *build(const char *first, const char *last, Node *p) {\n\t\tif (first > last) return NULL;\n\t\tif (first == last) return new Node(p, &r, *first);\n\t\telse {\n\t\t\tconst char *mid = first + (last - first) / 2;\n\t\t\tNode *v = new Node(p, &r, *mid);\n\t\t\tv->c[0] = build(first, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, last, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBounds(const int x) {\n\t\tNode *v = r;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &r, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->p;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *first, const char *last) {\n\t\tr = build(first, last, NULL);\n\t\tbuildBounds(0);\n\t\tbuildBounds(1);\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x < v->lsize() + 1) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(const int l, const int r) {\n\t\tNode *a = select(l - 1), *b = select(r + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\treturn b->c[0];\n\t}\n\n\tNode *insert(const int pos, const char ch) {\n\t\tNode *a = select(pos), *b = select(pos + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\tb->c[0] = new Node(b, &r, ch);\n\t\tNode *v = b->c[0];\n\t\tdo {\n\t\t\tv->maintain();\n\t\t\tv = v->p;\n\t\t} while (v);\n\t\treturn b->c[0]->splay();\n\t}\n\n\tvoid update(const int pos, const char ch) {\n\t\tNode *v = select(pos);\n\t\tv->val = ch;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(const int l, const int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() { return r->size - 2; }\n} splay;\n\ninline void print() {\n\tsplay.r->print();\n\tputs(\"------------------------\");\n}\n\ninline int lcp(const int a, const int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE;\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.update(pos, ch[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.insert(pos, ch[0]);\n\t\t}\n\n\t\t// print();\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-prefix","published":1,"updated":"2016-10-18T13:10:35.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ru100wcooxlcqqts8cq"},{"title":"JSOI2008 - Splay","id":"56","updated":"2016-02-20T02:13:55.000Z","date":"2016-02-20T02:11:00.000Z","_content":"\n\n\n1.   \n   `Q L`  \n    `L`   \n   `L` \n2. \n   `A n`  \n    `n`  `t` `t`  `t = 0`) `D`   \n   `n` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### \nSplay  \n\n\n\n Splay qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-maxnumber.md","raw":"title: JSOI2008 - Splay\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - \n  - \npermalink: jsoi2008-maxnumber\nid: 56\nupdated: '2016-02-20 10:13:55'\ndate: 2016-02-20 10:11:00\n---\n\n\n\n1.   \n   `Q L`  \n    `L`   \n   `L` \n2. \n   `A n`  \n    `n`  `t` `t`  `t = 0`) `D`   \n   `n` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### \nSplay  \n\n\n\n Splay qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-maxnumber","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ru700wjooxldpiytopo"},{"title":"JSOI2008 -  DP","date":"2016-07-11T15:10:00.000Z","_content":"\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1017](http://www.lydsy.com/JudgeOnline/problem.php?id=1017)\n\n### \n$ f(i, j) $  $ i $  $ j $ \n\n $ g(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 51;\nconst int MAXM = 2000;\nconst int MAXK = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, val, ind;\n\tbool basic; // , visited;\n\tint f[MAXK + 1][MAXM + 1];\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\t// printf(\"E(%d, %d, %d)\\n\", s, t, w);\n\tN[t].ind++;\n\tN[s].e = new Edge(&N[s], &N[t], w);\n}\n\nint n, m, ans;\n\ninline void bfs() {\n\tint pos = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].ind) continue;\n\t\t// printf(\"%d\\n\", i);\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\t// N[i].visited = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tfor (Edge *e = (seq[--pos] = q.front())->e; e; e = e->next) q.push(e->t); // , e->t->visited = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n}\n\ninline void dp1() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tif (!v->basic) {\n\t\t\tv->cnt = INT_MAX;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->cnt = std::min(v->cnt, e->t->cnt / e->w);\n\t\t\t\tv->cost += e->t->cost * e->w;\n\t\t\t}\n\t\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\t}\n\t}\n}\n\ninline void dp2() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tint (&f)[MAXK + 1][MAXM + 1] = v->f;\n\t\tstatic int g[MAXN + 1][MAXM + 1];\n\n\t\tif (v->basic) {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\tfor (int j = v->cost * i; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::max(f[i][j], std::min(v->cnt - i, (j - v->cost * i) / v->cost) * v->val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\t// memset(g, 0, sizeof(g));\n\t\t\t\tfor (int i = 0; i <= MAXN; i++) for (int j = 0; j <= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN;\n\t\t\t\t// if (!v->e) {\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\t\tf[j][k] = std::max(f[j][k], v->val * (i - j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t// } else {\n\t\t\t\t\t// for (int j = v->cost * i; j <= m; j++) g[j] = v->val * i;\n\n\t\t\t\tint id = 0;\n\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\tid++;\n\t\t\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\t\t\tfor (int k = i * e->w * e->t->cost; k <= j; k++) {\n\t\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->t->f[e->w * i][k]);\n\t\t\t\t\t\t\t// if (j - k * e->t->cost >= v->cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e->t->cost]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// printf(\"g[%d][%d] = %d\\n\", i, j, g[i][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\tf[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v->val);\n\t\t\t\t\t\tans = std::max(ans, f[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &N[i].val);\n\t\tchar s[2];\n\t\tscanf(\"%s\", s);\n\n\t\tif (s[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\twhile (t--) {\n\t\t\t\tint u, w;\n\t\t\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\t\t\taddEdge(i, u, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs();\n\tdp1();\n\tdp2();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2008-dotr.md","raw":"title: JSOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - DP\n  -  DP\npermalink: jsoi2008-dotr\ndate: 2016-07-11 23:10:00\n---\n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1017](http://www.lydsy.com/JudgeOnline/problem.php?id=1017)\n\n### \n$ f(i, j) $  $ i $  $ j $ \n\n $ g(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 51;\nconst int MAXM = 2000;\nconst int MAXK = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, val, ind;\n\tbool basic; // , visited;\n\tint f[MAXK + 1][MAXM + 1];\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\t// printf(\"E(%d, %d, %d)\\n\", s, t, w);\n\tN[t].ind++;\n\tN[s].e = new Edge(&N[s], &N[t], w);\n}\n\nint n, m, ans;\n\ninline void bfs() {\n\tint pos = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].ind) continue;\n\t\t// printf(\"%d\\n\", i);\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\t// N[i].visited = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tfor (Edge *e = (seq[--pos] = q.front())->e; e; e = e->next) q.push(e->t); // , e->t->visited = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n}\n\ninline void dp1() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tif (!v->basic) {\n\t\t\tv->cnt = INT_MAX;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->cnt = std::min(v->cnt, e->t->cnt / e->w);\n\t\t\t\tv->cost += e->t->cost * e->w;\n\t\t\t}\n\t\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\t}\n\t}\n}\n\ninline void dp2() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tint (&f)[MAXK + 1][MAXM + 1] = v->f;\n\t\tstatic int g[MAXN + 1][MAXM + 1];\n\n\t\tif (v->basic) {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\tfor (int j = v->cost * i; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::max(f[i][j], std::min(v->cnt - i, (j - v->cost * i) / v->cost) * v->val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\t// memset(g, 0, sizeof(g));\n\t\t\t\tfor (int i = 0; i <= MAXN; i++) for (int j = 0; j <= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN;\n\t\t\t\t// if (!v->e) {\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\t\tf[j][k] = std::max(f[j][k], v->val * (i - j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t// } else {\n\t\t\t\t\t// for (int j = v->cost * i; j <= m; j++) g[j] = v->val * i;\n\n\t\t\t\tint id = 0;\n\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\tid++;\n\t\t\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\t\t\tfor (int k = i * e->w * e->t->cost; k <= j; k++) {\n\t\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->t->f[e->w * i][k]);\n\t\t\t\t\t\t\t// if (j - k * e->t->cost >= v->cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e->t->cost]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// printf(\"g[%d][%d] = %d\\n\", i, j, g[i][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\tf[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v->val);\n\t\t\t\t\t\tans = std::max(ans, f[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &N[i].val);\n\t\tchar s[2];\n\t\tscanf(\"%s\", s);\n\n\t\tif (s[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\twhile (t--) {\n\t\t\t\tint u, w;\n\t\t\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\t\t\taddEdge(i, u, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs();\n\tdp1();\n\tdp2();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2008-dotr","published":1,"updated":"2016-10-24T23:37:01.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ruc00wqooxlpzw8wzrg"},{"title":"JSOI2008 - ","date":"2016-10-18T13:34:00.000Z","_content":"\n $ \\leq 10 $\n\n<!-- more -->\n\n### \n[BZOJ 1016](http://www.lydsy.com/JudgeOnline/problem.php?id=1016)\n\n### \n> \n\nhttps://blog.sengxian.com/solutions/bzoj-1016\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nconst int MAXN = 100;\nconst int MAXM = 1000;\nconst int MAXC = 1000000000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool used;\n\n\tbool operator<(const Edge &other) const { return w < other.w; }\n} E[MAXM];\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tvoid merge(const int x, const int y) {\n\t\ta[find(x)] = find(y);\n\t}\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n} ufs;\n\nstruct EdgeGroup {\n\tint used;\n\tstd::vector<Edge> edges;\n};\n\nint n, m, graph[MAXN][MAXN];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.test(E[i].u, E[i].v)) {\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tE[i].used = true;\n\t\t\tgroups[E[i].w].used++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].edges.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w), E[i].u--, E[i].v--;\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.used == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.edges.size()); s++) {\n\t\t\t\tint popcount = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.edges.size(); i++) if (s & (1 << i)) popcount++;\n\t\t\t\tif (popcount != it->second.used) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tif (!(s & (1 << (e - it->second.edges.begin())))) continue;\n\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tif (graph[i][j]) {\n\t\t\t\t\t\t\tif (ufs.test(i, j)) {\n\t\t\t\t\t\t\t\tgoto nextLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\nnextLoop:;\n\t\t\t}\n\t\t\t// printf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = e->used;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-award.md","raw":"title: JSOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2008-award\ndate: 2016-10-18 21:34:00\n---\n\n $ \\leq 10 $\n\n<!-- more -->\n\n### \n[BZOJ 1016](http://www.lydsy.com/JudgeOnline/problem.php?id=1016)\n\n### \n> \n\nhttps://blog.sengxian.com/solutions/bzoj-1016\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nconst int MAXN = 100;\nconst int MAXM = 1000;\nconst int MAXC = 1000000000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool used;\n\n\tbool operator<(const Edge &other) const { return w < other.w; }\n} E[MAXM];\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tvoid merge(const int x, const int y) {\n\t\ta[find(x)] = find(y);\n\t}\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n} ufs;\n\nstruct EdgeGroup {\n\tint used;\n\tstd::vector<Edge> edges;\n};\n\nint n, m, graph[MAXN][MAXN];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.test(E[i].u, E[i].v)) {\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tE[i].used = true;\n\t\t\tgroups[E[i].w].used++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].edges.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w), E[i].u--, E[i].v--;\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.used == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.edges.size()); s++) {\n\t\t\t\tint popcount = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.edges.size(); i++) if (s & (1 << i)) popcount++;\n\t\t\t\tif (popcount != it->second.used) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tif (!(s & (1 << (e - it->second.edges.begin())))) continue;\n\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tif (graph[i][j]) {\n\t\t\t\t\t\t\tif (ufs.test(i, j)) {\n\t\t\t\t\t\t\t\tgoto nextLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\nnextLoop:;\n\t\t\t}\n\t\t\t// printf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = e->used;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-award","published":1,"updated":"2016-10-18T13:41:02.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ruh00wwooxlfh07q9na"},{"title":"JSOI2007 - ","date":"2016-11-13T01:11:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029)\n\n### \n****\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 150000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic std::pair<int, int> a[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].second, &a[i].first);\n\n\tstd::sort(a, a + n);\n\n\tstd::priority_queue<int> q;\n\tlong long t = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t + a[i].second <= a[i].first) {\n\t\t\tt += a[i].second;\n\t\t\tq.push(a[i].second);\n\t\t\tans++;\n\t\t} else if (!q.empty() && q.top() > a[i].second) {\n\t\t\tt -= q.top();\n\t\t\tt += a[i].second;\n\t\t\tq.pop();\n\t\t\tq.push(a[i].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-repair.md","raw":"title: JSOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \npermalink: jsoi2007-repair\ndate: 2016-11-13 09:11:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029)\n\n### \n****\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 150000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic std::pair<int, int> a[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].second, &a[i].first);\n\n\tstd::sort(a, a + n);\n\n\tstd::priority_queue<int> q;\n\tlong long t = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t + a[i].second <= a[i].first) {\n\t\t\tt += a[i].second;\n\t\t\tq.push(a[i].second);\n\t\t\tans++;\n\t\t} else if (!q.empty() && q.top() > a[i].second) {\n\t\t\tt -= q.top();\n\t\t\tt += a[i].second;\n\t\t\tq.pop();\n\t\t\tq.push(a[i].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"jsoi2007-repair","published":1,"updated":"2016-11-13T01:25:57.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rum00x2ooxlk70b6ezl"},{"title":"JSOI2007 -  + ","date":"2016-11-13T00:27:00.000Z","_content":"\n\n $ 1 $  $ n $  $ 3m + 2 $  $ 3m $  $ m $  $ 3m + 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028)\n\n### \n $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 1000;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN];\n\tfor (int i = 0; i < m * 3 + 1; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1]++;\n\t}\n\n\tstatic int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic int b[MAXN];\n\t\tstd::copy(a, a + n, b);\n\t\tb[i]++;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (b[j] >= 2) {\n\t\t\t\tstatic int c[MAXN + 2];\n\t\t\t\tstd::copy(b, b + n, c);\n\t\t\t\tc[j] -= 2;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (c[k] == 0) continue;\n\t\t\t\t\tc[k] %= 3;\n\t\t\t\t\tint x = std::min(std::min(c[k], c[k + 1]), c[k + 2]);\n\t\t\t\t\tif (x < c[k]) goto fail;\n\t\t\t\t\tc[k] -= x, c[k + 1] -= x, c[k + 2] -= x;\n\t\t\t\t}\n\n\t\t\t\tgoto success;\n\nfail:;\n\t\t\t}\n\t\t}\n\n\t\tcontinue;\n\nsuccess:\n\t\tans[cnt++] = i + 1;\n\t}\n\n\tif (cnt) {\n\t\tfor (int i = 0; i < cnt; i++) printf(\"%d%c\", ans[i], i == cnt - 1 ? '\\n' : ' ');\n\t} else puts(\"NO\");\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-mahjong.md","raw":"title: JSOI2007 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2007-mahjong\ndate: 2016-11-13 08:27:00\n---\n\n\n $ 1 $  $ n $  $ 3m + 2 $  $ 3m $  $ m $  $ 3m + 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028)\n\n### \n $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 1000;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN];\n\tfor (int i = 0; i < m * 3 + 1; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1]++;\n\t}\n\n\tstatic int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic int b[MAXN];\n\t\tstd::copy(a, a + n, b);\n\t\tb[i]++;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (b[j] >= 2) {\n\t\t\t\tstatic int c[MAXN + 2];\n\t\t\t\tstd::copy(b, b + n, c);\n\t\t\t\tc[j] -= 2;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (c[k] == 0) continue;\n\t\t\t\t\tc[k] %= 3;\n\t\t\t\t\tint x = std::min(std::min(c[k], c[k + 1]), c[k + 2]);\n\t\t\t\t\tif (x < c[k]) goto fail;\n\t\t\t\t\tc[k] -= x, c[k + 1] -= x, c[k + 2] -= x;\n\t\t\t\t}\n\n\t\t\t\tgoto success;\n\nfail:;\n\t\t\t}\n\t\t}\n\n\t\tcontinue;\n\nsuccess:\n\t\tans[cnt++] = i + 1;\n\t}\n\n\tif (cnt) {\n\t\tfor (int i = 0; i < cnt; i++) printf(\"%d%c\", ans[i], i == cnt - 1 ? '\\n' : ' ');\n\t} else puts(\"NO\");\n\n\treturn 0;\n}\n```","slug":"jsoi2007-mahjong","published":1,"updated":"2016-11-13T00:32:35.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rur00x7ooxlhuw5oi9f"},{"title":"JSOI2007 - AC ","date":"2016-09-11T23:19:00.000Z","_content":"\n    \n\n $ a $  $ b $ $ b $  $ a $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030)\n\n### \n\n\n DP    $ i $  $ j $  KMP \n\n KMP  AC  $ j $  AC  $ j $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 60;\nconst int MAXM = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\n\nstruct Trie {\n\tstruct Node {\n\t\tint id;\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool next(Node *v, const char ch, Node *&next) {\n\t\twhile (v != root && !v->c[ch]) v = v->fail;\n\t\tnext = v->c[ch] ? v->c[ch] : root;\n\t\tif (!v->c[ch]) return false;\n\t\telse if (v->c[ch]->isWord) return true;\n\t\telse if (v->c[ch]->next) return true;\n\t\telse return false;\n\t}\n\n\tvoid getNodeList(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tvec.push_back(v);\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) if (v->c[i]) q.push(v->c[i]);\n\t\t}\n\t}\n} t;\n\ninline int pow(int x, int n) {\n\tint ans = 1;\n\tfor (; n; n >>= 1, x = x * x % MOD) if (n & 1) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (n--) {\n\t\tchar s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\n\tstd::vector<Trie::Node *> vec;\n\tt.getNodeList(vec);\n\n\t// std::tr1::unordered_map<Trie::Node *, int> f[MAXM + 1];\n\tstatic int f[MAXM + 1][MAXM * MAXN + 1];\n\t// for (size_t i = 0; i < vec.size(); i++) for (int j = 0; j < CHARSET_SIZE; j++) if (!vec[i]->c[j] || !vec[i]->c[j]->isWord) f[1][vec[i]]++;\n\tfor (size_t i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tTrie::Node *next;\n\t\t\t\tif (!t.next(vec[j], k, next)) {\n\t\t\t\t\t(f[i][j] += f[i - 1][next->id]) %= MOD;\n\t\t\t\t\t// if (k <= 5) printf(\"(%d, %lu) => %d (%d)\\n\", i, j, k, f[i - 1][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) printf(\"f(%d, %lu) = %d\\n\", i, j, f[i][vec[j]]);\n\t\tputchar('\\n');\n\t}\n\t// */\n\n\t// printf(\"%d\\n\", f[m][t.root]);\n\tprintf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id]) % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-generator.md","raw":"title: JSOI2007 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - AC \n  - DP\npermalink: jsoi2007-generator\ndate: 2016-09-12 07:19:00\n---\n\n    \n\n $ a $  $ b $ $ b $  $ a $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030)\n\n### \n\n\n DP    $ i $  $ j $  KMP \n\n KMP  AC  $ j $  AC  $ j $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 60;\nconst int MAXM = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\n\nstruct Trie {\n\tstruct Node {\n\t\tint id;\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool next(Node *v, const char ch, Node *&next) {\n\t\twhile (v != root && !v->c[ch]) v = v->fail;\n\t\tnext = v->c[ch] ? v->c[ch] : root;\n\t\tif (!v->c[ch]) return false;\n\t\telse if (v->c[ch]->isWord) return true;\n\t\telse if (v->c[ch]->next) return true;\n\t\telse return false;\n\t}\n\n\tvoid getNodeList(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tvec.push_back(v);\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) if (v->c[i]) q.push(v->c[i]);\n\t\t}\n\t}\n} t;\n\ninline int pow(int x, int n) {\n\tint ans = 1;\n\tfor (; n; n >>= 1, x = x * x % MOD) if (n & 1) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (n--) {\n\t\tchar s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\n\tstd::vector<Trie::Node *> vec;\n\tt.getNodeList(vec);\n\n\t// std::tr1::unordered_map<Trie::Node *, int> f[MAXM + 1];\n\tstatic int f[MAXM + 1][MAXM * MAXN + 1];\n\t// for (size_t i = 0; i < vec.size(); i++) for (int j = 0; j < CHARSET_SIZE; j++) if (!vec[i]->c[j] || !vec[i]->c[j]->isWord) f[1][vec[i]]++;\n\tfor (size_t i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tTrie::Node *next;\n\t\t\t\tif (!t.next(vec[j], k, next)) {\n\t\t\t\t\t(f[i][j] += f[i - 1][next->id]) %= MOD;\n\t\t\t\t\t// if (k <= 5) printf(\"(%d, %lu) => %d (%d)\\n\", i, j, k, f[i - 1][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) printf(\"f(%d, %lu) = %d\\n\", i, j, f[i][vec[j]]);\n\t\tputchar('\\n');\n\t}\n\t// */\n\n\t// printf(\"%d\\n\", f[m][t.root]);\n\tprintf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id]) % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```","slug":"jsoi2007-generator","published":1,"updated":"2016-09-11T23:28:09.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ruw00xeooxlo4d9l9wm"},{"title":"JSOI2007 - ","date":"2016-09-29T13:00:00.000Z","_content":"\n $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5 * 2;\n\nchar s[MAXN];\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\n\ninline void print(const int *a) {\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(fir);\n\t\t// print(sec);\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\t\t// print(tmp);\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(buc);\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\t\t// print(sa);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\t// print(rk);\n\n\t\t// return;\n\t}\n\t// puts(\"----------------\");\n\t// print(sa);\n\t// print(rk);\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", s + sa[i]);\n\t\n\t/*\n\tfor (int i = 0, j, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tj = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\t// k = 0;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\t*/\n\t// print(ht);\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++) s[i + n] = s[i];\n\tn *= 2;\n\tsuffixArray();\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i] + 1, i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 1; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sa[i] < n / 2) {\n\t\t\tputchar(s[sa[i] + n / 2 - 1]);\n\t\t}\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-cipher.md","raw":"title: JSOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2007-cipher\ndate: 2016-09-29 21:00:00\n---\n\n $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5 * 2;\n\nchar s[MAXN];\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\n\ninline void print(const int *a) {\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(fir);\n\t\t// print(sec);\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\t\t// print(tmp);\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(buc);\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\t\t// print(sa);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\t// print(rk);\n\n\t\t// return;\n\t}\n\t// puts(\"----------------\");\n\t// print(sa);\n\t// print(rk);\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", s + sa[i]);\n\t\n\t/*\n\tfor (int i = 0, j, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tj = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\t// k = 0;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\t*/\n\t// print(ht);\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++) s[i + n] = s[i];\n\tn *= 2;\n\tsuffixArray();\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i] + 1, i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 1; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sa[i] < n / 2) {\n\t\t\tputchar(s[sa[i] + n / 2 - 1]);\n\t\t}\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","slug":"jsoi2007-cipher","published":1,"updated":"2016-09-29T13:06:01.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rv100xlooxlpu5l47dr"},{"title":"IOI2011Race - ","date":"2016-06-16T12:01:00.000Z","_content":"\n**** $ K $\n\n<!-- more -->\n\n### \n[BZOJ 2599](http://www.lydsy.com/JudgeOnline/problem.php?id=2599)\n\n### \n $ K $ \n\n $ {\\rm depth}(v) $  $ {\\rm dist}(v) $\n\n $ f(i) $ **** $ i $ \n\n $ {\\rm depth}(i) + f(K - {\\rm dist}(i)) $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n// #include \"rand.h\"\n#include <queue>\n#include <stack>\n\nconst int MAXN = 200000;\nconst int MAXK = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist, depth, size, max;\n\tbool visited, solved;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\nint f[MAXK + 1];\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->visited = false;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// return a[rand(0, cnt - 1)];\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"%d %d\\n\", cnt, start->size);\n\t\tassert(cnt == start->size);\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\treturn res;\n}\n\ninline int calc(Node *root) {\n\tstatic int A[MAXN];\n\tint tot = 0, res = INT_MAX;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(e->t);\n\t\te->t->parent = root;\n\t\te->t->dist = e->w;\n\t\te->t->depth = 1;\n\n\t\tstatic Node *a[MAXN];\n\t\tint cnt = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tif (v->dist > k) continue;\n\n\t\t\tA[tot++] = v->dist;\n\t\t\ta[cnt++] = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t// assert(k - a[i]->dist >= 0 && k - a[i]->dist <= k);\n\t\t\tif (f[k - a[i]->dist] != INT_MAX) res = std::min(res, f[k - a[i]->dist] + a[i]->depth);\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tf[a[i]->dist] = std::min(f[a[i]->dist], a[i]->depth);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) {\n\t\t// assert(A[i] >= 0 && A[i] <= k);\n\t\tf[A[i]] = INT_MAX;\n\t}\n\n\t// printf(\"calc(%ld) = %d\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = INT_MAX;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans = std::min(ans, calc(root));\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\t// assert(n <= MAXN);\n\t// assert(k <= MAXK);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w);\n\t}\n\n\tfor (int i = 1; i <= k; i++) f[i] = INT_MAX;\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/ioi2011-race.md","raw":"title: IOI2011Race - \ncategories: OI\ntags: \n  - IOI\n  - BZOJ\n  - \n  - \npermalink: ioi2011-race\ndate: 2016-06-16 20:01:00\n---\n\n**** $ K $\n\n<!-- more -->\n\n### \n[BZOJ 2599](http://www.lydsy.com/JudgeOnline/problem.php?id=2599)\n\n### \n $ K $ \n\n $ {\\rm depth}(v) $  $ {\\rm dist}(v) $\n\n $ f(i) $ **** $ i $ \n\n $ {\\rm depth}(i) + f(K - {\\rm dist}(i)) $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n// #include \"rand.h\"\n#include <queue>\n#include <stack>\n\nconst int MAXN = 200000;\nconst int MAXK = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist, depth, size, max;\n\tbool visited, solved;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\nint f[MAXK + 1];\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->visited = false;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// return a[rand(0, cnt - 1)];\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"%d %d\\n\", cnt, start->size);\n\t\tassert(cnt == start->size);\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\treturn res;\n}\n\ninline int calc(Node *root) {\n\tstatic int A[MAXN];\n\tint tot = 0, res = INT_MAX;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(e->t);\n\t\te->t->parent = root;\n\t\te->t->dist = e->w;\n\t\te->t->depth = 1;\n\n\t\tstatic Node *a[MAXN];\n\t\tint cnt = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tif (v->dist > k) continue;\n\n\t\t\tA[tot++] = v->dist;\n\t\t\ta[cnt++] = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t// assert(k - a[i]->dist >= 0 && k - a[i]->dist <= k);\n\t\t\tif (f[k - a[i]->dist] != INT_MAX) res = std::min(res, f[k - a[i]->dist] + a[i]->depth);\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tf[a[i]->dist] = std::min(f[a[i]->dist], a[i]->depth);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) {\n\t\t// assert(A[i] >= 0 && A[i] <= k);\n\t\tf[A[i]] = INT_MAX;\n\t}\n\n\t// printf(\"calc(%ld) = %d\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = INT_MAX;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans = std::min(ans, calc(root));\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\t// assert(n <= MAXN);\n\t// assert(k <= MAXK);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w);\n\t}\n\n\tfor (int i = 1; i <= k; i++) f[i] = INT_MAX;\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","slug":"ioi2011-race","published":1,"updated":"2016-06-16T12:01:55.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rv700xrooxl1oxktl3f"},{"title":"IOI2008 -  DP","date":"2016-10-24T13:39:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1791](http://www.lydsy.com/JudgeOnline/problem.php?id=1791)\n\n### \n\n\n $ f(i) $  $ i $  $ i $  $ j $$ f(i) = \\max\\{ f(j) + d(i, j) \\} $\n\n $ u $$ v $  $ f(u) + d(i, u) + f(v) + d(i, v) $ \n\n DP\n\n $ f'(i) $  $ i $  $ f $ $ s(i) $  $ i $ \n\n $ i $  $ i $  $ j $ $ i $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + s(i) - s(j) \\pod {i > j} \\\\\n= & f'(j) - s(j) + f'(i) + s(i)\n\\end{aligned}\n$$\n\n $ i $  $ j $$ S $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + S - (s(i) - s(j)) \\pod {i > j} \\\\\n= & f'(i) + f'(j) + S - s(i) + s(j) \\\\\n= & f'(j) + s(j) + S + f'(i) - s(i)\n\\end{aligned}\n$$\n\n $ f'(j) + s(j) + S $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tbool inCircle, solved, visited, pushed;\n\tint depth, inDegree;\n\tlong long len;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long w;\n\tEdge *next, *r;\n\tbool disabled;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nint n;\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline std::vector<Node *> getBlock(Node *start) {\n\tstd::queue<Node *> q;\n\tq.push(start);\n\tstart->inDegree = 0;\n\tstart->visited = true;\n\n\tstd::vector<Node *> block;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tblock.push_back(v);\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e == v->in || e->t->solved) continue;\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->inDegree = 1;\n\t\t\t\te->t->in = e;\n\t\t\t\tq.push(e->t);\n\t\t\t} else e->t->inDegree++;\n\t\t}\n\t}\n\n\treturn block;\n}\n\ninline void toposort(std::vector<Node *> &v) {\n\tstd::queue<Node *> q;\n\tfor (size_t i = 0; i < v.size(); i++) {\n#ifdef DBG\n\t\tprintf(\"toposort(): inDegree[%lu] = %d\\n\", v[i] - N + 1, v[i]->inDegree);\n#endif\n\t\tif (v[i]->inDegree == 1) q.push(v[i]);\n\t\telse v[i]->inCircle = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tv->inCircle = false;\n#ifdef CHECK\n\t\tprintf(\"%lu\\n\", v - N);\n#endif\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->solved) continue;\n\t\t\tif (--e->t->inDegree == 1) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calcTree(std::vector<Node *> &v) {\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i]->visited = false;\n\t\tv[i]->inDegree = 0;\n\t\tv[i]->depth = 0;\n\t}\n\n\tstd::stack<Node *> s;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->depth = 1;\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t}\n\t\t\n\t\twhile (v->c && (v->c->t->inCircle || v->c->t->pushed || v->c->t->solved)) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\te->t->pushed = true;\n\t\t\te->t->parent = v;\n\t\t\ts.push(e->t);\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tv->len = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->inCircle || e->t->parent != v) continue;\n\n\t\t\t\tans = std::max(ans, v->len + e->t->len + e->w);\n\t\t\t\tv->len = std::max(v->len, e->t->len + e->w);\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\"calcTree(size = %lu) = %lld\\n\", v.size(), ans);\n#endif\n\treturn ans;\n}\n\ninline long long calcCircle(std::vector<Node *> &v) {\n\tNode *start;\n\tfor (size_t i = 0; i < v.size(); i++) v[i]->visited = false;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->visited = true;\n\t\t\tstart = v[i];\n\t\t\tbreak;\n\t\t}\n\t\tfor (Edge *e = v[i]->e; e; e = e->next) e->disabled = false;\n\t}\n\n\tstatic Node *c[MAXN];\n\tstatic long long s[MAXN];\n\tint cnt = 0;\n\tlong long sum = 0;\n\n#ifdef DBG\n\tfor (int i = 0; i < MAXN; i++) c[i] = NULL, s[i] = 0;\n#endif\n\n\tNode *u = start;\n\tc[cnt++] = u;\n\twhile (1) {\n\t\tNode *next = NULL;\n\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\tif (!e->t->visited && e->t->inCircle) {\n\t\t\t\tc[cnt] = e->t;\n\t\t\t\ts[cnt] = e->w;\n\t\t\t\tsum += e->w;\n\t\t\t\tcnt++;\n\t\t\t\te->t->visited = true;\n\t\t\t\te->r->disabled = true;\n\t\t\t\tnext = e->t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tu = next;\n\t\t} else {\n\t\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\t\tif (e->t == start) {\n\t\t\t\t\tsum += e->w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n == 0) return 0;\n\t/*\n\tif (cnt == 2) {\n\t\tlong long ans = c[0]->len + c[1]->len + std::max(s[1], sum - s[1]);\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", s[1], sum);\n\t\tprintf(\"calcCircle(size = 2) = %lld\\n\", ans);\n#endif\n\t\treturn ans;\n\t}\n\t*/\n\n\tfor (int i = 1; i < cnt; i++) s[i] += s[i - 1];\n\n\t// ans1 = f[a] + f[b] + s[a] - s[b]\n\t// ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b]\n\t// maintain the max of f[b] - s[b] and f[b] + s[b]\n\tlong long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans = std::max(ans, c[i]->len + s[i] + max1);\n\t\tans = std::max(ans, sum + c[i]->len - s[i] + max2);\n\n\t\tmax1 = std::max(max1, c[i]->len - s[i]);\n\t\tmax2 = std::max(max2, c[i]->len + s[i]);\n\n#ifdef DBG\n\t\tprintf(\"ans = %lld, max1 = %lld, max2 = %lld\\n\", ans, max1, max2);\n#endif\n\t}\n\n#ifdef DBG\n\tprintf(\"calcCircle(size = %lu, cnt = %d) = %lld\\n\", v.size(), cnt, ans);\n#endif\n\treturn ans;\n}\n\ninline long long solve() {\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].solved) continue;\n\n\t\tstd::vector<Node *> block = getBlock(&N[i]);\n\t\ttoposort(block);\n\n\t\tlong long tmp = calcTree(block);\n\t\ttmp = std::max(tmp, calcCircle(block));\n\t\tans += tmp;\n\n\t\tfor (size_t i = 0; i < block.size(); i++) block[i]->solved = true;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u, w;\n\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\taddEdge(i, u, w);\n\t}\n\n\tprintf(\"%lld\\n\", solve());\n\n#ifdef CHECK\n\tfor (int i = 0; i < n; i++) printf(\"f[%d] = %lld\\n\", i, N[i].len);\n#endif\n\n\treturn 0;\n}\n```\n","source":"_posts/ioi2008-island.md","raw":"title: IOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\n  - \n  - Tarjan\npermalink: ioi2008-island\ndate: 2016-10-24 21:39:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1791](http://www.lydsy.com/JudgeOnline/problem.php?id=1791)\n\n### \n\n\n $ f(i) $  $ i $  $ i $  $ j $$ f(i) = \\max\\{ f(j) + d(i, j) \\} $\n\n $ u $$ v $  $ f(u) + d(i, u) + f(v) + d(i, v) $ \n\n DP\n\n $ f'(i) $  $ i $  $ f $ $ s(i) $  $ i $ \n\n $ i $  $ i $  $ j $ $ i $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + s(i) - s(j) \\pod {i > j} \\\\\n= & f'(j) - s(j) + f'(i) + s(i)\n\\end{aligned}\n$$\n\n $ i $  $ j $$ S $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + S - (s(i) - s(j)) \\pod {i > j} \\\\\n= & f'(i) + f'(j) + S - s(i) + s(j) \\\\\n= & f'(j) + s(j) + S + f'(i) - s(i)\n\\end{aligned}\n$$\n\n $ f'(j) + s(j) + S $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tbool inCircle, solved, visited, pushed;\n\tint depth, inDegree;\n\tlong long len;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long w;\n\tEdge *next, *r;\n\tbool disabled;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nint n;\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline std::vector<Node *> getBlock(Node *start) {\n\tstd::queue<Node *> q;\n\tq.push(start);\n\tstart->inDegree = 0;\n\tstart->visited = true;\n\n\tstd::vector<Node *> block;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tblock.push_back(v);\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e == v->in || e->t->solved) continue;\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->inDegree = 1;\n\t\t\t\te->t->in = e;\n\t\t\t\tq.push(e->t);\n\t\t\t} else e->t->inDegree++;\n\t\t}\n\t}\n\n\treturn block;\n}\n\ninline void toposort(std::vector<Node *> &v) {\n\tstd::queue<Node *> q;\n\tfor (size_t i = 0; i < v.size(); i++) {\n#ifdef DBG\n\t\tprintf(\"toposort(): inDegree[%lu] = %d\\n\", v[i] - N + 1, v[i]->inDegree);\n#endif\n\t\tif (v[i]->inDegree == 1) q.push(v[i]);\n\t\telse v[i]->inCircle = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tv->inCircle = false;\n#ifdef CHECK\n\t\tprintf(\"%lu\\n\", v - N);\n#endif\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->solved) continue;\n\t\t\tif (--e->t->inDegree == 1) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calcTree(std::vector<Node *> &v) {\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i]->visited = false;\n\t\tv[i]->inDegree = 0;\n\t\tv[i]->depth = 0;\n\t}\n\n\tstd::stack<Node *> s;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->depth = 1;\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t}\n\t\t\n\t\twhile (v->c && (v->c->t->inCircle || v->c->t->pushed || v->c->t->solved)) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\te->t->pushed = true;\n\t\t\te->t->parent = v;\n\t\t\ts.push(e->t);\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tv->len = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->inCircle || e->t->parent != v) continue;\n\n\t\t\t\tans = std::max(ans, v->len + e->t->len + e->w);\n\t\t\t\tv->len = std::max(v->len, e->t->len + e->w);\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\"calcTree(size = %lu) = %lld\\n\", v.size(), ans);\n#endif\n\treturn ans;\n}\n\ninline long long calcCircle(std::vector<Node *> &v) {\n\tNode *start;\n\tfor (size_t i = 0; i < v.size(); i++) v[i]->visited = false;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->visited = true;\n\t\t\tstart = v[i];\n\t\t\tbreak;\n\t\t}\n\t\tfor (Edge *e = v[i]->e; e; e = e->next) e->disabled = false;\n\t}\n\n\tstatic Node *c[MAXN];\n\tstatic long long s[MAXN];\n\tint cnt = 0;\n\tlong long sum = 0;\n\n#ifdef DBG\n\tfor (int i = 0; i < MAXN; i++) c[i] = NULL, s[i] = 0;\n#endif\n\n\tNode *u = start;\n\tc[cnt++] = u;\n\twhile (1) {\n\t\tNode *next = NULL;\n\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\tif (!e->t->visited && e->t->inCircle) {\n\t\t\t\tc[cnt] = e->t;\n\t\t\t\ts[cnt] = e->w;\n\t\t\t\tsum += e->w;\n\t\t\t\tcnt++;\n\t\t\t\te->t->visited = true;\n\t\t\t\te->r->disabled = true;\n\t\t\t\tnext = e->t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tu = next;\n\t\t} else {\n\t\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\t\tif (e->t == start) {\n\t\t\t\t\tsum += e->w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n == 0) return 0;\n\t/*\n\tif (cnt == 2) {\n\t\tlong long ans = c[0]->len + c[1]->len + std::max(s[1], sum - s[1]);\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", s[1], sum);\n\t\tprintf(\"calcCircle(size = 2) = %lld\\n\", ans);\n#endif\n\t\treturn ans;\n\t}\n\t*/\n\n\tfor (int i = 1; i < cnt; i++) s[i] += s[i - 1];\n\n\t// ans1 = f[a] + f[b] + s[a] - s[b]\n\t// ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b]\n\t// maintain the max of f[b] - s[b] and f[b] + s[b]\n\tlong long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans = std::max(ans, c[i]->len + s[i] + max1);\n\t\tans = std::max(ans, sum + c[i]->len - s[i] + max2);\n\n\t\tmax1 = std::max(max1, c[i]->len - s[i]);\n\t\tmax2 = std::max(max2, c[i]->len + s[i]);\n\n#ifdef DBG\n\t\tprintf(\"ans = %lld, max1 = %lld, max2 = %lld\\n\", ans, max1, max2);\n#endif\n\t}\n\n#ifdef DBG\n\tprintf(\"calcCircle(size = %lu, cnt = %d) = %lld\\n\", v.size(), cnt, ans);\n#endif\n\treturn ans;\n}\n\ninline long long solve() {\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].solved) continue;\n\n\t\tstd::vector<Node *> block = getBlock(&N[i]);\n\t\ttoposort(block);\n\n\t\tlong long tmp = calcTree(block);\n\t\ttmp = std::max(tmp, calcCircle(block));\n\t\tans += tmp;\n\n\t\tfor (size_t i = 0; i < block.size(); i++) block[i]->solved = true;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u, w;\n\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\taddEdge(i, u, w);\n\t}\n\n\tprintf(\"%lld\\n\", solve());\n\n#ifdef CHECK\n\tfor (int i = 0; i < n; i++) printf(\"f[%d] = %lld\\n\", i, N[i].len);\n#endif\n\n\treturn 0;\n}\n```\n","slug":"ioi2008-island","published":1,"updated":"2016-10-25T13:32:29.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvd00xyooxltd7l4l7c"},{"title":"HNOI2016 -  + ","date":"2016-05-11T09:28:00.000Z","_content":"\n A  A  $ N $  $ 1,\\ 2,\\ \\dots,\\ N $ $ 1 $  A \n\n1. \n2.  345  $ M $ \n3.  $ a,\\ b $ $ 1 \\leq a \\leq N $$ 1 \\leq b \\leq $ \n4.  $ a $  $ b $  $ a $  $ b $ )\n5.  4  $ L $  $ a $  $ C $  $ C $  $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $ $ C $  $ C $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### \n\n\n $ k $ \n\n\n\n1. \n2. \n3.  2 \n\n $ O((m + q) \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-tree.md","raw":"title: HNOI2016 -  + \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - \n  - \n  - \npermalink: hnoi2016-tree\ndate: 2016-05-11 17:28:00\n---\n\n A  A  $ N $  $ 1,\\ 2,\\ \\dots,\\ N $ $ 1 $  A \n\n1. \n2.  345  $ M $ \n3.  $ a,\\ b $ $ 1 \\leq a \\leq N $$ 1 \\leq b \\leq $ \n4.  $ a $  $ b $  $ a $  $ b $ )\n5.  4  $ L $  $ a $  $ C $  $ C $  $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $ $ C $  $ C $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### \n\n\n $ k $ \n\n\n\n1. \n2. \n3.  2 \n\n $ O((m + q) \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-tree","published":1,"updated":"2016-09-10T05:51:35.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvi00y6ooxlkshkth0r"},{"title":"HNOI2016 -  + RMQ","date":"2016-04-30T13:23:18.000Z","_content":"\n $ n $ $ a_1,\\ a_2,\\ \\dots,\\ a_n $ $ a[1:n] $$ a[l:r] $$ 1 \\leq l \\leq r \\leq n $$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $ $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $ $ a[s:t] $  $ a[l:r] $ \n\n $ q $  $ l $  $ r $$ 1 \\leq l \\leq r \\leq n $ $ a[l:r] $ \n\n<!-- more -->\n\n### \n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### \n[Sengxian ](https://blog.sengxian.com/solutions/bzoj-4540)\n\n\n\n $ [i] $  $ i $  $ a_i $$ [ \\ [l,\\ r],\\ R \\ ] $  $ [l,\\ r] $ $ R $ \n\n $ [l,\\ r - 1] $  $ [r] $  $ r - l + 1 $  $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $\n\n$ [l, r] $  $ [m] $ $ [ \\ [l,\\ m],\\ r \\ ] $  $ [m] $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n $ [ \\ [1,\\ 4],\\ 6 \\ ] $  $ [4] $ $ 1 $\n\n $ r - m $  $ r $  $ [r] $ ****$ r $  $ [r] $ $ [r] $  $ [8] = 3 $ $ {\\rm left}(r) = p $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $  $ r - p = 10 - 8 = 2 $  $ [10] = 4 $ $ (r - p) \\times [r] $\n\n $ [p] = 3 $  $ [6] = 2 $ $ {\\rm left}(p) = p' = 6 $\n\n|  | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $  $ p - p' = 8 - 6 = 2 $  $ [8] = 3 $ $ (p - p') \\times [p] $\n\n $ p' $  $ 1 $ $ {\\rm left}(p') = m = 4 $ $ m $  $ p' - m = 6 - 4 = 2 $  $ [p'] = 2 $ $ (p' - m) \\times [p'] $\n\n $ O(n) $\n\n $ m = \\min[l,\\ r] $  $ [l,\\ r] $  $ f(l, r) $  $ [l,\\ r] $ \n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n $ m $  $ l $ \n\n $ s(i) $  $ i $ \n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n$ {\\rm left}(p') = {\\rm left}(m + 1) = m $********\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n $ {\\rm left}(i) $ $ O(n) $  $ s(i) $\n\n RMQ $ O(n \\log n) $  $ O(1) $  $ O(1) $ $ O(q \\log q + n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-sequence.md","raw":"title: HNOI2016 -  + RMQ\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - RMQ\npermalink: hnoi2016-sequence\ndate: 2016-04-30 21:23:18\n---\n\n $ n $ $ a_1,\\ a_2,\\ \\dots,\\ a_n $ $ a[1:n] $$ a[l:r] $$ 1 \\leq l \\leq r \\leq n $$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $ $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $ $ a[s:t] $  $ a[l:r] $ \n\n $ q $  $ l $  $ r $$ 1 \\leq l \\leq r \\leq n $ $ a[l:r] $ \n\n<!-- more -->\n\n### \n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### \n[Sengxian ](https://blog.sengxian.com/solutions/bzoj-4540)\n\n\n\n $ [i] $  $ i $  $ a_i $$ [ \\ [l,\\ r],\\ R \\ ] $  $ [l,\\ r] $ $ R $ \n\n $ [l,\\ r - 1] $  $ [r] $  $ r - l + 1 $  $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $\n\n$ [l, r] $  $ [m] $ $ [ \\ [l,\\ m],\\ r \\ ] $  $ [m] $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n $ [ \\ [1,\\ 4],\\ 6 \\ ] $  $ [4] $ $ 1 $\n\n $ r - m $  $ r $  $ [r] $ ****$ r $  $ [r] $ $ [r] $  $ [8] = 3 $ $ {\\rm left}(r) = p $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $  $ r - p = 10 - 8 = 2 $  $ [10] = 4 $ $ (r - p) \\times [r] $\n\n $ [p] = 3 $  $ [6] = 2 $ $ {\\rm left}(p) = p' = 6 $\n\n|  | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $  $ p - p' = 8 - 6 = 2 $  $ [8] = 3 $ $ (p - p') \\times [p] $\n\n $ p' $  $ 1 $ $ {\\rm left}(p') = m = 4 $ $ m $  $ p' - m = 6 - 4 = 2 $  $ [p'] = 2 $ $ (p' - m) \\times [p'] $\n\n $ O(n) $\n\n $ m = \\min[l,\\ r] $  $ [l,\\ r] $  $ f(l, r) $  $ [l,\\ r] $ \n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n $ m $  $ l $ \n\n $ s(i) $  $ i $ \n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n$ {\\rm left}(p') = {\\rm left}(m + 1) = m $********\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n $ {\\rm left}(i) $ $ O(n) $  $ s(i) $\n\n RMQ $ O(n \\log n) $  $ O(1) $  $ O(1) $ $ O(q \\log q + n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-sequence","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvp00yfooxldumqyx55"},{"title":"HNOI2016 -  + DFS ","date":"2016-05-11T09:08:00.000Z","_content":"\n\n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### \n DFS  DFS  $ O(\\log n) $ \n\n******** DFS  $ O(\\log n) $  $ O(\\log n) $ \n\n\n\n $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","source":"_posts/hnoi2016-network.md","raw":"title: HNOI2016 -  + DFS \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - \n  - DFS \npermalink: hnoi2016-network\ndate: 2016-05-11 17:08:00\n---\n\n\n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### \n DFS  DFS  $ O(\\log n) $ \n\n******** DFS  $ O(\\log n) $  $ O(\\log n) $ \n\n\n\n $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","slug":"hnoi2016-network","published":1,"updated":"2016-05-11T09:39:49.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvt00ylooxlsots6p61"},{"title":"HNOI2016 -  + ","date":"2016-05-11T08:39:00.000Z","_content":"\n $ N $  $ M $  $ 1,\\ 2,\\ \\dots,\\ n $ $ 2 ^ a 3 ^ b $  $ q $  $ u $$ v $$ a $  $ b $ $ u $  $ v $  $ 2 ^ a 3 ^ b $\n\n<!-- more -->\n\n### \n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### \n******** $ 2 $  $ 3 $  $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $  $ 2 $  $ 3 $  $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $\n\n $ a $  $ b $ \n\n $ a $  $ b $  $ a $  $ b $  $ O(qm \\  \\alpha(m)) $\n\n $ a $  $ a $  $ b $ \n\n $ a $  $ T $  $ a $  $ a $ $ b $  $ a $  $ b $ ****\n\n********\n\n $ O(\\frac{n}{T}) $  $ O(\\frac{n}{T}) $  $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $ $ T $  $ 1 $  $ O(T m \\log m + q \\log q) $ $ T = \\sqrt m $ $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-multiple.md","raw":"title: HNOI2016 -  + \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - CodeVS\n  - HNOI\n  - \n  - \npermalink: hnoi2016-multiple\ndate: 2016-05-11 16:39:00\n---\n\n $ N $  $ M $  $ 1,\\ 2,\\ \\dots,\\ n $ $ 2 ^ a 3 ^ b $  $ q $  $ u $$ v $$ a $  $ b $ $ u $  $ v $  $ 2 ^ a 3 ^ b $\n\n<!-- more -->\n\n### \n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### \n******** $ 2 $  $ 3 $  $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $  $ 2 $  $ 3 $  $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $\n\n $ a $  $ b $ \n\n $ a $  $ b $  $ a $  $ b $  $ O(qm \\  \\alpha(m)) $\n\n $ a $  $ a $  $ b $ \n\n $ a $  $ T $  $ a $  $ a $ $ b $  $ a $  $ b $ ****\n\n********\n\n $ O(\\frac{n}{T}) $  $ O(\\frac{n}{T}) $  $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $ $ T $  $ 1 $  $ O(T m \\log m + q \\log q) $ $ T = \\sqrt m $ $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-multiple","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rvz00ytooxlfpvqw87o"},{"title":"HNOI2012 - ","date":"2016-09-07T23:52:00.000Z","_content":"\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2730](http://www.lydsy.com/JudgeOnline/problem.php?id=2730)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// if (v->flag) printf(\"!!!: %lu\\n\", v - N + 1);\n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n\ninline void solve(int &min, long long &cnt) {\n\tmin = 0, cnt = 1;\n\tfor (int i = 0; i < n; i++) N[i].v = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v || N[i].flag) continue;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].v = true;\n\n\t\tstd::tr1::unordered_set<unsigned long> s;\n\t\tint size = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tsize++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->flag) s.insert(e->t - N);\n\t\t\t\telse if (!e->t->v) q.push(e->t), e->t->v = true;\n\t\t\t}\n\t\t}\n\n\t\tif (s.size() == 1) min++, cnt *= size;\n\t}\n\n\tif (!min) min = 2, cnt = n * (n - 1) / 2;\n}\n\nint main() {\n\tfor (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n\t\tn = 0;\n\t\twhile (m--) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tn = std::max(n, std::max(u, v));\n\t\t\tu--, v--;\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\ttarjan();\n\n\t\tint min;\n\t\tlong long cnt;\n\t\tsolve(min, cnt);\n\t\tprintf(\"Case %d: %d %lld\\n\", i, min, cnt);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].v = N[i].pushed = N[i].flag = false;\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].p = NULL;\n\t\t\tEdge *next;\n\t\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2012-mine.md","raw":"title: HNOI2012 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Tarjan\n  - \n  - \npermalink: hnoi2012-mine\ndate: 2016-09-08 07:52:00\n---\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2730](http://www.lydsy.com/JudgeOnline/problem.php?id=2730)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// if (v->flag) printf(\"!!!: %lu\\n\", v - N + 1);\n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n\ninline void solve(int &min, long long &cnt) {\n\tmin = 0, cnt = 1;\n\tfor (int i = 0; i < n; i++) N[i].v = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v || N[i].flag) continue;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].v = true;\n\n\t\tstd::tr1::unordered_set<unsigned long> s;\n\t\tint size = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tsize++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->flag) s.insert(e->t - N);\n\t\t\t\telse if (!e->t->v) q.push(e->t), e->t->v = true;\n\t\t\t}\n\t\t}\n\n\t\tif (s.size() == 1) min++, cnt *= size;\n\t}\n\n\tif (!min) min = 2, cnt = n * (n - 1) / 2;\n}\n\nint main() {\n\tfor (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n\t\tn = 0;\n\t\twhile (m--) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tn = std::max(n, std::max(u, v));\n\t\t\tu--, v--;\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\ttarjan();\n\n\t\tint min;\n\t\tlong long cnt;\n\t\tsolve(min, cnt);\n\t\tprintf(\"Case %d: %d %lld\\n\", i, min, cnt);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].v = N[i].pushed = N[i].flag = false;\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].p = NULL;\n\t\t\tEdge *next;\n\t\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","slug":"hnoi2012-mine","published":1,"updated":"2016-09-07T23:53:21.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rw500z1ooxleae4rpj2"},{"title":"HNOI2010 -  DP","date":"2016-07-06T04:08:00.000Z","_content":"\n\n\n1. \n2. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1996](http://www.lydsy.com/JudgeOnline/problem.php?id=1996)\n\n### \n\n\n $ [l, r] $  $ A $  $ A $  $ [l, r - 1] $  $ [l, r - 1] $  $ A $ \n\n $ f(l, r, flag) $  $ [l, r] $  $ flag $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MOD = 19650827;\n\nconst int DP_L = 0;\nconst int DP_R = 1;\nconst int DP_LR = 2;\n\nint n, a[MAXN];\n\ninline int dp(const int l, const int r, const int flag) {\n\tstatic int mem[MAXN][MAXN][3];\n\tstatic bool calced[MAXN][MAXN][3];\n\tint &ans = mem[l][r][flag];\n\tif (calced[l][r][flag]) return ans;\n\tcalced[l][r][flag] = true;\n\n\tif (r - l + 1 == 2) {\n\t\tif (a[l] > a[r]) return ans = 0;\n\t\telse if (flag == DP_LR) return ans = 2;\n\t\telse return ans = 1;\n\t}\n\n\tif (flag != DP_L) {\n\t\tconst int L = l, R = r - 1;\n\t\tif (a[r] > a[L] && a[r] > a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[r] > a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[r] > a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\tif (flag != DP_R) {\n\t\tconst int L = l + 1, R = r;\n\t\tif (a[l] < a[L] && a[l] < a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[l] < a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[l] < a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\treturn ans %= MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", dp(0, n - 1, DP_LR));\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2010-chorus.md","raw":"title: HNOI2010 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - DP\n  -  DP\npermalink: hnoi2010-chorus\ndate: 2016-07-06 12:08:00\n---\n\n\n\n1. \n2. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1996](http://www.lydsy.com/JudgeOnline/problem.php?id=1996)\n\n### \n\n\n $ [l, r] $  $ A $  $ A $  $ [l, r - 1] $  $ [l, r - 1] $  $ A $ \n\n $ f(l, r, flag) $  $ [l, r] $  $ flag $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MOD = 19650827;\n\nconst int DP_L = 0;\nconst int DP_R = 1;\nconst int DP_LR = 2;\n\nint n, a[MAXN];\n\ninline int dp(const int l, const int r, const int flag) {\n\tstatic int mem[MAXN][MAXN][3];\n\tstatic bool calced[MAXN][MAXN][3];\n\tint &ans = mem[l][r][flag];\n\tif (calced[l][r][flag]) return ans;\n\tcalced[l][r][flag] = true;\n\n\tif (r - l + 1 == 2) {\n\t\tif (a[l] > a[r]) return ans = 0;\n\t\telse if (flag == DP_LR) return ans = 2;\n\t\telse return ans = 1;\n\t}\n\n\tif (flag != DP_L) {\n\t\tconst int L = l, R = r - 1;\n\t\tif (a[r] > a[L] && a[r] > a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[r] > a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[r] > a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\tif (flag != DP_R) {\n\t\tconst int L = l + 1, R = r;\n\t\tif (a[l] < a[L] && a[l] < a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[l] < a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[l] < a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\treturn ans %= MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", dp(0, n - 1, DP_LR));\n\n\treturn 0;\n}\n```\n","slug":"hnoi2010-chorus","published":1,"updated":"2016-10-24T23:36:49.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rwc00z8ooxlcaf0w1yj"},{"title":"HNOI2008 - Prfer ","date":"2016-10-11T10:51:00.000Z","_content":"\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005)\n\n### \nPrufer \n\n>  $ n $  Prufer  $ n - 2 $ $ -1 $  Prufer \n\n $ k $ $ d_i $  $ i $ $ s = \\sum\\limits_{d_i \\neq -1} d_i - 1 $ $ s $ \n\n Prufer \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} $$\n\n $ n - k $  $ n - 2 - s $ \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} $$\n\n\n\n$$\n\\begin{aligned}\n&= \\frac{(n - 2)!}{s!(n - 2 - s)!} \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} \\\\\n&= \\frac{(n - 2)! (n - k) ^ {n - 2 - s}}{(n - 2 - s)! \\prod\\limits_{i = 1} ^ k (d_i - 1) !}\n\\end{aligned}\n$$\n\n### \n```java\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint d[] = new int[n], s = 0, k = 0;\n\t\tboolean invalid = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t\tif (d[i] != -1) {\n\t\t\t\tk++;\n\t\t\t\tif (d[i] <= 0 || d[i] >= n + 1) invalid = true;\n\t\t\t\ts += d[i] - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tif (d[0] == 0 || d[0] == -1) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (n == 2) {\n\t\t\tif ((d[0] == 1 || d[0] == -1) && (d[1] == 1 || d[1] == -1)) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (invalid) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tBigInteger fac[] = new BigInteger[n - 1];\n\t\t\tfac[0] = BigInteger.ONE;\n\t\t\tfor (int i = 1; i <= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i));\n\n\t\t\tBigInteger ans = BigInteger.ONE;\n\t\t\tans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]);\n\t\t\tfor (int i = 0; i < n; i++) if (d[i] > 1) ans = ans.divide(fac[d[i] - 1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n```\n","source":"_posts/hnoi2008-tree.md","raw":"title: HNOI2008 - Prfer \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Prfer \n  - \n  - \npermalink: hnoi2008-tree\ndate: 2016-10-11 18:51:00\n---\n\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005)\n\n### \nPrufer \n\n>  $ n $  Prufer  $ n - 2 $ $ -1 $  Prufer \n\n $ k $ $ d_i $  $ i $ $ s = \\sum\\limits_{d_i \\neq -1} d_i - 1 $ $ s $ \n\n Prufer \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} $$\n\n $ n - k $  $ n - 2 - s $ \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} $$\n\n\n\n$$\n\\begin{aligned}\n&= \\frac{(n - 2)!}{s!(n - 2 - s)!} \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} \\\\\n&= \\frac{(n - 2)! (n - k) ^ {n - 2 - s}}{(n - 2 - s)! \\prod\\limits_{i = 1} ^ k (d_i - 1) !}\n\\end{aligned}\n$$\n\n### \n```java\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint d[] = new int[n], s = 0, k = 0;\n\t\tboolean invalid = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t\tif (d[i] != -1) {\n\t\t\t\tk++;\n\t\t\t\tif (d[i] <= 0 || d[i] >= n + 1) invalid = true;\n\t\t\t\ts += d[i] - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tif (d[0] == 0 || d[0] == -1) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (n == 2) {\n\t\t\tif ((d[0] == 1 || d[0] == -1) && (d[1] == 1 || d[1] == -1)) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (invalid) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tBigInteger fac[] = new BigInteger[n - 1];\n\t\t\tfac[0] = BigInteger.ONE;\n\t\t\tfor (int i = 1; i <= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i));\n\n\t\t\tBigInteger ans = BigInteger.ONE;\n\t\t\tans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]);\n\t\t\tfor (int i = 0; i < n; i++) if (d[i] > 1) ans = ans.divide(fac[d[i] - 1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n```\n","slug":"hnoi2008-tree","published":1,"updated":"2016-10-17T03:06:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rwh00zeooxl94ccbys0"},{"title":"HNOI2008 -  DP","date":"2016-04-24T03:23:41.000Z","_content":"\nP  $ 1 $ ~ $ N $  $ N $  $ i $  $ C_i $P  $ i $  $ j $  $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $ $ x $ $ (x - L) ^ 2 $ $ L $ P \n $ L $\n\n<!-- more -->\n\n### \n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### \n $ f[i] $  i  $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $\n\n $ j $ $ j + 1 $ ~ $ i $  $ i - j - 1 + s(i) - s(j) $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n $ O(n ^ 2) $\n\n $ g(i) = s(i) + i - L - 1 $$ h(j) = s(j) + j $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n $ j = a $  $ j = b $$ a > b $ a  b \n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n $ O(1) $ $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2008-toy.md","raw":"title: HNOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - COGS\n  - HNOI\n  - \n  - \n  - DP\npermalink: hnoi2008-toy\ndate: 2016-04-24 11:23:41\n---\n\nP  $ 1 $ ~ $ N $  $ N $  $ i $  $ C_i $P  $ i $  $ j $  $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $ $ x $ $ (x - L) ^ 2 $ $ L $ P \n $ L $\n\n<!-- more -->\n\n### \n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### \n $ f[i] $  i  $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $\n\n $ j $ $ j + 1 $ ~ $ i $  $ i - j - 1 + s(i) - s(j) $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n $ O(n ^ 2) $\n\n $ g(i) = s(i) + i - L - 1 $$ h(j) = s(j) + j $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n $ j = a $  $ j = b $$ a > b $ a  b \n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n $ O(1) $ $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"hnoi2008-toy","published":1,"updated":"2016-10-24T23:36:27.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rwo00zmooxl4rjkgjx8"},{"title":"HNOI2008 - ","date":"2016-10-17T03:07:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006)\n\n### \nMCS********\n\n\n\n1. \n2.  $ +1 $\n3. \n4.  (2)\n\n $ O(n ^ 2 + m) $  $ O(n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <set>\n#include <list>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nstruct Node {\n\tstruct Edge *e;\n\tint d, color;\n\tbool visited;\n\tstd::list<Node *>::iterator iterator;\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, m;\n\ninline void mcs() {\n\tstatic std::list<Node *> lists[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tN[i].d = 0;\n\t\tN[i].visited = false;\n\t\tlists[0].push_front(&N[i]);\n\t\tN[i].iterator = lists[0].begin();\n\t}\n\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (lists[max].empty()) max--;\n\t\tNode *v = lists[max].front();\n\t\tlists[max].pop_front();\n\t\tseq[i] = v;\n\t\t// printf(\"%lu\\n\", seq[i] - N + 1);\n\t\tv->visited = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\tlists[e->t->d].erase(e->t->iterator);\n\t\t\t\te->t->d++;\n\t\t\t\tlists[e->t->d].push_front(e->t);\n\t\t\t\te->t->iterator = lists[e->t->d].begin();\n\t\t\t\tmax = std::max(max, e->t->d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tmcs();\n\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tstd::set<int> s;\n\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\tif (e->t->color) s.insert(e->t->color);\n\t\t}\n\t\ts.insert(INT_MAX);\n\n\t\tint last = 0;\n\t\tfor (std::set<int>::const_iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tif (last + 1 != *it) {\n\t\t\t\tseq[i]->color = last + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = *it;\n\t\t}\n\n\t\tans = std::max(ans, seq[i]->color);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-kingdom.md","raw":"title: HNOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - \npermalink: hnoi2008-kingdom\ndate: 2016-10-17 11:07:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006)\n\n### \nMCS********\n\n\n\n1. \n2.  $ +1 $\n3. \n4.  (2)\n\n $ O(n ^ 2 + m) $  $ O(n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <set>\n#include <list>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nstruct Node {\n\tstruct Edge *e;\n\tint d, color;\n\tbool visited;\n\tstd::list<Node *>::iterator iterator;\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, m;\n\ninline void mcs() {\n\tstatic std::list<Node *> lists[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tN[i].d = 0;\n\t\tN[i].visited = false;\n\t\tlists[0].push_front(&N[i]);\n\t\tN[i].iterator = lists[0].begin();\n\t}\n\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (lists[max].empty()) max--;\n\t\tNode *v = lists[max].front();\n\t\tlists[max].pop_front();\n\t\tseq[i] = v;\n\t\t// printf(\"%lu\\n\", seq[i] - N + 1);\n\t\tv->visited = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\tlists[e->t->d].erase(e->t->iterator);\n\t\t\t\te->t->d++;\n\t\t\t\tlists[e->t->d].push_front(e->t);\n\t\t\t\te->t->iterator = lists[e->t->d].begin();\n\t\t\t\tmax = std::max(max, e->t->d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tmcs();\n\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tstd::set<int> s;\n\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\tif (e->t->color) s.insert(e->t->color);\n\t\t}\n\t\ts.insert(INT_MAX);\n\n\t\tint last = 0;\n\t\tfor (std::set<int>::const_iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tif (last + 1 != *it) {\n\t\t\t\tseq[i]->color = last + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = *it;\n\t\t}\n\n\t\tans = std::max(ans, seq[i]->color);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"hnoi2008-kingdom","published":1,"updated":"2016-10-17T09:25:23.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rwu00zvooxlp3x9im32"},{"title":"HNOI2008GT - KMP + ","date":"2016-10-07T22:43:00.000Z","_content":"\n $ m $  $ T $ $ n $  $ T $ \n\n<!-- more -->\n\n### \n[BZOJ 1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009)\n\n### \n $ T $  KMP  $ f(i, j) $  $ i $  $ T $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e9;\nconst int MAXM = 20;\nconst int MAXK = 1000;\n\nstruct Matrix {\n\tint a[MAXM][MAXM];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i < MAXM; i++) a[i][i] = 1;\n\t\t}\n\t}\n\n\tint &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\n\tconst int &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\n\nint mod;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) for (int k = 0; k < MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tchar s[MAXM + 2];\n\tscanf(\"%d %d %d\\n%s\", &n, &m, &mod, s + 1);\n\n\tint fail[MAXM + 1];\n\tfail[0] = fail[1] = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\tint k = fail[i - 1];\n\t\twhile (k && s[k + 1] != s[i]) k = fail[k];\n\t\tif (s[k + 1] == s[i]) fail[i] = k + 1;\n\t\telse fail[i] = 0;\n\t}\n\n\t// for (int i = 0; i <= m; i++) printf(\"%d%c\", fail[i], i == m ? '\\n' : ' ');\n\n\t/*\n\tint f[50][MAXM + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\t\tint k = j;\n\t\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\t\tif (s[k + 1] == c) k++;\n\n\t\t\t\tf[i + 1][k] += f[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tint k = i;\n\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\tif (s[k + 1] == c) k++;\n\t\t\tif (k < m) shift(i, k)++;\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\tMatrix res = init * pow(shift, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res(0, i)) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\t// for (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) printf(\"%d%c\", res(i, j), j == MAXM - 1 ? '\\n' : ' ');\n\n\t/*\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\t*/\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-gt.md","raw":"title: HNOI2008GT - KMP + \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - DP\n  - KMP\n  - \n  - \n  - \npermalink: hnoi2008-gt\ndate: 2016-10-08 06:43:00\n---\n\n $ m $  $ T $ $ n $  $ T $ \n\n<!-- more -->\n\n### \n[BZOJ 1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009)\n\n### \n $ T $  KMP  $ f(i, j) $  $ i $  $ T $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e9;\nconst int MAXM = 20;\nconst int MAXK = 1000;\n\nstruct Matrix {\n\tint a[MAXM][MAXM];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i < MAXM; i++) a[i][i] = 1;\n\t\t}\n\t}\n\n\tint &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\n\tconst int &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\n\nint mod;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) for (int k = 0; k < MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tchar s[MAXM + 2];\n\tscanf(\"%d %d %d\\n%s\", &n, &m, &mod, s + 1);\n\n\tint fail[MAXM + 1];\n\tfail[0] = fail[1] = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\tint k = fail[i - 1];\n\t\twhile (k && s[k + 1] != s[i]) k = fail[k];\n\t\tif (s[k + 1] == s[i]) fail[i] = k + 1;\n\t\telse fail[i] = 0;\n\t}\n\n\t// for (int i = 0; i <= m; i++) printf(\"%d%c\", fail[i], i == m ? '\\n' : ' ');\n\n\t/*\n\tint f[50][MAXM + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\t\tint k = j;\n\t\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\t\tif (s[k + 1] == c) k++;\n\n\t\t\t\tf[i + 1][k] += f[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tint k = i;\n\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\tif (s[k + 1] == c) k++;\n\t\t\tif (k < m) shift(i, k)++;\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\tMatrix res = init * pow(shift, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res(0, i)) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\t// for (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) printf(\"%d%c\", res(i, j), j == MAXM - 1 ? '\\n' : ' ');\n\n\t/*\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\t*/\n\n\treturn 0;\n}\n```","slug":"hnoi2008-gt","published":1,"updated":"2016-10-07T22:52:45.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rx00103ooxl8nvl0ffh"},{"title":"HNOI2008Cards - Burnside ","date":"2016-10-17T02:57:00.000Z","_content":"\n $ n $ 3  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004)\n\n### \nBurnside   \n\n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXX = 20;\nconst int MAXN = 60;\nconst int MAXM = 60;\n\nint a, b, c, n, mod;\n\ninline int calc(const int *map) {\n\tbool flag[MAXM] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = 0;\n\t\tfor (int t = i; !flag[t]; t = map[t]) {\n\t\t\tflag[t] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAXX + 1][MAXX + 1][MAXX + 1];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"calc() = %d\\n\", f[a][b][c]);\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int x) {\n\tint tmp1, tmp2, res;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint map[MAXN];\n\t\tfor (int j = 0; j < n; j++) scanf(\"%d\", &map[j]), map[j]--;\n\t\t(sum += calc(map)) %= mod;\n\t}\n\n\tint map[MAXN];\n\tfor (int i = 0; i < n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-cards.md","raw":"title: HNOI2008Cards - Burnside \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Burnside \n  - \n  - \npermalink: hnoi2008-cards\ndate: 2016-10-17 10:57:00\n---\n\n $ n $ 3  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004)\n\n### \nBurnside   \n\n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXX = 20;\nconst int MAXN = 60;\nconst int MAXM = 60;\n\nint a, b, c, n, mod;\n\ninline int calc(const int *map) {\n\tbool flag[MAXM] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = 0;\n\t\tfor (int t = i; !flag[t]; t = map[t]) {\n\t\t\tflag[t] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAXX + 1][MAXX + 1][MAXX + 1];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"calc() = %d\\n\", f[a][b][c]);\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int x) {\n\tint tmp1, tmp2, res;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint map[MAXN];\n\t\tfor (int j = 0; j < n; j++) scanf(\"%d\", &map[j]), map[j]--;\n\t\t(sum += calc(map)) %= mod;\n\t}\n\n\tint map[MAXN];\n\tfor (int i = 0; i < n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"hnoi2008-cards","published":1,"updated":"2016-10-17T03:03:37.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rx6010cooxlj2093ofg"},{"title":"HNOI2004 - set","id":"5","updated":"2016-01-19T13:08:01.000Z","date":"2015-12-15T21:14:20.000Z","_content":"\n `N`<= 80000 `a`\n\n<!-- more -->\n\n### \n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### \n$O({\\log} n)$ STL  set\n\n set set  `lower_bound` ********\n\n### \n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2004-pet.md","raw":"title: HNOI2004 - set\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - HNOI\n  - set\n  - STL\npermalink: hnoi2004-pet\nid: 5\nupdated: '2016-01-19 21:08:01'\ndate: 2015-12-16 05:14:20\n---\n\n `N`<= 80000 `a`\n\n<!-- more -->\n\n### \n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### \n$O({\\log} n)$ STL  set\n\n set set  `lower_bound` ********\n\n### \n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"hnoi2004-pet","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rxd010kooxl8kwyqo81"},{"title":"HNOI2004L - Trie","date":"2016-09-12T23:40:00.000Z","_content":"\n $ T $  $ D $  $ T $  $ D $ \n\n $ D $ $ D $  $ D $ \n\n<!-- more -->\n\n### \n[BZOJ 1212](http://www.lydsy.com/JudgeOnline/problem.php?id=1212)\n\n### \n $ f_i $  $ i $  $ f_{i - 1} $  $ m $  $ i $  $ f_{i + m - 1} $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1024 * 1024;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAT = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE]; //, *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\t/*\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a';\n\t\tt.insert(s, s + len);\n\t}\n\n\t// t.build();\n\n\twhile (m--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tstatic bool _f[MAXN + 1], *f = _f + 1;\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a', f[i] = false;\n\t\tint ans = -1;\n\t\tf[-1] = true;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!f[i - 1]) continue;\n\t\t\tTrie::Node *v = t.root;\n\t\t\tfor (int j = i; j < len; j++) {\n\t\t\t\t// while (v != t.root && !v->c[s[j]]) v = v->fail;\n\t\t\t\tif (!v->c[s[j]]) break;\n\t\t\t\tv = v->c[s[j]];\n\t\t\t\tif (v->isWord) f[j] = true, ans = std::max(ans, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans + 1);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2004-language.md","raw":"title: HNOI2004L - Trie\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - Trie\npermalink: hnoi2004-language\ndate: 2016-09-13 07:40:00\n---\n\n $ T $  $ D $  $ T $  $ D $ \n\n $ D $ $ D $  $ D $ \n\n<!-- more -->\n\n### \n[BZOJ 1212](http://www.lydsy.com/JudgeOnline/problem.php?id=1212)\n\n### \n $ f_i $  $ i $  $ f_{i - 1} $  $ m $  $ i $  $ f_{i + m - 1} $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1024 * 1024;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAT = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE]; //, *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\t/*\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a';\n\t\tt.insert(s, s + len);\n\t}\n\n\t// t.build();\n\n\twhile (m--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tstatic bool _f[MAXN + 1], *f = _f + 1;\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a', f[i] = false;\n\t\tint ans = -1;\n\t\tf[-1] = true;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!f[i - 1]) continue;\n\t\t\tTrie::Node *v = t.root;\n\t\t\tfor (int j = i; j < len; j++) {\n\t\t\t\t// while (v != t.root && !v->c[s[j]]) v = v->fail;\n\t\t\t\tif (!v->c[s[j]]) break;\n\t\t\t\tv = v->c[s[j]];\n\t\t\t\tif (v->isWord) f[j] = true, ans = std::max(ans, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans + 1);\n\t}\n\n\treturn 0;\n}\n```","slug":"hnoi2004-language","published":1,"updated":"2016-09-12T23:45:11.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rxj010rooxlb78fqxbl"},{"title":"","date":"2017-01-01T15:30:00.000Z","_content":"\n\n\n![](here-the-best-sight/1.jpg)\n\n<!-- more -->\n\n\n\n\n\n\n\n![](here-the-best-sight/2.jpg)\n\n\n\n\n\n![](here-the-best-sight/3.jpg)\n","source":"_posts/here-the-best-sight.md","raw":"title: \ncategories: \n  - Diary\npermalink: here-the-best-sight\ndate: 2017-01-01 23:30:00\n---\n\n\n\n![](here-the-best-sight/1.jpg)\n\n<!-- more -->\n\n\n\n\n\n\n\n![](here-the-best-sight/2.jpg)\n\n\n\n\n\n![](here-the-best-sight/3.jpg)\n","slug":"here-the-best-sight","published":1,"updated":"2017-01-01T23:47:32.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rxo010xooxlim11g2sa"},{"title":"HEOI2013Eden  -  DP","date":"2016-07-11T15:10:00.000Z","_content":"\n $ n $  $ m $  $ m $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3163](http://www.lydsy.com/JudgeOnline/problem.php?id=3163)\n\n### \n $ f(i, j) $  $ i $ **** $ j $  $ g(i, j) $  $ i $ **** $ j $ \n\n $ a $  $ m $\n\n$$\n\\max\\limits_{i = 0} ^ {m} \\{ f(a - 1, i) + g(a + 1, m - i) \\}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\nconst int MAXLOGN = 10;\nconst int MAXQ = 300000;\n\nint main() {\n\tint n;\n\tstatic int w[MAXN], v[MAXN], cnt[MAXN];\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &w[i], &v[i], &cnt[i]);\n\n\tstatic std::pair<int, int> r[MAXN];\n\tstatic int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN];\n\tint N = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i].first = N + 1;\n\t\tfor (int j = 1; j <= cnt[i]; cnt[i] -= j, j *= 2) {\n\t\t// for (int j = 1; cnt[i]; cnt[i]--) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * j;\n\t\t\tV[N] = v[i] * j;\n\t\t}\n\t\tif (cnt[i]) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * cnt[i];\n\t\t\tV[N] = v[i] * cnt[i];\n\t\t}\n\t\tr[i].second = N;\n\t}\n\n\tstatic int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1];\n\t// for (int i = 0; i <= N; i++) f[i][0] = 1;\n\t// for (int i = 1; i <= N + 1; i++) g[i][0] = 1;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) g[i][j] = g[i + 1][j];\n\t\t\telse g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint id, m;\n\t\tscanf(\"%d %d\", &id, &m);\n\n\t\tint ans = 0, a = r[id].first - 1, b = r[id].second + 1;\n\t\tfor (int j = 0; j <= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/heoi2013-bag.md","raw":"title: HEOI2013Eden  -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HEOI\n  - DP\n  -  DP\npermalink: heoi2013-bag\ndate: 2016-07-11 23:10:00\n---\n\n $ n $  $ m $  $ m $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3163](http://www.lydsy.com/JudgeOnline/problem.php?id=3163)\n\n### \n $ f(i, j) $  $ i $ **** $ j $  $ g(i, j) $  $ i $ **** $ j $ \n\n $ a $  $ m $\n\n$$\n\\max\\limits_{i = 0} ^ {m} \\{ f(a - 1, i) + g(a + 1, m - i) \\}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\nconst int MAXLOGN = 10;\nconst int MAXQ = 300000;\n\nint main() {\n\tint n;\n\tstatic int w[MAXN], v[MAXN], cnt[MAXN];\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &w[i], &v[i], &cnt[i]);\n\n\tstatic std::pair<int, int> r[MAXN];\n\tstatic int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN];\n\tint N = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i].first = N + 1;\n\t\tfor (int j = 1; j <= cnt[i]; cnt[i] -= j, j *= 2) {\n\t\t// for (int j = 1; cnt[i]; cnt[i]--) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * j;\n\t\t\tV[N] = v[i] * j;\n\t\t}\n\t\tif (cnt[i]) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * cnt[i];\n\t\t\tV[N] = v[i] * cnt[i];\n\t\t}\n\t\tr[i].second = N;\n\t}\n\n\tstatic int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1];\n\t// for (int i = 0; i <= N; i++) f[i][0] = 1;\n\t// for (int i = 1; i <= N + 1; i++) g[i][0] = 1;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) g[i][j] = g[i + 1][j];\n\t\t\telse g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint id, m;\n\t\tscanf(\"%d %d\", &id, &m);\n\n\t\tint ans = 0, a = r[id].first - 1, b = r[id].second + 1;\n\t\tfor (int j = 0; j <= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"heoi2013-bag","published":1,"updated":"2016-10-24T23:36:40.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rxv010zooxl992znn8t"},{"title":"HDU 5906Square Revolution -  +  + ","date":"2016-09-30T10:00:00.000Z","_content":"\n $ S $ prefix-suffix-square free \n\n square `abab``aa`  square `aaa``abba`  prefix-suffix-square free  square\n\n<!-- more -->\n\n### \n[HDU 5906](http://acm.hdu.edu.cn/showproblem.php?pid=5906)\n\n### \n square $ i $  $ i $  square  $ f(i) $ $ i $  $ g(i) $ $ i $ $ j \\in [i, i + f(i) - 2] $  $ i \\geq g(j) $  $ j $ \n\n squareNOI2016  $ k $ $ k $  $ 2k $  square  $ [l, r] $ square $ [L, R] $  $ 2k $  square $ 2k $  $ f(i), i \\in[L, R] $\n\n $ k $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\tinline void build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tinline int rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n\n\tinline int lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint n, forward[MAXN], backward[MAXN];\n\ninline int lcp(const int i, const int j) { return sa1.lcp(i, j); }\ninline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); }\n\ninline void prepare(const int n) {\n\t/*\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int l, const int r, const int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) this->val = std::min(this->val, x);\n\t\t\telse lc->update(l, r, x), rc->update(l, r, x);\n\t\t}\n\n\t\tint query(const int pos) {\n\t\t\treturn (l == r) ? val : std::min(val, ((pos <= mid) ? lc : rc)->query(pos));\n\t\t}\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t\t}\n\t\t}\n\t} *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1);\n\t*/\n\n\tstatic struct UnionFindSet {\n\t\tint a[MAXN], n;\n\n\t\tvoid init(const int n) {\n\t\t\tthis->n = n;\n\t\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t\t}\n\n\t\tint find(const int x) {\n\t\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t\t}\n\n\t\tvoid merge(const int child, const int parent) {\n#ifdef DBG\n\t\t\tprintf(\"merge: %d => %d\\n\", child, parent);\n#endif\n\t\t\tconst int _child = find(child), _parent = find(parent);\n\t\t\ta[_child] = _parent;\n\t\t}\n\n\t\tvoid cover(const int l, const int r, const int x, int *val) {\n#ifdef DBG\n\t\t\tprintf(\"cover(%d, %d, %d)\\n\", l, r, x);\n#endif\n\t\t\tfor (int i = find(l); i <= r; i = find(i + 1)) {\n\t\t\t\tval[i] = std::min(val[i], x);\n\t\t\t\tif (i != n - 1) merge(i, i + 1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t} sForawrd, sBackward;\n\n\tsForawrd.init(n);\n\tsBackward.init(n);\n\n\tfor (int i = 0; i < n; i++) forward[i] = backward[i] = INT_MAX;\n\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i + len < n; i += len) {\n\t\t\tconst int j = i + len;\n\t\t\tconst int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1;\n\t\t\t// const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1;\n#ifdef DBG\n\t\t\tprintf(\"s = %d, len = %d\\n\", s, len);\n#endif\n\t\t\tif (s >= len) {\n#ifdef DBG\n\t\t\t\tprintf(\"!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\\n\", i, j, a, b, len);\n#endif\n\t\t\t\tconst int l = i - a + 1, r = j + b - 1;\n\t\t\t\tsForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward);\n\t\t\t\tsBackward.cover(l + len * 2 - 1, r, len * 2, backward);\n\t\t\t\t// sForawrd->update(l, l + (r - (l + len * 2 - 1)), len * 2);\n\t\t\t\t// sBackward->update(l + len * 2 - 1, r, len * 2);\n\t\t\t\t/*\n\t\t\t\tfor (int i = l + len * 2 - 1; i <= r; i++) {\n\t\t\t\t\tprintf(\"[%d, %d]\\n\", i - len * 2 + 1, i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) forward[i] = sForawrd->query(i);\n\t// for (int i = 0; i < n; i++) backward[i] = sBackward->query(i);\n\n#ifdef DBG\n\tputs(\"forward / backward\");\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\n/*\nstruct ChairmanTree {\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint cnt, refCnt;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc && lc->unRef()) delete lc;\n\t\t\tif (rc && rc->unRef()) delete rc;\n\t\t}\n\n\t\tSegmentTree *ref() {\n\t\t\trefCnt++;\n\t\t\treturn this;\n\t\t}\n\n\t\tbool unRef() {\n\t\t\treturn !refCnt--;\n\t\t}\n\n\t\tint query(const int l, const int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\t\telse return (lc ? lc->query(l, r) : 0) + (rc ? rc->query(l, r) : 0);\n\t\t}\n\n\t\tSegmentTree *insertSelf(const int x) {\n\t\t\tif (l == r) return this;\n\t\t\tif (x <= mid) {\n\t\t\t\tthis->lc = (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x);\n\t\t\t} else {\n\t\t\t\tthis->rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tSegmentTree *insert(const int x) {\n\t\t\tif (x <= mid) {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\t\t} else {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x), cnt + 1);\n\t\t\t}\n\t\t}\n\n\t\tint lcount() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n, l, r;\n\n\tvoid clear() {\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tdelete root[i];\n\t\t}\n\t}\n\n\t// Build tree with array a, whose elements are limited in [l, r]\n\tvoid build(const int *a, const int n, const int l, const int r) {\n\t\tthis->n = n, this->l = l, this->r = r;\n\t\troot[0] = new SegmentTree(0, n, NULL, NULL, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, const int x) {\n\t\t// Adjust input [0, n - 1] to [1, n]\n\t\tSegmentTree *vr = root[r + 1], *vl = root[l];\n\t\tint ans = vr->query(this->l, x);\n\t\tif (vl) ans -= vl->query(this->l, x);\n\t\treturn ans;\n\n\t\t/ *\n\t\twhile (min != max) {\n\t\t\tconst int mid = mid + (max - min) / 2, t = vr->lcount() - (vl ? vl->lcount() : 0);\n\t\t\tif (t < k) {\n\t\t\t\tk -= t, vr = vr->rc;\n\t\t\t\tif (vl) vl = vl->rc;\n\t\t\t} else {\n\t\t\t\tvr = vr->lc;\n\t\t\t\tif (vl) vl = vl->lc;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t\t* /\n\t}\n} t;\n*/\n\ninline unsigned long long solve(const int *limit, const int *forward, const int n) {\n\tstatic struct Query {\n\t\tint type;\n\t\tint pos, val;\n\n\t\tbool operator<(const Query &other) const {\n\t\t\tif (pos < other.pos) return true;\n\t\t\telse if (pos == other.pos && !type && other.type) return true;\n\t\t\telse return false;\n\t\t}\n\t} Q[MAXN * 3];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[i].pos = i;\n\t\tQ[i].type = 0;\n\t\tQ[i].val = limit[i];\n\n#ifdef DBG\n\t\tprintf(\"add(pos = %d, val = %d)\\n\", Q[i].pos, Q[i].val);\n#endif\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[n + i].pos = i - 1;\n\t\tQ[n + i].val = i;\n\t\tQ[n + i].type = -1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i].pos, Q[n + i].val, Q[n + i].type);\n#endif\n\n\t\tQ[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1);\n\t\tQ[n + i + n].val = i;\n\t\tQ[n + i + n].type = 1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type);\n#endif\n\t}\n\n\tstd::sort(Q, Q + n * 3);\n\n\tstatic struct BinaryIndexedTree {\n\t\tint a[MAXN], n;\n\n\t\tstatic int lowbit(const int x) {\n\t\t\treturn x & -x;\n\t\t}\n\n\t\tvoid update(const int x, const int delta) {\n\t\t\t/*\n\t\t\ta[x - 1] += delta;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t\t}\n\n\t\tint query(const int x) {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t\t/*\n\t\t\tfor (int i = 1; i <= x; i++) ans += a[i - 1];\n\t\t\t*/\n\t\t\treturn ans;\n\t\t}\n\n\t\tvoid clear(const int x) {\n\t\t\t/*\n\t\t\ta[x - 1] = 0;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\t\tif (!a[i - 1]) break;\n\t\t\t\ta[i - 1] = 0;\n\t\t\t}\n\t\t}\n\t} bit;\n\n\tbit.n = n;\n\n\tunsigned long long ans = 0;\n\tfor (int i = 0; i < n * 3; i++) {\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].type, Q[i].pos, Q[i].val);\n#endif\n\t\tif (Q[i].type) {\n\t\t\tint t = bit.query(Q[i].val + 1) * Q[i].type;\n\t\t\tans += t;\n#ifdef DBG\n\t\t\tprintf(\"t = %d\\n\", t);\n#endif\n\t\t} else bit.update(Q[i].val + 1, 1);\n\t\t/*\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].l, Q[i].r, Q[i].val);\n#endif\n\t\tif (Q[i].l == -1) bit.update(Q[i].val + 1, 1);\n\t\telse ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l);\n#ifdef DBG\n\t\tprintf(\"ans = %d\\n\", ans);\n#endif\n\t\t*/\n\t}\n\n\tfor (int i = 0; i < n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1);\n\n\treturn ans;\n}\n\nint main() {\n\tint testcase;\n\tscanf(\"%d\", &testcase);\n\n\twhile (testcase--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsa1.build(s, n);\n\t\tstd::reverse(s, s + n);\n\t\tsa2.build(s, n);\n\n\t\tprepare(n);\n\t\tstatic int limit[MAXN];\n\t\tfor (int i = 0; i < n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2);\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", limit[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\n\t\t// t.clear();\n\t\t// t.build(limit, n, 0, n - 1);\n\n\t\t/*\n\t\tunsigned long long ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i);\n\t\t}\n\t\t*/\n\n\t\tunsigned long long ans = solve(limit, forward, n);\n\t\tprintf(\"%llu\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/hdu-5906.md","raw":"title: HDU 5906Square Revolution -  +  + \ncategories: OI\ntags: \n  - HDU\n  - Bestcoder\n  - \n  - \n  - \n  - \n  - \npermalink: hdu-5906\ndate: 2016-09-30 18:00:00\n---\n\n $ S $ prefix-suffix-square free \n\n square `abab``aa`  square `aaa``abba`  prefix-suffix-square free  square\n\n<!-- more -->\n\n### \n[HDU 5906](http://acm.hdu.edu.cn/showproblem.php?pid=5906)\n\n### \n square $ i $  $ i $  square  $ f(i) $ $ i $  $ g(i) $ $ i $ $ j \\in [i, i + f(i) - 2] $  $ i \\geq g(j) $  $ j $ \n\n squareNOI2016  $ k $ $ k $  $ 2k $  square  $ [l, r] $ square $ [L, R] $  $ 2k $  square $ 2k $  $ f(i), i \\in[L, R] $\n\n $ k $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\tinline void build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tinline int rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n\n\tinline int lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint n, forward[MAXN], backward[MAXN];\n\ninline int lcp(const int i, const int j) { return sa1.lcp(i, j); }\ninline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); }\n\ninline void prepare(const int n) {\n\t/*\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int l, const int r, const int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) this->val = std::min(this->val, x);\n\t\t\telse lc->update(l, r, x), rc->update(l, r, x);\n\t\t}\n\n\t\tint query(const int pos) {\n\t\t\treturn (l == r) ? val : std::min(val, ((pos <= mid) ? lc : rc)->query(pos));\n\t\t}\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t\t}\n\t\t}\n\t} *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1);\n\t*/\n\n\tstatic struct UnionFindSet {\n\t\tint a[MAXN], n;\n\n\t\tvoid init(const int n) {\n\t\t\tthis->n = n;\n\t\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t\t}\n\n\t\tint find(const int x) {\n\t\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t\t}\n\n\t\tvoid merge(const int child, const int parent) {\n#ifdef DBG\n\t\t\tprintf(\"merge: %d => %d\\n\", child, parent);\n#endif\n\t\t\tconst int _child = find(child), _parent = find(parent);\n\t\t\ta[_child] = _parent;\n\t\t}\n\n\t\tvoid cover(const int l, const int r, const int x, int *val) {\n#ifdef DBG\n\t\t\tprintf(\"cover(%d, %d, %d)\\n\", l, r, x);\n#endif\n\t\t\tfor (int i = find(l); i <= r; i = find(i + 1)) {\n\t\t\t\tval[i] = std::min(val[i], x);\n\t\t\t\tif (i != n - 1) merge(i, i + 1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t} sForawrd, sBackward;\n\n\tsForawrd.init(n);\n\tsBackward.init(n);\n\n\tfor (int i = 0; i < n; i++) forward[i] = backward[i] = INT_MAX;\n\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i + len < n; i += len) {\n\t\t\tconst int j = i + len;\n\t\t\tconst int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1;\n\t\t\t// const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1;\n#ifdef DBG\n\t\t\tprintf(\"s = %d, len = %d\\n\", s, len);\n#endif\n\t\t\tif (s >= len) {\n#ifdef DBG\n\t\t\t\tprintf(\"!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\\n\", i, j, a, b, len);\n#endif\n\t\t\t\tconst int l = i - a + 1, r = j + b - 1;\n\t\t\t\tsForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward);\n\t\t\t\tsBackward.cover(l + len * 2 - 1, r, len * 2, backward);\n\t\t\t\t// sForawrd->update(l, l + (r - (l + len * 2 - 1)), len * 2);\n\t\t\t\t// sBackward->update(l + len * 2 - 1, r, len * 2);\n\t\t\t\t/*\n\t\t\t\tfor (int i = l + len * 2 - 1; i <= r; i++) {\n\t\t\t\t\tprintf(\"[%d, %d]\\n\", i - len * 2 + 1, i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) forward[i] = sForawrd->query(i);\n\t// for (int i = 0; i < n; i++) backward[i] = sBackward->query(i);\n\n#ifdef DBG\n\tputs(\"forward / backward\");\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\n/*\nstruct ChairmanTree {\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint cnt, refCnt;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc && lc->unRef()) delete lc;\n\t\t\tif (rc && rc->unRef()) delete rc;\n\t\t}\n\n\t\tSegmentTree *ref() {\n\t\t\trefCnt++;\n\t\t\treturn this;\n\t\t}\n\n\t\tbool unRef() {\n\t\t\treturn !refCnt--;\n\t\t}\n\n\t\tint query(const int l, const int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\t\telse return (lc ? lc->query(l, r) : 0) + (rc ? rc->query(l, r) : 0);\n\t\t}\n\n\t\tSegmentTree *insertSelf(const int x) {\n\t\t\tif (l == r) return this;\n\t\t\tif (x <= mid) {\n\t\t\t\tthis->lc = (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x);\n\t\t\t} else {\n\t\t\t\tthis->rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tSegmentTree *insert(const int x) {\n\t\t\tif (x <= mid) {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\t\t} else {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x), cnt + 1);\n\t\t\t}\n\t\t}\n\n\t\tint lcount() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n, l, r;\n\n\tvoid clear() {\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tdelete root[i];\n\t\t}\n\t}\n\n\t// Build tree with array a, whose elements are limited in [l, r]\n\tvoid build(const int *a, const int n, const int l, const int r) {\n\t\tthis->n = n, this->l = l, this->r = r;\n\t\troot[0] = new SegmentTree(0, n, NULL, NULL, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, const int x) {\n\t\t// Adjust input [0, n - 1] to [1, n]\n\t\tSegmentTree *vr = root[r + 1], *vl = root[l];\n\t\tint ans = vr->query(this->l, x);\n\t\tif (vl) ans -= vl->query(this->l, x);\n\t\treturn ans;\n\n\t\t/ *\n\t\twhile (min != max) {\n\t\t\tconst int mid = mid + (max - min) / 2, t = vr->lcount() - (vl ? vl->lcount() : 0);\n\t\t\tif (t < k) {\n\t\t\t\tk -= t, vr = vr->rc;\n\t\t\t\tif (vl) vl = vl->rc;\n\t\t\t} else {\n\t\t\t\tvr = vr->lc;\n\t\t\t\tif (vl) vl = vl->lc;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t\t* /\n\t}\n} t;\n*/\n\ninline unsigned long long solve(const int *limit, const int *forward, const int n) {\n\tstatic struct Query {\n\t\tint type;\n\t\tint pos, val;\n\n\t\tbool operator<(const Query &other) const {\n\t\t\tif (pos < other.pos) return true;\n\t\t\telse if (pos == other.pos && !type && other.type) return true;\n\t\t\telse return false;\n\t\t}\n\t} Q[MAXN * 3];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[i].pos = i;\n\t\tQ[i].type = 0;\n\t\tQ[i].val = limit[i];\n\n#ifdef DBG\n\t\tprintf(\"add(pos = %d, val = %d)\\n\", Q[i].pos, Q[i].val);\n#endif\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[n + i].pos = i - 1;\n\t\tQ[n + i].val = i;\n\t\tQ[n + i].type = -1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i].pos, Q[n + i].val, Q[n + i].type);\n#endif\n\n\t\tQ[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1);\n\t\tQ[n + i + n].val = i;\n\t\tQ[n + i + n].type = 1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type);\n#endif\n\t}\n\n\tstd::sort(Q, Q + n * 3);\n\n\tstatic struct BinaryIndexedTree {\n\t\tint a[MAXN], n;\n\n\t\tstatic int lowbit(const int x) {\n\t\t\treturn x & -x;\n\t\t}\n\n\t\tvoid update(const int x, const int delta) {\n\t\t\t/*\n\t\t\ta[x - 1] += delta;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t\t}\n\n\t\tint query(const int x) {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t\t/*\n\t\t\tfor (int i = 1; i <= x; i++) ans += a[i - 1];\n\t\t\t*/\n\t\t\treturn ans;\n\t\t}\n\n\t\tvoid clear(const int x) {\n\t\t\t/*\n\t\t\ta[x - 1] = 0;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\t\tif (!a[i - 1]) break;\n\t\t\t\ta[i - 1] = 0;\n\t\t\t}\n\t\t}\n\t} bit;\n\n\tbit.n = n;\n\n\tunsigned long long ans = 0;\n\tfor (int i = 0; i < n * 3; i++) {\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].type, Q[i].pos, Q[i].val);\n#endif\n\t\tif (Q[i].type) {\n\t\t\tint t = bit.query(Q[i].val + 1) * Q[i].type;\n\t\t\tans += t;\n#ifdef DBG\n\t\t\tprintf(\"t = %d\\n\", t);\n#endif\n\t\t} else bit.update(Q[i].val + 1, 1);\n\t\t/*\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].l, Q[i].r, Q[i].val);\n#endif\n\t\tif (Q[i].l == -1) bit.update(Q[i].val + 1, 1);\n\t\telse ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l);\n#ifdef DBG\n\t\tprintf(\"ans = %d\\n\", ans);\n#endif\n\t\t*/\n\t}\n\n\tfor (int i = 0; i < n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1);\n\n\treturn ans;\n}\n\nint main() {\n\tint testcase;\n\tscanf(\"%d\", &testcase);\n\n\twhile (testcase--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsa1.build(s, n);\n\t\tstd::reverse(s, s + n);\n\t\tsa2.build(s, n);\n\n\t\tprepare(n);\n\t\tstatic int limit[MAXN];\n\t\tfor (int i = 0; i < n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2);\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", limit[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\n\t\t// t.clear();\n\t\t// t.build(limit, n, 0, n - 1);\n\n\t\t/*\n\t\tunsigned long long ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i);\n\t\t}\n\t\t*/\n\n\t\tunsigned long long ans = solve(limit, forward, n);\n\t\tprintf(\"%llu\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"hdu-5906","published":1,"updated":"2016-09-30T10:00:52.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ry00116ooxl48j4l9aq"},{"title":"HDU 5462King's Order -  DP","date":"2016-05-11T23:47:00.000Z","_content":"\n-- $ 3 $ . ---- \n\n $ n $ $ n $ \n\n<!-- more -->\n\n### \n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### \n DP\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n $ n $  $ lastChar $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5642.md","raw":"title: HDU 5462King's Order -  DP\ncategories: OI\ntags: \n  - HDU\n  - BestCoder\n  -  DP\n  - DP\npermalink: hdu-5642\ndate: 2016-05-12 07:47:00\n---\n\n-- $ 3 $ . ---- \n\n $ n $ $ n $ \n\n<!-- more -->\n\n### \n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### \n DP\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n $ n $  $ lastChar $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5642","published":1,"updated":"2016-10-24T23:36:12.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ry8011hooxlyt6940cs"},{"title":"HDU 632Rikka with Array -  DP","date":"2016-05-12T14:11:00.000Z","_content":"\n $ A(x) $  $ x $  $ 1 $  $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $  $ [i, j] $ \n\n<!-- more -->\n\n### \n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### \n DP\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n $ n $ $ j - i $ $ gap $ $ i \\lt j $  $ i = j $$ i $$ j $ \n\n $ i $$ j $  $ 0 $  $ 1 $ \n\n $ i \\gt j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5632.md","raw":"title: HDU 632Rikka with Array -  DP\ncategories: OI\ntags: \n  - HDU\n  -  DP\n  - DP\npermalink: hdu-5632\ndate: 2016-05-12 22:11:00\n---\n\n $ A(x) $  $ x $  $ 1 $  $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $  $ [i, j] $ \n\n<!-- more -->\n\n### \n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### \n DP\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n $ n $ $ j - i $ $ gap $ $ i \\lt j $  $ i = j $$ i $$ j $ \n\n $ i $$ j $  $ 0 $  $ 1 $ \n\n $ i \\gt j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5632","published":1,"updated":"2016-10-24T23:36:02.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rye011oooxljwdrbzgj"},{"title":"HDU 2089 62 -  DP","date":"2016-05-12T03:56:00.000Z","_content":"\n $ 4 $  $ 62 $ $ 62315,\\ 73418,\\ 88914 $ $ 61152 $  $ 6 $  $ 2 $ $ 62 $ \n\n\n\n<!-- more -->\n\n### \n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### \n DP\n\n$$ f[n][last][flag] $$\n\n $ n $  $ n $  $ last $\n\n $ n $  $ 4 $ $ 62 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-2089.md","raw":"title: HDU 2089 62 -  DP\ncategories: OI\ntags: \n  - HDU\n  -  DP\n  - DP\npermalink: hdu-2089\ndate: 2016-05-12 11:56:00\n---\n\n $ 4 $  $ 62 $ $ 62315,\\ 73418,\\ 88914 $ $ 61152 $  $ 6 $  $ 2 $ $ 62 $ \n\n\n\n<!-- more -->\n\n### \n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### \n DP\n\n$$ f[n][last][flag] $$\n\n $ n $  $ n $  $ last $\n\n $ n $  $ 4 $ $ 62 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-2089","published":1,"updated":"2016-10-24T23:35:53.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ryj011tooxlqxng4x0m"},{"title":"HAOI2016 -  + DP","date":"2016-04-28T14:20:45.000Z","_content":"\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### \n****\n\n DP \n\n****\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/haoi2016-chain.md","raw":"title: HAOI2016 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - \n  - DP\npermalink: haoi2016-chain\ndate: 2016-04-28 22:20:45\n---\n\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### \n****\n\n DP \n\n****\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"haoi2016-chain","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ryn011yooxl4lnh3tww"},{"title":"HAOI2015 -  + DFS","date":"2016-04-03T14:32:45.000Z","_content":"\n $ N $  $ 1 $  $ M $ \n\n1.  $ x $  $ a $\n2.  $ x $  $ a $\n3.  $ x $ \n\n<!-- more -->\n\n### \n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### \n + DFS  `long long` \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2015-t2.md","raw":"title: HAOI2015 -  + DFS\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - \n  - DFS \npermalink: haoi2015-t2\ndate: 2016-04-03 22:32:45\n---\n\n $ N $  $ 1 $  $ M $ \n\n1.  $ x $  $ a $\n2.  $ x $  $ a $\n3.  $ x $ \n\n<!-- more -->\n\n### \n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### \n + DFS  `long long` \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2015-t2","published":1,"updated":"2016-09-10T09:44:45.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ryt0126ooxlyqbk9q9y"},{"title":"HAOI2011Problem b - ","date":"2016-04-08T03:32:33.000Z","_content":"\n $ n $  $ (x, y) $ $ a \\leq x \\leq b $$ c \\leq y \\leq d $ $ \\gcd(x, y) = k $$ \\gcd(x, y) $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### \n\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n $ F $ \n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n $ F(n, m, k) $ \n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n\n\n $ \\frac{n}{k} $  $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n $ F' $  $ \\mu(T) $  $ O(\\sqrt{n}) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2011-problemb.md","raw":"title: HAOI2011Problem b - \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - \n  - \n  - \n  - \npermalink: haoi2011-problemb\ndate: 2016-04-08 11:32:33\n---\n\n $ n $  $ (x, y) $ $ a \\leq x \\leq b $$ c \\leq y \\leq d $ $ \\gcd(x, y) = k $$ \\gcd(x, y) $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### \n\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n $ F $ \n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n $ F(n, m, k) $ \n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n\n\n $ \\frac{n}{k} $  $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n $ F' $  $ \\mu(T) $  $ O(\\sqrt{n}) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2011-problemb","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ryz012dooxlzzp4ojvx"},{"title":"HAOI2008 -  + DP","date":"2016-11-13T03:31:00.000Z","_content":"\n $ n $  $ i $  $ L_i $$ n $  $ n - 1 $  $ m $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1044](http://www.lydsy.com/JudgeOnline/problem.php?id=1044)\n\n### \n $ t $\n\n $ f(i, j) $  $ i $  $ j $  $ t $ \n\n $ s(i) $  $ i $ \n\n$$ f(i, j) = \\sum\\limits_{s(i) - s(k - 1) \\leq t} f(k - 1, j - 1)  $$\n\n $ k $  $ i $  $ j $ $ k $ \n\n $ f(i, j - 1) $  $ i $  $ k $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 1000;\nconst int MO = 10007;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\n\ninline bool check(int limit) {\n\tint k = m, s = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s + a[i] > limit) k--, s = a[i];\n\t\telse s += a[i];\n\t}\n\treturn k >= 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m), m++;\n\n\tint max = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), max = std::max(max, a[i]);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n\tint l = max, r = s[n];\n\twhile (r - l >= 5) {\n\t\tint mid = l + (r - l) / 2;\n\t\t// printf(\"[%d, %d, %d]\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tint ans;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (check(i)) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d \", ans);\n\n\tint tot = 0;\n\tstatic int f[MAXN + 1][2];\n\tfor (int i = 1; i <= n; i++) f[i][1] = s[i] <= ans ? 1 : 0;\n\tfor (int j = 2; j <= m; j++) {\n\t\tfor (int i = 1; i <= n; i++) (f[i][(j - 1) & 1] += f[i - 1][(j - 1) & 1]) %= MO;\n\t\tfor (int i = 1, k = j; i <= n; i++) {\n\t\t\tf[i][j & 1] = 0;\n\t\t\twhile (k <= i && s[i] - s[k - 1] > ans) k++;\n\t\t\tif (k <= i && s[i] - s[k - 1] <= ans) {\n\t\t\t\t// printf(\"f(%d, %d) += f([%d, %d], %d)\\n\", i, j, i - 1, k - 1, j - 1);\n\t\t\t\t(f[i][j & 1] += f[i - 1][(j - 1) & 1] - f[k - 2][(j - 1) & 1]) %= MO;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = j; k <= i; k++) {\n\t\t\t\tif (s[i] - s[k - 1] <= ans) {\n\t\t\t\t\tf[i][j] += f[k - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\t\t\t// f[i][j] += f[i - 1][j];\n\t\t}\n\t\t(tot += f[n][j & 1]) %= MO;\n\t}\n\n\t// for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\tprintf(\"%d\\n\", (tot + MO) % MO);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-stick.md","raw":"title: HAOI2008 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - DP\npermalink: haoi2008-stick\ndate: 2016-11-13 11:31:00\n---\n\n $ n $  $ i $  $ L_i $$ n $  $ n - 1 $  $ m $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1044](http://www.lydsy.com/JudgeOnline/problem.php?id=1044)\n\n### \n $ t $\n\n $ f(i, j) $  $ i $  $ j $  $ t $ \n\n $ s(i) $  $ i $ \n\n$$ f(i, j) = \\sum\\limits_{s(i) - s(k - 1) \\leq t} f(k - 1, j - 1)  $$\n\n $ k $  $ i $  $ j $ $ k $ \n\n $ f(i, j - 1) $  $ i $  $ k $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 1000;\nconst int MO = 10007;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\n\ninline bool check(int limit) {\n\tint k = m, s = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s + a[i] > limit) k--, s = a[i];\n\t\telse s += a[i];\n\t}\n\treturn k >= 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m), m++;\n\n\tint max = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), max = std::max(max, a[i]);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n\tint l = max, r = s[n];\n\twhile (r - l >= 5) {\n\t\tint mid = l + (r - l) / 2;\n\t\t// printf(\"[%d, %d, %d]\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tint ans;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (check(i)) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d \", ans);\n\n\tint tot = 0;\n\tstatic int f[MAXN + 1][2];\n\tfor (int i = 1; i <= n; i++) f[i][1] = s[i] <= ans ? 1 : 0;\n\tfor (int j = 2; j <= m; j++) {\n\t\tfor (int i = 1; i <= n; i++) (f[i][(j - 1) & 1] += f[i - 1][(j - 1) & 1]) %= MO;\n\t\tfor (int i = 1, k = j; i <= n; i++) {\n\t\t\tf[i][j & 1] = 0;\n\t\t\twhile (k <= i && s[i] - s[k - 1] > ans) k++;\n\t\t\tif (k <= i && s[i] - s[k - 1] <= ans) {\n\t\t\t\t// printf(\"f(%d, %d) += f([%d, %d], %d)\\n\", i, j, i - 1, k - 1, j - 1);\n\t\t\t\t(f[i][j & 1] += f[i - 1][(j - 1) & 1] - f[k - 2][(j - 1) & 1]) %= MO;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = j; k <= i; k++) {\n\t\t\t\tif (s[i] - s[k - 1] <= ans) {\n\t\t\t\t\tf[i][j] += f[k - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\t\t\t// f[i][j] += f[i - 1][j];\n\t\t}\n\t\t(tot += f[n][j & 1]) %= MO;\n\t}\n\n\t// for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\tprintf(\"%d\\n\", (tot + MO) % MO);\n\n\treturn 0;\n}\n```","slug":"haoi2008-stick","published":1,"updated":"2016-11-13T03:31:51.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rz7012nooxlpm9o4mdc"},{"title":"HAOI2008 - map + Splay","date":"2016-12-13T09:08:00.000Z","_content":"\n $ 10 $ \n\n<!-- more -->\n\n### \n[BZOJ 1056](http://www.lydsy.com/JudgeOnline/problem.php?id=1056)\n\n### \n Splay  `map`  Splay \n\n### \n```c++\n#include <cstdio>\n// #include <cassert>\n#include <climits>\n#include <vector>\n#include <map>\n#include <iostream>\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *fa, **root;\n\t\tconst std::map<std::string, Node *>::iterator it;\n\t\tstd::pair<int, int> x;\n\t\tint size;\n\n\t\tNode(Node **root, Node *fa, const std::pair<int, int> &x, const std::map<std::string, Node *>::iterator it) : fa(fa), root(root), it(it), x(x), size(0) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tNode *o = fa;\n\t\t\tint x = relation();\n\t\t\t\n\t\t\tif (o->fa) o->fa->c[o->relation()] = this;\n\t\t\tfa = o->fa;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->fa = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!fa) *root = this;\n\t\t}\n\n\t\tNode *splay(Node *target = NULL) {\n\t\t\twhile (fa != target) {\n\t\t\t\tif (fa->fa == target) rotate();\n\t\t\t\telse if (relation() == fa->relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prev() {\n\t\t\tNode *v = splay()->c[0];\n\t\t\twhile (v->c[1]) v = v->c[1];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tNode *v = splay()->c[1];\n\t\t\twhile (v->c[0]) v = v->c[0];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[0] ? c[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay(const std::map<std::string, Node *>::iterator null) : root(NULL) {\n\t\tinsert(std::make_pair(INT_MIN, INT_MIN), null);\n\t\tinsert(std::make_pair(INT_MAX, INT_MAX), null);\n\t}\n\n\tNode *insert(const std::pair<int, int> &x, std::map<std::string, Node *>::iterator it) {\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v) {\n\t\t\tfa = *v;\n\t\t\tfa->size++;\n\t\t\tv = &fa->c[x > fa->x];\n\t\t}\n\t\t*v = new Node(&root, fa, x, it);\n\t\treturn (*v)->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tNode *l = v->prev(), *r = v->succ();\n\t\tr->splay();\n\t\tl->splay(r);\n\t\t// assert(v == l->c[1]);\n\t\tdelete v;\n\t\tl->c[1] = NULL;\n\t\tl->size--, r->size--;\n\t}\n\n\tNode *select(int k) {\n\t\tint x = k;\n\t\tNode *v = root;\n\t\twhile (v->rank() != x) {\n\t\t\tif (v->rank() > x) v = v->c[0];\n\t\t\telse x -= v->rank() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *prev = select(l - 1), *succ = select(r + 1);\n\t\tsucc->splay();\n\t\tprev->splay(succ);\n\t\treturn prev->c[1];\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nstd::map<std::string, Splay::Node *> map;\nSplay splay(map.end());\n\nvoid dfs(Splay::Node *v, std::vector<const std::string *> &vec) {\n\tif (!v) return;\n\tdfs(v->c[0], vec);\n\tif (v->it != map.end()) vec.push_back(&v->it->first);\n\tdfs(v->c[1], vec);\n}\n\ninline int parseInt(std::string s) {\n\tint x = 0;\n\tfor (std::string::iterator it = s.begin(); it != s.end(); it++) x = x * 10 + (*it - '0');\n\treturn x;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile (n--) {\n\t\tstd::string cmd;\n\t\tstd::cin >> cmd;\n\t\tif (cmd[0] == '+') {\n\t\t\tstd::string name = cmd.substr(1, cmd.length() - 1);\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tstd::map<std::string, Splay::Node *>::iterator it = map.find(name);\n\t\t\tif (it != map.end()) {\n\t\t\t\tsplay.erase(it->second);\n\t\t\t} else {\n\t\t\t\tit = map.insert(std::make_pair(name, static_cast<Splay::Node *>(NULL))).first;\n\t\t\t}\n\n\t\t\tit->second = splay.insert(std::make_pair(-x, -n), it);\n\t\t} else if (cmd[0] == '?') {\n\t\t\tstd::string arg = cmd.substr(1, cmd.length() - 1);\n\t\t\tif (arg[0] >= '0' && arg[0] <= '9') {\n\t\t\t\tint x = parseInt(arg);\n\t\t\t\tSplay::Node *v = splay.select(x, std::min(splay.size(), x + 10 - 1));\n\n\t\t\t\tstd::vector<const std::string *> vec;\n\t\t\t\tdfs(v, vec);\n\n\t\t\t\tfor (std::vector<const std::string *>::iterator it = vec.begin(); it != vec.end(); it++) std::cout << **it << (it == vec.end() - 1 ? '\\n' : ' ');\n\t\t\t} else {\n\t\t\t\tSplay::Node *v = map[arg];\n\t\t\t\tprintf(\"%d\\n\", v->splay()->rank());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-rank.md","raw":"title: HAOI2008 - map + Splay\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - map\n  - Splay\n  - \npermalink: haoi2008-rank\ndate: 2016-12-13 17:08:00\n---\n\n $ 10 $ \n\n<!-- more -->\n\n### \n[BZOJ 1056](http://www.lydsy.com/JudgeOnline/problem.php?id=1056)\n\n### \n Splay  `map`  Splay \n\n### \n```c++\n#include <cstdio>\n// #include <cassert>\n#include <climits>\n#include <vector>\n#include <map>\n#include <iostream>\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *fa, **root;\n\t\tconst std::map<std::string, Node *>::iterator it;\n\t\tstd::pair<int, int> x;\n\t\tint size;\n\n\t\tNode(Node **root, Node *fa, const std::pair<int, int> &x, const std::map<std::string, Node *>::iterator it) : fa(fa), root(root), it(it), x(x), size(0) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tNode *o = fa;\n\t\t\tint x = relation();\n\t\t\t\n\t\t\tif (o->fa) o->fa->c[o->relation()] = this;\n\t\t\tfa = o->fa;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->fa = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!fa) *root = this;\n\t\t}\n\n\t\tNode *splay(Node *target = NULL) {\n\t\t\twhile (fa != target) {\n\t\t\t\tif (fa->fa == target) rotate();\n\t\t\t\telse if (relation() == fa->relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prev() {\n\t\t\tNode *v = splay()->c[0];\n\t\t\twhile (v->c[1]) v = v->c[1];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tNode *v = splay()->c[1];\n\t\t\twhile (v->c[0]) v = v->c[0];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[0] ? c[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay(const std::map<std::string, Node *>::iterator null) : root(NULL) {\n\t\tinsert(std::make_pair(INT_MIN, INT_MIN), null);\n\t\tinsert(std::make_pair(INT_MAX, INT_MAX), null);\n\t}\n\n\tNode *insert(const std::pair<int, int> &x, std::map<std::string, Node *>::iterator it) {\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v) {\n\t\t\tfa = *v;\n\t\t\tfa->size++;\n\t\t\tv = &fa->c[x > fa->x];\n\t\t}\n\t\t*v = new Node(&root, fa, x, it);\n\t\treturn (*v)->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tNode *l = v->prev(), *r = v->succ();\n\t\tr->splay();\n\t\tl->splay(r);\n\t\t// assert(v == l->c[1]);\n\t\tdelete v;\n\t\tl->c[1] = NULL;\n\t\tl->size--, r->size--;\n\t}\n\n\tNode *select(int k) {\n\t\tint x = k;\n\t\tNode *v = root;\n\t\twhile (v->rank() != x) {\n\t\t\tif (v->rank() > x) v = v->c[0];\n\t\t\telse x -= v->rank() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *prev = select(l - 1), *succ = select(r + 1);\n\t\tsucc->splay();\n\t\tprev->splay(succ);\n\t\treturn prev->c[1];\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nstd::map<std::string, Splay::Node *> map;\nSplay splay(map.end());\n\nvoid dfs(Splay::Node *v, std::vector<const std::string *> &vec) {\n\tif (!v) return;\n\tdfs(v->c[0], vec);\n\tif (v->it != map.end()) vec.push_back(&v->it->first);\n\tdfs(v->c[1], vec);\n}\n\ninline int parseInt(std::string s) {\n\tint x = 0;\n\tfor (std::string::iterator it = s.begin(); it != s.end(); it++) x = x * 10 + (*it - '0');\n\treturn x;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile (n--) {\n\t\tstd::string cmd;\n\t\tstd::cin >> cmd;\n\t\tif (cmd[0] == '+') {\n\t\t\tstd::string name = cmd.substr(1, cmd.length() - 1);\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tstd::map<std::string, Splay::Node *>::iterator it = map.find(name);\n\t\t\tif (it != map.end()) {\n\t\t\t\tsplay.erase(it->second);\n\t\t\t} else {\n\t\t\t\tit = map.insert(std::make_pair(name, static_cast<Splay::Node *>(NULL))).first;\n\t\t\t}\n\n\t\t\tit->second = splay.insert(std::make_pair(-x, -n), it);\n\t\t} else if (cmd[0] == '?') {\n\t\t\tstd::string arg = cmd.substr(1, cmd.length() - 1);\n\t\t\tif (arg[0] >= '0' && arg[0] <= '9') {\n\t\t\t\tint x = parseInt(arg);\n\t\t\t\tSplay::Node *v = splay.select(x, std::min(splay.size(), x + 10 - 1));\n\n\t\t\t\tstd::vector<const std::string *> vec;\n\t\t\t\tdfs(v, vec);\n\n\t\t\t\tfor (std::vector<const std::string *>::iterator it = vec.begin(); it != vec.end(); it++) std::cout << **it << (it == vec.end() - 1 ? '\\n' : ' ');\n\t\t\t} else {\n\t\t\t\tSplay::Node *v = map[arg];\n\t\t\t\tprintf(\"%d\\n\", v->splay()->rank());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"haoi2008-rank","published":1,"updated":"2016-12-13T09:08:05.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rzc012tooxlsxa4uvxb"},{"title":"HAOI2008 -  DP","date":"2016-07-06T03:37:00.000Z","_content":"\n `WING`  `WING` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1055](http://www.lydsy.com/JudgeOnline/problem.php?id=1055)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 200;\nconst int K = 4;\n\nint n, a[MAXN];\nbool map[K][K][K];\n\ninline int id(const char ch) {\n\tswitch (ch) {\n\t\tcase 'W': return 0;\n\t\tcase 'I': return 1;\n\t\tcase 'N': return 2;\n\t\tcase 'G': return 3;\n\t\tdefault: return -1;\n\t}\n}\n\ninline char letter(const int x) {\n\treturn (\"WING\")[x];\n}\n\ninline void setMap(const int x, const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tmap[id(s[0])][id(s[1])][x] = true;\n\t}\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tstatic bool calced[MAXN][MAXN];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1 << a[l];\n\n\tfor (int i = l; i < r; i++) {\n\t\tconst int a = dp(l, i), b = dp(i + 1, r);\n\n\t\tfor (int i = 0; i < K; i++) if (a & (1 << i)) for (int j = 0; j < K; j++) if (b & (1 << j)) {\n\t\t\tfor (int k = 0; k < K; k++) if (map[i][j][k]) ans |= 1 << k;\n\t\t}\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\treturn ans;\n}\n\nint main() {\n\tint cnt[K];\n\tfor (int i = 0; i < K; i++) scanf(\"%d\", &cnt[i]);\n\tfor (int i = 0; i < K; i++) setMap(i, cnt[i]);\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = id(s[i]);\n\n\tint res = dp(0, n - 1);\n\tbool flag = false;\n\tfor (int i = 0; i < K; i++) if (res & (1 << i)) putchar(letter(i)), flag = true;\n\n\tif (flag) putchar('\\n');\n\telse puts(\"The name is wrong!\");\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2008-name.md","raw":"title: HAOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  -  DP\npermalink: haoi2008-name\ndate: 2016-07-06 11:37:00\n---\n\n `WING`  `WING` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1055](http://www.lydsy.com/JudgeOnline/problem.php?id=1055)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 200;\nconst int K = 4;\n\nint n, a[MAXN];\nbool map[K][K][K];\n\ninline int id(const char ch) {\n\tswitch (ch) {\n\t\tcase 'W': return 0;\n\t\tcase 'I': return 1;\n\t\tcase 'N': return 2;\n\t\tcase 'G': return 3;\n\t\tdefault: return -1;\n\t}\n}\n\ninline char letter(const int x) {\n\treturn (\"WING\")[x];\n}\n\ninline void setMap(const int x, const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tmap[id(s[0])][id(s[1])][x] = true;\n\t}\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tstatic bool calced[MAXN][MAXN];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1 << a[l];\n\n\tfor (int i = l; i < r; i++) {\n\t\tconst int a = dp(l, i), b = dp(i + 1, r);\n\n\t\tfor (int i = 0; i < K; i++) if (a & (1 << i)) for (int j = 0; j < K; j++) if (b & (1 << j)) {\n\t\t\tfor (int k = 0; k < K; k++) if (map[i][j][k]) ans |= 1 << k;\n\t\t}\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\treturn ans;\n}\n\nint main() {\n\tint cnt[K];\n\tfor (int i = 0; i < K; i++) scanf(\"%d\", &cnt[i]);\n\tfor (int i = 0; i < K; i++) setMap(i, cnt[i]);\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = id(s[i]);\n\n\tint res = dp(0, n - 1);\n\tbool flag = false;\n\tfor (int i = 0; i < K; i++) if (res & (1 << i)) putchar(letter(i)), flag = true;\n\n\tif (flag) putchar('\\n');\n\telse puts(\"The name is wrong!\");\n\n\treturn 0;\n}\n```\n","slug":"haoi2008-name","published":1,"updated":"2016-10-24T23:35:44.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rzi0130ooxlwf551u6z"},{"title":"HAOI2008 -  + BFS","date":"2016-12-13T09:01:00.000Z","_content":"\n $ 4 \\times 4 $ \n\n<!-- more -->\n\n### \n[BZOJ 1054](http://www.lydsy.com/JudgeOnline/problem.php?id=1054)\n\n### \n $ 16 $ BFS \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 16;\n\ninline unsigned int read() {\n\tunsigned int res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tchar s[4 + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[j] == '1') res |= (1 << (4 * i + j));\n\t\t}\n\t}\n\treturn res;\n}\n\ninline int bfs(unsigned int s, unsigned int t) {\n\tstatic int dist[1 << MAXN];\n\tfor (int i = 0; i < (1 << MAXN); i++) dist[i] = INT_MAX;\n\n\tstd::queue<unsigned int> q;\n\tdist[s] = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tunsigned int v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return dist[v];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint a = 4 * i + j;\n\t\t\t\tunsigned int va = !!(v & (1 << a));\n\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tint b = 4 * (i + 1) + j;\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j != 3) {\n\t\t\t\t\tint b = 4 * i + (j + 1);\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tunsigned int s = read(), t = read();\n\tprintf(\"%d\\n\", bfs(s, t));\n\treturn 0;\n}\n```\n","source":"_posts/haoi2008-move.md","raw":"title: HAOI2008 -  + BFS\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - BFS\npermalink: haoi2008-move\ndate: 2016-12-13 17:01:00\n---\n\n $ 4 \\times 4 $ \n\n<!-- more -->\n\n### \n[BZOJ 1054](http://www.lydsy.com/JudgeOnline/problem.php?id=1054)\n\n### \n $ 16 $ BFS \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 16;\n\ninline unsigned int read() {\n\tunsigned int res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tchar s[4 + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[j] == '1') res |= (1 << (4 * i + j));\n\t\t}\n\t}\n\treturn res;\n}\n\ninline int bfs(unsigned int s, unsigned int t) {\n\tstatic int dist[1 << MAXN];\n\tfor (int i = 0; i < (1 << MAXN); i++) dist[i] = INT_MAX;\n\n\tstd::queue<unsigned int> q;\n\tdist[s] = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tunsigned int v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return dist[v];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint a = 4 * i + j;\n\t\t\t\tunsigned int va = !!(v & (1 << a));\n\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tint b = 4 * (i + 1) + j;\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j != 3) {\n\t\t\t\t\tint b = 4 * i + (j + 1);\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tunsigned int s = read(), t = read();\n\tprintf(\"%d\\n\", bfs(s, t));\n\treturn 0;\n}\n```\n","slug":"haoi2008-move","published":1,"updated":"2016-12-13T09:08:17.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rzp0136ooxl1yz71ohq"},{"title":"HAOI2008 -  DP + ","date":"2016-11-13T03:11:00.000Z","_content":"\n $ 4 $  $ c_1, c_2, c_3, c_4 $ $ n $  $ d_i $  $ c_i $  $ s_i $ \n\n<!-- more -->\n\n### \n[BZOJ 1042](http://www.lydsy.com/JudgeOnline/problem.php?id=1042)\n\n### \n $ c $  $ f(c) $\n\n $ s_i $    -  +  - \n\n $ i $    $ d_i + 1 $  $ i $  $ s - (d_i + 1) \\times c_i $  $ f(s - (d_i + 1) \\times c_i) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MAXM = 100000;\n\nint main() {\n\tint c[4 + 1], n;\n\tscanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &n);\n\n\tstatic long long f[4 + 1][MAXM + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < c[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n\t\t}\n\t}\n\n\twhile (n--) {\n\t\tint d[4 + 1], m;\n\t\tscanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &m);\n\n\t\tlong long ans = f[4][m];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tif (m - (d[i] + 1) * c[i] >= 0) ans -= f[4][m - (d[i] + 1) * c[i]];\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] >= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tfor (int k = j + 1; k <= 4; k++) {\n\t\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] >= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] >= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-coins.md","raw":"title: HAOI2008 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - DP\n  -  DP\n  - \npermalink: haoi2008-coins\ndate: 2016-11-13 11:11:00\n---\n\n $ 4 $  $ c_1, c_2, c_3, c_4 $ $ n $  $ d_i $  $ c_i $  $ s_i $ \n\n<!-- more -->\n\n### \n[BZOJ 1042](http://www.lydsy.com/JudgeOnline/problem.php?id=1042)\n\n### \n $ c $  $ f(c) $\n\n $ s_i $    -  +  - \n\n $ i $    $ d_i + 1 $  $ i $  $ s - (d_i + 1) \\times c_i $  $ f(s - (d_i + 1) \\times c_i) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MAXM = 100000;\n\nint main() {\n\tint c[4 + 1], n;\n\tscanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &n);\n\n\tstatic long long f[4 + 1][MAXM + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < c[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n\t\t}\n\t}\n\n\twhile (n--) {\n\t\tint d[4 + 1], m;\n\t\tscanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &m);\n\n\t\tlong long ans = f[4][m];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tif (m - (d[i] + 1) * c[i] >= 0) ans -= f[4][m - (d[i] + 1) * c[i]];\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] >= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tfor (int k = j + 1; k <= 4; k++) {\n\t\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] >= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] >= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"haoi2008-coins","published":1,"updated":"2016-11-13T03:11:42.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9rzu013cooxlvok6je2x"},{"title":"HAOI2008 - ","date":"2016-11-13T02:56:00.000Z","_content":"\n $ x ^ 2 + y ^ 2 = r ^ 2 $\n\n<!-- more -->\n\n### \n[BZOJ 1041](http://www.lydsy.com/JudgeOnline/problem.php?id=1041)\n\n### \n$$\n\\begin{aligned}\nx ^ 2 + y ^ 2 &= r ^ 2 \\\\\ny ^ 2 &= r ^ 2 - x ^ 2 \\\\\ny ^ 2 &= (r + x) \\times (r - x)\n\\end{aligned}\n$$\n\n $ d = \\gcd(r + x, r - x) $$ a = \\frac{r - x}{d} $$ b = \\frac{r + x}{d} $ $ \\gcd(a, b) = 1 $\n\n$$\n\\begin{aligned}\ny ^ 2 &= (r + x) \\times (r - x) \\\\\n&= d ^ 2 \\times a \\times b\n\\end{aligned}\n$$\n\n$ d ^ 2 $  $ y ^ 2 $  $ a \\times b $  $ \\gcd(a, b) = 1 $ $ a $  $ b $ \n\n$$\n\\begin{aligned}\na + b &= \\frac{r - x}{d} + \\frac{r + x}{d} \\\\\na + b &= \\frac{2r}{d}\n\\end{aligned}\n$$\n\n $ \\{ a, b, d \\} $ $ a $  $ b $  $ d $  $ 2r $ \n\n $ d $ $ \\sqrt a $ $ b $ $ \\gcd(a, b) = 1 $ \n\n $ k $ $ 4k + 4 $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 2e9;\nconst double EPS = 1e-6;\n\nint main() {\n\tlong long r;\n\tscanf(\"%lld\", &r);\n\n\t// 2 * r = d * (a ^ 2 + b ^ 2)\n\tlong long cnt = 0;\n\tfor (long long i = 1; i * i <= r * 2; i++) {\n\t\tif (2 * r % i != 0) continue;\n\n\t\tlong long d = i;\n\t\tlong long t = 2 * r / i;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (long long a = 1; a * a < t / 2; a++) {\n\t\t\t\tdouble b = sqrt(t - a * a);\n\t\t\t\tlong long _b = static_cast<long long>(b);\n\t\t\t\tif (fabs(b - _b) <= EPS && std::__gcd(a, _b) == 1) {\n\t\t\t\t\t// printf(\"d = %lld, a = %lld, b = %lld\\n\", d, a, _b);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != d) std::swap(t, d);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", cnt * 4 + 4);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-cir.md","raw":"title: HAOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \npermalink: haoi2008-cir\ndate: 2016-11-13 10:56:00\n---\n\n $ x ^ 2 + y ^ 2 = r ^ 2 $\n\n<!-- more -->\n\n### \n[BZOJ 1041](http://www.lydsy.com/JudgeOnline/problem.php?id=1041)\n\n### \n$$\n\\begin{aligned}\nx ^ 2 + y ^ 2 &= r ^ 2 \\\\\ny ^ 2 &= r ^ 2 - x ^ 2 \\\\\ny ^ 2 &= (r + x) \\times (r - x)\n\\end{aligned}\n$$\n\n $ d = \\gcd(r + x, r - x) $$ a = \\frac{r - x}{d} $$ b = \\frac{r + x}{d} $ $ \\gcd(a, b) = 1 $\n\n$$\n\\begin{aligned}\ny ^ 2 &= (r + x) \\times (r - x) \\\\\n&= d ^ 2 \\times a \\times b\n\\end{aligned}\n$$\n\n$ d ^ 2 $  $ y ^ 2 $  $ a \\times b $  $ \\gcd(a, b) = 1 $ $ a $  $ b $ \n\n$$\n\\begin{aligned}\na + b &= \\frac{r - x}{d} + \\frac{r + x}{d} \\\\\na + b &= \\frac{2r}{d}\n\\end{aligned}\n$$\n\n $ \\{ a, b, d \\} $ $ a $  $ b $  $ d $  $ 2r $ \n\n $ d $ $ \\sqrt a $ $ b $ $ \\gcd(a, b) = 1 $ \n\n $ k $ $ 4k + 4 $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 2e9;\nconst double EPS = 1e-6;\n\nint main() {\n\tlong long r;\n\tscanf(\"%lld\", &r);\n\n\t// 2 * r = d * (a ^ 2 + b ^ 2)\n\tlong long cnt = 0;\n\tfor (long long i = 1; i * i <= r * 2; i++) {\n\t\tif (2 * r % i != 0) continue;\n\n\t\tlong long d = i;\n\t\tlong long t = 2 * r / i;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (long long a = 1; a * a < t / 2; a++) {\n\t\t\t\tdouble b = sqrt(t - a * a);\n\t\t\t\tlong long _b = static_cast<long long>(b);\n\t\t\t\tif (fabs(b - _b) <= EPS && std::__gcd(a, _b) == 1) {\n\t\t\t\t\t// printf(\"d = %lld, a = %lld, b = %lld\\n\", d, a, _b);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != d) std::swap(t, d);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", cnt * 4 + 4);\n\n\treturn 0;\n}\n```","slug":"haoi2008-cir","published":1,"updated":"2016-11-13T02:56:51.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s01013kooxlpt7nhhab"},{"title":"HAOI2008 - ","date":"2016-11-13T03:45:00.000Z","_content":"\n $ n $  $ a_i $  $ 1 $\n\n<!-- more -->\n\n### \n[BZOJ 1045](http://www.lydsy.com/JudgeOnline/problem.php?id=1045)\n\n### \n $ v = \\frac{\\sum\\limits_{i = 1} ^ n a_i}{n} $$ x_1 $  $ i - 1 $  $ i $ \n\n$$\n\\begin{aligned}\nv &= a_i + x_i - x_{i - 1} \\\\\nx_{i + 1} &= x_i - v + a_i\n\\end{aligned}\n$$\n\n\n\n$$\n\\begin{aligned}\nx_2 &= x_1 - v + a_1 \\\\\nx_3 &= x_2 - v + a_2 \\\\\n    &= x_1 - v + a_1 - v + a_2 \\\\\nx_4 &= x_3 - v + a_3 \\\\\n    &= x_1 - v + a_1 - v + a_2 - v + a_3\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ n | x_i | $\n\n $ c_0 = 0, c_i = c_{i - 1} + v - a_i $\n\n$$\n\\begin{aligned}\nx_1 &= x_1 - c_0 \\\\\nx_2 &= x_1 - c_1 \\\\\nx_3 &= x_1 - c_2 \\\\\nx_4 &= x_1 - c_3\n\\end{aligned}\n$$\n\n\n\n$$ \\sum\\limits_{i = 1} ^ n | x_1 - c_{i - 1} | $$\n\n $ c_i $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic long long a[MAXN];\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tlong long avg = sum / n;\n\tstatic long long c[MAXN];\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i++) c[i] = c[i - 1] - a[i] + avg;\n\n\tstd::sort(c, c + n);\n\n\tlong long mid = c[n / 2], ans = 0;\n\tfor (int i = 0; i < n; i++) ans += llabs(c[i] - mid);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-candy.md","raw":"title: HAOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \npermalink: haoi2008-candy\ndate: 2016-11-13 11:45:00\n---\n\n $ n $  $ a_i $  $ 1 $\n\n<!-- more -->\n\n### \n[BZOJ 1045](http://www.lydsy.com/JudgeOnline/problem.php?id=1045)\n\n### \n $ v = \\frac{\\sum\\limits_{i = 1} ^ n a_i}{n} $$ x_1 $  $ i - 1 $  $ i $ \n\n$$\n\\begin{aligned}\nv &= a_i + x_i - x_{i - 1} \\\\\nx_{i + 1} &= x_i - v + a_i\n\\end{aligned}\n$$\n\n\n\n$$\n\\begin{aligned}\nx_2 &= x_1 - v + a_1 \\\\\nx_3 &= x_2 - v + a_2 \\\\\n    &= x_1 - v + a_1 - v + a_2 \\\\\nx_4 &= x_3 - v + a_3 \\\\\n    &= x_1 - v + a_1 - v + a_2 - v + a_3\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ n | x_i | $\n\n $ c_0 = 0, c_i = c_{i - 1} + v - a_i $\n\n$$\n\\begin{aligned}\nx_1 &= x_1 - c_0 \\\\\nx_2 &= x_1 - c_1 \\\\\nx_3 &= x_1 - c_2 \\\\\nx_4 &= x_1 - c_3\n\\end{aligned}\n$$\n\n\n\n$$ \\sum\\limits_{i = 1} ^ n | x_1 - c_{i - 1} | $$\n\n $ c_i $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic long long a[MAXN];\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tlong long avg = sum / n;\n\tstatic long long c[MAXN];\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i++) c[i] = c[i - 1] - a[i] + avg;\n\n\tstd::sort(c, c + n);\n\n\tlong long mid = c[n / 2], ans = 0;\n\tfor (int i = 0; i < n; i++) ans += llabs(c[i] - mid);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2008-candy","published":1,"updated":"2016-11-13T07:24:37.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s06013pooxll1sqek1m"},{"title":"HAOI2007 - ","date":"2016-12-01T23:16:00.000Z","_content":"\n $ n \\times m $  $ k \\times k $ \n\n<!-- more -->\n\n### \n[BZOJ 1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047)\n\n### \n $ b(i, j) = \\max\\limits_{t = j - k + 1} ^ j a(i, t) $ $ k $  $ c(i, j) = \\max\\limits_{t = i - k + 1} ^ i b(t, j) $ $ k $  $ k $  $ k $  $ k \\times k $ \n\n $ k \\times k $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 1000;\n\nint n, m, k, a[MAXN + 1][MAXN + 1];\n\ntemplate <typename T>\ninline void workColumns(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[i][j], a[i][*r])) r--;\n\t\t\t*++r = j;\n\t\t\tb[i][j] = a[i][*l];\n#ifdef DBG\n\t\t\tprintf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n\t\t}\n\t}\n}\n\ntemplate <typename T>\ninline void workRows(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[j][i], a[*r][i])) r--;\n\t\t\t*++r = j;\n\t\t\tb[j][i] = a[*l][i];\n\t\t}\n\t}\n#ifdef DBG\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tstatic int columnMax[MAXN + 1][MAXN + 1], rowMax[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMax, std::greater<int>());\n\tworkRows(columnMax, rowMax, std::greater<int>());\n\n\tstatic int columnMin[MAXN + 1][MAXN + 1], rowMin[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMin, std::less<int>());\n\tworkRows(columnMin, rowMin, std::less<int>());\n\n\tint ans = INT_MAX;\n\tfor (int i = k; i <= n; i++) for (int j = k; j <= m; j++) ans = std::min(ans, rowMax[i][j] - rowMin[i][j]);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-square.md","raw":"title: HAOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \npermalink: haoi2007-square\ndate: 2016-12-02 07:16:00\n---\n\n $ n \\times m $  $ k \\times k $ \n\n<!-- more -->\n\n### \n[BZOJ 1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047)\n\n### \n $ b(i, j) = \\max\\limits_{t = j - k + 1} ^ j a(i, t) $ $ k $  $ c(i, j) = \\max\\limits_{t = i - k + 1} ^ i b(t, j) $ $ k $  $ k $  $ k $  $ k \\times k $ \n\n $ k \\times k $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 1000;\n\nint n, m, k, a[MAXN + 1][MAXN + 1];\n\ntemplate <typename T>\ninline void workColumns(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[i][j], a[i][*r])) r--;\n\t\t\t*++r = j;\n\t\t\tb[i][j] = a[i][*l];\n#ifdef DBG\n\t\t\tprintf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n\t\t}\n\t}\n}\n\ntemplate <typename T>\ninline void workRows(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[j][i], a[*r][i])) r--;\n\t\t\t*++r = j;\n\t\t\tb[j][i] = a[*l][i];\n\t\t}\n\t}\n#ifdef DBG\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tstatic int columnMax[MAXN + 1][MAXN + 1], rowMax[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMax, std::greater<int>());\n\tworkRows(columnMax, rowMax, std::greater<int>());\n\n\tstatic int columnMin[MAXN + 1][MAXN + 1], rowMin[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMin, std::less<int>());\n\tworkRows(columnMin, rowMin, std::less<int>());\n\n\tint ans = INT_MAX;\n\tfor (int i = k; i <= n; i++) for (int j = k; j <= m; j++) ans = std::min(ans, rowMax[i][j] - rowMin[i][j]);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2007-square","published":1,"updated":"2016-12-01T23:16:57.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0a013uooxlg37nsti1"},{"title":"HAOI2007 - ","date":"2016-12-04T23:52:00.000Z","_content":"\n $ n \\times m $  $ k - 1 $  $ k $  $ n $  $ n $\n\n<!-- more -->\n\n### \n[BZOJ 1048](http://www.lydsy.com/JudgeOnline/problem.php?id=1048)\n\n### \n $ s $ $ x_1 \\sim x_k $ $ S = \\sum\\limits_{i = 1} ^ k x_i $  $ x' = \\frac{S}{k} $\n\n$$\n\\begin{aligned}\ns ^ 2 &= \\frac{\\sum\\limits_{i = 1} ^ k (x_i - \\frac{S}{k}) ^ 2}{k} \\\\\n&= \\frac{\\sum\\limits_{i = 1} ^ k(x_i ^ 2 + (\\frac{S}{k}) ^ 2 + 2x_i\\frac{S}{k})}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\sum\\limits_{i = 1} ^ k \\frac{\\frac{S ^ 2}{k ^ 2}}{k} - 2(\\sum\\limits_{i = 1} ^ k x_i) \\frac{\\frac{S}{k}}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\frac{S ^ 2}{k^ 2} - 2 \\frac{(\\sum\\limits_{i = 1} ^ k x_i) S}{k ^ 2} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} - \\frac{S ^ 2}{k ^ 2} \\\\\n&= \\frac{k \\sum\\limits_{i = 1} ^ k x_i ^ 2 - S ^ 2}{k ^ 2}\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ k x_i ^ 2 $\n\n$ f(i_1, j_1, i_2, j_2, k) $  $ (i_1, j_1) $ $ (i_2, j_2) $  $ k $ \n\n$ n $  $ m $  $ O(n ^ 4 k \\times nk) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10;\n\nint n, m, k, a[MAXN + 1][MAXN + 1], s[MAXN + 1][MAXN + 1];\n\ninline int sum(int i1, int j1, int i2, int j2) {\n\treturn s[i2][j2] - s[i1 - 1][j2] - s[i2][j1 - 1] + s[i1 - 1][j1 - 1];\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sumLine = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tsumLine += a[i][j];\n\t\t\ts[i][j] = s[i - 1][j] + sumLine;\n\t\t}\n\t}\n}\n\ntemplate <typename T> T sqr(T x) { return x * x; }\n\ninline int search(int i1, int j1, int i2, int j2, int cnt) {\n\tstatic int mem[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tstatic bool calced[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tint &ans = mem[i1][j1][i2][j2][cnt];\n\tif (calced[i1][j1][i2][j2][cnt]) return ans;\n\tcalced[i1][j1][i2][j2][cnt] = true;\n\n\tif (!cnt) {\n\t\treturn ans = sqr(sum(i1, j1, i2, j2));\n\t}\n\n\tans = INT_MAX;\n\n\tfor (int i = i1; i < i2; i++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i + 1, j1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i, j2, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\tfor (int j = j1; j < j2; j++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i1, j + 1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i2, j, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\t// printf(\"search(%d, %d, %d, %d, %d) = %d\\n\", i1, j1, i2, j2, cnt, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprepare();\n\n\tint ans = search(1, 1, n, m, k - 1);\n\n\t// printf(\"%d\\n\", ans);\n\tprintf(\"%.2lf\\n\", sqrt((ans * k - sqr(s[n][m])) / static_cast<double>(sqr(k))));\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-separation.md","raw":"title: HAOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  - \n  - DFS\npermalink: haoi2007-separation\ndate: 2016-12-05 07:52:00\n---\n\n $ n \\times m $  $ k - 1 $  $ k $  $ n $  $ n $\n\n<!-- more -->\n\n### \n[BZOJ 1048](http://www.lydsy.com/JudgeOnline/problem.php?id=1048)\n\n### \n $ s $ $ x_1 \\sim x_k $ $ S = \\sum\\limits_{i = 1} ^ k x_i $  $ x' = \\frac{S}{k} $\n\n$$\n\\begin{aligned}\ns ^ 2 &= \\frac{\\sum\\limits_{i = 1} ^ k (x_i - \\frac{S}{k}) ^ 2}{k} \\\\\n&= \\frac{\\sum\\limits_{i = 1} ^ k(x_i ^ 2 + (\\frac{S}{k}) ^ 2 + 2x_i\\frac{S}{k})}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\sum\\limits_{i = 1} ^ k \\frac{\\frac{S ^ 2}{k ^ 2}}{k} - 2(\\sum\\limits_{i = 1} ^ k x_i) \\frac{\\frac{S}{k}}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\frac{S ^ 2}{k^ 2} - 2 \\frac{(\\sum\\limits_{i = 1} ^ k x_i) S}{k ^ 2} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} - \\frac{S ^ 2}{k ^ 2} \\\\\n&= \\frac{k \\sum\\limits_{i = 1} ^ k x_i ^ 2 - S ^ 2}{k ^ 2}\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ k x_i ^ 2 $\n\n$ f(i_1, j_1, i_2, j_2, k) $  $ (i_1, j_1) $ $ (i_2, j_2) $  $ k $ \n\n$ n $  $ m $  $ O(n ^ 4 k \\times nk) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10;\n\nint n, m, k, a[MAXN + 1][MAXN + 1], s[MAXN + 1][MAXN + 1];\n\ninline int sum(int i1, int j1, int i2, int j2) {\n\treturn s[i2][j2] - s[i1 - 1][j2] - s[i2][j1 - 1] + s[i1 - 1][j1 - 1];\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sumLine = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tsumLine += a[i][j];\n\t\t\ts[i][j] = s[i - 1][j] + sumLine;\n\t\t}\n\t}\n}\n\ntemplate <typename T> T sqr(T x) { return x * x; }\n\ninline int search(int i1, int j1, int i2, int j2, int cnt) {\n\tstatic int mem[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tstatic bool calced[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tint &ans = mem[i1][j1][i2][j2][cnt];\n\tif (calced[i1][j1][i2][j2][cnt]) return ans;\n\tcalced[i1][j1][i2][j2][cnt] = true;\n\n\tif (!cnt) {\n\t\treturn ans = sqr(sum(i1, j1, i2, j2));\n\t}\n\n\tans = INT_MAX;\n\n\tfor (int i = i1; i < i2; i++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i + 1, j1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i, j2, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\tfor (int j = j1; j < j2; j++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i1, j + 1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i2, j, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\t// printf(\"search(%d, %d, %d, %d, %d) = %d\\n\", i1, j1, i2, j2, cnt, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprepare();\n\n\tint ans = search(1, 1, n, m, k - 1);\n\n\t// printf(\"%d\\n\", ans);\n\tprintf(\"%.2lf\\n\", sqrt((ans * k - sqr(s[n][m])) / static_cast<double>(sqr(k))));\n\n\treturn 0;\n}\n```","slug":"haoi2007-separation","published":1,"updated":"2016-12-04T23:52:39.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0f013zooxl6lho0k0m"},{"title":"HAOI2007 - DP + ","date":"2016-12-01T03:43:00.000Z","_content":"\n $ S = \\{ a_1, a_2, a_3, \\ldots , a_n \\} $ $ P = \\{ a_{x_1},a_{x_2}, a_{x_3}, \\ldots, a_{x_m} \\} $ $ x_1 < x_2 < \\ldots < x_m $  $ a_{x_1} < a_{x_2} < \\ldots < a_{x_m} $ $ P $  $ S $  $ P $ \n\n $ S $  $ i $  $ L_i $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1046](http://www.lydsy.com/JudgeOnline/problem.php?id=1046)\n\n### \n $ f(i) $  $ i $ ****\n\n$$ f(i) = \\max\\limits_{j > i, a_j > a_i}\\{ f(j) \\} + 1 $$\n\n $ \\leq l $ $ l $  $ 1 $ $ l \\neq 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int f[MAXN + 1];\n\tfor (int i = n; i >= 1; i--) {\n\t\tf[i] = 1;\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"f[%d] = %d\\n\", i, f[i]);\n#endif\n\t}\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\n\t\tstatic int tmp[MAXN + 1];\n\t\tint cnt = 0;\n\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[i] >= l && a[i] > last) {\n\t\t\t\tl--;\n\t\t\t\tlast = a[i];\n\t\t\t\ttmp[++cnt] = a[i];\n\t\t\t}\n\t\t\tif (!l) break;\n\t\t}\n\n\t\tif (l) puts(\"Impossible\");\n\t\telse for (int i = 1; i <= cnt; i++) printf(\"%d%c\", tmp[i], i == cnt ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2007-lis.md","raw":"title: HAOI2007 - DP + \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  - \npermalink: haoi2007-lis\ndate: 2016-12-01 11:43:00\n---\n\n $ S = \\{ a_1, a_2, a_3, \\ldots , a_n \\} $ $ P = \\{ a_{x_1},a_{x_2}, a_{x_3}, \\ldots, a_{x_m} \\} $ $ x_1 < x_2 < \\ldots < x_m $  $ a_{x_1} < a_{x_2} < \\ldots < a_{x_m} $ $ P $  $ S $  $ P $ \n\n $ S $  $ i $  $ L_i $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1046](http://www.lydsy.com/JudgeOnline/problem.php?id=1046)\n\n### \n $ f(i) $  $ i $ ****\n\n$$ f(i) = \\max\\limits_{j > i, a_j > a_i}\\{ f(j) \\} + 1 $$\n\n $ \\leq l $ $ l $  $ 1 $ $ l \\neq 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int f[MAXN + 1];\n\tfor (int i = n; i >= 1; i--) {\n\t\tf[i] = 1;\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"f[%d] = %d\\n\", i, f[i]);\n#endif\n\t}\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\n\t\tstatic int tmp[MAXN + 1];\n\t\tint cnt = 0;\n\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[i] >= l && a[i] > last) {\n\t\t\t\tl--;\n\t\t\t\tlast = a[i];\n\t\t\t\ttmp[++cnt] = a[i];\n\t\t\t}\n\t\t\tif (!l) break;\n\t\t}\n\n\t\tif (l) puts(\"Impossible\");\n\t\telse for (int i = 1; i <= cnt; i++) printf(\"%d%c\", tmp[i], i == cnt ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2007-lis","published":1,"updated":"2016-12-01T08:25:25.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0l0146ooxlgvaxaqja"},{"title":"HAOI2007 -  + ","date":"2016-12-13T08:37:00.000Z","_content":"\n $ L \\times L $ \n\n<!-- more -->\n\n### \n[BZOJ 1052](http://www.lydsy.com/JudgeOnline/problem.php?id=1052)\n\n### \n\n\n\n\n\n\n $ O(4 \\times 4 \\times n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Point {\n\tint x, y;\n\tbool covered[2];\n} a[MAXN + 1];\n\nstruct Rectangle {\n\tint x1, y1, x2, y2;\n};\n\nint n;\n\ninline Rectangle getBound() {\n\tRectangle rect;\n\trect.x1 = rect.y1 = INT_MAX, rect.x2 = rect.y2 = INT_MIN;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].covered[0] || a[i].covered[1]) continue;\n\t\trect.x1 = std::min(rect.x1, a[i].x);\n\t\trect.y1 = std::min(rect.y1, a[i].y);\n\t\trect.x2 = std::max(rect.x2, a[i].x);\n\t\trect.y2 = std::max(rect.y2, a[i].y);\n\t}\n\treturn rect;\n}\n\ninline void cover(int x, int y, int len, int index, bool flag) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].x >= x && a[i].x <= x + len && a[i].y >= y && a[i].y <= y + len) {\n\t\t\ta[i].covered[index] = flag;\n\t\t}\n\t}\n}\n\ninline void cover(Rectangle rect, int limit, int corner, int index, bool flag) {\n\tif (corner == 1) cover(rect.x1, rect.y1, limit, index, flag);\n\telse if (corner == 2) cover(rect.x2 - limit, rect.y1, limit, index, flag);\n\telse if (corner == 3) cover(rect.x2 - limit, rect.y2 - limit, limit, index, flag);\n\telse cover(rect.x1, rect.y2 - limit, limit, index, flag);\n}\n\ninline bool check(int limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].covered[0] = a[i].covered[1] = false;\n\t}\n\n\tRectangle rect1 = getBound();\n\tfor (int i = 1; i <= 4; i++) {\n\t\tcover(rect1, limit, i, 0, true);\n\n\t\tRectangle rect2 = getBound();\n\t\tfor (int j = 1; j <= 4; j++) {\n\t\t\tcover(rect2, limit, j, 1, true);\n\n\t\t\tRectangle rect3 = getBound();\n\t\t\tif (std::max(rect3.x2 - rect3.x1, rect3.y2 - rect3.y1) <= limit) return true;\n\n\t\t\tcover(rect2, limit, j, 1, false);\n\t\t}\n\n\t\tcover(rect1, limit, i, 0, false);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t}\n\n\tRectangle rect = getBound();\n\n\tint l = 0, r = std::max(rect.x2 - rect.x1, rect.y2 - rect.y1);\n\twhile (l < r) {\n\t\tint mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-cover.md","raw":"title: HAOI2007 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - \npermalink: haoi2007-cover\ndate: 2016-12-13 16:37:00\n---\n\n $ L \\times L $ \n\n<!-- more -->\n\n### \n[BZOJ 1052](http://www.lydsy.com/JudgeOnline/problem.php?id=1052)\n\n### \n\n\n\n\n\n\n $ O(4 \\times 4 \\times n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Point {\n\tint x, y;\n\tbool covered[2];\n} a[MAXN + 1];\n\nstruct Rectangle {\n\tint x1, y1, x2, y2;\n};\n\nint n;\n\ninline Rectangle getBound() {\n\tRectangle rect;\n\trect.x1 = rect.y1 = INT_MAX, rect.x2 = rect.y2 = INT_MIN;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].covered[0] || a[i].covered[1]) continue;\n\t\trect.x1 = std::min(rect.x1, a[i].x);\n\t\trect.y1 = std::min(rect.y1, a[i].y);\n\t\trect.x2 = std::max(rect.x2, a[i].x);\n\t\trect.y2 = std::max(rect.y2, a[i].y);\n\t}\n\treturn rect;\n}\n\ninline void cover(int x, int y, int len, int index, bool flag) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].x >= x && a[i].x <= x + len && a[i].y >= y && a[i].y <= y + len) {\n\t\t\ta[i].covered[index] = flag;\n\t\t}\n\t}\n}\n\ninline void cover(Rectangle rect, int limit, int corner, int index, bool flag) {\n\tif (corner == 1) cover(rect.x1, rect.y1, limit, index, flag);\n\telse if (corner == 2) cover(rect.x2 - limit, rect.y1, limit, index, flag);\n\telse if (corner == 3) cover(rect.x2 - limit, rect.y2 - limit, limit, index, flag);\n\telse cover(rect.x1, rect.y2 - limit, limit, index, flag);\n}\n\ninline bool check(int limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].covered[0] = a[i].covered[1] = false;\n\t}\n\n\tRectangle rect1 = getBound();\n\tfor (int i = 1; i <= 4; i++) {\n\t\tcover(rect1, limit, i, 0, true);\n\n\t\tRectangle rect2 = getBound();\n\t\tfor (int j = 1; j <= 4; j++) {\n\t\t\tcover(rect2, limit, j, 1, true);\n\n\t\t\tRectangle rect3 = getBound();\n\t\t\tif (std::max(rect3.x2 - rect3.x1, rect3.y2 - rect3.y1) <= limit) return true;\n\n\t\t\tcover(rect2, limit, j, 1, false);\n\t\t}\n\n\t\tcover(rect1, limit, i, 0, false);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t}\n\n\tRectangle rect = getBound();\n\n\tint l = 0, r = std::max(rect.x2 - rect.x1, rect.y2 - rect.y1);\n\twhile (l < r) {\n\t\tint mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```","slug":"haoi2007-cover","published":1,"updated":"2016-12-13T08:37:24.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0q014cooxluoph4st4"},{"title":"HAOI2007 - ","date":"2016-12-13T08:57:00.000Z","_content":"\n $ x $ $ g(x) $ $ g(1) = 1 $$ g(6) = 4 $ $ x $  $ i \\in (0, x) $  $ g(x) > g(i) $ $ x $ \n\n $ N $ $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1053](http://www.lydsy.com/JudgeOnline/problem.php?id=1053)\n\n### \n $ x $  $ [1, x] $  $ y < x $  $ y $  $ x $ \n\n $ 2 $ \n\n $ x $  $ x = 2 ^ {t_1} \\times 3 ^ {t_2} \\times \\ldots \\times p_k ^ {t_k} $ $ x $  $ g(x) = \\prod\\limits_{i = 1} ^ k t_i $ $ j $  $ p_j $  $ p_{j + 1} $  $ p_{j + 1} $  $ p_j $ $ p_{j + 2} \\sim p_k $ $ \\{ t_i \\} $  $ x $ \n\n $ 11 $ $ \\{ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 \\} $ $ 2 \\times 10 ^ 9 $\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2e9;\n\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\nconst int PRIMES_CNT = 11;\n\nint n, cntAns;\nlong long ans;\n\ninline void search(int i, long long x, int cnt) {\n\tif (i == PRIMES_CNT) {\n\t\tif ((cnt == cntAns && x < ans) || (cnt > cntAns)) {\n\t\t\tans = x;\n\t\t\tcntAns = cnt;\n\t\t\t// printf(\"%lld\\n\", ans);\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long t = 1;\n\tfor (int j = 0; x * t <= n; j++) {\n\t\tsearch(i + 1, x * t, cnt * (j + 1));\n\t\tt *= PRIMES[i];\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsearch(0, 1, 1);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-ant.md","raw":"title: HAOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - \npermalink: haoi2007-ant\ndate: 2016-12-13 16:57:00\n---\n\n $ x $ $ g(x) $ $ g(1) = 1 $$ g(6) = 4 $ $ x $  $ i \\in (0, x) $  $ g(x) > g(i) $ $ x $ \n\n $ N $ $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1053](http://www.lydsy.com/JudgeOnline/problem.php?id=1053)\n\n### \n $ x $  $ [1, x] $  $ y < x $  $ y $  $ x $ \n\n $ 2 $ \n\n $ x $  $ x = 2 ^ {t_1} \\times 3 ^ {t_2} \\times \\ldots \\times p_k ^ {t_k} $ $ x $  $ g(x) = \\prod\\limits_{i = 1} ^ k t_i $ $ j $  $ p_j $  $ p_{j + 1} $  $ p_{j + 1} $  $ p_j $ $ p_{j + 2} \\sim p_k $ $ \\{ t_i \\} $  $ x $ \n\n $ 11 $ $ \\{ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 \\} $ $ 2 \\times 10 ^ 9 $\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2e9;\n\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\nconst int PRIMES_CNT = 11;\n\nint n, cntAns;\nlong long ans;\n\ninline void search(int i, long long x, int cnt) {\n\tif (i == PRIMES_CNT) {\n\t\tif ((cnt == cntAns && x < ans) || (cnt > cntAns)) {\n\t\t\tans = x;\n\t\t\tcntAns = cnt;\n\t\t\t// printf(\"%lld\\n\", ans);\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long t = 1;\n\tfor (int j = 0; x * t <= n; j++) {\n\t\tsearch(i + 1, x * t, cnt * (j + 1));\n\t\tt *= PRIMES[i];\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsearch(0, 1, 1);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2007-ant","published":1,"updated":"2016-12-13T08:57:07.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s0w014iooxl1n7w1ay9"},{"title":"HAOI2006 - DP","date":"2016-12-07T00:35:00.000Z","_content":"\n $ n $  $ \\{ a_i \\} $\n\n<!-- more -->\n\n### \n[BZOJ 1049](http://www.lydsy.com/JudgeOnline/problem.php?id=1049)\n\n### \n $ a_0 = \\min\\limits_{i = 1} ^ n\\{ a_i \\} $ $ a_{n + 1} = \\max\\limits_{i = 1} ^ n\\{ a_i \\} $\n\n $ a_i $ $ k $  $ k $ $ a_i \\geq a_{i - k} + k $ $ f(i) $  $ i $  DP \n\n$$ f(i) = \\max\\limits_{j = 0} ^ {i - 1} \\{ f(j) + 1, a_i - a_j \\geq i - j \\} $$\n\n $ n - f(n + 1) + 1 $\n\n\n\n $ a_i $  $ i $ $ b_i = a_i - i $ $ \\{ b_i \\} $  $ \\{ a_i \\} $  $ b_i $  $ b_i $ \n\n $ \\mathrm{cost}(l, r) $ ** $ l $  $ r $ ** $ [l, r] $  $ g(i) $  $ i $  $ [1, i] $ \n\n$$ g(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ g(j) + \\mathrm{cost}(j, i), f(i) = f(j) + 1 \\} $$\n\n $ (i, j) $ $ k \\in (i, j) $  $ b_i \\leq b_k \\leq b_j $ $ k \\in (i, j) $ $ b_k > b_i $  $ b_k < b_j $\n\n![](haoi2006-sequence/1.svg)\n\n $ b_j $ $ b_i $\n\n![](haoi2006-sequence/2.svg)\n\n $ b_j $ $ b_i $  $ g(i) $\n\n $ O(n ^ 3) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 35000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int b[MAXN + 2];\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i] = a[i] - i;\n\n\t\tb[0] = std::min(b[0], b[i]);\n\t\tb[n + 1] = std::max(b[n + 1], b[i]);\n\t}\n\n\tstatic int f[MAXN + 2];\n\tint maxLen = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 > f[i]) {\n\t\t\t\tf[i] = f[j] + 1;\n\t\t\t\tmaxLen = std::max(maxLen, f[i]);\n\t\t\t}\n\t\t}\n#ifdef DBG\n\t\tprintf(\"b[%d] = %d, f[%d] = %d\\n\", i, b[i], i, f[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", n - f[n + 1] + 1);\n\n\tstatic int g[MAXN + 2];\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tg[i] = INT_MAX;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 == f[i]) {\n\t\t\t\tint w = 0;\n\t\t\t\tfor (int k = i - 1; k > j; k--) w += abs(b[k] - b[j]);\n\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\tfor (int k = i - 1; k > j; k--) {\n\t\t\t\t\tw -= abs(b[k] - b[j]);\n\t\t\t\t\tw += abs(b[k] - b[i]);\n\t\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(g[i] != INT_MAX);\n#ifdef DBG\n\t\tprintf(\"g[%d] = %d\\n\", i, g[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", g[n + 1]);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2006-sequence.md","raw":"title: HAOI2006 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\npermalink: haoi2006-sequence\ndate: 2016-12-07 08:35:00\n---\n\n $ n $  $ \\{ a_i \\} $\n\n<!-- more -->\n\n### \n[BZOJ 1049](http://www.lydsy.com/JudgeOnline/problem.php?id=1049)\n\n### \n $ a_0 = \\min\\limits_{i = 1} ^ n\\{ a_i \\} $ $ a_{n + 1} = \\max\\limits_{i = 1} ^ n\\{ a_i \\} $\n\n $ a_i $ $ k $  $ k $ $ a_i \\geq a_{i - k} + k $ $ f(i) $  $ i $  DP \n\n$$ f(i) = \\max\\limits_{j = 0} ^ {i - 1} \\{ f(j) + 1, a_i - a_j \\geq i - j \\} $$\n\n $ n - f(n + 1) + 1 $\n\n\n\n $ a_i $  $ i $ $ b_i = a_i - i $ $ \\{ b_i \\} $  $ \\{ a_i \\} $  $ b_i $  $ b_i $ \n\n $ \\mathrm{cost}(l, r) $ ** $ l $  $ r $ ** $ [l, r] $  $ g(i) $  $ i $  $ [1, i] $ \n\n$$ g(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ g(j) + \\mathrm{cost}(j, i), f(i) = f(j) + 1 \\} $$\n\n $ (i, j) $ $ k \\in (i, j) $  $ b_i \\leq b_k \\leq b_j $ $ k \\in (i, j) $ $ b_k > b_i $  $ b_k < b_j $\n\n![](haoi2006-sequence/1.svg)\n\n $ b_j $ $ b_i $\n\n![](haoi2006-sequence/2.svg)\n\n $ b_j $ $ b_i $  $ g(i) $\n\n $ O(n ^ 3) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 35000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int b[MAXN + 2];\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i] = a[i] - i;\n\n\t\tb[0] = std::min(b[0], b[i]);\n\t\tb[n + 1] = std::max(b[n + 1], b[i]);\n\t}\n\n\tstatic int f[MAXN + 2];\n\tint maxLen = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 > f[i]) {\n\t\t\t\tf[i] = f[j] + 1;\n\t\t\t\tmaxLen = std::max(maxLen, f[i]);\n\t\t\t}\n\t\t}\n#ifdef DBG\n\t\tprintf(\"b[%d] = %d, f[%d] = %d\\n\", i, b[i], i, f[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", n - f[n + 1] + 1);\n\n\tstatic int g[MAXN + 2];\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tg[i] = INT_MAX;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 == f[i]) {\n\t\t\t\tint w = 0;\n\t\t\t\tfor (int k = i - 1; k > j; k--) w += abs(b[k] - b[j]);\n\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\tfor (int k = i - 1; k > j; k--) {\n\t\t\t\t\tw -= abs(b[k] - b[j]);\n\t\t\t\t\tw += abs(b[k] - b[i]);\n\t\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(g[i] != INT_MAX);\n#ifdef DBG\n\t\tprintf(\"g[%d] = %d\\n\", i, g[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", g[n + 1]);\n\n\treturn 0;\n}\n```","slug":"haoi2006-sequence","published":1,"updated":"2016-12-07T00:36:12.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s11014oooxlk15ca9gr"},{"title":"HAOI2006 - ","date":"2016-03-04T13:28:17.000Z","_content":"\n $ N $  $ M $  $ (A,B) $ $ A $  $ B $   $ A $  $ B $ $ B $  $ C $  $ A $  $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2006-cow.md","raw":"title: HAOI2006 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - Tarjan\n  - \npermalink: haoi2006-cow\ndate: 2016-03-04 21:28:17\n---\n\n $ N $  $ M $  $ (A,B) $ $ A $  $ B $   $ A $  $ B $ $ B $  $ C $  $ A $  $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","slug":"haoi2006-cow","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s1a014tooxlrxx0i9sh"},{"title":"GDB ","id":"41","updated":"2016-02-05T02:59:41.000Z","date":"2016-02-05T02:58:07.000Z","_content":"\nGDBGNU Debugger GNU  UNIXLinux  Windows  CC++Pascal \n\n<!-- more -->\n\n### \n#### Linux\n Ubuntu  `apt`  GDB\n```bash\nsudo apt-get install gdb\n```\nNOI Linux  GDB\n\n RHEL/Fedora/Archlinux  GDB\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n Windows  Cygwin/MSYS2  GDB MinGW \n\nDev-C++  MinGW `bin`  `gdb.exe` `bin`  `PATH`  `cmd`  `gdb` \n\n### \n `gdb` Windows  GDB\n```bash\ngdb\n```\n GDB  `file` \n```bash\n(gdb) file test\n```\n GDB \n```bash\ngdb test\n```\n `test` \n\n GDB ** `-g` **\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB \n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### \n `run` `r`\n```bash\n(gdb) run\n```\n\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\nRuntime ErrorRE\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n `SIGSEGV` Segmentation fault `6` \n\n\n\n### \n `quit` `q`\n\n `q`  GDB\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n `y`  GDB\n\n### \n `break` `b`\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n `r`  `528` \n\nPascal  `==`  `=`\n\n### \n `continue` `c`\n\n********   \n\n `step` `s`\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n Pascal \n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n `next` `n`****\n\n\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### \n GDB \n\n `print` `p`\n\n A + B \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n `display` `disp`\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n GDB 7.0  `p`  STL \n\n### \n `backtrace` `bt`\n\n\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n 272043 \n\n`bt` \n\n `frame` \n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n`frame 3`  `d(x)`  `p x`  `4`\n\n`frame`  STL  STL \n\n### \n `list` `l`\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","source":"_posts/gnu-debugger.md","raw":"title: GDB \ncategories: OI\ntags: \n  - GDB\n  - \n  - C++\npermalink: gnu-debugger\nid: 41\nupdated: '2016-02-05 10:59:41'\ndate: 2016-02-05 10:58:07\n---\n\nGDBGNU Debugger GNU  UNIXLinux  Windows  CC++Pascal \n\n<!-- more -->\n\n### \n#### Linux\n Ubuntu  `apt`  GDB\n```bash\nsudo apt-get install gdb\n```\nNOI Linux  GDB\n\n RHEL/Fedora/Archlinux  GDB\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n Windows  Cygwin/MSYS2  GDB MinGW \n\nDev-C++  MinGW `bin`  `gdb.exe` `bin`  `PATH`  `cmd`  `gdb` \n\n### \n `gdb` Windows  GDB\n```bash\ngdb\n```\n GDB  `file` \n```bash\n(gdb) file test\n```\n GDB \n```bash\ngdb test\n```\n `test` \n\n GDB ** `-g` **\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB \n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### \n `run` `r`\n```bash\n(gdb) run\n```\n\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\nRuntime ErrorRE\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n `SIGSEGV` Segmentation fault `6` \n\n\n\n### \n `quit` `q`\n\n `q`  GDB\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n `y`  GDB\n\n### \n `break` `b`\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n `r`  `528` \n\nPascal  `==`  `=`\n\n### \n `continue` `c`\n\n********   \n\n `step` `s`\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n Pascal \n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n `next` `n`****\n\n\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### \n GDB \n\n `print` `p`\n\n A + B \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n `display` `disp`\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n GDB 7.0  `p`  STL \n\n### \n `backtrace` `bt`\n\n\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n 272043 \n\n`bt` \n\n `frame` \n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n`frame 3`  `d(x)`  `p x`  `4`\n\n`frame`  STL  STL \n\n### \n `list` `l`\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","slug":"gnu-debugger","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s1g0150ooxltpgq3ka0"},{"title":"","date":"2017-01-06T08:30:00.000Z","_content":"\nComputational Geometry\n\n OI \n\n<!-- more -->\n\n### \n `double`  $ a $$ b $ $ | a - b | \\leq d $ $ a = b $$ d $ `EPS` $ 10 ^ {-8} $\n\n```c++\nconst double EPS = 1e-8;\n\n//  x  y\ninline bool dcmp(double x, double y = 0)\n{\n\treturn fabs(x - y) <= EPS;\n}\n```\n\n### \nvector********   $ A $  $ B $  $ \\overrightarrow{AB} $\n\n$ \\overrightarrow{AB} $ $ \\boldsymbol{a} $\n\n   $ (0, 0) $ ****\n\n $ \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $  $ \\boldsymbol{a} $  $ \\boldsymbol{b} $ \n\nnorm $ \\overrightarrow{AB} = (x, y) $  $ x ^ 2 + y ^ 2 $ $ | \\overrightarrow{AB} | ^ 2 $\n\n****scalar\n\n### \n$ (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2) $\n\n\n\n $ k $ $ k $  $ k $ \n\n\n\n```c++\n/* \n * Vector\n *\n *  (x, y) \n *  A  B  A - B\n */\ntypedef struct Vec\n{\n\tdouble x, y;\n\n\tVec(double x = 0, double y = 0) : x(x), y(y) {}\n\n\t// \n\tVec operator+(const Vec &v) const\n\t{\n\t\treturn Vec(x + v.x, y - v.y);\n\t}\n\n\t// \n\tVec operator-(const Vec &v) const\n\t{\n\t\treturn Vec(x - v.x, y - v.y);\n\t}\n\n\t// \n\tVec operator*(double d) const\n\t{\n\t\treturn Vec(x * d, y * d);\n\t}\n\n\tVec operator/(const double d) const\n\t{\n\t\treturn Vec(x / d, y / d);\n\t}\n\n\t// \n\tdouble norm() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n} Pt;\n```\n\n `Pt`  `Vec` \n\n*  $ + $  $ = $ \n*  $ + $  $ = $ \n*  $ \\times $  $ = $ \n\n### \n  DotCross\n\n#### \n $ \\boldsymbol{a} \\cdot \\boldsymbol{b} $ $ \\boldsymbol{a} = (x_1, y_1), \\boldsymbol{b} = (x_2, y_2) $\n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = x_1x_2 + y_1y_2 $$\n\n $ \\boldsymbol{a} $  $ \\boldsymbol{b} $  $ \\boldsymbol{b} $ \n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\cos \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $$\n\n $ \\cos-\\alpha = \\cos \\alpha $ $ \\cos \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle = \\cos \\langle \\boldsymbol{b}, \\boldsymbol{a} \\rangle $****\n\n#### \n $ \\boldsymbol{a} \\times \\boldsymbol{b} $ $ \\boldsymbol{a} = (x_1, y_1), \\boldsymbol{b} = (x_2, y_2) $\n\n$$ \\boldsymbol{a} \\times \\boldsymbol{b} = x_1y_2 - x_2y_1 $$\n\n $ \\boldsymbol{a} $  $ \\boldsymbol{b} $ \n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $$\n\n![](geometry-notes/1.svg)\n\n $ \\boldsymbol{b} $  $ \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $\n\n $ \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $  $ \\boldsymbol{b} $  $ \\boldsymbol{a} $ \n\n\n\n#### \n```c++\n// \ndouble dot(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// \ndouble cross(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n```\n\n### \n\n\n****\n\n#### \n $ P $  $ \\overrightarrow{PA} $$ \\overrightarrow{PB} $  $ \\overrightarrow{PA} \\times \\overrightarrow{PB} = 0 $\n\n```c++\nbool include(const Pt &p) const\n{\n    return dcmp(cross(a - p, b - p));\n}\n```\n\n#### \n* \n* \n\n```c++\n// \n// 0 \n// 1 \n// -1 \nstatic int relation(const Line &a, const Line &b)\n{\n    if (a.include(b.a) && a.include(b.b)) return -1;\n    else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0;\n    else return 1;\n}\n```\n\n#### \n $ AB $$ CD $  $ P $ $ A $$ B $  $ CD $  $ AB $$ BC $$ CD $$ DA $ $ \\overrightarrow{AP} $ $ \\overrightarrow{AP} $ $ P = A + \\overrightarrow{AP} $\n\n![](geometry-notes/5.svg)\n\n $ \\angle AFP = \\angle BGP = 90 ^\\circ, \\angle APF = \\angle BPG $  \n $ \\triangle AFP \\sim \\triangle BGP $  \n $ \\frac{\\overrightarrow{AP}}{\\overrightarrow{PB}} = \\frac{|AF|}{|BG|} = \\frac{S_{\\triangle ACD}}{S_{\\triangle BCD}} $  \n $ \\frac{\\overrightarrow{AP}}{\\overrightarrow{AB}} = \\frac{\\overrightarrow{AP}}{\\overrightarrow{AP} + \\overrightarrow{PB}} = \\frac{S_{\\triangle ACD}}{S_{\\triangle ACD} + S_{\\triangle BCD}} = \\frac{2S_{\\triangle ACD}}{2S_{\\triangle ACD} + 2S_{\\triangle BCD}} $\n\n $ \\overrightarrow{AP} $ \n\n```c++\n// \nstatic Pt intersect(const Line &a, const Line &b)\n{\n    double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b);\n    return a.a + (a.b - a.a) * s1 / (s1 + s2);\n}\n```\n\n#### \n $ P $  $ AB $  $ \\overrightarrow{PA} $$ \\overrightarrow{PB} $  $ \\overrightarrow{PA} \\times \\overrightarrow{PB} = 0 $\n\n $ P $  $ A $  $ B $ \n\n*  $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} > 0 $ $ \\langle \\overrightarrow{PA}, \\overrightarrow{PB} \\rangle = 0 ^\\circ $$ \\cos 0 ^\\circ = 1 > 0 $\n*  $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} < 0 $ $ \\langle \\overrightarrow{PA}, \\overrightarrow{PB} \\rangle = \\pm180 ^\\circ $$ \\cos \\pm180 ^\\circ = -1 $\n*  $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} = 0 $ $ \\overrightarrow{PA} = 0 $  $ \\overrightarrow{PB} = 0 $ $ P $  $ A $  $ B $ \n\n $ P $  $ AB $ \n\n```c++\n// \nbool include(const Pt &p) const\n{\n    // PA  PB = 0PA  PB \n    // PA  PB = 0PA  PB A  B  P  PA  PB = 0  P = A  P = B\n    return dcmp(cross(a - p, b - p)) && dot(a - p, b - p) <= 0;\n}\n```\n\n####  / \n\n\n### \npolygon\n\n```c++\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n};\n```\n\n#### \n**** $ x $ \n\n $ A $  $ B $ $ P $  $ AB $  $ \\overrightarrow{PA}, \\overrightarrow{PB} $ $ A $$ B $  $ x $  $ C $$ D $ $ \\overrightarrow{CA} = d_1, \\overrightarrow{DB} = d_2 $\n\n $ \\overrightarrow{PB} $  $ \\overrightarrow{PA} $  $ \\overrightarrow{PA} \\times \\overrightarrow{PB} < 0 $ $ A $  $ C $ $ B $  $ D $  $ d_1 \\leq 0, d_2 > 0 $\n\n![ 1](geometry-notes/2.svg)\n\n $ d_1 $  $ 0 $ $ A $ \n\n![](geometry-notes/4.svg)\n\n $ D $  $ B $  $ B $ \n\n $ \\overrightarrow{PB} $  $ \\overrightarrow{PA} $  $ \\overrightarrow{PA} \\times \\overrightarrow{PB} > 0 $ $ A $  $ C $ $ B $  $ D $  $ d_1 < 0, d_2 \\geq 0 $\n\n![ 2](geometry-notes/3.svg)\n\n##### \n```c++\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\tbool include(const Pt &p) const\n\t{\n\t\tint cnt = 0;\n\t\t// \n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// \n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\n\t\t\t//  P  AB \n\t\t\tif (Seg(a, b).include(p)) return true;\n\n\t\t\t// \n\t\t\tdouble d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p);\n\t\t\tif ((tmp >= 0 && d1 >= 0 && d2 < 0) || (tmp <= 0 && d1 < 0 && d2 >= 0)) cnt++;\n\t\t}\n\n\t\t// \n\t\treturn cnt % 2 == 1;\n\t}\n};\n```\n\n#### \n\n\n![](geometry-notes/6.svg)\n\n $ E $ \n\n\n\n```c++\n// \ndouble area() const\n{\n    double res = 0;\n    for (size_t i = 0; i < pts.size(); i++)\n    {\n        // \n        const Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n        res += cross(a, b);\n    }\n    return res / 2;\n}\n```\n\n### \n****Convex Hull\n\n Graham's Scan\n\n1. \n2. \n3. \n\n $ P $  $ \\boldsymbol{a} $ $ A $  $ \\langle \\boldsymbol{a}, \\overrightarrow{PA} \\rangle $ $ A $$ B $  $ \\overrightarrow{PA} $  $ \\overrightarrow{PB} $ $ \\overrightarrow{PA} \\times \\overrightarrow{PB} > 0 $ $ A $ \n\n\n\n![](geometry-notes/7.svg)\n\n $ A $$ B $$ C $$ D $ $ E $   $ \\overrightarrow{DE} $  $ \\overrightarrow{CD} $  $ \\overrightarrow{CD} \\times \\overrightarrow{DE} \\leq 0 $ $ D $  $ E $  $ DE $ \n\n\n\n```c++\n// \nint n;\nPt a[MAXN + 1];\n\n// \ninline bool compare(const Pt &a, const Pt &b)\n{\n\t// \n\tVec va = a - ::a[1], vb = b - ::a[1];\n\tdouble t = cross(va, vb);\n\tif (!dcmp(t)) return t > 0; // OA -> OB  A \n\telse return va.norm() < vb.norm(); // norm \n}\n\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\t// Convex pts \n\tvoid convex()\n\t{\n\t\t// \n\t\tint id = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i].x < a[id].x || (a[i].x == a[id].x && a[i].y < a[id].y)) id = i;\n\t\t}\n\t\tif (id != 1) std::swap(a[1], a[id]);\n\n\t\t// \n\t\tstd::sort(a + 2, a + n + 1, &compare);\n\n\t\t// \n\t\tpts.push_back(a[1]);\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\t// pop_back\n\t\t\twhile (pts.size() >= 2 && cross(pts.back() - pts[pts.size() - 2], a[i] - pts.back()) <= 0) pts.pop_back();\n\t\t\tpts.push_back(a[i]);\n\t\t}\n\t}\n};\n```\n\n### \n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 100000;\nconst double EPS = 1e-8;\n\n// \ninline bool dcmp(double x, double y = 0)\n{\n\treturn fabs(x - y) <= EPS;\n}\n\n/* \n * Vector\n *\n *  (x, y) \n *  A  B  A - B\n */\ntypedef struct Vec\n{\n\tdouble x, y;\n\n\tVec(double x = 0, double y = 0) : x(x), y(y) {}\n\n\t// \n\tVec operator+(const Vec &v) const\n\t{\n\t\treturn Vec(x + v.x, y - v.y);\n\t}\n\n\t// \n\tVec operator-(const Vec &v) const\n\t{\n\t\treturn Vec(x - v.x, y - v.y);\n\t}\n\n\t// \n\tVec operator*(double d) const\n\t{\n\t\treturn Vec(x * d, y * d);\n\t}\n\n\tVec operator/(const double d) const\n\t{\n\t\treturn Vec(x / d, y / d);\n\t}\n\n\t// \n\tdouble norm() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n} Pt;\n\n// \ndouble dot(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// \ndouble cross(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// Segment\nstruct Seg\n{\n\tPt a, b;\n\n\tSeg(const Pt &a, const Pt &b) : a(a), b(b) {}\n\n\t// \n\tbool include(const Pt &p)\n\t{\n\t\t// PA  PB = 0PA  PB \n\t\t// PA  PB = 0PA  PB A  B  P  PA  PB = 0  P = A  P = B\n\t\treturn dcmp(cross(a - p, b - p)) && dot(a - p, b - p) <= 0;\n\t}\n};\n\n// \nstruct Line\n{\n\tPt a, b;\n\n\tLine() {} // \n\tLine(const Pt &a, const Pt &b) : a(a), b(b) {}\n\n\tbool include(const Pt &p) const\n\t{\n\t\treturn dcmp(cross(a - p, b - p));\n\t}\n\n\t// \n\t// 0 \n\t// 1 \n\t// -1 \n\tstatic int relation(const Line &a, const Line &b)\n\t{\n\t\tif (a.include(b.a) && a.include(b.b)) return -1;\n\t\telse if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0;\n\t\telse return 1;\n\t}\n\n\t// \n\tstatic Pt intersect(const Line &a, const Line &b)\n\t{\n\t\tdouble s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b);\n\t\treturn a.a + (a.b - a.a) * s1 / (s1 + s2);\n\t}\n};\n\n// \nint n;\nPt a[MAXN + 1];\n\n// \ninline bool compare(const Pt &a, const Pt &b)\n{\n\t// \n\tVec va = a - ::a[1], vb = b - ::a[1];\n\tdouble t = cross(va, vb);\n\tif (!dcmp(t)) return t > 0; // OA -> OB  A \n\telse return va.norm() < vb.norm(); // norm \n}\n\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\tbool include(const Pt &p) const\n\t{\n\t\tint cnt = 0;\n\t\t// \n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// \n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\n\t\t\t//  P  AB \n\t\t\tif (Seg(a, b).include(p)) return true;\n\n\t\t\t// \n\t\t\tdouble d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p);\n\t\t\tif ((tmp >= 0 && d1 >= 0 && d2 < 0) || (tmp <= 0 && d1 < 0 && d2 >= 0)) cnt++;\n\t\t}\n\n\t\t// \n\t\treturn cnt % 2 == 1;\n\t}\n\n\t// \n\tdouble area() const\n\t{\n\t\tdouble res = 0;\n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// \n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\t\t\tres += cross(a, b);\n\t\t}\n\t\treturn res / 2;\n\t}\n\n\t// Convex pts \n\tvoid convex()\n\t{\n\t\t// \n\t\tint id = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i].x < a[id].x || (a[i].x == a[id].x && a[i].y < a[id].y)) id = i;\n\t\t}\n\t\tif (id != 1) std::swap(a[1], a[id]);\n\n\t\t// \n\t\tstd::sort(a + 2, a + n + 1, &compare);\n\n\t\t// \n\t\tpts.push_back(a[1]);\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\t// pop_back\n\t\t\twhile (pts.size() >= 2 && cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) >= 0) pts.pop_back();\n\t\t\tpts.push_back(a[i]);\n\t\t}\n\t}\n};\n```\n","source":"_posts/geometry-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: geometry-notes\ndate: 2017-01-06 16:30:00\n---\n\nComputational Geometry\n\n OI \n\n<!-- more -->\n\n### \n `double`  $ a $$ b $ $ | a - b | \\leq d $ $ a = b $$ d $ `EPS` $ 10 ^ {-8} $\n\n```c++\nconst double EPS = 1e-8;\n\n//  x  y\ninline bool dcmp(double x, double y = 0)\n{\n\treturn fabs(x - y) <= EPS;\n}\n```\n\n### \nvector********   $ A $  $ B $  $ \\overrightarrow{AB} $\n\n$ \\overrightarrow{AB} $ $ \\boldsymbol{a} $\n\n   $ (0, 0) $ ****\n\n $ \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $  $ \\boldsymbol{a} $  $ \\boldsymbol{b} $ \n\nnorm $ \\overrightarrow{AB} = (x, y) $  $ x ^ 2 + y ^ 2 $ $ | \\overrightarrow{AB} | ^ 2 $\n\n****scalar\n\n### \n$ (x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2) $\n\n\n\n $ k $ $ k $  $ k $ \n\n\n\n```c++\n/* \n * Vector\n *\n *  (x, y) \n *  A  B  A - B\n */\ntypedef struct Vec\n{\n\tdouble x, y;\n\n\tVec(double x = 0, double y = 0) : x(x), y(y) {}\n\n\t// \n\tVec operator+(const Vec &v) const\n\t{\n\t\treturn Vec(x + v.x, y - v.y);\n\t}\n\n\t// \n\tVec operator-(const Vec &v) const\n\t{\n\t\treturn Vec(x - v.x, y - v.y);\n\t}\n\n\t// \n\tVec operator*(double d) const\n\t{\n\t\treturn Vec(x * d, y * d);\n\t}\n\n\tVec operator/(const double d) const\n\t{\n\t\treturn Vec(x / d, y / d);\n\t}\n\n\t// \n\tdouble norm() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n} Pt;\n```\n\n `Pt`  `Vec` \n\n*  $ + $  $ = $ \n*  $ + $  $ = $ \n*  $ \\times $  $ = $ \n\n### \n  DotCross\n\n#### \n $ \\boldsymbol{a} \\cdot \\boldsymbol{b} $ $ \\boldsymbol{a} = (x_1, y_1), \\boldsymbol{b} = (x_2, y_2) $\n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = x_1x_2 + y_1y_2 $$\n\n $ \\boldsymbol{a} $  $ \\boldsymbol{b} $  $ \\boldsymbol{b} $ \n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\cos \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $$\n\n $ \\cos-\\alpha = \\cos \\alpha $ $ \\cos \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle = \\cos \\langle \\boldsymbol{b}, \\boldsymbol{a} \\rangle $****\n\n#### \n $ \\boldsymbol{a} \\times \\boldsymbol{b} $ $ \\boldsymbol{a} = (x_1, y_1), \\boldsymbol{b} = (x_2, y_2) $\n\n$$ \\boldsymbol{a} \\times \\boldsymbol{b} = x_1y_2 - x_2y_1 $$\n\n $ \\boldsymbol{a} $  $ \\boldsymbol{b} $ \n\n$$ \\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $$\n\n![](geometry-notes/1.svg)\n\n $ \\boldsymbol{b} $  $ \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $\n\n $ \\sin \\langle \\boldsymbol{a}, \\boldsymbol{b} \\rangle $  $ \\boldsymbol{b} $  $ \\boldsymbol{a} $ \n\n\n\n#### \n```c++\n// \ndouble dot(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// \ndouble cross(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n```\n\n### \n\n\n****\n\n#### \n $ P $  $ \\overrightarrow{PA} $$ \\overrightarrow{PB} $  $ \\overrightarrow{PA} \\times \\overrightarrow{PB} = 0 $\n\n```c++\nbool include(const Pt &p) const\n{\n    return dcmp(cross(a - p, b - p));\n}\n```\n\n#### \n* \n* \n\n```c++\n// \n// 0 \n// 1 \n// -1 \nstatic int relation(const Line &a, const Line &b)\n{\n    if (a.include(b.a) && a.include(b.b)) return -1;\n    else if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0;\n    else return 1;\n}\n```\n\n#### \n $ AB $$ CD $  $ P $ $ A $$ B $  $ CD $  $ AB $$ BC $$ CD $$ DA $ $ \\overrightarrow{AP} $ $ \\overrightarrow{AP} $ $ P = A + \\overrightarrow{AP} $\n\n![](geometry-notes/5.svg)\n\n $ \\angle AFP = \\angle BGP = 90 ^\\circ, \\angle APF = \\angle BPG $  \n $ \\triangle AFP \\sim \\triangle BGP $  \n $ \\frac{\\overrightarrow{AP}}{\\overrightarrow{PB}} = \\frac{|AF|}{|BG|} = \\frac{S_{\\triangle ACD}}{S_{\\triangle BCD}} $  \n $ \\frac{\\overrightarrow{AP}}{\\overrightarrow{AB}} = \\frac{\\overrightarrow{AP}}{\\overrightarrow{AP} + \\overrightarrow{PB}} = \\frac{S_{\\triangle ACD}}{S_{\\triangle ACD} + S_{\\triangle BCD}} = \\frac{2S_{\\triangle ACD}}{2S_{\\triangle ACD} + 2S_{\\triangle BCD}} $\n\n $ \\overrightarrow{AP} $ \n\n```c++\n// \nstatic Pt intersect(const Line &a, const Line &b)\n{\n    double s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b);\n    return a.a + (a.b - a.a) * s1 / (s1 + s2);\n}\n```\n\n#### \n $ P $  $ AB $  $ \\overrightarrow{PA} $$ \\overrightarrow{PB} $  $ \\overrightarrow{PA} \\times \\overrightarrow{PB} = 0 $\n\n $ P $  $ A $  $ B $ \n\n*  $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} > 0 $ $ \\langle \\overrightarrow{PA}, \\overrightarrow{PB} \\rangle = 0 ^\\circ $$ \\cos 0 ^\\circ = 1 > 0 $\n*  $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} < 0 $ $ \\langle \\overrightarrow{PA}, \\overrightarrow{PB} \\rangle = \\pm180 ^\\circ $$ \\cos \\pm180 ^\\circ = -1 $\n*  $ \\overrightarrow{PA} \\cdot \\overrightarrow{PB} = 0 $ $ \\overrightarrow{PA} = 0 $  $ \\overrightarrow{PB} = 0 $ $ P $  $ A $  $ B $ \n\n $ P $  $ AB $ \n\n```c++\n// \nbool include(const Pt &p) const\n{\n    // PA  PB = 0PA  PB \n    // PA  PB = 0PA  PB A  B  P  PA  PB = 0  P = A  P = B\n    return dcmp(cross(a - p, b - p)) && dot(a - p, b - p) <= 0;\n}\n```\n\n####  / \n\n\n### \npolygon\n\n```c++\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n};\n```\n\n#### \n**** $ x $ \n\n $ A $  $ B $ $ P $  $ AB $  $ \\overrightarrow{PA}, \\overrightarrow{PB} $ $ A $$ B $  $ x $  $ C $$ D $ $ \\overrightarrow{CA} = d_1, \\overrightarrow{DB} = d_2 $\n\n $ \\overrightarrow{PB} $  $ \\overrightarrow{PA} $  $ \\overrightarrow{PA} \\times \\overrightarrow{PB} < 0 $ $ A $  $ C $ $ B $  $ D $  $ d_1 \\leq 0, d_2 > 0 $\n\n![ 1](geometry-notes/2.svg)\n\n $ d_1 $  $ 0 $ $ A $ \n\n![](geometry-notes/4.svg)\n\n $ D $  $ B $  $ B $ \n\n $ \\overrightarrow{PB} $  $ \\overrightarrow{PA} $  $ \\overrightarrow{PA} \\times \\overrightarrow{PB} > 0 $ $ A $  $ C $ $ B $  $ D $  $ d_1 < 0, d_2 \\geq 0 $\n\n![ 2](geometry-notes/3.svg)\n\n##### \n```c++\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\tbool include(const Pt &p) const\n\t{\n\t\tint cnt = 0;\n\t\t// \n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// \n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\n\t\t\t//  P  AB \n\t\t\tif (Seg(a, b).include(p)) return true;\n\n\t\t\t// \n\t\t\tdouble d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p);\n\t\t\tif ((tmp >= 0 && d1 >= 0 && d2 < 0) || (tmp <= 0 && d1 < 0 && d2 >= 0)) cnt++;\n\t\t}\n\n\t\t// \n\t\treturn cnt % 2 == 1;\n\t}\n};\n```\n\n#### \n\n\n![](geometry-notes/6.svg)\n\n $ E $ \n\n\n\n```c++\n// \ndouble area() const\n{\n    double res = 0;\n    for (size_t i = 0; i < pts.size(); i++)\n    {\n        // \n        const Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n        res += cross(a, b);\n    }\n    return res / 2;\n}\n```\n\n### \n****Convex Hull\n\n Graham's Scan\n\n1. \n2. \n3. \n\n $ P $  $ \\boldsymbol{a} $ $ A $  $ \\langle \\boldsymbol{a}, \\overrightarrow{PA} \\rangle $ $ A $$ B $  $ \\overrightarrow{PA} $  $ \\overrightarrow{PB} $ $ \\overrightarrow{PA} \\times \\overrightarrow{PB} > 0 $ $ A $ \n\n\n\n![](geometry-notes/7.svg)\n\n $ A $$ B $$ C $$ D $ $ E $   $ \\overrightarrow{DE} $  $ \\overrightarrow{CD} $  $ \\overrightarrow{CD} \\times \\overrightarrow{DE} \\leq 0 $ $ D $  $ E $  $ DE $ \n\n\n\n```c++\n// \nint n;\nPt a[MAXN + 1];\n\n// \ninline bool compare(const Pt &a, const Pt &b)\n{\n\t// \n\tVec va = a - ::a[1], vb = b - ::a[1];\n\tdouble t = cross(va, vb);\n\tif (!dcmp(t)) return t > 0; // OA -> OB  A \n\telse return va.norm() < vb.norm(); // norm \n}\n\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\t// Convex pts \n\tvoid convex()\n\t{\n\t\t// \n\t\tint id = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i].x < a[id].x || (a[i].x == a[id].x && a[i].y < a[id].y)) id = i;\n\t\t}\n\t\tif (id != 1) std::swap(a[1], a[id]);\n\n\t\t// \n\t\tstd::sort(a + 2, a + n + 1, &compare);\n\n\t\t// \n\t\tpts.push_back(a[1]);\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\t// pop_back\n\t\t\twhile (pts.size() >= 2 && cross(pts.back() - pts[pts.size() - 2], a[i] - pts.back()) <= 0) pts.pop_back();\n\t\t\tpts.push_back(a[i]);\n\t\t}\n\t}\n};\n```\n\n### \n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 100000;\nconst double EPS = 1e-8;\n\n// \ninline bool dcmp(double x, double y = 0)\n{\n\treturn fabs(x - y) <= EPS;\n}\n\n/* \n * Vector\n *\n *  (x, y) \n *  A  B  A - B\n */\ntypedef struct Vec\n{\n\tdouble x, y;\n\n\tVec(double x = 0, double y = 0) : x(x), y(y) {}\n\n\t// \n\tVec operator+(const Vec &v) const\n\t{\n\t\treturn Vec(x + v.x, y - v.y);\n\t}\n\n\t// \n\tVec operator-(const Vec &v) const\n\t{\n\t\treturn Vec(x - v.x, y - v.y);\n\t}\n\n\t// \n\tVec operator*(double d) const\n\t{\n\t\treturn Vec(x * d, y * d);\n\t}\n\n\tVec operator/(const double d) const\n\t{\n\t\treturn Vec(x / d, y / d);\n\t}\n\n\t// \n\tdouble norm() const\n\t{\n\t\treturn x * x + y * y;\n\t}\n} Pt;\n\n// \ndouble dot(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\n\n// \ndouble cross(const Vec &a, const Vec &b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n// Segment\nstruct Seg\n{\n\tPt a, b;\n\n\tSeg(const Pt &a, const Pt &b) : a(a), b(b) {}\n\n\t// \n\tbool include(const Pt &p)\n\t{\n\t\t// PA  PB = 0PA  PB \n\t\t// PA  PB = 0PA  PB A  B  P  PA  PB = 0  P = A  P = B\n\t\treturn dcmp(cross(a - p, b - p)) && dot(a - p, b - p) <= 0;\n\t}\n};\n\n// \nstruct Line\n{\n\tPt a, b;\n\n\tLine() {} // \n\tLine(const Pt &a, const Pt &b) : a(a), b(b) {}\n\n\tbool include(const Pt &p) const\n\t{\n\t\treturn dcmp(cross(a - p, b - p));\n\t}\n\n\t// \n\t// 0 \n\t// 1 \n\t// -1 \n\tstatic int relation(const Line &a, const Line &b)\n\t{\n\t\tif (a.include(b.a) && a.include(b.b)) return -1;\n\t\telse if (dcmp(cross(a.b - a.a, b.b - b.a))) return 0;\n\t\telse return 1;\n\t}\n\n\t// \n\tstatic Pt intersect(const Line &a, const Line &b)\n\t{\n\t\tdouble s1 = cross(b.a - a.a, b.b - a.a), s2 = cross(b.b - a.b, b.a - a.b);\n\t\treturn a.a + (a.b - a.a) * s1 / (s1 + s2);\n\t}\n};\n\n// \nint n;\nPt a[MAXN + 1];\n\n// \ninline bool compare(const Pt &a, const Pt &b)\n{\n\t// \n\tVec va = a - ::a[1], vb = b - ::a[1];\n\tdouble t = cross(va, vb);\n\tif (!dcmp(t)) return t > 0; // OA -> OB  A \n\telse return va.norm() < vb.norm(); // norm \n}\n\nstruct Poly\n{\n\tstd::vector<Pt> pts;\n\n\tbool include(const Pt &p) const\n\t{\n\t\tint cnt = 0;\n\t\t// \n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// \n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\n\t\t\t//  P  AB \n\t\t\tif (Seg(a, b).include(p)) return true;\n\n\t\t\t// \n\t\t\tdouble d1 = a.y - p.y, d2 = b.y - p.y, tmp = cross(a - p, b - p);\n\t\t\tif ((tmp >= 0 && d1 >= 0 && d2 < 0) || (tmp <= 0 && d1 < 0 && d2 >= 0)) cnt++;\n\t\t}\n\n\t\t// \n\t\treturn cnt % 2 == 1;\n\t}\n\n\t// \n\tdouble area() const\n\t{\n\t\tdouble res = 0;\n\t\tfor (size_t i = 0; i < pts.size(); i++)\n\t\t{\n\t\t\t// \n\t\t\tconst Pt &a = pts[i], &b = pts[(i + 1) % pts.size()];\n\t\t\tres += cross(a, b);\n\t\t}\n\t\treturn res / 2;\n\t}\n\n\t// Convex pts \n\tvoid convex()\n\t{\n\t\t// \n\t\tint id = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (a[i].x < a[id].x || (a[i].x == a[id].x && a[i].y < a[id].y)) id = i;\n\t\t}\n\t\tif (id != 1) std::swap(a[1], a[id]);\n\n\t\t// \n\t\tstd::sort(a + 2, a + n + 1, &compare);\n\n\t\t// \n\t\tpts.push_back(a[1]);\n\t\tfor (int i = 2; i <= n; i++)\n\t\t{\n\t\t\t// pop_back\n\t\t\twhile (pts.size() >= 2 && cross(a[i] - pts[pts.size() - 2], pts.back() - pts[pts.size() - 2]) >= 0) pts.pop_back();\n\t\t\tpts.push_back(a[i]);\n\t\t}\n\t}\n};\n```\n","slug":"geometry-notes","published":1,"updated":"2017-01-06T08:43:19.588Z","_id":"cixlg9s1m0157ooxlhi08t0uw","comments":1,"layout":"post","photos":[],"link":""},{"title":"FJOI2007 - ","date":"2016-10-17T02:54:00.000Z","_content":"\n $ N $  $ N $ 2  2  $ N $  $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002)\n\n### \n$ f(i) = 3f(i - 1) - f(i - 2) + 2 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MAXN = 100;\n\nstruct BigInt {\n\tstd::vector<int> v;\n\n\tBigInt(const int n = 0) { *this = n; }\n\tBigInt(const std::string &s) { *this = s; }\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n\n\tBigInt &operator=(const std::string &s) {\n\t\tv.resize(s.length());\n\t\tfor (size_t i = 0; i < s.length(); i++) v[i] = s[s.length() - i - 1] - '0';\n\t}\n\n\tvoid print() {\n\t\tfor (int i = v.size() - 1; i >= 0; i--) printf(\"%d\", v[i]);\n\t\tputchar('\\n');\n\t}\n};\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t += b.v[i];\n\t\tif (flag) t++, flag = false;\n\t\tif (t >= 10) t -= 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\tif (flag) res.v.push_back(1);\n\treturn res;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t -= b.v[i];\n\t\tif (flag) t--, flag = false;\n\t\tif (t < 0) t += 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\treturn res;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.resize(a.v.size() + b.v.size() + 1);\n\tfor (size_t i = 0; i < a.v.size(); i++) {\n\t\tfor (size_t j = 0; j < b.v.size(); j++) {\n\t\t\tres.v[i + j] += a.v[i] * b.v[j];\n\t\t\tres.v[i + j + 1] += res.v[i + j] / 10;\n\t\t\tres.v[i + j] %= 10;\n\t\t}\n\t}\n\twhile (res.v.size() > 1 && res.v.back() == 0) res.v.pop_back();\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBigInt f[MAXN + 1];\n\tf[1] = 1, f[2] = 5;\n\tfor (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2;\n\tf[n].print();\n\treturn 0;\n}\n```\n","source":"_posts/fjoi2007-wheel.md","raw":"title: FJOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - FJOI\n  - \npermalink: fjoi2007-wheel\ndate: 2016-10-17 10:54:00\n---\n\n $ N $  $ N $ 2  2  $ N $  $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002)\n\n### \n$ f(i) = 3f(i - 1) - f(i - 2) + 2 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MAXN = 100;\n\nstruct BigInt {\n\tstd::vector<int> v;\n\n\tBigInt(const int n = 0) { *this = n; }\n\tBigInt(const std::string &s) { *this = s; }\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n\n\tBigInt &operator=(const std::string &s) {\n\t\tv.resize(s.length());\n\t\tfor (size_t i = 0; i < s.length(); i++) v[i] = s[s.length() - i - 1] - '0';\n\t}\n\n\tvoid print() {\n\t\tfor (int i = v.size() - 1; i >= 0; i--) printf(\"%d\", v[i]);\n\t\tputchar('\\n');\n\t}\n};\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t += b.v[i];\n\t\tif (flag) t++, flag = false;\n\t\tif (t >= 10) t -= 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\tif (flag) res.v.push_back(1);\n\treturn res;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t -= b.v[i];\n\t\tif (flag) t--, flag = false;\n\t\tif (t < 0) t += 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\treturn res;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.resize(a.v.size() + b.v.size() + 1);\n\tfor (size_t i = 0; i < a.v.size(); i++) {\n\t\tfor (size_t j = 0; j < b.v.size(); j++) {\n\t\t\tres.v[i + j] += a.v[i] * b.v[j];\n\t\t\tres.v[i + j + 1] += res.v[i + j] / 10;\n\t\t\tres.v[i + j] %= 10;\n\t\t}\n\t}\n\twhile (res.v.size() > 1 && res.v.back() == 0) res.v.pop_back();\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBigInt f[MAXN + 1];\n\tf[1] = 1, f[2] = 5;\n\tfor (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2;\n\tf[n].print();\n\treturn 0;\n}\n```\n","slug":"fjoi2007-wheel","published":1,"updated":"2016-10-17T09:26:27.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s2d015eooxloob8hphs"},{"title":"","date":"2016-06-17T13:38:00.000Z","_content":"\nFFT Number-Theoretic Transform\n\n<!-- more -->\n\n### \nFFT  $ \\omega_n ^ k = \\cos \\frac{2 \\pi}{n}k + i \\sin\\frac{2 \\pi}{n}k $\n\n1. $ \\omega_n ^ t (0 \\leq t \\leq n - 1) $ \n2. $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n3. $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n3.  $ k \\neq 0 $ $ 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} = 0 $\n\n $ p = qn + 1 $ $ n $  $ 2 $ **** $ g $  $ g ^ i(0 \\leq i \\leq p - 1) $ \n\n#### \n\n $ \\omega_n = g ^ q $ $ 1,\\ g ^ q,\\ g ^ {2q},\\ \\dots,\\ g ^ {(n - 1)q} $ ****\n\n#### \n\n $ \\omega_n = g ^ q $  $ \\omega_{2n} = g ^ { \\frac{q}{2} } $$ p = \\frac{q}{2} \\times 2n + 1 $ $ \\omega_{2n} ^ {2k} = g ^ {2k \\frac{q}{2} } = g ^ {kq} = \\omega_n ^ k $****\n\n#### \n\n\n\n$$ \\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ (\\omega_{n} ^ { \\frac{n}{2} }) ^ 2 = \\omega_n ^ n $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv \\pm 1 \\pmod p $ $ \\omega_n ^ { \\frac{n}{2} } \\neq \\omega_n ^ 0 \\ $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv -1 \\pmod p $ $ \\omega_n ^ { k + \\frac{n}{2} } = \\omega_n ^ k \\times \\omega_n ^ { \\frac{n}{2} } \\equiv -\\omega_n ^ k \\pmod p $****\n\n#### \n $ k \\neq 0 $ \n\n$$\n\\begin{aligned}\nS(\\omega_n ^ k) &= 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} \\\\\n\\omega_n ^ k S(\\omega_n ^ k) &= \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n \\\\\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{aligned}\n$$\n\n****$ (\\omega_n ^ k) ^ n - 1 \\equiv 0 \\pmod p $ $ S(\\omega_n ^ k) \\equiv 0  \\pmod p $****\n\n### \n   $ g $ $ g $  $ p $ \n\n>  $ g $ $ g ^ k \\equiv 1 \\pmod p $  $ k $  $ p - 1 $ \n\n $ k $  $ p - 1 $  $ x $  $ xk > p - 1 > (x - 1)k $\n\n$$ g ^ {xk} \\equiv g ^ {p - 1} \\equiv 1 \\equiv g ^ {xk - (p - 1)} \\pmod p $$\n\n$ xk - (p - 1) < k $\n\n $ p - 1 $  $ q $ $ g ^ q \\not\\equiv 1 \\pmod p $ \n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n```\n\n### \n\n\n $ \\div n $  $ \\times n ^ {-1} $\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n} ntt;\n```\n","source":"_posts/fft-to-ntt.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \n  - \npermalink: fft-to-ntt\ndate: 2016-06-17 21:38:00\n---\n\nFFT Number-Theoretic Transform\n\n<!-- more -->\n\n### \nFFT  $ \\omega_n ^ k = \\cos \\frac{2 \\pi}{n}k + i \\sin\\frac{2 \\pi}{n}k $\n\n1. $ \\omega_n ^ t (0 \\leq t \\leq n - 1) $ \n2. $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n3. $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n3.  $ k \\neq 0 $ $ 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} = 0 $\n\n $ p = qn + 1 $ $ n $  $ 2 $ **** $ g $  $ g ^ i(0 \\leq i \\leq p - 1) $ \n\n#### \n\n $ \\omega_n = g ^ q $ $ 1,\\ g ^ q,\\ g ^ {2q},\\ \\dots,\\ g ^ {(n - 1)q} $ ****\n\n#### \n\n $ \\omega_n = g ^ q $  $ \\omega_{2n} = g ^ { \\frac{q}{2} } $$ p = \\frac{q}{2} \\times 2n + 1 $ $ \\omega_{2n} ^ {2k} = g ^ {2k \\frac{q}{2} } = g ^ {kq} = \\omega_n ^ k $****\n\n#### \n\n\n\n$$ \\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ (\\omega_{n} ^ { \\frac{n}{2} }) ^ 2 = \\omega_n ^ n $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv \\pm 1 \\pmod p $ $ \\omega_n ^ { \\frac{n}{2} } \\neq \\omega_n ^ 0 \\ $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv -1 \\pmod p $ $ \\omega_n ^ { k + \\frac{n}{2} } = \\omega_n ^ k \\times \\omega_n ^ { \\frac{n}{2} } \\equiv -\\omega_n ^ k \\pmod p $****\n\n#### \n $ k \\neq 0 $ \n\n$$\n\\begin{aligned}\nS(\\omega_n ^ k) &= 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} \\\\\n\\omega_n ^ k S(\\omega_n ^ k) &= \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n \\\\\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{aligned}\n$$\n\n****$ (\\omega_n ^ k) ^ n - 1 \\equiv 0 \\pmod p $ $ S(\\omega_n ^ k) \\equiv 0  \\pmod p $****\n\n### \n   $ g $ $ g $  $ p $ \n\n>  $ g $ $ g ^ k \\equiv 1 \\pmod p $  $ k $  $ p - 1 $ \n\n $ k $  $ p - 1 $  $ x $  $ xk > p - 1 > (x - 1)k $\n\n$$ g ^ {xk} \\equiv g ^ {p - 1} \\equiv 1 \\equiv g ^ {xk - (p - 1)} \\pmod p $$\n\n$ xk - (p - 1) < k $\n\n $ p - 1 $  $ q $ $ g ^ q \\not\\equiv 1 \\pmod p $ \n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n```\n\n### \n\n\n $ \\div n $  $ \\times n ^ {-1} $\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n} ntt;\n```\n","slug":"fft-to-ntt","published":1,"updated":"2016-06-17T13:38:12.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s2j015kooxlno9phes2"},{"title":"FFT ","date":"2016-06-03T11:41:00.000Z","_content":"\nFast Fourier TransformFFT $ O(n \\log n) $ Discrete Fourier transformDFT OI \n\n<!-- more -->\n\n### \n#### \n##### \n $ A(x) $  $ n - 1 $  $ n $  $ ( a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1} ) $ \n\n$$\n\\begin{align*}\nA(x) &= \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i \\\\\n&= a_0 + a_1 x + a_2 x ^ 2 + \\dots + a_{n - 1} x ^ {n - 1}\n\\end{align*}\n$$\n\n**** $ n $  $ x $  $ n $  $ n $  $ ( x_0,\\ x_1,\\ x_2,\\ \\dots,\\ x_{n - 1} ) $$ ( y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1} ) $\n\n$$\n\\begin{align*}\ny_i &= A(x_i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j x_i ^ j\n\\end{align*}\n$$\n\n##### \n>  $ n - 1 $  $ n $ \n\n $ n - 1 $  $ A(x) $$ B(x) $ $ i \\in [0,\\ n - 1] $ $ A(x_i) = B(x_i) $\n\n $ C(x) = A(x) - B(x) $ $ C(x) $  $ n - 1 $  $ i \\in [0,\\ n - 1] $ $ C(x_i) = 0 $\n\n $ C(x) $  $ n $  $ n - 1 $  $ n - 1 $  $ C(x) $  $ n - 1 $ \n\n $ O(n ^ 2) $\n\n**** $ O(n ^ 2) $\n\n##### \n $ A(x) = \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i $  $ B(x) = \\sum\\limits_{i = 0} ^ {n - 1} b_i x ^ i $  $ C(x) $\n\n$$ C(x) = A(x) \\times B(x) = \\sum\\limits_{k = 0} ^ {2n - 2} (\\sum\\limits_{k = i + j} a_i b_j) x ^ k $$\n\n $ n - 1 $  $ 2n - 2 $  $ O(n ^ 2) $\n\n $ 2n - 1 $ \n\n$$ {y_3}_i = (\\sum\\limits_{j = 0} ^ {2n - 1} a_j x_i ^ j) \\times (\\sum\\limits_{j = 0} ^ {2n - 1} b_j x_i ^ j) = {y_1}_i \\times {y_2}_i $$\n\n $ O(n) $\n\n#### \n $ a $$ b $ $ i ^ 2 = -1 $ $ a + bi $ **** $ i $ ****\n\n##### \n$ x $ $ y $  $ a + bi $  $ (0,\\ 0) $  $ (a,\\ b) $ \n\n $ \\sqrt {a ^ 2 + b ^ 2} $  $ x $ \n\n\n\n\n\n### \n $ n $  $ 2 $ \n\n$ 1 $  $ n $  $ n $ **** $ \\omega_n $ $ n $ \n\n $ n - 1 $  $ \\omega_n ^ 2,\\ \\omega_n ^ 3,\\ \\dots,\\ \\omega_n ^ n $ $ \\omega_n ^ n = \\omega_n ^ 0 = 1 $\n\n $ 1 \\over n $\n\n$$ \\omega_n ^ k = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n#### \n\n> $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n\n\n\n\n\n$$ \\cos 2k \\frac{2 \\pi}{2n} + i\\sin 2k \\frac{2 \\pi}{2n} = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n> $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n\n $ \\omega_n ^ k $  $ \\omega_n ^ { \\frac{n}{2} } $\n\n$$\n\\begin{align*}\n\\omega_n ^ { \\frac{n}{2} } &= \\cos \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} + i\\sin \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} \\\\\n&= \\cos \\pi + i\\sin \\pi \\\\\n&= -1\n\\end{align*}\n$$\n\n### \n $ A(x) $  $ n $  $ 0 $  $ n - 1 $  $ (A(\\omega_n ^ 0),\\ A(\\omega_n ^ 1),\\ \\dots,\\ A(\\omega_n ^ {n - 1})) $  $ (a_0,\\ a_1,\\ \\dots,\\ a_{n - 1}) $ ****\n\n $ O(n ^ 2) $\n\n\n\n$$ A(x) = (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + \\dots + a_{n - 2} x ^ {n - 2}) + (a_1 x + a_3 x ^ 3 + a_5 x ^ 5 + \\dots + a_{n - 1} x ^ {n - 1}) $$\n\n\n\n$$\n\\begin{align*}\nA_1(x) &= a_0 + a_2 x + a_4 x ^ 2 + \\dots + a_{n - 2} x ^ {\\frac{n}{2} - 1} \\\\\nA_2(x) &= a_1 + a_3 x + a_5 x ^ 2 + \\dots + a_{n - 1} x ^ {\\frac{n}{2} - 1}\n\\end{align*}\n$$\n\n\n\n$$ A(x) = A_1(x ^ 2) + x A_2(x ^ 2) $$\n\n $ k < \\frac{n}{2} $ $ A(\\omega_n ^ k) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ k) &= A_1(\\omega_n ^ {2k}) + \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) + \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n\n\n $ A(\\omega_n ^ {k + \\frac{n}{2}}) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ {k + \\frac{n}{2}}) &= A_1(\\omega_n ^ {2k + n}) + \\omega_n ^ {k + \\frac{n}{2}} A_2(\\omega_n ^ {2k + n}) \\\\\n&= A_1(\\omega_n ^ {2k} \\times \\omega_n ^ n) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k} \\times \\omega_n ^ n) \\\\\n&= A_1(\\omega_n ^ {2k}) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) - \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n $ \\omega_n ^ n = 1 $ \n\n $ k $  $ [0,\\ \\frac{n}{2} - 1] $ $ k $  $ k + \\frac{n}{2} $  $ [0,\\ n - 1] $\n\n $ A_1(x) $  $ A_2(x) $  $ \\omega_{ \\frac{n}{2} } ^ 0,\\ \\omega_{ \\frac{n}{2} } ^ 1,\\ \\dots,\\ \\omega_{ \\frac{n}{2} } ^ { \\frac{n}{2} - 1 } $  $ O(n) $  $ A(x) $  $ \\omega_n ^ 0,\\ \\omega_n ^ 1,\\ \\dots,\\ \\omega_n ^ {n - 1} $  $ A_1(x) $  $ A_2(x) $  $ a_0 $\n\n\n\n$$ T(n) = 2T( \\frac{n}{2} ) + O(n) = O(n \\log n) $$\n\n FFT   Cooley-Tukey \n\n### \n****\n\n $ (y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1}) $  $ (a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1}) $  $ (c_0,\\ c_1,\\ c_2,\\ \\dots,\\ c_{n - 1}) $ \n\n$$\nc_k = \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i\n$$\n\n $ B(x) = y_0 + y_1 x + y_2 x ^ 2 + \\dots + y_{n - 1} x ^ {n - 1} $  $ \\omega_n ^ 0,\\ \\omega_n ^ {-1},\\ \\omega_n ^ {-2},\\ \\dots,\\  \\omega_n ^ {-(n - 1)} $ \n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ i) ^ j) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i (\\omega_n ^ {-k}) ^ i) \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ {j - k}) ^ i \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i)\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} $$\n\n $ k \\neq 0 $  $ \\omega_n ^ k $ \n\n$$ \\omega_n ^ k S(\\omega_n ^ k) = \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n $$\n\n\n\n$$\n\\begin{align*}\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 0 $$\n\n $ k = 0 $  $ S(\\omega_n ^ k) = n $\n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j S(\\omega_n ^ {j - k})\n\\end{align*}\n$$\n\n $ j = k $ $ S(\\omega_n ^ {j - k}) = n $ $ S(\\omega_n ^ {j - k}) = 0 $\n\n$$\n\\begin{align*}\nc_i &= n a_i \\\\\na_i &= \\frac{1}{n} c_i\n\\end{align*}\n$$\n\n $ n $\n\n### \nC++  STL  `complex`  `std::complex<T>` `T`  `double` `long double`  `__float128`\n\n `std::conj()`  IDFT \n\n#### \n\n\n##### \n\n```c++\nconst double PI = acos(-1);\n\nbool inversed = false;\n\ninline std::complex<double> omega(const int n, const int k) {\n    if (!inversed) return std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k));\n    else return std::conj(std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k)));\n}\n\ninline void transform(std::complex<double> *a, const int n) {\n    if (n == 1) return;\n\n    static std::complex<double> buf[MAXN];\n    const int m = n / 2;\n    // \n    for (int i = 0; i < m; i++) {\n        buf[i] = a[i * 2];\n        buf[i + m] = a[i * 2 + 1];\n    }\n    std::copy(buf, buf + n, a);\n\n    // \n    std::complex<double> *a1 = a, *a2 = a + m;\n    fft(a1, m);\n    fft(a2, m);\n\n    // \n    for (int i = 0; i < m; i++) {\n        std::complex<double> x = omega(n, i);\n        buf[i] = a1[i] + x * a2[i];\n        buf[i + m] = a1[i] - x * a2[i];\n    }\n\n    std::copy(buf, buf + n, a);\n}\n```\n\n#### \n FFT \n\n##### \n FFT \n\n```plain\n000 001 010 011 100 101 110 111\n 0   1   2   3   4   5   6   7\n 0   2   4   6 - 1   3   5   7\n 0   4 - 2   6 - 1   5 - 3   7\n 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7\n000 100 010 110 001 101 011 111\n```\n\n\n\n\n\n```c++\nint k = 0;\nwhile ((1 << k) < n) k++;\nfor (int i = 0; i < n; i++) {\n    int t = 0;\n    for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n    if (i < t) std::swap(a[i], a[t]);\n}\n```\n\n##### \n $ A_1(\\omega_{ \\frac{n}{2} } ^ k) $  $ A_2(\\omega_{ \\frac{n}{2} } ^ k) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ b(k) $  $ b(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nb(k) & \\leftarrow a(k) + \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\nb(\\frac{n}{2} + k) & \\leftarrow a(k) - \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\n\\end{align*}\n$$\n\n $ t $ $ b $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nt & \\leftarrow \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\na(\\frac{n}{2} + k) & \\leftarrow a(k) - t \\\\\na(k) & \\leftarrow a(k) + t \\\\\n\\end{align*}\n$$\n\n****\n\n##### \n`omega[k]`  $ \\omega_n ^ k $IDFT  $ \\omega_n ^ {-k} $\n\n $ l $ $ \\frac{l}{2} $  $ l $  $ \\omega_l ^ k = \\omega_n ^ { \\frac{n}{l} k } $\n\n```c++\nvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n    // \n    for (int l = 2; l <= n; l *= 2) {\n        int m = l / 2;\n        //  m  l \n        for (std::complex<double> *p = a; p != a + n; p += l) {\n            for (int i = 0; i < m; i++) {\n                // \n                std::complex<double> t = omega[n / l * i] * p[m + i];\n                p[m + i] = p[i] - t;\n                p[i] += t;\n            }\n        }\n    }\n}\n```\n\n### \n $ n_1 - 1 $  $ n_2 - 1 $ **** $ n_1 + n_2 - 1 $  $ n_1 + n_2 - 2 $ \n\n```c++\nstruct FastFourierTransform {\n    std::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n    void init(const int n) {\n        for (int i = 0; i < n; i++) {\n            omega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n            omegaInverse[i] = std::conj(omega[i]);\n        }\n    }\n\n    void transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n            if (i < t) std::swap(a[i], a[t]);\n        }\n\n        for (int l = 2; l <= n; l *= 2) {\n            int m = l / 2;\n            for (std::complex<double> *p = a; p != a + n; p += l) {\n                for (int i = 0; i < m; i++) {\n                    std::complex<double> t = omega[n / l * i] * p[m + i];\n                    p[m + i] = p[i] - t;\n                    p[i] += t;\n                }\n            }\n        }\n    }\n\n    void dft(std::complex<double> *a, const int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(std::complex<double> *a, const int n) {\n        transform(a, n, omegaInverse);\n        for (int i = 0; i < n; i++) a[i] /= n;\n    }\n} fft;\n\ninline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) {\n    int n = 1;\n    while (n < n1 + n2) n *= 2;\n    static std::complex<double> c1[MAXN], c2[MAXN];\n    for (int i = 0; i < n1; i++) c1[i].real(a1[i]);\n    for (int i = 0; i < n2; i++) c2[i].real(a2[i]);\n    fft.init(n);\n    fft.dft(c1, n), fft.dft(c2, n);\n    for (int i = 0; i < n; i++) c1[i] *= c2[i];\n    fft.idft(c1, n);\n    for (int i = 0; i < n1 + n2 - 1; i++) res[i] = static_cast<int>(floor(c1[i].real() + 0.5));\n}\n```\n\n### \n* [ - ](https://zh.wikipedia.org/zh/%E5%A4%9A%E9%A0%85%E5%BC%8F)Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%B9%B3%E9%9D%A2)Wikipedia\n* [ () - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)Wikipedia\n* [FFT & NTT | ZYK1997](http://zyk1997.github.io/2015/06/08/FFT/)ZYK1997\n* [BZOJ 3992 SDOI2015  - Fuxey -  - CSDN.NET](http://blog.csdn.net/fuxey/article/details/50840881)Fuxey\n* [ - Miskcoo's Space](http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform)Miskcoo\n* [OI  FFT - zball - ](http://www.cnblogs.com/tmzbot/p/4320955.html)zball\n* [Fourier transform](https://pan.baidu.com/wap/album/file?uk=3325080974&album_id=2474841267539644259&fsid=845742707277510&adapt=pc&fr=ftw)\n","source":"_posts/fft-notes.md","raw":"title: FFT \ncategories: OI\ntags: \n  - FFT\n  - \n  - \n  - \n  - \npermalink: fft-notes\ndate: 2016-06-03 19:41:00\n---\n\nFast Fourier TransformFFT $ O(n \\log n) $ Discrete Fourier transformDFT OI \n\n<!-- more -->\n\n### \n#### \n##### \n $ A(x) $  $ n - 1 $  $ n $  $ ( a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1} ) $ \n\n$$\n\\begin{align*}\nA(x) &= \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i \\\\\n&= a_0 + a_1 x + a_2 x ^ 2 + \\dots + a_{n - 1} x ^ {n - 1}\n\\end{align*}\n$$\n\n**** $ n $  $ x $  $ n $  $ n $  $ ( x_0,\\ x_1,\\ x_2,\\ \\dots,\\ x_{n - 1} ) $$ ( y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1} ) $\n\n$$\n\\begin{align*}\ny_i &= A(x_i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j x_i ^ j\n\\end{align*}\n$$\n\n##### \n>  $ n - 1 $  $ n $ \n\n $ n - 1 $  $ A(x) $$ B(x) $ $ i \\in [0,\\ n - 1] $ $ A(x_i) = B(x_i) $\n\n $ C(x) = A(x) - B(x) $ $ C(x) $  $ n - 1 $  $ i \\in [0,\\ n - 1] $ $ C(x_i) = 0 $\n\n $ C(x) $  $ n $  $ n - 1 $  $ n - 1 $  $ C(x) $  $ n - 1 $ \n\n $ O(n ^ 2) $\n\n**** $ O(n ^ 2) $\n\n##### \n $ A(x) = \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i $  $ B(x) = \\sum\\limits_{i = 0} ^ {n - 1} b_i x ^ i $  $ C(x) $\n\n$$ C(x) = A(x) \\times B(x) = \\sum\\limits_{k = 0} ^ {2n - 2} (\\sum\\limits_{k = i + j} a_i b_j) x ^ k $$\n\n $ n - 1 $  $ 2n - 2 $  $ O(n ^ 2) $\n\n $ 2n - 1 $ \n\n$$ {y_3}_i = (\\sum\\limits_{j = 0} ^ {2n - 1} a_j x_i ^ j) \\times (\\sum\\limits_{j = 0} ^ {2n - 1} b_j x_i ^ j) = {y_1}_i \\times {y_2}_i $$\n\n $ O(n) $\n\n#### \n $ a $$ b $ $ i ^ 2 = -1 $ $ a + bi $ **** $ i $ ****\n\n##### \n$ x $ $ y $  $ a + bi $  $ (0,\\ 0) $  $ (a,\\ b) $ \n\n $ \\sqrt {a ^ 2 + b ^ 2} $  $ x $ \n\n\n\n\n\n### \n $ n $  $ 2 $ \n\n$ 1 $  $ n $  $ n $ **** $ \\omega_n $ $ n $ \n\n $ n - 1 $  $ \\omega_n ^ 2,\\ \\omega_n ^ 3,\\ \\dots,\\ \\omega_n ^ n $ $ \\omega_n ^ n = \\omega_n ^ 0 = 1 $\n\n $ 1 \\over n $\n\n$$ \\omega_n ^ k = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n#### \n\n> $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n\n\n\n\n\n$$ \\cos 2k \\frac{2 \\pi}{2n} + i\\sin 2k \\frac{2 \\pi}{2n} = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n> $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n\n $ \\omega_n ^ k $  $ \\omega_n ^ { \\frac{n}{2} } $\n\n$$\n\\begin{align*}\n\\omega_n ^ { \\frac{n}{2} } &= \\cos \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} + i\\sin \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} \\\\\n&= \\cos \\pi + i\\sin \\pi \\\\\n&= -1\n\\end{align*}\n$$\n\n### \n $ A(x) $  $ n $  $ 0 $  $ n - 1 $  $ (A(\\omega_n ^ 0),\\ A(\\omega_n ^ 1),\\ \\dots,\\ A(\\omega_n ^ {n - 1})) $  $ (a_0,\\ a_1,\\ \\dots,\\ a_{n - 1}) $ ****\n\n $ O(n ^ 2) $\n\n\n\n$$ A(x) = (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + \\dots + a_{n - 2} x ^ {n - 2}) + (a_1 x + a_3 x ^ 3 + a_5 x ^ 5 + \\dots + a_{n - 1} x ^ {n - 1}) $$\n\n\n\n$$\n\\begin{align*}\nA_1(x) &= a_0 + a_2 x + a_4 x ^ 2 + \\dots + a_{n - 2} x ^ {\\frac{n}{2} - 1} \\\\\nA_2(x) &= a_1 + a_3 x + a_5 x ^ 2 + \\dots + a_{n - 1} x ^ {\\frac{n}{2} - 1}\n\\end{align*}\n$$\n\n\n\n$$ A(x) = A_1(x ^ 2) + x A_2(x ^ 2) $$\n\n $ k < \\frac{n}{2} $ $ A(\\omega_n ^ k) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ k) &= A_1(\\omega_n ^ {2k}) + \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) + \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n\n\n $ A(\\omega_n ^ {k + \\frac{n}{2}}) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ {k + \\frac{n}{2}}) &= A_1(\\omega_n ^ {2k + n}) + \\omega_n ^ {k + \\frac{n}{2}} A_2(\\omega_n ^ {2k + n}) \\\\\n&= A_1(\\omega_n ^ {2k} \\times \\omega_n ^ n) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k} \\times \\omega_n ^ n) \\\\\n&= A_1(\\omega_n ^ {2k}) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) - \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n $ \\omega_n ^ n = 1 $ \n\n $ k $  $ [0,\\ \\frac{n}{2} - 1] $ $ k $  $ k + \\frac{n}{2} $  $ [0,\\ n - 1] $\n\n $ A_1(x) $  $ A_2(x) $  $ \\omega_{ \\frac{n}{2} } ^ 0,\\ \\omega_{ \\frac{n}{2} } ^ 1,\\ \\dots,\\ \\omega_{ \\frac{n}{2} } ^ { \\frac{n}{2} - 1 } $  $ O(n) $  $ A(x) $  $ \\omega_n ^ 0,\\ \\omega_n ^ 1,\\ \\dots,\\ \\omega_n ^ {n - 1} $  $ A_1(x) $  $ A_2(x) $  $ a_0 $\n\n\n\n$$ T(n) = 2T( \\frac{n}{2} ) + O(n) = O(n \\log n) $$\n\n FFT   Cooley-Tukey \n\n### \n****\n\n $ (y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1}) $  $ (a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1}) $  $ (c_0,\\ c_1,\\ c_2,\\ \\dots,\\ c_{n - 1}) $ \n\n$$\nc_k = \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i\n$$\n\n $ B(x) = y_0 + y_1 x + y_2 x ^ 2 + \\dots + y_{n - 1} x ^ {n - 1} $  $ \\omega_n ^ 0,\\ \\omega_n ^ {-1},\\ \\omega_n ^ {-2},\\ \\dots,\\  \\omega_n ^ {-(n - 1)} $ \n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ i) ^ j) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i (\\omega_n ^ {-k}) ^ i) \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ {j - k}) ^ i \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i)\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} $$\n\n $ k \\neq 0 $  $ \\omega_n ^ k $ \n\n$$ \\omega_n ^ k S(\\omega_n ^ k) = \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n $$\n\n\n\n$$\n\\begin{align*}\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 0 $$\n\n $ k = 0 $  $ S(\\omega_n ^ k) = n $\n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j S(\\omega_n ^ {j - k})\n\\end{align*}\n$$\n\n $ j = k $ $ S(\\omega_n ^ {j - k}) = n $ $ S(\\omega_n ^ {j - k}) = 0 $\n\n$$\n\\begin{align*}\nc_i &= n a_i \\\\\na_i &= \\frac{1}{n} c_i\n\\end{align*}\n$$\n\n $ n $\n\n### \nC++  STL  `complex`  `std::complex<T>` `T`  `double` `long double`  `__float128`\n\n `std::conj()`  IDFT \n\n#### \n\n\n##### \n\n```c++\nconst double PI = acos(-1);\n\nbool inversed = false;\n\ninline std::complex<double> omega(const int n, const int k) {\n    if (!inversed) return std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k));\n    else return std::conj(std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k)));\n}\n\ninline void transform(std::complex<double> *a, const int n) {\n    if (n == 1) return;\n\n    static std::complex<double> buf[MAXN];\n    const int m = n / 2;\n    // \n    for (int i = 0; i < m; i++) {\n        buf[i] = a[i * 2];\n        buf[i + m] = a[i * 2 + 1];\n    }\n    std::copy(buf, buf + n, a);\n\n    // \n    std::complex<double> *a1 = a, *a2 = a + m;\n    fft(a1, m);\n    fft(a2, m);\n\n    // \n    for (int i = 0; i < m; i++) {\n        std::complex<double> x = omega(n, i);\n        buf[i] = a1[i] + x * a2[i];\n        buf[i + m] = a1[i] - x * a2[i];\n    }\n\n    std::copy(buf, buf + n, a);\n}\n```\n\n#### \n FFT \n\n##### \n FFT \n\n```plain\n000 001 010 011 100 101 110 111\n 0   1   2   3   4   5   6   7\n 0   2   4   6 - 1   3   5   7\n 0   4 - 2   6 - 1   5 - 3   7\n 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7\n000 100 010 110 001 101 011 111\n```\n\n\n\n\n\n```c++\nint k = 0;\nwhile ((1 << k) < n) k++;\nfor (int i = 0; i < n; i++) {\n    int t = 0;\n    for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n    if (i < t) std::swap(a[i], a[t]);\n}\n```\n\n##### \n $ A_1(\\omega_{ \\frac{n}{2} } ^ k) $  $ A_2(\\omega_{ \\frac{n}{2} } ^ k) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ b(k) $  $ b(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nb(k) & \\leftarrow a(k) + \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\nb(\\frac{n}{2} + k) & \\leftarrow a(k) - \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\n\\end{align*}\n$$\n\n $ t $ $ b $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nt & \\leftarrow \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\na(\\frac{n}{2} + k) & \\leftarrow a(k) - t \\\\\na(k) & \\leftarrow a(k) + t \\\\\n\\end{align*}\n$$\n\n****\n\n##### \n`omega[k]`  $ \\omega_n ^ k $IDFT  $ \\omega_n ^ {-k} $\n\n $ l $ $ \\frac{l}{2} $  $ l $  $ \\omega_l ^ k = \\omega_n ^ { \\frac{n}{l} k } $\n\n```c++\nvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n    // \n    for (int l = 2; l <= n; l *= 2) {\n        int m = l / 2;\n        //  m  l \n        for (std::complex<double> *p = a; p != a + n; p += l) {\n            for (int i = 0; i < m; i++) {\n                // \n                std::complex<double> t = omega[n / l * i] * p[m + i];\n                p[m + i] = p[i] - t;\n                p[i] += t;\n            }\n        }\n    }\n}\n```\n\n### \n $ n_1 - 1 $  $ n_2 - 1 $ **** $ n_1 + n_2 - 1 $  $ n_1 + n_2 - 2 $ \n\n```c++\nstruct FastFourierTransform {\n    std::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n    void init(const int n) {\n        for (int i = 0; i < n; i++) {\n            omega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n            omegaInverse[i] = std::conj(omega[i]);\n        }\n    }\n\n    void transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n            if (i < t) std::swap(a[i], a[t]);\n        }\n\n        for (int l = 2; l <= n; l *= 2) {\n            int m = l / 2;\n            for (std::complex<double> *p = a; p != a + n; p += l) {\n                for (int i = 0; i < m; i++) {\n                    std::complex<double> t = omega[n / l * i] * p[m + i];\n                    p[m + i] = p[i] - t;\n                    p[i] += t;\n                }\n            }\n        }\n    }\n\n    void dft(std::complex<double> *a, const int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(std::complex<double> *a, const int n) {\n        transform(a, n, omegaInverse);\n        for (int i = 0; i < n; i++) a[i] /= n;\n    }\n} fft;\n\ninline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) {\n    int n = 1;\n    while (n < n1 + n2) n *= 2;\n    static std::complex<double> c1[MAXN], c2[MAXN];\n    for (int i = 0; i < n1; i++) c1[i].real(a1[i]);\n    for (int i = 0; i < n2; i++) c2[i].real(a2[i]);\n    fft.init(n);\n    fft.dft(c1, n), fft.dft(c2, n);\n    for (int i = 0; i < n; i++) c1[i] *= c2[i];\n    fft.idft(c1, n);\n    for (int i = 0; i < n1 + n2 - 1; i++) res[i] = static_cast<int>(floor(c1[i].real() + 0.5));\n}\n```\n\n### \n* [ - ](https://zh.wikipedia.org/zh/%E5%A4%9A%E9%A0%85%E5%BC%8F)Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%B9%B3%E9%9D%A2)Wikipedia\n* [ () - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)Wikipedia\n* [FFT & NTT | ZYK1997](http://zyk1997.github.io/2015/06/08/FFT/)ZYK1997\n* [BZOJ 3992 SDOI2015  - Fuxey -  - CSDN.NET](http://blog.csdn.net/fuxey/article/details/50840881)Fuxey\n* [ - Miskcoo's Space](http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform)Miskcoo\n* [OI  FFT - zball - ](http://www.cnblogs.com/tmzbot/p/4320955.html)zball\n* [Fourier transform](https://pan.baidu.com/wap/album/file?uk=3325080974&album_id=2474841267539644259&fsid=845742707277510&adapt=pc&fr=ftw)\n","slug":"fft-notes","published":1,"updated":"2016-12-23T06:20:49.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s2r015tooxlois4c85n"},{"title":"","date":"2016-04-08T05:14:55.000Z","_content":"\n $ O(n) $  $ [1, n] $  $ O(n) $ \n\n<!-- more -->\n\n### \n $ \\phi(n) $  $ n $  $ n $ $ \\phi(1) = 1 $\n\n $ n $  $ \\phi(n) = n - 1 $\n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ $ n' $  $ n $ \n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ p_1 $ \n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### \n $ \\mu(n) $ \n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n $ n $  $ \\mu(n) = -1 $\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ \n\n$$ \\mu(n) = 0 $$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ N - 1 $  $ \\mu(n') \\neq 0 $ $ n' $  $ 1 $\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n $ \\mu(n') = 0 $ $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $\n\n$$ \\mu(n) = 0 $$\n\n $ \\mu(n) = -\\mu(n') $ \n\n\n### \n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","source":"_posts/euler-sieve.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: euler-sieve\ndate: 2016-04-08 13:14:55\n---\n\n $ O(n) $  $ [1, n] $  $ O(n) $ \n\n<!-- more -->\n\n### \n $ \\phi(n) $  $ n $  $ n $ $ \\phi(1) = 1 $\n\n $ n $  $ \\phi(n) = n - 1 $\n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ $ n' $  $ n $ \n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ p_1 $ \n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### \n $ \\mu(n) $ \n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n $ n $  $ \\mu(n) = -1 $\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ \n\n$$ \\mu(n) = 0 $$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ N - 1 $  $ \\mu(n') \\neq 0 $ $ n' $  $ 1 $\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n $ \\mu(n') = 0 $ $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $\n\n$$ \\mu(n) = 0 $$\n\n $ \\mu(n) = -\\mu(n') $ \n\n\n### \n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","slug":"euler-sieve","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s2x0160ooxlo3rwggjz"},{"title":"","date":"2017-01-01T03:09:00.000Z","_content":"\n\n\n<!-- more -->\n\n### [UOJ #117](http://uoj.ac/problem/117)\n![zyz ](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 1e5;\n\nstruct Node\n{\n\tstruct Edge *e;\n\tint deg; // \n\tint inDeg, outDeg; // \n} N[MAXN + 1];\n\nstruct Edge\n{\n\tint id;\n\tNode *s, *t;\n\tbool vis;\n\tEdge *next, *revEdge;\n\n\tEdge(int id, Node *s, Node *t) : id(id), s(s), t(t), vis(false), next(s->e) {}\n};\n\nint T;\n\ninline void addEdge(int id, int s, int t)\n{\n\tEdge *e1 = N[s].e = new Edge(id, &N[s], &N[t]);\n\n\tif (T == 1)\n\t{\n\t\tEdge *e2 = N[t].e = new Edge(-id, &N[t], &N[s]);\n\n\t\te1->revEdge = e2;\n\t\te2->revEdge = e1;\n\n\t\t//  N[s]->firstEdge->revEdge = N[t].e firstEdge \n\n\t\tN[s].deg++;\n\t\tN[t].deg++;\n\t}\n\telse\n\t{\n\t\tN[s].outDeg++;\n\t\tN[t].inDeg++;\n\t}\n}\n\nstd::vector<Edge *> path;\n\n// \ninline void dfs1(Node *v)\n{\n\twhile (v->e)\n\t{\n\t\tEdge *e = v->e;\n\t\tv->e = v->e->next; // \n\n\t\tif (e->vis) continue; //  vis  true\n\n\t\te->revEdge->vis = true; // \n\n\t\tdfs1(e->t);\n\n\t\tpath.push_back(e);\n\t}\n}\n\n// \ninline void dfs2(Node *v)\n{\n\twhile (v->e)\n\t{\n\t\tEdge *e = v->e;\n\t\tv->e = v->e->next; // \n\n\t\tdfs2(e->t);\n\n\t\tpath.push_back(e);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &T);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(i, u, v); // \n\t}\n\n\tint haveAns = true;\n\tif (T == 1)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].deg % 2 == 1) // \n\t\t\t{\n\t\t\t\thaveAns = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].inDeg != N[i].outDeg) // \n\t\t\t{\n\t\t\t\thaveAns = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!haveAns) puts(\"NO\");\n\telse\n\t{\n\t\tif (T == 1)\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (N[i].deg) // \n\t\t\t\t{\n\t\t\t\t\tdfs1(&N[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (N[i].outDeg) // \n\t\t\t\t{\n\t\t\t\t\tdfs2(&N[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (path.size() != m) // \n\t\t{\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"YES\");\n\t\t\tfor (int i = path.size() - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tprintf(\"%d%c\", path[i]->id, i == 0 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/euler-circuit-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: euler-circuit-notes\ndate: 2017-01-01 11:09:00\n---\n\n\n\n<!-- more -->\n\n### [UOJ #117](http://uoj.ac/problem/117)\n![zyz ](images/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 1e5;\n\nstruct Node\n{\n\tstruct Edge *e;\n\tint deg; // \n\tint inDeg, outDeg; // \n} N[MAXN + 1];\n\nstruct Edge\n{\n\tint id;\n\tNode *s, *t;\n\tbool vis;\n\tEdge *next, *revEdge;\n\n\tEdge(int id, Node *s, Node *t) : id(id), s(s), t(t), vis(false), next(s->e) {}\n};\n\nint T;\n\ninline void addEdge(int id, int s, int t)\n{\n\tEdge *e1 = N[s].e = new Edge(id, &N[s], &N[t]);\n\n\tif (T == 1)\n\t{\n\t\tEdge *e2 = N[t].e = new Edge(-id, &N[t], &N[s]);\n\n\t\te1->revEdge = e2;\n\t\te2->revEdge = e1;\n\n\t\t//  N[s]->firstEdge->revEdge = N[t].e firstEdge \n\n\t\tN[s].deg++;\n\t\tN[t].deg++;\n\t}\n\telse\n\t{\n\t\tN[s].outDeg++;\n\t\tN[t].inDeg++;\n\t}\n}\n\nstd::vector<Edge *> path;\n\n// \ninline void dfs1(Node *v)\n{\n\twhile (v->e)\n\t{\n\t\tEdge *e = v->e;\n\t\tv->e = v->e->next; // \n\n\t\tif (e->vis) continue; //  vis  true\n\n\t\te->revEdge->vis = true; // \n\n\t\tdfs1(e->t);\n\n\t\tpath.push_back(e);\n\t}\n}\n\n// \ninline void dfs2(Node *v)\n{\n\twhile (v->e)\n\t{\n\t\tEdge *e = v->e;\n\t\tv->e = v->e->next; // \n\n\t\tdfs2(e->t);\n\n\t\tpath.push_back(e);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &T);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(i, u, v); // \n\t}\n\n\tint haveAns = true;\n\tif (T == 1)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].deg % 2 == 1) // \n\t\t\t{\n\t\t\t\thaveAns = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif (N[i].inDeg != N[i].outDeg) // \n\t\t\t{\n\t\t\t\thaveAns = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!haveAns) puts(\"NO\");\n\telse\n\t{\n\t\tif (T == 1)\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (N[i].deg) // \n\t\t\t\t{\n\t\t\t\t\tdfs1(&N[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (N[i].outDeg) // \n\t\t\t\t{\n\t\t\t\t\tdfs2(&N[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (path.size() != m) // \n\t\t{\n\t\t\tputs(\"NO\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tputs(\"YES\");\n\t\t\tfor (int i = path.size() - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tprintf(\"%d%c\", path[i]->id, i == 0 ? '\\n' : ' ');\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"euler-circuit-notes","published":1,"updated":"2017-01-02T06:38:41.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s360167ooxl1fok2ucx"},{"title":"Edmonds-Karp ","date":"2016-02-19T09:04:38.000Z","_content":"\n Edmonds-Karp  Dinic  Edmonds-Karp \n\n<!-- more -->\n\n### \n$ \\mathrm{cost} $\n\n Dinic  Edmonds-Karp \n\nEdmonds-Karp \n\n### \n1. \n2. **** $ \\times $ ****\n3. \n\n Bellman-Ford   \n\nEdmonds-Karp \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 400;\n\nstruct Node {\n\tstruct Edge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity, cost);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0, -cost);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge;\n\tN[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n\ninline void edmondskarp(int s, int t, int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].flow = 0;\n\t\t\tN[i].dist = INT_MAX;\n\t\t\tN[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].flow = INT_MAX;\n\t\tN[s].dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].dist == INT_MAX) break;\n\n\t\tfor (Edge *e = N[t].inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += N[t].flow;\n\t\t\te->reversedEdge->flow -= N[t].flow;\n\t\t}\n\n\t\tflow += N[t].flow;\n\t\tcost += N[t].dist * N[t].flow;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v, cap, cost;\n\t\tscanf(\"%d %d %d %d\", &u, &v, &cap, &cost);\n\t\taddEdge(u, v, cap, cost);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(1, n, n, flow, cost);\n\n\tprintf(\"%d %d\\n\", flow, cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/edmonds-karp-notes.md","raw":"title: Edmonds-Karp \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Edmonds-Karp\n  - \n  - \npermalink: edmonds-karp-notes\ndate: 2016-02-19 17:04:38\n---\n\n Edmonds-Karp  Dinic  Edmonds-Karp \n\n<!-- more -->\n\n### \n$ \\mathrm{cost} $\n\n Dinic  Edmonds-Karp \n\nEdmonds-Karp \n\n### \n1. \n2. **** $ \\times $ ****\n3. \n\n Bellman-Ford   \n\nEdmonds-Karp \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 400;\n\nstruct Node {\n\tstruct Edge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity, cost);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0, -cost);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge;\n\tN[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n\ninline void edmondskarp(int s, int t, int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].flow = 0;\n\t\t\tN[i].dist = INT_MAX;\n\t\t\tN[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].flow = INT_MAX;\n\t\tN[s].dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].dist == INT_MAX) break;\n\n\t\tfor (Edge *e = N[t].inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += N[t].flow;\n\t\t\te->reversedEdge->flow -= N[t].flow;\n\t\t}\n\n\t\tflow += N[t].flow;\n\t\tcost += N[t].dist * N[t].flow;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v, cap, cost;\n\t\tscanf(\"%d %d %d %d\", &u, &v, &cap, &cost);\n\t\taddEdge(u, v, cap, cost);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(1, n, n, flow, cost);\n\n\tprintf(\"%d %d\\n\", flow, cost);\n\n\treturn 0;\n}\n```\n","slug":"edmonds-karp-notes","published":1,"updated":"2016-12-25T03:05:44.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s3c016eooxlotgt0e0n"},{"title":" Docker ","date":"2016-12-13T13:19:00.000Z","_content":"\nOnline JudgeSandbox\n\n<!-- more -->\n\n### \n `setrlimit()`Set Resource Limit\n\n`setrlimit()` Man Page`setrlimit()` `RLIMIT_RTTIME` CPU    `sleep()`  `scanf()` \n\n### \nSystem Call Web \n\n `ptrace()`  `seccamp` `ptrace()`  `seccamp` \n\n `ptrace()` [HustOJ](https://github.com/zhblue/hustoj)[UOJ](https://github.com/vfleaking/uoj)  \n `seccamp` [QDUOJ](https://github.com/QingdaoU/Judger)[TJudger](https://github.com/TimHsue/TJudger)\n\n###  Docker \nSandbox `chroot`  Docker \n\n Docker `fork()`  `setrlimit()`  `exec` \n\n .Net  Python   \n\nDocker \n\n `docker`  [`dockerode`](https://github.com/apocas/dockerode/)  Docker \n\n Docker  .Net  Python  C++   \n Docker Docker  32 \n\n### \n Web \n\n\n\n1.  Web \n2.  Web \n3. \n4. \n5. \n6.  Web \n\n\n\n![](docker-sandbox-judger/image.svg)\n","source":"_posts/docker-sandbox-judger.md","raw":"title:  Docker \ncategories: OI\ntags: \n  - Docker\n  - \npermalink: docker-sandbox-judger\ndate: 2016-12-13 21:19:00\n---\n\nOnline JudgeSandbox\n\n<!-- more -->\n\n### \n `setrlimit()`Set Resource Limit\n\n`setrlimit()` Man Page`setrlimit()` `RLIMIT_RTTIME` CPU    `sleep()`  `scanf()` \n\n### \nSystem Call Web \n\n `ptrace()`  `seccamp` `ptrace()`  `seccamp` \n\n `ptrace()` [HustOJ](https://github.com/zhblue/hustoj)[UOJ](https://github.com/vfleaking/uoj)  \n `seccamp` [QDUOJ](https://github.com/QingdaoU/Judger)[TJudger](https://github.com/TimHsue/TJudger)\n\n###  Docker \nSandbox `chroot`  Docker \n\n Docker `fork()`  `setrlimit()`  `exec` \n\n .Net  Python   \n\nDocker \n\n `docker`  [`dockerode`](https://github.com/apocas/dockerode/)  Docker \n\n Docker  .Net  Python  C++   \n Docker Docker  32 \n\n### \n Web \n\n\n\n1.  Web \n2.  Web \n3. \n4. \n5. \n6.  Web \n\n\n\n![](docker-sandbox-judger/image.svg)\n","slug":"docker-sandbox-judger","published":1,"updated":"2016-12-13T13:24:53.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s3i016mooxlfujpjwv5"},{"title":"Dinic ","date":"2016-02-03T10:57:59.000Z","_content":"\nDinic  $ O(n ^ 2m) $ \n\n<!-- more -->\n\n### \n* $ \\mathrm{capacity}(e) $  $ e(u, v) $ \n\n* $ \\mathrm{flow}(e) $  $ e(u, v) $ \n\n*  $ \\mathrm{capacity}(e) - \\mathrm{flow}(e) $ $ \\mathrm{e}(u, v) $ \n\n*  $ 0 $\n\n* \n\n* augmenting path****\n\n* augmenting****\n\n*  $ \\mathrm{level}(u) $  $ u $ \n\n* ********\n\n### \n1. \n2. \n3.  2  1 \n4. \n\n\n\n### \nDinic \n\n DFS \n\n### \n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} N[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n        \tN[i].level = 0;\n            N[i].currentEdge = N[i].firstEdge;\n        }\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge, N[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n```\n","source":"_posts/dinic-notes.md","raw":"title: Dinic \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Dinic\n  -   \npermalink: dinic-notes\ndate: 2016-02-03 18:57:59\n---\n\nDinic  $ O(n ^ 2m) $ \n\n<!-- more -->\n\n### \n* $ \\mathrm{capacity}(e) $  $ e(u, v) $ \n\n* $ \\mathrm{flow}(e) $  $ e(u, v) $ \n\n*  $ \\mathrm{capacity}(e) - \\mathrm{flow}(e) $ $ \\mathrm{e}(u, v) $ \n\n*  $ 0 $\n\n* \n\n* augmenting path****\n\n* augmenting****\n\n*  $ \\mathrm{level}(u) $  $ u $ \n\n* ********\n\n### \n1. \n2. \n3.  2  1 \n4. \n\n\n\n### \nDinic \n\n DFS \n\n### \n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} N[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n        \tN[i].level = 0;\n            N[i].currentEdge = N[i].firstEdge;\n        }\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge, N[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n```\n","slug":"dinic-notes","published":1,"updated":"2016-12-24T13:13:48.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s3q016sooxl1qscxmkg"},{"title":"","date":"2016-04-13T07:41:16.000Z","_content":"\n $ 1 $ ~ $ n $ \n\n<!-- more -->\n\n $ f(n) $\n\n $ n $  $ n - 1 $  $ 1 $\n\n $ n $  $ n $  $ 1 $  $ n $  $ 1 $ $ f(n - 1) $\n\n   $ n $  1  1  $ n $  1  $ f(n - 2) $\n\n\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","source":"_posts/derangement-number.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \npermalink: derangement-number\ndate: 2016-04-13 15:41:16\n---\n\n $ 1 $ ~ $ n $ \n\n<!-- more -->\n\n $ f(n) $\n\n $ n $  $ n - 1 $  $ 1 $\n\n $ n $  $ n $  $ 1 $  $ n $  $ 1 $ $ f(n - 1) $\n\n   $ n $  1  1  $ n $  1  $ f(n - 2) $\n\n\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","slug":"derangement-number","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s3w016zooxl934kfe33"},{"title":"CTSC1999 - ","id":"59","updated":"2016-02-24T13:42:46.000Z","date":"2016-02-24T13:41:36.000Z","_content":"\n `n`  `m`  `i`  `H[i]`  1\n\n<!-- more -->\n\n### \n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### \n  qwq\n\n `t` `t + 1`  0 ********\n\n 1\n\n  qwq\n\n`n`  `m` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/ctsc1999-home.md","raw":"title: CTSC1999 - \ncategories: OI\ntags: \n  - COGS\n  - CTSC\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: ctsc1999-home\nid: 59\nupdated: '2016-02-24 21:42:46'\ndate: 2016-02-24 21:41:36\n---\n\n `n`  `m`  `i`  `H[i]`  1\n\n<!-- more -->\n\n### \n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### \n  qwq\n\n `t` `t + 1`  0 ********\n\n 1\n\n  qwq\n\n`n`  `m` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"ctsc1999-home","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s410174ooxl2pkymw5v"},{"title":"CTSC1997 -  DP","id":"15","updated":"2016-01-19T13:05:52.000Z","date":"2016-01-06T21:12:01.000Z","_content":"\n N<= 300  M \n\n<!-- more -->\n\n### \n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### \n $f[i][m]$  `i`  `m` \n\n1.  `i` **** `k` `m - k - 1` ****\n2.  `i`  `m` ****\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","source":"_posts/ctsc1997-course.md","raw":"title: CTSC1997 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - CTSC\n  - DP\n  -  DP\npermalink: ctsc1997-course\nid: 15\nupdated: '2016-01-19 21:05:52'\ndate: 2016-01-07 05:12:01\n---\n\n N<= 300  M \n\n<!-- more -->\n\n### \n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### \n $f[i][m]$  `i`  `m` \n\n1.  `i` **** `k` `m - k - 1` ****\n2.  `i`  `m` ****\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","slug":"ctsc1997-course","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4b017fooxl29wv8xxx"},{"title":"CTSC2016 & APIO2016 ","date":"2016-05-09T10:18:13.000Z","_content":"\n CTSC & APIO\n\n<!-- more -->\n\n### 5.1\n   \n QAQ  \nqwq\n\nOxer  yts1999 RP++\n\n Teachk  ovo \n\n HA CXC   \n QwQ   \n\n~~sui  Fancy ~~  \nCOGS  QwQ ~~ID ~~  \n ovo  \n NOI LinuxUbuntu 14.04 LTS  \n~~ SDOI ~~\n\nFancy  vim   \n sui ~  \n~~ JSOI  vim ~~\n\n NOI   ~~~~  \n~~~~\n\n QQ smg   \n %fqk    \n QQ  DQS    \n~~~~\n\n COGS   \nsui Menci  \n%%%%%   \n~~Mencimdzz  &@!#@%~& ~~\n\n wmd  Chenyao    \n Chenyao   \n~~mdzz ~~\n~~Chenyao  Orz~~\n\n   \n   \n  qwq\n\n### 5.2\nCTSC2016 Day1\n\n  \n \n\n     \n   \n   \n\n dms    \n     \n   \n~~mdzz ~~\n\n \n\n   \n .jpg  \nSuffix Array 5    \n\n   \n   \n   \n  \n   \n `else`   \n~~mdzz ~~\n\n   \n   \n   \n   `n`    \n~~mdzz~~ \n\n   \n   \n   \n~~ 5 ~~\n\n   \n  \n~~mdzz ~~  \n\n 5  5  \n\n   \n T3 \n\n T3    \n\n Fancy    \nFancy  \nMenci&@!#@%~&   sui    \n~~mdzz  ~~\n\n  \n 01  X    \n  \n     \n  \n 0   \n  \n  \nmdzz   0  \n\n~~ ~~\n\n    XD  \n yts1999    \n  \n   \n\n`5 + 5 + 2 = 12`    \nFancy  0  15  \n\n Fe  \n\nsui  HNOI ~~~~\n\n### 5.3\n  QAQ\n\nfaebdc  \n\n     \n Fancy  \n\n   \n   \n\n   QAQ   mdzz   \n qwq   \nsui   0.0 ovoFancy  Kindle  ovo \n\n \n\nFancy    \nwoc   fqk   \nfqkFancy   \nMenci&@!#@%~&   \nfqkwori  .jpg HA    sb   \nfqk  shenben 2333\n\n### 5.4\nCTSC2016 Day2\n\n\n\n \n\n  \n  \n\n\n QAQ   XD\n\n   \n10   \n 3  \n\n   \n 2333  \n  mdzz   \n\n   SPFA  qwq   \n  md   \nmdzz  youdu\n\n APIO2009  atm    \n Tarjan \n\nTarjan    \n   \n \n\n   \n \n\n~~mdzz ~~    \n\n\n  \n  \n\n\n `O3`   \n n    3M+  \n`checker` 20  \n\n QAQ    \n  XD\n\n \n\n Dashgua SPFA 70    \n~~mdzz ~~  \n Cu    \ndms  A \n\n  ~~mdzz ~~\n\n qwq `O(E)`  SPFA   \n Fe  QAQ\n\nyts1999Oxerdmsheheda    \n 2333 \n\n qwq  \n abclzr lzr \n\nKZ  UbuntuWindows     \n \n\n### 5.5\n\n\n \n\n  \nKZ Menci    \nFancyMenci   \n~~Menci&@!#@%~&~~  \n~~.jpg~~\n\n qvq\n\nFancy    \n \n\n N  \n\n SDOI   &@!#@%~& 233333333\n\n### 5.6\n fqk \n\n XXXX  Orz fqk \n\n qwq \n\n HNOI  APIO  qwq  \nAPIO \n\n### 5.7\nAPIO2016 Day1\n\nAPIO  qwq  vim  \n\n Johann %%% \n\n PDF  qwq\n\n \n\n   \n   \n\n\n   DP    XD\n\n     \n\n 16  \n\n~~mdzz~~     \n30.38    46.38    \n\n 42    \n WA    \n\n CMS  ~~~~  \n~~~~\n\n  \n\nT3      \nT2  2  DP   QAQ\n\n Fe  XD\n\n THU  QwQ  \n Fuxey  Sengxian   qwq  \nSengxian ****46.38  23333\n\n### 5.8\n\n\n  smg   sui      \nmdzz   XD\n\n Fancy    \n   Fancy  XD\n\n  Cu 46  \n\nzdw1999  qvq  \n \n\n HA     ~~~~\n\n~~~~\n\n COGS WWTTTTTTTT \n\n Fancy  Ubuntu KZ   XD\n\n### 5.9\nget   23333\n\n \n\n  qwq\n\n \n\n \n","source":"_posts/ctsc-apio-2016.md","raw":"title: CTSC2016 & APIO2016 \ncategories: \n  - Diary\npermalink: ctsc-apio-2016\ndate: 2016-05-09 18:18:13\n---\n\n CTSC & APIO\n\n<!-- more -->\n\n### 5.1\n   \n QAQ  \nqwq\n\nOxer  yts1999 RP++\n\n Teachk  ovo \n\n HA CXC   \n QwQ   \n\n~~sui  Fancy ~~  \nCOGS  QwQ ~~ID ~~  \n ovo  \n NOI LinuxUbuntu 14.04 LTS  \n~~ SDOI ~~\n\nFancy  vim   \n sui ~  \n~~ JSOI  vim ~~\n\n NOI   ~~~~  \n~~~~\n\n QQ smg   \n %fqk    \n QQ  DQS    \n~~~~\n\n COGS   \nsui Menci  \n%%%%%   \n~~Mencimdzz  &@!#@%~& ~~\n\n wmd  Chenyao    \n Chenyao   \n~~mdzz ~~\n~~Chenyao  Orz~~\n\n   \n   \n  qwq\n\n### 5.2\nCTSC2016 Day1\n\n  \n \n\n     \n   \n   \n\n dms    \n     \n   \n~~mdzz ~~\n\n \n\n   \n .jpg  \nSuffix Array 5    \n\n   \n   \n   \n  \n   \n `else`   \n~~mdzz ~~\n\n   \n   \n   \n   `n`    \n~~mdzz~~ \n\n   \n   \n   \n~~ 5 ~~\n\n   \n  \n~~mdzz ~~  \n\n 5  5  \n\n   \n T3 \n\n T3    \n\n Fancy    \nFancy  \nMenci&@!#@%~&   sui    \n~~mdzz  ~~\n\n  \n 01  X    \n  \n     \n  \n 0   \n  \n  \nmdzz   0  \n\n~~ ~~\n\n    XD  \n yts1999    \n  \n   \n\n`5 + 5 + 2 = 12`    \nFancy  0  15  \n\n Fe  \n\nsui  HNOI ~~~~\n\n### 5.3\n  QAQ\n\nfaebdc  \n\n     \n Fancy  \n\n   \n   \n\n   QAQ   mdzz   \n qwq   \nsui   0.0 ovoFancy  Kindle  ovo \n\n \n\nFancy    \nwoc   fqk   \nfqkFancy   \nMenci&@!#@%~&   \nfqkwori  .jpg HA    sb   \nfqk  shenben 2333\n\n### 5.4\nCTSC2016 Day2\n\n\n\n \n\n  \n  \n\n\n QAQ   XD\n\n   \n10   \n 3  \n\n   \n 2333  \n  mdzz   \n\n   SPFA  qwq   \n  md   \nmdzz  youdu\n\n APIO2009  atm    \n Tarjan \n\nTarjan    \n   \n \n\n   \n \n\n~~mdzz ~~    \n\n\n  \n  \n\n\n `O3`   \n n    3M+  \n`checker` 20  \n\n QAQ    \n  XD\n\n \n\n Dashgua SPFA 70    \n~~mdzz ~~  \n Cu    \ndms  A \n\n  ~~mdzz ~~\n\n qwq `O(E)`  SPFA   \n Fe  QAQ\n\nyts1999Oxerdmsheheda    \n 2333 \n\n qwq  \n abclzr lzr \n\nKZ  UbuntuWindows     \n \n\n### 5.5\n\n\n \n\n  \nKZ Menci    \nFancyMenci   \n~~Menci&@!#@%~&~~  \n~~.jpg~~\n\n qvq\n\nFancy    \n \n\n N  \n\n SDOI   &@!#@%~& 233333333\n\n### 5.6\n fqk \n\n XXXX  Orz fqk \n\n qwq \n\n HNOI  APIO  qwq  \nAPIO \n\n### 5.7\nAPIO2016 Day1\n\nAPIO  qwq  vim  \n\n Johann %%% \n\n PDF  qwq\n\n \n\n   \n   \n\n\n   DP    XD\n\n     \n\n 16  \n\n~~mdzz~~     \n30.38    46.38    \n\n 42    \n WA    \n\n CMS  ~~~~  \n~~~~\n\n  \n\nT3      \nT2  2  DP   QAQ\n\n Fe  XD\n\n THU  QwQ  \n Fuxey  Sengxian   qwq  \nSengxian ****46.38  23333\n\n### 5.8\n\n\n  smg   sui      \nmdzz   XD\n\n Fancy    \n   Fancy  XD\n\n  Cu 46  \n\nzdw1999  qvq  \n \n\n HA     ~~~~\n\n~~~~\n\n COGS WWTTTTTTTT \n\n Fancy  Ubuntu KZ   XD\n\n### 5.9\nget   23333\n\n \n\n  qwq\n\n \n\n \n","slug":"ctsc-apio-2016","published":1,"updated":"2016-11-20T15:49:31.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4g017looxld0m4k1w0"},{"title":"CQOI2016 -  DP","date":"2016-04-21T15:31:24.000Z","_content":"\n $ 3 $  $ 8 $  $ 4 $$ 3000988721 $$ 23333333333 $$ 14444101000 $$ 1015400080 $$ 10010012022 $\n\n $ 11 $  $ 0 $ $ L $  $ R $ $ [L, R] $ $ L $  $ R $  $ 11 $ \n\n<!-- more -->\n\n### \n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### \n $ F(x) $  $ x $ $ F(R) - F(L - 1) $ \n\n $ F(x) $  DP\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n$ 10 $  $ 4 $ $ 8 $\n\n $ < limit $\n\n DP  $ O(10 ^ 4 * 2 ^ 4) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-number.md","raw":"title: CQOI2016 -  DP\ndate: 2016-04-21 23:31:24\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  -  DP\n  - DP\npermalink: cqoi2016-number\n---\n\n $ 3 $  $ 8 $  $ 4 $$ 3000988721 $$ 23333333333 $$ 14444101000 $$ 1015400080 $$ 10010012022 $\n\n $ 11 $  $ 0 $ $ L $  $ R $ $ [L, R] $ $ L $  $ R $  $ 11 $ \n\n<!-- more -->\n\n### \n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### \n $ F(x) $  $ x $ $ F(R) - F(L - 1) $ \n\n $ F(x) $  DP\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n$ 10 $  $ 4 $ $ 8 $\n\n $ < limit $\n\n DP  $ O(10 ^ 4 * 2 ^ 4) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-number","published":1,"updated":"2016-10-24T23:35:36.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4j017nooxl9ak6md5m"},{"title":"CQOI2016 -  + ","date":"2016-04-21T10:57:52.000Z","_content":"\n $ s $$ t $  $ s $$ t $  $ s $$ t $  $ s $$ t $ \n\n $ N $  $ \\frac{N(N  1)}{2} $\n\n<!-- more -->\n\n### \n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### \n $ s $$ t $  $ S $  $ T $ \n\n $ S $ $ T $  $ u $ $ s $  $ u $  $ S' $$ T' $ $ S $  $ S' $ \n\n $ N - 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-cuts.md","raw":"title: CQOI2016 -  + \ndate: 2016-04-21 18:57:52\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: cqoi2016-cuts\n---\n\n $ s $$ t $  $ s $$ t $  $ s $$ t $  $ s $$ t $ \n\n $ N $  $ \\frac{N(N  1)}{2} $\n\n<!-- more -->\n\n### \n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### \n $ s $$ t $  $ S $  $ T $ \n\n $ S $ $ T $  $ u $ $ s $  $ u $  $ S' $$ T' $ $ S $  $ S' $ \n\n $ N - 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-cuts","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4q017uooxldtfgrhmn"},{"title":"CQOI2011 - CDQ","date":"2016-06-20T12:10:00.000Z","_content":"\n $ A $ $ i < j $ $ A_i > A_j $  $ (i,\\ j) $  $ 1 $  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 3295](http://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n### \n\n\n  ****************\n\n $ a_i $  $ n - a_i + 1 $******** CDQ \n\n $ i $  $ n - i + 1 $ CDQ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 50000;\n\nstruct Triple {\n\tint id, pos, num;\n\tunsigned int *ans;\n\n\tTriple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tTriple() {}\n\t\n\tbool operator<(const Triple &other) const { return id < other.id; }\n} a[MAXN];\n\nint n, m;\n\nstruct BinaryIndexedTree {\n\tunsigned int a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tunsigned int query(const int x) {\n\t\tunsigned int ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\t/*\n\tfor (Triple *a = l; a <= r; a++) {\n\t\tif (a->ans) {\n\t\t\tfor (Triple *b = l; b < a; b++) {\n\t\t\t\tif (b->pos < a->pos && b->num < a->num) (*a->ans)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tif (l == r) return;\n\n\tTriple *m = l + (r - l) / 2;\n\n\tcdq(l, m);\n\tcdq(m + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = m + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= m && p1->pos <= p2->pos) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tbit.update(q->num, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) *q->ans += bit.query(q->num);\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\tbit.clear(q->num);\n\t\t*p = *q;\n\t\tassert(p->num != 0);\n\t}\n}\n\n/*\ninline void print() {\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"[%d, %d, %d]%s\", a[i].id, a[i].pos, a[i].num, i == n - 1 ? \"\\n\" : \", \");\n\t}\n}\n*/\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int num[MAXN], pos[MAXN], del[MAXM];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &num[i]), pos[num[i] - 1] = i + 1;\n\n\tstatic bool deleted[MAXN];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdel[i] = pos[x - 1];\n\t\tdeleted[del[i] - 1] = true;\n\t}\n\n\tstatic unsigned int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) if (!deleted[i - 1]) {\n\t\ta[cnt] = Triple(i, num[i - 1], &ans[n - cnt - 1]); // , printf(\"ans[%d]\\n\", n - cnt - 1);\n\t\tcnt++;\n\t}\n\n\t// const int invalidCnt = cnt;\n\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\ta[cnt++] = Triple(del[i], num[del[i] - 1], &ans[i]); // , printf(\"ans[%d]\\n\", i);\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t}\n\t\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tstd::sort(a, a + cnt);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t\ta[i].num = n - a[i].num + 1;\n\t}\n\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tfor (int i = n - 2; i >= 0; i--) ans[i] += ans[i + 1];\n\tfor (int i = 0; i < m; i++) printf(\"%u\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2011-inverse.md","raw":"title: CQOI2011 - CDQ\ndate: 2016-06-20 20:10:00\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: cqoi2011-inverse\n---\n\n $ A $ $ i < j $ $ A_i > A_j $  $ (i,\\ j) $  $ 1 $  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 3295](http://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n### \n\n\n  ****************\n\n $ a_i $  $ n - a_i + 1 $******** CDQ \n\n $ i $  $ n - i + 1 $ CDQ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 50000;\n\nstruct Triple {\n\tint id, pos, num;\n\tunsigned int *ans;\n\n\tTriple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tTriple() {}\n\t\n\tbool operator<(const Triple &other) const { return id < other.id; }\n} a[MAXN];\n\nint n, m;\n\nstruct BinaryIndexedTree {\n\tunsigned int a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tunsigned int query(const int x) {\n\t\tunsigned int ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\t/*\n\tfor (Triple *a = l; a <= r; a++) {\n\t\tif (a->ans) {\n\t\t\tfor (Triple *b = l; b < a; b++) {\n\t\t\t\tif (b->pos < a->pos && b->num < a->num) (*a->ans)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tif (l == r) return;\n\n\tTriple *m = l + (r - l) / 2;\n\n\tcdq(l, m);\n\tcdq(m + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = m + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= m && p1->pos <= p2->pos) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tbit.update(q->num, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) *q->ans += bit.query(q->num);\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\tbit.clear(q->num);\n\t\t*p = *q;\n\t\tassert(p->num != 0);\n\t}\n}\n\n/*\ninline void print() {\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"[%d, %d, %d]%s\", a[i].id, a[i].pos, a[i].num, i == n - 1 ? \"\\n\" : \", \");\n\t}\n}\n*/\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int num[MAXN], pos[MAXN], del[MAXM];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &num[i]), pos[num[i] - 1] = i + 1;\n\n\tstatic bool deleted[MAXN];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdel[i] = pos[x - 1];\n\t\tdeleted[del[i] - 1] = true;\n\t}\n\n\tstatic unsigned int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) if (!deleted[i - 1]) {\n\t\ta[cnt] = Triple(i, num[i - 1], &ans[n - cnt - 1]); // , printf(\"ans[%d]\\n\", n - cnt - 1);\n\t\tcnt++;\n\t}\n\n\t// const int invalidCnt = cnt;\n\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\ta[cnt++] = Triple(del[i], num[del[i] - 1], &ans[i]); // , printf(\"ans[%d]\\n\", i);\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t}\n\t\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tstd::sort(a, a + cnt);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t\ta[i].num = n - a[i].num + 1;\n\t}\n\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tfor (int i = n - 2; i >= 0; i--) ans[i] += ans[i + 1];\n\tfor (int i = 0; i < m; i++) printf(\"%u\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2011-inverse","published":1,"updated":"2016-06-20T14:10:53.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s4w0181ooxlklyp0pa2"},{"title":"","date":"2016-03-15T09:16:12.000Z","_content":"\n\n\n<!-- more -->\n\n### \n#### \n $ n $  $ p_i $ \n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### \n $ n $  $ p_i $ \n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### \n \n\n\n\n### \n#### \n $ n $  $ f(n) $ $ f(0) = 1 $\n\n$$ f(n) = f(n - 1) * n $$\n\n $ f(n) = n! $\n\n#### \n $ n $  $ k $  $ P(n, k) $ $ n $  $ n - 1 $  $ k $  $ n - k + 1 $ \n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n $ n! $  $ n - k $ \n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### \n $ k $  $ i $  $ n_i $  $ n = \\sum\\limits_{i = 1}^{k}n_i $ $ n! $\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### \n#### \n n  k  $ C(n, k) $ $ P(n, k) $  n  k  k \n\n$$ P(n, k) = C(n, k) * k! $$\n\n\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### \n$ C(n, 0) = C(n, n) = 1 $ \n\n$ C(n, k) = C(n, n - k) $  $ k $  $ n - k $ \n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ Pascal \n\n#### \n n  k  $ C(n + k - 1, k) $ \n\n#### \n##### \n Pascal \n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### \n `double`  `long long` \n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### \n#### Fibonacci \n $ n $ \n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan \n $ n $  $ n - 3 $  $ n - 2 $  $ f(n) $\n\n $ i $  $ V_i $ $ {V_1}{V_k}{V_n} $$ 1 \\lt k \\lt n $ $ k $  $ n - k + 1 $ \n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### \n#### \n $ \\{ a_1, a_2, \\cdots, a_n \\} $  $ 1 \\lt i \\leq n $  $ a_t - a_{i - 1} = d $\n\n$$ a_i = a_i + (i - 1)d $$\n\n\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### \n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n\n\n#### \n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","source":"_posts/combinatorics-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  -   \npermalink: combinatorics-notes\ndate: 2016-03-15 17:16:12\n---\n\n\n\n<!-- more -->\n\n### \n#### \n $ n $  $ p_i $ \n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### \n $ n $  $ p_i $ \n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### \n \n\n\n\n### \n#### \n $ n $  $ f(n) $ $ f(0) = 1 $\n\n$$ f(n) = f(n - 1) * n $$\n\n $ f(n) = n! $\n\n#### \n $ n $  $ k $  $ P(n, k) $ $ n $  $ n - 1 $  $ k $  $ n - k + 1 $ \n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n $ n! $  $ n - k $ \n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### \n $ k $  $ i $  $ n_i $  $ n = \\sum\\limits_{i = 1}^{k}n_i $ $ n! $\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### \n#### \n n  k  $ C(n, k) $ $ P(n, k) $  n  k  k \n\n$$ P(n, k) = C(n, k) * k! $$\n\n\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### \n$ C(n, 0) = C(n, n) = 1 $ \n\n$ C(n, k) = C(n, n - k) $  $ k $  $ n - k $ \n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ Pascal \n\n#### \n n  k  $ C(n + k - 1, k) $ \n\n#### \n##### \n Pascal \n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### \n `double`  `long long` \n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### \n#### Fibonacci \n $ n $ \n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan \n $ n $  $ n - 3 $  $ n - 2 $  $ f(n) $\n\n $ i $  $ V_i $ $ {V_1}{V_k}{V_n} $$ 1 \\lt k \\lt n $ $ k $  $ n - k + 1 $ \n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### \n#### \n $ \\{ a_1, a_2, \\cdots, a_n \\} $  $ 1 \\lt i \\leq n $  $ a_t - a_{i - 1} = d $\n\n$$ a_i = a_i + (i - 1)d $$\n\n\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### \n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n\n\n#### \n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","slug":"combinatorics-notes","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s560189ooxl8r20eqsp"},{"title":"COGS 746 - ","id":"53","updated":"2016-02-19T03:44:48.000Z","date":"2016-02-19T03:43:42.000Z","_content":"\n $ N * N $ \n\n<!-- more -->\n\n### \n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### \n\n\n> \n\n>  S  T X  S  Y  X  Y \n\n> COGS 734 - \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-746.md","raw":"title: COGS 746 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-746\nid: 53\nupdated: '2016-02-19 11:44:48'\ndate: 2016-02-19 11:43:42\n---\n\n $ N * N $ \n\n<!-- more -->\n\n### \n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### \n\n\n> \n\n>  S  T X  S  Y  X  Y \n\n> COGS 734 - \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-746","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s5d018fooxl5ozgscbd"},{"title":"COGS 742 - ","id":"58","updated":"2016-02-23T13:44:58.000Z","date":"2016-02-23T13:44:06.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### \n**** 1 0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-742.md","raw":"title: COGS 742 - \ncategories: OI\ntags: \n  - COGS\n  - Edmonds-Karp\n  -  24 \n  - \n  - \n  - \npermalink: cogs-742\nid: 58\nupdated: '2016-02-23 21:44:58'\ndate: 2016-02-23 21:44:06\n---\n\n\n\n<!-- more -->\n\n### \n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### \n**** 1 0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-742","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s5p018oooxl27rq9qgn"},{"title":"COGS 741 - ","id":"61","updated":"2016-02-25T07:38:10.000Z","date":"2016-02-25T07:37:15.000Z","_content":"\nG  `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### \n  \n\n\n\n   1****\n\n 0 0****\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-741.md","raw":"title: COGS 741 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Edmonds-Karp\n  - \npermalink: cogs-741\nid: 61\nupdated: '2016-02-25 15:38:10'\ndate: 2016-02-25 15:37:15\n---\n\nG  `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### \n  \n\n\n\n   1****\n\n 0 0****\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-741","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s5y018wooxl7i0ua8vq"},{"title":"COGS 740 - ","id":"60","updated":"2016-02-25T00:10:00.000Z","date":"2016-02-25T00:08:29.000Z","_content":"\n `n`  `n`  `i`  `j`  `c[i][j]` `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### \n****\n\n 1 0 1 0 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","source":"_posts/cogs-740.md","raw":"title: COGS 740 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Edmonds-Karp\n  - \n  - \npermalink: cogs-740\nid: 60\nupdated: '2016-02-25 08:10:00'\ndate: 2016-02-25 08:08:29\n---\n\n `n`  `n`  `i`  `j`  `c[i][j]` `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### \n****\n\n 1 0 1 0 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","slug":"cogs-740","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s640194ooxl2r9h3e11"},{"title":"COGS 739 - ","id":"57","updated":"2016-02-23T12:35:48.000Z","date":"2016-02-20T13:37:35.000Z","_content":"\nW  `m`  `n`  `i`  $ a_i $  `j`  $ b_j $  `i`  `j`  $ c_{ij} $\n\n<!-- more -->\n\n### \n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-739.md","raw":"title: COGS 739 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - \n  - Edmonds-Karp\n  -  24 \npermalink: cogs-739\nid: 57\nupdated: '2016-02-23 20:35:48'\ndate: 2016-02-20 21:37:35\n---\n\nW  `m`  `n`  `i`  $ a_i $  `j`  $ b_j $  `i`  `j`  $ c_{ij} $\n\n<!-- more -->\n\n### \n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-739","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s6c019dooxlmh2jkbae"},{"title":"COGS 738 - ","id":"52","updated":"2016-02-19T03:35:21.000Z","date":"2016-02-19T03:33:27.000Z","_content":"\n `n`  `m` \n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### \n\n\n 1 1 0 1 1 1 0\n\n\n\n**** `s`  0 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $ $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-738.md","raw":"title: COGS 738 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - \n  - Edmonds-Karp\n  -  24 \npermalink: cogs-738\nid: 52\nupdated: '2016-02-19 11:35:21'\ndate: 2016-02-19 11:33:27\n---\n\n `n`  `m` \n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### \n\n\n 1 1 0 1 1 1 0\n\n\n\n**** `s`  0 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $ $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-738","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s6n019looxlzh13wmyd"},{"title":"COGS 734 - ","id":"51","updated":"2016-02-15T09:03:18.000Z","date":"2016-02-15T09:02:01.000Z","_content":"\n $ M * N $ \n\n<!-- more -->\n\n### \n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### \n\n\n  ****\n\n\n\n S  T X  S  Y  X  Y \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-734.md","raw":"title: COGS 734 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-734\nid: 51\nupdated: '2016-02-15 17:03:18'\ndate: 2016-02-15 17:02:01\n---\n\n $ M * N $ \n\n<!-- more -->\n\n### \n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### \n\n\n  ****\n\n\n\n S  T X  S  Y  X  Y \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-734","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s6x019tooxl5anzrb2l"},{"title":"COGS 731 -  DP + ","id":"48","updated":"2016-02-09T06:40:10.000Z","date":"2016-02-09T06:37:32.000Z","_content":"\n `X1 ~ Xn`\n\n1.  `s`\n2.  `s` \n3.  `X1`  `Xn` `s` \n\n<!-- more -->\n\n### \n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### \n****\n\n $X_i$  $F_i$ $F_i$ $K$\n\n\n\n1.  $F_i = K$  1\n2.  $F_i = 1$  1\n3. $ X_jX_i $$F_i=F_j+1$ `i``j` `j`  `i`  1\n\n\n\n `i`  `i`  `i'` `i` `i'`  `i`  `i'`  1  1\n\n `1``n` \n\n**** 1NN\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-731.md","raw":"title: COGS 731 -  DP + \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \npermalink: cogs-731\nid: 48\nupdated: '2016-02-09 14:40:10'\ndate: 2016-02-09 14:37:32\n---\n\n `X1 ~ Xn`\n\n1.  `s`\n2.  `s` \n3.  `X1`  `Xn` `s` \n\n<!-- more -->\n\n### \n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### \n****\n\n $X_i$  $F_i$ $F_i$ $K$\n\n\n\n1.  $F_i = K$  1\n2.  $F_i = 1$  1\n3. $ X_jX_i $$F_i=F_j+1$ `i``j` `j`  `i`  1\n\n\n\n `i`  `i`  `i'` `i` `i'`  `i`  `i'`  1  1\n\n `1``n` \n\n**** 1NN\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-731","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7501a1ooxlw7ha4em1"},{"title":"COGS 729 - ","id":"47","updated":"2016-02-09T06:41:05.000Z","date":"2016-02-09T05:42:59.000Z","_content":"\n `m`  `ri` `n`  `ci` \n\n\n\n<!-- more -->\n\n### \n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### \n\n\n****\n\n `S` `S`  `T` `T`  `1`\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-729.md","raw":"title: COGS 729 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Dinic\npermalink: cogs-729\nid: 47\nupdated: '2016-02-09 14:41:05'\ndate: 2016-02-09 13:42:59\n---\n\n `m`  `ri` `n`  `ci` \n\n\n\n<!-- more -->\n\n### \n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### \n\n\n****\n\n `S` `S`  `T` `T`  `1`\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-729","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7c01a8ooxl7adpki8y"},{"title":"COGS 728 - ","id":"45","updated":"2016-02-06T14:53:58.000Z","date":"2016-02-06T14:52:12.000Z","_content":"\n $G=(V,E)$  P  G  V  P  P  G P  V  0G  G \n\n G \n\n<!-- more -->\n\n### \n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### \n 1 1\n\n\n\n `(u, v)` `u`  `v` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-728.md","raw":"title: COGS 728 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  - \n  -  24 \npermalink: cogs-728\nid: 45\nupdated: '2016-02-06 22:53:58'\ndate: 2016-02-06 22:52:12\n---\n\n $G=(V,E)$  P  G  V  P  P  G P  V  0G  G \n\n G \n\n<!-- more -->\n\n### \n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### \n 1 1\n\n\n\n `(u, v)` `u`  `v` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-728","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7j01afooxl6pdqftlp"},{"title":"COGS 727 - ","id":"49","updated":"2016-02-15T00:45:03.000Z","date":"2016-02-15T00:39:38.000Z","_content":"\nW  $ E = \\{ E1, E2, , Em \\} $ $ I = \\{ I1, I2, , In \\} $ $ E_j $  $ R_jI $ $ I_k $  $ c_k $ $ E_j $  $ p_j $ \n\n<!-- more -->\n\n### \n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### \n  ****\n\n********************\n\n Dinic ******** BFSBFS  `S`  `T`  `S`  `T` \n\n `std::set_difference` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-727.md","raw":"title: COGS 727 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-727\nid: 49\nupdated: '2016-02-15 08:45:03'\ndate: 2016-02-15 08:39:38\n---\n\nW  $ E = \\{ E1, E2, , Em \\} $ $ I = \\{ I1, I2, , In \\} $ $ E_j $  $ R_jI $ $ I_k $  $ c_k $ $ E_j $  $ p_j $ \n\n<!-- more -->\n\n### \n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### \n  ****\n\n********************\n\n Dinic ******** BFSBFS  `S`  `T`  `S`  `T` \n\n `std::set_difference` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-727","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7q01anooxl1oz6bhqz"},{"title":"COGS 439 -  + ","id":"50","updated":"2016-02-15T02:17:27.000Z","date":"2016-02-15T02:13:28.000Z","_content":"\n `n`  BUG `m`  BUG  BUG  BUG  BUG  BUG  BUG  BUG \n\n<!-- more -->\n\n### \n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### \n `unsigned int`  `i`  `i`  BUG  `std::tr1::unordered_map` `map[status]`  `status` \n\n `effectAddition``effectSubtract` BUG BUG\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n BUG  BUG  BUG\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n COGS  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n 24 ~~~~","source":"_posts/cogs-439.md","raw":"title: COGS 439 -  + \ncategories: OI\ntags: \n  - \n  - \n  - \n  - COGS\n  -  24 \n  - map\npermalink: cogs-439\nid: 50\nupdated: '2016-02-15 10:17:27'\ndate: 2016-02-15 10:13:28\n---\n\n `n`  BUG `m`  BUG  BUG  BUG  BUG  BUG  BUG  BUG \n\n<!-- more -->\n\n### \n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### \n `unsigned int`  `i`  `i`  BUG  `std::tr1::unordered_map` `map[status]`  `status` \n\n `effectAddition``effectSubtract` BUG BUG\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n BUG  BUG  BUG\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n COGS  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n 24 ~~~~","slug":"cogs-439","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s7y01avooxl5ku8le04"},{"title":"COGS 396 - ","id":"46","updated":"2016-02-06T15:04:22.000Z","date":"2016-02-06T15:02:55.000Z","_content":"\n `n` n 1234 ...... \n\n1. \n2.  2 \n\n `n` \n\n<!-- more -->\n\n### \n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-396.md","raw":"title: COGS 396 - \ncategories: OI\ntags: \n  - COGS\n  - \n  -  24 \npermalink: cogs-396\nid: 46\nupdated: '2016-02-06 23:04:22'\ndate: 2016-02-06 23:02:55\n---\n\n `n` n 1234 ...... \n\n1. \n2.  2 \n\n `n` \n\n<!-- more -->\n\n### \n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-396","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8601b4ooxl9xtoeca1"},{"title":"COGS 14 - ","id":"44","updated":"2016-02-06T14:22:28.000Z","date":"2016-02-06T14:21:18.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### \n~~~~\n\n  \n\n `X`  `Y` `S` `S`  `X`  `1` `T` `Y`  `T`  `1` `(u, v)` `u`  `v`  `u`  `v` **** `1`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-14.md","raw":"title: COGS 14 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  - \n  -  24 \npermalink: cogs-14\nid: 44\nupdated: '2016-02-06 22:22:28'\ndate: 2016-02-06 22:21:18\n---\n\n\n\n<!-- more -->\n\n### \n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### \n~~~~\n\n  \n\n `X`  `Y` `S` `S`  `X`  `1` `T` `Y`  `T`  `1` `(u, v)` `u`  `v`  `u`  `v` **** `1`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-14","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8b01b9ooxlt9mufp9o"},{"title":"CodeVS 3269 -  DP","id":"3","updated":"2016-01-19T13:08:13.000Z","date":"2015-11-22T21:00:15.000Z","_content":"\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> 1\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n  \n  \n `f[v]`  `v` `v` <= `V`    \n 01 \n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `v` `v`  `V`  `0`  `f[v]`  `v`  `f[v]`  `Vi`  `i`  `f[v]` `f[v - Vi]` **** `i`   \n\n `V` / `Vi`  `01`  01   \n 01  01 ******** `f[v]` `f[v - Vi]` **** `i`  `v`  `0`  `V`   \n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `V = 10` `Vi = 3` `Wi = 5`  \n\n `01`   \n `v = 10` **`f[v - Vi] = f[7] = 0`**`f[v]`  `5`  \n `v = 9` `f[v - Vi] = f[6] = 0``f[v]`  `5`  \n `v = 8` `f[v - Vi] = f[5] = 0``f[v]`  `5`  \n** `v = 7` `f[v - Vi] = f[4] = 0``f[v]`  `5`**  \n  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n `v = 3` `f[v - Vi] = f[0] = 0``f[v]`  `5`  \n\n  \n `v = 3` **`f[v - Vi] = f[0] = 0`**`f[v]`  `5`  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n  \n** `v = 6` `f[v - Vi] = f[3] = 5``f[v]`  `10`**  \n  \n** `v = 9` `f[v - Vi] = f[6] = 10``f[v]`  `15`**  \n `v = 10` `f[v - Vi] = f[7] = 10``f[v]`  `15`  \n\n 01   \n\n01   \n `Mi`  `Mi`  01  01 $O(V*{\\Sigma}Mi)$  \n `t`  01  `k`****${\\Sigma}k = Mi$ `k`  $1$,$2$,$4$,,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$  \n `Mi = 17`  `5`  `k`  `1`,`2`,`4`,`8`,`2`  \n$O(V * {\\Sigma}{\\log}Wi)$  \n`t[i].v`  `t[i].w`  `Vi`  `Wi`  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j  1  j  2  j \n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { //  2  k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### \n dp liujz    \n >_<\n","source":"_posts/codevs-3269.md","raw":"title: CodeVS 3269 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  -  DP\npermalink: codevs-3269\nid: 3\nupdated: '2016-01-19 21:08:13'\ndate: 2015-11-23 05:00:15\n---\n\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> 1\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n  \n  \n `f[v]`  `v` `v` <= `V`    \n 01 \n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `v` `v`  `V`  `0`  `f[v]`  `v`  `f[v]`  `Vi`  `i`  `f[v]` `f[v - Vi]` **** `i`   \n\n `V` / `Vi`  `01`  01   \n 01  01 ******** `f[v]` `f[v - Vi]` **** `i`  `v`  `0`  `V`   \n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `V = 10` `Vi = 3` `Wi = 5`  \n\n `01`   \n `v = 10` **`f[v - Vi] = f[7] = 0`**`f[v]`  `5`  \n `v = 9` `f[v - Vi] = f[6] = 0``f[v]`  `5`  \n `v = 8` `f[v - Vi] = f[5] = 0``f[v]`  `5`  \n** `v = 7` `f[v - Vi] = f[4] = 0``f[v]`  `5`**  \n  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n `v = 3` `f[v - Vi] = f[0] = 0``f[v]`  `5`  \n\n  \n `v = 3` **`f[v - Vi] = f[0] = 0`**`f[v]`  `5`  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n  \n** `v = 6` `f[v - Vi] = f[3] = 5``f[v]`  `10`**  \n  \n** `v = 9` `f[v - Vi] = f[6] = 10``f[v]`  `15`**  \n `v = 10` `f[v - Vi] = f[7] = 10``f[v]`  `15`  \n\n 01   \n\n01   \n `Mi`  `Mi`  01  01 $O(V*{\\Sigma}Mi)$  \n `t`  01  `k`****${\\Sigma}k = Mi$ `k`  $1$,$2$,$4$,,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$  \n `Mi = 17`  `5`  `k`  `1`,`2`,`4`,`8`,`2`  \n$O(V * {\\Sigma}{\\log}Wi)$  \n`t[i].v`  `t[i].w`  `Vi`  `Wi`  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j  1  j  2  j \n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { //  2  k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### \n dp liujz    \n >_<\n","slug":"codevs-3269","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8j01bhooxlw1ixjot5"},{"title":"CodeVS 3269 -  DP + ","id":"23","updated":"2016-01-19T13:03:26.000Z","date":"2016-01-14T21:47:45.000Z","_content":"\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> `1`\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n01 \n\n`n` `w` `c` \n\n\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n $r=i ~~ \\% ~~ c$$m=i ~~ / ~~ c$\n\n`m`   \n`r` \n\n `i`  `r` $[0,m]$  `d` $(m-d)*c+r$ `i`\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ k=m-d $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n$ f[k*c+r] $ `n + 1`  `n + 1`  $g(k,r)$ $O(1)$ \n\n `m`  `k` `k` ****\n\n### \n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3269-monotone-queue.md","raw":"title: CodeVS 3269 -  DP + \ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\npermalink: codevs-3269-monotone-queue\nid: 23\nupdated: '2016-01-19 21:03:26'\ndate: 2016-01-15 05:47:45\n---\n\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> `1`\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n01 \n\n`n` `w` `c` \n\n\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n $r=i ~~ \\% ~~ c$$m=i ~~ / ~~ c$\n\n`m`   \n`r` \n\n `i`  `r` $[0,m]$  `d` $(m-d)*c+r$ `i`\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ k=m-d $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n$ f[k*c+r] $ `n + 1`  `n + 1`  $g(k,r)$ $O(1)$ \n\n `m`  `k` `k` ****\n\n### \n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```\n","slug":"codevs-3269-monotone-queue","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8o01bmooxl9ynl5qen"},{"title":"CodeVS 3168 / 3162 -  DP / ","id":"14","updated":"2016-01-06T13:03:26.000Z","date":"2016-01-05T21:47:45.000Z","_content":"\n `M`  `K` \n\n<!-- more -->\n\n### \n[CodeVS 3162 - ](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 -  3](http://codevs.cn/problem/3168/)\n\n###  DP\n $a[m]$  `m` $f[m][k]$  `m`  `k` \n\n\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n `k`  `k - 1`  `k`  `k - 1`  `m - 1`  `k`  `k` \n\n $O(km^2)$\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### \n DP ************\n\n $O(m{\\log}m)$\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### \n~~ WA  8 ~~\n\n****\n\n\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n###  DPCodeVS 3162\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### CodeVS 3162CodeVS 3168\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3168-3162.md","raw":"title: CodeVS 3168 / 3162 -  DP / \ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\n  - \npermalink: codevs-3168-3162\nid: 14\nupdated: '2016-01-06 21:03:26'\ndate: 2016-01-06 05:47:45\n---\n\n `M`  `K` \n\n<!-- more -->\n\n### \n[CodeVS 3162 - ](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 -  3](http://codevs.cn/problem/3168/)\n\n###  DP\n $a[m]$  `m` $f[m][k]$  `m`  `k` \n\n\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n `k`  `k - 1`  `k`  `k - 1`  `m - 1`  `k`  `k` \n\n $O(km^2)$\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### \n DP ************\n\n $O(m{\\log}m)$\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### \n~~ WA  8 ~~\n\n****\n\n\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n###  DPCodeVS 3162\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### CodeVS 3162CodeVS 3168\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","slug":"codevs-3168-3162","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s8u01bsooxl09eayfj8"},{"title":"CodeVS 2822 - ","date":"2016-03-04T02:47:42.000Z","_content":"\n N  A  BB  C A  C\n\n -1\n\n<!-- more -->\n\n### \n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/codevs-2822.md","raw":"title: CodeVS 2822 - \ncategories: OI\ntags: \n  - CodeVS\n  - \n  - Tarjan\n  - \n  - \npermalink: codevs-2822\ndate: 2016-03-04 10:47:42\n---\n\n N  A  BB  C A  C\n\n -1\n\n<!-- more -->\n\n### \n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"codevs-2822","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9001bzooxlvzne69or"},{"title":"CodeVS 2598 -  DP","id":"17","updated":"2016-01-19T13:05:21.000Z","date":"2016-01-08T21:32:19.000Z","_content":"\n A  B  2  A  B\n\n1. \n2. \n3. \n\n A  B  A  B \n\n AB 4000\n\n<!-- more -->\n\n### \n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### \n\n `f[i][j]`  A  `i`  B  `j` \n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i]  B[j]} $$\n\n $ A[i]=B[j] $ \n\n $ A[i]B[j] $ \n\n1.  B  `j`  $A[i]$  $B[j-1]$  B  `j` \n2.  B  `j`  $A[i-1]$  $B[j]$  A  `i` \n3.  B  `j`  $A[i-1]$  $B[j-1]$  A  `i`  B  `j` \n\n### \n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```\n","source":"_posts/codevs-2598.md","raw":"title: CodeVS 2598 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\npermalink: codevs-2598\nid: 17\nupdated: '2016-01-19 21:05:21'\ndate: 2016-01-09 05:32:19\n---\n\n A  B  2  A  B\n\n1. \n2. \n3. \n\n A  B  A  B \n\n AB 4000\n\n<!-- more -->\n\n### \n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### \n\n `f[i][j]`  A  `i`  B  `j` \n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i]  B[j]} $$\n\n $ A[i]=B[j] $ \n\n $ A[i]B[j] $ \n\n1.  B  `j`  $A[i]$  $B[j-1]$  B  `j` \n2.  B  `j`  $A[i-1]$  $B[j]$  A  `i` \n3.  B  `j`  $A[i-1]$  $B[j-1]$  A  `i`  B  `j` \n\n### \n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```\n","slug":"codevs-2598","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9701c6ooxlp3f7afsi"},{"title":"CodeVS 1563 - ","id":"42","updated":"2016-02-06T14:23:12.000Z","date":"2016-02-05T13:06:41.000Z","_content":"\n `s`  `t` \n\n<!-- more -->\n\n### \n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[ 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### \n\n\n\n\n  \n\n `i`  `i'` `i` `i'`  `i`  `i'`  1 `(i, j)` `(i', j)`\n\n `s'`  `t`  `s`  `t'`\n\n###\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1563.md","raw":"title: CodeVS 1563 - \ncategories: OI\ntags: \n  - CodeVS\n  - USACO\n  - \n  - Dinic\n  - \npermalink: codevs-1563\nid: 42\nupdated: '2016-02-06 22:23:12'\ndate: 2016-02-05 21:06:41\n---\n\n `s`  `t` \n\n<!-- more -->\n\n### \n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[ 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### \n\n\n\n\n  \n\n `i`  `i'` `i` `i'`  `i`  `i'`  1 `(i, j)` `(i', j)`\n\n `s'`  `t`  `s`  `t'`\n\n###\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","slug":"codevs-1563","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9d01ccooxl31kv6hwb"},{"title":"CodeVS 1345 -  DP","id":"21","updated":"2016-01-19T13:04:02.000Z","date":"2016-01-13T21:17:18.000Z","_content":"\n `n` 1000\n\n<!-- more -->\n\n### \n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### \n \n\n  ****\n\n $ f[i] $  `i`  `i` \n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n****\n\n $ max\\{f[i],i{\\in}[1,n]\\} $ $f[n]$\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1345.md","raw":"title: CodeVS 1345 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - USACO\n  - DP\n  -  DP\npermalink: codevs-1345\nid: 21\nupdated: '2016-01-19 21:04:02'\ndate: 2016-01-14 05:17:18\n---\n\n `n` 1000\n\n<!-- more -->\n\n### \n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### \n \n\n  ****\n\n $ f[i] $  `i`  `i` \n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n****\n\n $ max\\{f[i],i{\\in}[1,n]\\} $ $f[n]$\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"codevs-1345","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9l01ckooxlliudo3kh"},{"title":"BZOJ 3881Divljak - AC  + ","date":"2016-09-17T23:27:00.000Z","_content":"\n $ n $  $ S_1, S_2, \\ldots, S_n $ $ T $  \n $ q $  $ T $  $ P $ $ T $  $ S_i $\n\n<!-- more -->\n\n### \n[BZOJ 3881](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)\n\n### \n $ S_i $  AC  $ P $  $ P $  $ +1 $\n\n $ O(n ^ 2) $  $ O(n) $ Fail \n\n $ P $  Fail **** $ +1 $\n\n DFS \n\n $ +1 $ $ -1 $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 2000000;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nint tot;\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tint id;\n\t\tbool isWord, visited;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, std::vector<int> &vec) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) vec.push_back(v->id);\n\t\t\telse if (v->next) vec.push_back(v->next->id);\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint l, r, depth, size;\n\tNode *p, *c, *top;\n\tbool visited;\n} N[MAXLEN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n#ifdef DBG\n\tprintf(\"addEdge: %d -> %d\\n\", s + 1, t + 1);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->fail != v) addEdge(v->id, v->fail->id);\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].depth = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) {\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->c || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->top = (!v->p || v != v->p->c) ? v : v->p->top;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) {\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) assert(N[i].l && N[i].r);\n\n#ifdef DBG\n\tfor (int i = 0; i < tot; i++) {\n\t\tprintf(\"N[%d] => [%d, %d]\\n\", i + 1, N[i].l, N[i].r);\n\t}\n#endif\n}\n\ninline Node *lca(Node *a, Node *b) {\n\twhile (a->top != b->top) {\n\t\tif (a->top->depth < b->top->depth) std::swap(a, b);\n\t\ta = a->top->p;\n\t}\n\tNode *res = a->depth < b->depth ? a : b;\n#ifdef DBG\n\tprintf(\"lca(%lu, %lu) = %lu\\n\", a - N + 1, b - N + 1, res - N + 1);\n#endif\n\treturn res;\n}\n\ninline bool compare(const int a, const int b) {\n\treturn N[a].l < N[b].l;\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN + 1 + 1 + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n#ifdef DBG\n\t\tprintf(\"BIT: %d add %d\\n\", pos, delta);\n#endif\n#ifdef FORCE\n\t\ta[pos] += delta;\n\t\treturn;\n#endif\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint sum(const int pos) {\n\t\tint res = 0;\n#ifdef FORCE\n\t\tfor (int i = 1; i <= pos; i++) res += a[i];\n\t\t// printf(\"sum(%d) = %d\\n\", pos, res);\n\t\treturn res;\n#endif\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef FORCE\n\t\tint res = 0;\n\t\tfor (int i = l; i <= r; i++) res += a[i];\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, res);\n\t\treturn res;\n#endif\n\t\treturn sum(r) - sum(l - 1);\n\t}\n} bit;\n\ninline void add(const char *begin, const char *end) {\n\tstd::vector<int> vec;\n\tt.exec(begin, end, vec);\n\tstd::sort(vec.begin(), vec.end(), compare);\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n#ifdef DBG\n\tprintf(\"%lu matched:\", vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++) printf(\" %d\", vec[i] + 1);\n\tputchar('\\n');\n#endif\n\n\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\tbit.update(N[vec[i]].l, 1);\n\t\tif (i != 0) {\n\t\t\tNode *p = lca(&N[vec[i]], &N[vec[i - 1]]);\n\t\t\tbit.update(p->l, -1);\n\t\t}\n\t}\n}\n\ninline int solve(const int x) {\n\treturn bit.query(N[x].l, N[x].r);\n}\n\nint main() {\n\tint n;\n\tstatic char s[MAXLEN + 1];\n\tscanf(\"%d\", &n);\n\tTrie::Node *a[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\ta[i] = t.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\tsplit();\n\tbit.init(tot);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tconst int len = strlen(s);\n#ifdef DBG\n\t\t\tprintf(\"add(\\\"%s\\\"): \", s);\n#endif\n\t\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\t\tadd(s, s + len);\n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%d\\n\", solve(a[x]->id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/coci2015-divljak.md","raw":"title: BZOJ 3881Divljak - AC  + \ncategories: OI\ntags: \n  - BZOJ\n  - COCI\n  - \n  - AC \n  - \n  - \npermalink: bzoj-3881\ndate: 2016-09-18 07:27:00\n---\n\n $ n $  $ S_1, S_2, \\ldots, S_n $ $ T $  \n $ q $  $ T $  $ P $ $ T $  $ S_i $\n\n<!-- more -->\n\n### \n[BZOJ 3881](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)\n\n### \n $ S_i $  AC  $ P $  $ P $  $ +1 $\n\n $ O(n ^ 2) $  $ O(n) $ Fail \n\n $ P $  Fail **** $ +1 $\n\n DFS \n\n $ +1 $ $ -1 $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 2000000;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nint tot;\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tint id;\n\t\tbool isWord, visited;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, std::vector<int> &vec) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) vec.push_back(v->id);\n\t\t\telse if (v->next) vec.push_back(v->next->id);\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint l, r, depth, size;\n\tNode *p, *c, *top;\n\tbool visited;\n} N[MAXLEN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n#ifdef DBG\n\tprintf(\"addEdge: %d -> %d\\n\", s + 1, t + 1);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->fail != v) addEdge(v->id, v->fail->id);\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].depth = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) {\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->c || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->top = (!v->p || v != v->p->c) ? v : v->p->top;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) {\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) assert(N[i].l && N[i].r);\n\n#ifdef DBG\n\tfor (int i = 0; i < tot; i++) {\n\t\tprintf(\"N[%d] => [%d, %d]\\n\", i + 1, N[i].l, N[i].r);\n\t}\n#endif\n}\n\ninline Node *lca(Node *a, Node *b) {\n\twhile (a->top != b->top) {\n\t\tif (a->top->depth < b->top->depth) std::swap(a, b);\n\t\ta = a->top->p;\n\t}\n\tNode *res = a->depth < b->depth ? a : b;\n#ifdef DBG\n\tprintf(\"lca(%lu, %lu) = %lu\\n\", a - N + 1, b - N + 1, res - N + 1);\n#endif\n\treturn res;\n}\n\ninline bool compare(const int a, const int b) {\n\treturn N[a].l < N[b].l;\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN + 1 + 1 + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n#ifdef DBG\n\t\tprintf(\"BIT: %d add %d\\n\", pos, delta);\n#endif\n#ifdef FORCE\n\t\ta[pos] += delta;\n\t\treturn;\n#endif\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint sum(const int pos) {\n\t\tint res = 0;\n#ifdef FORCE\n\t\tfor (int i = 1; i <= pos; i++) res += a[i];\n\t\t// printf(\"sum(%d) = %d\\n\", pos, res);\n\t\treturn res;\n#endif\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef FORCE\n\t\tint res = 0;\n\t\tfor (int i = l; i <= r; i++) res += a[i];\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, res);\n\t\treturn res;\n#endif\n\t\treturn sum(r) - sum(l - 1);\n\t}\n} bit;\n\ninline void add(const char *begin, const char *end) {\n\tstd::vector<int> vec;\n\tt.exec(begin, end, vec);\n\tstd::sort(vec.begin(), vec.end(), compare);\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n#ifdef DBG\n\tprintf(\"%lu matched:\", vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++) printf(\" %d\", vec[i] + 1);\n\tputchar('\\n');\n#endif\n\n\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\tbit.update(N[vec[i]].l, 1);\n\t\tif (i != 0) {\n\t\t\tNode *p = lca(&N[vec[i]], &N[vec[i - 1]]);\n\t\t\tbit.update(p->l, -1);\n\t\t}\n\t}\n}\n\ninline int solve(const int x) {\n\treturn bit.query(N[x].l, N[x].r);\n}\n\nint main() {\n\tint n;\n\tstatic char s[MAXLEN + 1];\n\tscanf(\"%d\", &n);\n\tTrie::Node *a[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\ta[i] = t.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\tsplit();\n\tbit.init(tot);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tconst int len = strlen(s);\n#ifdef DBG\n\t\t\tprintf(\"add(\\\"%s\\\"): \", s);\n#endif\n\t\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\t\tadd(s, s + len);\n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%d\\n\", solve(a[x]->id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3881","published":1,"updated":"2016-09-18T23:01:08.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9s9r01cqooxlimg9hty7"},{"title":"","date":"2016-05-11T13:06:00.000Z","_content":"\n $ k $ \n\n<!-- more -->\n\n### \n\n\n $ k $    $ k $  $ k $  $ k $  $ k $ \n\n $ O(\\log n) $\n\n### \n $ k $  $ n $  $ a $  $ n $  $ i $ $ a_1 $ ~ $ a_i $  $ [l, r] $  $ k $  $ r $  $ l - 1 $  $ k $ \n\n\n\n1.  $ O(n \\log n) $  $ O(n ^ 2 \\log n) $\n2.  $ O(n \\log n) $  $ O(n \\log n) $  $ O((n + m) n \\log n) $\n\n**** $ O(n ^ 2) $ \n\n### \n $ n $  $ O(\\log n) $  $ O(n \\log n) $ \n\n $ 0 $  $ O(\\log n) $  $ O(n \\log n) $\n\n $ O(n \\log n) $  $ O(\\log n) $ \n\n### \n[POJ 2104](http://poj.org/problem?id=2104)  \n\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/chairman-tree-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: chairman-tree-notes\ndate: 2016-05-11 21:06:00\n---\n\n $ k $ \n\n<!-- more -->\n\n### \n\n\n $ k $    $ k $  $ k $  $ k $  $ k $ \n\n $ O(\\log n) $\n\n### \n $ k $  $ n $  $ a $  $ n $  $ i $ $ a_1 $ ~ $ a_i $  $ [l, r] $  $ k $  $ r $  $ l - 1 $  $ k $ \n\n\n\n1.  $ O(n \\log n) $  $ O(n ^ 2 \\log n) $\n2.  $ O(n \\log n) $  $ O(n \\log n) $  $ O((n + m) n \\log n) $\n\n**** $ O(n ^ 2) $ \n\n### \n $ n $  $ O(\\log n) $  $ O(n \\log n) $ \n\n $ 0 $  $ O(\\log n) $  $ O(n \\log n) $\n\n $ O(n \\log n) $  $ O(\\log n) $ \n\n### \n[POJ 2104](http://poj.org/problem?id=2104)  \n\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"chairman-tree-notes","published":1,"updated":"2016-05-11T13:06:44.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sa201d0ooxlvy3jjpt2"},{"title":"Codeforces 716EDigit Tree - ","date":"2016-09-21T02:30:00.000Z","_content":"\n $ [1, 9] $  $ (u, v) $  $ u $  $ v $  $ m $  $ \\gcd(m, 10) = 1 $\n\n<!-- more -->\n\n### \n[Codeforces 716E](http://codeforces.com/contest/716/problem/E)\n\n### \n\n\n $ a_i $  $ i $ $ b_i $ $ d_i $  $ i $  $ a_i $  $ b_i $ \n\n![](cf-716e/example.svg)\n\n$$\n\\begin{cases}\na_u = 321 & a_v = 54 \\\\\nb_u = 123 & b_v = 45 \\\\\nd_u = 3 & d_v = 2\n\\end{cases}\n$$\n\n $ u $  $ v $ \n\n$$ a_u \\times 10 ^ {d_v} + b_v $$\n\n\n\n$$ a_u \\times 10 ^ {d_v} + b_v \\equiv 0 \\pmod m $$\n\n $ a_i $  $ b_i $ \n\n\n\n$$ a_u \\equiv -b_v \\times \\frac{1}{10 ^ {d_v}} \\pmod m $$\n\n $ u $ $ a_u $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tint size, depth, max;\n\tbool visited, solved;\n\tlong long backward, forward;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, mod;\nlong long pow10[MAXN + 1], pow10Inv[MAXN + 1];\n\nvoid exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long x) {\n\tlong long tmp1, res, tmp2;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline long long calc(Node *root, const int pre = 0) {\n\tif (pre != 0) {\n\t\troot->forward = root->backward = pre;\n\t\troot->depth = 1;\n\t} else {\n\t\troot->forward = root->backward = 0;\n\t\troot->depth = 0;\n\t}\n\troot->parent = NULL;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\n\tstd::map<long long, int> map;\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tmap[(mod - v->forward) * pow10Inv[v->depth] % mod]++;\n\t\tassert((mod - v->forward) * pow10Inv[v->depth] % mod >= 0);\n\t\ta[cnt++] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->forward = (v->forward * 10 + e->w) % mod;\n\t\t\te->t->backward = (e->w * pow10[v->depth] + v->backward) % mod;\n#ifdef DBG\n\t\t\tprintf(\"%lld <--> %lld\\n\", e->t->forward, e->t->backward);\n#endif\n\t\t\te->t->parent = v;\n\t\t\te->t->depth = v->depth + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tlong long ans = 0; // pre ? 0 : -1 * 0;\n#ifdef FORCE\n\tfor (int i = 0; i < cnt; i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif ((a[i]->backward * pow10[a[j]->depth] + a[j]->forward) % 3 == 0 /*&& !(a[i]->backward == 0 && a[j]->forward == 0)*/) {\n\t\t\t\tans++;\n#ifdef DBG\n\t\t\t\tprintf(\"%lld\\n\", a[i]->backward * pow10[a[j]->depth] + a[j]->forward);\n#endif\n\t\t\t}\n\t\t\tif (a[i]->backward == 0 && a[j]->forward == 0) printf(\"%lu %lu in %lu, %d\\n\", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--;\n\t\t}\n\t}\n#else\n\tmap[0]--;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans += map[a[i]->backward];\n#ifdef DBG\n\t\tprintf(\"back = %lld, ans + %d\\n\", a[i]->backward, map[a[i]->backward]);\n#endif\n\t}\n#endif\n#ifdef DBG\n\tfor (std::map<long long, int>::const_iterator it = map.begin(); it != map.end(); it++) printf(\"[%lld => %d]\\n\", it->first, it->second);\n\tprintf(\"** ans = %lld\\n\", ans);\n#endif\n\n\treturn ans;\n}\n\ninline long long solve() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n#ifdef DBG\n\t\tputs(\"+++++++++++++++++++\");\n#endif\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n#ifdef DBG\n\t\t\tputs(\"-------------------\");\n#endif\n\t\t\tans -= calc(e->t, e->w);\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &mod);\n#ifdef FORCE\n\tmod = 1e9 + 7;\n#endif\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w % mod);\n\t}\n\n\tpow10[0] = pow10Inv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10 % mod;\n\t\tpow10Inv[i] = inv(pow10[i]);\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}\n```\n","source":"_posts/cf-716e.md","raw":"title: Codeforces 716EDigit Tree - \ncategories: OI\ntags: \n  - Codeforces\n  - \n  - \n  - \n  - \n  - \npermalink: cf-716e\ndate: 2016-09-21 10:30:00\n---\n\n $ [1, 9] $  $ (u, v) $  $ u $  $ v $  $ m $  $ \\gcd(m, 10) = 1 $\n\n<!-- more -->\n\n### \n[Codeforces 716E](http://codeforces.com/contest/716/problem/E)\n\n### \n\n\n $ a_i $  $ i $ $ b_i $ $ d_i $  $ i $  $ a_i $  $ b_i $ \n\n![](cf-716e/example.svg)\n\n$$\n\\begin{cases}\na_u = 321 & a_v = 54 \\\\\nb_u = 123 & b_v = 45 \\\\\nd_u = 3 & d_v = 2\n\\end{cases}\n$$\n\n $ u $  $ v $ \n\n$$ a_u \\times 10 ^ {d_v} + b_v $$\n\n\n\n$$ a_u \\times 10 ^ {d_v} + b_v \\equiv 0 \\pmod m $$\n\n $ a_i $  $ b_i $ \n\n\n\n$$ a_u \\equiv -b_v \\times \\frac{1}{10 ^ {d_v}} \\pmod m $$\n\n $ u $ $ a_u $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tint size, depth, max;\n\tbool visited, solved;\n\tlong long backward, forward;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, mod;\nlong long pow10[MAXN + 1], pow10Inv[MAXN + 1];\n\nvoid exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long x) {\n\tlong long tmp1, res, tmp2;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline long long calc(Node *root, const int pre = 0) {\n\tif (pre != 0) {\n\t\troot->forward = root->backward = pre;\n\t\troot->depth = 1;\n\t} else {\n\t\troot->forward = root->backward = 0;\n\t\troot->depth = 0;\n\t}\n\troot->parent = NULL;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\n\tstd::map<long long, int> map;\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tmap[(mod - v->forward) * pow10Inv[v->depth] % mod]++;\n\t\tassert((mod - v->forward) * pow10Inv[v->depth] % mod >= 0);\n\t\ta[cnt++] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->forward = (v->forward * 10 + e->w) % mod;\n\t\t\te->t->backward = (e->w * pow10[v->depth] + v->backward) % mod;\n#ifdef DBG\n\t\t\tprintf(\"%lld <--> %lld\\n\", e->t->forward, e->t->backward);\n#endif\n\t\t\te->t->parent = v;\n\t\t\te->t->depth = v->depth + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tlong long ans = 0; // pre ? 0 : -1 * 0;\n#ifdef FORCE\n\tfor (int i = 0; i < cnt; i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif ((a[i]->backward * pow10[a[j]->depth] + a[j]->forward) % 3 == 0 /*&& !(a[i]->backward == 0 && a[j]->forward == 0)*/) {\n\t\t\t\tans++;\n#ifdef DBG\n\t\t\t\tprintf(\"%lld\\n\", a[i]->backward * pow10[a[j]->depth] + a[j]->forward);\n#endif\n\t\t\t}\n\t\t\tif (a[i]->backward == 0 && a[j]->forward == 0) printf(\"%lu %lu in %lu, %d\\n\", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--;\n\t\t}\n\t}\n#else\n\tmap[0]--;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans += map[a[i]->backward];\n#ifdef DBG\n\t\tprintf(\"back = %lld, ans + %d\\n\", a[i]->backward, map[a[i]->backward]);\n#endif\n\t}\n#endif\n#ifdef DBG\n\tfor (std::map<long long, int>::const_iterator it = map.begin(); it != map.end(); it++) printf(\"[%lld => %d]\\n\", it->first, it->second);\n\tprintf(\"** ans = %lld\\n\", ans);\n#endif\n\n\treturn ans;\n}\n\ninline long long solve() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n#ifdef DBG\n\t\tputs(\"+++++++++++++++++++\");\n#endif\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n#ifdef DBG\n\t\t\tputs(\"-------------------\");\n#endif\n\t\t\tans -= calc(e->t, e->w);\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &mod);\n#ifdef FORCE\n\tmod = 1e9 + 7;\n#endif\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w % mod);\n\t}\n\n\tpow10[0] = pow10Inv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10 % mod;\n\t\tpow10Inv[i] = inv(pow10[i]);\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}\n```\n","slug":"cf-716e","published":1,"updated":"2017-01-02T07:03:10.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sa801d6ooxltw9m0m0q"},{"title":"Codeforces 628DMagic Numbers -  DP","date":"2016-05-12T07:47:00.000Z","_content":"\n `d-magic`  $ d $ \n\n$ 1727374,\\ 17,\\ 1 $  `7-magic`  $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $  `7-magic` \n\n `m`  `d-magic`  $ [a, b] $ \n\n<!-- more -->\n\n### \n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### \n DP\n\n$$ f[n][limit][r] $$\n\n $ n $  $ limit $ $ m $  $ r $ \n\n $ [a, b] $  $ g(x) $  $ [0, x] $  $ g(b) - g(a - 1) $ $ a $  $ g(b) - g(a) $ $ a $ \n\n### \n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","source":"_posts/cf-628d.md","raw":"title: Codeforces 628DMagic Numbers -  DP\ncategories: OI\ntags: \n  - Codeforces\n  -  DP\n  - DP\npermalink: cf-628d\ndate: 2016-05-12 15:47:00\n---\n\n `d-magic`  $ d $ \n\n$ 1727374,\\ 17,\\ 1 $  `7-magic`  $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $  `7-magic` \n\n `m`  `d-magic`  $ [a, b] $ \n\n<!-- more -->\n\n### \n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### \n DP\n\n$$ f[n][limit][r] $$\n\n $ n $  $ limit $ $ m $  $ r $ \n\n $ [a, b] $  $ g(x) $  $ [0, x] $  $ g(b) - g(a - 1) $ $ a $  $ g(b) - g(a) $ $ a $ \n\n### \n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","slug":"cf-628d","published":1,"updated":"2016-10-24T23:38:39.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9saj01dfooxlkcflucvz"},{"title":"CEOI2008Order - ","date":"2016-06-22T08:07:00.000Z","_content":"\n $ N $ $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1391](http://www.lydsy.com/JudgeOnline/problem.php?id=1391)\n\n### \n\n\n\n\n\n\n\n\n### \n MLE \n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #include <queue>\n// #include <vector>\n\nconst int MAXN = 1200;\nconst int MAXM = 1200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t// std::queue<Node *> q;\n\t\t// q.push(s);\n\t\tstatic Node *q[MAXN + MAXM + 2];\n\t\tNode **l = q, **r = q - 1;\n\t\t*++r = s;\n\n\t\ts->l = 1;\n\n\t\twhile (l <= r /* !q.empty() */) {\n\t\t\tNode *v = *l++ /* q.front() */;\n\t\t\t// q.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse *++r = e->t; // q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w, k;\n\t\tscanf(\"%d %d\", &w, &k);\n\t\tsum += w;\n\n\t\taddEdge(s, i, w);\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\taddEdge(i, n + x, c);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(n + i, t, x);\n\t}\n\n\t/*\n\tstatic int w[MAXN];\n\tstatic std::vector< std::pair<int, int> > used[MAXN];\n\tstatic std::vector<int> borrow[MAXM];\n\tstatic std::pair<int, int> buy[MAXM];\n\tint id = n + 1, sum = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k;\n\t\tscanf(\"%d %d\", &w[i - 1], &k);\n\t\tsum += w[i - 1];\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\tint t = id++;\n\t\t\tused[i - 1].push_back(std::make_pair(t, c));\n\t\t\tborrow[x - 1].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &buy[i].second);\n\t\tbuy[i].first = id++;\n\t}\n\n\tconst int s = 0, t = id++;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, w[i - 1]);\n\n\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) {\n\t\t\taddEdge(i, it->first, it->second);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (std::vector<int>::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) {\n\t\t\taddEdge(*it, buy[i].first, INT_MAX);\n\t\t}\n\t\taddEdge(buy[i].first, t, buy[i].second);\n\t}\n\t*/\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/ceoi2008-order.md","raw":"title: CEOI2008Order - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: ceoi2008-order\ndate: 2016-06-22 16:07:00\n---\n\n $ N $ $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1391](http://www.lydsy.com/JudgeOnline/problem.php?id=1391)\n\n### \n\n\n\n\n\n\n\n\n### \n MLE \n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #include <queue>\n// #include <vector>\n\nconst int MAXN = 1200;\nconst int MAXM = 1200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t// std::queue<Node *> q;\n\t\t// q.push(s);\n\t\tstatic Node *q[MAXN + MAXM + 2];\n\t\tNode **l = q, **r = q - 1;\n\t\t*++r = s;\n\n\t\ts->l = 1;\n\n\t\twhile (l <= r /* !q.empty() */) {\n\t\t\tNode *v = *l++ /* q.front() */;\n\t\t\t// q.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse *++r = e->t; // q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w, k;\n\t\tscanf(\"%d %d\", &w, &k);\n\t\tsum += w;\n\n\t\taddEdge(s, i, w);\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\taddEdge(i, n + x, c);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(n + i, t, x);\n\t}\n\n\t/*\n\tstatic int w[MAXN];\n\tstatic std::vector< std::pair<int, int> > used[MAXN];\n\tstatic std::vector<int> borrow[MAXM];\n\tstatic std::pair<int, int> buy[MAXM];\n\tint id = n + 1, sum = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k;\n\t\tscanf(\"%d %d\", &w[i - 1], &k);\n\t\tsum += w[i - 1];\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\tint t = id++;\n\t\t\tused[i - 1].push_back(std::make_pair(t, c));\n\t\t\tborrow[x - 1].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &buy[i].second);\n\t\tbuy[i].first = id++;\n\t}\n\n\tconst int s = 0, t = id++;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, w[i - 1]);\n\n\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) {\n\t\t\taddEdge(i, it->first, it->second);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (std::vector<int>::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) {\n\t\t\taddEdge(*it, buy[i].first, INT_MAX);\n\t\t}\n\t\taddEdge(buy[i].first, t, buy[i].second);\n\t}\n\t*/\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"ceoi2008-order","published":1,"updated":"2016-06-22T08:07:58.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sao01dkooxl00fmrn5m"},{"title":"CEOI2004 -  DP","date":"2016-05-18T10:03:00.000Z","_content":"\n $ n $ \n\n\n<!-- more -->\n\n### \n[COGS 362](http://cogs.top/cogs/problem/problem.php?pid=362)\n\n### \n $ 0 $ \n\n $ f[i][j] $  $ i $  $ j $  $ f(i) $  $ f[i][j] $$ g(i) $  $ f[i][j - 1] $$ S(i) $  $ i $  $ 0 $ $ s(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i} \\{ g(j) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n{(g(a) - S(a) + s(a) \\times d(a + 1)) - (g(b) - S(b) + s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1)} < s(i)\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 3;\n\nint n;\nlong long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1];\nlong long g[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n    std::reverse(w + 1, w + n + 1);\n    std::reverse(d + 1, d + n + 1);\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n        s[i] = s[i - 1] + w[i];\n        S[i] = S[i - 1] + w[i] * d[i];\n    }\n}\n\n/*\ninline void force() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int _j = -1;\n            for (int j = 0; j < i; j++) {\n                if (f[i] > g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                    f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                    _j = j;\n                }\n            }\n            printf(\"%d --> %d\\n\", i, _j);\n        }\n    }\n}\n*/\n\ninline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; }\n\ninline double slope(const int a, const int b) {\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n\ninline void dp() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n\n        static int q[MAXN];\n        int *l = q, *r = q;\n        *r = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n\n            int &j = *l;\n            f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n            // printf(\"%d --> %d\\n\", i, j);\n\n            if (i < n) {\n                while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n                *++r = i;\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"two.in\", \"r\", stdin);\n    freopen(\"two.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld\", &w[i], &d[i]);\n    }\n\n    prepare();\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/ceoi2004-two.md","raw":"title: CEOI2004 -  DP\ncategories: OI\ntags: \n  - COGS\n  - CEOI\n  - \n  - \n  - DP\npermalink: ceoi2004-two\ndate: 2016-05-18 18:03:00\n---\n\n $ n $ \n\n\n<!-- more -->\n\n### \n[COGS 362](http://cogs.top/cogs/problem/problem.php?pid=362)\n\n### \n $ 0 $ \n\n $ f[i][j] $  $ i $  $ j $  $ f(i) $  $ f[i][j] $$ g(i) $  $ f[i][j - 1] $$ S(i) $  $ i $  $ 0 $ $ s(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i} \\{ g(j) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n{(g(a) - S(a) + s(a) \\times d(a + 1)) - (g(b) - S(b) + s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1)} < s(i)\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 3;\n\nint n;\nlong long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1];\nlong long g[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n    std::reverse(w + 1, w + n + 1);\n    std::reverse(d + 1, d + n + 1);\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n        s[i] = s[i - 1] + w[i];\n        S[i] = S[i - 1] + w[i] * d[i];\n    }\n}\n\n/*\ninline void force() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int _j = -1;\n            for (int j = 0; j < i; j++) {\n                if (f[i] > g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                    f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                    _j = j;\n                }\n            }\n            printf(\"%d --> %d\\n\", i, _j);\n        }\n    }\n}\n*/\n\ninline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; }\n\ninline double slope(const int a, const int b) {\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n\ninline void dp() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n\n        static int q[MAXN];\n        int *l = q, *r = q;\n        *r = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n\n            int &j = *l;\n            f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n            // printf(\"%d --> %d\\n\", i, j);\n\n            if (i < n) {\n                while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n                *++r = i;\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"two.in\", \"r\", stdin);\n    freopen(\"two.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld\", &w[i], &d[i]);\n    }\n\n    prepare();\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"ceoi2004-two","published":1,"updated":"2016-10-24T23:34:14.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sau01dqooxlnxqow11w"},{"title":"BZOJ 4403 - ","date":"2016-04-08T14:11:34.000Z","_content":"\n $ N $$ L $  $ R $ $ 1 $  $ N $  $ L $  $ R $  $ 10 ^ 6 + 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### \n $ [1, R - L + 1] $  $ N $ \n\n\n\n$$ M = R - L + 1 $$\n\n\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n Lucas \n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n $ n \\lt p, m \\lt p $ ****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4403.md","raw":"title: BZOJ 4403 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - \n  - Lucas \n  - \npermalink: bzoj-4403\ndate: 2016-04-08 22:11:34\n---\n\n $ N $$ L $  $ R $ $ 1 $  $ N $  $ L $  $ R $  $ 10 ^ 6 + 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### \n $ [1, R - L + 1] $  $ N $ \n\n\n\n$$ M = R - L + 1 $$\n\n\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n Lucas \n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n $ n \\lt p, m \\lt p $ ****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4403","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sb201dyooxl6v5leuke"},{"title":"BZOJ 4318OSU! - ","date":"2016-05-31T09:32:00.000Z","_content":"\n osu! : \n\n $ n $  $ 1 $ $ 0 $$ n $  $ 1 $  $ n $  01  $ x $  $ 1 $  $ x ^ 3 $  $ x $  $ 1 $  $ 1 $  $ 1 $\n\n $ n $\n\n<!-- more -->\n\n### \n[BZOJ 4318](http://www.lydsy.com/JudgeOnline/problem.php?id=4318)\n\n### \n $ f(i) $  $ i $ $ p(i) $  $ i $ \n\n $ 1 $  $ x $  $ i $  $ x_i = x_{i - 1} + 1 $ $ x ^ 3 $ \n\n$$ (x + 1) ^ 3 - x ^ 3 = 3x ^ 2 + 3x + 1 $$\n\n $ E_{x ^ 2} $  $ E_x $\n\n$$ E_{(x + 1) ^ 3 - x ^ 3} = 3E_{x ^ 2} + 3E_x + 1 $$\n\n $ i - 1 $ \n\n$$ f(i) = f(i - 1) + (3E_{x ^ 2}(i) + 3E_x(i) + 1) \\times p(i) $$\n\n $ E_{x ^ 2}(i) $  $ E_x(i) $\n\n\n\n$$ E_{x + 1} = E_x + 1 $$\n\n $ p(i) $  $ 1 $  $ 1 - p(i) $  $ 0 $\n\n$$ E_x(i) = (E_x(i - 1) + 1) \\times p(i) $$\n\n\n\n$$ E_{(x + 1) ^ 2} = E_{x ^ 2} + 2E_{x} + 1 $$\n\n\n\n$$ E_{x ^ 2}(i) = E_{x ^ 2}(i - 1) + 2E_{x}(i - 1) + 1 $$\n\n$ E_{x ^ 2}(i) $$ E_{x}(i) $$ f(i) $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n\nconst int MAXN = 100000;\n\nint n;\ndouble p[MAXN + 1], f[MAXN + 1];\ndouble ex1[MAXN + 1], ex2[MAXN + 1];\n\ninline void dp() {\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tex1[i] = (ex1[i - 1] + 1) * p[i];\n\t\tex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i];\n\t\tdouble t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i];\n\t\tf[i] = f[i - 1] + t;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n\n\tdp();\n\n\tprintf(\"%.1lf\\n\", floor(f[n] * 10 + 0.5) / 10);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4318.md","raw":"title: BZOJ 4318OSU! - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - DP\npermalink: bzoj-4318\ndate: 2016-05-31 17:32:00\n---\n\n osu! : \n\n $ n $  $ 1 $ $ 0 $$ n $  $ 1 $  $ n $  01  $ x $  $ 1 $  $ x ^ 3 $  $ x $  $ 1 $  $ 1 $  $ 1 $\n\n $ n $\n\n<!-- more -->\n\n### \n[BZOJ 4318](http://www.lydsy.com/JudgeOnline/problem.php?id=4318)\n\n### \n $ f(i) $  $ i $ $ p(i) $  $ i $ \n\n $ 1 $  $ x $  $ i $  $ x_i = x_{i - 1} + 1 $ $ x ^ 3 $ \n\n$$ (x + 1) ^ 3 - x ^ 3 = 3x ^ 2 + 3x + 1 $$\n\n $ E_{x ^ 2} $  $ E_x $\n\n$$ E_{(x + 1) ^ 3 - x ^ 3} = 3E_{x ^ 2} + 3E_x + 1 $$\n\n $ i - 1 $ \n\n$$ f(i) = f(i - 1) + (3E_{x ^ 2}(i) + 3E_x(i) + 1) \\times p(i) $$\n\n $ E_{x ^ 2}(i) $  $ E_x(i) $\n\n\n\n$$ E_{x + 1} = E_x + 1 $$\n\n $ p(i) $  $ 1 $  $ 1 - p(i) $  $ 0 $\n\n$$ E_x(i) = (E_x(i - 1) + 1) \\times p(i) $$\n\n\n\n$$ E_{(x + 1) ^ 2} = E_{x ^ 2} + 2E_{x} + 1 $$\n\n\n\n$$ E_{x ^ 2}(i) = E_{x ^ 2}(i - 1) + 2E_{x}(i - 1) + 1 $$\n\n$ E_{x ^ 2}(i) $$ E_{x}(i) $$ f(i) $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n\nconst int MAXN = 100000;\n\nint n;\ndouble p[MAXN + 1], f[MAXN + 1];\ndouble ex1[MAXN + 1], ex2[MAXN + 1];\n\ninline void dp() {\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tex1[i] = (ex1[i - 1] + 1) * p[i];\n\t\tex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i];\n\t\tdouble t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i];\n\t\tf[i] = f[i - 1] + t;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n\n\tdp();\n\n\tprintf(\"%.1lf\\n\", floor(f[n] * 10 + 0.5) / 10);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4318","published":1,"updated":"2016-05-31T12:06:27.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sbb01e8ooxlhjtta6av"},{"title":"BZOJ 4247 -  DP","date":"2016-07-11T15:22:00.000Z","_content":"\nJOI  $ N $  $ 1 \\to N $ JOI\n\n $ 1 $ \n\nJOI \n\n<!-- more -->\n\n### \n[BZOJ 4247](http://www.lydsy.com/JudgeOnline/problem.php?id=4247)\n\n### \n $ -n $  $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic struct Array {\n\t\tint a[MAXN * 2 + 1];\n\t\tint &operator[](const int i) { return a[i + MAXN]; }\n\t} f[MAXN + 1];\n\n\tfor (int i = -n; i < 0; i++) f[0][i] = INT_MIN;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, v;\n\t\tscanf(\"%d %d\", &x, &v);\n\n\t\tconst int w = 1 - x;\n\n\t\tfor (int j = -n; j <= n; j++) {\n\t\t\tif (j - w >= -n && j - w <= n && f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v);\n\t\t\telse if (j - w > n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v);\n\t\t\telse f[i][j] = f[i - 1][j];\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = -n; i <= 1; i++) ans = std::max(ans, f[n][i]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4247.md","raw":"title: BZOJ 4247 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-4247\ndate: 2016-07-11 23:22:00\n---\n\nJOI  $ N $  $ 1 \\to N $ JOI\n\n $ 1 $ \n\nJOI \n\n<!-- more -->\n\n### \n[BZOJ 4247](http://www.lydsy.com/JudgeOnline/problem.php?id=4247)\n\n### \n $ -n $  $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic struct Array {\n\t\tint a[MAXN * 2 + 1];\n\t\tint &operator[](const int i) { return a[i + MAXN]; }\n\t} f[MAXN + 1];\n\n\tfor (int i = -n; i < 0; i++) f[0][i] = INT_MIN;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, v;\n\t\tscanf(\"%d %d\", &x, &v);\n\n\t\tconst int w = 1 - x;\n\n\t\tfor (int j = -n; j <= n; j++) {\n\t\t\tif (j - w >= -n && j - w <= n && f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v);\n\t\t\telse if (j - w > n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v);\n\t\t\telse f[i][j] = f[i - 1][j];\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = -n; i <= 1; i++) ans = std::max(ans, f[n][i]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4247","published":1,"updated":"2016-10-24T23:34:05.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sbh01eeooxla294l35s"},{"title":"BZOJ 4145The Prices -  DP","date":"2016-07-11T15:29:00.000Z","_content":"\n $ m $  $ n $  $ i $  $ d(i) $ $ i $  $ j $  $ c(i)(j) $\n\n<!-- more -->\n\n### \n[BZOJ 4145](http://www.lydsy.com/JudgeOnline/problem.php?id=4145)\n\n### \n $ f(i, j) $  $ i $  $ j $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int maxn = 100;\nconst int maxm = 16;\nconst int maxstatus = 1 << 16;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int c[maxn][maxm], d[maxn];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d[i]);\n\t\tfor (int j = 0; j < m; j++) scanf(\"%d\", &c[i][j]);\n\t}\n\n\tstatic int f[maxn][maxstatus];\n\tfor (int j = 0; j < (1 << m); j++) {\n\t\tf[0][j] = d[0];\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (j & (1 << k)) f[0][j] += c[0][k];\n\t\t}\n\t}\n\tf[0][0] = 0;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = f[i - 1][j] + d[i];\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (j & (1 << k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 << k)] + c[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", f[n - 1][(1 << m) - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4145.md","raw":"title: BZOJ 4145The Prices -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-4145\ndate: 2016-07-11 23:29:00\n---\n\n $ m $  $ n $  $ i $  $ d(i) $ $ i $  $ j $  $ c(i)(j) $\n\n<!-- more -->\n\n### \n[BZOJ 4145](http://www.lydsy.com/JudgeOnline/problem.php?id=4145)\n\n### \n $ f(i, j) $  $ i $  $ j $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int maxn = 100;\nconst int maxm = 16;\nconst int maxstatus = 1 << 16;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int c[maxn][maxm], d[maxn];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d[i]);\n\t\tfor (int j = 0; j < m; j++) scanf(\"%d\", &c[i][j]);\n\t}\n\n\tstatic int f[maxn][maxstatus];\n\tfor (int j = 0; j < (1 << m); j++) {\n\t\tf[0][j] = d[0];\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (j & (1 << k)) f[0][j] += c[0][k];\n\t\t}\n\t}\n\tf[0][0] = 0;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = f[i - 1][j] + d[i];\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (j & (1 << k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 << k)] + c[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", f[n - 1][(1 << m) - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4145","published":1,"updated":"2016-10-24T23:33:52.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sbn01ejooxlsdjn57bi"},{"title":"BZOJ 3940Censoring - AC ","date":"2016-09-13T23:52:00.000Z","_content":"\n $ S $  $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 3940](http://www.lydsy.com/JudgeOnline/problem.php?id=3940)\n\n### \n AC \n\n  \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <list>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint length;\n\n\t\tNode(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, end - begin);\n\t\telse (*v)->isWord = true, (*v)->length = end - begin;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(std::list<char> &list) {\n\t\tNode *v = root;\n\t\tstd::stack<Node *> history;\n\t\tfor (std::list<char>::iterator it = list.begin(); it != list.end(); ) {\n\t\t\thistory.push(v);\n\t\t\t// while (v != root && !v->c[*it]) v = v->fail, assert(false);\n\t\t\tif (v->c[*it]) v = v->c[*it];\n\t\t\tif (!v->isWord && v->next) v = v->next;\n\t\t\tif (v->isWord) {\n\t\t\t\tfor (int i = 1; i < v->length; i++) it--;\n\t\t\t\tfor (int i = 0; i < v->length; i++) it = list.erase(it);\n\t\t\t\tfor (int i = 1; i < v->length; i++) history.pop();\n\t\t\t\tv = history.top();\n\t\t\t\thistory.pop();\n\t\t\t} else it++;\n\t\t}\n\t}\n} t;\n\nint main() {\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tstd::list<char> list;\n\tfor (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tt.exec(list);\n\n\tfor (std::list<char>::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR);\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3940.md","raw":"title: BZOJ 3940Censoring - AC \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - AC \n  - \n  - \npermalink: bzoj-3940\ndate: 2016-09-14 07:52:00\n---\n\n $ S $  $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 3940](http://www.lydsy.com/JudgeOnline/problem.php?id=3940)\n\n### \n AC \n\n  \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <list>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint length;\n\n\t\tNode(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, end - begin);\n\t\telse (*v)->isWord = true, (*v)->length = end - begin;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(std::list<char> &list) {\n\t\tNode *v = root;\n\t\tstd::stack<Node *> history;\n\t\tfor (std::list<char>::iterator it = list.begin(); it != list.end(); ) {\n\t\t\thistory.push(v);\n\t\t\t// while (v != root && !v->c[*it]) v = v->fail, assert(false);\n\t\t\tif (v->c[*it]) v = v->c[*it];\n\t\t\tif (!v->isWord && v->next) v = v->next;\n\t\t\tif (v->isWord) {\n\t\t\t\tfor (int i = 1; i < v->length; i++) it--;\n\t\t\t\tfor (int i = 0; i < v->length; i++) it = list.erase(it);\n\t\t\t\tfor (int i = 1; i < v->length; i++) history.pop();\n\t\t\t\tv = history.top();\n\t\t\t\thistory.pop();\n\t\t\t} else it++;\n\t\t}\n\t}\n} t;\n\nint main() {\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tstd::list<char> list;\n\tfor (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tt.exec(list);\n\n\tfor (std::list<char>::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR);\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","slug":"bzoj-3940","published":1,"updated":"2016-09-13T23:47:40.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sbs01eoooxlp93dnb2z"},{"title":"BZOJ 3894 - ","date":"2016-06-21T09:51:00.000Z","_content":"\n P  $ n \\times m $ \n\n1.  $ i $  $ j $  $ a[i][j] $  $ b[i][j] $ \n2.  $ i $  $ j $  $ A[i][j] $ \n3.  $ i $  $ j $  $ B[i][j] $ \n\n P \n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n $ 3 $  TA  $ b[i][j] - a[i][j] $TA  TA TA  TA   \n**TA  TA ** TA  TA  TA  TA \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 3 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3];\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &A[i][j]), sum += A[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &B[i][j]);\n\t\n\tint x = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < 3; k++) id[i][j][k] = x++;\n\n\tconst int s = 0, t = n * m * 3 + 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n\t\t\telse addEdge(id[i][j][0], t, -x);\n\t\t\taddEdge(id[i][j][1], t, A[i][j]);\n\t\t\taddEdge(s, id[i][j][2], B[i][j]), sum += B[i][j];\n\n\t\t\taddEdge(id[i][j][0], id[i][j][1], INT_MAX);\n\t\t\taddEdge(id[i][j][2], id[i][j][0], INT_MAX);\n\n\t\t\tif (i != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m * 3 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3894.md","raw":"title: BZOJ 3894 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3894\ndate: 2016-06-21 17:51:00\n---\n\n P  $ n \\times m $ \n\n1.  $ i $  $ j $  $ a[i][j] $  $ b[i][j] $ \n2.  $ i $  $ j $  $ A[i][j] $ \n3.  $ i $  $ j $  $ B[i][j] $ \n\n P \n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n $ 3 $  TA  $ b[i][j] - a[i][j] $TA  TA TA  TA   \n**TA  TA ** TA  TA  TA  TA \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 3 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3];\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &A[i][j]), sum += A[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &B[i][j]);\n\t\n\tint x = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < 3; k++) id[i][j][k] = x++;\n\n\tconst int s = 0, t = n * m * 3 + 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n\t\t\telse addEdge(id[i][j][0], t, -x);\n\t\t\taddEdge(id[i][j][1], t, A[i][j]);\n\t\t\taddEdge(s, id[i][j][2], B[i][j]), sum += B[i][j];\n\n\t\t\taddEdge(id[i][j][0], id[i][j][1], INT_MAX);\n\t\t\taddEdge(id[i][j][2], id[i][j][0], INT_MAX);\n\n\t\t\tif (i != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m * 3 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3894","published":1,"updated":"2016-06-22T08:25:43.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sc201eyooxlr7xobk40"},{"title":"BZOJ 3796Mushroom -  + AC ","date":"2016-09-29T23:41:00.000Z","_content":"\n $ s_1, s_2, s_3 $ $ w $\n\n1. $ w $  $ s_1 $ \n2. $ w $  $ s_2 $ \n3. $ s_3 $  $ w $ \n\n<!-- more -->\n\n### \n[BZOJ 3796](http://www.lydsy.com/JudgeOnline/problem.php?id=3796)\n\n### \n $ s_1 $  $ s_2 $  $ s_1 $  $ s_2 $ \n\n 3 $ s_3 $  AC  $ s_3 $  $ s_1 $  $ i $  $ s_3 $  $ r(i) $ $ i $  $ r(i) - i + \\mathrm{len}(s_3) - 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\nconst int CHARSET_SIZE = 12;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail;\n\t\tbool isWord;\n\t\tint depth;\n\n\t\tNode(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p - BASE_CHAR];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root;\n\t\troot->depth = 0;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc->depth = v->depth + 1;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, bool *match) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\tif (v->isWord) match[p - begin - v->depth + 1] = true;\n\t\t}\n\t}\n} t;\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\ttemplate <typename T>\n\tvoid build(const T *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"build: %s\\n\", s);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) < n) st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\telse st[i][j] = st[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tint rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\telse {\n\t\t\tconst int t = log[r - l];\n\t\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t\t}\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint main() {\n\tstatic char buf[MAXN];\n\tscanf(\"%s\", buf);\n\tconst int n1 = strlen(buf);\n\tbuf[n1] = '$';\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n2 = strlen(buf + n1 + 1);\n\tsa1.build(buf, n1 + 1 + n2);\n\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n3 = strlen(buf + n1 + 1);\n\t// sa2.build(buf, n1 + 1 + n3);\n\n\tt.insert(buf + n1 + 1, buf + n1 + 1 + n3);\n\tt.build();\n\n\tstatic bool match[MAXN];\n\tt.exec(buf, buf + n1, match);\n\n\tstatic int nextMatch[MAXN];\n\tfor (int i = n1 - 1, x = INT_MAX; i >= 0; i--) {\n\t\tif (match[i]) x = i;\n\t\tnextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1;\n\t}\n\n#ifdef DBG\n\tputs(\"KMP:\");\n\tbuf[n1] = '\\0';\n\tfor (int i = 0; i < n1; i++) printf(\"%d %s\\n\", nextMatch[i], &buf[i]);\n#endif\n\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 1, x = -1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) l[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\tfor (int i = n1 + n2 + 1 - 1, x = -1; i >= 1; i--) {\n\t\tif (sa1.sa[i] < n1) r[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\n#ifdef DBG\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) printf(\"l[%d] = %d\\n\", i, l[i]);\n\t\tif (sa1.sa[i] < n1) printf(\"r[%d] = %d\\n\", i, r[i]);\n\t}\n#endif\n\n\tint ans = 0;\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] > n1) continue;\n\t\tint x;\n\t\tif (l[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (r[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3796.md","raw":"title: BZOJ 3796Mushroom -  + AC \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - AC \npermalink: bzoj-3796\ndate: 2016-09-30 07:41:00\n---\n\n $ s_1, s_2, s_3 $ $ w $\n\n1. $ w $  $ s_1 $ \n2. $ w $  $ s_2 $ \n3. $ s_3 $  $ w $ \n\n<!-- more -->\n\n### \n[BZOJ 3796](http://www.lydsy.com/JudgeOnline/problem.php?id=3796)\n\n### \n $ s_1 $  $ s_2 $  $ s_1 $  $ s_2 $ \n\n 3 $ s_3 $  AC  $ s_3 $  $ s_1 $  $ i $  $ s_3 $  $ r(i) $ $ i $  $ r(i) - i + \\mathrm{len}(s_3) - 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\nconst int CHARSET_SIZE = 12;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail;\n\t\tbool isWord;\n\t\tint depth;\n\n\t\tNode(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p - BASE_CHAR];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root;\n\t\troot->depth = 0;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc->depth = v->depth + 1;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, bool *match) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\tif (v->isWord) match[p - begin - v->depth + 1] = true;\n\t\t}\n\t}\n} t;\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\ttemplate <typename T>\n\tvoid build(const T *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"build: %s\\n\", s);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) < n) st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\telse st[i][j] = st[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tint rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\telse {\n\t\t\tconst int t = log[r - l];\n\t\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t\t}\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint main() {\n\tstatic char buf[MAXN];\n\tscanf(\"%s\", buf);\n\tconst int n1 = strlen(buf);\n\tbuf[n1] = '$';\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n2 = strlen(buf + n1 + 1);\n\tsa1.build(buf, n1 + 1 + n2);\n\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n3 = strlen(buf + n1 + 1);\n\t// sa2.build(buf, n1 + 1 + n3);\n\n\tt.insert(buf + n1 + 1, buf + n1 + 1 + n3);\n\tt.build();\n\n\tstatic bool match[MAXN];\n\tt.exec(buf, buf + n1, match);\n\n\tstatic int nextMatch[MAXN];\n\tfor (int i = n1 - 1, x = INT_MAX; i >= 0; i--) {\n\t\tif (match[i]) x = i;\n\t\tnextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1;\n\t}\n\n#ifdef DBG\n\tputs(\"KMP:\");\n\tbuf[n1] = '\\0';\n\tfor (int i = 0; i < n1; i++) printf(\"%d %s\\n\", nextMatch[i], &buf[i]);\n#endif\n\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 1, x = -1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) l[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\tfor (int i = n1 + n2 + 1 - 1, x = -1; i >= 1; i--) {\n\t\tif (sa1.sa[i] < n1) r[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\n#ifdef DBG\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) printf(\"l[%d] = %d\\n\", i, l[i]);\n\t\tif (sa1.sa[i] < n1) printf(\"r[%d] = %d\\n\", i, r[i]);\n\t}\n#endif\n\n\tint ans = 0;\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] > n1) continue;\n\t\tint x;\n\t\tif (l[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (r[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"bzoj-3796","published":1,"updated":"2016-09-29T23:48:43.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sc901f5ooxlt4ls5piq"},{"title":"BZOJ 3697 - ","date":"2016-06-15T02:26:00.000Z","_content":"\n\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3697](http://www.lydsy.com/JudgeOnline/problem.php?id=3697)\n\n### \n\n\n $ 0 $  $ -1 $\n\n DFS  $ f(i,\\ 0) $  $ i $ ** $ i $ **$ f(i,\\ 1) $  $ i $ ** $ i $ **\n\n $ i $  $ -i $    $ i $ \n\n DFS  $ c(i) $  $ i $  $ f(i,\\ 0) $  $ f(i,\\ 1 ) $ \n\n $ g(i,\\ 0) $$ g(i,\\ 1) $ \n\n$$ \\sum\\limits_i f(i,\\ 0) g(-i,\\ 1) + f(i,\\ 1) g(-i,\\ 0) + f(i,\\ 1) g(-i,\\ 1) $$\n\n $ g(0,\\ 0) $  $ 1 $\n\n$$ (g(0,\\ 0) - 1) \\times f(0,\\ 0) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100003;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, max, dist;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ntemplate <typename T, int L, int R>\nstruct Array {\n\tT a[R - L + 1];\n\n\tT &operator[](const int pos) { return a[pos - L]; }\n\n\tconst T &operator[](const int pos) const { return a[pos - L]; }\n};\n\nArray<long long [2], -(MAXN - 1), MAXN - 1> f, g;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline void dfs(Node *start, const int dist, int &max) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->dist = dist;\n\tstart->visited = false;\n\n\tstatic int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tf[v->dist][!cnt[v->dist] ? 0 : 1]++;\n\t\t\tcnt[v->dist]++;\n\n\t\t\tmax = std::max(max, v->dist);\n\t\t\tmax = std::max(max, abs(v->dist));\n\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tcnt[v->dist]--;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\n/*\ninline void print(const int max) {\n\tfor (int i = -max; i <= max; i++) {\n\t\tprintf(\"f[%d][0] = %lld, f[%d][1] = %lld\\n\", i, f[i][0], i, f[i][1]);\n\t\tprintf(\"g[%d][0] = %lld, g[%d][1] = %lld\\n\", i, g[i][0], i, g[i][1]);\n\t}\n\tputchar('\\n');\n}\n*/\n\ninline long long calc(Node *root) {\n\tlong long res = 0;\n\tint max = 0;\n\tg[0][0] = 1;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tint curr = 0;\n\t\tdfs(e->t, e->w, curr);\n\t\t// print(max);\n\n\t\tres += (g[0][0] - 1) * f[0][0];\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\t// printf(\"res += %lld\\n\", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]));\n\t\t\tres += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]);\n\t\t}\n\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\tg[i][0] += f[i][0];\n\t\t\tg[i][1] += f[i][1];\n\t\t\tf[i][0] = f[i][1] = 0;\n\t\t}\n\n\t\tmax = std::max(max, curr);\n\t}\n\n\tfor (int i = -max; i <= max; i++) {\n\t\tg[i][0] = g[i][1] = 0;\n\t}\n\n\t// printf(\"calc(%ld) = %lld\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline long long solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\t\tans += calc(root);\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\tif (w == 0) w = -1;\n\t\taddEdge(u, v, w);\n\t}\n\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\t// printf(\"counter: %lld\\n\", counter);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3697.md","raw":"title: BZOJ 3697 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3697\ndate: 2016-06-15 10:26:00\n---\n\n\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3697](http://www.lydsy.com/JudgeOnline/problem.php?id=3697)\n\n### \n\n\n $ 0 $  $ -1 $\n\n DFS  $ f(i,\\ 0) $  $ i $ ** $ i $ **$ f(i,\\ 1) $  $ i $ ** $ i $ **\n\n $ i $  $ -i $    $ i $ \n\n DFS  $ c(i) $  $ i $  $ f(i,\\ 0) $  $ f(i,\\ 1 ) $ \n\n $ g(i,\\ 0) $$ g(i,\\ 1) $ \n\n$$ \\sum\\limits_i f(i,\\ 0) g(-i,\\ 1) + f(i,\\ 1) g(-i,\\ 0) + f(i,\\ 1) g(-i,\\ 1) $$\n\n $ g(0,\\ 0) $  $ 1 $\n\n$$ (g(0,\\ 0) - 1) \\times f(0,\\ 0) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100003;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, max, dist;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ntemplate <typename T, int L, int R>\nstruct Array {\n\tT a[R - L + 1];\n\n\tT &operator[](const int pos) { return a[pos - L]; }\n\n\tconst T &operator[](const int pos) const { return a[pos - L]; }\n};\n\nArray<long long [2], -(MAXN - 1), MAXN - 1> f, g;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline void dfs(Node *start, const int dist, int &max) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->dist = dist;\n\tstart->visited = false;\n\n\tstatic int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tf[v->dist][!cnt[v->dist] ? 0 : 1]++;\n\t\t\tcnt[v->dist]++;\n\n\t\t\tmax = std::max(max, v->dist);\n\t\t\tmax = std::max(max, abs(v->dist));\n\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tcnt[v->dist]--;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\n/*\ninline void print(const int max) {\n\tfor (int i = -max; i <= max; i++) {\n\t\tprintf(\"f[%d][0] = %lld, f[%d][1] = %lld\\n\", i, f[i][0], i, f[i][1]);\n\t\tprintf(\"g[%d][0] = %lld, g[%d][1] = %lld\\n\", i, g[i][0], i, g[i][1]);\n\t}\n\tputchar('\\n');\n}\n*/\n\ninline long long calc(Node *root) {\n\tlong long res = 0;\n\tint max = 0;\n\tg[0][0] = 1;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tint curr = 0;\n\t\tdfs(e->t, e->w, curr);\n\t\t// print(max);\n\n\t\tres += (g[0][0] - 1) * f[0][0];\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\t// printf(\"res += %lld\\n\", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]));\n\t\t\tres += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]);\n\t\t}\n\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\tg[i][0] += f[i][0];\n\t\t\tg[i][1] += f[i][1];\n\t\t\tf[i][0] = f[i][1] = 0;\n\t\t}\n\n\t\tmax = std::max(max, curr);\n\t}\n\n\tfor (int i = -max; i <= max; i++) {\n\t\tg[i][0] = g[i][1] = 0;\n\t}\n\n\t// printf(\"calc(%ld) = %lld\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline long long solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\t\tans += calc(root);\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\tif (w == 0) w = -1;\n\t\taddEdge(u, v, w);\n\t}\n\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\t// printf(\"counter: %lld\\n\", counter);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3697","published":1,"updated":"2016-09-25T13:05:40.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9scf01fbooxllohwmidy"},{"title":"BZOJ 3511 - ","date":"2016-04-06T14:33:05.000Z","_content":"\n $ n $  $ m $  $ 1 $  $ A $$ n $  $ B $\n\n1.  $ i $ $ A $  $ VA_i $  $ B $  $ VB_i $ \n2.  $ i $ $ A $  $ EA_i $  $ B $  $ EB_i $  $ EC_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### \n $ A $  $ S $ $ B $  $ T $ \n\n $ u $ $ (S, u) = VA_i $ $ A $  $ (u, T) = VB_i $ $ B $ \n\n $ 1 $  $ n $ $ (S, 1) $  $ (n, T) $\n\n $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $  $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $\n\n $ A $  $ EB_i $  $ B $  $ EA_i $  $ EA_i $ $ EB_i $ \n\n$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3511.md","raw":"title: BZOJ 3511 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3511\ndate: 2016-04-06 22:33:05\n---\n\n $ n $  $ m $  $ 1 $  $ A $$ n $  $ B $\n\n1.  $ i $ $ A $  $ VA_i $  $ B $  $ VB_i $ \n2.  $ i $ $ A $  $ EA_i $  $ B $  $ EB_i $  $ EC_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### \n $ A $  $ S $ $ B $  $ T $ \n\n $ u $ $ (S, u) = VA_i $ $ A $  $ (u, T) = VB_i $ $ B $ \n\n $ 1 $  $ n $ $ (S, 1) $  $ (n, T) $\n\n $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $  $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $\n\n $ A $  $ EB_i $  $ B $  $ EA_i $  $ EA_i $ $ EB_i $ \n\n$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3511","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9scl01fgooxltchcuriw"},{"title":"BZOJ 3438 M  - ","date":"2016-06-21T07:18:00.000Z","_content":"\n M  $ A $  $ B $ $ n $ i $ A $  $ a_i $  $ B $  $ b_i $   \n $ m $  $ i $  $ A $  $ c_{1_i} $ $ B $  $ c_{2_i} $   \n\n\n<!-- more -->\n\n### \n[BZOJ 3438](http://www.lydsy.com/JudgeOnline/problem.php?id=3438)\n\n### \n $ A $  $ \\sum\\limits_{i = 1} ^ n a_i + \\sum\\limits_{i = 1} ^ m c_{1_i} $\n\n $ B $  $ B $  $ i $  $ c_{1_i} $ **** $ B $  $ i $  $ c_{2_i} $ \n\n $ B_i - A_i $ $ c_{1_i} $ $ c_{2_i} $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"[%d, %d] = %d\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\n\tconst int s = 0, t = n + m * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w = b[i - 1] - a[i - 1];\n\t\tif (w > 0) addEdge(s, i, w), sum += w;\n\t\telse addEdge(i, t, -w);\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint k, c1, c2;\n\t\tscanf(\"%d %d %d\", &k, &c1, &c2);\n\n\t\taddEdge(i, t, c1);\n\t\taddEdge(s, i + m, c2);\n\n\t\tsum += c1 + c2;\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(x, i, INT_MAX);\n\t\t\taddEdge(i + m, x, INT_MAX);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3438.md","raw":"title: BZOJ 3438 M  - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3438\ndate: 2016-06-21 15:18:00\n---\n\n M  $ A $  $ B $ $ n $ i $ A $  $ a_i $  $ B $  $ b_i $   \n $ m $  $ i $  $ A $  $ c_{1_i} $ $ B $  $ c_{2_i} $   \n\n\n<!-- more -->\n\n### \n[BZOJ 3438](http://www.lydsy.com/JudgeOnline/problem.php?id=3438)\n\n### \n $ A $  $ \\sum\\limits_{i = 1} ^ n a_i + \\sum\\limits_{i = 1} ^ m c_{1_i} $\n\n $ B $  $ B $  $ i $  $ c_{1_i} $ **** $ B $  $ i $  $ c_{2_i} $ \n\n $ B_i - A_i $ $ c_{1_i} $ $ c_{2_i} $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"[%d, %d] = %d\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\n\tconst int s = 0, t = n + m * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w = b[i - 1] - a[i - 1];\n\t\tif (w > 0) addEdge(s, i, w), sum += w;\n\t\telse addEdge(i, t, -w);\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint k, c1, c2;\n\t\tscanf(\"%d %d %d\", &k, &c1, &c2);\n\n\t\taddEdge(i, t, c1);\n\t\taddEdge(s, i + m, c2);\n\n\t\tsum += c1 + c2;\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(x, i, INT_MAX);\n\t\t\taddEdge(i + m, x, INT_MAX);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3438","published":1,"updated":"2016-06-21T07:18:27.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9scs01fnooxlnm5ke1v2"},{"title":"BZOJ 3365Distance Statistics - ","date":"2016-06-16T10:09:00.000Z","_content":"\n $ K $$ 1 \\leq K \\leq 10 ^ 9 $ $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 3365](http://www.lydsy.com/JudgeOnline/problem.php?id=3365)\n\n### \n [BZOJ 1468](bzoj-1468) \n\n### \n```c++\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// printf(\"start->size - cnt = %d\\n\", start->size - cnt);\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tchar s[2];\n\t\tscanf(\"%d %d %d %s\", &u, &v, &w, s), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3365.md","raw":"title: BZOJ 3365Distance Statistics - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3365\ndate: 2016-06-16 18:09:00\n---\n\n $ K $$ 1 \\leq K \\leq 10 ^ 9 $ $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 3365](http://www.lydsy.com/JudgeOnline/problem.php?id=3365)\n\n### \n [BZOJ 1468](bzoj-1468) \n\n### \n```c++\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// printf(\"start->size - cnt = %d\\n\", start->size - cnt);\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tchar s[2];\n\t\tscanf(\"%d %d %d %s\", &u, &v, &w, s), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3365","published":1,"updated":"2016-06-16T10:09:41.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sd001fuooxld0xz6w8z"},{"title":"BZOJ 3289Mato  - ","date":"2016-12-30T02:45:00.000Z","_content":"\n $ n $  $ [l, r] $ \n\n<!-- more -->\n\n### \n[BZOJ 3289](http://www.lydsy.com/JudgeOnline/problem.php?id=3289)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\n\nint blockSize;\n\nstruct Query {\n\tint l, r, a, b;\n\tstd::pair<int, int> *ans;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) return r < other.r;\n\t\telse return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\nint n, m, a[MAXN + 1];\n\nstruct BIT {\n\tint a[MAXN + MAXM * 2 + 1], n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t}\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n} bit1, bit2;\n\ninline std::pair<int, int> calc(int a, int b) {\n\treturn std::make_pair(bit1.query(a, b), bit2.query(a, b));\n}\n\nint cnt[MAXN + MAXM + 2 + 1];\ninline void extend(int l, int r, bool left, int d) {\n\tint pos = left ? l : r;\n\tbit1.update(a[pos], d);\n\tif (d == 1) {\n\t\tif (++cnt[a[pos]] == 1) bit2.update(a[pos], 1);\n\t} else {\n\t\tif (--cnt[a[pos]] == 0) bit2.update(a[pos], -1);\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (r < Q[i].r) extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) extend(l++, r, true, -1);\n\n\t\t*Q[i].ans = calc(Q[i].a, Q[i].b);\n\t}\n}\n\ninline void prepare() {\n\tstatic int set[MAXN + MAXM * 2 + 1];\n\tstd::copy(a + 1, a + n + 1, set + 1);\n\tfor (int i = 1; i <= m; i++) set[n + i] = Q[i].a;\n\tfor (int i = 1; i <= m; i++) set[n + m + i] = Q[i].b;\n\n\tstd::sort(set + 1, set + n + m * 2 + 1);\n\tint *end = std::unique(set + 1, set + n + m * 2 + 1);\n\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set;\n\n\tint cnt = end - (set + 1);\n\tbit1.init(cnt);\n\tbit2.init(cnt);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic std::pair<int, int> ans[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d %d %d\", &Q[i].l, &Q[i].r, &Q[i].a, &Q[i].b);\n\t\tQ[i].ans = &ans[i];\n\t}\n\n\tprepare();\n\n\tblockSize = floor(sqrt(n) + 1);\n\tstd::sort(Q + 1, Q + m + 1);\n\tsolve();\n\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3289.md","raw":"title: BZOJ 3289Mato  - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3289\ndate: 2016-12-30 10:45:00\n---\n\n $ n $  $ [l, r] $ \n\n<!-- more -->\n\n### \n[BZOJ 3289](http://www.lydsy.com/JudgeOnline/problem.php?id=3289)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\n\nint blockSize;\n\nstruct Query {\n\tint l, r, a, b;\n\tstd::pair<int, int> *ans;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) return r < other.r;\n\t\telse return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\nint n, m, a[MAXN + 1];\n\nstruct BIT {\n\tint a[MAXN + MAXM * 2 + 1], n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t}\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n} bit1, bit2;\n\ninline std::pair<int, int> calc(int a, int b) {\n\treturn std::make_pair(bit1.query(a, b), bit2.query(a, b));\n}\n\nint cnt[MAXN + MAXM + 2 + 1];\ninline void extend(int l, int r, bool left, int d) {\n\tint pos = left ? l : r;\n\tbit1.update(a[pos], d);\n\tif (d == 1) {\n\t\tif (++cnt[a[pos]] == 1) bit2.update(a[pos], 1);\n\t} else {\n\t\tif (--cnt[a[pos]] == 0) bit2.update(a[pos], -1);\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (r < Q[i].r) extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) extend(l++, r, true, -1);\n\n\t\t*Q[i].ans = calc(Q[i].a, Q[i].b);\n\t}\n}\n\ninline void prepare() {\n\tstatic int set[MAXN + MAXM * 2 + 1];\n\tstd::copy(a + 1, a + n + 1, set + 1);\n\tfor (int i = 1; i <= m; i++) set[n + i] = Q[i].a;\n\tfor (int i = 1; i <= m; i++) set[n + m + i] = Q[i].b;\n\n\tstd::sort(set + 1, set + n + m * 2 + 1);\n\tint *end = std::unique(set + 1, set + n + m * 2 + 1);\n\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set;\n\n\tint cnt = end - (set + 1);\n\tbit1.init(cnt);\n\tbit2.init(cnt);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic std::pair<int, int> ans[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d %d %d\", &Q[i].l, &Q[i].r, &Q[i].a, &Q[i].b);\n\t\tQ[i].ans = &ans[i];\n\t}\n\n\tprepare();\n\n\tblockSize = floor(sqrt(n) + 1);\n\tstd::sort(Q + 1, Q + m + 1);\n\tsolve();\n\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n```","slug":"bzoj-3289","published":1,"updated":"2016-12-30T02:45:35.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sd701fzooxlgv99imzv"},{"title":"BZOJ 3280 R  - ","date":"2016-09-03T23:21:00.000Z","_content":"\n $ n $  $ i $  $ a_i $  $ m $  $ j $  $ l_j $  $ p_j $ \n\n $ k $  $ i $  $ d_i $  $ q_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3280](http://www.lydsy.com/JudgeOnline/problem.php?id=3280)\n\n### \n\n\n $ a_i $\n\n $ m $  $ l_i $ $ p_i $\n\n $ i $  $ i + d_i $  $ q_i $\n\n $ a_i $ $ a_i $ $ \\sum a_i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXK = 50;\n\nstruct Node {\n\tstruct Edge *e, *in;\n\tbool q;\n\tint d, f;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].q = false;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].f = 0;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t}\n}\n\ninline void clear(const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t\tconst int s = 0, t = n * 2 + 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i, t, x, 0);\n\t\t\taddEdge(s, i + n, x, 0);\n\t\t\tsum += x;\n\n\t\t\tif (i != n) addEdge(i, i + 1, INT_MAX, 0);\n\t\t}\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\taddEdge(s, 1, a, b);\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b), a++;\n\t\t\tfor (int j = 1; j <= n - a; j++) addEdge(j + n, j + a, INT_MAX, b);\n\t\t}\n\n\t\tint flow, cost;\n\t\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\t\tprintf(\"Case %d: \", i);\n\t\tif (flow == sum) printf(\"%d\\n\", cost);\n\t\telse puts(\"impossible\");\n\n\t\tclear(n * 2 + 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3280.md","raw":"title: BZOJ 3280 R  - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Edmonds-Karp\npermalink: bzoj-3280\ndate: 2016-09-04 07:21:00\n---\n\n $ n $  $ i $  $ a_i $  $ m $  $ j $  $ l_j $  $ p_j $ \n\n $ k $  $ i $  $ d_i $  $ q_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3280](http://www.lydsy.com/JudgeOnline/problem.php?id=3280)\n\n### \n\n\n $ a_i $\n\n $ m $  $ l_i $ $ p_i $\n\n $ i $  $ i + d_i $  $ q_i $\n\n $ a_i $ $ a_i $ $ \\sum a_i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXK = 50;\n\nstruct Node {\n\tstruct Edge *e, *in;\n\tbool q;\n\tint d, f;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].q = false;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].f = 0;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t}\n}\n\ninline void clear(const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t\tconst int s = 0, t = n * 2 + 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i, t, x, 0);\n\t\t\taddEdge(s, i + n, x, 0);\n\t\t\tsum += x;\n\n\t\t\tif (i != n) addEdge(i, i + 1, INT_MAX, 0);\n\t\t}\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\taddEdge(s, 1, a, b);\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b), a++;\n\t\t\tfor (int j = 1; j <= n - a; j++) addEdge(j + n, j + a, INT_MAX, b);\n\t\t}\n\n\t\tint flow, cost;\n\t\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\t\tprintf(\"Case %d: \", i);\n\t\tif (flow == sum) printf(\"%d\\n\", cost);\n\t\telse puts(\"impossible\");\n\n\t\tclear(n * 2 + 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3280","published":1,"updated":"2016-09-10T11:54:33.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sdc01g4ooxl4pl7m6x7"},{"title":"BZOJ 3277 -  +  + ","date":"2016-09-29T23:24:00.000Z","_content":"\n $ n $  $ n $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 3277](http://www.lydsy.com/JudgeOnline/problem.php?id=3277)  \n[Codeforces 204E](http://codeforces.com/problemset/problem/204/E)\n\n### \n$ \\geq x $  $ \\geq k $  $ x $ \n\n $ x $ $ \\geq x $  `set`  $ x $  $ < x $ \n\n $ x $  $ x - 1 $  $ x - 1 $  $ x - 1 $  $ x $ \n\n $ k = 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 100000 + MAXN;\n\nint s[MAXLEN];\nint n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN];\n\ninline void suffixArray() {\n\tstatic int set[MAXLEN], a[MAXLEN];\n\tstd::copy(s, s + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\t\t\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tbool unique = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\tif (unique) break;\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\nstruct UnionFindSet {\n\tint a[MAXLEN], l[MAXLEN], r[MAXLEN];\n\tstd::set<int> set[MAXLEN];\n\n\tvoid init(const int n, const int *belong) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = i;\n\t\t\trk[i] = 1;\n\t\t\tl[i] = r[i] = i;\n\t\t\tset[i].insert(belong[i]);\n\t\t}\n\t}\n\n\tint find(const int x) {\n\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t}\n\n\tint merge(const int x, const int y) {\n#ifdef DBG\n\t\tprintf(\"merge(%d, %d)\\n\", x, y);\n#endif\n\t\tint _x = find(x), _y = find(y);\n\t\tif (set[_x].size() < set[_y].size()) std::swap(_x, _y);\n\t\ta[_y] = _x;\n\t\tset[_x].insert(set[_y].begin(), set[_y].end());\n\t\tl[_x] = std::min(l[_x], l[_y]);\n\t\tr[_x] = std::max(r[_x], r[_y]);\n\t\treturn _x;\n\t}\n\n\tint uniqueCount(const int x) {\n\t\treturn set[x].size();\n\t}\n\n\tvoid getRange(const int x, int &l, int &r) {\n\t\tl = this->l[x];\n\t\tr = this->r[x];\n\t}\n} ufs;\n\nlong long gap[MAXLEN + 1];\ninline void apply(const int id, const int val = 1) {\n\tint l, r;\n\tufs.getRange(id, l, r);\n\tgap[l] += val, gap[r + 1] -= val;\n#ifdef DBG\n\tfor (int i = l; i <= r; i++) printf(\"ans[%d] += %d\\n\", belong[i], val);\n#endif\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d\", &m, &k);\n\n\tint *p = s;\n\tint spliter = 233;\n\tfor (int i = 0; i < m; i++) {\n#ifdef DBG\n\t\tprintf(\"%d\\n\", i);\n#endif\n\t\tpos[i] = p - s;\n\t\tstatic char buf[MAXLEN];\n\t\tscanf(\"%s\", buf);\n\t\tint len = strlen(buf);\n\t\tif (k == 1) {\n\t\t\tstd::cout << (static_cast<long long>(len) * (len + 1) / 2) << (i == m - 1 ? '\\n' : ' ');\n\t\t}\n\t\tfor (int i = 0; i < len; i++) *p++ = buf[i];\n\t\t*p++ = spliter++;\n\t}\n\t\n\tif (k == 1) return 0;\n\n\t*--p = '\\0';\n\tn = p - s;\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1;\n\tufs.init(n, belong);\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d %s\\n\", belong[i], ht[i], &s[sa[i]]);\n\t}\n#endif\n\n\tstd::vector<int> v[MAXLEN];\n\tint maxH = 0;\n\tfor (int i = 0; i < n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]);\n\tfor (int i = maxH; i > 0; i--) {\n#ifdef DBG\n\t\tprintf(\"Now processing h = %d\\n\", i);\n#endif\n\t\tstd::vector<int> vec;\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\tint id = ufs.merge(*it, *it - 1);\n\t\t\tif (ufs.uniqueCount(id) >= k) {\n\t\t\t\t// apply(id);\n\t\t\t\tvec.push_back(id);\n\t\t\t}\n\t\t}\n\t\tfor (std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it);\n\t\tstd::sort(vec.begin(), vec.end());\n\t\tstd::vector<int>::const_iterator end = std::unique(vec.begin(), vec.end());\n\t\tfor (std::vector<int>::const_iterator it = vec.begin(); it != end; it++) {\n\t\t\tint l, r;\n\t\t\tufs.getRange(*it, l, r);\n\t\t\tint x = ht[l];\n\t\t\tif (r != n - 1) x = std::max(x, ht[r + 1]);\n\t\t\tapply(*it, i - x);\n\t\t}\n\t}\n\n\tstatic long long ans[MAXN];\n\tfor (int i = 1; i < n; i++) gap[i] += gap[i - 1];\n\tfor (int i = 0; i < n; i++) ans[belong[i]] += gap[i];\n\n\t// for (int i = 0; i < m; i++) printf(\"%lld%c\", ans[i], i == m - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::cout << ans[i]; //  << (i == m - 1 ? '\\0' : ' ');\n\t\tif (i != m - 1) std::cout << ' ';\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3277.md","raw":"title: BZOJ 3277 -  +  + \ncategories: OI\ntags: \n  - BZOJ\n  - Codeforces\n  - \n  - \n  - \n  - \npermalink: bzoj-3277\ndate: 2016-09-30 07:24:00\n---\n\n $ n $  $ n $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 3277](http://www.lydsy.com/JudgeOnline/problem.php?id=3277)  \n[Codeforces 204E](http://codeforces.com/problemset/problem/204/E)\n\n### \n$ \\geq x $  $ \\geq k $  $ x $ \n\n $ x $ $ \\geq x $  `set`  $ x $  $ < x $ \n\n $ x $  $ x - 1 $  $ x - 1 $  $ x - 1 $  $ x $ \n\n $ k = 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 100000 + MAXN;\n\nint s[MAXLEN];\nint n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN];\n\ninline void suffixArray() {\n\tstatic int set[MAXLEN], a[MAXLEN];\n\tstd::copy(s, s + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\t\t\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tbool unique = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\tif (unique) break;\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\nstruct UnionFindSet {\n\tint a[MAXLEN], l[MAXLEN], r[MAXLEN];\n\tstd::set<int> set[MAXLEN];\n\n\tvoid init(const int n, const int *belong) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = i;\n\t\t\trk[i] = 1;\n\t\t\tl[i] = r[i] = i;\n\t\t\tset[i].insert(belong[i]);\n\t\t}\n\t}\n\n\tint find(const int x) {\n\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t}\n\n\tint merge(const int x, const int y) {\n#ifdef DBG\n\t\tprintf(\"merge(%d, %d)\\n\", x, y);\n#endif\n\t\tint _x = find(x), _y = find(y);\n\t\tif (set[_x].size() < set[_y].size()) std::swap(_x, _y);\n\t\ta[_y] = _x;\n\t\tset[_x].insert(set[_y].begin(), set[_y].end());\n\t\tl[_x] = std::min(l[_x], l[_y]);\n\t\tr[_x] = std::max(r[_x], r[_y]);\n\t\treturn _x;\n\t}\n\n\tint uniqueCount(const int x) {\n\t\treturn set[x].size();\n\t}\n\n\tvoid getRange(const int x, int &l, int &r) {\n\t\tl = this->l[x];\n\t\tr = this->r[x];\n\t}\n} ufs;\n\nlong long gap[MAXLEN + 1];\ninline void apply(const int id, const int val = 1) {\n\tint l, r;\n\tufs.getRange(id, l, r);\n\tgap[l] += val, gap[r + 1] -= val;\n#ifdef DBG\n\tfor (int i = l; i <= r; i++) printf(\"ans[%d] += %d\\n\", belong[i], val);\n#endif\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d\", &m, &k);\n\n\tint *p = s;\n\tint spliter = 233;\n\tfor (int i = 0; i < m; i++) {\n#ifdef DBG\n\t\tprintf(\"%d\\n\", i);\n#endif\n\t\tpos[i] = p - s;\n\t\tstatic char buf[MAXLEN];\n\t\tscanf(\"%s\", buf);\n\t\tint len = strlen(buf);\n\t\tif (k == 1) {\n\t\t\tstd::cout << (static_cast<long long>(len) * (len + 1) / 2) << (i == m - 1 ? '\\n' : ' ');\n\t\t}\n\t\tfor (int i = 0; i < len; i++) *p++ = buf[i];\n\t\t*p++ = spliter++;\n\t}\n\t\n\tif (k == 1) return 0;\n\n\t*--p = '\\0';\n\tn = p - s;\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1;\n\tufs.init(n, belong);\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d %s\\n\", belong[i], ht[i], &s[sa[i]]);\n\t}\n#endif\n\n\tstd::vector<int> v[MAXLEN];\n\tint maxH = 0;\n\tfor (int i = 0; i < n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]);\n\tfor (int i = maxH; i > 0; i--) {\n#ifdef DBG\n\t\tprintf(\"Now processing h = %d\\n\", i);\n#endif\n\t\tstd::vector<int> vec;\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\tint id = ufs.merge(*it, *it - 1);\n\t\t\tif (ufs.uniqueCount(id) >= k) {\n\t\t\t\t// apply(id);\n\t\t\t\tvec.push_back(id);\n\t\t\t}\n\t\t}\n\t\tfor (std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it);\n\t\tstd::sort(vec.begin(), vec.end());\n\t\tstd::vector<int>::const_iterator end = std::unique(vec.begin(), vec.end());\n\t\tfor (std::vector<int>::const_iterator it = vec.begin(); it != end; it++) {\n\t\t\tint l, r;\n\t\t\tufs.getRange(*it, l, r);\n\t\t\tint x = ht[l];\n\t\t\tif (r != n - 1) x = std::max(x, ht[r + 1]);\n\t\t\tapply(*it, i - x);\n\t\t}\n\t}\n\n\tstatic long long ans[MAXN];\n\tfor (int i = 1; i < n; i++) gap[i] += gap[i - 1];\n\tfor (int i = 0; i < n; i++) ans[belong[i]] += gap[i];\n\n\t// for (int i = 0; i < m; i++) printf(\"%lld%c\", ans[i], i == m - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::cout << ans[i]; //  << (i == m - 1 ? '\\0' : ' ');\n\t\tif (i != m - 1) std::cout << ' ';\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3277","published":1,"updated":"2016-09-29T23:40:34.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sdj01gaooxlldwx269a"},{"title":"BZOJ 3275Number - ","date":"2016-05-23T13:50:00.000Z","_content":"\n $ N $ \n\n $ a,\\ b $  $ a,\\ b $ \n\n1.  $ c $ $ a ^ 2 + b ^ 2 = c ^ 2 $\n2. $ \\gcd(a,\\ b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 3275](http://www.lydsy.com/JudgeOnline/problem.php?id=3275)  \n[COGS 1389](http://cogs.top/cogs/problem/problem.php?pid=1389)\n\n### \n\n\n $ X $  $ Y $  $ X $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n\tlong long x;\n\tbool color, v;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const long long c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], 0);\n\t(N[u].e->r = N[v].e)->r = N[u].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlong long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tlong long flow = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->f += flow;\n\t\t\t\t\te->r->f -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlong long operator()(const int s, const int t, const int n) {\n\t\tlong long res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tlong long flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\nint n;\nbool flag[MAXN][MAXN];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\n\ntemplate <typename T>\ninline bool isSquare(const T x) {\n\tT t = static_cast<T>(sqrt(static_cast<double>(x)));\n\treturn t * t == x;\n}\n\ntemplate <typename T>\ninline T gcd(const T a, const T b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].color = true;\n\t\tN[i].v = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->v) {\n\t\t\t\t\te->t->v = true;\n\t\t\t\t\te->t->color = !v->color;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else assert(e->t->color != v->color);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void clean() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &N[i].x);\n\t\tsum += N[i].x;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (isSquare(sqr(N[i].x) + sqr(N[j].x)) && gcd(N[i].x, N[j].x) == 1) {\n\t\t\t\tflag[i][j] = flag[j][i] = true;\n\t\t\t\taddEdge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcolor();\n\tclean();\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].color) addEdge(s, i, N[i].x);\n\t\telse addEdge(i, t, N[i].x);\n\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (flag[i][j]) {\n\t\t\t\tif (N[i].color) addEdge(i, j, LLONG_MAX);\n\t\t\t\telse addEdge(j, i, LLONG_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%lld\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3275.md","raw":"title: BZOJ 3275Number - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \n  - \npermalink: bzoj-3275\ndate: 2016-05-23 21:50:00\n---\n\n $ N $ \n\n $ a,\\ b $  $ a,\\ b $ \n\n1.  $ c $ $ a ^ 2 + b ^ 2 = c ^ 2 $\n2. $ \\gcd(a,\\ b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 3275](http://www.lydsy.com/JudgeOnline/problem.php?id=3275)  \n[COGS 1389](http://cogs.top/cogs/problem/problem.php?pid=1389)\n\n### \n\n\n $ X $  $ Y $  $ X $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n\tlong long x;\n\tbool color, v;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const long long c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], 0);\n\t(N[u].e->r = N[v].e)->r = N[u].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlong long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tlong long flow = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->f += flow;\n\t\t\t\t\te->r->f -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlong long operator()(const int s, const int t, const int n) {\n\t\tlong long res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tlong long flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\nint n;\nbool flag[MAXN][MAXN];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\n\ntemplate <typename T>\ninline bool isSquare(const T x) {\n\tT t = static_cast<T>(sqrt(static_cast<double>(x)));\n\treturn t * t == x;\n}\n\ntemplate <typename T>\ninline T gcd(const T a, const T b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].color = true;\n\t\tN[i].v = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->v) {\n\t\t\t\t\te->t->v = true;\n\t\t\t\t\te->t->color = !v->color;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else assert(e->t->color != v->color);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void clean() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &N[i].x);\n\t\tsum += N[i].x;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (isSquare(sqr(N[i].x) + sqr(N[j].x)) && gcd(N[i].x, N[j].x) == 1) {\n\t\t\t\tflag[i][j] = flag[j][i] = true;\n\t\t\t\taddEdge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcolor();\n\tclean();\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].color) addEdge(s, i, N[i].x);\n\t\telse addEdge(i, t, N[i].x);\n\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (flag[i][j]) {\n\t\t\t\tif (N[i].color) addEdge(i, j, LLONG_MAX);\n\t\t\t\telse addEdge(j, i, LLONG_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%lld\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3275","published":1,"updated":"2016-05-23T15:09:19.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sdr01giooxlxt70lzsf"},{"title":"BZOJ 3262 - CDQ","date":"2016-06-19T12:56:00.000Z","_content":"\n $ A_i = (a,\\ b,\\ c) $  \n $ a_i \\leq a_j,\\ b_i \\leq b_j,\\ c_i \\leq c_j $ $ A_j $  $ A_i $   \n $ A_i $  $ A_j $  $ A_i $  $ A_j $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 3262](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n### \n CDQ \n\n CDQ  $ a $  $ b $ \n\n $ b $  $ c $  $ c $  $ c $  $ b $  $ a $ CDQ \n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXK = 200000;\n\nstruct Triple {\n\tint a, b, c, cnt, ans;\n} a[MAXN], A[MAXN];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.a < b.a || (a.a == b.a && a.b < b.b) || (a.a == b.a && a.b == b.b && a.c < b.c);\n}\n\nint n, k;\n\nstruct BinaryIndexedTree {\n\tint a[MAXK];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clean(const int x) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->b <= p2->b && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tbit.clean(p->c);\n\t\t*q = *p;\n\t}\n\n\t/*\n\tprintf(\"cdq(%ld, %ld): \", l - A + 1, r - A + 1);\n\tfor (Triple *p = l; p <= r; p++) {\n\t\tprintf(\"(%d, %d, %d)%s\", p->a, p->b, p->c, p == r ? \"\\n\" : \", \");\n\t}\n\t*/\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T &x) {\n\tstatic char s[20];\n\tint cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tread(n), read(k);\n\tfor (int i = 0; i < n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1;\n\t// scanf(\"%d %d\", &n, &k);\n\t// for (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\n\tstd::sort(a, a + n);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[cnt++] = a[i];\n\t\telse A[cnt - 1].cnt++;\n\t}\n\n\tcdq(A, A + cnt - 1);\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0; i < cnt; i++) ans[A[i].ans] += A[i].cnt;\n\t\n\tfor (int i = 0; i < n; i++) write(ans[i]);\n\t// for (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3262.md","raw":"title: BZOJ 3262 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-3262\ndate: 2016-06-19 20:56:00\n---\n\n $ A_i = (a,\\ b,\\ c) $  \n $ a_i \\leq a_j,\\ b_i \\leq b_j,\\ c_i \\leq c_j $ $ A_j $  $ A_i $   \n $ A_i $  $ A_j $  $ A_i $  $ A_j $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 3262](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n### \n CDQ \n\n CDQ  $ a $  $ b $ \n\n $ b $  $ c $  $ c $  $ c $  $ b $  $ a $ CDQ \n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXK = 200000;\n\nstruct Triple {\n\tint a, b, c, cnt, ans;\n} a[MAXN], A[MAXN];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.a < b.a || (a.a == b.a && a.b < b.b) || (a.a == b.a && a.b == b.b && a.c < b.c);\n}\n\nint n, k;\n\nstruct BinaryIndexedTree {\n\tint a[MAXK];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clean(const int x) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->b <= p2->b && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tbit.clean(p->c);\n\t\t*q = *p;\n\t}\n\n\t/*\n\tprintf(\"cdq(%ld, %ld): \", l - A + 1, r - A + 1);\n\tfor (Triple *p = l; p <= r; p++) {\n\t\tprintf(\"(%d, %d, %d)%s\", p->a, p->b, p->c, p == r ? \"\\n\" : \", \");\n\t}\n\t*/\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T &x) {\n\tstatic char s[20];\n\tint cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tread(n), read(k);\n\tfor (int i = 0; i < n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1;\n\t// scanf(\"%d %d\", &n, &k);\n\t// for (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\n\tstd::sort(a, a + n);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[cnt++] = a[i];\n\t\telse A[cnt - 1].cnt++;\n\t}\n\n\tcdq(A, A + cnt - 1);\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0; i < cnt; i++) ans[A[i].ans] += A[i].cnt;\n\t\n\tfor (int i = 0; i < n; i++) write(ans[i]);\n\t// for (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3262","published":1,"updated":"2016-06-19T12:56:40.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sdy01gpooxlb5n43bq4"},{"title":"BZOJ 3230 - ","date":"2016-09-29T22:59:00.000Z","_content":"\n $ N $  $ S $ $ f = a ^ 2 + b ^ 2 $  $ a $$ b $ $ S[l \\ldots l + a - 1] = S[p \\ldots p + a - 1] $$ S[r - b + 1 \\ldots r] = S[q - b + 1 \\ldots q] $$ 0 \\leq a \\leq r - l + 1 $$ 0 \\leq b \\leq q - p + 1 $\n\n $ i $  $ j $ \n\n<!-- more -->\n\n### \n[BZOJ 3230](http://www.lydsy.com/JudgeOnline/problem.php?id=3230)\n\n### \n $ N $  $ O(N ^ 2) $ \n\n $ i $  $ i - 1 $  $ l $ $ i $  $ i - 1 $  $ \\mathrm{len}(i) - l $  $ l + 1 $\n\n $ i $ $ a $  $ b $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812;\n\nchar s[MAXN], sRev[MAXN];\nint n, log[MAXN + 1];\nlong long cnt[MAXN];\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1];\n\n\tvoid build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n\t\t// */\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef TEST\n\t\tassert(l <= r);\n#endif\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\tint res = std::min(st[l][t], st[r - (1 << t) + 1][t]);\n#ifdef TEST\n\t\tint ans = n;\n\t\tfor (int k = l; k <= r; k++) ans = std::min(ans, ht[k]);\n\t\tassert(res == ans);\n#endif\n\t\treturn res;\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn query(a + 1, b);\n\t}\n} sa, saRev;\n\ninline int lcp(const int i, const int j) {\n\tint res = sa.lcp(i, j);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i + ans < n && j + ans < n && s[i + ans] == s[j + ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline int lcs(const int i, const int j) {\n\tint res = saRev.lcp(n - i - 1, n - j - 1);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i - ans >= 0 && j - ans >= 0 && s[i - ans] == s[j - ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline void prepare() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t\t// printf(\"log(%d) = %d\\n\", i, log[i]);\n\t}\n\n\tsa.build(s, n);\n\n\tlong long x = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tx += n - sa.sa[i];\n\t\tif (i) x -= sa.ht[i];\n\t\tcnt[i] = x;\n\t\t// printf(\"%lld\\n\", x);\n\t}\n\n\tstd::copy(s, s + n, sRev);\n\tstd::reverse(sRev, sRev + n);\n\tsaRev.build(sRev, n);\n}\n\ninline bool locate(const long long k, int &l, int &r) {\n\tlong long *p = std::upper_bound(cnt, cnt + n, k - 1);\n\tif (p == cnt + n) return false;\n\tint t = *p - k;\n\tl = sa.sa[p - cnt];\n\tr = n - t - 1;\n\treturn true;\n}\n\ninline void all() {\n\tstd::vector<std::string> v;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) v.push_back(std::string(&s[i], &s[j]));\n\tstd::sort(v.begin(), v.end());\n\tv.erase(std::unique(v.begin(), v.end()), v.end());\n\tint i = 1;\n\tfor (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tint l, r;\n\t\tlocate(i++, l, r);\n\t\t// printf(\"%d %d\\n\", l, r);\n\t\tfor (int j = l; j <= r; j++) putchar(s[j]);\n\t\tputchar('\\n');\n\t\tprintf(\"%s\\n\", it->c_str());\n\t}\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\\n%s\", &n, &q, s);\n\tn = strlen(s);\n\tprepare();\n\t// all();\n\n\t/*\n\tputs(\"left query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"lq(%d, %d) = %d\\n\", i, j, query(stp, i, j));\n\n\tputs(\"right query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"rq(%d, %d) = %d\\n\", i, j, query(sts, i, j));\n\t*/\n\n\t/*\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcp(%d, %d) = %d\\n\", i, j, lcp(i, j));\n\tputchar('\\n');\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcs(%d, %d) = %d\\n\", i, j, lcs(i, j));\n\t*/\n\n\twhile (q--) {\n\t\tlong long i, j;\n\t\tscanf(\"%lld %lld\", &i, &j);\n\t\tint l1, r1, l2, r2;\n\t\tif (!locate(i, l1, r1) || !locate(j, l2, r2)) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint lim = std::min(r1 - l1 + 1, r2 - l2 + 1);\n\t\tlong long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2));\n\t\tprintf(\"%lld\\n\", a * a + b * b);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3230.md","raw":"title: BZOJ 3230 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3230\ndate: 2016-09-30 06:59:00\n---\n\n $ N $  $ S $ $ f = a ^ 2 + b ^ 2 $  $ a $$ b $ $ S[l \\ldots l + a - 1] = S[p \\ldots p + a - 1] $$ S[r - b + 1 \\ldots r] = S[q - b + 1 \\ldots q] $$ 0 \\leq a \\leq r - l + 1 $$ 0 \\leq b \\leq q - p + 1 $\n\n $ i $  $ j $ \n\n<!-- more -->\n\n### \n[BZOJ 3230](http://www.lydsy.com/JudgeOnline/problem.php?id=3230)\n\n### \n $ N $  $ O(N ^ 2) $ \n\n $ i $  $ i - 1 $  $ l $ $ i $  $ i - 1 $  $ \\mathrm{len}(i) - l $  $ l + 1 $\n\n $ i $ $ a $  $ b $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812;\n\nchar s[MAXN], sRev[MAXN];\nint n, log[MAXN + 1];\nlong long cnt[MAXN];\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1];\n\n\tvoid build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n\t\t// */\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef TEST\n\t\tassert(l <= r);\n#endif\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\tint res = std::min(st[l][t], st[r - (1 << t) + 1][t]);\n#ifdef TEST\n\t\tint ans = n;\n\t\tfor (int k = l; k <= r; k++) ans = std::min(ans, ht[k]);\n\t\tassert(res == ans);\n#endif\n\t\treturn res;\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn query(a + 1, b);\n\t}\n} sa, saRev;\n\ninline int lcp(const int i, const int j) {\n\tint res = sa.lcp(i, j);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i + ans < n && j + ans < n && s[i + ans] == s[j + ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline int lcs(const int i, const int j) {\n\tint res = saRev.lcp(n - i - 1, n - j - 1);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i - ans >= 0 && j - ans >= 0 && s[i - ans] == s[j - ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline void prepare() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t\t// printf(\"log(%d) = %d\\n\", i, log[i]);\n\t}\n\n\tsa.build(s, n);\n\n\tlong long x = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tx += n - sa.sa[i];\n\t\tif (i) x -= sa.ht[i];\n\t\tcnt[i] = x;\n\t\t// printf(\"%lld\\n\", x);\n\t}\n\n\tstd::copy(s, s + n, sRev);\n\tstd::reverse(sRev, sRev + n);\n\tsaRev.build(sRev, n);\n}\n\ninline bool locate(const long long k, int &l, int &r) {\n\tlong long *p = std::upper_bound(cnt, cnt + n, k - 1);\n\tif (p == cnt + n) return false;\n\tint t = *p - k;\n\tl = sa.sa[p - cnt];\n\tr = n - t - 1;\n\treturn true;\n}\n\ninline void all() {\n\tstd::vector<std::string> v;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) v.push_back(std::string(&s[i], &s[j]));\n\tstd::sort(v.begin(), v.end());\n\tv.erase(std::unique(v.begin(), v.end()), v.end());\n\tint i = 1;\n\tfor (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tint l, r;\n\t\tlocate(i++, l, r);\n\t\t// printf(\"%d %d\\n\", l, r);\n\t\tfor (int j = l; j <= r; j++) putchar(s[j]);\n\t\tputchar('\\n');\n\t\tprintf(\"%s\\n\", it->c_str());\n\t}\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\\n%s\", &n, &q, s);\n\tn = strlen(s);\n\tprepare();\n\t// all();\n\n\t/*\n\tputs(\"left query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"lq(%d, %d) = %d\\n\", i, j, query(stp, i, j));\n\n\tputs(\"right query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"rq(%d, %d) = %d\\n\", i, j, query(sts, i, j));\n\t*/\n\n\t/*\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcp(%d, %d) = %d\\n\", i, j, lcp(i, j));\n\tputchar('\\n');\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcs(%d, %d) = %d\\n\", i, j, lcs(i, j));\n\t*/\n\n\twhile (q--) {\n\t\tlong long i, j;\n\t\tscanf(\"%lld %lld\", &i, &j);\n\t\tint l1, r1, l2, r2;\n\t\tif (!locate(i, l1, r1) || !locate(j, l2, r2)) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint lim = std::min(r1 - l1 + 1, r2 - l2 + 1);\n\t\tlong long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2));\n\t\tprintf(\"%lld\\n\", a * a + b * b);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3230","published":1,"updated":"2016-09-29T23:26:11.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9se501gwooxl4he1heaz"},{"title":"BZOJ 3196 - ","date":"2016-06-19T01:37:00.000Z","_content":"\n\n\n1.  $ k $ \n2.  $ k $ \n3. \n4.  $ k $  $ x $\n5.  $ k $  $ x $\n\n<!-- more -->\n\n### \n[BZOJ 3196](http://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n### \n\n\n $ O(\\log n) $  $ O(n \\log n) $ $ O(n \\log ^ 2 n) $ \n\n#### \n $ O(\\log n) $ \n\n#### \n\n\n $ x $ $ x $  $ k $ $ x $\n\n\n\n#### \n\n\n#### \n $ O(\\log n) $ \n\n $ O(n \\log ^ 3 n) $ Splay  BZOJ \n\n $ O(n \\log ^ 2 n) $ 512M \n\n![](bzoj-3196/lemon.png)\n\n $ O(n \\sqrt n \\log n) $\n\n### \n SplayRP  TLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\n\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size, cnt, val;\n\n\t\tNode(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) {\n\t\t\tc[L] = c[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = cnt;\n\t\t\tif (c[L]) size += c[L]->size;\n\t\t\tif (c[R]) size += c[R]->size;\n\t\t}\n\n\t\tRelation relatain() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relatain();\n\t\t\tNode *o = p;\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relatain()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (p->relatain() == relatain()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prec() {\n\t\t\tsplay();\n\t\t\tNode *v = c[L];\n\t\t\twhile (v->c[R]) v = v->c[R];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = c[R];\n\t\t\twhile (v->c[L]) v = v->c[L];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tint left() const { return c[L] ? c[L]->size : 0; }\n\n#ifdef DBG\n\t\tvoid validate() {\n\t\t\tint size = 0;\n\t\t\tif (c[L]) c[L]->validate(), assert(this->val > c[L]->val), size += c[L]->size;\n\t\t\tif (c[R]) c[R]->validate(), assert(this->val < c[R]->val), size += c[R]->size;\n\t\t\tassert(this->size == size + cnt);\n\t\t}\n\n\t\tvoid print(const int depth = 0);\n#endif\n\t} *r;\n#ifdef DBG\n\tint id;\n#endif\n\n\tSplay(const int *a, const int n) : r(NULL) {\n\t\tinsert(INT_MAX), insert(INT_MIN);\n#ifdef DBG\n\t\tstatic int time = 0;\n\t\ttime++;\n\t\tid = time;\n\t\tprintf(\"build(%d): \", id);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~Splay() { delete r; }\n\n\tNode *find(const int x) {\n\t\tNode *v = r;\n\t\twhile (v && x != v->val) {\n\t\t\tif (x < v->val) v = v->c[L];\n\t\t\telse v = v->c[R];\n\t\t}\n\t\treturn v ? v->splay() : NULL;\n\t}\n\n\tNode *insert(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) {\n\t\t\tv->cnt++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &r, *p = NULL;\n\t\twhile (*target) {\n\t\t\tp = *target;\n\t\t\tp->size++;\n\t\t\tif (x< p->val) target = &p->c[L];\n\t\t\telse target = &p->c[R];\n\t\t}\n\n\t\treturn (*target = new Node(p, x, &r))->splay();\n\t}\n\n\tint rank(const int x) {\n\t\tNode *v = find(x);\n\t\tint res;\n\t\tif (v) res = v->left();\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tres = v->left();\n\t\t\terase(v);\n\t\t}\n#ifdef DBG\n\t\tprintf(\"rank(%d) in (%d) = %d\\n\", x, id, res);\n#endif\n\t\treturn res;\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (!(x >= v->left() + 1 && x <= v->left() + v->cnt)) {\n\t\t\tif (x < v->left() + 1) v = v->c[L];\n\t\t\telse x -= v->left() + v->cnt, v = v->c[R];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->cnt != 1) {\n\t\t\tv->cnt--, v->size--;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode *prec = v->prec(), *succ = v->succ();\n\n\t\tprec->splay();\n\t\tsucc->splay(prec);\n\n\t\tdelete succ->c[L];\n\t\tsucc->c[L] = NULL;\n\n\t\tsucc->maintain(), prec->maintain();\n\t}\n\n\tvoid erase(const int x) {\n\t\tNode *v = find(x);\n\t\terase(v);\n\t}\n\n\tint prec(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->prec()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->prec()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint succ(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->succ()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tr->validate();\n\t}\n#endif\n};\n\n#ifdef DBG\nvoid Splay::Node::print(const int depth) {\n\tif (c[L]) c[L]->print(depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' '), putchar(' ');\n\tprintf(\"%d\\n\", val);\n\tif (c[R]) c[R]->print(depth + 1);\n}\n#endif\n\nint map[MAXM + MAXN], max;\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tSplay s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n\nMLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\nint map[MAXM + MAXN], max;\n\nstruct WeightSegmentTree {\n\tint l, r, mid;\n\tWeightSegmentTree *lc, *rc;\n\tint min, max, cnt;\n\n\tWeightSegmentTree(const int l, const int r)\n\t\t: l(l), r(r), mid(l + (r - l) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{}\n\n\tWeightSegmentTree(const int *a, const int n)\n\t\t: l(0), r(::max - 1), mid((max - 1) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~WeightSegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tvoid maintain() {\n\t\tmin = INT_MAX;\n\t\tif (lc) min = std::min(min, lc->min);\n\t\tif (rc) min = std::min(min, rc->min);\n\n\t\tmax = INT_MIN;\n\t\tif (lc) max = std::max(max, lc->max);\n\t\tif (rc) max = std::max(max, rc->max);\n\n\t\tcnt = 0;\n\t\tif (lc) cnt += lc->cnt;\n\t\tif (rc) cnt += rc->cnt;\n\t}\n\n\tvoid insert(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!cnt++) min = max = x;\n\t\t} else {\n\t\t\tif (x <= mid) {\n\t\t\t\tif (!lc) lc = new WeightSegmentTree(l, mid);\n\t\t\t\tlc->insert(x);\n\t\t\t} else {\n\t\t\t\tif (!rc) rc = new WeightSegmentTree(mid + 1, r);\n\t\t\t\trc->insert(x);\n\t\t\t}\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tvoid erase(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!--cnt) min = INT_MAX, max = INT_MIN;\n\t\t} else {\n\t\t\tif (x <= mid) lc->erase(x);\n\t\t\telse rc->erase(x);\n\t\t\tmaintain();\n\t\t\tif (x <= mid && lc->cnt == 0) delete lc, lc = NULL;\n\t\t\telse if (x > mid && rc->cnt == 0) delete rc, rc = NULL;\n\t\t}\n\t}\n\n\tint prec(const int x) {\n\t\treturn queryMax(0, x - 1);\n\t}\n\n\tint succ(const int x) {\n\t\treturn queryMin(x + 1, ::max);\n\t}\n\n\tint rank(const int x) {\n\t\treturn queryCnt(0, x - 1) + 1;\n\t}\n\n\tint select(const int k) {\n\t\tint x = k;\n\t\tWeightSegmentTree *v = this;\n\t\twhile (v->l != v->r) {\n\t\t\tif (!v->lc) v = v->rc;\n\t\t\telse if (x <= v->lc->cnt) v = v->lc;\n\t\t\telse x -= v->lc->cnt, v = v->rc;\n\t\t}\n\t\treturn v->mid;\n\t}\n\n\tint queryMin(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return min;\n\t\telse {\n\t\t\tint res = INT_MAX;\n\t\t\tif (lc) res = lc->queryMin(l, r);\n\t\t\tif (res == INT_MAX && rc) return rc->queryMin(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse {\n\t\t\tint res = INT_MIN;\n\t\t\tif (rc) res = rc->queryMax(l, r);\n\t\t\tif (res == INT_MIN && lc) return lc->queryMax(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryCnt(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tif (lc) res += lc->queryCnt(l, r);\n\t\t\tif (rc) res += rc->queryCnt(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tWeightSegmentTree s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3196.md","raw":"title: BZOJ 3196 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Splay\n  - \npermalink: bzoj-3196\ndate: 2016-06-19 09:37:00\n---\n\n\n\n1.  $ k $ \n2.  $ k $ \n3. \n4.  $ k $  $ x $\n5.  $ k $  $ x $\n\n<!-- more -->\n\n### \n[BZOJ 3196](http://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n### \n\n\n $ O(\\log n) $  $ O(n \\log n) $ $ O(n \\log ^ 2 n) $ \n\n#### \n $ O(\\log n) $ \n\n#### \n\n\n $ x $ $ x $  $ k $ $ x $\n\n\n\n#### \n\n\n#### \n $ O(\\log n) $ \n\n $ O(n \\log ^ 3 n) $ Splay  BZOJ \n\n $ O(n \\log ^ 2 n) $ 512M \n\n![](bzoj-3196/lemon.png)\n\n $ O(n \\sqrt n \\log n) $\n\n### \n SplayRP  TLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\n\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size, cnt, val;\n\n\t\tNode(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) {\n\t\t\tc[L] = c[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = cnt;\n\t\t\tif (c[L]) size += c[L]->size;\n\t\t\tif (c[R]) size += c[R]->size;\n\t\t}\n\n\t\tRelation relatain() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relatain();\n\t\t\tNode *o = p;\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relatain()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (p->relatain() == relatain()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prec() {\n\t\t\tsplay();\n\t\t\tNode *v = c[L];\n\t\t\twhile (v->c[R]) v = v->c[R];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = c[R];\n\t\t\twhile (v->c[L]) v = v->c[L];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tint left() const { return c[L] ? c[L]->size : 0; }\n\n#ifdef DBG\n\t\tvoid validate() {\n\t\t\tint size = 0;\n\t\t\tif (c[L]) c[L]->validate(), assert(this->val > c[L]->val), size += c[L]->size;\n\t\t\tif (c[R]) c[R]->validate(), assert(this->val < c[R]->val), size += c[R]->size;\n\t\t\tassert(this->size == size + cnt);\n\t\t}\n\n\t\tvoid print(const int depth = 0);\n#endif\n\t} *r;\n#ifdef DBG\n\tint id;\n#endif\n\n\tSplay(const int *a, const int n) : r(NULL) {\n\t\tinsert(INT_MAX), insert(INT_MIN);\n#ifdef DBG\n\t\tstatic int time = 0;\n\t\ttime++;\n\t\tid = time;\n\t\tprintf(\"build(%d): \", id);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~Splay() { delete r; }\n\n\tNode *find(const int x) {\n\t\tNode *v = r;\n\t\twhile (v && x != v->val) {\n\t\t\tif (x < v->val) v = v->c[L];\n\t\t\telse v = v->c[R];\n\t\t}\n\t\treturn v ? v->splay() : NULL;\n\t}\n\n\tNode *insert(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) {\n\t\t\tv->cnt++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &r, *p = NULL;\n\t\twhile (*target) {\n\t\t\tp = *target;\n\t\t\tp->size++;\n\t\t\tif (x< p->val) target = &p->c[L];\n\t\t\telse target = &p->c[R];\n\t\t}\n\n\t\treturn (*target = new Node(p, x, &r))->splay();\n\t}\n\n\tint rank(const int x) {\n\t\tNode *v = find(x);\n\t\tint res;\n\t\tif (v) res = v->left();\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tres = v->left();\n\t\t\terase(v);\n\t\t}\n#ifdef DBG\n\t\tprintf(\"rank(%d) in (%d) = %d\\n\", x, id, res);\n#endif\n\t\treturn res;\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (!(x >= v->left() + 1 && x <= v->left() + v->cnt)) {\n\t\t\tif (x < v->left() + 1) v = v->c[L];\n\t\t\telse x -= v->left() + v->cnt, v = v->c[R];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->cnt != 1) {\n\t\t\tv->cnt--, v->size--;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode *prec = v->prec(), *succ = v->succ();\n\n\t\tprec->splay();\n\t\tsucc->splay(prec);\n\n\t\tdelete succ->c[L];\n\t\tsucc->c[L] = NULL;\n\n\t\tsucc->maintain(), prec->maintain();\n\t}\n\n\tvoid erase(const int x) {\n\t\tNode *v = find(x);\n\t\terase(v);\n\t}\n\n\tint prec(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->prec()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->prec()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint succ(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->succ()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tr->validate();\n\t}\n#endif\n};\n\n#ifdef DBG\nvoid Splay::Node::print(const int depth) {\n\tif (c[L]) c[L]->print(depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' '), putchar(' ');\n\tprintf(\"%d\\n\", val);\n\tif (c[R]) c[R]->print(depth + 1);\n}\n#endif\n\nint map[MAXM + MAXN], max;\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tSplay s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n\nMLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\nint map[MAXM + MAXN], max;\n\nstruct WeightSegmentTree {\n\tint l, r, mid;\n\tWeightSegmentTree *lc, *rc;\n\tint min, max, cnt;\n\n\tWeightSegmentTree(const int l, const int r)\n\t\t: l(l), r(r), mid(l + (r - l) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{}\n\n\tWeightSegmentTree(const int *a, const int n)\n\t\t: l(0), r(::max - 1), mid((max - 1) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~WeightSegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tvoid maintain() {\n\t\tmin = INT_MAX;\n\t\tif (lc) min = std::min(min, lc->min);\n\t\tif (rc) min = std::min(min, rc->min);\n\n\t\tmax = INT_MIN;\n\t\tif (lc) max = std::max(max, lc->max);\n\t\tif (rc) max = std::max(max, rc->max);\n\n\t\tcnt = 0;\n\t\tif (lc) cnt += lc->cnt;\n\t\tif (rc) cnt += rc->cnt;\n\t}\n\n\tvoid insert(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!cnt++) min = max = x;\n\t\t} else {\n\t\t\tif (x <= mid) {\n\t\t\t\tif (!lc) lc = new WeightSegmentTree(l, mid);\n\t\t\t\tlc->insert(x);\n\t\t\t} else {\n\t\t\t\tif (!rc) rc = new WeightSegmentTree(mid + 1, r);\n\t\t\t\trc->insert(x);\n\t\t\t}\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tvoid erase(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!--cnt) min = INT_MAX, max = INT_MIN;\n\t\t} else {\n\t\t\tif (x <= mid) lc->erase(x);\n\t\t\telse rc->erase(x);\n\t\t\tmaintain();\n\t\t\tif (x <= mid && lc->cnt == 0) delete lc, lc = NULL;\n\t\t\telse if (x > mid && rc->cnt == 0) delete rc, rc = NULL;\n\t\t}\n\t}\n\n\tint prec(const int x) {\n\t\treturn queryMax(0, x - 1);\n\t}\n\n\tint succ(const int x) {\n\t\treturn queryMin(x + 1, ::max);\n\t}\n\n\tint rank(const int x) {\n\t\treturn queryCnt(0, x - 1) + 1;\n\t}\n\n\tint select(const int k) {\n\t\tint x = k;\n\t\tWeightSegmentTree *v = this;\n\t\twhile (v->l != v->r) {\n\t\t\tif (!v->lc) v = v->rc;\n\t\t\telse if (x <= v->lc->cnt) v = v->lc;\n\t\t\telse x -= v->lc->cnt, v = v->rc;\n\t\t}\n\t\treturn v->mid;\n\t}\n\n\tint queryMin(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return min;\n\t\telse {\n\t\t\tint res = INT_MAX;\n\t\t\tif (lc) res = lc->queryMin(l, r);\n\t\t\tif (res == INT_MAX && rc) return rc->queryMin(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse {\n\t\t\tint res = INT_MIN;\n\t\t\tif (rc) res = rc->queryMax(l, r);\n\t\t\tif (res == INT_MIN && lc) return lc->queryMax(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryCnt(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tif (lc) res += lc->queryCnt(l, r);\n\t\t\tif (rc) res += rc->queryCnt(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tWeightSegmentTree s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-3196","published":1,"updated":"2017-01-02T07:05:01.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9seb01h1ooxlnh5z10y5"},{"title":"BZOJ 3156 -  DP","date":"2016-05-19T03:58:00.000Z","_content":"\n $ n $  $ n $  $ 1 $  $ n $ $ i $  $ c(i) $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 3156](http://www.lydsy.com/JudgeOnline/problem.php?id=3156)\n\n### \n****\n\n $ f(i) $  $ i $  $ j $ $ j + 1 $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + \\frac{(i - j - 1)(i - j)}{2} \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + \\frac{(i - a - 1)(i - a)}{2} &< f(b) + c(b + 1) + \\frac{(i - b - 1)(i - b)}{2} \\\\\nf(a) + c(a + 1) + \\frac{i ^ 2}{2} + \\frac{a ^ 2}{2} - ia - \\frac{i}{2} + \\frac{a}{2} &< f(b) + c(b + 1) + \\frac{i ^ 2}{2} + \\frac{b ^ 2}{2} - ib - \\frac{i}{2} + \\frac{b}{2} \\\\\n{ (f(a) + c(a + 1) + \\frac{a ^ 2}{2} + \\frac{a}{2}) - (f(b) + c(b + 1) + \\frac{b ^ 2}{2} + \\frac{b}{2}) \\over a - b } &< i \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long c[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n\tstd::reverse(c + 1, c + n + 1);\n}\n\n/*\ninline void force() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _j = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (f[i] > f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) {\n\t\t\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t\t\t_j = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d --> %d\\n\", i, _j);\n\t}\n}\n*/\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast<long long>(i)) * 0.5 + i * 0.5; }\n\ninline double slope(const int a, const int b) {\n\treturn double(x(a) - x(b))\n\t\t / double(a - b);\n}\n\ninline void dp() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\n\tstatic int q[MAXN];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (l < r && slope(*(l + 1), *l) < i) l++;\n\n\t\tint &j = *l;\n\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t// printf(\"%d --> %d\\n\", i, j);\n\n\t\tif (i < n) {\n\t\t\twhile (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n\t\t\t*++r = i;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\n\tprepare();\n\n\t// force();\n\tdp();\n\tprintf(\"%lld\\n\", f[n]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3156.md","raw":"title: BZOJ 3156 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - \n  - \npermalink: bzoj-3156\ndate: 2016-05-19 11:58:00\n---\n\n $ n $  $ n $  $ 1 $  $ n $ $ i $  $ c(i) $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 3156](http://www.lydsy.com/JudgeOnline/problem.php?id=3156)\n\n### \n****\n\n $ f(i) $  $ i $  $ j $ $ j + 1 $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + \\frac{(i - j - 1)(i - j)}{2} \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + \\frac{(i - a - 1)(i - a)}{2} &< f(b) + c(b + 1) + \\frac{(i - b - 1)(i - b)}{2} \\\\\nf(a) + c(a + 1) + \\frac{i ^ 2}{2} + \\frac{a ^ 2}{2} - ia - \\frac{i}{2} + \\frac{a}{2} &< f(b) + c(b + 1) + \\frac{i ^ 2}{2} + \\frac{b ^ 2}{2} - ib - \\frac{i}{2} + \\frac{b}{2} \\\\\n{ (f(a) + c(a + 1) + \\frac{a ^ 2}{2} + \\frac{a}{2}) - (f(b) + c(b + 1) + \\frac{b ^ 2}{2} + \\frac{b}{2}) \\over a - b } &< i \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long c[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n\tstd::reverse(c + 1, c + n + 1);\n}\n\n/*\ninline void force() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _j = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (f[i] > f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) {\n\t\t\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t\t\t_j = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d --> %d\\n\", i, _j);\n\t}\n}\n*/\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast<long long>(i)) * 0.5 + i * 0.5; }\n\ninline double slope(const int a, const int b) {\n\treturn double(x(a) - x(b))\n\t\t / double(a - b);\n}\n\ninline void dp() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\n\tstatic int q[MAXN];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (l < r && slope(*(l + 1), *l) < i) l++;\n\n\t\tint &j = *l;\n\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t// printf(\"%d --> %d\\n\", i, j);\n\n\t\tif (i < n) {\n\t\t\twhile (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n\t\t\t*++r = i;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\n\tprepare();\n\n\t// force();\n\tdp();\n\tprintf(\"%lld\\n\", f[n]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3156","published":1,"updated":"2016-10-24T23:33:42.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sel01h9ooxlbob18bs1"},{"title":"BZOJ 2820YYGCD - ","date":"2016-04-07T14:24:12.000Z","_content":"\n $ 1 \\leq x \\leq N $$ 1 \\leq y \\leq M $  $ \\gcd(x, y) $  $ (x, y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### \n $ N \\leq M $  $ M \\lt N $  $ N $  $ M $ \n\n $ N $  $ p_1, p_2, , p_n $\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n $ T = p_k \\times d $\t $ T $  $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n $ \\mu $  $ T' \\ {\\rm mod} \\ p_1 = 0 $ \n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n $ x_1 \\gt 1 $ \n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2820.md","raw":"title: BZOJ 2820YYGCD - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - \npermalink: bzoj-2820\ndate: 2016-04-07 22:24:12\n---\n\n $ 1 \\leq x \\leq N $$ 1 \\leq y \\leq M $  $ \\gcd(x, y) $  $ (x, y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### \n $ N \\leq M $  $ M \\lt N $  $ N $  $ M $ \n\n $ N $  $ p_1, p_2, , p_n $\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n $ T = p_k \\times d $\t $ T $  $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n $ \\mu $  $ T' \\ {\\rm mod} \\ p_1 = 0 $ \n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n $ x_1 \\gt 1 $ \n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2820","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9ses01hfooxlfbrle23q"},{"title":"BZOJ 2716 - CDQ","date":"2016-06-25T03:08:00.000Z","_content":"\n\n\n1.  $ (x,\\ y) $\n2. **** $ (x,\\ y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2716](http://www.lydsy.com/JudgeOnline/problem.php?id=2716)\n\n### \n $ (x_1,\\ y_1) $$ (x_2,\\ y_2) $  $ | x_1 - x_2 | + | y_1 - y_2 | $\n\n $ (x_1,\\ y_1) $  $ (x_2,\\ y_2) $ \n\n$$\n\\begin{aligned}\n & | x_1 - x_2 | + | y_1 - y_2 | \\\\\n=& ( x_1 - x_2 ) + ( y_1 - y_2 ) \\\\\n=& ( x_1 + y_1 ) - (x_2 + y_2)\n\\end{aligned}\n$$\n\n $ (x_2 + y_2) $  CDQ  CDQ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 1000000;\n\nstruct Triple {\n\tint id, x, y, *ans;\n\n\tTriple() {}\n\n\tTriple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) {\n\t\tstatic int i = 0;\n\t\tid = i++;\n\t}\n} a[MAXN + MAXM];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.id < b.id;\n}\n\nint maxX, maxY;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int v) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v);\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, q->x + q->y);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) {\n\t\t\t\tint res = bit.query(q->y);\n\t\t\t\tif (res) *q->ans = std::min(*q->ans, q->x + q->y - res);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; p++, q++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\\n\", &x, &y), x += 2, y += 2;\n\t\ta[cnt++] = Triple(x, y);\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint qCnt = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d %d %d\", &t, &x, &y), x += 2, y += 2;\n\t\tif (t == 1) {\n\t\t\ta[cnt++] = Triple(x, y);\n\t\t} else {\n\t\t\ta[cnt++] = Triple(x, y, &ans[qCnt++]);\n\t\t}\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tfor (int i = 0; i < qCnt; i++) ans[i] = INT_MAX;\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].y = maxY - a[i].y + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qCnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2716.md","raw":"title: BZOJ 2716 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - \n  - CDQ\n  - \n  - \npermalink: bzoj-2716\ndate: 2016-06-25 11:08:00\n---\n\n\n\n1.  $ (x,\\ y) $\n2. **** $ (x,\\ y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2716](http://www.lydsy.com/JudgeOnline/problem.php?id=2716)\n\n### \n $ (x_1,\\ y_1) $$ (x_2,\\ y_2) $  $ | x_1 - x_2 | + | y_1 - y_2 | $\n\n $ (x_1,\\ y_1) $  $ (x_2,\\ y_2) $ \n\n$$\n\\begin{aligned}\n & | x_1 - x_2 | + | y_1 - y_2 | \\\\\n=& ( x_1 - x_2 ) + ( y_1 - y_2 ) \\\\\n=& ( x_1 + y_1 ) - (x_2 + y_2)\n\\end{aligned}\n$$\n\n $ (x_2 + y_2) $  CDQ  CDQ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 1000000;\n\nstruct Triple {\n\tint id, x, y, *ans;\n\n\tTriple() {}\n\n\tTriple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) {\n\t\tstatic int i = 0;\n\t\tid = i++;\n\t}\n} a[MAXN + MAXM];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.id < b.id;\n}\n\nint maxX, maxY;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int v) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v);\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, q->x + q->y);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) {\n\t\t\t\tint res = bit.query(q->y);\n\t\t\t\tif (res) *q->ans = std::min(*q->ans, q->x + q->y - res);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; p++, q++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\\n\", &x, &y), x += 2, y += 2;\n\t\ta[cnt++] = Triple(x, y);\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint qCnt = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d %d %d\", &t, &x, &y), x += 2, y += 2;\n\t\tif (t == 1) {\n\t\t\ta[cnt++] = Triple(x, y);\n\t\t} else {\n\t\t\ta[cnt++] = Triple(x, y, &ans[qCnt++]);\n\t\t}\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tfor (int i = 0; i < qCnt; i++) ans[i] = INT_MAX;\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].y = maxY - a[i].y + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qCnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2716","published":1,"updated":"2016-06-25T03:08:50.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sez01hmooxlc2dlr6n3"},{"title":"BZOJ 2683 - CDQ","id":"43","updated":"2016-02-05T14:46:27.000Z","date":"2016-02-05T14:42:35.000Z","_content":"\n$N*N$ 0\n\n1. $(x,y)$$A$\n2. $(x1,y1)(x2,y2)$\n\n<!-- more -->\n\n### \n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2683.md","raw":"title: BZOJ 2683 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-2683\nid: 43\nupdated: '2016-02-05 22:46:27'\ndate: 2016-02-05 22:42:35\n---\n\n$N*N$ 0\n\n1. $(x,y)$$A$\n2. $(x1,y1)(x2,y2)$\n\n<!-- more -->\n\n### \n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2683","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sf701htooxlxaoc9nf8"},{"title":"BZOJ 2580Video Game - AC ","date":"2016-09-17T23:16:00.000Z","_content":"\n $ n $  $ s_i $ $ k $  $ S $ $ S $  $ s_i $\n\n<!-- more -->\n\n### \n[BZOJ 2580](http://www.lydsy.com/JudgeOnline/problem.php?id=2580)\n\n### \n $ f(i, j) $  $ k - i $  AC  $ j $  $ i $ \n\n $ + $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 15;\nconst int MAXM = 20;\nconst int MAXK = 1000;\nconst int CHARSET_SIZE = 26;\nconst int BASE_CHAR = 'A';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint wordCnt, id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tv->id = vec.size();\n#ifdef DBG\n\t\t\tprintf(\"wordCnt(%d) = %d\\n\", v->id, v->wordCnt);\n#endif\n\t\t\tvec.push_back(v);\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tc->wordCnt = c->isWord + (c->next ? c->next->wordCnt : 0);\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\twhile (n--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tstd::vector<Trie::Node *> vec;\n\tt.build(vec);\n\n\tstatic int f[MAXN * MAXM + 1][MAXK + 1];\n#ifdef DBG\n\tstatic char g[MAXN * MAXM + 1][MAXK + 1];\n#endif\n\t// for (size_t i = 0; i < vec.size(); i++) f[i][0] = vec[i]->wordCnt;\n\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tint t = f[vec[j]->c[k]->id][i - 1] + vec[j]->c[k]->wordCnt;\n\t\t\t\tif (t >= f[j][i]) {\n\t\t\t\t\tf[j][i] = t;\n#ifdef DBG\n\t\t\t\t\tg[j][i] = k;\n#endif\n\t\t\t\t}\n\t\t\t}\n#ifdef DBG\n\t\t\tprintf(\"f(%lu, %d) = %d\\n\", j, i, f[j][i]);\n#endif\n\t\t}\n\t}\n\n#ifdef DBG\n\tint last = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tputchar(g[last][i] + 'A');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n\tputchar('\\n');\n\n\tlast = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tprintf(\"%d%c\", last, i == 1 ? '\\n' : ' ');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n#endif\n\n\tprintf(\"%d\\n\", f[0][k]);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2580.md","raw":"title: BZOJ 2580Video Game - AC \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - AC \n  - DP\npermalink: bzoj-2580\ndate: 2016-09-18 07:16:00\n---\n\n $ n $  $ s_i $ $ k $  $ S $ $ S $  $ s_i $\n\n<!-- more -->\n\n### \n[BZOJ 2580](http://www.lydsy.com/JudgeOnline/problem.php?id=2580)\n\n### \n $ f(i, j) $  $ k - i $  AC  $ j $  $ i $ \n\n $ + $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 15;\nconst int MAXM = 20;\nconst int MAXK = 1000;\nconst int CHARSET_SIZE = 26;\nconst int BASE_CHAR = 'A';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint wordCnt, id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tv->id = vec.size();\n#ifdef DBG\n\t\t\tprintf(\"wordCnt(%d) = %d\\n\", v->id, v->wordCnt);\n#endif\n\t\t\tvec.push_back(v);\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tc->wordCnt = c->isWord + (c->next ? c->next->wordCnt : 0);\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\twhile (n--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tstd::vector<Trie::Node *> vec;\n\tt.build(vec);\n\n\tstatic int f[MAXN * MAXM + 1][MAXK + 1];\n#ifdef DBG\n\tstatic char g[MAXN * MAXM + 1][MAXK + 1];\n#endif\n\t// for (size_t i = 0; i < vec.size(); i++) f[i][0] = vec[i]->wordCnt;\n\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tint t = f[vec[j]->c[k]->id][i - 1] + vec[j]->c[k]->wordCnt;\n\t\t\t\tif (t >= f[j][i]) {\n\t\t\t\t\tf[j][i] = t;\n#ifdef DBG\n\t\t\t\t\tg[j][i] = k;\n#endif\n\t\t\t\t}\n\t\t\t}\n#ifdef DBG\n\t\t\tprintf(\"f(%lu, %d) = %d\\n\", j, i, f[j][i]);\n#endif\n\t\t}\n\t}\n\n#ifdef DBG\n\tint last = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tputchar(g[last][i] + 'A');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n\tputchar('\\n');\n\n\tlast = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tprintf(\"%d%c\", last, i == 1 ? '\\n' : ' ');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n#endif\n\n\tprintf(\"%d\\n\", f[0][k]);\n\n\treturn 0;\n}\n```","slug":"bzoj-2580","published":1,"updated":"2016-09-17T23:25:45.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sfg01i0ooxlihy27wv6"},{"title":"BZOJ 2565 - Manacher","date":"2017-01-02T08:29:00.000Z","_content":"\n $ S $ $ S $  $ T $ $ T $  $ X $$ Y $$ |X|, |Y| \\geq 1 $ $ X $  $ Y $ \n\n<!-- more -->\n\n### \n[BZOJ 2565](http://www.lydsy.com/JudgeOnline/problem.php?id=2565)\n\n### \n Manacher  $ r(i) $\n\n $ \\mathrm{right}(i) $  $ i $ $ \\mathrm{left}(i) $  $ i $  $ r(i) $\n\n $ \\mathrm{right}(i) $  $ \\mathrm{left}(i) $  $ \\mathrm{right}(i) $  $ \\mathrm{right}(i + 1) - 1 $ $ \\mathrm{left}(i) $  $ \\mathrm{right}(i) $  $ \\mathrm{left}(i) $ \n\n `#`\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\n\nchar s1[MAXN + 2], s2[MAXN * 2 + 2];\nint n, len, r[MAXN * 2 + 2];\n\ninline void prepare() {\n\tn = strlen(s1 + 1);\n\n\ts2[++len] = '@';\n\ts2[++len] = '#';\n\tfor (int i = 1; i <= n; i++) {\n\t\ts2[++len] = s1[i];\n\t\ts2[++len] = '#';\n\t}\n\n\ts2[++len] = '\\0';\n}\n\ninline void manacher() {\n\tint right = 0, pos = -1;\n\tfor (int i = 1; i <= len; i++) {\n\t\tint x;\n\n\t\tif (right < i) x = 1;\n\t\telse x = std::min(r[2 * pos - i], right - i);\n\n\t\twhile (s2[i - x] == s2[i + x]) x++;\n\n\t\tif (x + i > right) {\n\t\t\tright = x + i;\n\t\t\tpos = i;\n\t\t}\n\n\t\tr[i] = x;\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s1 + 1);\n\n\tprepare();\n\tmanacher();\n\n\t// puts(s2 + 1);\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", r[i], i == len ? '\\n' : ' ');\n\t// for (int i = 1; i <= len; i++) printf(\"%c%c\", s2[i], i == len ? '\\n' : ' ');\n\n\tstatic int right[MAXN * 2 + 2], left[MAXN * 2 + 2];\n\tfor (int i = 1; i <= len; i++) {\n\t\tif (i + r[i] - 1 <= len) right[i + r[i] - 1] = std::max(right[i + r[i] - 1], r[i] - 1);\n\t\tif (i - r[i] + 1 >= 0) left[i - r[i] + 1] = std::max(left[i - r[i] + 1], r[i] - 1);\n\t}\n\n\tfor (int i = 2; i <= len; i++) {\n\t\tleft[i] = std::max(left[i], left[i - 1] - 1);\n\t\t// if (s2[i - 1 - right[i - 1]] == s2[i + 1]) right[i] = std::max(right[i], right[i - 1] + 1);\n\t}\n\n\tfor (int i = len - 1; i >= 1; i--) {\n\t\tright[i] = std::max(right[i], right[i + 1] - 1);\n\t\t// if (s2[i + 1 + left[i + 1]] == s2[i - 1]) left[i] = std::max(left[i], left[i + 1] + 1);\n\t}\n\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", right[i], i == len ? '\\n' : ' ');\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", left[i], i == len ? '\\n' : ' ');\n\n\tint ans = 0;\n\tfor (int i = 1; i <= len; i++) {\n\t\tif (s2[i] == '#') {\n\t\t\tans = std::max(ans, right[i] + left[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2565.md","raw":"title: BZOJ 2565 - Manacher\ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Manacher\npermalink: bzoj-2565\ndate: 2017-01-02 16:29:00\n---\n\n $ S $ $ S $  $ T $ $ T $  $ X $$ Y $$ |X|, |Y| \\geq 1 $ $ X $  $ Y $ \n\n<!-- more -->\n\n### \n[BZOJ 2565](http://www.lydsy.com/JudgeOnline/problem.php?id=2565)\n\n### \n Manacher  $ r(i) $\n\n $ \\mathrm{right}(i) $  $ i $ $ \\mathrm{left}(i) $  $ i $  $ r(i) $\n\n $ \\mathrm{right}(i) $  $ \\mathrm{left}(i) $  $ \\mathrm{right}(i) $  $ \\mathrm{right}(i + 1) - 1 $ $ \\mathrm{left}(i) $  $ \\mathrm{right}(i) $  $ \\mathrm{left}(i) $ \n\n `#`\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\n\nchar s1[MAXN + 2], s2[MAXN * 2 + 2];\nint n, len, r[MAXN * 2 + 2];\n\ninline void prepare() {\n\tn = strlen(s1 + 1);\n\n\ts2[++len] = '@';\n\ts2[++len] = '#';\n\tfor (int i = 1; i <= n; i++) {\n\t\ts2[++len] = s1[i];\n\t\ts2[++len] = '#';\n\t}\n\n\ts2[++len] = '\\0';\n}\n\ninline void manacher() {\n\tint right = 0, pos = -1;\n\tfor (int i = 1; i <= len; i++) {\n\t\tint x;\n\n\t\tif (right < i) x = 1;\n\t\telse x = std::min(r[2 * pos - i], right - i);\n\n\t\twhile (s2[i - x] == s2[i + x]) x++;\n\n\t\tif (x + i > right) {\n\t\t\tright = x + i;\n\t\t\tpos = i;\n\t\t}\n\n\t\tr[i] = x;\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s1 + 1);\n\n\tprepare();\n\tmanacher();\n\n\t// puts(s2 + 1);\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", r[i], i == len ? '\\n' : ' ');\n\t// for (int i = 1; i <= len; i++) printf(\"%c%c\", s2[i], i == len ? '\\n' : ' ');\n\n\tstatic int right[MAXN * 2 + 2], left[MAXN * 2 + 2];\n\tfor (int i = 1; i <= len; i++) {\n\t\tif (i + r[i] - 1 <= len) right[i + r[i] - 1] = std::max(right[i + r[i] - 1], r[i] - 1);\n\t\tif (i - r[i] + 1 >= 0) left[i - r[i] + 1] = std::max(left[i - r[i] + 1], r[i] - 1);\n\t}\n\n\tfor (int i = 2; i <= len; i++) {\n\t\tleft[i] = std::max(left[i], left[i - 1] - 1);\n\t\t// if (s2[i - 1 - right[i - 1]] == s2[i + 1]) right[i] = std::max(right[i], right[i - 1] + 1);\n\t}\n\n\tfor (int i = len - 1; i >= 1; i--) {\n\t\tright[i] = std::max(right[i], right[i + 1] - 1);\n\t\t// if (s2[i + 1 + left[i + 1]] == s2[i - 1]) left[i] = std::max(left[i], left[i + 1] + 1);\n\t}\n\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", right[i], i == len ? '\\n' : ' ');\n\t// for (int i = 1; i <= len; i++) printf(\"%d%c\", left[i], i == len ? '\\n' : ' ');\n\n\tint ans = 0;\n\tfor (int i = 1; i <= len; i++) {\n\t\tif (s2[i] == '#') {\n\t\t\tans = std::max(ans, right[i] + left[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"bzoj-2565","published":1,"updated":"2017-01-02T08:30:04.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sfo01i7ooxlz6m9wk11"},{"title":"BeiJing2011 - AC ","date":"2016-09-13T23:32:00.000Z","_content":"\n $ M $  $ N $  01  $ Q $  $ A $  $ B $  01  $ Q $  \n\n<!-- more -->\n\n### \n[BZOJ 2462](http://www.lydsy.com/JudgeOnline/problem.php?id=2462)\n\n### \n AC  $ i $  $ j $  $ k $  $ (i - k, j - b + 1) $  $ 1 $ \n\n $ \\geq b $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint id;\n\n\t\tNode(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply(std::vector< std::pair<int, int> > &vec, const int pos) {\n\t\t\tassert(isWord);\n\t\t\tvec.push_back(std::make_pair(pos, id));\n\t\t\tif (next) next->apply(vec, pos);\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\ttemplate <typename T>\n\tvoid insert(const T *begin, const T *end, const int id) {\n\t\tNode **v = &root;\n\t\tfor (const T *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, id);\n\t\telse (*v)->id = id, (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const bool *begin, const bool *end, std::vector< std::pair<int, int> > &vec) {\n\t\tNode *v = root;\n\t\tfor (const bool *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply(vec, p - begin);\n\t\t\telse if (v->next) v->next->apply(vec, p - begin);\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\troot = NULL;\n\t}\n} t;\n\nint main() {\n\tint n, m, a, b;\n\tscanf(\"%d %d %d %d\", &n, &m, &a, &b);\n\n\tstatic bool matrix[MAXN][MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < m; j++) matrix[i][j] = s[j] - BASE_CHAR;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tt.clear();\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tstatic char s[MAXN + 1];\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor (int j = 0; j < b; j++) s[j] -= BASE_CHAR;\n\t\t\tt.insert(s, s + b, i);\n\t\t}\n\n\t\tt.build();\n\n\t\tstatic int matchCnt[MAXN][MAXN];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::vector< std::pair<int, int> > vec;\n\t\t\tt.exec(matrix[i], matrix[i] + m, vec);\n\t\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n \t\t\t\t// printf(\"%d matched %d\\n\", i, *it);\n\t\t\t\tif (i - it->second >= 0) matchCnt[i - it->second][it->first - b + 1]++;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// printf(\"match(%d) = %d\\n\", i, matchCnt[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (matchCnt[i][j] >= b) flag = true;\n\t\t\t\tmatchCnt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(flag ? \"1\" : \"0\");\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2462.md","raw":"title: BeiJing2011 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - AC \npermalink: bzoj-2462\ndate: 2016-09-14 07:32:00\n---\n\n $ M $  $ N $  01  $ Q $  $ A $  $ B $  01  $ Q $  \n\n<!-- more -->\n\n### \n[BZOJ 2462](http://www.lydsy.com/JudgeOnline/problem.php?id=2462)\n\n### \n AC  $ i $  $ j $  $ k $  $ (i - k, j - b + 1) $  $ 1 $ \n\n $ \\geq b $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint id;\n\n\t\tNode(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply(std::vector< std::pair<int, int> > &vec, const int pos) {\n\t\t\tassert(isWord);\n\t\t\tvec.push_back(std::make_pair(pos, id));\n\t\t\tif (next) next->apply(vec, pos);\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\ttemplate <typename T>\n\tvoid insert(const T *begin, const T *end, const int id) {\n\t\tNode **v = &root;\n\t\tfor (const T *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, id);\n\t\telse (*v)->id = id, (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const bool *begin, const bool *end, std::vector< std::pair<int, int> > &vec) {\n\t\tNode *v = root;\n\t\tfor (const bool *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply(vec, p - begin);\n\t\t\telse if (v->next) v->next->apply(vec, p - begin);\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\troot = NULL;\n\t}\n} t;\n\nint main() {\n\tint n, m, a, b;\n\tscanf(\"%d %d %d %d\", &n, &m, &a, &b);\n\n\tstatic bool matrix[MAXN][MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < m; j++) matrix[i][j] = s[j] - BASE_CHAR;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tt.clear();\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tstatic char s[MAXN + 1];\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor (int j = 0; j < b; j++) s[j] -= BASE_CHAR;\n\t\t\tt.insert(s, s + b, i);\n\t\t}\n\n\t\tt.build();\n\n\t\tstatic int matchCnt[MAXN][MAXN];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::vector< std::pair<int, int> > vec;\n\t\t\tt.exec(matrix[i], matrix[i] + m, vec);\n\t\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n \t\t\t\t// printf(\"%d matched %d\\n\", i, *it);\n\t\t\t\tif (i - it->second >= 0) matchCnt[i - it->second][it->first - b + 1]++;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// printf(\"match(%d) = %d\\n\", i, matchCnt[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (matchCnt[i][j] >= b) flag = true;\n\t\t\t\tmatchCnt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(flag ? \"1\" : \"0\");\n\t}\n\n\treturn 0;\n}\n```","slug":"bzoj-2462","published":1,"updated":"2016-09-13T23:41:03.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sfu01icooxl6b4q2hml"},{"title":"BZOJ 2456mode - ","date":"2016-06-17T14:07:00.000Z","_content":"\n $ n $  $ n \\over 2 $ \n\n<!-- more -->\n\n### \n[BZOJ 2456](http://www.lydsy.com/JudgeOnline/problem.php?id=2456)\n\n### \n$ 500,000 $ $ \\text {1M} $  $ O(1) $ \n\n $ n \\over 2 $ \n\n $ 0 $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 500000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = -1, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (cnt == 0) {\n\t\t\tans = x;\n\t\t\tcnt = 1;\n\t\t} else {\n\t\t\tif (ans == x) {\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2456.md","raw":"title: BZOJ 2456mode - \ncategories: OI\ntags: \n  - BZOJ\n  - \npermalink: bzoj-2456\ndate: 2016-06-17 22:07:00\n---\n\n $ n $  $ n \\over 2 $ \n\n<!-- more -->\n\n### \n[BZOJ 2456](http://www.lydsy.com/JudgeOnline/problem.php?id=2456)\n\n### \n$ 500,000 $ $ \\text {1M} $  $ O(1) $ \n\n $ n \\over 2 $ \n\n $ 0 $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 500000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = -1, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (cnt == 0) {\n\t\t\tans = x;\n\t\t\tcnt = 1;\n\t\t} else {\n\t\t\tif (ans == x) {\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2456","published":1,"updated":"2016-06-17T14:08:31.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sg201ihooxlf6fgnhkg"},{"title":"BZOJ 2442 -  DP + ","id":"24","updated":"2016-01-19T13:03:11.000Z","date":"2016-01-16T14:32:47.000Z","_content":"\nFJ  `N`$1  N  100,000$ `1`  `N` `i` $E_i$$0  E_i  1,000,000,000$\n\n FJ  `K`  FJ  FJ  `K` \n\n<!-- more -->\n\n### \n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### \n $O(n^2)$  DP $a[i]$  `i` $f[i]$  `i`  `j`$i-k  j < i$ `j` \n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n\n\n$$ f[1]=a[1] $$\n\n $O(n)$ \n\n `-1`\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n DP\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n $f[i-1]$\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n `k + 1`  $g(j)$ $O(1)$ \n\n\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n\n\n1. $E_i$ `int` `long long` \n2. \n\n~~~~\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2442.md","raw":"title: BZOJ 2442 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - USACO\n  - DP\n  - \n  -  DP\npermalink: bzoj-2442\nid: 24\nupdated: '2016-01-19 21:03:11'\ndate: 2016-01-16 22:32:47\n---\n\nFJ  `N`$1  N  100,000$ `1`  `N` `i` $E_i$$0  E_i  1,000,000,000$\n\n FJ  `K`  FJ  FJ  `K` \n\n<!-- more -->\n\n### \n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### \n $O(n^2)$  DP $a[i]$  `i` $f[i]$  `i`  `j`$i-k  j < i$ `j` \n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n\n\n$$ f[1]=a[1] $$\n\n $O(n)$ \n\n `-1`\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n DP\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n $f[i-1]$\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n `k + 1`  $g(j)$ $O(1)$ \n\n\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n\n\n1. $E_i$ `int` `long long` \n2. \n\n~~~~\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2442","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sg701ilooxlvxbywlgz"},{"title":"BZOJ 2438 - ","date":"2016-06-25T08:31:00.000Z","_content":"\n $ N $ \n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2438](http://www.lydsy.com/JudgeOnline/problem.php?id=2438)\n\n### \n\n\n\n\n\n\n $ 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *e, *in, *c;\n\tbool visited, pushed, inStack;\n\tint dfn, low, inDegree;\n\tSCC *scc;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint s;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, m;\n\ninline int tarjan() {\n\tint time = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->dfn = v->low = time++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tif (v->c->t->inStack) v->low = std::min(v->low, v->c->t->dfn);\n\t\t\t\telse if (v->c->t->pushed == false) s.push(v->c->t), v->c->t->pushed = true, v->c->t->in = v->c;\n\t\t\t\tv->c = v->c->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = scc;\n\t\t\t\t\t\tu->scc->s++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->in) v->in->s->low = std::min(v->in->s->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tif (e->s->scc != e->t->scc) {\n\t\t\t\te->s->scc->v.e = new Edge(&e->s->scc->v, &e->t->scc->v);\n\t\t\t\te->t->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t), s--, t--;\n\t\taddEdge(s, t);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint k = 0;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0) k++;\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0 && S[i].s == 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (Edge *e = S[i].v.e; e; e = e->next) {\n\t\t\t\tif (e->t->inDegree <= 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tk--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", static_cast<double>(n - k) / n);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2438.md","raw":"title: BZOJ 2438 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Tarjan\n  - \npermalink: bzoj-2438\ndate: 2016-06-25 16:31:00\n---\n\n $ N $ \n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2438](http://www.lydsy.com/JudgeOnline/problem.php?id=2438)\n\n### \n\n\n\n\n\n\n $ 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *e, *in, *c;\n\tbool visited, pushed, inStack;\n\tint dfn, low, inDegree;\n\tSCC *scc;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint s;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, m;\n\ninline int tarjan() {\n\tint time = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->dfn = v->low = time++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tif (v->c->t->inStack) v->low = std::min(v->low, v->c->t->dfn);\n\t\t\t\telse if (v->c->t->pushed == false) s.push(v->c->t), v->c->t->pushed = true, v->c->t->in = v->c;\n\t\t\t\tv->c = v->c->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = scc;\n\t\t\t\t\t\tu->scc->s++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->in) v->in->s->low = std::min(v->in->s->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tif (e->s->scc != e->t->scc) {\n\t\t\t\te->s->scc->v.e = new Edge(&e->s->scc->v, &e->t->scc->v);\n\t\t\t\te->t->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t), s--, t--;\n\t\taddEdge(s, t);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint k = 0;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0) k++;\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0 && S[i].s == 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (Edge *e = S[i].v.e; e; e = e->next) {\n\t\t\t\tif (e->t->inDegree <= 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tk--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", static_cast<double>(n - k) / n);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2438","published":1,"updated":"2016-06-25T08:31:49.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sgh01itooxl4uq404pe"},{"title":"BZOJ 2296 - ","date":"2016-04-01T14:59:45.000Z","_content":"\n $ x $$ 0 \\leq x \\leq 10 ^ 6 $ $ n $ \n\n1. $ n $  0 ~ 9 \n2. $ n ~ {\\rm mod} ~ x = 0 $\n3. $ 0 \\leq n \\leq 10 ^ {16} $\n\n<!-- more -->\n\n### \n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### \n 1 n  10  $ 9876543210 $ 6 \n\n $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $ $ 9876543210 $  $ d $ $ n = 9876543210 \\times 10 ^ 6 + x - d $ \n\n 0 \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2296.md","raw":"title: BZOJ 2296 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-2296\ndate: 2016-04-01 22:59:45\n---\n\n $ x $$ 0 \\leq x \\leq 10 ^ 6 $ $ n $ \n\n1. $ n $  0 ~ 9 \n2. $ n ~ {\\rm mod} ~ x = 0 $\n3. $ 0 \\leq n \\leq 10 ^ {16} $\n\n<!-- more -->\n\n### \n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### \n 1 n  10  $ 9876543210 $ 6 \n\n $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $ $ 9876543210 $  $ d $ $ n = 9876543210 \\times 10 ^ 6 + x - d $ \n\n 0 \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2296","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sgo01izooxlvy5gpnck"},{"title":"BZOJ 2194 - FFT","date":"2016-06-10T01:32:00.000Z","_content":"\n $ n $  $ A $$ B $ $ n $  $ C $ $ C_k = \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} $\n\n<!-- more -->\n\n### \n[BZOJ 2194](http://www.lydsy.com/JudgeOnline/problem.php?id=2194)\n\n### \n $ A $  $ A' $\n\n$$\n\\begin{align*}\nC_k &= \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} \\\\\n&= \\sum\\limits_{i = k} ^ {n - 1} A'_{n - i - 1} \\times B_{i - k}\n\\end{align*}\n$$\n\n $ i $  $ 0 $ \n\n$$\nC_k = \\sum\\limits_{i = 0} ^ {n - k - 1} A'_{n - k - 1 - i} \\times B_{i}\n$$\n\n\n\n$$ c_t = \\sum\\limits_{i = 0} ^ {t} a_{t - i} b_{i} $$\n\n $ t = n - k - 1 $\n\n$$\nC_{n - t - 1} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ C $  $ C' $\n\n$$\nC'_{t} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ A' $  $ B $  $ C' $ $ n $  $ C $\n\n FFT $ O(n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n\nconst int MAXN = 131072 * 2;\nconst double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << (k - j - 1))) t |= (1 << j);\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid operator()(const int *a, const int n1, const int *b, const int n2, int *c) {\n\t\tfor (int k = 0; k < n1 + n2; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tc[k] += a[i] * b[k - i];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\n\t\tstatic std::complex<double> ca[MAXN], cb[MAXN];\n\n\t\tint n = 1;\n\t\twhile (n < (n1 + n2)) n *= 2;\n\n\t\tfor (int i = 0; i < n; i++) ca[i] = std::complex<double>(i < n1 ? a[i] : 0, 0);\n\t\tfor (int i = 0; i < n; i++) cb[i] = std::complex<double>(i < n2 ? b[i] : 0, 0);\n\n\t\tinit(n);\n\t\tdft(ca, n);\n\t\tdft(cb, n);\n\n\t\tfor (int i = 0; i < n; i++) ca[i] *= cb[i];\n\n\t\tidft(ca, n);\n\n\t\tfor (int i = 0; i < n; i++) c[i] = static_cast<int>(floor(ca[i].real() + 0.5));\n\t}\n} fft;\n\ninline void force(const int *a, const int *b, int *c, const int n) {\n\t/*\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tc[k] += a[n - i - 1] * b[i - k];\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n - k; i++) {\n\t\t\tc[k] += a[n - k - 1 - i] * b[i];\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN], c[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[n - i - 1], &b[i]);\n\n\t// force(a, b, c, n);\n\tfft(a, n, b, n, c);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", c[n - i - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2194.md","raw":"title: BZOJ 2194 - FFT\ncategories: OI\ntags: \n  - BZOJ\n  - \n  - FFT\npermalink: bzoj-2194\ndate: 2016-06-10 09:32:00\n---\n\n $ n $  $ A $$ B $ $ n $  $ C $ $ C_k = \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} $\n\n<!-- more -->\n\n### \n[BZOJ 2194](http://www.lydsy.com/JudgeOnline/problem.php?id=2194)\n\n### \n $ A $  $ A' $\n\n$$\n\\begin{align*}\nC_k &= \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} \\\\\n&= \\sum\\limits_{i = k} ^ {n - 1} A'_{n - i - 1} \\times B_{i - k}\n\\end{align*}\n$$\n\n $ i $  $ 0 $ \n\n$$\nC_k = \\sum\\limits_{i = 0} ^ {n - k - 1} A'_{n - k - 1 - i} \\times B_{i}\n$$\n\n\n\n$$ c_t = \\sum\\limits_{i = 0} ^ {t} a_{t - i} b_{i} $$\n\n $ t = n - k - 1 $\n\n$$\nC_{n - t - 1} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ C $  $ C' $\n\n$$\nC'_{t} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ A' $  $ B $  $ C' $ $ n $  $ C $\n\n FFT $ O(n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n\nconst int MAXN = 131072 * 2;\nconst double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << (k - j - 1))) t |= (1 << j);\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid operator()(const int *a, const int n1, const int *b, const int n2, int *c) {\n\t\tfor (int k = 0; k < n1 + n2; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tc[k] += a[i] * b[k - i];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\n\t\tstatic std::complex<double> ca[MAXN], cb[MAXN];\n\n\t\tint n = 1;\n\t\twhile (n < (n1 + n2)) n *= 2;\n\n\t\tfor (int i = 0; i < n; i++) ca[i] = std::complex<double>(i < n1 ? a[i] : 0, 0);\n\t\tfor (int i = 0; i < n; i++) cb[i] = std::complex<double>(i < n2 ? b[i] : 0, 0);\n\n\t\tinit(n);\n\t\tdft(ca, n);\n\t\tdft(cb, n);\n\n\t\tfor (int i = 0; i < n; i++) ca[i] *= cb[i];\n\n\t\tidft(ca, n);\n\n\t\tfor (int i = 0; i < n; i++) c[i] = static_cast<int>(floor(ca[i].real() + 0.5));\n\t}\n} fft;\n\ninline void force(const int *a, const int *b, int *c, const int n) {\n\t/*\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tc[k] += a[n - i - 1] * b[i - k];\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n - k; i++) {\n\t\t\tc[k] += a[n - k - 1 - i] * b[i];\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN], c[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[n - i - 1], &b[i]);\n\n\t// force(a, b, c, n);\n\tfft(a, n, b, n, c);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", c[n - i - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2194","published":1,"updated":"2016-06-11T13:32:41.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sgu01j4ooxlhpdlz7gb"},{"title":"BZOJ 2152 - ","date":"2016-06-14T14:09:00.000Z","_content":"\n $ n $  $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2152](http://www.lydsy.com/JudgeOnline/problem.php?id=2152)\n\n### \n $ \\bmod 3 $  $ i $  $ f(i) $\n\n $ f(1) \\times f(2) \\times 2 $   \n $ f(0) $  $ \\frac{ f(0) \\times (f(0) - 1) }{2} $ $ 2 $ $ f ^ 2(0) $\n\n $ f ^ 2(0) + f(1) \\times f(2) \\times 2 $ \n\n $ n ^ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, dist, max;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(start->size - a[i]->max, a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->parent = NULL;\n\troot->dist = dist;\n\t\n\tint a[3] = { 0, 0, 0 }, cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt++;\n\t\ta[v->dist %= 3]++;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn a[0] * a[0] + a[1] * a[2] * 2;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint res = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\tres += calc(root);\n\t\troot->solved = true;\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tres -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--, w %= 3;\n\t\taddEdge(u, v, w);\n\t}\n\n\tint cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum);\n\tprintf(\"%d/%d\\n\", cnt / g, sum / g);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2152.md","raw":"title: BZOJ 2152 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-2152\ndate: 2016-06-14 22:09:00\n---\n\n $ n $  $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2152](http://www.lydsy.com/JudgeOnline/problem.php?id=2152)\n\n### \n $ \\bmod 3 $  $ i $  $ f(i) $\n\n $ f(1) \\times f(2) \\times 2 $   \n $ f(0) $  $ \\frac{ f(0) \\times (f(0) - 1) }{2} $ $ 2 $ $ f ^ 2(0) $\n\n $ f ^ 2(0) + f(1) \\times f(2) \\times 2 $ \n\n $ n ^ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, dist, max;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(start->size - a[i]->max, a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->parent = NULL;\n\troot->dist = dist;\n\t\n\tint a[3] = { 0, 0, 0 }, cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt++;\n\t\ta[v->dist %= 3]++;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn a[0] * a[0] + a[1] * a[2] * 2;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint res = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\tres += calc(root);\n\t\troot->solved = true;\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tres -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--, w %= 3;\n\t\taddEdge(u, v, w);\n\t}\n\n\tint cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum);\n\tprintf(\"%d/%d\\n\", cnt / g, sum / g);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2152","published":1,"updated":"2016-06-16T10:10:15.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sh001j9ooxlbo7maly2"},{"title":"BZOJ 2143 - ","date":"2016-03-22T11:50:15.000Z","_content":"\n $ N * M $  $ i $  $ j $  $ A_{ij} $  $ B_{ij} $  $ 1 $ $ (i,j) $  $ A_{ij} $   $ B_{ij} $ \n\n XYZ $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2143](http://www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### \n 40% $ B_{ij} $ $ B_{ij} $  $ A_{ij} $  0 Dijkstra \n\n   Dijkstra \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2143.md","raw":"title: BZOJ 2143 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dijkstra\n  - \npermalink: bzoj-2143\ndate: 2016-03-22 19:50:15\n---\n\n $ N * M $  $ i $  $ j $  $ A_{ij} $  $ B_{ij} $  $ 1 $ $ (i,j) $  $ A_{ij} $   $ B_{ij} $ \n\n XYZ $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2143](http://www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### \n 40% $ B_{ij} $ $ B_{ij} $  $ A_{ij} $  0 Dijkstra \n\n   Dijkstra \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2143","published":1,"updated":"2016-06-14T07:16:00.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sh601jeooxl6gdfag18"},{"title":"BZOJ 2132 - ","date":"2016-06-23T08:56:00.000Z","_content":"\n $ i $  $ j $  $ A_{i,\\ j} $  $ B_{i,\\ j} $  $ (i,\\ j) $  $ K $  $ K $  $ 4 $ $ (i,\\ j) $  $ K \\times C_{i,\\ j} $ \n\n<!-- more -->\n\n### \n[BZOJ 2132](http://www.lydsy.com/JudgeOnline/problem.php?id=2132)\n\n### \n $ X $  $ A_{i,\\ j} $ $ Y $  $ B_{i,\\ j} $ $ X $  $ B_{i,\\ j} $ $ Y $  $ A_{i,\\ j} $\n\n $ C_{i_1,\\ j_1} + C_{i_2,\\ j_2} $ \n\n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\tconst int s = 0, t = n * m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\t\t\t\n\t\t\tif ((i + j) % 2 == 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\n\t\t\tif ((i + j) % 2 != 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x;\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x;\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2132.md","raw":"title: BZOJ 2132 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: bzoj-2132\ndate: 2016-06-23 16:56:00\n---\n\n $ i $  $ j $  $ A_{i,\\ j} $  $ B_{i,\\ j} $  $ (i,\\ j) $  $ K $  $ K $  $ 4 $ $ (i,\\ j) $  $ K \\times C_{i,\\ j} $ \n\n<!-- more -->\n\n### \n[BZOJ 2132](http://www.lydsy.com/JudgeOnline/problem.php?id=2132)\n\n### \n $ X $  $ A_{i,\\ j} $ $ Y $  $ B_{i,\\ j} $ $ X $  $ B_{i,\\ j} $ $ Y $  $ A_{i,\\ j} $\n\n $ C_{i_1,\\ j_1} + C_{i_2,\\ j_2} $ \n\n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\tconst int s = 0, t = n * m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\t\t\t\n\t\t\tif ((i + j) % 2 == 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\n\t\t\tif ((i + j) % 2 != 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x;\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x;\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2132","published":1,"updated":"2016-06-23T08:56:59.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9she01jlooxl1qtik5ks"},{"title":"BZOJ 2127happiness - ","date":"2016-06-21T09:41:00.000Z","_content":"\n $ n \\times m $ ********\n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2];\n\tconst int DOWN = 0, RIGHT = 1;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &aDown[i][j]), sum += aDown[i][j];\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &bDown[i][j]);\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &aRight[i][j]), sum += aRight[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &bRight[i][j]);\n\n\tint id = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) vID[i][j] = id++;\n\n\t// printf(\"eID starts from %d\\n\", id);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++;\n\t\t\tif (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++;\n\t\t}\n\t}\n\n\tconst int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1;\n\n\t// printf(\"%d %d\\n\", id, t);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, vID[i][j], x), sum += x;\n\t\t\telse addEdge(vID[i][j], t, -x);\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(eID[i][j][DOWN][0], t, aDown[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX);\n\t\t\t\taddEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(eID[i][j][RIGHT][0], t, aRight[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX);\n\t\t\t\taddEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2127.md","raw":"title: BZOJ 2127happiness - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-2127\ndate: 2016-06-21 17:41:00\n---\n\n $ n \\times m $ ********\n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2];\n\tconst int DOWN = 0, RIGHT = 1;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &aDown[i][j]), sum += aDown[i][j];\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &bDown[i][j]);\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &aRight[i][j]), sum += aRight[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &bRight[i][j]);\n\n\tint id = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) vID[i][j] = id++;\n\n\t// printf(\"eID starts from %d\\n\", id);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++;\n\t\t\tif (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++;\n\t\t}\n\t}\n\n\tconst int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1;\n\n\t// printf(\"%d %d\\n\", id, t);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, vID[i][j], x), sum += x;\n\t\t\telse addEdge(vID[i][j], t, -x);\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(eID[i][j][DOWN][0], t, aDown[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX);\n\t\t\t\taddEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(eID[i][j][RIGHT][0], t, aRight[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX);\n\t\t\t\taddEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2127","published":1,"updated":"2016-06-22T08:25:36.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9shl01jrooxl0bhviy1k"},{"title":"BZOJ 2120 - ","date":"2016-12-30T01:40:00.000Z","_content":"\n $ N $   \n\n1. `Q L R`  $ L $  $ R $ \n2. `R P Col`  $ P $  $ \\text{Col}$\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2120](http://www.lydsy.com/JudgeOnline/problem.php?id=2120)\n\n### \n\n\n $ n ^ {\\frac{2}{3}} $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\nconst int MAXX = 1e6;\n\nint n, a[MAXN + 1], blockSize;\n\nstruct Update {\n\tint pos, oldVal, newVal;\n} b[MAXM + 1];\n\nint q, ans[MAXM + 1], cnt[MAXX + 1];\n\nstruct Query {\n\tint id, l, r, time, block;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) {\n\t\t\tif (r / blockSize == other.r / blockSize) {\n\t\t\t\treturn time < other.time;\n\t\t\t} else return r / blockSize < other.r / blockSize;\n\t\t} else return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\ninline int extend(int l, int r, bool left, int d) {\n\tif (left) {\n\t\tif (d == 1) {\n\t\t\tif (++cnt[a[l]] == 1) return 1;\n\t\t\telse return 0;\n\t\t} else {\n\t\t\tif (--cnt[a[l]] == 0) return -1;\n\t\t\telse return 0;\n\t\t}\n\t} else {\n\t\tif (d == 1) {\n\t\t\tif (++cnt[a[r]] == 1) return 1;\n\t\t\telse return 0;\n\t\t} else {\n\t\t\tif (--cnt[a[r]] == 0) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n}\n\ninline int update(int l, int r, int time, int d) {\n\tUpdate x = b[time];\n\tint res = 0;\n\tif (d == 1) {\n\t\ta[x.pos] = x.newVal;\n\t\tif (x.pos >= l && x.pos <= r) {\n\t\t\tif (--cnt[x.oldVal] == 0) res--;\n\t\t\tif (++cnt[x.newVal] == 1) res++;\n\t\t}\n\t} else {\n\t\tif (x.pos >= l && x.pos <= r) {\n\t\t\tif (--cnt[x.newVal] == 0) res--;\n\t\t\tif (++cnt[x.oldVal] == 1) res++;\n\t\t}\n\t\ta[x.pos] = x.oldVal;\n\t}\n\treturn res;\n}\n\ninline void prepare(int t) {\n\tstatic int newA[MAXN + 1];\n\tstd::copy(a + 1, a + n + 1, newA + 1);\n\tfor (int i = 1; i <= t; i++) {\n\t\tb[i].oldVal = newA[b[i].pos];\n\t\tnewA[b[i].pos] = b[i].newVal;\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0, time = 0, ans = 0;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (r < Q[i].r) ans += extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) ans += extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) ans += extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) ans += extend(l++, r, true, -1);\n\n\t\twhile (time < Q[i].time) ans += update(l, r, ++time, 1);\n\t\twhile (time > Q[i].time) ans += update(l, r, time--, -1);\n\n\t\t::ans[Q[i].id] = ans;\n\t}\n}\n\nint main() {\n\tint m, t = 0;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tq++;\n\t\t\tQ[q].id = q;\n\t\t\tscanf(\"%d %d\", &Q[q].l, &Q[q].r);\n\t\t\tQ[q].time = t;\n\t\t} else {\n\t\t\tt++;\n\t\t\tscanf(\"%d %d\", &b[t].pos, &b[t].newVal);\n\t\t}\n\t}\n\n\tprepare(t);\n\n\tblockSize = floor(pow(n, 2.0 / 3) + 1);\n\tstd::sort(Q + 1, Q + q + 1);\n\n\tsolve();\n\n\tfor (int i = 1; i <= q; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2120.md","raw":"title: BZOJ 2120 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-2120\ndate: 2016-12-30 09:40:00\n---\n\n $ N $   \n\n1. `Q L R`  $ L $  $ R $ \n2. `R P Col`  $ P $  $ \\text{Col}$\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2120](http://www.lydsy.com/JudgeOnline/problem.php?id=2120)\n\n### \n\n\n $ n ^ {\\frac{2}{3}} $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\nconst int MAXX = 1e6;\n\nint n, a[MAXN + 1], blockSize;\n\nstruct Update {\n\tint pos, oldVal, newVal;\n} b[MAXM + 1];\n\nint q, ans[MAXM + 1], cnt[MAXX + 1];\n\nstruct Query {\n\tint id, l, r, time, block;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) {\n\t\t\tif (r / blockSize == other.r / blockSize) {\n\t\t\t\treturn time < other.time;\n\t\t\t} else return r / blockSize < other.r / blockSize;\n\t\t} else return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\ninline int extend(int l, int r, bool left, int d) {\n\tif (left) {\n\t\tif (d == 1) {\n\t\t\tif (++cnt[a[l]] == 1) return 1;\n\t\t\telse return 0;\n\t\t} else {\n\t\t\tif (--cnt[a[l]] == 0) return -1;\n\t\t\telse return 0;\n\t\t}\n\t} else {\n\t\tif (d == 1) {\n\t\t\tif (++cnt[a[r]] == 1) return 1;\n\t\t\telse return 0;\n\t\t} else {\n\t\t\tif (--cnt[a[r]] == 0) return -1;\n\t\t\telse return 0;\n\t\t}\n\t}\n}\n\ninline int update(int l, int r, int time, int d) {\n\tUpdate x = b[time];\n\tint res = 0;\n\tif (d == 1) {\n\t\ta[x.pos] = x.newVal;\n\t\tif (x.pos >= l && x.pos <= r) {\n\t\t\tif (--cnt[x.oldVal] == 0) res--;\n\t\t\tif (++cnt[x.newVal] == 1) res++;\n\t\t}\n\t} else {\n\t\tif (x.pos >= l && x.pos <= r) {\n\t\t\tif (--cnt[x.newVal] == 0) res--;\n\t\t\tif (++cnt[x.oldVal] == 1) res++;\n\t\t}\n\t\ta[x.pos] = x.oldVal;\n\t}\n\treturn res;\n}\n\ninline void prepare(int t) {\n\tstatic int newA[MAXN + 1];\n\tstd::copy(a + 1, a + n + 1, newA + 1);\n\tfor (int i = 1; i <= t; i++) {\n\t\tb[i].oldVal = newA[b[i].pos];\n\t\tnewA[b[i].pos] = b[i].newVal;\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0, time = 0, ans = 0;\n\tfor (int i = 1; i <= q; i++) {\n\t\twhile (r < Q[i].r) ans += extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) ans += extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) ans += extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) ans += extend(l++, r, true, -1);\n\n\t\twhile (time < Q[i].time) ans += update(l, r, ++time, 1);\n\t\twhile (time > Q[i].time) ans += update(l, r, time--, -1);\n\n\t\t::ans[Q[i].id] = ans;\n\t}\n}\n\nint main() {\n\tint m, t = 0;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tq++;\n\t\t\tQ[q].id = q;\n\t\t\tscanf(\"%d %d\", &Q[q].l, &Q[q].r);\n\t\t\tQ[q].time = t;\n\t\t} else {\n\t\t\tt++;\n\t\t\tscanf(\"%d %d\", &b[t].pos, &b[t].newVal);\n\t\t}\n\t}\n\n\tprepare(t);\n\n\tblockSize = floor(pow(n, 2.0 / 3) + 1);\n\tstd::sort(Q + 1, Q + q + 1);\n\n\tsolve();\n\n\tfor (int i = 1; i <= q; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","slug":"bzoj-2120","published":1,"updated":"2016-12-30T01:46:39.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9shs01jyooxle7mhon4u"},{"title":"BZOJ 2038Z - ","date":"2016-04-01T14:15:45.000Z","_content":"\n $ x_1 $ ~ $ x_n $ $ m $  $ x_i $ ~ $ x_j $ \n\n<!-- more -->\n\n### \n $ \\sqrt n $ \n\n $ x_i $ ~ $ x_j $ \n\n $ x $  $ c_i $ \n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2038.md","raw":"title: BZOJ 2038Z - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \npermalink: bzoj-2038\ndate: 2016-04-01 22:15:45\n---\n\n $ x_1 $ ~ $ x_n $ $ m $  $ x_i $ ~ $ x_j $ \n\n<!-- more -->\n\n### \n $ \\sqrt n $ \n\n $ x_i $ ~ $ x_j $ \n\n $ x $  $ c_i $ \n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2038","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9shy01k3ooxld3fb801r"},{"title":"BZOJ 1756 - ","id":"38","updated":"2016-01-24T15:24:35.000Z","date":"2016-01-24T15:19:48.000Z","_content":"\n `n`  `a`  `b`  `a``b` \n\n<!-- more -->\n\n### \n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### \n\n\n\n\n1. \n2. \n3. ****\n4. ****\n\n\n\n****\n\n\n\n `a``b`  `a`  `b` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1756.md","raw":"title: BZOJ 1756 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - DP\npermalink: bzoj-1756\nid: 38\nupdated: '2016-01-24 23:24:35'\ndate: 2016-01-24 23:19:48\n---\n\n `n`  `a`  `b`  `a``b` \n\n<!-- more -->\n\n### \n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### \n\n\n\n\n1. \n2. \n3. ****\n4. ****\n\n\n\n****\n\n\n\n `a``b`  `a`  `b` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1756","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9si501k9ooxlkdf2kt40"},{"title":"BZOJ 1718Redundant Paths - ","date":"2017-01-01T01:22:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1718](http://www.lydsy.com/JudgeOnline/problem.php?id=1718)  \n[POJ 3177](https://vjudge.net/problem/POJ-3177)\n\n### \n\n\n### \n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 5000;\nconst int MAXM = 10000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge, *inEdge;\n\tint dfn, low, deg;\n\tbool vis;\n\tNode *fa;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tbool isCut;\n\tEdge *next, *revEdge;\n\t                                  /*  */\n\tEdge(Node *from, Node *to) : from(from), to(to), isCut(false), next(from->firstEdge) {}\n} *E[MAXM + 1]; // \n\ninline Edge *addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n\n\tN[from].firstEdge->revEdge = N[to].firstEdge;\n\tN[to].firstEdge->revEdge = N[from].firstEdge;\n\n\treturn N[from].firstEdge; // \n}\n\nint n, cnt;\n\ninline void tarjan(Node *v)\n{\n\tstatic int ts;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->revEdge == v->inEdge) continue; // \n\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->inEdge = e;\n\t\t\ttarjan(e->to);\n\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (e->to->low > v->dfn) //  e->to  ve \n\t\t\t{\t                     //  v  e->to \n\t\t\t\te->isCut = e->revEdge->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n}\n\n\n// \nstruct UFS\n{\n\tint fa[MAXN + 1];\n\n\tvoid init(int n)\n\t{\n\t\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\t}\n\n\tint find(int x)\n\t{\n\t\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n\t}\n\n\tvoid merge(int x, int y)\n\t{\n\t\tfa[find(x)] = find(y);\n\t}\n} ufs;\n\nint main()\n{\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\t//  u  v \n\t\tE[i] = addEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis)\n\t\t{\n\t\t\ttarjan(&N[i]);\n\t\t}\n\t}\n\n\tufs.init(n); // \n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\t// \n\t\tif (!E[i]->isCut) ufs.merge(E[i]->from - N, E[i]->to - N);\n\t}\n\n\tfor (int i = 1; i <= m; i++) // \n\t{\n\t\t// \n\t\tif (E[i]->isCut)\n\t\t{\n\t\t\t// printf(\"cutEdge: (%lu, %lu)\\n\", E[i]->from - N, E[i]->to - N);\n\t\t\tN[ufs.find(E[i]->from - N)].deg++;\n\t\t\tN[ufs.find(E[i]->to - N)].deg++;\n\t\t}\n\t}\n\n\tint leaves = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (ufs.find(i) == i) // \n\t\t{\n\t\t\tif (N[i].deg == 1) // \n\t\t\t{\n\t\t\t\tleaves++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"leaves = %d\\n\", leaves);\n\tprintf(\"%d\\n\", (leaves + 1) / 2);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1718.md","raw":"title: BZOJ 1718Redundant Paths - \ndate: 2017-01-01 09:22:00\ncategories: OI\ntags:\n  - BZOJ\n  - USACO\n  - \n  - \npermalink: bzoj-1718\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1718](http://www.lydsy.com/JudgeOnline/problem.php?id=1718)  \n[POJ 3177](https://vjudge.net/problem/POJ-3177)\n\n### \n\n\n### \n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 5000;\nconst int MAXM = 10000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge, *inEdge;\n\tint dfn, low, deg;\n\tbool vis;\n\tNode *fa;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tbool isCut;\n\tEdge *next, *revEdge;\n\t                                  /*  */\n\tEdge(Node *from, Node *to) : from(from), to(to), isCut(false), next(from->firstEdge) {}\n} *E[MAXM + 1]; // \n\ninline Edge *addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n\n\tN[from].firstEdge->revEdge = N[to].firstEdge;\n\tN[to].firstEdge->revEdge = N[from].firstEdge;\n\n\treturn N[from].firstEdge; // \n}\n\nint n, cnt;\n\ninline void tarjan(Node *v)\n{\n\tstatic int ts;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->revEdge == v->inEdge) continue; // \n\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->inEdge = e;\n\t\t\ttarjan(e->to);\n\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (e->to->low > v->dfn) //  e->to  ve \n\t\t\t{\t                     //  v  e->to \n\t\t\t\te->isCut = e->revEdge->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n}\n\n\n// \nstruct UFS\n{\n\tint fa[MAXN + 1];\n\n\tvoid init(int n)\n\t{\n\t\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\t}\n\n\tint find(int x)\n\t{\n\t\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n\t}\n\n\tvoid merge(int x, int y)\n\t{\n\t\tfa[find(x)] = find(y);\n\t}\n} ufs;\n\nint main()\n{\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\t//  u  v \n\t\tE[i] = addEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis)\n\t\t{\n\t\t\ttarjan(&N[i]);\n\t\t}\n\t}\n\n\tufs.init(n); // \n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\t// \n\t\tif (!E[i]->isCut) ufs.merge(E[i]->from - N, E[i]->to - N);\n\t}\n\n\tfor (int i = 1; i <= m; i++) // \n\t{\n\t\t// \n\t\tif (E[i]->isCut)\n\t\t{\n\t\t\t// printf(\"cutEdge: (%lu, %lu)\\n\", E[i]->from - N, E[i]->to - N);\n\t\t\tN[ufs.find(E[i]->from - N)].deg++;\n\t\t\tN[ufs.find(E[i]->to - N)].deg++;\n\t\t}\n\t}\n\n\tint leaves = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (ufs.find(i) == i) // \n\t\t{\n\t\t\tif (N[i].deg == 1) // \n\t\t\t{\n\t\t\t\tleaves++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"leaves = %d\\n\", leaves);\n\tprintf(\"%d\\n\", (leaves + 1) / 2);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1718","published":1,"updated":"2017-01-01T01:30:39.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sic01kgooxlh6482eho"},{"title":"BZOJ 1711Dining - ","date":"2016-06-21T14:17:00.000Z","_content":"\n $ F $$ 1 \\leq F \\leq 100 $ $ D $$ 1 \\leq D \\leq 100 $$ N $$ 1 \\leq N \\leq 100 $\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1711](http://www.lydsy.com/JudgeOnline/problem.php?id=1711)\n\n### \n $ A $  $ A' $ $ A $  $ A' $ \n\n\n\n $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m1, m2;\n\tscanf(\"%d %d %d\", &n, &m1, &m2);\n\n\tconst int s = 0, t = n * 2 + m1 + m2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\tfor (int i = n + n + 1; i <= n + n + m1; i++) addEdge(s, i, 1);\n\tfor (int i = n + n + m1 + 1; i <= n + n + m1 + m2; i++) addEdge(i, t, 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k1, k2;\n\t\tscanf(\"%d %d\", &k1, &k2);\n\n\t\tfor (int j = 0; j < k1; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(n + n + x, i, 1);\n\t\t}\n\n\t\tfor (int j = 0; j < k2; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i + n, n + n + m1 + x, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1711.md","raw":"title: BZOJ 1711Dining - \ndate: 2016-06-21 22:17:00\ncategories: OI\ntags:\n  - BZOJ\n  - USACO\n  - \n  - Dinic\npermalink: bzoj-1711\n---\n\n $ F $$ 1 \\leq F \\leq 100 $ $ D $$ 1 \\leq D \\leq 100 $$ N $$ 1 \\leq N \\leq 100 $\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1711](http://www.lydsy.com/JudgeOnline/problem.php?id=1711)\n\n### \n $ A $  $ A' $ $ A $  $ A' $ \n\n\n\n $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m1, m2;\n\tscanf(\"%d %d %d\", &n, &m1, &m2);\n\n\tconst int s = 0, t = n * 2 + m1 + m2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\tfor (int i = n + n + 1; i <= n + n + m1; i++) addEdge(s, i, 1);\n\tfor (int i = n + n + m1 + 1; i <= n + n + m1 + m2; i++) addEdge(i, t, 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k1, k2;\n\t\tscanf(\"%d %d\", &k1, &k2);\n\n\t\tfor (int j = 0; j < k1; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(n + n + x, i, 1);\n\t\t}\n\n\t\tfor (int j = 0; j < k2; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i + n, n + n + m1 + x, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1711","published":1,"updated":"2016-10-08T09:04:46.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sil01knooxlo1st7o09"},{"title":"BZOJ 1706 - ","date":"2016-10-07T23:11:00.000Z","_content":"\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1586](www.lydsy.com/JudgeOnline/problem.php?id=1586)  \n[COGS 1470](http://cogs.pro/cogs/problem/problem.php?pid=1470)\n\n### \n $ k $  $ k $ \n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 100;\nconst int MAXN_SMALL = 200;\nconst int MAXK = 1000000;\n\nstruct Matrix {\n\tint a[MAXN_SMALL][MAXN_SMALL];\n\n\tMatrix(const bool unit = false) {\n\t\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) a[i][j] = INT_MAX;\n\t\tif (unit) for (int i = 0; i < MAXN_SMALL; i++) a[i][i] = 0;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) for (int k = 0; k < MAXN_SMALL; k++) if (a(i, k) != INT_MAX && b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j));\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"relays.in\", \"r\", stdin);\n\tfreopen(\"relays.out\", \"w\", stdout);\n\n\tint n, m, s, t, cnt;\n\tstatic int set[MAXM * 2];\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n\tstatic struct {\n\t\tint u, v, w;\n\t} E[MAXM];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].w, &E[i].u, &E[i].v);\n\t\tset[i] = E[i].u;\n\t\tset[i + m] = E[i].v;\n\t}\n\n\tstd::sort(set, set + m * 2);\n\tint *end = std::unique(set, set + m * 2);\n\tcnt = end - set;\n\n\tMatrix g(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tE[i].u = std::lower_bound(set, end, E[i].u) - set;\n\t\tE[i].v = std::lower_bound(set, end, E[i].v) - set;\n\t\tg(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w;\n\t}\n\ts = std::lower_bound(set, end, s) - set;\n\tt = std::lower_bound(set, end, t) - set;\n\n\tMatrix res = pow(g, n);\n\t/*\n\tMatrix res(true);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = res * g;\n\t\tfor (int i = 0; i < cnt; i++) for (int j = 0; j < cnt; j++) printf(\"%d%c\", res(i, j), j == cnt - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------------\");\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", res(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1706.md","raw":"title: BZOJ 1706 - \ndate: 2016-10-08 07:11:00\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - USACO\n  - \npermalink: bzoj-1706\n---\n\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1586](www.lydsy.com/JudgeOnline/problem.php?id=1586)  \n[COGS 1470](http://cogs.pro/cogs/problem/problem.php?pid=1470)\n\n### \n $ k $  $ k $ \n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 100;\nconst int MAXN_SMALL = 200;\nconst int MAXK = 1000000;\n\nstruct Matrix {\n\tint a[MAXN_SMALL][MAXN_SMALL];\n\n\tMatrix(const bool unit = false) {\n\t\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) a[i][j] = INT_MAX;\n\t\tif (unit) for (int i = 0; i < MAXN_SMALL; i++) a[i][i] = 0;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) for (int k = 0; k < MAXN_SMALL; k++) if (a(i, k) != INT_MAX && b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j));\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"relays.in\", \"r\", stdin);\n\tfreopen(\"relays.out\", \"w\", stdout);\n\n\tint n, m, s, t, cnt;\n\tstatic int set[MAXM * 2];\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n\tstatic struct {\n\t\tint u, v, w;\n\t} E[MAXM];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].w, &E[i].u, &E[i].v);\n\t\tset[i] = E[i].u;\n\t\tset[i + m] = E[i].v;\n\t}\n\n\tstd::sort(set, set + m * 2);\n\tint *end = std::unique(set, set + m * 2);\n\tcnt = end - set;\n\n\tMatrix g(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tE[i].u = std::lower_bound(set, end, E[i].u) - set;\n\t\tE[i].v = std::lower_bound(set, end, E[i].v) - set;\n\t\tg(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w;\n\t}\n\ts = std::lower_bound(set, end, s) - set;\n\tt = std::lower_bound(set, end, t) - set;\n\n\tMatrix res = pow(g, n);\n\t/*\n\tMatrix res(true);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = res * g;\n\t\tfor (int i = 0; i < cnt; i++) for (int j = 0; j < cnt; j++) printf(\"%d%c\", res(i, j), j == cnt - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------------\");\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", res(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"bzoj-1706","published":1,"updated":"2016-10-07T23:18:48.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sit01ktooxl5amhekiy"},{"title":"BZOJ 1692 -  + ","date":"2016-09-29T13:33:00.000Z","_content":"\n $ S $ $ T $  $ T $\n\n<!-- more -->\n\n### \n[BZOJ 1692](http://www.lydsy.com/JudgeOnline/problem.php?id=1692)\n\n### \n\n\n\n\n 80 \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1692.md","raw":"title: BZOJ 1692 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - \n  - \npermalink: bzoj-1692\ndate: 2016-09-29 21:33:00\n---\n\n $ S $ $ T $  $ T $\n\n<!-- more -->\n\n### \n[BZOJ 1692](http://www.lydsy.com/JudgeOnline/problem.php?id=1692)\n\n### \n\n\n\n\n 80 \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","slug":"bzoj-1692","published":1,"updated":"2016-09-29T13:45:54.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sj301kzooxlp726ykia"},{"title":"BZOJ 1597 -  DP","date":"2016-05-18T09:04:00.000Z","_content":"\n John  $ N $$ 1 \\leq N \\leq 50000 $$ 1 \\leq $  $ \\leq 1000000 $ FJ  FJ  $ 3 \\times 5 $  $ 5 \\times 3 $  $ 5 \\times 5 = 25 $FJ \n\n<!-- more -->\n\n### \n[BZOJ 1597](http://www.lydsy.com/JudgeOnline/problem.php?id=1597)\n\n### \n\n\n $ w(i) $  $ h(i) $  $ f(i) $  $ i $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + w(j + 1) \\times h(i) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + w(a + 1) \\times h(i) & < f(b) + w(b + 1) \\times h(i) \\\\\nf(a) + f(b) & < (w(b + 1) - w(a + 1)) \\times h(i) \\\\\nf(a) + f(b) \\over w(b + 1) - w(a + 1) & < h(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50000;\n\nstd::pair<int, int> A[MAXN];\nstd::vector< std::pair<int, int>* > vec;\n\nint n;\nlong long f[MAXN + 1];\n\ninline void prepare() {\n    std::sort(A, A + n, std::greater< std::pair<int, int> >());\n\n    std::pair<int, int> *last = NULL;\n    for (int i = 0; i < n; i++) {\n        if (!last || A[i].second > last->second) {\n            vec.push_back(&A[i]);\n            last = &A[i];\n        }\n    }\n\n    n = vec.size();\n}\n\ninline long long w(const int i) { return static_cast<long long>(vec[i - 1]->first); }\ninline long long h(const int i) { return static_cast<long long>(vec[i - 1]->second); }\n\ninline void force() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + w(j + 1) * h(i)) {\n                f[i] = f[j] + w(j + 1) * h(i);\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n\ninline double slope(const int a, const int b) {\n    return double(f[a] - f[b])\n         / double(w(b + 1) - w(a + 1));\n}\n\ninline void dp() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n\n    static int q[MAXN + 1];\n    int *l = &q[0], *r = &q[0];\n    *r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < h(i)) l++;\n\n        int tmp = *l;\n        f[i] = f[tmp] + w(tmp + 1) * h(i);\n        // printf(\"%d --> %d\\n\", i, tmp);\n\n        if (i != n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &A[i].first, &A[i].second);\n\n    prepare();\n    // for (int i = 0; i < n; i++) printf(\"%d %d\\n\", vec[i]->first, vec[i]->second);\n\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/bzoj-1597.md","raw":"title: BZOJ 1597 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - \n  - \npermalink: bzoj-1597\ndate: 2016-05-18 17:04:00\n---\n\n John  $ N $$ 1 \\leq N \\leq 50000 $$ 1 \\leq $  $ \\leq 1000000 $ FJ  FJ  $ 3 \\times 5 $  $ 5 \\times 3 $  $ 5 \\times 5 = 25 $FJ \n\n<!-- more -->\n\n### \n[BZOJ 1597](http://www.lydsy.com/JudgeOnline/problem.php?id=1597)\n\n### \n\n\n $ w(i) $  $ h(i) $  $ f(i) $  $ i $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + w(j + 1) \\times h(i) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + w(a + 1) \\times h(i) & < f(b) + w(b + 1) \\times h(i) \\\\\nf(a) + f(b) & < (w(b + 1) - w(a + 1)) \\times h(i) \\\\\nf(a) + f(b) \\over w(b + 1) - w(a + 1) & < h(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50000;\n\nstd::pair<int, int> A[MAXN];\nstd::vector< std::pair<int, int>* > vec;\n\nint n;\nlong long f[MAXN + 1];\n\ninline void prepare() {\n    std::sort(A, A + n, std::greater< std::pair<int, int> >());\n\n    std::pair<int, int> *last = NULL;\n    for (int i = 0; i < n; i++) {\n        if (!last || A[i].second > last->second) {\n            vec.push_back(&A[i]);\n            last = &A[i];\n        }\n    }\n\n    n = vec.size();\n}\n\ninline long long w(const int i) { return static_cast<long long>(vec[i - 1]->first); }\ninline long long h(const int i) { return static_cast<long long>(vec[i - 1]->second); }\n\ninline void force() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + w(j + 1) * h(i)) {\n                f[i] = f[j] + w(j + 1) * h(i);\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n\ninline double slope(const int a, const int b) {\n    return double(f[a] - f[b])\n         / double(w(b + 1) - w(a + 1));\n}\n\ninline void dp() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n\n    static int q[MAXN + 1];\n    int *l = &q[0], *r = &q[0];\n    *r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < h(i)) l++;\n\n        int tmp = *l;\n        f[i] = f[tmp] + w(tmp + 1) * h(i);\n        // printf(\"%d --> %d\\n\", i, tmp);\n\n        if (i != n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &A[i].first, &A[i].second);\n\n    prepare();\n    // for (int i = 0; i < n; i++) printf(\"%d %d\\n\", vec[i]->first, vec[i]->second);\n\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"bzoj-1597","published":1,"updated":"2016-10-24T23:38:54.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sjd01l6ooxlwpwa5oi0"},{"title":"BZOJ 1585Earthquake Damage 2 - ","date":"2016-06-22T08:14:00.000Z","_content":"\n $ P $  $ C $  $ i $  $ A_i $  $ B_i $ $ A_i $ $ B_i $ $ A_i $  $ B_i $ Farmer John  $ 1 $ $ C $  $ N $  $ i $  $ R_i $ $ R_i $  $ R_i $  $ 1 $  Farmer John \n\n<!-- more -->\n\n### \n[BZOJ 1585](http://www.lydsy.com/JudgeOnline/problem.php?id=1585)\n\n### \n $ 1 $ $ R_i $ $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u + n, v, INT_MAX);\n\t\taddEdge(v + n, u, INT_MAX);\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\n\t\taddEdge(s, u + n, INT_MAX);\n\t}\n\n\taddEdge(1, t, INT_MAX);\n\n\tint maxFlow = dinic(s, t, n + n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1585.md","raw":"title: BZOJ 1585Earthquake Damage 2 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \n  - USACO\npermalink: bzoj-1585\ndate: 2016-06-22 16:14:00\n---\n\n $ P $  $ C $  $ i $  $ A_i $  $ B_i $ $ A_i $ $ B_i $ $ A_i $  $ B_i $ Farmer John  $ 1 $ $ C $  $ N $  $ i $  $ R_i $ $ R_i $  $ R_i $  $ 1 $  Farmer John \n\n<!-- more -->\n\n### \n[BZOJ 1585](http://www.lydsy.com/JudgeOnline/problem.php?id=1585)\n\n### \n $ 1 $ $ R_i $ $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u + n, v, INT_MAX);\n\t\taddEdge(v + n, u, INT_MAX);\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\n\t\taddEdge(s, u + n, INT_MAX);\n\t}\n\n\taddEdge(1, t, INT_MAX);\n\n\tint maxFlow = dinic(s, t, n + n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1585","published":1,"updated":"2016-06-22T08:14:52.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sjo01lcooxl36c3xbdc"},{"title":"BZOJ 1477 - ","date":"2016-01-23T15:20:01.000Z","_content":"\n A  B 0  1  A  x B  y A  m  B  n  L \n\n<!-- more -->\n\n### \n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### \n $t$ \n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n $k=k_{1}-k_{2}$\n\n$$ (x+tm)-(y+tn)=kL $$\n\n\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n****\n\n\n\n### \n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1477.md","raw":"title: BZOJ 1477 - \ncategories: OI\ntags: \n  - BZOJ\n  - Tyvj\n  - EXGCD\n  - \npermalink: bzoj-1477\ndate: 2016-01-23 23:20:01\n---\n\n A  B 0  1  A  x B  y A  m  B  n  L \n\n<!-- more -->\n\n### \n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### \n $t$ \n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n $k=k_{1}-k_{2}$\n\n$$ (x+tm)-(y+tn)=kL $$\n\n\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n****\n\n\n\n### \n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1477","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sjw01ljooxlc2d2aocm"},{"title":"BZOJ 1468Tree - ","date":"2016-06-14T13:59:00.000Z","_content":"\n Tree Tree  $ K $\n\n<!-- more -->\n\n### \n[BZOJ 1468](http://www.lydsy.com/JudgeOnline/problem.php?id=1468)\n\n### \n****\n\n $ K $ \n\n $ a_i $ $ a_i + a_j \\leq K $  $ a_j $  $ i $ $ j $  $ i $  $ j $ $ a_i + a_j \\leq K $ $ [i + 1,\\ j] $  $ j - i $\n\n****\n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tprintf(\"%d\\n\", solve());\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1468.md","raw":"title: BZOJ 1468Tree - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-1468\ndate: 2016-06-14 21:59:00\n---\n\n Tree Tree  $ K $\n\n<!-- more -->\n\n### \n[BZOJ 1468](http://www.lydsy.com/JudgeOnline/problem.php?id=1468)\n\n### \n****\n\n $ K $ \n\n $ a_i $ $ a_i + a_j \\leq K $  $ a_j $  $ i $ $ j $  $ i $  $ j $ $ a_i + a_j \\leq K $ $ [i + 1,\\ j] $  $ j - i $\n\n****\n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tprintf(\"%d\\n\", solve());\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1468","published":1,"updated":"2016-06-16T10:09:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sk501lpooxllld15m00"},{"title":"BZOJ 1334Elect -  DP","date":"2016-07-11T14:50:00.000Z","_content":"\n$ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1334](http://www.lydsy.com/JudgeOnline/problem.php?id=1334)\n\n### \n\n\n $ f(i) $  $ i $ \n\n DP  $ i - f(i) \\leq \\frac{m}{2} $  $ i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tint m = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), m += a[i];\n\n\tstatic int f[MAXM + 1];\n\tf[0] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= a[i]; j--) {\n\t\t\tf[j] = std::max(f[j], std::min(f[j - a[i]], a[i]));\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (i - f[i] <= m / 2) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1334.md","raw":"title: BZOJ 1334Elect -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-1334\ndate: 2016-07-11 22:50:00\n---\n\n$ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1334](http://www.lydsy.com/JudgeOnline/problem.php?id=1334)\n\n### \n\n\n $ f(i) $  $ i $ \n\n DP  $ i - f(i) \\leq \\frac{m}{2} $  $ i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tint m = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), m += a[i];\n\n\tstatic int f[MAXM + 1];\n\tf[0] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= a[i]; j--) {\n\t\t\tf[j] = std::max(f[j], std::min(f[j - a[i]], a[i]));\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (i - f[i] <= m / 2) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1334","published":1,"updated":"2016-10-24T23:33:15.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9skb01luooxlybp32p0j"},{"title":"BZOJ 1251 - Splay","id":"27","updated":"2016-01-19T13:02:18.000Z","date":"2016-01-18T13:44:15.000Z","_content":"\n `N` \n\n1.  `[L,R]`  `V`\n2.  `[L,R]`  `1 2 3 4`  `4 3 2 1`\n3.  `[L,R]`   `0`\n\n<!-- more -->\n\n### \n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### \nSplay \n\n `lazy-tag` `pushDown()` \n\n `maintain()` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1251.md","raw":"title: BZOJ 1251 - Splay\ncategories: OI\ntags: \n  - Splay\n  - BZOJ\n  - CodeVS\n  - \npermalink: bzoj-1251\nid: 27\nupdated: '2016-01-19 21:02:18'\ndate: 2016-01-18 21:44:15\n---\n\n `N` \n\n1.  `[L,R]`  `V`\n2.  `[L,R]`  `1 2 3 4`  `4 3 2 1`\n3.  `[L,R]`   `0`\n\n<!-- more -->\n\n### \n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### \nSplay \n\n `lazy-tag` `pushDown()` \n\n `maintain()` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","slug":"bzoj-1251","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9skn01lzooxl1c1iro6x"},{"title":"BZOJ 1176Mokia - CDQ","date":"2016-06-20T11:48:00.000Z","_content":"\n $ N \\times N $$ N \\leq 2000000 $ $ S $\n\n $ \\leq 160000 $ $ \\leq 10000 $\n\n<!-- more -->\n\n### \n[BZOJ 1176](http://www.lydsy.com/JudgeOnline/problem.php?id=1176)\n\n### \n $ Q(x1,\\ y1,\\ x2,\\ y2) $  $ [x1,\\ y1] $  $ [x2,\\ y2] $ \n\n$$\n\\begin{aligned}\nQ(x1,\\ y1,\\ x2,\\ y2) = &  Q(0,\\ 0,\\ x2,\\ y2) \\\\\n& - Q(0,\\ 0,\\ x1 - 1,\\ y2) - Q(0,\\ 0,\\ x2,\\ y1 - 1) \\\\\n& + Q(0,\\ 0,\\ x1,\\ y1)\n\\end{aligned}\n$$\n\n$ x $$ y $ $ x $  $ y $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2000000 + 1;\nconst int MAXQ = 10000;\nconst int MAXM = 160000 + MAXQ * 4;\n\nstruct Triple {\n\tint id, x, y, d, delta, *ans;\n\n\tTriple() {}\n\tTriple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); }\n\tTriple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); }\n\n\tvoid setID() {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tbool isQuery() const { return d != 0; }\n} a[MAXM];\n\nint s, n, m, cnt, ans[MAXQ];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXM];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->x <= p2->x && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tif (!p->isQuery()) bit.update(p->y, p->delta);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tif (p->isQuery()) *p->ans += bit.query(p->y) * p->d;\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tif (q <= mid && !q->isQuery()) bit.clear(q->y);\n\t\t*q = *p;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &s, &n), n++;\n\t\n\tint qcnt = 0;\n\twhile (true) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 3) break;\n\t\telse if (t == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1++, y1++, x2++, y2++;\n\n\t\t\tint *p = &ans[qcnt++];\n\t\t\t*p = (y2 - y1 + 1) * (x2 - x1 + 1) * s;\n\t\t\ta[cnt++] = Triple(x2, y2, 1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y2, -1, p);\n\t\t\ta[cnt++] = Triple(x2, y1 - 1, -1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, 1, p);\n\t\t} else if (t == 1) {\n\t\t\tint x, y, delta;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &delta), x++, y++;\n\t\t\ta[cnt++] = Triple(x, y, delta);\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < cnt; i++) {\n\t\tprintf(\"Triple(x = %d, y = %d, d = %d, delta = %d)\\n\", a[i].x, a[i].y, a[i].d, a[i].delta);\n\t}\n\t*/\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qcnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1176.md","raw":"title: BZOJ 1176Mokia - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-1176\ndate: 2016-06-20 19:48:00\n---\n\n $ N \\times N $$ N \\leq 2000000 $ $ S $\n\n $ \\leq 160000 $ $ \\leq 10000 $\n\n<!-- more -->\n\n### \n[BZOJ 1176](http://www.lydsy.com/JudgeOnline/problem.php?id=1176)\n\n### \n $ Q(x1,\\ y1,\\ x2,\\ y2) $  $ [x1,\\ y1] $  $ [x2,\\ y2] $ \n\n$$\n\\begin{aligned}\nQ(x1,\\ y1,\\ x2,\\ y2) = &  Q(0,\\ 0,\\ x2,\\ y2) \\\\\n& - Q(0,\\ 0,\\ x1 - 1,\\ y2) - Q(0,\\ 0,\\ x2,\\ y1 - 1) \\\\\n& + Q(0,\\ 0,\\ x1,\\ y1)\n\\end{aligned}\n$$\n\n$ x $$ y $ $ x $  $ y $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2000000 + 1;\nconst int MAXQ = 10000;\nconst int MAXM = 160000 + MAXQ * 4;\n\nstruct Triple {\n\tint id, x, y, d, delta, *ans;\n\n\tTriple() {}\n\tTriple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); }\n\tTriple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); }\n\n\tvoid setID() {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tbool isQuery() const { return d != 0; }\n} a[MAXM];\n\nint s, n, m, cnt, ans[MAXQ];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXM];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->x <= p2->x && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tif (!p->isQuery()) bit.update(p->y, p->delta);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tif (p->isQuery()) *p->ans += bit.query(p->y) * p->d;\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tif (q <= mid && !q->isQuery()) bit.clear(q->y);\n\t\t*q = *p;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &s, &n), n++;\n\t\n\tint qcnt = 0;\n\twhile (true) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 3) break;\n\t\telse if (t == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1++, y1++, x2++, y2++;\n\n\t\t\tint *p = &ans[qcnt++];\n\t\t\t*p = (y2 - y1 + 1) * (x2 - x1 + 1) * s;\n\t\t\ta[cnt++] = Triple(x2, y2, 1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y2, -1, p);\n\t\t\ta[cnt++] = Triple(x2, y1 - 1, -1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, 1, p);\n\t\t} else if (t == 1) {\n\t\t\tint x, y, delta;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &delta), x++, y++;\n\t\t\ta[cnt++] = Triple(x, y, delta);\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < cnt; i++) {\n\t\tprintf(\"Triple(x = %d, y = %d, d = %d, delta = %d)\\n\", a[i].x, a[i].y, a[i].d, a[i].delta);\n\t}\n\t*/\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qcnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1176","published":1,"updated":"2016-06-20T14:11:06.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sku01m5ooxlitgi4rbt"},{"title":"HNOI2008 - ","date":"2016-04-06T13:04:45.000Z","_content":"\n $ 1  N $  $ N $ M\n\n<!-- more -->\n\n### \n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### \n\n\n $ N $  $ M $  $ M ^ N $\n\n $ M $  $ M - 1 $  $ M * (M - 1) ^ {N - 1} $\n\n $ M ^ N - M * (M - 1) ^ {N - 1} $\n\n### \n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1008.md","raw":"title: HNOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - \npermalink: bzoj-1008\ndate: 2016-04-06 21:04:45\n---\n\n $ 1  N $  $ N $ M\n\n<!-- more -->\n\n### \n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### \n\n\n $ N $  $ M $  $ M ^ N $\n\n $ M $  $ M - 1 $  $ M * (M - 1) ^ {N - 1} $\n\n $ M ^ N - M * (M - 1) ^ {N - 1} $\n\n### \n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1008","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sl201mcooxlv07ksmff"},{"title":"BeiJing2006 - ","date":"2016-04-03T14:46:25.000Z","_content":"\n $ (1, 1) $ $ (N, M) $\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n $ (1, 1) $  $ (N, M) $  $ K $ $ K $ .\n\n<!-- more -->\n\n### \n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### \nDinic  \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1001.md","raw":"title: BeiJing2006 - \ncategories: OI\ntags: \n  - BZOJ\n  - Dinic\n  - \n  - \npermalink: bzoj-1001\ndate: 2016-04-03 22:46:25\n---\n\n $ (1, 1) $ $ (N, M) $\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n $ (1, 1) $  $ (N, M) $  $ K $ $ K $ .\n\n<!-- more -->\n\n### \n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### \nDinic  \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-1001","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sl901miooxljfxbb22y"},{"title":" BSGS","date":"2016-06-13T03:52:00.000Z","_content":"\n![zyz ](images/zyz.png)\n\n $ a $$ b $$ p $  $ x $\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ x $  $ b $  $ p $  $ a $ ****\n\n<!-- more -->\n\n### \n\n\n$$\n\\begin{aligned}\n\\log_g x + \\log_g y &\\equiv \\log_g xy \\pmod p \\\\\n\\log_g x ^ y &\\equiv y \\log_g x \\pmod p\n\\end{aligned}\n$$\n\n### BSGS\n BSGSBaby-Step Giant-Step\n\n$ p $ \n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ m = \\lceil \\sqrt p \\rceil $  \n $ a ^ {p - 1} \\equiv 1 \\pmod p $ $ 0 \\leq x < p - 1 $\n\n $ x = im + j $ $ 0 \\leq i,\\ j \\leq m $\n\n\n\n$$\n\\begin{align*}\na ^ {x} &\\equiv b \\pmod p \\\\\na ^ {im + j} &\\equiv b \\pmod p \\\\\na ^ {j} &\\equiv b \\times a ^ {-im} \\pmod p \\\\\na ^ {j} &\\equiv b \\times (a ^ {-m}) ^ i \\pmod p\n\\end{align*}\n$$\n\n $ i $$ j $ \n\n $ j $ $ a ^ j \\bmod p $  $ (a ^ j \\bmod p) \\mapsto j $ \n\n $ a ^ m \\bmod p $  $ a ^ {-m} \\bmod p $ $ i $ $ b \\times (a ^ {-m}) ^ i $ $ j $$ x = im + j $ \n\n $ O(\\sqrt p) $\n\n#### \n```c++\ninline void exgcd(long long a, long long b, long long &g, long long &x, long long &y)\n{\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(long long x, long long p)\n{\n\tlong long g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ninline long long bsgs(long long a, long long b, long long p)\n{\n\tif (a == 0) return b == 0 ? 1 : -1;\n\n\tstd::map<long long, long long> map;\n\n\tlong long m = ceil(sqrt(p)), t = 1;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tlong long k = inv(t, p), w = b;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (map.count(w)) return i * m + map[w];\n\t\tw = w * k % p;\n\t}\n\n\treturn -1;\n}\n```\n\n### EXBSGS\n BSGS  $ p $  $ a $  $ \\gcd(a,\\ p) = 1 $ \n\n\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n\n\n$$ a ^ x = b + kp $$\n\n $ d = \\gcd(a,\\ p) $ $ d \\mid b $\n\n$$ a ^ {x - 1} \\frac{a}{d} = \\frac{b}{d} + k \\frac{p}{d} $$\n\n\n\n$$ a ^ {x - 1} \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod { \\frac{p}{d} } $$\n\n $ \\gcd(\\frac{a}{d},\\ \\frac{p}{d}) = 1 $ $ \\frac{a}{d} $ \n\n$$ a ^ {x - 1} \\equiv \\frac{b}{d} \\times (\\frac{a}{d}) ^ {-1} \\pmod { \\frac{p}{d} } $$\n\n $ d = 1 $  BSGS  $ d \\not \\mid b $  $ b = 1 $  $ 0 $ $ 1 $\n\n#### \n```c++\ninline long long exbsgs(long long a, long long b, long long p)\n{\n\tlong long t, c = 0;\n\twhile ((t = std::__gcd(a, p)) != 1)\n\t{\n\t\tif (b == 1) return c;\n\t\tif (b % t != 0) return -1;\n\t\tp /= t;\n\t\tb = b / t * inv(a / t, p) % p;\n\t\tc++;\n\t}\n\n\tlong long r = bsgs(a, b, p);\n\tif (r == -1) return -1;\n\telse return r + c;\n}\n```\n","source":"_posts/bsgs-notes.md","raw":"title:  BSGS\ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - BSGS\npermalink: bsgs-notes\ndate: 2016-06-13 11:52:00\n---\n\n![zyz ](images/zyz.png)\n\n $ a $$ b $$ p $  $ x $\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ x $  $ b $  $ p $  $ a $ ****\n\n<!-- more -->\n\n### \n\n\n$$\n\\begin{aligned}\n\\log_g x + \\log_g y &\\equiv \\log_g xy \\pmod p \\\\\n\\log_g x ^ y &\\equiv y \\log_g x \\pmod p\n\\end{aligned}\n$$\n\n### BSGS\n BSGSBaby-Step Giant-Step\n\n$ p $ \n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ m = \\lceil \\sqrt p \\rceil $  \n $ a ^ {p - 1} \\equiv 1 \\pmod p $ $ 0 \\leq x < p - 1 $\n\n $ x = im + j $ $ 0 \\leq i,\\ j \\leq m $\n\n\n\n$$\n\\begin{align*}\na ^ {x} &\\equiv b \\pmod p \\\\\na ^ {im + j} &\\equiv b \\pmod p \\\\\na ^ {j} &\\equiv b \\times a ^ {-im} \\pmod p \\\\\na ^ {j} &\\equiv b \\times (a ^ {-m}) ^ i \\pmod p\n\\end{align*}\n$$\n\n $ i $$ j $ \n\n $ j $ $ a ^ j \\bmod p $  $ (a ^ j \\bmod p) \\mapsto j $ \n\n $ a ^ m \\bmod p $  $ a ^ {-m} \\bmod p $ $ i $ $ b \\times (a ^ {-m}) ^ i $ $ j $$ x = im + j $ \n\n $ O(\\sqrt p) $\n\n#### \n```c++\ninline void exgcd(long long a, long long b, long long &g, long long &x, long long &y)\n{\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(long long x, long long p)\n{\n\tlong long g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ninline long long bsgs(long long a, long long b, long long p)\n{\n\tif (a == 0) return b == 0 ? 1 : -1;\n\n\tstd::map<long long, long long> map;\n\n\tlong long m = ceil(sqrt(p)), t = 1;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tlong long k = inv(t, p), w = b;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tif (map.count(w)) return i * m + map[w];\n\t\tw = w * k % p;\n\t}\n\n\treturn -1;\n}\n```\n\n### EXBSGS\n BSGS  $ p $  $ a $  $ \\gcd(a,\\ p) = 1 $ \n\n\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n\n\n$$ a ^ x = b + kp $$\n\n $ d = \\gcd(a,\\ p) $ $ d \\mid b $\n\n$$ a ^ {x - 1} \\frac{a}{d} = \\frac{b}{d} + k \\frac{p}{d} $$\n\n\n\n$$ a ^ {x - 1} \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod { \\frac{p}{d} } $$\n\n $ \\gcd(\\frac{a}{d},\\ \\frac{p}{d}) = 1 $ $ \\frac{a}{d} $ \n\n$$ a ^ {x - 1} \\equiv \\frac{b}{d} \\times (\\frac{a}{d}) ^ {-1} \\pmod { \\frac{p}{d} } $$\n\n $ d = 1 $  BSGS  $ d \\not \\mid b $  $ b = 1 $  $ 0 $ $ 1 $\n\n#### \n```c++\ninline long long exbsgs(long long a, long long b, long long p)\n{\n\tlong long t, c = 0;\n\twhile ((t = std::__gcd(a, p)) != 1)\n\t{\n\t\tif (b == 1) return c;\n\t\tif (b % t != 0) return -1;\n\t\tp /= t;\n\t\tb = b / t * inv(a / t, p) % p;\n\t\tc++;\n\t}\n\n\tlong long r = bsgs(a, b, p);\n\tif (r == -1) return -1;\n\telse return r + c;\n}\n```\n","slug":"bsgs-notes","published":1,"updated":"2017-01-02T12:47:43.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9slg01moooxltxsdu2p9"},{"title":"","date":"2016-03-14T13:34:42.000Z","_content":"\n \n \n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","source":"_posts/bigint-template.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \npermalink: bigint-template\ndate: 2016-03-14 21:34:42\n---\n\n \n \n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","slug":"bigint-template","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9slq01mwooxlefrrc6zm"},{"title":"   NOI2016 ","date":"2016-08-30T18:42:00.000Z","_content":"\n<div style=\"width: 100%; text-align: center; \"><div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div></div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: 'KOKIA',\n        url: 'https://dn-menci.qbox.me/music/mzr/mzr.ogg',\n        pic: 'https://dn-menci.qbox.me/music/mzr/mzr.jpg',\n        lrc: '/at-the-cross-of-time/mzr.lrc'\n    }\n});\n</script>\n\n OIer NOI \n\n<!-- more -->\n\nNOI   \n\n\n\n OIer     \n\n  \n    \n\n  \n\n\n    \n\n\n\n\n\n****\n\n OIer \n\n\n\n\n\n OI \n","source":"_posts/at-the-cross-of-time.md","raw":"title:    NOI2016 \ncategories: \n  - Diary\npermalink: at-the-cross-of-time\ndate: 2016-08-31 02:42:00\n---\n\n<div style=\"width: 100%; text-align: center; \"><div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div></div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: 'KOKIA',\n        url: 'https://dn-menci.qbox.me/music/mzr/mzr.ogg',\n        pic: 'https://dn-menci.qbox.me/music/mzr/mzr.jpg',\n        lrc: '/at-the-cross-of-time/mzr.lrc'\n    }\n});\n</script>\n\n OIer NOI \n\n<!-- more -->\n\nNOI   \n\n\n\n OIer     \n\n  \n    \n\n  \n\n\n    \n\n\n\n\n\n****\n\n OIer \n\n\n\n\n\n OI \n","slug":"at-the-cross-of-time","published":1,"updated":"2016-12-31T05:04:52.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9slv01n0ooxlauq8af31"},{"title":"APIO2012Dispatching - ","date":"2017-01-04T03:33:00.000Z","_content":"\n $ n $  $ C_i $  $ L_i $ $ R $ $ R $  $ R $  $ C_i $  $ M $ $ \\times L_R $\n\n<!-- more -->\n\n### \n[BZOJ 2809](http://www.lydsy.com/JudgeOnline/problem.php?id=2809)\n\n### \n\n\n### \n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct LeftTree\n{\n\tLeftTree *lc, *rc;\n\tlong long dist, sum, x, size;\n\n\tLeftTree(long long x) : lc(NULL), rc(NULL), dist(0), sum(x), x(x), size(1) {}\n\n\t//  size  sum\n\tvoid maintain()\n\t{\n\t\tsize = (lc ? lc->size : 0) + (rc ? rc->size : 0) + 1;\n\t\tsum = (lc ? lc->sum : 0) + (rc ? rc->sum : 0) + x;\n\t}\n\n\t//  ab  a \n\tstatic LeftTree *merge(LeftTree *a, LeftTree *b)\n\t{\n\t\tif (!a) return b;\n\t\tif (!b) return a;\n\t\tif (a->x < b->x) std::swap(a, b); //  >= \n\t\n\t\t// \n\t\ta->rc = merge(a->rc, b);\n\n\t\t// \n\t\tif (!a->lc || a->lc->dist < a->rc->dist) std::swap(a->lc, a->rc);\n\n\t\t// \n\t\ta->dist = a->rc ? a->rc->dist + 1 : 0;\n\t\ta->maintain();\n\n\t\treturn a;\n\t}\n};\n\nstruct Node\n{\n\tstruct Edge *e;\n\tlong long c, l;\n\tLeftTree *lt;\n} N[MAXN + 1], *seq[MAXN + 1]; //  BFS \n\nstruct Edge\n{\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\ninline void bfs()\n{\n\tstd::queue<Node *> q;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\t//  BFS \n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next)\n\t\t{\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tlong long m;\n\tscanf(\"%d %lld\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint fa;\n\t\tscanf(\"%d\", &fa);\n\t\tif (fa) addEdge(fa, i);\n\n\t\tscanf(\"%lld %lld\", &N[i].c, &N[i].l);\n\n\t\t// \n\t\tN[i].lt = new LeftTree(N[i].c);\n\t}\n\n\tbfs();\n\n\tlong long ans = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tNode *v = seq[i];\n\n\t\t// \n\t\tfor (Edge *e = v->e; e; e = e->next)\n\t\t{\n\t\t\tv->lt = LeftTree::merge(v->lt, e->t->lt);\n\t\t}\n\n\t\t//  <= M\n\t\twhile (v->lt->sum > m) v->lt = LeftTree::merge(v->lt->lc, v->lt->rc);\n\n\t\tans = std::max(ans, v->lt->size * v->l);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/apio2012-dispatching.md","raw":"title: APIO2012Dispatching - \ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - \n  - \npermalink: apio2012-dispatching\ndate: 2017-01-04 11:33:00\n---\n\n $ n $  $ C_i $  $ L_i $ $ R $ $ R $  $ R $  $ C_i $  $ M $ $ \\times L_R $\n\n<!-- more -->\n\n### \n[BZOJ 2809](http://www.lydsy.com/JudgeOnline/problem.php?id=2809)\n\n### \n\n\n### \n![zyz ](images/zyz.png)\n\n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct LeftTree\n{\n\tLeftTree *lc, *rc;\n\tlong long dist, sum, x, size;\n\n\tLeftTree(long long x) : lc(NULL), rc(NULL), dist(0), sum(x), x(x), size(1) {}\n\n\t//  size  sum\n\tvoid maintain()\n\t{\n\t\tsize = (lc ? lc->size : 0) + (rc ? rc->size : 0) + 1;\n\t\tsum = (lc ? lc->sum : 0) + (rc ? rc->sum : 0) + x;\n\t}\n\n\t//  ab  a \n\tstatic LeftTree *merge(LeftTree *a, LeftTree *b)\n\t{\n\t\tif (!a) return b;\n\t\tif (!b) return a;\n\t\tif (a->x < b->x) std::swap(a, b); //  >= \n\t\n\t\t// \n\t\ta->rc = merge(a->rc, b);\n\n\t\t// \n\t\tif (!a->lc || a->lc->dist < a->rc->dist) std::swap(a->lc, a->rc);\n\n\t\t// \n\t\ta->dist = a->rc ? a->rc->dist + 1 : 0;\n\t\ta->maintain();\n\n\t\treturn a;\n\t}\n};\n\nstruct Node\n{\n\tstruct Edge *e;\n\tlong long c, l;\n\tLeftTree *lt;\n} N[MAXN + 1], *seq[MAXN + 1]; //  BFS \n\nstruct Edge\n{\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\ninline void bfs()\n{\n\tstd::queue<Node *> q;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\t//  BFS \n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next)\n\t\t{\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tlong long m;\n\tscanf(\"%d %lld\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint fa;\n\t\tscanf(\"%d\", &fa);\n\t\tif (fa) addEdge(fa, i);\n\n\t\tscanf(\"%lld %lld\", &N[i].c, &N[i].l);\n\n\t\t// \n\t\tN[i].lt = new LeftTree(N[i].c);\n\t}\n\n\tbfs();\n\n\tlong long ans = 0;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tNode *v = seq[i];\n\n\t\t// \n\t\tfor (Edge *e = v->e; e; e = e->next)\n\t\t{\n\t\t\tv->lt = LeftTree::merge(v->lt, e->t->lt);\n\t\t}\n\n\t\t//  <= M\n\t\twhile (v->lt->sum > m) v->lt = LeftTree::merge(v->lt->lc, v->lt->rc);\n\n\t\tans = std::max(ans, v->lt->size * v->l);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"apio2012-dispatching","published":1,"updated":"2017-01-04T08:26:53.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sm301n2ooxlq7v6oo1l"},{"title":"APIO2010 -  DP","date":"2016-05-13T12:16:00.000Z","_content":"\n $ n $  $ 1 $  $ n $ \n\n $ i $  $ x_i $  $ x $  $ x' = Ax ^ 2 + Bx + C $ $ A $$ B $$ C $ $ A < 0 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### \n $ f[i] $  $ i $ $ s_i $ \n\n $ j $ $ j + 1 $  $ i $ \n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n $ O(n ^ 2) $\n\n $ j = a $$ j = b $$ a > b $ $ a $  $ b $ \n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n\n\n $ 2 A s_i $\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","source":"_posts/apio2010-commando.md","raw":"title: APIO2010 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - DP\n  - \n  - \npermalink: apio2010-commando\ndate: 2016-05-13 20:16:00\n---\n\n $ n $  $ 1 $  $ n $ \n\n $ i $  $ x_i $  $ x $  $ x' = Ax ^ 2 + Bx + C $ $ A $$ B $$ C $ $ A < 0 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### \n $ f[i] $  $ i $ $ s_i $ \n\n $ j $ $ j + 1 $  $ i $ \n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n $ O(n ^ 2) $\n\n $ j = a $$ j = b $$ a > b $ $ a $  $ b $ \n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n\n\n $ 2 A s_i $\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","slug":"apio2010-commando","published":1,"updated":"2016-10-24T23:33:06.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9smd01naooxliy5evulj"},{"title":"APIO2009 - ","date":"2016-03-10T11:57:45.000Z","_content":"\n ATM  ATM \n\n ATM  ATM  ATM \n\n<!-- more -->\n\n### \n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### \nTarjan  DAG DAG \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### \n Dijkstra   Dijkstra \n\n()  Dijkstra\n\n('-')  Bellman-Ford  WA  \n\n \n\n OvO \n\n### \n _\n\n|             | |  | |\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","source":"_posts/apio2009-atm.md","raw":"title: APIO2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - \n  - Tarjan\n  - \n  - DAG\n  - \n  - Bellman-Ford\npermalink: apio2009-atm\ndate: 2016-03-10 19:57:45\n---\n\n ATM  ATM \n\n ATM  ATM  ATM \n\n<!-- more -->\n\n### \n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### \nTarjan  DAG DAG \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### \n Dijkstra   Dijkstra \n\n()  Dijkstra\n\n('-')  Bellman-Ford  WA  \n\n \n\n OvO \n\n### \n _\n\n|             | |  | |\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","slug":"apio2009-atm","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9smm01nhooxlgmz9268i"},{"title":"AHOI2014 - ","date":"2016-04-08T09:57:21.000Z","_content":"\n $ N $  $ 1 $  $ N $  $ i $  $ K_i $  $ 0 $ $ i $ \n\n $ 1 $  $ 1 $  $ 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 3876](http://www.lydsy.com/JudgeOnline/problem.php?id=3876)\n\n### \n DAG 1  1  DAG \n\n\n\n $ (u, v, w) $ $ (u, v, [1, \\infty], w) $  $ 1 $  $ u $ $ (u, 1, \\infty, 0) $  $ 1 $ \n\n $ (u, v, w) $ $ (S, v, 1, w) $ $ (u, T, 1, 0) $  $ v $ \n\n$ (u, T, 1, 0) $  $ (u, T, k_i, 0) $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2014-story.md","raw":"title: AHOI2014 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \n  - Edmonds-Karp\npermalink: ahoi2014-story\ndate: 2016-04-08 17:57:21\n---\n\n $ N $  $ 1 $  $ N $  $ i $  $ K_i $  $ 0 $ $ i $ \n\n $ 1 $  $ 1 $  $ 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 3876](http://www.lydsy.com/JudgeOnline/problem.php?id=3876)\n\n### \n DAG 1  1  DAG \n\n\n\n $ (u, v, w) $ $ (u, v, [1, \\infty], w) $  $ 1 $  $ u $ $ (u, 1, \\infty, 0) $  $ 1 $ \n\n $ (u, v, w) $ $ (S, v, 1, w) $ $ (u, T, 1, 0) $  $ v $ \n\n$ (u, T, 1, 0) $  $ (u, T, k_i, 0) $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"ahoi2014-story","published":1,"updated":"2016-12-25T01:57:05.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sn001nuooxlg7lxrwrf"},{"title":"AHOI2013 - ","date":"2016-12-30T02:58:00.000Z","_content":"\n $ n $  $ x \\in [l, r] $  $ a_i \\leq x \\leq b_i $  $ x $  $ x $ \n\n<!-- more -->\n\n### \n[BZOJ 3236](http://www.lydsy.com/JudgeOnline/problem.php?id=3236)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\n\nint blockSize;\n\nstruct Query {\n\tint l, r, a, b;\n\tstd::pair<int, int> *ans;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) return r < other.r;\n\t\telse return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\nint n, m, a[MAXN + 1];\n\nstruct BIT {\n\tint a[MAXN + MAXM * 2 + 1], n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t}\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n} bit1, bit2;\n\ninline std::pair<int, int> calc(int a, int b) {\n\treturn std::make_pair(bit1.query(a, b), bit2.query(a, b));\n}\n\nint cnt[MAXN + MAXM + 2 + 1];\ninline void extend(int l, int r, bool left, int d) {\n\tint pos = left ? l : r;\n\tbit1.update(a[pos], d);\n\tif (d == 1) {\n\t\tif (++cnt[a[pos]] == 1) bit2.update(a[pos], 1);\n\t} else {\n\t\tif (--cnt[a[pos]] == 0) bit2.update(a[pos], -1);\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (r < Q[i].r) extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) extend(l++, r, true, -1);\n\n\t\t*Q[i].ans = calc(Q[i].a, Q[i].b);\n\t}\n}\n\ninline void prepare() {\n\tstatic int set[MAXN + MAXM * 2 + 1];\n\tstd::copy(a + 1, a + n + 1, set + 1);\n\tfor (int i = 1; i <= m; i++) set[n + i] = Q[i].a;\n\tfor (int i = 1; i <= m; i++) set[n + m + i] = Q[i].b;\n\n\tstd::sort(set + 1, set + n + m * 2 + 1);\n\tint *end = std::unique(set + 1, set + n + m * 2 + 1);\n\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set;\n\n\tint cnt = end - (set + 1);\n\tbit1.init(cnt);\n\tbit2.init(cnt);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic std::pair<int, int> ans[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d %d %d\", &Q[i].l, &Q[i].r, &Q[i].a, &Q[i].b);\n\t\tQ[i].ans = &ans[i];\n\t}\n\n\tprepare();\n\n\tblockSize = floor(sqrt(n) + 1);\n\tstd::sort(Q + 1, Q + m + 1);\n\tsolve();\n\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2013-homework.md","raw":"title: AHOI2013 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \npermalink: ahoi2013-homework\ndate: 2016-12-30 10:58:00\n---\n\n $ n $  $ x \\in [l, r] $  $ a_i \\leq x \\leq b_i $  $ x $  $ x $ \n\n<!-- more -->\n\n### \n[BZOJ 3236](http://www.lydsy.com/JudgeOnline/problem.php?id=3236)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\n\nint blockSize;\n\nstruct Query {\n\tint l, r, a, b;\n\tstd::pair<int, int> *ans;\n\n\tbool operator<(const Query &other) const {\n\t\tif (l / blockSize == other.l / blockSize) return r < other.r;\n\t\telse return l / blockSize < other.l / blockSize;\n\t}\n} Q[MAXM + 1];\n\nint n, m, a[MAXN + 1];\n\nstruct BIT {\n\tint a[MAXN + MAXM * 2 + 1], n;\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t}\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n} bit1, bit2;\n\ninline std::pair<int, int> calc(int a, int b) {\n\treturn std::make_pair(bit1.query(a, b), bit2.query(a, b));\n}\n\nint cnt[MAXN + MAXM + 2 + 1];\ninline void extend(int l, int r, bool left, int d) {\n\tint pos = left ? l : r;\n\tbit1.update(a[pos], d);\n\tif (d == 1) {\n\t\tif (++cnt[a[pos]] == 1) bit2.update(a[pos], 1);\n\t} else {\n\t\tif (--cnt[a[pos]] == 0) bit2.update(a[pos], -1);\n\t}\n}\n\ninline void solve() {\n\tint l = 1, r = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\twhile (r < Q[i].r) extend(l, ++r, false, 1);\n\t\twhile (r > Q[i].r) extend(l, r--, false, -1);\n\n\t\twhile (l > Q[i].l) extend(--l, r, true, 1);\n\t\twhile (l < Q[i].l) extend(l++, r, true, -1);\n\n\t\t*Q[i].ans = calc(Q[i].a, Q[i].b);\n\t}\n}\n\ninline void prepare() {\n\tstatic int set[MAXN + MAXM * 2 + 1];\n\tstd::copy(a + 1, a + n + 1, set + 1);\n\tfor (int i = 1; i <= m; i++) set[n + i] = Q[i].a;\n\tfor (int i = 1; i <= m; i++) set[n + m + i] = Q[i].b;\n\n\tstd::sort(set + 1, set + n + m * 2 + 1);\n\tint *end = std::unique(set + 1, set + n + m * 2 + 1);\n\n\tfor (int i = 1; i <= n; i++) a[i] = std::lower_bound(set + 1, end, a[i]) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].a = std::lower_bound(set + 1, end, Q[i].a) - set;\n\tfor (int i = 1; i <= m; i++) Q[i].b = std::lower_bound(set + 1, end, Q[i].b) - set;\n\n\tint cnt = end - (set + 1);\n\tbit1.init(cnt);\n\tbit2.init(cnt);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic std::pair<int, int> ans[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d %d %d %d\", &Q[i].l, &Q[i].r, &Q[i].a, &Q[i].b);\n\t\tQ[i].ans = &ans[i];\n\t}\n\n\tprepare();\n\n\tblockSize = floor(sqrt(n) + 1);\n\tstd::sort(Q + 1, Q + m + 1);\n\tsolve();\n\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\treturn 0;\n}\n```\n","slug":"ahoi2013-homework","published":1,"updated":"2016-12-30T03:08:09.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9snb01o3ooxl45snx359"},{"title":"AHOI2013 - ","date":"2016-09-29T13:07:00.000Z","_content":"\n $ n $  $ T_i $  $ i $ \n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) - 2 \\times \\mathrm{lcp}(T_i, T_j) $$\n\n<!-- more -->\n\n### \n[BZOJ 3238](http://www.lydsy.com/JudgeOnline/problem.php?id=3238)\n\n### \n\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) = \\sum\\limits_{i = 2} ^ n \\frac{i(i - 1)}{2} + i(i - 1) $$\n\n\n\n$$ -2 \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{lcp}(T_i, T_j) $$\n\n LCP \n\n $ \\mathrm{height}[] $  $ a_i $ \n\n $ a_i $ ********$ a_i $ \n\n $ a_i $  $ l_i $  $ a_i $  $ r_i $  $ a_i $ \n\n$$ (l_i + 1) \\times (r_i + 1) \\times a_i $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 500000;\n\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\nunsigned long long l[MAXN], r[MAXN];\nchar s[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", &s[sa[i]]);\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n}\n\n/*\ninline int lcp(const int i, const int j) {\n\t/ *\n\tint a = rk[i], b = rk[j], ans = n;\n\tif (a > b) std::swap(a, b);\n\tfor (int i = a + 1; i <= b; i++) ans = std::min(ans, ht[i]);\n\t// printf(\"- %d %d => %d\\n\", a + 1, b, ans);\n\treturn ans;\n\t* /\n\n\tint ans = 0;\n\twhile (s[i + ans] == s[j + ans] && i + ans < n && j + ans < n) ans++;\n\treturn ans;\n}\n*/\n\ninline void prepare() {\n\tstd::stack<int> s;\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (!s.empty() && ht[s.top()] > ht[i]) s.pop();\n\t\tl[i] = s.empty() ? i - 1 : i - s.top() - 1;\n\t\ts.push(i);\n\t}\n\twhile (!s.empty()) s.pop();\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\twhile (!s.empty() && ht[s.top()] >= ht[i]) s.pop();\n\t\tr[i] = s.empty() ? n - i - 1 : s.top() - i - 1;\n\t\ts.push(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsuffixArray();\n\n\tunsigned long long sumLcp = 0;\n\t/*\n\tfor (int i = 1; i < n; i++) for (int j = i; j < n; j++) {\n\t\tint min = n;\n\t\tfor (int k = i; k <= j; k++) min = std::min(min, ht[k]);\n\t\tsumLcp += min;\n\t}\n\t*/\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tsumLcp += lcp(i, j);\n\t\t}\n\t}\n\t*/\n\n\tprepare();\n\t// /*\n\tfor (int i = 1; i < n; i++) {\n\t\t// printf(\"%d: %d %d\\n\", i, l[i], r[i]);\n\t\tsumLcp += static_cast<unsigned long long>(l[i] + 2) * (r[i] + 1) * ht[i];\n\t}\n\t// */\n\n\tunsigned long long sum = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tunsigned long long t = static_cast<unsigned long long>(1 + (i - 1)) * (i - 1) / 2 + static_cast<unsigned long long>(i) * (i - 1);\n\t\t// printf(\"- %lld\\n\", t);\n\t\tsum += t;\n\t\t// printf(\"sum = %llu\\n\", sum);\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t// printf(\"- %d %d\\n\", n - i, n - j);\n\t\t\tsum += n - i + n - j;\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%llu\\n\", sum - 2 * sumLcp);\n\n\treturn 0;\n}\n```","source":"_posts/ahoi2013-diff.md","raw":"title: AHOI2013 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \npermalink: ahoi2013-diff\ndate: 2016-09-29 21:07:00\n---\n\n $ n $  $ T_i $  $ i $ \n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) - 2 \\times \\mathrm{lcp}(T_i, T_j) $$\n\n<!-- more -->\n\n### \n[BZOJ 3238](http://www.lydsy.com/JudgeOnline/problem.php?id=3238)\n\n### \n\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) = \\sum\\limits_{i = 2} ^ n \\frac{i(i - 1)}{2} + i(i - 1) $$\n\n\n\n$$ -2 \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{lcp}(T_i, T_j) $$\n\n LCP \n\n $ \\mathrm{height}[] $  $ a_i $ \n\n $ a_i $ ********$ a_i $ \n\n $ a_i $  $ l_i $  $ a_i $  $ r_i $  $ a_i $ \n\n$$ (l_i + 1) \\times (r_i + 1) \\times a_i $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 500000;\n\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\nunsigned long long l[MAXN], r[MAXN];\nchar s[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", &s[sa[i]]);\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n}\n\n/*\ninline int lcp(const int i, const int j) {\n\t/ *\n\tint a = rk[i], b = rk[j], ans = n;\n\tif (a > b) std::swap(a, b);\n\tfor (int i = a + 1; i <= b; i++) ans = std::min(ans, ht[i]);\n\t// printf(\"- %d %d => %d\\n\", a + 1, b, ans);\n\treturn ans;\n\t* /\n\n\tint ans = 0;\n\twhile (s[i + ans] == s[j + ans] && i + ans < n && j + ans < n) ans++;\n\treturn ans;\n}\n*/\n\ninline void prepare() {\n\tstd::stack<int> s;\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (!s.empty() && ht[s.top()] > ht[i]) s.pop();\n\t\tl[i] = s.empty() ? i - 1 : i - s.top() - 1;\n\t\ts.push(i);\n\t}\n\twhile (!s.empty()) s.pop();\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\twhile (!s.empty() && ht[s.top()] >= ht[i]) s.pop();\n\t\tr[i] = s.empty() ? n - i - 1 : s.top() - i - 1;\n\t\ts.push(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsuffixArray();\n\n\tunsigned long long sumLcp = 0;\n\t/*\n\tfor (int i = 1; i < n; i++) for (int j = i; j < n; j++) {\n\t\tint min = n;\n\t\tfor (int k = i; k <= j; k++) min = std::min(min, ht[k]);\n\t\tsumLcp += min;\n\t}\n\t*/\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tsumLcp += lcp(i, j);\n\t\t}\n\t}\n\t*/\n\n\tprepare();\n\t// /*\n\tfor (int i = 1; i < n; i++) {\n\t\t// printf(\"%d: %d %d\\n\", i, l[i], r[i]);\n\t\tsumLcp += static_cast<unsigned long long>(l[i] + 2) * (r[i] + 1) * ht[i];\n\t}\n\t// */\n\n\tunsigned long long sum = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tunsigned long long t = static_cast<unsigned long long>(1 + (i - 1)) * (i - 1) / 2 + static_cast<unsigned long long>(i) * (i - 1);\n\t\t// printf(\"- %lld\\n\", t);\n\t\tsum += t;\n\t\t// printf(\"sum = %llu\\n\", sum);\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t// printf(\"- %d %d\\n\", n - i, n - j);\n\t\t\tsum += n - i + n - j;\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%llu\\n\", sum - 2 * sumLcp);\n\n\treturn 0;\n}\n```","slug":"ahoi2013-diff","published":1,"updated":"2016-09-29T13:25:07.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sno01o9ooxlgt1j214s"},{"title":"AHOI2008 - ","date":"2016-03-07T12:36:46.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### \n LCA \n\n LCA  LCA   qwq\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2008-meet.md","raw":"title: AHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \npermalink: ahoi2008-meet\ndate: 2016-03-07 20:36:46\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### \n LCA \n\n LCA  LCA   qwq\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"ahoi2008-meet","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sny01ohooxlry34pi7o"},{"title":"AC ","date":"2016-09-18T23:04:00.000Z","_content":"\nAC \n\n<!-- more -->\n\n### \n>  Trie  Trie \n\n Trie  KMP  $ O(n) $ \n\n### \n KMP  $ i $  $ j $ $ \\mathrm{fail}(i) = j $\n\n $ \\mathrm{fail}(i) = j $    $ j $  $ i $ ****\n\n Trie  $ j $ $ j $  $ i $ ****\n\n### \n![AC ](acam-notes/acam.svg)\n\n $ i $  $ i' $$ i $  $ c $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(i) $  \n $ \\mathrm{fail}(7) = 1, \\mathrm{fail}(8) = 2 $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(\\mathrm{fail}(i')) $   $ \\mathrm{fail}(i) $   \n $ \\mathrm{fail}(3) = 0 $\n\n### \n $ i $ $ c $ $ i $  $ c $ $ \\mathrm{fail}(i) $  $ c $ \n\n $ i $ $ \\mathrm{fail}(i) $ \n\n`a`  `bac`  AC \n![AC ](acam-notes/acam2.svg)\n\n 3  1 `ba`  3 1   $ \\mathrm{next}(i) $  $ i $  $ \\mathrm{next}(3) = 1 $\n\n\n\n   $ \\mathrm{fail}(i) $  $ \\mathrm{next}(i) = \\mathrm{fail}(i) $ $ \\mathrm{next}(i) = \\mathrm{next}(\\mathrm{fail}(i)) $\n\n### \n\n\n****\n\n $ i $ $ c $  $ c $  $ \\mathrm{fail}(i) $  Trie **Trie **\n\n### \n\n\n 2016  12  27 \n\n![zyz ](images/zyz.png)\n\n```c++\nconst int CHARSET_SIZE = 'z' - 'a' + 1; // \nconst char BASE_CHAR = 'a'; // \n\nstruct Trie\n{\n\tstruct Node\n\t{\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n\t\tint ans;\n\n\t\tNode(bool isWord = false) : next(NULL), fail(NULL), isWord(isWord)\n\t\t{\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply()\n\t\t{\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end)\n\t{\n\t\t//  Splay\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// \n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build()\n\t{\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root; // \n\t\troot->next = NULL;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\tNode *&c = v->c[i];\n\n\t\t\t\t//  Trie \n\t\t\t\tif (!c)\n\t\t\t\t{\n\t\t\t\t\t//  v == root v->fail == rootc  v->fail->c[i] \n                    c = v == root ? root : v->fail->c[i];\n                    continue;\n                }\n\t\t\t\tNode *u = v->fail;\n\n\t\t\t\t//  KMP \n\t\t\t\t// while (u != root && !u->c[i]) u = u->fail; //  Trie \n\n\t\t\t\t//  v == root\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\n\t\t\t\t//  fail \n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end)\n\t{\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// \n\t\t\tv = v->c[*p];\n\n\t\t\t// \n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply(); //  else if\n\t\t}\n\t}\n};\n```\n","source":"_posts/acam-notes.md","raw":"title: AC \ncategories: OI\ntags: \n  - AC \n  - \n  - \n  - \npermalink: acam-notes\ndate: 2016-09-19 07:04:00\n---\n\nAC \n\n<!-- more -->\n\n### \n>  Trie  Trie \n\n Trie  KMP  $ O(n) $ \n\n### \n KMP  $ i $  $ j $ $ \\mathrm{fail}(i) = j $\n\n $ \\mathrm{fail}(i) = j $    $ j $  $ i $ ****\n\n Trie  $ j $ $ j $  $ i $ ****\n\n### \n![AC ](acam-notes/acam.svg)\n\n $ i $  $ i' $$ i $  $ c $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(i) $  \n $ \\mathrm{fail}(7) = 1, \\mathrm{fail}(8) = 2 $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(\\mathrm{fail}(i')) $   $ \\mathrm{fail}(i) $   \n $ \\mathrm{fail}(3) = 0 $\n\n### \n $ i $ $ c $ $ i $  $ c $ $ \\mathrm{fail}(i) $  $ c $ \n\n $ i $ $ \\mathrm{fail}(i) $ \n\n`a`  `bac`  AC \n![AC ](acam-notes/acam2.svg)\n\n 3  1 `ba`  3 1   $ \\mathrm{next}(i) $  $ i $  $ \\mathrm{next}(3) = 1 $\n\n\n\n   $ \\mathrm{fail}(i) $  $ \\mathrm{next}(i) = \\mathrm{fail}(i) $ $ \\mathrm{next}(i) = \\mathrm{next}(\\mathrm{fail}(i)) $\n\n### \n\n\n****\n\n $ i $ $ c $  $ c $  $ \\mathrm{fail}(i) $  Trie **Trie **\n\n### \n\n\n 2016  12  27 \n\n![zyz ](images/zyz.png)\n\n```c++\nconst int CHARSET_SIZE = 'z' - 'a' + 1; // \nconst char BASE_CHAR = 'a'; // \n\nstruct Trie\n{\n\tstruct Node\n\t{\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n\t\tint ans;\n\n\t\tNode(bool isWord = false) : next(NULL), fail(NULL), isWord(isWord)\n\t\t{\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply()\n\t\t{\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end)\n\t{\n\t\t//  Splay\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// \n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build()\n\t{\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root; // \n\t\troot->next = NULL;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\tNode *&c = v->c[i];\n\n\t\t\t\t//  Trie \n\t\t\t\tif (!c)\n\t\t\t\t{\n\t\t\t\t\t//  v == root v->fail == rootc  v->fail->c[i] \n                    c = v == root ? root : v->fail->c[i];\n                    continue;\n                }\n\t\t\t\tNode *u = v->fail;\n\n\t\t\t\t//  KMP \n\t\t\t\t// while (u != root && !u->c[i]) u = u->fail; //  Trie \n\n\t\t\t\t//  v == root\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\n\t\t\t\t//  fail \n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end)\n\t{\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// \n\t\t\tv = v->c[*p];\n\n\t\t\t// \n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply(); //  else if\n\t\t}\n\t}\n};\n```\n","slug":"acam-notes","published":1,"updated":"2017-01-02T07:03:44.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9so601ooooxluh670jtd"},{"title":" 2016Play with array - ","date":"2016-05-27T15:55:00.000Z","_content":"\n $ n $ \n\n1.  $ a_r $  $ a_l $ \n2.  $ [l,\\ r] $  $ k $ \n\n<!-- more -->\n\n### \n $ O(\\sqrt n) $ \n\n $ [l,\\ r] $  $ [1,\\ r] $  $ [1,\\ l - 1] $ \n\n $ O(n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\n#define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__)\n\nconst int MAXN = 100000;\nconst int MAXN_SQRT = 316 + 1;\nconst int MAXM = 100000;\n\nint n, m, a[MAXN];\n\nstruct BlockList {\n\tstruct Block {\n\t\tstd::list<int> l;\n\t\tstd::vector<int> sum;\n\n\t\tBlock() : sum(n) {}\n\n\t\tinline int left(const int k, const int pos) {\n\t\t\tint res = 0;\n\t\t\tstd::list<int>::const_iterator it = l.begin();\n\t\t\tfor (int i = 0; i <= pos; i++) if (*it++ == k) res++;\n\t\t\treturn res;\n\t\t}\n\t};\n\tstd::list<Block> blocks;\n\tint blockCount, blockSize;\n\n\tinline void build(const int *a, const int n) {\n\t\tblockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast<double>(n) / blockCount);\n\t\t// dprintf(\"BlockList::build(): blockCount = %d, blockSize = %d\\n\", blockCount, blockSize);\n\t\tblocks.resize(blockCount);\n\t\tstd::list<Block>::iterator b = blocks.begin();\n\t\tfor (int i = 0, j = 0; i < blockCount; i++, b++) {\n\t\t\tfor (int k = 0; k <= blockSize && j < n; k++, j++) {\n\t\t\t\tb->sum[a[j]]++;\n\t\t\t\tb->l.push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int erase(int pos) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tconst int x = *it;\n\t\t\t\tb->sum[*it]--;\n\t\t\t\tb->l.erase(it);\n\t\t\t\treturn x;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline void insert(int pos, const int x) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tb->sum[x]++;\n\t\t\t\tb->l.insert(it, x);\n\t\t\t\treturn;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline int query(int pos, const int k) {\n\t\tint ans = 0;\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tans += b->left(k, pos);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpos -= b->l.size();\n\t\t\t\tans += b->sum[k];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline void mergeNext(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator next = b;\n\t\tnext++;\n\t\tif (next == blocks.end()) return;\n\t\tfor (std::list<int>::const_iterator it = next->l.begin(); it != next->l.end(); it++) {\n\t\t\tb->l.push_back(*it);\n\t\t\tb->sum[*it]++;\n\t\t}\n\t\tblocks.erase(next);\n\t}\n\n\tinline void split(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator newBlock = blocks.insert(b, Block());\n\t\tfor (int i = 0; i < b->l.size() / 2; i++) {\n\t\t\tconst int &x = b->l.front();\n\t\t\tnewBlock->l.push_back(x);\n\t\t\tnewBlock->sum[x]++;\n\t\t\tb->sum[x]--;\n\t\t\tb->l.pop_front();\n\t\t}\n\t}\n\n\tinline void maintain() {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (b->l.size() <= blockSize / 2) mergeNext(b);\n\t\t\telse if (b->l.size() >= blockSize * 2) split(b);\n\t\t}\n\t}\n\n\tinline void print() {\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tdprintf(\"blockSize = %d\\n\", b->l.size());\n\t\t}\n\n\t\treturn;\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tfor (std::list<int>::const_iterator it = b->l.begin(); it != b->l.end(); it++) {\n\t\t\t\tdprintf(\"%d \", *it + 1);\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%c\", '\\n');\n\t}\n} list;\n\nint main() {\n\t// freopen(\"array.in\", \"r\", stdin);\n\t// freopen(\"array.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]), a[i]--;\n\t}\n\n\tlist.build(a, n);\n\n\t// list.print();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r), l--, r--;\n\t\tif (t == 1) {\n\t\t\tint x = list.erase(r);\n\t\t\tlist.insert(l, x);\n\t\t\t// list.print();\n\t\t\tlist.maintain();\n\t\t\t// list.print();\n\t\t\t// dprintf(\"%c\", '\\n');\n\t\t} else {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k), k--;\n\t\t\tint R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k);\n\t\t\tprintf(\"%d\\n\", R - L);\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\t// list.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/20160527-array.md","raw":"title:  2016Play with array - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: 20160527-array\ndate: 2016-05-27 23:55:00\n---\n\n $ n $ \n\n1.  $ a_r $  $ a_l $ \n2.  $ [l,\\ r] $  $ k $ \n\n<!-- more -->\n\n### \n $ O(\\sqrt n) $ \n\n $ [l,\\ r] $  $ [1,\\ r] $  $ [1,\\ l - 1] $ \n\n $ O(n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\n#define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__)\n\nconst int MAXN = 100000;\nconst int MAXN_SQRT = 316 + 1;\nconst int MAXM = 100000;\n\nint n, m, a[MAXN];\n\nstruct BlockList {\n\tstruct Block {\n\t\tstd::list<int> l;\n\t\tstd::vector<int> sum;\n\n\t\tBlock() : sum(n) {}\n\n\t\tinline int left(const int k, const int pos) {\n\t\t\tint res = 0;\n\t\t\tstd::list<int>::const_iterator it = l.begin();\n\t\t\tfor (int i = 0; i <= pos; i++) if (*it++ == k) res++;\n\t\t\treturn res;\n\t\t}\n\t};\n\tstd::list<Block> blocks;\n\tint blockCount, blockSize;\n\n\tinline void build(const int *a, const int n) {\n\t\tblockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast<double>(n) / blockCount);\n\t\t// dprintf(\"BlockList::build(): blockCount = %d, blockSize = %d\\n\", blockCount, blockSize);\n\t\tblocks.resize(blockCount);\n\t\tstd::list<Block>::iterator b = blocks.begin();\n\t\tfor (int i = 0, j = 0; i < blockCount; i++, b++) {\n\t\t\tfor (int k = 0; k <= blockSize && j < n; k++, j++) {\n\t\t\t\tb->sum[a[j]]++;\n\t\t\t\tb->l.push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int erase(int pos) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tconst int x = *it;\n\t\t\t\tb->sum[*it]--;\n\t\t\t\tb->l.erase(it);\n\t\t\t\treturn x;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline void insert(int pos, const int x) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tb->sum[x]++;\n\t\t\t\tb->l.insert(it, x);\n\t\t\t\treturn;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline int query(int pos, const int k) {\n\t\tint ans = 0;\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tans += b->left(k, pos);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpos -= b->l.size();\n\t\t\t\tans += b->sum[k];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline void mergeNext(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator next = b;\n\t\tnext++;\n\t\tif (next == blocks.end()) return;\n\t\tfor (std::list<int>::const_iterator it = next->l.begin(); it != next->l.end(); it++) {\n\t\t\tb->l.push_back(*it);\n\t\t\tb->sum[*it]++;\n\t\t}\n\t\tblocks.erase(next);\n\t}\n\n\tinline void split(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator newBlock = blocks.insert(b, Block());\n\t\tfor (int i = 0; i < b->l.size() / 2; i++) {\n\t\t\tconst int &x = b->l.front();\n\t\t\tnewBlock->l.push_back(x);\n\t\t\tnewBlock->sum[x]++;\n\t\t\tb->sum[x]--;\n\t\t\tb->l.pop_front();\n\t\t}\n\t}\n\n\tinline void maintain() {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (b->l.size() <= blockSize / 2) mergeNext(b);\n\t\t\telse if (b->l.size() >= blockSize * 2) split(b);\n\t\t}\n\t}\n\n\tinline void print() {\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tdprintf(\"blockSize = %d\\n\", b->l.size());\n\t\t}\n\n\t\treturn;\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tfor (std::list<int>::const_iterator it = b->l.begin(); it != b->l.end(); it++) {\n\t\t\t\tdprintf(\"%d \", *it + 1);\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%c\", '\\n');\n\t}\n} list;\n\nint main() {\n\t// freopen(\"array.in\", \"r\", stdin);\n\t// freopen(\"array.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]), a[i]--;\n\t}\n\n\tlist.build(a, n);\n\n\t// list.print();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r), l--, r--;\n\t\tif (t == 1) {\n\t\t\tint x = list.erase(r);\n\t\t\tlist.insert(l, x);\n\t\t\t// list.print();\n\t\t\tlist.maintain();\n\t\t\t// list.print();\n\t\t\t// dprintf(\"%c\", '\\n');\n\t\t} else {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k), k--;\n\t\t\tint R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k);\n\t\t\tprintf(\"%d\\n\", R - L);\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\t// list.print();\n\n\treturn 0;\n}\n```\n","slug":"20160527-array","published":1,"updated":"2016-05-27T16:14:44.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9soh01ouooxl31ydifdg"},{"title":" - ","date":"2016-04-04T02:35:52.000Z","_content":"\n $ 1 \\to n $\n\n<!-- more -->\n\n### \n\n\n\n\n### 40 + DP\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160404-theory.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  -  DP\n  - \n  - \n  - Dinic\n  - \npermalink: 20160404-theory\ndate: 2016-04-04 10:35:52\n---\n\n $ 1 \\to n $\n\n<!-- more -->\n\n### \n\n\n\n\n### 40 + DP\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160404-theory","published":1,"updated":"2016-10-24T23:32:53.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sor01p2ooxlmqnul7js"},{"title":" - DP","date":"2016-04-01T13:24:45.000Z","_content":"\n $ N $  $ M $  $ K $  $ M $ \n\n<!-- more -->\n\n### \n $ f_{i, j} $  i  j \n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n $ 10 ^ 5 $  $ (N, K) $  $ f_K $  $ N $ \n\n $ K = 1, 2, 3 $ \n\n $ K = 1 $  $ N $  \n $ K = 2 $  $ x $\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n $ K = 3 $  1 ~ 3  $ f $  $ 2 \\times 10 ^ 6 $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/20160331-naive.md","raw":"title:  - DP\ncategories: OI\ntags: \n  - \n  - DP\n  - \npermalink: 20160331-naive\ndate: 2016-04-01 21:24:45\n---\n\n $ N $  $ M $  $ K $  $ M $ \n\n<!-- more -->\n\n### \n $ f_{i, j} $  i  j \n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n $ 10 ^ 5 $  $ (N, K) $  $ f_K $  $ N $ \n\n $ K = 1, 2, 3 $ \n\n $ K = 1 $  $ N $  \n $ K = 2 $  $ x $\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n $ K = 3 $  1 ~ 3  $ f $  $ 2 \\times 10 ^ 6 $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"20160331-naive","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sp101pbooxlgpu4kmkq"},{"title":" - ","date":"2016-03-20T14:50:45.000Z","_content":"\n $ n $  $ S $ $ a + b $$ a $$ b $  $ S $ $ k $  $ S $ \n\n<!-- more -->\n\n### \n$ m1 $ $ m2 $ $ s $ \n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-set.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: 20160319-set\ndate: 2016-03-20 22:50:45\n---\n\n $ n $  $ S $ $ a + b $$ a $$ b $  $ S $ $ k $  $ S $ \n\n<!-- more -->\n\n### \n$ m1 $ $ m2 $ $ s $ \n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-set","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9sp901phooxlc2uv4z47"},{"title":" -  + ","date":"2016-03-20T14:58:12.000Z","_content":"\n $ N $ \n\n<!-- more -->\n\n### \n\n\n\n\n\n\n\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-candy.md","raw":"title:  -  + \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: 20160319-candy\ndate: 2016-03-20 22:58:12\n---\n\n $ N $ \n\n<!-- more -->\n\n### \n\n\n\n\n\n\n\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-candy","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlg9spg01pnooxlq77ex1mq"}],"PostAsset":[{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"hotkey.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/network.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"network.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/port.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"port.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"screenfetch.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/share.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"share.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","post":"cixlg9r9g0034ooxlb1zybm8l","slug":"terminal.png","modified":1},{"_id":"source/_posts/uva-11538/cells.png","post":"cixlg9rac0041ooxl472q7ojl","slug":"cells.png","modified":1},{"_id":"source/_posts/tree-chain-split-notes/1.svg","post":"cixlg9rbn0060ooxlf67buek0","slug":"1.svg","modified":1},{"_id":"source/_posts/splay-notes-1/splay.png","post":"cixlg9rds0094ooxlo8t6v8ua","slug":"splay.png","modified":1},{"_id":"source/_posts/sdoi2016-game/line.png","post":"cixlg9rf800c7ooxlwt64odd7","slug":"line.png","modified":1},{"_id":"source/_posts/sdoi2016-game/tree.png","post":"cixlg9rf800c7ooxlwt64odd7","slug":"tree.png","modified":1},{"_id":"source/_posts/noip2016-running/linear-backward1.svg","post":"cixlg9rkc00l0ooxl3gg8o7tc","slug":"linear-backward1.svg","modified":1},{"_id":"source/_posts/noip2016-running/linear-forward1.svg","post":"cixlg9rkc00l0ooxl3gg8o7tc","slug":"linear-forward1.svg","modified":1},{"_id":"source/_posts/noip2016-running/linear-forward2.svg","post":"cixlg9rkc00l0ooxl3gg8o7tc","slug":"linear-forward2.svg","modified":1},{"_id":"source/_posts/noi2008-candy/1.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"1.svg","modified":1},{"_id":"source/_posts/noi2008-candy/2.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"2.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/2.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"2.svg","modified":1},{"_id":"source/_posts/noi2008-candy/3.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"3.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/3.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"3.svg","modified":1},{"_id":"source/_posts/noi2008-candy/4.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"4.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/4.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"4.svg","modified":1},{"_id":"source/_posts/noi2008-candy/5.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"5.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/5.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"5.svg","modified":1},{"_id":"source/_posts/noi2008-candy/6.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"6.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/6.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"6.svg","modified":1},{"_id":"source/_posts/noi2008-candy/7.ggb","post":"cixlg9rq200sfooxly4o781l4","slug":"7.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/7.svg","post":"cixlg9rq200sfooxly4o781l4","slug":"7.svg","modified":1},{"_id":"source/_posts/node-devide-notes/tree1.svg","post":"cixlg9rrt00tjooxl26si2srg","slug":"tree1.svg","modified":1},{"_id":"source/_posts/node-devide-notes/tree2.svg","post":"cixlg9rrt00tjooxl26si2srg","slug":"tree2.svg","modified":1},{"_id":"source/_posts/manacher-notes/1.svg","post":"cixlg9rso00unooxlniigyuwv","slug":"1.svg","modified":1},{"_id":"source/_posts/manacher-notes/2.svg","post":"cixlg9rso00unooxlniigyuwv","slug":"2.svg","modified":1},{"_id":"source/_posts/manacher-notes/3.svg","post":"cixlg9rso00unooxlniigyuwv","slug":"3.svg","modified":1},{"_id":"source/_posts/here-the-best-sight/1.jpg","post":"cixlg9rxo010xooxlim11g2sa","slug":"1.jpg","modified":1},{"_id":"source/_posts/here-the-best-sight/2.jpg","post":"cixlg9rxo010xooxlim11g2sa","slug":"2.jpg","modified":1},{"_id":"source/_posts/here-the-best-sight/3.jpg","post":"cixlg9rxo010xooxlim11g2sa","slug":"3.jpg","modified":1},{"_id":"source/_posts/haoi2006-sequence/1.svg","post":"cixlg9s11014oooxlk15ca9gr","slug":"1.svg","modified":1},{"_id":"source/_posts/haoi2006-sequence/2.svg","post":"cixlg9s11014oooxlk15ca9gr","slug":"2.svg","modified":1},{"_id":"source/_posts/geometry-notes/1.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"1.ggb","modified":1},{"_id":"source/_posts/geometry-notes/1.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"1.svg","modified":1},{"_id":"source/_posts/geometry-notes/2.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"2.ggb","modified":1},{"_id":"source/_posts/geometry-notes/2.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"2.svg","modified":1},{"_id":"source/_posts/geometry-notes/3.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"3.ggb","modified":1},{"_id":"source/_posts/geometry-notes/3.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"3.svg","modified":1},{"_id":"source/_posts/geometry-notes/4.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"4.ggb","modified":1},{"_id":"source/_posts/geometry-notes/4.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"4.svg","modified":1},{"_id":"source/_posts/geometry-notes/5.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"5.ggb","modified":1},{"_id":"source/_posts/geometry-notes/5.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"5.svg","modified":1},{"_id":"source/_posts/geometry-notes/6.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"6.ggb","modified":1},{"_id":"source/_posts/geometry-notes/6.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"6.svg","modified":1},{"_id":"source/_posts/docker-sandbox-judger/image.svg","post":"cixlg9s3i016mooxlfujpjwv5","slug":"image.svg","modified":1},{"_id":"source/_posts/cf-716e/example.svg","post":"cixlg9sa801d6ooxltw9m0m0q","slug":"example.svg","modified":1},{"_id":"source/_posts/bzoj-3196/lemon.png","post":"cixlg9seb01h1ooxlnh5z10y5","slug":"lemon.png","modified":1},{"_id":"source/_posts/bzoj-2683/cdq.png","post":"cixlg9sf701htooxlxaoc9nf8","slug":"cdq.png","modified":1},{"_id":"source/_posts/at-the-cross-of-time/mzr.lrc","post":"cixlg9slv01n0ooxlauq8af31","slug":"mzr.lrc","modified":1},{"_id":"source/_posts/acam-notes/acam.svg","post":"cixlg9so601ooooxluh670jtd","slug":"acam.svg","modified":1},{"_id":"source/_posts/acam-notes/acam2.svg","post":"cixlg9so601ooooxluh670jtd","slug":"acam2.svg","modified":1},{"_id":"source/_posts/geometry-notes/7.ggb","slug":"7.ggb","post":"cixlg9s1m0157ooxlhi08t0uw","modified":1},{"_id":"source/_posts/geometry-notes/7.svg","post":"cixlg9s1m0157ooxlhi08t0uw","slug":"7.svg","modified":1}],"PostCategory":[{"post_id":"cixlg9r760000ooxlll2vxp8k","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r7h0007ooxlh0ippyz3"},{"post_id":"cixlg9r7v000gooxlu86flrpb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r7w000hooxlxqgbme59"},{"post_id":"cixlg9r80000qooxls99odt0h","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r81000rooxl2wf5fw80"},{"post_id":"cixlg9r880012ooxly9xlvj0j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r890013ooxlp6ujfri2"},{"post_id":"cixlg9r8b001aooxlsxcj7zkb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8d001booxl75wyt7hl"},{"post_id":"cixlg9r8j001gooxl5xhuodpp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8l001hooxlep3n3d6h"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8q001nooxl773gq2bw"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8u001yooxluc8ow30n"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r8z0028ooxl6b1jl5jp"},{"post_id":"cixlg9r92002iooxlczrdlyzt","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r93002jooxlrgb41mo8"},{"post_id":"cixlg9r95002oooxls8l15ust","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r96002pooxlone2270z"},{"post_id":"cixlg9r99002wooxlw9wlizgc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9r9e002xooxlmoycnemw"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","category_id":"cixlg9r9h0035ooxlomt7421m","_id":"cixlg9r9j003cooxl5vely9y6"},{"post_id":"cixlg9ra4003jooxlk639w24c","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ra5003kooxlsbuhkspi"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9raa003uooxlnokbieza"},{"post_id":"cixlg9rac0041ooxl472q7ojl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rae0042ooxliq8nmfx3"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rao0048ooxlhqxol1xa"},{"post_id":"cixlg9raq004fooxlyk872vzc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rar004gooxlp7ybxms7"},{"post_id":"cixlg9rat004nooxl0udxuz2r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rau004oooxljweexac3"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ray0050ooxlhav9xg7y"},{"post_id":"cixlg9rb10057ooxl45cl24ny","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rb30058ooxla5ymmk3d"},{"post_id":"cixlg9rb5005fooxl4xju7de7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rb7005gooxlk10duyg9"},{"post_id":"cixlg9rbg005rooxlwmmodxef","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rbi005sooxlz3qvzh7a"},{"post_id":"cixlg9rbn0060ooxlf67buek0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rbp0061ooxlcwwiaqrz"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rbz006aooxlqx8ms5oe"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rc3006iooxlrg219bkj"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rc7006qooxlpubrcom4"},{"post_id":"cixlg9rcc006zooxl7j0zh7n1","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9rcf0071ooxlcwnj9fpj"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rcl0073ooxlyv6av57i"},{"post_id":"cixlg9rcq007cooxll7931685","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rcs007dooxlipr9egv0"},{"post_id":"cixlg9rcu007kooxl669tzoxp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rcv007looxliu2vnp0h"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rcy007tooxl9h8a27as"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rd40081ooxlwfhjqwty"},{"post_id":"cixlg9rd70089ooxleh439i2r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rd9008aooxldtcgdg52"},{"post_id":"cixlg9rdb008fooxlmuqr73ki","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdh008gooxlnjtah2mr"},{"post_id":"cixlg9rdj008looxlpanbg3cl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdl008mooxlgg4hh4sh"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdo008sooxl7ty9optf"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdr008yooxl1a8ypolq"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdu0095ooxllz9r1htn"},{"post_id":"cixlg9rdx009booxlch8h998g","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rdy009cooxlm55jye3f"},{"post_id":"cixlg9re0009hooxl4o7msif9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9re1009iooxlln3w83o7"},{"post_id":"cixlg9re3009oooxl9oqc1j4j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9re4009pooxlzuqq35kg"},{"post_id":"cixlg9re6009tooxlxwkgks62","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9re8009uooxlnv5bsiwz"},{"post_id":"cixlg9re9009yooxl765qsyac","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9reb009zooxlz75znryj"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ref00a7ooxljq82dmof"},{"post_id":"cixlg9reh00adooxl81or26s2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rei00aeooxlx9cmct7d"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ren00aoooxljtf1w8l6"},{"post_id":"cixlg9req00azooxln3o0605f","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9rer00b0ooxl1wx594pf"},{"post_id":"cixlg9res00b1ooxl1tynortw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ret00b2ooxlycbufpa4"},{"post_id":"cixlg9rev00bbooxlauiqllaa","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rew00bcooxlb5z4supy"},{"post_id":"cixlg9rf000bqooxlxoy869wq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rf100brooxlwsfto2ot"},{"post_id":"cixlg9rf400byooxl5qvktlmq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rf600bzooxl2fml66ay"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rf900c8ooxliyl6ua7f"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rfk00cjooxlvkh0r1g4"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rfp00ctooxlssyrsxq3"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rfu00d7ooxll0h67hz4"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rfx00ddooxlb7b3mq78"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rg200doooxlvpwqmnlk"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rg600dyooxlt73oh5cb"},{"post_id":"cixlg9rg800e5ooxlwalebfg2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rga00e6ooxlo8z4ktfi"},{"post_id":"cixlg9rgb00eaooxla477j5s2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgc00ebooxlolhlk4y2"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgg00eiooxl5v4hqtgz"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgj00eoooxlhv8g5y4v"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgp00ezooxlwylhcfiw"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgv00f9ooxlyobgj5ex"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rgz00fiooxlqsgrhnlt"},{"post_id":"cixlg9rh300frooxlgpbhevex","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rh500fsooxlsfxjdjb4"},{"post_id":"cixlg9rh800fzooxlezmphpdp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rh900g0ooxlj5o08pd9"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rhc00g8ooxllazgl2ap"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rhg00geooxlemilw23b"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rho00goooxlatr0rx2x"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rhu00gyooxl5s82knew"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rhx00h4ooxlz8p8c2j3"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ri100haooxltvxzlmdh"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ri500hjooxl2f6g1tou"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ria00hrooxl6z5bgmat"},{"post_id":"cixlg9ric00hzooxlglirxi4t","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rid00i0ooxldjp5mnne"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rih00i6ooxlj0z2sebi"},{"post_id":"cixlg9rik00ieooxlposk45jc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rim00ifooxl50z4t33u"},{"post_id":"cixlg9rio00ikooxllp2j80bd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rip00ilooxlnfiumjbc"},{"post_id":"cixlg9rir00ipooxlk35f67ay","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rit00iqooxleos1kun3"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rix00ixooxl4upuv7xu"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rj200j4ooxlrcwt3kbe"},{"post_id":"cixlg9rj600jeooxll009vlfm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rj700jfooxlm00baiev"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rjb00jnooxlt528jqor"},{"post_id":"cixlg9rjd00juooxlptjla394","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rjf00jvooxlyjn98az4"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rji00k2ooxlb3bfi5zu"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rjm00k9ooxl7n703z40"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rjq00kgooxl8s0qqwnc"},{"post_id":"cixlg9rk300klooxl9kn22g9j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rk400kmooxlsny9m3r8"},{"post_id":"cixlg9rk700ktooxl6g2yf5hl","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9rk800kuooxloryhs3k4"},{"post_id":"cixlg9rk900kvooxl5hjzokqa","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rka00kwooxlfkt6dwth"},{"post_id":"cixlg9rkc00l0ooxl3gg8o7tc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rke00l1ooxl9rc8iq5z"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rkt00l7ooxlttpl2m69"},{"post_id":"cixlg9rkv00lcooxls72wclbx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rkx00ldooxlk815vkzv"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rl100liooxl7mwvmvcp"},{"post_id":"cixlg9rl400loooxl33swj2te","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rl500lpooxl2in96041"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlf00lxooxlybrbueyt"},{"post_id":"cixlg9rlj00m2ooxlr531mhw2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlk00m3ooxlexofujop"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rln00m8ooxlwmogi13f"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlq00meooxlhlcktyfj"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlv00mmooxle9prkfvr"},{"post_id":"cixlg9rly00msooxlf3pyicvr","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rlz00mtooxl8kgvisqm"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rm600n2ooxlvqxuxy8f"},{"post_id":"cixlg9rm900n8ooxltf4y1ddn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rma00n9ooxlz5fovyni"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmd00neooxl6k5thk6x"},{"post_id":"cixlg9rmh00nlooxl1idgmfrv","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmj00nmooxlv7n7hbu5"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmn00nrooxl37gkffcw"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmu00o1ooxl6nhvewnc"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rmz00o8ooxly6b3qpf8"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rn800okooxlhakqehll"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rnd00osooxlj8rqy4ij"},{"post_id":"cixlg9rng00oyooxl1q61w30r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rni00ozooxlvp7f5jb8"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rnn00p8ooxlp7xoqm0m"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rns00pgooxljy1fem59"},{"post_id":"cixlg9rnu00plooxlun40oh7g","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rnw00pmooxlgxcofur3"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ro000psooxlwjlqd5ek"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ro400pzooxl3wz1kuux"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ro800q5ooxlqhddu9qt"},{"post_id":"cixlg9rob00qbooxle38fb1mx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rod00qcooxlm5mwo808"},{"post_id":"cixlg9roi00qnooxl0d6iws72","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9roj00qoooxlc69hoopx"},{"post_id":"cixlg9ron00qvooxltvmba5m0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9roo00qwooxld9w9quht"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9row00r5ooxlnq7wex4f"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rp500reooxl0zkmzbjy"},{"post_id":"cixlg9rp900rkooxl4329aiu2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpb00rlooxl92kjkcez"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpf00rrooxlg9mgd3d1"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpk00rxooxlsly8exjg"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpp00s4ooxlkblvkmej"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rpv00saooxlhm5a4gvz"},{"post_id":"cixlg9rq200sfooxly4o781l4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rq500sgooxlw0h5tf61"},{"post_id":"cixlg9rqx00soooxllb590yw9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rqy00spooxlnyzoxvjg"},{"post_id":"cixlg9rr500szooxl5spvxvdd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rrd00t0ooxlvfw4wz7f"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rrm00t8ooxleuasqdna"},{"post_id":"cixlg9rrp00teooxlvdm3u5f0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rrr00tfooxley7agmpc"},{"post_id":"cixlg9rrt00tjooxl26si2srg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rrv00tkooxlstfurpt9"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rs300trooxl0smwla3g"},{"post_id":"cixlg9rs700txooxlxitu2z26","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rs900tyooxlgy61sek0"},{"post_id":"cixlg9rsc00u4ooxlj8ab512z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rse00u5ooxl7nocpsek"},{"post_id":"cixlg9rsg00uaooxljndn1qui","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rsi00ubooxlncr7lejy"},{"post_id":"cixlg9rso00unooxlniigyuwv","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rsq00uoooxlh3y0ppnd"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rsz00uvooxl5zv2y032"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rt700v3ooxljb6ctsne"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rtb00vaooxl46ee6chn"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rth00vhooxl1jwdsybd"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rtl00voooxlpjsnzwnn"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rts00vyooxlru30dj08"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rty00w7ooxl3dihh8gs"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ru400wdooxl7w4cacdm"},{"post_id":"cixlg9ru700wjooxldpiytopo","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ru900wkooxl06x112wo"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rue00wrooxl5snl7i7i"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ruj00wxooxlqietpgzs"},{"post_id":"cixlg9rum00x2ooxlk70b6ezl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ruo00x3ooxlr7tdneyi"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rus00x8ooxlnwdbcn7h"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ruy00xfooxlk7nq25in"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rv400xmooxl35x0cex8"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rv900xsooxl3dqgusbl"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rve00xzooxlrczp9w9v"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rvk00y7ooxlesp2yuzd"},{"post_id":"cixlg9rvp00yfooxldumqyx55","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rvq00ygooxltxcng8vr"},{"post_id":"cixlg9rvt00ylooxlsots6p61","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rvv00ymooxlc72xxdqd"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rw100yuooxlgdkkbze2"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rw700z2ooxl2oxjfva6"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rwe00z9ooxlhzhses12"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rwj00zfooxlenvjtcw6"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rwp00znooxl0smw211a"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rww00zwooxl6myhc3vp"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rx20104ooxlq6ozcl45"},{"post_id":"cixlg9rx6010cooxlj2093ofg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rx8010dooxlvu4w99l8"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rxf010looxlpugqt1dv"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rxl010sooxl0yl159jx"},{"post_id":"cixlg9rxo010xooxlim11g2sa","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9rxq010yooxli6mkc7ck"},{"post_id":"cixlg9rxv010zooxl992znn8t","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rxw0110ooxlztoeobjy"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ry20117ooxlhprc3rgz"},{"post_id":"cixlg9ry8011hooxlyt6940cs","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rya011iooxlm4dtupuk"},{"post_id":"cixlg9rye011oooxljwdrbzgj","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ryg011pooxljgduwv3w"},{"post_id":"cixlg9ryj011tooxlqxng4x0m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ryl011uooxl9egdxcc3"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ryp011zooxlyj1yckhn"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ryv0127ooxlqlhap5xk"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rz1012eooxlgd5w2zgu"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rz9012oooxl575tvbix"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rze012uooxld1rgz3vk"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rzm0131ooxlei4dst3d"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rzr0137ooxlopwdsopf"},{"post_id":"cixlg9rzu013cooxlvok6je2x","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9rzw013dooxlgf6zdmft"},{"post_id":"cixlg9s01013kooxlpt7nhhab","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s03013looxlxz10vjnp"},{"post_id":"cixlg9s06013pooxll1sqek1m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s08013qooxl9cujxdsb"},{"post_id":"cixlg9s0a013uooxlg37nsti1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0c013vooxlril84ij8"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0h0140ooxl7spa2wa2"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0n0147ooxl54v4xl0r"},{"post_id":"cixlg9s0q014cooxluoph4st4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0s014dooxliv4ixu0p"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s0x014jooxltq0zp9qz"},{"post_id":"cixlg9s11014oooxlk15ca9gr","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s13014pooxl58tmz2hs"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s1c014uooxl5y0uj3rm"},{"post_id":"cixlg9s1g0150ooxltpgq3ka0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s1i0151ooxlj5oq4fzd"},{"post_id":"cixlg9s2d015eooxloob8hphs","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s2g015fooxl8ckj1wtw"},{"post_id":"cixlg9s2j015kooxlno9phes2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s2l015looxlr3ifmfyu"},{"post_id":"cixlg9s2r015tooxlois4c85n","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s2t015uooxl5qphqhk0"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s310161ooxl8jh7va9y"},{"post_id":"cixlg9s360167ooxl1fok2ucx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s380168ooxlu17rm5qz"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s3e016fooxlmcrk3cns"},{"post_id":"cixlg9s3i016mooxlfujpjwv5","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s3l016nooxlaeca22bu"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s3s016tooxlixkh67lj"},{"post_id":"cixlg9s3w016zooxl934kfe33","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s3y0170ooxlriersdqg"},{"post_id":"cixlg9s410174ooxl2pkymw5v","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s440175ooxl4haj6l37"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s4d017gooxlnhst5dt5"},{"post_id":"cixlg9s4g017looxld0m4k1w0","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9s4j017mooxlc05d6byg"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s4m017oooxl1anjml1p"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s4s017vooxl0bwu5mb6"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s4z0182ooxl0luhu5nr"},{"post_id":"cixlg9s560189ooxl8r20eqsp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s59018aooxlbb2kjls2"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s5f018gooxlsh5bjewb"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s5t018pooxlg5zq9xzj"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s60018xooxlykam5ody"},{"post_id":"cixlg9s640194ooxl2r9h3e11","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s670195ooxlx6vuhtio"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s6f019eooxlfy0rumiw"},{"post_id":"cixlg9s6n019looxlzh13wmyd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s6s019mooxl6pxfuusd"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s6z019uooxloqn0s5l7"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s7801a2ooxllakxbmyu"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s7e01a9ooxlighc88nf"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s7l01agooxlfmw9yymq"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s7t01aoooxl7d9y20mg"},{"post_id":"cixlg9s7y01avooxl5ku8le04","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8001awooxla4v7f9yq"},{"post_id":"cixlg9s8601b4ooxl9xtoeca1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8801b5ooxlb7notgvg"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8e01baooxlq9qsc49o"},{"post_id":"cixlg9s8j01bhooxlw1ixjot5","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8l01biooxl6isz8y2r"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8q01bnooxlvruqktr1"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s8w01btooxlxrj30919"},{"post_id":"cixlg9s9001bzooxlvzne69or","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9201c0ooxlzts0x5da"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9901c7ooxlcqyoqiep"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9f01cdooxlcn7q96hm"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9n01clooxl0ejqg3yq"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9s9v01crooxl6ubkgimz"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sa401d1ooxl1rhog74z"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sab01d7ooxln5tgqcfg"},{"post_id":"cixlg9saj01dfooxlkcflucvz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sal01dgooxlfjoxggkc"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sar01dlooxlwsxl8l37"},{"post_id":"cixlg9sau01dqooxlnxqow11w","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9saw01drooxlqf52sygt"},{"post_id":"cixlg9sb201dyooxl6v5leuke","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sb401dzooxl0b50dfl1"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sbd01e9ooxlhgragry2"},{"post_id":"cixlg9sbh01eeooxla294l35s","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sbk01efooxl0t2u67yj"},{"post_id":"cixlg9sbn01ejooxlsdjn57bi","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sbp01ekooxlm8j8garv"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sbv01epooxlhpj5tinw"},{"post_id":"cixlg9sc201eyooxlr7xobk40","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sc401ezooxloh80yig0"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9scb01f6ooxlpk6zsu8d"},{"post_id":"cixlg9scf01fbooxllohwmidy","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sch01fcooxlfut9v91v"},{"post_id":"cixlg9scl01fgooxltchcuriw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sco01fhooxle7zdzi5e"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9scv01foooxlu5zumzgx"},{"post_id":"cixlg9sd001fuooxld0xz6w8z","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sd401fvooxlvwnb3cxg"},{"post_id":"cixlg9sd701fzooxlgv99imzv","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sd901g0ooxl4o6mm73c"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sdf01g5ooxlt3imji8f"},{"post_id":"cixlg9sdj01gaooxlldwx269a","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sdl01gbooxlba4gz2xi"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sdt01gjooxlobxi2v6q"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9se001gqooxl3at70pxp"},{"post_id":"cixlg9se501gwooxl4he1heaz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9se801gxooxlcncucsn7"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sed01h2ooxlrev3u5io"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9seo01haooxlw4f5tcc9"},{"post_id":"cixlg9ses01hfooxlfbrle23q","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sev01hgooxlj53v8d4c"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sf201hnooxl5iwhwqqn"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sf901huooxlygt24vtj"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sfj01i1ooxlk3o1qhpt"},{"post_id":"cixlg9sfo01i7ooxlz6m9wk11","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sfr01i8ooxlto2akck4"},{"post_id":"cixlg9sfu01icooxl6b4q2hml","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sfy01idooxlbp3lf23s"},{"post_id":"cixlg9sg201ihooxlf6fgnhkg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sg501iiooxljw36679p"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sga01imooxll3j1p9zo"},{"post_id":"cixlg9sgh01itooxl4uq404pe","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sgk01iuooxljmedct1a"},{"post_id":"cixlg9sgo01izooxlvy5gpnck","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sgr01j0ooxln4ida5xv"},{"post_id":"cixlg9sgu01j4ooxlhpdlz7gb","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sgw01j5ooxl4pk7b5wl"},{"post_id":"cixlg9sh001j9ooxlbo7maly2","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sh201jaooxlr6robvzo"},{"post_id":"cixlg9sh601jeooxl6gdfag18","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sh801jfooxls69n6g7n"},{"post_id":"cixlg9she01jlooxl1qtik5ks","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9shg01jmooxlne6bo2x4"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9shn01jsooxl7dgj2mfn"},{"post_id":"cixlg9shs01jyooxle7mhon4u","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9shv01jzooxl12fm9lcb"},{"post_id":"cixlg9shy01k3ooxld3fb801r","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9si101k4ooxlfydhrqbz"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9si801kaooxlhpaqk3tq"},{"post_id":"cixlg9sic01kgooxlh6482eho","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sif01khooxl64uou7fg"},{"post_id":"cixlg9sil01knooxlo1st7o09","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sio01koooxlq5lj97o8"},{"post_id":"cixlg9sit01ktooxl5amhekiy","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9siw01kuooxll14xchm9"},{"post_id":"cixlg9sj301kzooxlp726ykia","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sj701l0ooxlsot184ud"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sji01l7ooxlm2klshhk"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sjr01ldooxls5yaf96r"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sk001lkooxl1e34yh3t"},{"post_id":"cixlg9sk501lpooxllld15m00","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sk701lqooxlxtxrlef1"},{"post_id":"cixlg9skb01luooxlybp32p0j","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9ski01lvooxlirpy0e1y"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9skq01m0ooxl9pi0w7tc"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9skx01m6ooxlzkdl0xkt"},{"post_id":"cixlg9sl201mcooxlv07ksmff","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sl501mdooxlcdcv3p18"},{"post_id":"cixlg9sl901miooxljfxbb22y","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9slc01mjooxl6xojdmge"},{"post_id":"cixlg9slg01moooxltxsdu2p9","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9slj01mpooxl5h3d9k3c"},{"post_id":"cixlg9slq01mwooxlefrrc6zm","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9slt01mxooxl0twqanpa"},{"post_id":"cixlg9slv01n0ooxlauq8af31","category_id":"cixlg9rcd0070ooxlp5rw7pai","_id":"cixlg9slz01n1ooxls1v6m9r8"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sm701n3ooxls1ha6gfs"},{"post_id":"cixlg9smd01naooxliy5evulj","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9smg01nbooxlyayy0a60"},{"post_id":"cixlg9smm01nhooxlgmz9268i","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9smo01niooxl4whx8pr2"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sn301nvooxlal7g56zk"},{"post_id":"cixlg9snb01o3ooxl45snx359","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sni01o4ooxlmx999dkh"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9snr01oaooxlleqpsx6b"},{"post_id":"cixlg9sny01ohooxlry34pi7o","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9so101oiooxlckgsc0r9"},{"post_id":"cixlg9so601ooooxluh670jtd","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9so901opooxlvdghxwsc"},{"post_id":"cixlg9soh01ouooxl31ydifdg","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sok01ovooxlq4az7hoi"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sou01p3ooxlr0c5jju8"},{"post_id":"cixlg9sp101pbooxlgpu4kmkq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9sp401pcooxlzfr9im69"},{"post_id":"cixlg9sp901phooxlc2uv4z47","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9spc01piooxl0xw4eps8"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlg9spj01poooxl408h1qae"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","category_id":"cixlg9r7c0001ooxleudrxue8","_id":"cixlk169l0000s5xl3ho7q84r"}],"PostTag":[{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9r7i0008ooxl9h0i8hwn"},{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9r7i0009ooxlscg67id6"},{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9r7i000aooxlzdfa29uw"},{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9r7i000booxlsxzxjhtm"},{"post_id":"cixlg9r760000ooxlll2vxp8k","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9r7j000cooxlniknq3qn"},{"post_id":"cixlg9r7v000gooxlu86flrpb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r7x000mooxlmaz5n4v8"},{"post_id":"cixlg9r7v000gooxlu86flrpb","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r7y000nooxlimgegxap"},{"post_id":"cixlg9r7v000gooxlu86flrpb","tag_id":"cixlg9r7x000kooxl1wzq6q2w","_id":"cixlg9r7y000oooxlkcq57g0q"},{"post_id":"cixlg9r7v000gooxlu86flrpb","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9r7y000pooxl5b7i36x3"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r84000wooxlkwuaxbxr"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r84000xooxl2emj08ap"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9r84000yooxlexqz3mrt"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9r85000zooxlrw311gx2"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9r850010ooxld72xou99"},{"post_id":"cixlg9r80000qooxls99odt0h","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9r850011ooxl88revdus"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r890015ooxlwxhwbbgs"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8a0016ooxlog9p7l3b"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9r8a0017ooxl6ux6v3vp"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9r8a0018ooxlrqopps5z"},{"post_id":"cixlg9r880012ooxly9xlvj0j","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9r8a0019ooxlrmz9ebkn"},{"post_id":"cixlg9r8b001aooxlsxcj7zkb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r8e001dooxlcy1oxzz0"},{"post_id":"cixlg9r8b001aooxlsxcj7zkb","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8e001eooxl9h2jlifn"},{"post_id":"cixlg9r8b001aooxlsxcj7zkb","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r8f001fooxldtxlvusb"},{"post_id":"cixlg9r8j001gooxl5xhuodpp","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r8m001jooxl5ccqc6rx"},{"post_id":"cixlg9r8j001gooxl5xhuodpp","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8m001kooxlvseow096"},{"post_id":"cixlg9r8j001gooxl5xhuodpp","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9r8n001looxla4ko84yt"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r8s001rooxlnebw1vl9"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9r8s001sooxlv7w4j079"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8s001tooxl4ftoiws7"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r8r001pooxlyc0q1m6c","_id":"cixlg9r8s001uooxldjnndurz"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r8r001qooxlwlkctz05","_id":"cixlg9r8s001vooxlfjhlb163"},{"post_id":"cixlg9r8o001mooxltmkb3fh1","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9r8s001wooxljk9fjfm7"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r8w0021ooxl11f8f62u"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9r8w0022ooxlexcpm74b"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r8w0023ooxlx4w2kluy"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9r8w0024ooxl9ga7u0ju"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9r8w0025ooxlsdei0fd3"},{"post_id":"cixlg9r8t001xooxlf2d94gbw","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r8w0026ooxl8u8zyot6"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r90002cooxldl8zdnf4"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r90002dooxl152m6596"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r8z0029ooxlyqa6zz0l","_id":"cixlg9r90002eooxllpn06fs3"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9r90002fooxlsdjmj0vs"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9r91002gooxl5o33ap97"},{"post_id":"cixlg9r8x0027ooxl2z31ndqo","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r91002hooxlku857mkl"},{"post_id":"cixlg9r92002iooxlczrdlyzt","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r94002looxlfm5g2u9b"},{"post_id":"cixlg9r92002iooxlczrdlyzt","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r94002mooxlrriclheb"},{"post_id":"cixlg9r92002iooxlczrdlyzt","tag_id":"cixlg9r93002kooxlh54bru8k","_id":"cixlg9r94002nooxlfw3gtgxm"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r96002rooxlc0uvftlj"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9r97002sooxl3b91njdq"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r97002tooxlfhogw1l7"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9r97002uooxllcpm533u"},{"post_id":"cixlg9r95002oooxls8l15ust","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r97002vooxl3s9i5tgi"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9r9f002zooxldtuen99r"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9r9f0030ooxlri8yf6vn"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r7x000jooxl3ou6o1z6","_id":"cixlg9r9f0031ooxly5e11zuv"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9r9f0032ooxllcmslabm"},{"post_id":"cixlg9r99002wooxlw9wlizgc","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9r9f0033ooxlzhedb37u"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9h0036ooxlqisj2rda","_id":"cixlg9r9j003dooxlu2nv3j47"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i0037ooxlsbc7nni3","_id":"cixlg9r9j003eooxlrxscntva"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i0038ooxlkm3my37w","_id":"cixlg9r9j003fooxl6z9bcga7"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i0039ooxlvgirf8rg","_id":"cixlg9r9j003gooxlm0wnoh07"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i003aooxlewo42a2j","_id":"cixlg9r9j003hooxlqdfemr0w"},{"post_id":"cixlg9r9g0034ooxlb1zybm8l","tag_id":"cixlg9r9i003booxlqglqwn0h","_id":"cixlg9r9j003iooxl2m55kvaz"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9ra8003oooxlm11sy55y"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9ra8003pooxlz91tamku"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ra9003qooxl2eqkinqi"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9ra9003rooxlvl584u2p"},{"post_id":"cixlg9ra4003jooxlk639w24c","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9ra9003sooxlif0kezda"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rab003xooxlg7y6o5jb"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rab003yooxlsdbkqg4b"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9rab003zooxlf2glsyv7"},{"post_id":"cixlg9raa003tooxlpkd1wmj8","tag_id":"cixlg9rab003wooxl37uc1xiy","_id":"cixlg9rab0040ooxlr528ikv2"},{"post_id":"cixlg9rac0041ooxl472q7ojl","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rae0043ooxl5yqgbyke"},{"post_id":"cixlg9rac0041ooxl472q7ojl","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9raf0044ooxl9zlw3u5g"},{"post_id":"cixlg9rac0041ooxl472q7ojl","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9raf0045ooxluw6iarj1"},{"post_id":"cixlg9rac0041ooxl472q7ojl","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9raf0046ooxl6g4wzhkv"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rap004booxlk5obr9j1"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rap004cooxly2n17rlm"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9rap004dooxlw0wysxt1"},{"post_id":"cixlg9ran0047ooxl2b7e0xtc","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9rap004eooxl6efv4qop"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9ras004iooxl0820wc0k"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9ras004jooxlke15q0v3"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9ras004kooxl0coii2xy"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ras004looxl4c4pi368"},{"post_id":"cixlg9raq004fooxlyk872vzc","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9ras004mooxlkbkr15tu"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rav004sooxl7tr0tz0s"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9raw004tooxlj2j9lawz"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9raw004uooxlfh4bor8j"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9raw004vooxlyqgnkrhd"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9raw004wooxlwkaafzk2"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9raw004xooxloxudlij7"},{"post_id":"cixlg9rat004nooxl0udxuz2r","tag_id":"cixlg9rav004rooxl64zczyza","_id":"cixlg9raw004yooxls4vhqmp0"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rb00052ooxlqqqxwe5l"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rb00053ooxlchd1zzlw"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9rb00054ooxl57imefoq"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rb00055ooxlrm9qbq8x"},{"post_id":"cixlg9raw004zooxlsfkm9zyy","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rb00056ooxlo36ntqf3"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rb4005aooxldve8jtpn"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rb5005booxlfiho5442"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rb5005cooxlvz57a8bi"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rb5005dooxl1nlhy1ln"},{"post_id":"cixlg9rb10057ooxl45cl24ny","tag_id":"cixlg9rb30059ooxlcu3albgd","_id":"cixlg9rb5005eooxlp8imxcd3"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9ra5003looxlqj25k0xd","_id":"cixlg9rba005kooxldi48hckh"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rba005looxlbc7lz22o"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9rba005mooxlq5vu447c"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9rba005nooxls2nyci8e"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9rba005oooxlc9iyj90t"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9rb8005iooxl4nklbagp","_id":"cixlg9rba005pooxlilm0tt24"},{"post_id":"cixlg9rb5005fooxl4xju7de7","tag_id":"cixlg9rb9005jooxljsf2wusx","_id":"cixlg9rba005qooxlueqn8olo"},{"post_id":"cixlg9rbg005rooxlwmmodxef","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rbm005wooxl5n2xe6s3"},{"post_id":"cixlg9rbg005rooxlwmmodxef","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rbm005xooxl5dg7tgnl"},{"post_id":"cixlg9rbg005rooxlwmmodxef","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rbm005yooxllowg9fnb"},{"post_id":"cixlg9rbg005rooxlwmmodxef","tag_id":"cixlg9rbl005vooxl8g5rzkci","_id":"cixlg9rbm005zooxl5n58r33k"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rbq0063ooxlppwaqcny"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rbq0064ooxlh3cn7ld4"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rbq0065ooxlzy277ira"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rbq0066ooxlksi8kz8m"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rbq0067ooxln8hm49q0"},{"post_id":"cixlg9rbn0060ooxlf67buek0","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rbq0068ooxlgqqvha5t"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rc0006dooxl8zknacxs"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","tag_id":"cixlg9rbz006booxlc2aoef6x","_id":"cixlg9rc0006eooxltzw6ky7n"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","tag_id":"cixlg9rbz006cooxlo6c2fj1p","_id":"cixlg9rc0006fooxl10n38pz0"},{"post_id":"cixlg9rbw0069ooxlmf2loxri","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9rc0006gooxl2tt45nxe"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rc5006looxlnlo4fp40"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","tag_id":"cixlg9rbz006booxlc2aoef6x","_id":"cixlg9rc5006mooxl4wa5fti3"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rc5006nooxldqww97o7"},{"post_id":"cixlg9rc1006hooxlvjp7qzfs","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rc5006oooxl0waut8sm"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rc9006uooxlx64swgdf"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9rbz006booxlc2aoef6x","_id":"cixlg9rcb006vooxlj1u883a5"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9rc7006rooxl1vs8rdyg","_id":"cixlg9rcb006wooxlv3llqcfo"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rcb006xooxlx7vp7cha"},{"post_id":"cixlg9rc6006pooxlzn7qpvcm","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9rcb006yooxliizfwgah"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rcn0077ooxlegqd8qyw"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rco0078ooxloisf3gjw"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9rco0079ooxlqm8e44qa"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rco007aooxl4lg7iez0"},{"post_id":"cixlg9rcj0072ooxl3m66k49j","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rco007booxljacn2e2d"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rct007fooxlhzhr9872"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rct007gooxl0wr4lv1v"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9rcs007eooxljl4cr6fp","_id":"cixlg9rct007hooxl2bc1hm8j"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rct007iooxlra5hyudu"},{"post_id":"cixlg9rcq007cooxll7931685","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rct007jooxl3ixnzcjn"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rcv007nooxl0x3z29z4"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rcw007oooxlcufsz2ew"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9rcv007mooxl2rcb6kfa","_id":"cixlg9rcw007pooxlonrh5xfd"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rcw007qooxlou21gs82"},{"post_id":"cixlg9rcu007kooxl669tzoxp","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rcw007rooxlelsqe2vb"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rcz007vooxl4f04gjvj"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rcz007wooxlngxa9g72"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9rcy007uooxlgxy1ji5a","_id":"cixlg9rcz007xooxlhkzx4qts"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9rcz007yooxl89c3ueth"},{"post_id":"cixlg9rcx007sooxl0re9kkbg","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rcz007zooxlwfssqrm2"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rd60084ooxl37r52uqt"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rd60085ooxl0brizigm"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rd60086ooxl7zvksmdy"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rd60087ooxlmzg2vi1b"},{"post_id":"cixlg9rd10080ooxlz7juhd5t","tag_id":"cixlg9rd50083ooxlpmj401g3","_id":"cixlg9rd60088ooxlfe68igbr"},{"post_id":"cixlg9rd70089ooxleh439i2r","tag_id":"cixlg9rd9008booxlvhckog1m","_id":"cixlg9rda008dooxlagddyqtf"},{"post_id":"cixlg9rd70089ooxleh439i2r","tag_id":"cixlg9rd9008cooxlorh78wc9","_id":"cixlg9rda008eooxl23bfekkl"},{"post_id":"cixlg9rdb008fooxlmuqr73ki","tag_id":"cixlg9rdi008hooxly39dpt5q","_id":"cixlg9rdi008iooxlwbrlw2a2"},{"post_id":"cixlg9rdb008fooxlmuqr73ki","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rdj008jooxlh9adjqvg"},{"post_id":"cixlg9rdb008fooxlmuqr73ki","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rdj008kooxlav7fq6vp"},{"post_id":"cixlg9rdj008looxlpanbg3cl","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rdl008nooxlffybi31a"},{"post_id":"cixlg9rdj008looxlpanbg3cl","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rdm008oooxl8fqj7wmp"},{"post_id":"cixlg9rdj008looxlpanbg3cl","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rdm008pooxldbsgd0k1"},{"post_id":"cixlg9rdj008looxlpanbg3cl","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rdm008qooxlwuari606"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rdo008tooxl5e8erkhp"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rdp008uooxl82tvsmsm"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rdp008vooxl147iqfav"},{"post_id":"cixlg9rdn008rooxl40ma1v0r","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rdp008wooxlokd7ej5v"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rdr008zooxlgqvdp6ij"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rdr0090ooxl8005qk5p"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rdr0091ooxlzin5g4pz"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rdr0092ooxlvvquiskm"},{"post_id":"cixlg9rdq008xooxlfaz16hdw","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rdr0093ooxloqjlawa1"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rdu0096ooxl5lfi9ao0"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rdu0097ooxls3dcbtun"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rdv0098ooxl8y12rom6"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rdv0099ooxlke4ecdi4"},{"post_id":"cixlg9rds0094ooxlo8t6v8ua","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rdv009aooxlgw4pt27a"},{"post_id":"cixlg9rdx009booxlch8h998g","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rdz009eooxllxdrtng9"},{"post_id":"cixlg9rdx009booxlch8h998g","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9rdz009fooxlyit3cdty"},{"post_id":"cixlg9rdx009booxlch8h998g","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rdz009gooxlxdi9tafl"},{"post_id":"cixlg9re0009hooxl4o7msif9","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9re1009kooxlvse8sjg9"},{"post_id":"cixlg9re0009hooxl4o7msif9","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9re2009looxlc76duuer"},{"post_id":"cixlg9re0009hooxl4o7msif9","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9re2009mooxlw1bxezc9"},{"post_id":"cixlg9re0009hooxl4o7msif9","tag_id":"cixlg9re1009jooxl17lu709s","_id":"cixlg9re2009nooxlx4gli8v0"},{"post_id":"cixlg9re3009oooxl9oqc1j4j","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9re4009qooxlw8y6bit3"},{"post_id":"cixlg9re3009oooxl9oqc1j4j","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9re5009rooxlcgb8ncxd"},{"post_id":"cixlg9re3009oooxl9oqc1j4j","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9re5009sooxl6uaj7f6x"},{"post_id":"cixlg9re6009tooxlxwkgks62","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9re8009vooxli48s6tnc"},{"post_id":"cixlg9re6009tooxlxwkgks62","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9re8009wooxl9nwcn9ez"},{"post_id":"cixlg9re6009tooxlxwkgks62","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9re8009xooxlr1kmo277"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rec00a1ooxlu9pobxj1"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9rec00a2ooxl9dfr8ecj"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rec00a3ooxl4tylkzux"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9reb00a0ooxlhez8iqr8","_id":"cixlg9rec00a4ooxla37tzc9n"},{"post_id":"cixlg9re9009yooxl765qsyac","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rec00a5ooxl08ft4ega"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ref00a8ooxlz3a59prm"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9reg00a9ooxlns18adfm"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9reg00aaooxlcwv0u3dv"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9reg00abooxlicxfhccl"},{"post_id":"cixlg9red00a6ooxldbfoe8ph","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9reg00acooxl0jhoauzz"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rek00ahooxlaocqv2b1"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9rel00aiooxlr8mns5la"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rel00ajooxl3yca3vat"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9rel00akooxliw07b2py"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9rel00alooxl5akcep82"},{"post_id":"cixlg9reh00adooxl81or26s2","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9rel00amooxlea2tw7ai"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9reo00atooxlly69jvxd"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rep00auooxlscektk0p"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rep00avooxlunfnsgk5"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9ren00aqooxlfsj277q8","_id":"cixlg9rep00awooxlu8em6pms"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9reo00arooxleknn6uqx","_id":"cixlg9rep00axooxlxuhxl7ob"},{"post_id":"cixlg9rem00anooxl0p5xvvaj","tag_id":"cixlg9reo00asooxlwj0nsdlc","_id":"cixlg9rep00ayooxlid0lvh4m"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9reu00b4ooxlcrvptdfv"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rev00b5ooxl6c2aizdx"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rev00b6ooxl9vo0hdtu"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9rev00b7ooxlyp5yffah"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rev00b8ooxlo7pza2pu"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9ret00b3ooxllpne01jw","_id":"cixlg9rev00b9ooxl81i84ncd"},{"post_id":"cixlg9res00b1ooxl1tynortw","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9rev00baooxl8fc217hx"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rey00bgooxlc4twgiqw"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rez00bhooxl8cxugafm"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rez00biooxlxdrxhite"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9rez00bjooxlvjvcs438"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rez00bkooxlc2bb3050"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9rex00bdooxlx8kdkklz","_id":"cixlg9rez00blooxll32t1vk0"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9rex00beooxlwxao8570","_id":"cixlg9rez00bmooxlnovq3peq"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rez00bnooxl4wbkfbsp"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9rez00boooxlaw0u9c2k"},{"post_id":"cixlg9rev00bbooxlauiqllaa","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rez00bpooxl1raq0xyb"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rf200bsooxlm9oiuxf7"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rf200btooxlu0smwddb"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rf200buooxljc3ixrer"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rf300bvooxlyl7pnboz"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9rf300bwooxl1z5wszmw"},{"post_id":"cixlg9rf000bqooxlxoy869wq","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9rf300bxooxly9wvxemo"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rf700c1ooxlrq5go698"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rf700c2ooxl28vr16zi"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rf700c3ooxlfgpqqtuc"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rf700c4ooxlt0tt397k"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rf700c5ooxlte7pmd7w"},{"post_id":"cixlg9rf400byooxl5qvktlmq","tag_id":"cixlg9rf600c0ooxlh79pc7t9","_id":"cixlg9rf700c6ooxlyh80fscx"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rfb00caooxlseqt10mo"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rfd00cbooxlcdgn5yhg"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfd00ccooxl4nyfije6"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rfd00cdooxl9txvguc8"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rfd00ceooxlxo5o41j5"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rfd00cfooxlzwxvx18y"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rfd00cgooxlyi8z2f79"},{"post_id":"cixlg9rf800c7ooxlwt64odd7","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9rfd00chooxldprc53z8"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfm00clooxl3e3zedh8"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rfn00cmooxlro48mlre"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rfn00cnooxleu9t0wdc"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rfn00coooxlkwvnjvi1"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rfn00cpooxl3322zbxv"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rfn00cqooxlqem2sc4z"},{"post_id":"cixlg9rfj00ciooxlhm5cby1n","tag_id":"cixlg9rfl00ckooxl1t1ryhzn","_id":"cixlg9rfn00crooxlhtdofvx5"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfr00cyooxl72nwscul"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rfs00czooxlfd9mna5p"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9r7x000kooxl1wzq6q2w","_id":"cixlg9rfs00d0ooxl33rhc16p"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9rfp00cuooxlb418ewkl","_id":"cixlg9rft00d1ooxlscu6c7dk"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rft00d2ooxlq3bqnbc7"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9rfq00cvooxlscwpkhkd","_id":"cixlg9rft00d3ooxlifs5lnxr"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9rft00d4ooxlej7xi49a"},{"post_id":"cixlg9rfo00csooxlhfez3dbn","tag_id":"cixlg9rfr00cxooxldhdyuxmz","_id":"cixlg9rft00d5ooxlnr8mwy6z"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfv00d8ooxl9vta6e86"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rfv00d9ooxl25doryca"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rfv00daooxl5fp9s0ts"},{"post_id":"cixlg9rft00d6ooxlm2ytmtoh","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rfv00dbooxllhu8q44m"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rfz00dhooxlfu13nv4c"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rg000diooxlyhnsatn3"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rg000djooxlkslrj385"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9rfy00dfooxl3d9e7det","_id":"cixlg9rg000dkooxlgd41grkj"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9rfz00dgooxl7dflz7zw","_id":"cixlg9rg000dlooxl49tb2w20"},{"post_id":"cixlg9rfw00dcooxlt9lyjj2q","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9rg000dmooxlfxnvgefv"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rg300drooxlc03acpfi"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rg400dsooxlj1b2ssz9"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rg400dtooxlqr0lvrgf"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9rg200dpooxlpxgfrm7a","_id":"cixlg9rg400duooxl7uoe3usv"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9rg400dvooxlgcxuj5di"},{"post_id":"cixlg9rg100dnooxloxhb1gg3","tag_id":"cixlg9rg300dqooxljoaconen","_id":"cixlg9rg400dwooxlczfv9vuu"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rg600dzooxllpsabm4e"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rg700e0ooxl8in7sh23"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9rg700e1ooxl7g2vsgiw"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rg700e2ooxl83sfn3vz"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rg700e3ooxlvwrg6l8n"},{"post_id":"cixlg9rg500dxooxl2qhyge5n","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9rg700e4ooxl0fvez3ge"},{"post_id":"cixlg9rg800e5ooxlwalebfg2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rga00e7ooxllhlzw3ji"},{"post_id":"cixlg9rg800e5ooxlwalebfg2","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rga00e8ooxlf9991wmb"},{"post_id":"cixlg9rg800e5ooxlwalebfg2","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rgb00e9ooxlnphrs10p"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgd00ecooxlv0xyk9cv"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rgd00edooxlzj1tpvem"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rgd00eeooxlcz97uagz"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9rgd00efooxl83tpfuk0"},{"post_id":"cixlg9rgb00eaooxla477j5s2","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9rgd00egooxld12lotpp"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgg00ejooxlsvi34zp8"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rgh00ekooxl5d4sg6qw"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rgh00elooxl6ftp5kw3"},{"post_id":"cixlg9rge00ehooxlqzn0kp06","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rgh00emooxlbosn9yf1"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgl00erooxls2es12iw"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9ren00apooxlc77jnqlj","_id":"cixlg9rgm00esooxlthdef1xy"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rgm00etooxl0fxldh0n"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rgm00euooxlcbu3abut"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rgm00evooxlhk55eq5d"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9rgk00epooxlz9d136ps","_id":"cixlg9rgm00ewooxlozkhntvy"},{"post_id":"cixlg9rgi00enooxlb04gdz9k","tag_id":"cixlg9rgl00eqooxl6rx31ll9","_id":"cixlg9rgm00exooxl0iq11fg1"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgs00f3ooxljktftaph"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rgt00f4ooxlqa3nteq0"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rgt00f5ooxl5edaqomj"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9rgq00f1ooxljoqfe3j6","_id":"cixlg9rgt00f6ooxlsscjrnpx"},{"post_id":"cixlg9rgn00eyooxl34o2j4rb","tag_id":"cixlg9rgr00f2ooxl5h77j5xb","_id":"cixlg9rgt00f7ooxldq0r7qag"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rgv00faooxlhbr3g3ug"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rgx00fbooxly8jxwh1n"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rgx00fcooxlg4pabi81"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9rc7006rooxl1vs8rdyg","_id":"cixlg9rgx00fdooxl89yeyqyr"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9rgl00eqooxl6rx31ll9","_id":"cixlg9rgx00feooxl88gnnvbr"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rgx00ffooxl68iaibmg"},{"post_id":"cixlg9rgu00f8ooxlekr1ehvn","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rgx00fgooxlh8zxdqw1"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rh100fkooxlkejgrlpj"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rh200flooxl9kba03nu"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rh200fmooxlsygl27yl"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rh200fnooxln24wivwh"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9rh200foooxlr6k2kuvo"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rh200fpooxlv9uneavt"},{"post_id":"cixlg9rgy00fhooxl3k6h71qd","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rh200fqooxlhq74ipvv"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rh600fuooxludo7ey99"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rh700fvooxlf34v5u1x"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rh700fwooxlmkguifu9"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rh700fxooxlkapek3wj"},{"post_id":"cixlg9rh300frooxlgpbhevex","tag_id":"cixlg9rh500ftooxliog0rt8q","_id":"cixlg9rh700fyooxlor4gm0eu"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rha00g2ooxl1f85yc0m"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rha00g3ooxl1vflo205"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9rha00g4ooxljqyzcrl3"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9rha00g5ooxla7hqx769"},{"post_id":"cixlg9rh800fzooxlezmphpdp","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9rhb00g6ooxlr9yfhwo8"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhd00g9ooxl52wlz7a1"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhe00gaooxlic6vw2in"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rhe00gbooxleracgrjw"},{"post_id":"cixlg9rhb00g7ooxlkn1pigrh","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rhe00gcooxlhfi1dky8"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhl00ggooxlb6yuouvr"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhm00ghooxlbwzsngsw"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9rhm00giooxlnph9tdad"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rhm00gjooxl040hxk9h"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9rhm00gkooxlwpz85si2"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9rhg00gfooxl7ajpt78z","_id":"cixlg9rhm00glooxlucbyuq0u"},{"post_id":"cixlg9rhe00gdooxlfqdkhbdw","tag_id":"cixlg9rcy007uooxlgxy1ji5a","_id":"cixlg9rhm00gmooxliozrylsi"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhq00grooxlrvie7b8d"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhq00gsooxlstsit1af"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rhr00gtooxlap98lp92"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9rhr00guooxl18xe5fc3"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rho00gpooxldpn403og","_id":"cixlg9rhr00gvooxlzrut2qzw"},{"post_id":"cixlg9rhn00gnooxl5rbwdn1f","tag_id":"cixlg9rhp00gqooxlwhqlb558","_id":"cixlg9rhr00gwooxltsqlw10m"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhu00gzooxlr3il7zwe"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhv00h0ooxlb3iygvd5"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9rhv00h1ooxlr3c5duhn"},{"post_id":"cixlg9rhs00gxooxlkf7c3f5g","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rhv00h2ooxlral1dzbi"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rhy00h5ooxl3k1p8klu"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rhz00h6ooxl4gi42r58"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rhz00h7ooxlk7t0oq0v"},{"post_id":"cixlg9rhv00h3ooxl3lmr2y96","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rhz00h8ooxl7ml1wlru"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ri200hcooxlhz1sg13f"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9ri300hdooxlntw4kcww"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9ri300heooxli38xezwu"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9ri100hbooxlkoeo17fm","_id":"cixlg9ri300hfooxl0o7acv5p"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9ri300hgooxlh6k0pbli"},{"post_id":"cixlg9ri000h9ooxloxq9cuyx","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ri300hhooxl16ye1s0b"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ri700hmooxlq8abu4um"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9ri700hnooxlwsofdke8"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9ri700hoooxl57sll0xw"},{"post_id":"cixlg9ri400hiooxlr5ux6do7","tag_id":"cixlg9ri600hlooxlg6n4blh1","_id":"cixlg9ri700hpooxls56jrppj"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ria00hsooxlka6m9wmj"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rib00htooxlabzfwut2"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9ric00huooxlsx14q2ad"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9ric00hvooxl5tyomopb"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9ric00hwooxlrdbei60f"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9ric00hxooxlh9chyr1c"},{"post_id":"cixlg9ri800hqooxl0br8tnkk","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9ric00hyooxlqtxekeou"},{"post_id":"cixlg9ric00hzooxlglirxi4t","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rie00i1ooxl7nwynp4d"},{"post_id":"cixlg9ric00hzooxlglirxi4t","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rif00i2ooxl4ahz51p1"},{"post_id":"cixlg9ric00hzooxlglirxi4t","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rif00i3ooxlcoxw5n2c"},{"post_id":"cixlg9ric00hzooxlglirxi4t","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rif00i4ooxlx91sj943"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rii00i9ooxlmalwvj82"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rij00iaooxle7t2jdtq"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9rih00i7ooxl65jx3w5z","_id":"cixlg9rij00ibooxl4u6888is"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9rij00icooxlgg1x68ja"},{"post_id":"cixlg9rif00i5ooxl84oy73ga","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rij00idooxltd75pzkq"},{"post_id":"cixlg9rik00ieooxlposk45jc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rim00igooxlkm2u1co8"},{"post_id":"cixlg9rik00ieooxlposk45jc","tag_id":"cixlg9rgq00f0ooxla2z4aqjo","_id":"cixlg9rin00ihooxlmrw2ruwn"},{"post_id":"cixlg9rik00ieooxlposk45jc","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rin00iiooxlzc4vvozx"},{"post_id":"cixlg9rik00ieooxlposk45jc","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9rin00ijooxlnbbwiqge"},{"post_id":"cixlg9rio00ikooxllp2j80bd","tag_id":"cixlg9rf600c0ooxlh79pc7t9","_id":"cixlg9riq00imooxllodk10tu"},{"post_id":"cixlg9rio00ikooxllp2j80bd","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rir00inooxlu151dxb1"},{"post_id":"cixlg9rio00ikooxllp2j80bd","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rir00ioooxlmp3p13oz"},{"post_id":"cixlg9rir00ipooxlk35f67ay","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9riu00itooxlvd7rlp3a"},{"post_id":"cixlg9rir00ipooxlk35f67ay","tag_id":"cixlg9riu00isooxlcigd4msu","_id":"cixlg9riv00iuooxl3i88oh00"},{"post_id":"cixlg9rir00ipooxlk35f67ay","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9riv00ivooxl0ntwopuv"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9riz00izooxlfldzp9z8"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","tag_id":"cixlg9riy00iyooxlqp6j5wny","_id":"cixlg9rj000j0ooxlp40lihfj"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rj000j1ooxlr1vv7gau"},{"post_id":"cixlg9riw00iwooxlq7cnrzba","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rj000j2ooxlvim1d9un"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9rj400j8ooxl63g33q0e"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rj200j5ooxl5hfu647a","_id":"cixlg9rj500j9ooxlux7evyl6"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rj300j6ooxlxbxwjitw","_id":"cixlg9rj500jaooxlpqsbsp4j"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rj500jbooxl2q5s9mw9"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rfl00ckooxl1t1ryhzn","_id":"cixlg9rj500jcooxlgmf4caeg"},{"post_id":"cixlg9rj000j3ooxl2ngxiemi","tag_id":"cixlg9rj300j7ooxly5xcactb","_id":"cixlg9rj500jdooxlfma2sm72"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9rj800jgooxlan3brwi5"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9rao0049ooxlbzlf0rr3","_id":"cixlg9rj900jhooxll0rc42d0"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9rj900jiooxlieougfkm"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9rj900jjooxlinuqpm1s"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9rj900jkooxluaurnt86"},{"post_id":"cixlg9rj600jeooxll009vlfm","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rj900jlooxl47m5zzc0"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rjc00jpooxl5dmykwnl"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9rjb00joooxl7dpm24bd","_id":"cixlg9rjd00jqooxla2i860ti"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rjd00jrooxllzkb0rdt"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rjd00jsooxl0r55w0f1"},{"post_id":"cixlg9rj900jmooxls9vrr6cg","tag_id":"cixlg9rcs007eooxljl4cr6fp","_id":"cixlg9rjd00jtooxlyfhieb8x"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rjf00jwooxlklvl0xfv"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9rjb00joooxl7dpm24bd","_id":"cixlg9rjg00jxooxlxnyljg4t"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rjg00jyooxl7g2w4sv7"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9rjg00jzooxlfugtqkww"},{"post_id":"cixlg9rjd00juooxlptjla394","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9rjg00k0ooxl8n5lkj3t"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rjj00k3ooxlekc72mzn"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9rjb00joooxl7dpm24bd","_id":"cixlg9rjk00k4ooxliojpvfwc"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rjk00k5ooxlcpjqxpk9"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rjk00k6ooxlobbtch90"},{"post_id":"cixlg9rjh00k1ooxltud1xze2","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rjk00k7ooxlrczj1b8i"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rjm00kaooxl3b63jer0"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9rjb00joooxl7dpm24bd","_id":"cixlg9rjn00kbooxl6x55c5bo"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rjo00kcooxlq83z9zhm"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rjo00kdooxlcsu4rt61"},{"post_id":"cixlg9rjk00k8ooxl6ttbs39a","tag_id":"cixlg9rhg00gfooxl7ajpt78z","_id":"cixlg9rjo00keooxld6aao35q"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rjq00khooxlzzd6ipba"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rjr00kiooxlrjz4c77i"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rjr00kjooxl9mf58h3p"},{"post_id":"cixlg9rjo00kfooxlcesjwb8f","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rjr00kkooxltklb5e4b"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9rd9008cooxlorh78wc9","_id":"cixlg9rk500knooxlwiclfmcy"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9ri600hlooxlg6n4blh1","_id":"cixlg9rk600koooxl15lh4bj7"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rk600kpooxllsix46ed"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rk600kqooxlk0t4ukik"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9rk600krooxlcjlvlfiz"},{"post_id":"cixlg9rk300klooxl9kn22g9j","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rk600ksooxlhybanpj9"},{"post_id":"cixlg9rk900kvooxl5hjzokqa","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rkb00kyooxlzkm2qfqe"},{"post_id":"cixlg9rk900kvooxl5hjzokqa","tag_id":"cixlg9r8r001pooxlyc0q1m6c","_id":"cixlg9rkc00kzooxlwkipf9fe"},{"post_id":"cixlg9rkc00l0ooxl3gg8o7tc","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rkf00l3ooxlf7ivgt91"},{"post_id":"cixlg9rkc00l0ooxl3gg8o7tc","tag_id":"cixlg9rke00l2ooxl1uern1gg","_id":"cixlg9rkf00l4ooxl73sy6ync"},{"post_id":"cixlg9rkc00l0ooxl3gg8o7tc","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rkf00l5ooxlueeui6s5"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rku00l8ooxlkcqm7399"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","tag_id":"cixlg9rke00l2ooxl1uern1gg","_id":"cixlg9rkv00l9ooxlpied9tqn"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rkv00laooxlc838o3k0"},{"post_id":"cixlg9rks00l6ooxlzwyn17nd","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9rkv00lbooxl8d9tk18j"},{"post_id":"cixlg9rkv00lcooxls72wclbx","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rky00lfooxl7wzauzb9"},{"post_id":"cixlg9rkv00lcooxls72wclbx","tag_id":"cixlg9rkx00leooxlh03treh7","_id":"cixlg9rky00lgooxl6t8ep8ui"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rl200lkooxlw16vtl2r"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rl300llooxlzvza4bfl"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","tag_id":"cixlg9rl200ljooxlseakivmj","_id":"cixlg9rl300lmooxln9tuezvr"},{"post_id":"cixlg9rkz00lhooxldw6ys8ng","tag_id":"cixlg9rb30059ooxlcu3albgd","_id":"cixlg9rl300lnooxlf4mda5k5"},{"post_id":"cixlg9rl400loooxl33swj2te","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rl700lsooxlgc49rl3w"},{"post_id":"cixlg9rl400loooxl33swj2te","tag_id":"cixlg9rl600lqooxly4jhus6y","_id":"cixlg9rlc00ltooxlkvlu40lj"},{"post_id":"cixlg9rl400loooxl33swj2te","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9rlc00luooxlbhpovvzv"},{"post_id":"cixlg9rl400loooxl33swj2te","tag_id":"cixlg9rl600lrooxlwthjx2u0","_id":"cixlg9rlc00lvooxlcbuldfjt"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rlg00lyooxlff5le8p2"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rlh00lzooxlf02si488"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rlh00m0ooxlc27dtzuk"},{"post_id":"cixlg9rld00lwooxllsb6x8v1","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9rlh00m1ooxl0lof6ylw"},{"post_id":"cixlg9rlj00m2ooxlr531mhw2","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rlk00m4ooxljxt6kg6x"},{"post_id":"cixlg9rlj00m2ooxlr531mhw2","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rll00m5ooxl6etp3c7a"},{"post_id":"cixlg9rlj00m2ooxlr531mhw2","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rll00m6ooxlqwk5av6x"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rln00m9ooxluns5wfc2"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rlo00maooxlkax8im2c"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rlo00mbooxlnbqvdlk5"},{"post_id":"cixlg9rlm00m7ooxlo7pfy78d","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9rlo00mcooxlw2kmstul"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rls00mgooxlo5wuf5zy"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rlt00mhooxly7bve2oq"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rlt00miooxlvzm0xst1"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9rlr00mfooxlmgoshp8r","_id":"cixlg9rlt00mjooxl73v5xw9s"},{"post_id":"cixlg9rlp00mdooxln4fgznoz","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rlt00mkooxl8ezz79au"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rlw00mnooxlj6w2pmvw"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rlx00moooxl837u3vjv"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rlx00mpooxlnl265bwl"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rlx00mqooxlmnx9ysbl"},{"post_id":"cixlg9rlu00mlooxlgdr1hbkg","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rlx00mrooxll91o5pc1"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rm200mvooxllao4yx8b"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rm400mwooxl9hvadz3s"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9rm400mxooxlsuz2mqyr"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9rm400myooxlhzhix4ga"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9rm000muooxlvx6kdpsq","_id":"cixlg9rm400mzooxlx4j0dvln"},{"post_id":"cixlg9rly00msooxlf3pyicvr","tag_id":"cixlg9rl600lrooxlwthjx2u0","_id":"cixlg9rm400n0ooxl29rg7jny"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rm700n4ooxljn3pykx6"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rm800n5ooxltl3n6926"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","tag_id":"cixlg9rm700n3ooxlba6ej9bv","_id":"cixlg9rm800n6ooxlh98go0oa"},{"post_id":"cixlg9rm500n1ooxlmjs77nnl","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9rm800n7ooxlzatcm2fa"},{"post_id":"cixlg9rm900n8ooxltf4y1ddn","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rmb00naooxl453ur1mo"},{"post_id":"cixlg9rm900n8ooxltf4y1ddn","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rmb00nbooxlve85ttvx"},{"post_id":"cixlg9rm900n8ooxltf4y1ddn","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9rmb00ncooxl618ju7bw"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rme00nfooxlraefbrjw"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rmg00ngooxlyue2bsz8"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rmg00nhooxlrvcg2pk7"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rmg00niooxlb45n8cg4"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rg200dpooxlpxgfrm7a","_id":"cixlg9rmg00njooxl4ukv5cb3"},{"post_id":"cixlg9rmc00ndooxlkjffopq1","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9rmg00nkooxlf6kqngex"},{"post_id":"cixlg9rmh00nlooxl1idgmfrv","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rmk00nnooxlx4qbue20"},{"post_id":"cixlg9rmh00nlooxl1idgmfrv","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rmk00noooxl09k3wbd0"},{"post_id":"cixlg9rmh00nlooxl1idgmfrv","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9rml00npooxlio3riv1n"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rmr00nuooxlqqcyms1y"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rms00nvooxl5by6mqei"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rms00nwooxl83oqx8ht"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9rmn00nsooxl0pr2me3j","_id":"cixlg9rms00nxooxlgvhc3c89"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rms00nyooxlik5gprlt"},{"post_id":"cixlg9rml00nqooxlq0mqpsh5","tag_id":"cixlg9rmq00ntooxl3yfmg7cc","_id":"cixlg9rms00nzooxl18grhf8v"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rmv00o2ooxltltkanqk"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rmw00o3ooxlr5g0bkf7"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9rmn00nsooxl0pr2me3j","_id":"cixlg9rmx00o4ooxlrzn8tpnv"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9rmx00o5ooxl05hm5pi3"},{"post_id":"cixlg9rmt00o0ooxlss0g7dh7","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9rmx00o6ooxlekluefxs"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rn300ocooxlqgadrkyi"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rn500odooxlv4mu3itq"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rmz00o9ooxl61y81v7x","_id":"cixlg9rn500oeooxl9td0n0zk"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rn000oaooxlafm6tkz7","_id":"cixlg9rn500ofooxlojzo4wcw"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rn500ogooxlq49kr8e7"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9rn500ohooxlvwxbeisq"},{"post_id":"cixlg9rmy00o7ooxly56ie22t","tag_id":"cixlg9rn200obooxl8e4bkjz3","_id":"cixlg9rn500oiooxlgr4d4cri"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rn900omooxlhz02zm7g"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rnb00onooxlq0uheo9v"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9rl600lrooxlwthjx2u0","_id":"cixlg9rnb00ooooxlsmzveo89"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnb00opooxleezvhnon"},{"post_id":"cixlg9rn600ojooxl1ilaowdd","tag_id":"cixlg9rn800olooxln9dpmyn1","_id":"cixlg9rnb00oqooxlelunnsp5"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rne00otooxl071vkp0r"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnf00ouooxl92o3rcok"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rnf00ovooxlofa77gt6"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rnf00owooxlogb8mvcu"},{"post_id":"cixlg9rnb00orooxl4qu3u03v","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9rnf00oxooxlmvloyydf"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rnj00p0ooxl53bxnl02"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnl00p1ooxl8yigjjhk"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rnl00p2ooxlram2b0ou"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rmz00o9ooxl61y81v7x","_id":"cixlg9rnl00p3ooxli4sklm45"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rh500ftooxliog0rt8q","_id":"cixlg9rnl00p4ooxl0o465yzx"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9rn000oaooxlafm6tkz7","_id":"cixlg9rnl00p5ooxlk7dmbeqe"},{"post_id":"cixlg9rng00oyooxl1q61w30r","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rnl00p6ooxlc24ylnz8"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rno00p9ooxl1pkaz32b"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnp00paooxl8yv2h3tx"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rnp00pbooxlwtoek6lo"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rbl005vooxl8g5rzkci","_id":"cixlg9rnp00pcooxlc99x5j95"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rn000oaooxlafm6tkz7","_id":"cixlg9rnq00pdooxlq4tugqhq"},{"post_id":"cixlg9rnm00p7ooxlnvt9fmv4","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9rnq00peooxln6pkvcb3"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rns00phooxld4g5gwbg"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rnu00piooxlq7ew1hbh"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","tag_id":"cixlg9rkb00kxooxledeoav11","_id":"cixlg9rnu00pjooxlc8clpvk8"},{"post_id":"cixlg9rnq00pfooxlzh4qesq9","tag_id":"cixlg9rbl005vooxl8g5rzkci","_id":"cixlg9rnu00pkooxl5295ws5b"},{"post_id":"cixlg9rnu00plooxlun40oh7g","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rnx00poooxlwv0fj47s"},{"post_id":"cixlg9rnu00plooxlun40oh7g","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rny00ppooxlxfcj5k8e"},{"post_id":"cixlg9rnu00plooxlun40oh7g","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9rny00pqooxlro5iy9tl"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ro100ptooxl9bp0f99f"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9ro200puooxlpzaxvuai"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9ro200pvooxlyzi3e8wk"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9ro200pwooxl12pgsjyg"},{"post_id":"cixlg9rnz00prooxl7q1qk4o8","tag_id":"cixlg9rcs007eooxljl4cr6fp","_id":"cixlg9ro200pxooxlen2mns99"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9ro500q0ooxlemvfney4"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ro600q1ooxl1wis1vqv"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9ro600q2ooxl141lztgc"},{"post_id":"cixlg9ro300pyooxlz2chxlgs","tag_id":"cixlg9rlr00mfooxlmgoshp8r","_id":"cixlg9ro600q3ooxltnsi2sr5"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9ro900q6ooxlpqbqcu8i"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rob00q7ooxlrmcfyb7x"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rob00q8ooxlrlchidv0"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rob00q9ooxlzdtgf9in"},{"post_id":"cixlg9ro700q4ooxl1wfasfhv","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rob00qaooxl2j838nhd"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rof00qgooxlnvqt3uhm"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9roh00qhooxlms1d9vjg"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9roh00qiooxlbpd9dtby"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rod00qdooxlha53ivln","_id":"cixlg9roh00qjooxl9ki2vbfo"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9roh00qkooxlbnl6rxed"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9roe00qeooxl9sfddbb5","_id":"cixlg9roh00qlooxl2n6hn004"},{"post_id":"cixlg9rob00qbooxle38fb1mx","tag_id":"cixlg9rof00qfooxlq93jumjl","_id":"cixlg9roh00qmooxljyay57wx"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rok00qpooxl1kg2apvq"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rom00qqooxlref3jnq4"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rom00qrooxluscfelzk"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rom00qsooxlg76smrp1"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rom00qtooxl7rkfc5rq"},{"post_id":"cixlg9roi00qnooxl0d6iws72","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rom00quooxl0a3bxo8w"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9roq00qyooxl1mmk6wtu"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ror00qzooxlfdu25lx8"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ror00r0ooxln8te60hw"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rot00r1ooxlzock308z"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9roo00qxooxl28ecubjc","_id":"cixlg9rot00r2ooxlgtr1nfnz"},{"post_id":"cixlg9ron00qvooxltvmba5m0","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rot00r3ooxljsmq03p7"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rp100r8ooxlle0p5i0e"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rp200r9ooxlge32ydtz"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9roz00r6ooxlo5iwgtep","_id":"cixlg9rp200raooxl2mmtpdaq"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rp200rbooxlhoyk6nv0"},{"post_id":"cixlg9rou00r4ooxl3cv5u0r4","tag_id":"cixlg9rp000r7ooxlymu9fyh8","_id":"cixlg9rp200rcooxljngkala2"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rp600rfooxlnbabk7v8"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rp800rgooxlfkbsp1qp"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rp800rhooxl9y1ws707"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9rbz006cooxlo6c2fj1p","_id":"cixlg9rp800riooxlaexwfkpz"},{"post_id":"cixlg9rp300rdooxlqbidw1i1","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rp800rjooxlo9f3gh9b"},{"post_id":"cixlg9rp900rkooxl4329aiu2","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpb00rmooxlhaai2tay"},{"post_id":"cixlg9rp900rkooxl4329aiu2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rpc00rnooxlon8kt4rc"},{"post_id":"cixlg9rp900rkooxl4329aiu2","tag_id":"cixlg9riy00iyooxlqp6j5wny","_id":"cixlg9rpc00roooxl18uo4xyc"},{"post_id":"cixlg9rp900rkooxl4329aiu2","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rpc00rpooxlhc6e4xvq"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpg00rsooxlxsfbsecy"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rph00rtooxl5wmlbqve"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","tag_id":"cixlg9reo00asooxlwj0nsdlc","_id":"cixlg9rph00ruooxlnfwlv5ih"},{"post_id":"cixlg9rpe00rqooxltmjb81r9","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9rph00rvooxl2mjiqsww"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpl00rzooxlyleg3hpl"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rpm00s0ooxl67y7v9ru"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","tag_id":"cixlg9rpk00ryooxl36numal7","_id":"cixlg9rpm00s1ooxl0t1t6d12"},{"post_id":"cixlg9rpi00rwooxll1nhr5tg","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rpm00s2ooxl1bukwuzg"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpq00s5ooxld1cyl5gj"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rpr00s6ooxli3vosvys"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rpr00s7ooxlvw90v5oi"},{"post_id":"cixlg9rpn00s3ooxllpwfew4u","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9rpr00s8ooxl1159z7u5"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rpw00sbooxl0vmnu0tl"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rq000scooxlwpzaz95l"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rq000sdooxldihv9x21"},{"post_id":"cixlg9rpt00s9ooxl7iak3jm3","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rq000seooxlpthob8pq"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rq800sjooxllt7cj20m"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rqc00skooxlikprojpe"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9rq500shooxlt5reslko","_id":"cixlg9rqc00slooxlppo1wi40"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9rqc00smooxloigup3qb"},{"post_id":"cixlg9rq200sfooxly4o781l4","tag_id":"cixlg9rq700siooxlrvcwf8av","_id":"cixlg9rqc00snooxll4ctuk7q"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rr000srooxl5uranmsr"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rr200ssooxlsmiq0ynd"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rr200stooxllyik02tj"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rr200suooxlivizf98v"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rr200svooxlahylnc21"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9rr200swooxlhdnehvak"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9rr200sxooxlkgo8x2yl"},{"post_id":"cixlg9rqx00soooxllb590yw9","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rr200syooxlr0zhkz0e"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rre00t1ooxlesu7rafp"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rrj00t2ooxlgzg9ebug"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rrj00t3ooxl0vc5lain"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rrj00t4ooxlyvpjv94q"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rrj00t5ooxlr3y0jm9d"},{"post_id":"cixlg9rr500szooxl5spvxvdd","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rrj00t6ooxlp6lhutoa"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rrm00t9ooxl072mlk8y"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rro00taooxlbmkd192w"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rro00tbooxlf0clm0vm"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rro00tcooxlwy7xvajb"},{"post_id":"cixlg9rrk00t7ooxlvthp0h3z","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rro00tdooxlyiurj24w"},{"post_id":"cixlg9rrp00teooxlvdm3u5f0","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rrr00tgooxl7gkw7z6q"},{"post_id":"cixlg9rrp00teooxlvdm3u5f0","tag_id":"cixlg9rnw00pnooxlb0nmeehc","_id":"cixlg9rrs00thooxlzxq1mfgf"},{"post_id":"cixlg9rrp00teooxlvdm3u5f0","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rrs00tiooxl958c3lzo"},{"post_id":"cixlg9rrt00tjooxl26si2srg","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9rrw00tmooxlqvqya066"},{"post_id":"cixlg9rrt00tjooxl26si2srg","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rrx00tnooxlkib5hq9f"},{"post_id":"cixlg9rrt00tjooxl26si2srg","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rrx00toooxluf7nmioe"},{"post_id":"cixlg9rrt00tjooxl26si2srg","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rrx00tpooxl77t437lo"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rs300tsooxl4h0wl21v"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rs600ttooxlsbhlh3lw"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rs700tuooxlffpptvq3"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rs700tvooxl1jniwdg8"},{"post_id":"cixlg9rs100tqooxl5k76m1y3","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9rs700twooxlyg7lzdc8"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9rsa00tzooxlz4mhvv9j"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rsb00u0ooxlz43k7i2t"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rsb00u1ooxle0nwomhu"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rsb00u2ooxl5pfk6gvj"},{"post_id":"cixlg9rs700txooxlxitu2z26","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rsb00u3ooxlmk3yfrym"},{"post_id":"cixlg9rsc00u4ooxlj8ab512z","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9rsf00u7ooxlkvytlbej"},{"post_id":"cixlg9rsc00u4ooxlj8ab512z","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rsg00u8ooxlawsk17l5"},{"post_id":"cixlg9rsc00u4ooxlj8ab512z","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rsg00u9ooxlrfyz6w67"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rsi00ucooxlwjr6ng4m","_id":"cixlg9rsk00ueooxlyhh5k19v"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rit00irooxlr95e0h0y","_id":"cixlg9rsn00ufooxle3xooeo5"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rj200j5ooxl5hfu647a","_id":"cixlg9rsn00ugooxlma0makap"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9rsn00uhooxl1swk0nx0"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rsn00uiooxly0ty0wej"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rsn00ujooxl5hn83h0p"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rsn00ukooxl12i9xa5i"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rsj00udooxl4sgwnk5b","_id":"cixlg9rsn00ulooxl8gejbzua"},{"post_id":"cixlg9rsg00uaooxljndn1qui","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rsn00umooxl3iftuxgv"},{"post_id":"cixlg9rso00unooxlniigyuwv","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rsr00uqooxl0ys0ivfk"},{"post_id":"cixlg9rso00unooxlniigyuwv","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rss00urooxl0p0rdiqu"},{"post_id":"cixlg9rso00unooxlniigyuwv","tag_id":"cixlg9rsq00upooxl3x7f7dd6","_id":"cixlg9rss00usooxl57d42bj5"},{"post_id":"cixlg9rso00unooxlniigyuwv","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rss00utooxl3sothraw"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9rgl00eqooxl6rx31ll9","_id":"cixlg9rt000uwooxlk81ydpdh"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9rgk00epooxlz9d136ps","_id":"cixlg9rt400uxooxl2dktmxwr"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rt400uyooxldxe9p28h"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rt400uzooxlzku6rj22"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9rt400v0ooxlcn3v6mn7"},{"post_id":"cixlg9rsx00uuooxlshkbqrni","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rt400v1ooxlgcxe3jnc"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rt700v4ooxl5ehy6vpi"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9riy00iyooxlqp6j5wny","_id":"cixlg9rt900v5ooxl7gfpqpyr"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rt900v6ooxlgoehqr5e"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9rt900v7ooxl21c3jx2r"},{"post_id":"cixlg9rt500v2ooxlyhxrer1o","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9rt900v8ooxljayqj9e8"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rtd00vcooxluz7459gr"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9rte00vdooxlpekaav81"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","tag_id":"cixlg9rgr00f2ooxl5h77j5xb","_id":"cixlg9rte00veooxl5u7h0pze"},{"post_id":"cixlg9rta00v9ooxl9eodp9pp","tag_id":"cixlg9rf600c0ooxlh79pc7t9","_id":"cixlg9rte00vfooxlonf5svgl"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rth00viooxlre14q66t"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rtj00vjooxlbf5wnxhe"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rtj00vkooxl8m1rouua"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9rtj00vlooxl6up4ymde"},{"post_id":"cixlg9rtf00vgooxlnbkd5can","tag_id":"cixlg9rl200ljooxlseakivmj","_id":"cixlg9rtj00vmooxllpufqczh"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rtn00vqooxl4ti7pl9e"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rtp00vrooxl20zxds8a"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rtp00vsooxlrhw0ppgb"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rtp00vtooxlw9fluv96"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rb30059ooxlcu3albgd","_id":"cixlg9rtq00vuooxlb9pk1jlk"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rtq00vvooxl25hnfizw"},{"post_id":"cixlg9rtk00vnooxl69lpu6t0","tag_id":"cixlg9rtm00vpooxl0x4ha848","_id":"cixlg9rtq00vwooxlry5s1p06"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rtt00w0ooxlcdbigclw"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rtv00w1ooxli3by6r0d"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9rts00vzooxl6iva4crz","_id":"cixlg9rtw00w2ooxlqwspo771"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9rtw00w3ooxlcie94t60"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9rtw00w4ooxllb4b4ciq"},{"post_id":"cixlg9rtq00vxooxl8iv12hvc","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9rtw00w5ooxl8wbl9z6n"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rtz00w8ooxlgeem2nn0"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ru000w9ooxlskzhvlm5"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9ru000waooxlkln1ue02"},{"post_id":"cixlg9rtw00w6ooxlkgx27f4e","tag_id":"cixlg9rc7006rooxl1vs8rdyg","_id":"cixlg9ru000wbooxlcvn5xmpp"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ru500weooxlkerxwmzo"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ru700wfooxlmmoflcw5"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9ru700wgooxlpgc8ha4w"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9rlr00mfooxlmgoshp8r","_id":"cixlg9ru700whooxlq3sprs6w"},{"post_id":"cixlg9ru100wcooxlcqqts8cq","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9ru700wiooxlkujl4si9"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rua00wlooxljs3szmij"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ruc00wmooxlh9ljff5j"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9ruc00wnooxllz9crb3j"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9ruc00woooxlbhtufdqh"},{"post_id":"cixlg9ru700wjooxldpiytopo","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9ruc00wpooxll2yxu6es"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ruf00wsooxlxin2kez4"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rug00wtooxlehfox906"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rug00wuooxlwhuam3ty"},{"post_id":"cixlg9ruc00wqooxlpzw8wzrg","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9rug00wvooxl578bwecl"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ruk00wyooxlfa3bl9m6"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rul00wzooxldf3kwyba"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","tag_id":"cixlg9rsj00udooxl4sgwnk5b","_id":"cixlg9rul00x0ooxlcp67oy5y"},{"post_id":"cixlg9ruh00wwooxlfh07q9na","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9rul00x1ooxly61vh7ao"},{"post_id":"cixlg9rum00x2ooxlk70b6ezl","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rup00x4ooxl18y5a5wo"},{"post_id":"cixlg9rum00x2ooxlk70b6ezl","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ruq00x5ooxl2wpwejrn"},{"post_id":"cixlg9rum00x2ooxlk70b6ezl","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9ruq00x6ooxlsvf07xqo"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ruu00xaooxltrz8m7e7"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9ruv00xbooxlbuq1u9qt"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","tag_id":"cixlg9rut00x9ooxlcdp781e3","_id":"cixlg9ruv00xcooxls9mpg5y2"},{"post_id":"cixlg9rur00x7ooxlhuw5oi9f","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9ruv00xdooxl65o5nggj"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ruy00xgooxlcvc16u98"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rv000xhooxlqaj6peh5"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rv000xiooxl3ma5mtah"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9rv000xjooxl2t3evd6w"},{"post_id":"cixlg9ruw00xeooxlo4d9l9wm","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rv000xkooxlpcg766ks"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rv400xnooxlcedj2idj"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","tag_id":"cixlg9rtb00vbooxljymxu8cu","_id":"cixlg9rv600xoooxluyyh7zna"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rv600xpooxlfb0t5abv"},{"post_id":"cixlg9rv100xlooxlpu5l47dr","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9rv600xqooxlcjb8moei"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","tag_id":"cixlg9rv900xtooxla3ya2diu","_id":"cixlg9rvb00xuooxle8diskq0"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvc00xvooxl34vgy1mu"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9rvc00xwooxlmoluc6k5"},{"post_id":"cixlg9rv700xrooxl1oxktl3f","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rvc00xxooxlnf0rob9r"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvg00y1ooxldpway2at"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9rdz009dooxl0667i3py","_id":"cixlg9rvi00y2ooxluitqygvg"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rvi00y3ooxl7kur5s6u"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9rvf00y0ooxlaikb14ap","_id":"cixlg9rvi00y4ooxlhupvrjmj"},{"post_id":"cixlg9rvd00xyooxltd7l4l7c","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rvi00y5ooxle1amy8u4"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvm00y9ooxl0q0b5v41"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rvo00yaooxl074ro6sw"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rvo00ybooxlaisdafkt"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rvo00ycooxlmnq158rt"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9rfy00dfooxl3d9e7det","_id":"cixlg9rvo00ydooxl97dyll7i"},{"post_id":"cixlg9rvi00y6ooxlkshkth0r","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9rvo00yeooxl03yqdwsb"},{"post_id":"cixlg9rvp00yfooxldumqyx55","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvr00yhooxllasee5v8"},{"post_id":"cixlg9rvp00yfooxldumqyx55","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rvt00yiooxl8ch3k8sh"},{"post_id":"cixlg9rvp00yfooxldumqyx55","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9rvt00yjooxln7j9l22g"},{"post_id":"cixlg9rvp00yfooxldumqyx55","tag_id":"cixlg9rf600c0ooxlh79pc7t9","_id":"cixlg9rvt00ykooxlydzs3acy"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rvx00yoooxl0wke87o7"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rvy00ypooxleaxkfgoz"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rvy00yqooxlnruk842y"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9rvz00yrooxllwnmtiwp"},{"post_id":"cixlg9rvt00ylooxlsots6p61","tag_id":"cixlg9rvw00ynooxlewljezon","_id":"cixlg9rvz00ysooxle3kgw6fe"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rw200yvooxleqcgmmf9"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rw400ywooxltuz467o7"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rw400yxooxlzl0b4mru"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rw400yyooxlbq0n1xex"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9rw400yzooxlkb1ff4ob"},{"post_id":"cixlg9rvz00ytooxlfpvqw87o","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9rw400z0ooxlu34jthee"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rw800z3ooxlpfjg4f2q"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rw900z4ooxlvw40x2bf"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9rw900z5ooxlhct4nfym"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9rw900z6ooxl6k3mdny1"},{"post_id":"cixlg9rw500z1ooxleae4rpj2","tag_id":"cixlg9rcs007eooxljl4cr6fp","_id":"cixlg9rw900z7ooxlrozs57cc"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rwf00zaooxlua0el9kd"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rwg00zbooxl7g4uubwd"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rwh00zcooxlagcq3zrh"},{"post_id":"cixlg9rwc00z8ooxlcaf0w1yj","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9rwh00zdooxl9cnazoxs"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rwl00zhooxlm7ckdzgh"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rwn00ziooxlu61mpj6m"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9rwk00zgooxl7mcitqah","_id":"cixlg9rwn00zjooxl8lzpu11c"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rwn00zkooxlq2pzyht4"},{"post_id":"cixlg9rwh00zeooxl94ccbys0","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9rwn00zlooxluk18jo67"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rwq00zoooxly661lkyf"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rwt00zpooxlw60apqi4"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rwt00zqooxlkqbq9cp3"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rwt00zrooxln4bb2pte"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9rwt00zsooxlaug9y36y"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9rwt00ztooxljjz0dqrd"},{"post_id":"cixlg9rwo00zmooxl4rjkgjx8","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rwt00zuooxl4eci228y"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rwy00zzooxlzg3utqcq"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rwz0100ooxlfo33i109"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","tag_id":"cixlg9rww00zxooxlxr3mjpwx","_id":"cixlg9rwz0101ooxlrwhv33ur"},{"post_id":"cixlg9rwu00zvooxlp3x9im32","tag_id":"cixlg9rwx00zyooxl7u22v0ag","_id":"cixlg9rwz0102ooxlwkj5wj8k"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rx30105ooxle0n7ezd9"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rx60106ooxla1i9ghit"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rx60107ooxlslhcdi26"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9riy00iyooxlqp6j5wny","_id":"cixlg9rx60108ooxl6m3z08ys"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rx60109ooxl5gjhuzu0"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9rx6010aooxl5gne9c5k"},{"post_id":"cixlg9rx00103ooxl8nvl0ffh","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9rx6010booxlsp2s4ywv"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rxb010fooxl0uk3frm2"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rxd010gooxlc7y7n80e"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9rx9010eooxlyuii46yp","_id":"cixlg9rxd010hooxlcs308d33"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9ri100hbooxlkoeo17fm","_id":"cixlg9rxd010iooxlqmbawoxv"},{"post_id":"cixlg9rx6010cooxlj2093ofg","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rxd010jooxl78awwc7x"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rxg010mooxlnxttty17"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9rxi010nooxlrsfhrg1e"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rxi010oooxlntewb9vy"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9rgq00f1ooxljoqfe3j6","_id":"cixlg9rxi010pooxl24y4xzcv"},{"post_id":"cixlg9rxd010kooxl8kwyqo81","tag_id":"cixlg9rd9008cooxlorh78wc9","_id":"cixlg9rxi010qooxl73m3olir"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rxm010tooxl2grurj8f"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9rxn010uooxlm0ju7v6c"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9rxn010vooxlk2yv4ng5"},{"post_id":"cixlg9rxj010rooxlb78fqxbl","tag_id":"cixlg9riu00isooxlcigd4msu","_id":"cixlg9rxn010wooxlf0q318hi"},{"post_id":"cixlg9rxv010zooxl992znn8t","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rxy0112ooxlce3iz14q"},{"post_id":"cixlg9rxv010zooxl992znn8t","tag_id":"cixlg9rxx0111ooxl9cql4m0g","_id":"cixlg9ry00113ooxl7s89tj02"},{"post_id":"cixlg9rxv010zooxl992znn8t","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ry00114ooxlnfyv3h4q"},{"post_id":"cixlg9rxv010zooxl992znn8t","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9ry00115ooxl5o6sjr7i"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9ry20118ooxlv5uflbnw","_id":"cixlg9ry5011aooxlj89uiycb"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9ry40119ooxlwynjo53g","_id":"cixlg9ry8011booxlmte6pv7f"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9ry8011cooxlww3r4crw"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9ry8011dooxlwq6arqrm"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9ry8011eooxlk9fy9lq7"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rc7006rooxl1vs8rdyg","_id":"cixlg9ry8011fooxlepcwhqwm"},{"post_id":"cixlg9ry00116ooxl48j4l9aq","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9ry8011gooxl204rly4v"},{"post_id":"cixlg9ry8011hooxlyt6940cs","tag_id":"cixlg9ry20118ooxlv5uflbnw","_id":"cixlg9ryc011kooxlzyh2212j"},{"post_id":"cixlg9ry8011hooxlyt6940cs","tag_id":"cixlg9ryb011jooxlj980a8it","_id":"cixlg9ryd011looxliuoka1ad"},{"post_id":"cixlg9ry8011hooxlyt6940cs","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9ryd011mooxllb2y6mh4"},{"post_id":"cixlg9ry8011hooxlyt6940cs","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rye011nooxliscybrvf"},{"post_id":"cixlg9rye011oooxljwdrbzgj","tag_id":"cixlg9ry20118ooxlv5uflbnw","_id":"cixlg9ryh011qooxl8hf0evct"},{"post_id":"cixlg9rye011oooxljwdrbzgj","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9ryi011rooxlwmji9ogh"},{"post_id":"cixlg9rye011oooxljwdrbzgj","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ryi011sooxl71n9wwe7"},{"post_id":"cixlg9ryj011tooxlqxng4x0m","tag_id":"cixlg9ry20118ooxlv5uflbnw","_id":"cixlg9ryl011vooxl6q72nvr4"},{"post_id":"cixlg9ryj011tooxlqxng4x0m","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9ryn011wooxl6scgyhn6"},{"post_id":"cixlg9ryj011tooxlqxng4x0m","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ryn011xooxl2pl9ub3j"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ryr0121ooxlwjvcauor"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9ryt0122ooxlyzta2spf"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9ryt0123ooxlalrfyzbx"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9rhg00gfooxl7ajpt78z","_id":"cixlg9ryt0124ooxlxjjkypum"},{"post_id":"cixlg9ryn011yooxl4lnh3tww","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ryt0125ooxl1nagbg2o"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9ryw0128ooxloqxn7nbz"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9ryy0129ooxl22ci6dtw"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9ryz012aooxl5x5cz1zm"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9ryz012booxlxvlvbchf"},{"post_id":"cixlg9ryt0126ooxlyqbk9q9y","tag_id":"cixlg9rvw00ynooxlewljezon","_id":"cixlg9ryz012cooxl0dz1xc31"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rz3012gooxl1k539181"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9rz6012hooxl2q6dfyci"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rz6012iooxljn4gqdzi"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9rz2012fooxlv35g1ywr","_id":"cixlg9rz6012jooxlm90s9sy3"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9rz6012kooxlao9ash87"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9rz6012looxlr66r3bpn"},{"post_id":"cixlg9ryz012dooxlzzp4ojvx","tag_id":"cixlg9rex00beooxlwxao8570","_id":"cixlg9rz6012mooxlq5men0qf"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rza012pooxlup50tp69"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rzb012qooxlmmfe6aae"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","tag_id":"cixlg9rmn00nsooxl0pr2me3j","_id":"cixlg9rzb012rooxlb5ob0b5n"},{"post_id":"cixlg9rz7012nooxlpm9o4mdc","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rzb012sooxlikypclz6"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rzf012vooxlkbkfkcsx"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rzh012wooxlphl10na3"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9rof00qfooxlq93jumjl","_id":"cixlg9rzh012xooxlnropz9oz"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9rzh012yooxlsaywpwtf"},{"post_id":"cixlg9rzc012tooxlsxa4uvxb","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9rzh012zooxlunsbbbjo"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rzn0132ooxl49j0tfpw"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rzo0133ooxlge1yxwlz"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9rzo0134ooxllvjofz4x"},{"post_id":"cixlg9rzi0130ooxlwf551u6z","tag_id":"cixlg9ra6003mooxl1fo09kse","_id":"cixlg9rzo0135ooxl9ag9cjpg"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rzs0138ooxl3332b1ci"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9rzu0139ooxl3ngivg4j"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","tag_id":"cixlg9rl600lqooxly4jhus6y","_id":"cixlg9rzu013aooxloho6s54c"},{"post_id":"cixlg9rzp0136ooxl1yz71ohq","tag_id":"cixlg9rl600lrooxlwthjx2u0","_id":"cixlg9rzu013booxl09vgcuth"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9rzx013eooxlkrxk8cn6"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s00013fooxlzsxub61j"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s00013gooxl2f07o1vm"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s00013hooxl5kx7aj28"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9s00013iooxlbuqnlqmo"},{"post_id":"cixlg9rzu013cooxlvok6je2x","tag_id":"cixlg9rab003wooxl37uc1xiy","_id":"cixlg9s00013jooxljrk2yp4d"},{"post_id":"cixlg9s01013kooxlpt7nhhab","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s04013mooxlgqvzaba0"},{"post_id":"cixlg9s01013kooxlpt7nhhab","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s05013nooxllgbrdqnd"},{"post_id":"cixlg9s01013kooxlpt7nhhab","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s05013oooxlw9wwewkh"},{"post_id":"cixlg9s06013pooxll1sqek1m","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s08013rooxlood5h1j4"},{"post_id":"cixlg9s06013pooxll1sqek1m","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s09013sooxlj49xr6j3"},{"post_id":"cixlg9s06013pooxll1sqek1m","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s09013tooxlzck8ftmj"},{"post_id":"cixlg9s0a013uooxlg37nsti1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0d013wooxl66q1ofo8"},{"post_id":"cixlg9s0a013uooxlg37nsti1","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s0e013xooxlkhpxsk5m"},{"post_id":"cixlg9s0a013uooxlg37nsti1","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9s0e013yooxlnoz9nkjh"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0i0141ooxliw2njapb"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s0k0142ooxlegbar7xj"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s0k0143ooxl24xpo6ji"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9s0k0144ooxl4x6fzav5"},{"post_id":"cixlg9s0f013zooxl6lho0k0m","tag_id":"cixlg9ri600hlooxlg6n4blh1","_id":"cixlg9s0k0145ooxlfxbch53b"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0o0148ooxl0jtx07w0"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s0p0149ooxlrykyzwak"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s0p014aooxlmehem2hl"},{"post_id":"cixlg9s0l0146ooxlgvaxaqja","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9s0p014booxl24vffhg4"},{"post_id":"cixlg9s0q014cooxluoph4st4","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0t014eooxl1cda0int"},{"post_id":"cixlg9s0q014cooxluoph4st4","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s0v014fooxlusjiedtg"},{"post_id":"cixlg9s0q014cooxluoph4st4","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9s0v014gooxl78n2vwof"},{"post_id":"cixlg9s0q014cooxluoph4st4","tag_id":"cixlg9rut00x9ooxlcdp781e3","_id":"cixlg9s0v014hooxlz7l6c36q"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s0y014kooxluy1c38qn"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s10014looxl4bwx17cg"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9s10014mooxlft7gutkb"},{"post_id":"cixlg9s0w014iooxl1n7w1ay9","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s10014nooxlagx9dml6"},{"post_id":"cixlg9s11014oooxlk15ca9gr","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s14014qooxlzfwmkj2v"},{"post_id":"cixlg9s11014oooxlk15ca9gr","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s15014rooxlh35mtd9x"},{"post_id":"cixlg9s11014oooxlk15ca9gr","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s15014sooxlsjgmu0j7"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s1d014vooxl4umg9hzk"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9ryp0120ooxlouxejw54","_id":"cixlg9s1f014wooxlku0jwk58"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9s1f014xooxlt51kqh0t"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9s1f014yooxlyzlg612f"},{"post_id":"cixlg9s1a014tooxlrxx0i9sh","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9s1f014zooxl7ehephj3"},{"post_id":"cixlg9s1g0150ooxltpgq3ka0","tag_id":"cixlg9s1i0152ooxla05m35n3","_id":"cixlg9s1k0154ooxl9b32t6ot"},{"post_id":"cixlg9s1g0150ooxltpgq3ka0","tag_id":"cixlg9s1j0153ooxlrv98ovk8","_id":"cixlg9s1l0155ooxltvrcng1p"},{"post_id":"cixlg9s1g0150ooxltpgq3ka0","tag_id":"cixlg9rd9008booxlvhckog1m","_id":"cixlg9s1l0156ooxls8df3bme"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s1q015aooxlg6itppam"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","tag_id":"cixlg9s1o0159ooxl6hkwjn6q","_id":"cixlg9s1s015booxlv8yvgnj8"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s1s015cooxl1cw2j8f3"},{"post_id":"cixlg9s1m0157ooxlhi08t0uw","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s1s015dooxlool4m8g3"},{"post_id":"cixlg9s2d015eooxloob8hphs","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s2h015hooxl3fmwmsj0"},{"post_id":"cixlg9s2d015eooxloob8hphs","tag_id":"cixlg9s2g015gooxl90p0wbn7","_id":"cixlg9s2i015iooxl3n210q05"},{"post_id":"cixlg9s2d015eooxloob8hphs","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9s2i015jooxl0iwjjm9f"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s2n015nooxl18podupt"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s2q015oooxlxithyeh7"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s2q015pooxlr10qy1l6"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9s2l015mooxlkeheh0t2","_id":"cixlg9s2q015qooxl24qco4pe"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9s2q015rooxlux5jn8rj"},{"post_id":"cixlg9s2j015kooxlno9phes2","tag_id":"cixlg9rfr00cxooxldhdyuxmz","_id":"cixlg9s2q015sooxlwnd39iy5"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9r7x000kooxl1wzq6q2w","_id":"cixlg9s2u015vooxl4ggvjxis"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s2w015wooxldh7yf4x8"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s2w015xooxlluuawlcs"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s2w015yooxlq1hd7588"},{"post_id":"cixlg9s2r015tooxlois4c85n","tag_id":"cixlg9s2l015mooxlkeheh0t2","_id":"cixlg9s2w015zooxl1pzh6c89"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s320162ooxly0vmfntb"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9s350163ooxlgl3am309"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s350164ooxlkk8p3gta"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s350165ooxl3pr3qq8p"},{"post_id":"cixlg9s2x0160ooxlo3rwggjz","tag_id":"cixlg9rex00beooxlwxao8570","_id":"cixlg9s350166ooxlkyy1ed1m"},{"post_id":"cixlg9s360167ooxl1fok2ucx","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s39016aooxltx2h4tl1"},{"post_id":"cixlg9s360167ooxl1fok2ucx","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s3b016booxl9e6zuv4n"},{"post_id":"cixlg9s360167ooxl1fok2ucx","tag_id":"cixlg9s380169ooxl6lbbs2mr","_id":"cixlg9s3b016cooxlkpjrvi44"},{"post_id":"cixlg9s360167ooxl1fok2ucx","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s3b016dooxl42phfy03"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s3f016gooxlgz2lr3qn"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s3i016hooxlb2br3eo5"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s3i016iooxlbniz24j1"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s3i016jooxlc3ztac5t"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s3i016kooxllkhw03t2"},{"post_id":"cixlg9s3c016eooxlotgt0e0n","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s3i016looxlhhw7hc06"},{"post_id":"cixlg9s3i016mooxlfujpjwv5","tag_id":"cixlg9s3l016oooxlwjlyby5o","_id":"cixlg9s3n016qooxlafwpbdq6"},{"post_id":"cixlg9s3i016mooxlfujpjwv5","tag_id":"cixlg9s3m016pooxlwg1c0auh","_id":"cixlg9s3o016rooxl1y1lbv4x"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s3t016uooxlyqkh34ji"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s3v016vooxlbseqvxla"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s3v016wooxlloi5rqum"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s3w016xooxl95kj3h6u"},{"post_id":"cixlg9s3q016sooxl1qscxmkg","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s3w016yooxlpc7o0vz2"},{"post_id":"cixlg9s3w016zooxl934kfe33","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s3z0171ooxlvyy8by71"},{"post_id":"cixlg9s3w016zooxl934kfe33","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s410172ooxlqnhxl5dq"},{"post_id":"cixlg9s3w016zooxl934kfe33","tag_id":"cixlg9ret00b3ooxllpne01jw","_id":"cixlg9s410173ooxl970ujpzp"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s460178ooxlggdkvza6"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9s440176ooxlcjm0iksp","_id":"cixlg9s4a0179ooxl1t6cpwgc"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s4a017aooxl85r18pyt"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s4a017booxlx6qn1731"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s4a017cooxlcdbk318v"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s4a017dooxlk4w72hdl"},{"post_id":"cixlg9s410174ooxl2pkymw5v","tag_id":"cixlg9rhp00gqooxlwhqlb558","_id":"cixlg9s4a017eooxlry3opppp"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s4e017hooxlwwq34bpu"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","tag_id":"cixlg9s440176ooxlcjm0iksp","_id":"cixlg9s4f017iooxle8jyzyu1"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s4f017jooxler5sy21h"},{"post_id":"cixlg9s4b017fooxl29wv8xxx","tag_id":"cixlg9rh500ftooxliog0rt8q","_id":"cixlg9s4f017kooxlx73u0i2r"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","tag_id":"cixlg9s4m017pooxlba720hsh","_id":"cixlg9s4n017qooxlbwoxibpv"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s4p017rooxl73k5jdxg"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9s4p017sooxlc0d83hkp"},{"post_id":"cixlg9s4j017nooxl9ak6md5m","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s4p017tooxl5osdqbuf"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9s4m017pooxlba720hsh","_id":"cixlg9s4t017wooxl7dmz841d"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s4v017xooxlg5e7xgh0"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s4v017yooxlueq6x274"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s4v017zooxlmcxvp1jl"},{"post_id":"cixlg9s4q017uooxldtfgrhmn","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9s4v0180ooxlca33kfxm"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9s4m017pooxlba720hsh","_id":"cixlg9s500183ooxlascyzw86"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s550184ooxlurjyhl74"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9s550185ooxlgibv0xvg"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9s550186ooxlox7th305"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9s550187ooxl6zmhm9pd"},{"post_id":"cixlg9s4w0181ooxlklyp0pa2","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9s550188ooxlook85s0d"},{"post_id":"cixlg9s560189ooxl8r20eqsp","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9s5a018booxlbe4wwuov"},{"post_id":"cixlg9s560189ooxl8r20eqsp","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9s5c018cooxlwc8v8mzq"},{"post_id":"cixlg9s560189ooxl8r20eqsp","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9s5c018dooxlorp1i60m"},{"post_id":"cixlg9s560189ooxl8r20eqsp","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9s5c018eooxl8v8r5gzq"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s5h018iooxlr2mnssb5"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s5n018jooxlrdyni1qv"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s5o018kooxleny2f2vw"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s5o018looxlgn6ucqrn"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s5o018mooxlc0xsj4eg"},{"post_id":"cixlg9s5d018fooxl5ozgscbd","tag_id":"cixlg9s5g018hooxlgrq3o7qc","_id":"cixlg9s5o018nooxlwm5rfx8l"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s5u018qooxl6gcms8f8"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s5x018rooxlq81e973l"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s5x018sooxl5slftrln"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s5x018tooxlqw10gttx"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s5x018uooxl2lfhkynd"},{"post_id":"cixlg9s5p018oooxl27rq9qgn","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s5x018vooxlbujwqpvh"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s61018yooxlpekde3ps"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s64018zooxllw5ao4zt"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s640190ooxliuvi61eo"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s640191ooxl1ewx7l4i"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s640192ooxlalf40gse"},{"post_id":"cixlg9s5y018wooxl7i0ua8vq","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s640193ooxl4dbmac9k"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s680196ooxlt8ggyd61"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s6b0197ooxl9s16kbce"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s6b0198ooxlkpmh5l46"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s6b0199ooxl6rjw8xp9"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s6b019aooxl3izi5uld"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s6b019booxlh0agbtw4"},{"post_id":"cixlg9s640194ooxl2r9h3e11","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9s6b019cooxlbqd4m6mt"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s6h019fooxl9qsq3kr8"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s6l019gooxlq7f1k7lv"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s6l019hooxlanxc83s3"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s6l019iooxldaa3a3u8"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s6l019jooxlmjzqlbj5"},{"post_id":"cixlg9s6c019dooxlmh2jkbae","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s6l019kooxlqogdzhls"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s6t019nooxl83ab51op"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s6w019oooxltn9lzoo0"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s6w019pooxl45mwt657"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9s6w019qooxljggog67c"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9s6w019rooxlva5a6a88"},{"post_id":"cixlg9s6n019looxlzh13wmyd","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s6w019sooxl89bksf2y"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s70019vooxl5ixpp3hw"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s74019wooxl73vsmufz"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s74019xooxltiofe1rb"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s74019yooxldv9lg2x8"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s74019zooxl7tkhytsn"},{"post_id":"cixlg9s6x019tooxl5anzrb2l","tag_id":"cixlg9s5g018hooxlgrq3o7qc","_id":"cixlg9s7401a0ooxl04t2rt29"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s7901a3ooxl9s38gl4s"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s7b01a4ooxlx93wnzpw"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s7b01a5ooxlj5jag5ua"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s7b01a6ooxlgyk173pv"},{"post_id":"cixlg9s7501a1ooxlw7ha4em1","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s7b01a7ooxlaflx8zq7"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s7f01aaooxl99d1h095"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s7i01abooxlrzdp8uld"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s7i01acooxld1svdu67"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s7i01adooxlh7meshhj"},{"post_id":"cixlg9s7c01a8ooxl7adpki8y","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s7i01aeooxlpgae3uop"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s7m01ahooxl3q2z48un"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s7p01aiooxlp65zh2bq"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s7p01ajooxlkh13w2ub"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s7p01akooxl1wqn14fe"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9s7p01alooxljh1ajg81"},{"post_id":"cixlg9s7j01afooxl6pdqftlp","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s7q01amooxl6jzeh8op"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s7u01apooxlpalirjkj"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s7x01aqooxlun6r5o4d"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s7x01arooxl2h0yhz7q"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s7x01asooxlfziup17p"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s7x01atooxlxgdtpj51"},{"post_id":"cixlg9s7q01anooxl1oz6bhqz","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9s7x01auooxlsc4o5hy0"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9ri600hkooxlzzsveto4","_id":"cixlg9s8201ayooxlbzit41i1"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9s8001axooxlyobic1zh","_id":"cixlg9s8501azooxly32fzx2z"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9reo00asooxlwj0nsdlc","_id":"cixlg9s8501b0ooxl205hh8nk"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s8501b1ooxl2k29w1qp"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s8501b2ooxl8a1zmn7x"},{"post_id":"cixlg9s7y01avooxl5ku8le04","tag_id":"cixlg9rof00qfooxlq93jumjl","_id":"cixlg9s8501b3ooxllfvfblv8"},{"post_id":"cixlg9s8601b4ooxl9xtoeca1","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s8901b6ooxllcsnww4q"},{"post_id":"cixlg9s8601b4ooxl9xtoeca1","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9s8a01b7ooxlz2jr3ks1"},{"post_id":"cixlg9s8601b4ooxl9xtoeca1","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s8b01b8ooxlt19v2oi9"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9s8f01bbooxlcmjhx677"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s8i01bcooxl3lhcxa67"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s8i01bdooxlfghhbicc"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s8i01beooxl2xk5lv2f"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9rh000fjooxlob9h9hrs","_id":"cixlg9s8i01bfooxl4z9f9hg3"},{"post_id":"cixlg9s8b01b9ooxlt9mufp9o","tag_id":"cixlg9s450177ooxl6o0v9ah2","_id":"cixlg9s8i01bgooxl722prcjx"},{"post_id":"cixlg9s8j01bhooxlw1ixjot5","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s8m01bjooxl58is72ie"},{"post_id":"cixlg9s8j01bhooxlw1ixjot5","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s8n01bkooxlbvvg2z5w"},{"post_id":"cixlg9s8j01bhooxlw1ixjot5","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9s8n01blooxl2f910c1i"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s8r01boooxlgmzdjf3e"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s8t01bpooxlcoa7t8sw"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9s8t01bqooxl9djo5ts0"},{"post_id":"cixlg9s8o01bmooxl9ynl5qen","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9s8t01brooxly69mpn95"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s8x01buooxlihe6f15j"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s8z01bvooxlnuvdnefb"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9rex00bfooxld9yilwth","_id":"cixlg9s8z01bwooxlg4uchppy"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9rbl005vooxl8g5rzkci","_id":"cixlg9s8z01bxooxlwq59k1v1"},{"post_id":"cixlg9s8u01bsooxl09eayfj8","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9s8z01byooxli67hrgbr"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s9301c1ooxlhlbwd6uy"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s9601c2ooxl5ppt7bad"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9s9601c3ooxlpfpfmcik"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9s9601c4ooxl8fd7tcl1"},{"post_id":"cixlg9s9001bzooxlvzne69or","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9s9601c5ooxl7dgmd1iu"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s9a01c8ooxln2eee8eq"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s9c01c9ooxl689kll4q"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9s9c01caooxlwalb5bg3"},{"post_id":"cixlg9s9701c6ooxlp3f7afsi","tag_id":"cixlg9rn800olooxln9dpmyn1","_id":"cixlg9s9c01cbooxllvdbk4c5"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s9h01cfooxllypqden0"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9s9k01cgooxl3zt8urbv"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9s9k01chooxl2qi4ghrb"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9s9k01ciooxl1xtgo6sc"},{"post_id":"cixlg9s9d01ccooxl31kv6hwb","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9s9k01cjooxlrgfnl6ph"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9s9o01cmooxlxp8aosdd"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9s9q01cnooxl6qaqiqv9"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9s9q01coooxlnm8wms6a"},{"post_id":"cixlg9s9l01ckooxlliudo3kh","tag_id":"cixlg9rn800olooxln9dpmyn1","_id":"cixlg9s9q01cpooxljkat3o5u"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9s9y01cuooxl0liikocq"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9s9v01csooxlmermlh5i","_id":"cixlg9sa101cvooxl1v3jmibr"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sa101cwooxlavbtdk8u"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sa101cxooxlffnnjyga"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9r7g0003ooxlouh2e40f","_id":"cixlg9sa101cyooxll81af90i"},{"post_id":"cixlg9s9r01cqooxlimg9hty7","tag_id":"cixlg9s9x01ctooxleb6zfw7h","_id":"cixlg9sa101czooxlb15hz2uv"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sa501d2ooxli9ynvywr"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","tag_id":"cixlg9rfy00dfooxl3d9e7det","_id":"cixlg9sa701d3ooxlafqk99k7"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9sa701d4ooxl66l6v9l6"},{"post_id":"cixlg9sa201d0ooxlvy3jjpt2","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9sa701d5ooxl2s5sdt3p"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9sab01d8ooxlzeyhdtns","_id":"cixlg9sad01d9ooxlwazs3o5s"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sag01daooxldhshhhpu"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9sag01dbooxl8c0ik6kg"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sag01dcooxl0nl8nbyl"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sag01ddooxlqnwt6770"},{"post_id":"cixlg9sa801d6ooxltw9m0m0q","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9sag01deooxli655cihj"},{"post_id":"cixlg9saj01dfooxlkcflucvz","tag_id":"cixlg9sab01d8ooxlzeyhdtns","_id":"cixlg9sam01dhooxli5g0u2cl"},{"post_id":"cixlg9saj01dfooxlkcflucvz","tag_id":"cixlg9rar004hooxlh2cneg9p","_id":"cixlg9sao01diooxl6o66ftkv"},{"post_id":"cixlg9saj01dfooxlkcflucvz","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sao01djooxl2im0mgbq"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sar01dmooxl94z08hsh"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sat01dnooxl6e3ubc9d"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sat01doooxlgpauywbt"},{"post_id":"cixlg9sao01dkooxl00fmrn5m","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9sat01dpooxl4fjxnqf9"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9saz01dtooxlksnfzk1e"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9sax01dsooxlao4x3j2t","_id":"cixlg9sb101duooxl7b8420jc"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9sb101dvooxl52cd45oe"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9sb101dwooxll00pfzwk"},{"post_id":"cixlg9sau01dqooxlnxqow11w","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sb101dxooxl5pzhmv8l"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sb601e1ooxl57hcd5cr"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sba01e2ooxlhjk7rsac"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9rab003vooxlzfo01j5s","_id":"cixlg9sba01e3ooxlhpgoo1uc"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9rb8005hooxlvkuj3iik","_id":"cixlg9sba01e4ooxl6k1wuf3r"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sba01e5ooxl8jsbmux8"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9sb501e0ooxlvk8hqk17","_id":"cixlg9sba01e6ooxls1tug3cj"},{"post_id":"cixlg9sb201dyooxl6v5leuke","tag_id":"cixlg9rav004qooxldtjdx275","_id":"cixlg9sba01e7ooxl1fdattwa"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sbe01eaooxl0csr839h"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sbh01ebooxlx1qtp8a2"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","tag_id":"cixlg9rb30059ooxlcu3albgd","_id":"cixlg9sbh01ecooxla5ts68li"},{"post_id":"cixlg9sbb01e8ooxlhjtta6av","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sbh01edooxlil8dpp5u"},{"post_id":"cixlg9sbh01eeooxla294l35s","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sbl01egooxlkka80qv1"},{"post_id":"cixlg9sbh01eeooxla294l35s","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sbm01ehooxlhtb2b0kv"},{"post_id":"cixlg9sbh01eeooxla294l35s","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9sbm01eiooxlujibyoje"},{"post_id":"cixlg9sbn01ejooxlsdjn57bi","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sbq01elooxlvoce974w"},{"post_id":"cixlg9sbn01ejooxlsdjn57bi","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sbr01emooxl8ldj94hy"},{"post_id":"cixlg9sbn01ejooxlsdjn57bi","tag_id":"cixlg9rbz006cooxlo6c2fj1p","_id":"cixlg9sbr01enooxl9irqw02a"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sby01esooxlkkh0pj8n"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sc101etooxl50rh7swi"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sc101euooxllqa4e7tk"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sc101evooxllekebwu4"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9sbv01eqooxlwg5rkdwl","_id":"cixlg9sc101ewooxlmb82ru67"},{"post_id":"cixlg9sbs01eoooxlp93dnb2z","tag_id":"cixlg9sbw01erooxl4wqdz5la","_id":"cixlg9sc101exooxl5e4y96y7"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sc501f0ooxlgslufy7c"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9sc801f1ooxlfa2jd70x"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sc801f2ooxl07h7ihxq"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sc801f3ooxlozermc1t"},{"post_id":"cixlg9sc201eyooxlr7xobk40","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9sc801f4ooxls6r8k1n7"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9scc01f7ooxli86a6ku4"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sce01f8ooxlwn5sfuza"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9sce01f9ooxltwpvpfye"},{"post_id":"cixlg9sc901f5ooxlt4ls5piq","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sce01faooxlo6yvynvu"},{"post_id":"cixlg9scf01fbooxllohwmidy","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sci01fdooxlt1xs402j"},{"post_id":"cixlg9scf01fbooxllohwmidy","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9sck01feooxlg60v3d15"},{"post_id":"cixlg9scf01fbooxllohwmidy","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sck01ffooxlyzmeo41g"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9scp01fiooxlf1vyjq5j"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9scr01fjooxl8h1ehux5"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9scr01fkooxl22sh77m3"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9scr01flooxlczsv3gmo"},{"post_id":"cixlg9scl01fgooxltchcuriw","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9scr01fmooxly11cwm49"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9scw01fpooxlzgtwp2ec"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9scz01fqooxllwcs9pgf"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9scz01frooxlfsc2ilw4"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9scz01fsooxl641ehnoz"},{"post_id":"cixlg9scs01fnooxlnm5ke1v2","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9scz01ftooxl5hc80y2i"},{"post_id":"cixlg9sd001fuooxld0xz6w8z","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sd501fwooxl3co7fuqn"},{"post_id":"cixlg9sd001fuooxld0xz6w8z","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9sd601fxooxlrs59ijik"},{"post_id":"cixlg9sd001fuooxld0xz6w8z","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sd601fyooxl2yythiwc"},{"post_id":"cixlg9sd701fzooxlgv99imzv","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sda01g1ooxlbp6jyc80"},{"post_id":"cixlg9sd701fzooxlgv99imzv","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9sdc01g2ooxly2fudsjm"},{"post_id":"cixlg9sd701fzooxlgv99imzv","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sdc01g3ooxldeduyalu"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sdg01g6ooxl10necm2g"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sdi01g7ooxlrj096lj5"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9sdi01g8ooxlmt5sxsgl"},{"post_id":"cixlg9sdc01g4ooxl4pl7m6x7","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9sdi01g9ooxligu6crxy"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sdn01gcooxlzhqffetw"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9sab01d8ooxlzeyhdtns","_id":"cixlg9sdq01gdooxlii9upjz6"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sdq01geooxlv6rggect"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9sdq01gfooxly5ofdde4"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9rfy00deooxl4rys2yhu","_id":"cixlg9sdq01ggooxle0nuypfy"},{"post_id":"cixlg9sdj01gaooxlldwx269a","tag_id":"cixlg9rfz00dgooxl7dflz7zw","_id":"cixlg9sdq01ghooxliqmv9g93"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sdu01gkooxlz6beifaf"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sdx01glooxl4ipy8l5x"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sdx01gmooxle2q1a6ec"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9sdx01gnooxl9nvf8m8u"},{"post_id":"cixlg9sdr01giooxlxt70lzsf","tag_id":"cixlg9rn200obooxl8e4bkjz3","_id":"cixlg9sdx01goooxli97014yl"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9se101grooxl0z22e5lq"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9se401gsooxla9pg7it2"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9se401gtooxltg4ev1gw"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9se401guooxl4evr19ke"},{"post_id":"cixlg9sdy01gpooxlb5n43bq4","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9se401gvooxlbhplze7m"},{"post_id":"cixlg9se501gwooxl4he1heaz","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9se901gyooxl5hz7ph5s"},{"post_id":"cixlg9se501gwooxl4he1heaz","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sea01gzooxld02fiuog"},{"post_id":"cixlg9se501gwooxl4he1heaz","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9sea01h0ooxl0emoslsv"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9seg01h4ooxlxm4fxvny"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9sej01h5ooxl1dv34rp6"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9see01h3ooxlcc3v1zyy","_id":"cixlg9sej01h6ooxlocg89h2f"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9sej01h7ooxladwrrxog"},{"post_id":"cixlg9seb01h1ooxlnh5z10y5","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sej01h8ooxla3nat7oq"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sep01hbooxlxzo0gxhx"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9ser01hcooxltmdjl58w"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9ser01hdooxln6c19lz5"},{"post_id":"cixlg9sel01h9ooxlbob18bs1","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9ser01heooxlw9ifljbs"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sew01hhooxlxiqfls76"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9rz2012fooxlv35g1ywr","_id":"cixlg9sey01hiooxlcwt6qqw2"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sez01hjooxlfhgnjr2t"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9rex00beooxlwxao8570","_id":"cixlg9sez01hkooxldszm82ar"},{"post_id":"cixlg9ses01hfooxlfbrle23q","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sez01hlooxlnunbj4tx"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sf301hoooxlicy41ue0"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sf601hpooxlyl2ob9bt"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9sf601hqooxlezf9bznq"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9sf601hrooxl9y4c5ty8"},{"post_id":"cixlg9sez01hmooxlc2dlr6n3","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9sf601hsooxln318g8xp"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sfa01hvooxlr1u7sjp3"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9sfd01hwooxlf34jausc"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9sfd01hxooxlscrm265b"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sfd01hyooxlt6u91gt6"},{"post_id":"cixlg9sf701htooxlxaoc9nf8","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9sfd01hzooxlg8uclgtb"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sfk01i2ooxlxsikpt84"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sfn01i3ooxlvqm9jlue"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sfn01i4ooxlmotyywdq"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sfn01i5ooxlqfo9t7jf"},{"post_id":"cixlg9sfg01i0ooxlihy27wv6","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sfn01i6ooxl3arj4qtz"},{"post_id":"cixlg9sfo01i7ooxlz6m9wk11","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sfs01i9ooxlua29uttn"},{"post_id":"cixlg9sfo01i7ooxlz6m9wk11","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sft01iaooxljtl8oln5"},{"post_id":"cixlg9sfo01i7ooxlz6m9wk11","tag_id":"cixlg9rsq00upooxl3x7f7dd6","_id":"cixlg9sft01ibooxl66ayx9y0"},{"post_id":"cixlg9sfu01icooxl6b4q2hml","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sfz01ieooxl802v2i5l"},{"post_id":"cixlg9sfu01icooxl6b4q2hml","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sg101ifooxle0ybnkrg"},{"post_id":"cixlg9sfu01icooxl6b4q2hml","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9sg101igooxl16wki9bh"},{"post_id":"cixlg9sg201ihooxlf6fgnhkg","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sg601ijooxltq2y2jzm"},{"post_id":"cixlg9sg201ihooxlf6fgnhkg","tag_id":"cixlg9rgr00f2ooxl5h77j5xb","_id":"cixlg9sg701ikooxlxr3hxoaa"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sgb01inooxlnf9z559i"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9sgg01ioooxlnkywsj5a"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sgg01ipooxlmstrrmwn"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sgg01iqooxljyqjxvly"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9sgg01irooxlykyant8k"},{"post_id":"cixlg9sg701ilooxlvxbywlgz","tag_id":"cixlg9rn800olooxln9dpmyn1","_id":"cixlg9sgh01isooxl1qkwqrjo"},{"post_id":"cixlg9sgh01itooxl4uq404pe","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sgl01ivooxll3j5i550"},{"post_id":"cixlg9sgh01itooxl4uq404pe","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9sgn01iwooxlom8e8rz6"},{"post_id":"cixlg9sgh01itooxl4uq404pe","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9sgn01ixooxlcd0vrwf4"},{"post_id":"cixlg9sgh01itooxl4uq404pe","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9sgn01iyooxlg9wa56sm"},{"post_id":"cixlg9sgo01izooxlvy5gpnck","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sgr01j1ooxl0rrbb1pv"},{"post_id":"cixlg9sgo01izooxlvy5gpnck","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sgt01j2ooxlkz6qowk8"},{"post_id":"cixlg9sgo01izooxlvy5gpnck","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9sgt01j3ooxlha2pa25x"},{"post_id":"cixlg9sgu01j4ooxlhpdlz7gb","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sgx01j6ooxl5so88b2s"},{"post_id":"cixlg9sgu01j4ooxlhpdlz7gb","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9sgz01j7ooxl3s0ntc5t"},{"post_id":"cixlg9sgu01j4ooxlhpdlz7gb","tag_id":"cixlg9r7x000kooxl1wzq6q2w","_id":"cixlg9sgz01j8ooxlokos0atz"},{"post_id":"cixlg9sh001j9ooxlbo7maly2","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sh301jbooxl64g6jhuq"},{"post_id":"cixlg9sh001j9ooxlbo7maly2","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9sh501jcooxlwydgc34g"},{"post_id":"cixlg9sh001j9ooxlbo7maly2","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sh501jdooxlo9qkzkgl"},{"post_id":"cixlg9sh601jeooxl6gdfag18","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9shb01jhooxll2iigb28"},{"post_id":"cixlg9sh601jeooxl6gdfag18","tag_id":"cixlg9r96002qooxl5r2zlzp3","_id":"cixlg9shd01jiooxlsnanvdba"},{"post_id":"cixlg9sh601jeooxl6gdfag18","tag_id":"cixlg9sh901jgooxlcbu0n7lg","_id":"cixlg9shd01jjooxly0w7stx9"},{"post_id":"cixlg9sh601jeooxl6gdfag18","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9shd01jkooxlzzddc8ep"},{"post_id":"cixlg9she01jlooxl1qtik5ks","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9shh01jnooxl2mbmm8bf"},{"post_id":"cixlg9she01jlooxl1qtik5ks","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9shk01joooxle2rj7wbd"},{"post_id":"cixlg9she01jlooxl1qtik5ks","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9shk01jpooxlo3g18fq8"},{"post_id":"cixlg9she01jlooxl1qtik5ks","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9shk01jqooxlr5vsxelk"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sho01jtooxlw5kzl0rf"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9shr01juooxl58mpxr6y"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9shr01jvooxlrjws1tpk"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9shr01jwooxlq674j8f8"},{"post_id":"cixlg9shl01jrooxl0bhviy1k","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9shr01jxooxlsfqyg4ko"},{"post_id":"cixlg9shs01jyooxle7mhon4u","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9shw01k0ooxlbf5pmsi5"},{"post_id":"cixlg9shs01jyooxle7mhon4u","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9shx01k1ooxlret9mlcs"},{"post_id":"cixlg9shs01jyooxle7mhon4u","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9shx01k2ooxlq0ys70uh"},{"post_id":"cixlg9shy01k3ooxld3fb801r","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9si201k5ooxle5lh7hoe"},{"post_id":"cixlg9shy01k3ooxld3fb801r","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9si401k6ooxl2gah9f3v"},{"post_id":"cixlg9shy01k3ooxld3fb801r","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9si401k7ooxlewyis2rj"},{"post_id":"cixlg9shy01k3ooxld3fb801r","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9si401k8ooxl4k8s8bx2"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9si801kbooxlk0bguwl6"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r7g0004ooxlpu66horl","_id":"cixlg9sib01kcooxllpnmk968"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9sib01kdooxl0w1282ub"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sib01keooxl2fbf1dam"},{"post_id":"cixlg9si501k9ooxlkdf2kt40","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sib01kfooxldfe80j08"},{"post_id":"cixlg9sic01kgooxlh6482eho","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sii01kjooxlas7dfv1j"},{"post_id":"cixlg9sic01kgooxlh6482eho","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sik01kkooxl4blq9bxf"},{"post_id":"cixlg9sic01kgooxlh6482eho","tag_id":"cixlg9sig01kiooxl0qora2h0","_id":"cixlg9sik01klooxlvfxsvw4m"},{"post_id":"cixlg9sic01kgooxlh6482eho","tag_id":"cixlg9rcm0075ooxlzl3dcu1u","_id":"cixlg9sik01kmooxl4lpw1u6v"},{"post_id":"cixlg9sil01knooxlo1st7o09","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sip01kpooxlchnr9fkl"},{"post_id":"cixlg9sil01knooxlo1st7o09","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sis01kqooxlp3ue0coy"},{"post_id":"cixlg9sil01knooxlo1st7o09","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sis01krooxl25g5wrux"},{"post_id":"cixlg9sil01knooxlo1st7o09","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sis01ksooxlewrc5l0r"},{"post_id":"cixlg9sit01ktooxl5amhekiy","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9six01kvooxlqm402a0o"},{"post_id":"cixlg9sit01ktooxl5amhekiy","tag_id":"cixlg9r8q001oooxltzzq2ggv","_id":"cixlg9siz01kwooxlvat6j569"},{"post_id":"cixlg9sit01ktooxl5amhekiy","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9siz01kxooxlbm4ol1dq"},{"post_id":"cixlg9sit01ktooxl5amhekiy","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9siz01kyooxlr0tlvc8o"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sj801l1ooxl3c4yzzgm"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sjc01l2ooxl03dzrl5r"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sjc01l3ooxlos6yqlka"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9sjc01l4ooxl80cz18k3"},{"post_id":"cixlg9sj301kzooxlp726ykia","tag_id":"cixlg9r8l001iooxldlw1thtn","_id":"cixlg9sjc01l5ooxlslvclwws"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sjk01l8ooxlo6mnawfa"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sjn01l9ooxl72rpva01"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9sjn01laooxlzpy9a3m7"},{"post_id":"cixlg9sjd01l6ooxlwpwa5oi0","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9sjn01lbooxlme1ddjcx"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sjs01leooxl23bo1zna"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sjv01lfooxlfq9ay3dm"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sjv01lgooxleaigsk2v"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9sjv01lhooxlfzar84lw"},{"post_id":"cixlg9sjo01lcooxl36c3xbdc","tag_id":"cixlg9s9f01ceooxl27qmc1ld","_id":"cixlg9sjv01liooxl6ll23ybw"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sk101llooxl5pb6r7ku"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","tag_id":"cixlg9rbk005uooxlb05mbcgh","_id":"cixlg9sk401lmooxlvcebuml7"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","tag_id":"cixlg9rg200dpooxlpxgfrm7a","_id":"cixlg9sk401lnooxlxm0hikh5"},{"post_id":"cixlg9sjw01ljooxlc2d2aocm","tag_id":"cixlg9rau004pooxlsan64mz1","_id":"cixlg9sk401loooxl6yxb1112"},{"post_id":"cixlg9sk501lpooxllld15m00","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sk801lrooxliutqsc9e"},{"post_id":"cixlg9sk501lpooxllld15m00","tag_id":"cixlg9rrv00tlooxl6yjfntb3","_id":"cixlg9ska01lsooxl1nd6bkbu"},{"post_id":"cixlg9sk501lpooxllld15m00","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9ska01ltooxln5mj78mg"},{"post_id":"cixlg9skb01luooxlybp32p0j","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9skk01lwooxlq2ngx388"},{"post_id":"cixlg9skb01luooxlybp32p0j","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9skm01lxooxl2vyjzx31"},{"post_id":"cixlg9skb01luooxlybp32p0j","tag_id":"cixlg9raz0051ooxl916ggp6y","_id":"cixlg9skm01lyooxlytxowiv0"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","tag_id":"cixlg9rc8006sooxl8iyr5nub","_id":"cixlg9skr01m1ooxl70m4v21p"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9skt01m2ooxl49d1nbfu"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","tag_id":"cixlg9rbi005tooxledxvr0pf","_id":"cixlg9skt01m3ooxlszzjntvd"},{"post_id":"cixlg9skn01lzooxl1c1iro6x","tag_id":"cixlg9r7h0006ooxlkks9dhtl","_id":"cixlg9skt01m4ooxld8i28lz1"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sky01m7ooxl0u9tshwu"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9rej00afooxlb4lvl9wu","_id":"cixlg9sl101m8ooxlogoiffkz"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9sl101m9ooxl12ajrc3t"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9sl101maooxlia3z5nqt"},{"post_id":"cixlg9sku01m5ooxlitgi4rbt","tag_id":"cixlg9rej00agooxlg957oy88","_id":"cixlg9sl101mbooxl2sx9bsxt"},{"post_id":"cixlg9sl201mcooxlv07ksmff","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sl601meooxlqy4twtb9"},{"post_id":"cixlg9sl201mcooxlv07ksmff","tag_id":"cixlg9rvk00y8ooxljxtmuyiu","_id":"cixlg9sl801mfooxlhzgjcs6r"},{"post_id":"cixlg9sl201mcooxlv07ksmff","tag_id":"cixlg9ra7003nooxlw398qyzu","_id":"cixlg9sl801mgooxlw0marjvb"},{"post_id":"cixlg9sl201mcooxlv07ksmff","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9sl801mhooxlozh3mki0"},{"post_id":"cixlg9sl901miooxljfxbb22y","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sld01mkooxlshferh9k"},{"post_id":"cixlg9sl901miooxljfxbb22y","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9slg01mlooxlh90e6jiw"},{"post_id":"cixlg9sl901miooxljfxbb22y","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9slg01mmooxlme9ibyqw"},{"post_id":"cixlg9sl901miooxljfxbb22y","tag_id":"cixlg9r890014ooxlijrzvrc1","_id":"cixlg9slg01mnooxl0l81134x"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9slm01mrooxleowwkf4z"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9slp01msooxlk174v6m3"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9slp01mtooxlhteynnnw"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9slj01mqooxldc9qajm0","_id":"cixlg9slp01muooxl72bp4mut"},{"post_id":"cixlg9slg01moooxltxsdu2p9","tag_id":"cixlg9rg300dqooxljoaconen","_id":"cixlg9slp01mvooxlcw6zkp2r"},{"post_id":"cixlg9slq01mwooxlefrrc6zm","tag_id":"cixlg9rao004aooxlk0p6c313","_id":"cixlg9slt01myooxl86bhxz1g"},{"post_id":"cixlg9slq01mwooxlefrrc6zm","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9slu01mzooxlsicc5rer"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sma01n6ooxlyxuevsdk"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","tag_id":"cixlg9sm701n4ooxl7zlbu8l9","_id":"cixlg9smd01n7ooxlwjxwd5yu"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9smd01n8ooxlljvbd0ai"},{"post_id":"cixlg9sm301n2ooxlq7v6oo1l","tag_id":"cixlg9sm801n5ooxl8g1hv5ne","_id":"cixlg9smd01n9ooxlf44wxeur"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9smi01ncooxlzn6a5357"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9sm701n4ooxl7zlbu8l9","_id":"cixlg9sml01ndooxl6zsn7vnv"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sml01neooxltnz5e7gk"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9r8v0020ooxlw36qxixv","_id":"cixlg9sml01nfooxl0d1bq3f3"},{"post_id":"cixlg9smd01naooxliy5evulj","tag_id":"cixlg9r8v001zooxlcpw9gdef","_id":"cixlg9sml01ngooxlawjv01op"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9smt01nmooxl49ezcnm8"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9sm701n4ooxl7zlbu8l9","_id":"cixlg9smz01nnooxl27vy02yo"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9rcn0076ooxl3h88991m","_id":"cixlg9smz01noooxlge58qars"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9r90002aooxlgrd2fgg3","_id":"cixlg9smz01npooxle5v8y5oq"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9r90002booxli7z03vs8","_id":"cixlg9smz01nqooxlwxyiyia6"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9smp01njooxlytyl9kii","_id":"cixlg9smz01nrooxldzdfsxmj"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9smq01nkooxlrcpmhl1t","_id":"cixlg9smz01nsooxlw0v6kj5u"},{"post_id":"cixlg9smm01nhooxlgmz9268i","tag_id":"cixlg9smr01nlooxlcaizbhnv","_id":"cixlg9smz01ntooxl24x74l0m"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9sn501nxooxlmnysmjte"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9sn301nwooxlx3m2uyjt","_id":"cixlg9sn901nyooxlxrc39gu2"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sn901nzooxlo62ru2dl"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9r82000uooxl4p625n8c","_id":"cixlg9sn901o0ooxln3kk6ic7"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9roo00qxooxl28ecubjc","_id":"cixlg9sn901o1ooxlrnvh4qmq"},{"post_id":"cixlg9sn001nuooxlg7lxrwrf","tag_id":"cixlg9r82000vooxly90aizya","_id":"cixlg9sn901o2ooxllizvbkq8"},{"post_id":"cixlg9snb01o3ooxl45snx359","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9snj01o5ooxlrfub6oz4"},{"post_id":"cixlg9snb01o3ooxl45snx359","tag_id":"cixlg9sn301nwooxlx3m2uyjt","_id":"cixlg9snn01o6ooxlgqnt3aor"},{"post_id":"cixlg9snb01o3ooxl45snx359","tag_id":"cixlg9rse00u6ooxlnjgn3lg4","_id":"cixlg9snn01o7ooxlzc1t57y0"},{"post_id":"cixlg9snb01o3ooxl45snx359","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9snn01o8ooxlsxgjl2i3"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9snu01ocooxlweyqkm1i"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9sn301nwooxlx3m2uyjt","_id":"cixlg9snx01odooxlmlyv95e3"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9snx01oeooxl5gdfr9ng"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9rd40082ooxlb1eovlp3","_id":"cixlg9snx01ofooxllkskd08o"},{"post_id":"cixlg9sno01o9ooxlgt1j214s","tag_id":"cixlg9sns01obooxlkc2bvkb3","_id":"cixlg9snx01ogooxlx2tevstb"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9r7w000iooxlt8ncwmsh","_id":"cixlg9so201ojooxlzq49z6w7"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9sn301nwooxlx3m2uyjt","_id":"cixlg9so501okooxlybavgv84"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9rfa00c9ooxl4findci1","_id":"cixlg9so601olooxlt2kof8r5"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9rgr00f2ooxl5h77j5xb","_id":"cixlg9so601omooxlivvk0cg0"},{"post_id":"cixlg9sny01ohooxlry34pi7o","tag_id":"cixlg9rh900g1ooxlncu1qjx3","_id":"cixlg9so601onooxlog2rd875"},{"post_id":"cixlg9so601ooooxluh670jtd","tag_id":"cixlg9rc4006kooxl1xded5ep","_id":"cixlg9soa01oqooxlst08pqha"},{"post_id":"cixlg9so601ooooxluh670jtd","tag_id":"cixlg9rc3006jooxljttx1uit","_id":"cixlg9sod01orooxlkresep8i"},{"post_id":"cixlg9so601ooooxluh670jtd","tag_id":"cixlg9rcl0074ooxl5pv0t1yh","_id":"cixlg9sod01osooxl1xpobwcg"},{"post_id":"cixlg9so601ooooxluh670jtd","tag_id":"cixlg9rbp0062ooxlfaygxjdl","_id":"cixlg9sod01otooxl1sviftrm"},{"post_id":"cixlg9soh01ouooxl31ydifdg","tag_id":"cixlg9sol01owooxlnsy6tr1f","_id":"cixlg9soo01oyooxlubt3x8li"},{"post_id":"cixlg9soh01ouooxl31ydifdg","tag_id":"cixlg9rii00i8ooxlfaebte34","_id":"cixlg9soq01ozooxlu0b7d1fv"},{"post_id":"cixlg9soh01ouooxl31ydifdg","tag_id":"cixlg9som01oxooxlbyevypln","_id":"cixlg9soq01p0ooxl4ncekq1k"},{"post_id":"cixlg9soh01ouooxl31ydifdg","tag_id":"cixlg9r7h0005ooxl7xizzqno","_id":"cixlg9soq01p1ooxla7jh44z4"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9sox01p5ooxlxecql5y6"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9rh500ftooxliog0rt8q","_id":"cixlg9sp001p6ooxlxv92b0mp"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9sou01p4ooxlnhjn2tly","_id":"cixlg9sp101p7ooxlxdyn2n1j"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9r81000sooxl5gjr8ndd","_id":"cixlg9sp101p8ooxlq9vvtu2p"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9r81000tooxlvy3lm704","_id":"cixlg9sp101p9ooxlujbgj9j3"},{"post_id":"cixlg9sor01p2ooxlmqnul7js","tag_id":"cixlg9rqz00sqooxl63n06e12","_id":"cixlg9sp101paooxln0fqloeo"},{"post_id":"cixlg9sp101pbooxlgpu4kmkq","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9sp601peooxlfgdaznol"},{"post_id":"cixlg9sp101pbooxlgpu4kmkq","tag_id":"cixlg9r8e001cooxl3z233dg9","_id":"cixlg9sp801pfooxlh6q02d1h"},{"post_id":"cixlg9sp101pbooxlgpu4kmkq","tag_id":"cixlg9sp401pdooxl8crfl9d2","_id":"cixlg9sp801pgooxlhle5jx3m"},{"post_id":"cixlg9sp901phooxlc2uv4z47","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9spd01pjooxlmcosaapl"},{"post_id":"cixlg9sp901phooxlc2uv4z47","tag_id":"cixlg9r9e002yooxlon1e05fs","_id":"cixlg9spf01pkooxl6pipe5qv"},{"post_id":"cixlg9sp901phooxlc2uv4z47","tag_id":"cixlg9rfr00cwooxl2taux3yw","_id":"cixlg9spf01plooxlmng7n4lc"},{"post_id":"cixlg9sp901phooxlc2uv4z47","tag_id":"cixlg9r7x000looxlfgkh3sst","_id":"cixlg9spf01pmooxli3ottx9c"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9r7c0002ooxlgw1ab7ay","_id":"cixlg9spm01pqooxlijsey068"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9spj01ppooxlwdbmdw83","_id":"cixlg9spp01prooxlsheedey8"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9sbv01eqooxlwg5rkdwl","_id":"cixlg9spp01psooxlm9g2r5yz"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9rc9006tooxlt4hpqc8m","_id":"cixlg9spp01ptooxlmkm1lnty"},{"post_id":"cixlg9spg01pnooxlq77ex1mq","tag_id":"cixlg9rod00qdooxlha53ivln","_id":"cixlg9spp01puooxl25dgl9st"}],"Tag":[{"name":"","_id":"cixlg9r7c0002ooxlgw1ab7ay"},{"name":"","_id":"cixlg9r7g0003ooxlouh2e40f"},{"name":"","_id":"cixlg9r7g0004ooxlpu66horl"},{"name":"","_id":"cixlg9r7h0005ooxl7xizzqno"},{"name":"","_id":"cixlg9r7h0006ooxlkks9dhtl"},{"name":"BZOJ","_id":"cixlg9r7w000iooxlt8ncwmsh"},{"name":"ZJOI","_id":"cixlg9r7x000jooxl3ou6o1z6"},{"name":"FFT","_id":"cixlg9r7x000kooxl1wzq6q2w"},{"name":"","_id":"cixlg9r7x000looxlfgkh3sst"},{"name":"","_id":"cixlg9r81000sooxl5gjr8ndd"},{"name":"Dinic","_id":"cixlg9r81000tooxlvy3lm704"},{"name":"","_id":"cixlg9r82000uooxl4p625n8c"},{"name":"Edmonds-Karp","_id":"cixlg9r82000vooxly90aizya"},{"name":"","_id":"cixlg9r890014ooxlijrzvrc1"},{"name":"DP","_id":"cixlg9r8e001cooxl3z233dg9"},{"name":"","_id":"cixlg9r8l001iooxldlw1thtn"},{"name":"COGS","_id":"cixlg9r8q001oooxltzzq2ggv"},{"name":"","_id":"cixlg9r8r001pooxlyc0q1m6c"},{"name":"","_id":"cixlg9r8r001qooxlwlkctz05"},{"name":"","_id":"cixlg9r8v001zooxlcpw9gdef"},{"name":"","_id":"cixlg9r8v0020ooxlw36qxixv"},{"name":"","_id":"cixlg9r8z0029ooxlyqa6zz0l"},{"name":"Tarjan","_id":"cixlg9r90002aooxlgrd2fgg3"},{"name":"","_id":"cixlg9r90002booxli7z03vs8"},{"name":"","_id":"cixlg9r93002kooxlh54bru8k"},{"name":"","_id":"cixlg9r96002qooxl5r2zlzp3"},{"name":"","_id":"cixlg9r9e002yooxlon1e05fs"},{"name":"OS X","_id":"cixlg9r9h0036ooxlqisj2rda"},{"name":"Linux","_id":"cixlg9r9i0037ooxlsbc7nni3"},{"name":"Archlinux","_id":"cixlg9r9i0038ooxlkm3my37w"},{"name":"VirtualBox","_id":"cixlg9r9i0039ooxlvgirf8rg"},{"name":"","_id":"cixlg9r9i003aooxlewo42a2j"},{"name":"SSH","_id":"cixlg9r9i003booxlqglqwn0h"},{"name":"UVa","_id":"cixlg9ra5003looxlqj25k0xd"},{"name":" DP","_id":"cixlg9ra6003mooxl1fo09kse"},{"name":"","_id":"cixlg9ra7003nooxlw398qyzu"},{"name":"","_id":"cixlg9rab003vooxlzfo01j5s"},{"name":"","_id":"cixlg9rab003wooxl37uc1xiy"},{"name":"","_id":"cixlg9rao0049ooxlbzlf0rr3"},{"name":"","_id":"cixlg9rao004aooxlk0p6c313"},{"name":" DP","_id":"cixlg9rar004hooxlh2cneg9p"},{"name":"","_id":"cixlg9rau004pooxlsan64mz1"},{"name":"","_id":"cixlg9rav004qooxldtjdx275"},{"name":"","_id":"cixlg9rav004rooxl64zczyza"},{"name":" DP","_id":"cixlg9raz0051ooxl916ggp6y"},{"name":"","_id":"cixlg9rb30059ooxlcu3albgd"},{"name":"","_id":"cixlg9rb8005hooxlvkuj3iik"},{"name":"","_id":"cixlg9rb8005iooxl4nklbagp"},{"name":"","_id":"cixlg9rb9005jooxljsf2wusx"},{"name":"CodeVS","_id":"cixlg9rbi005tooxledxvr0pf"},{"name":"Tyvj","_id":"cixlg9rbk005uooxlb05mbcgh"},{"name":" DP","_id":"cixlg9rbl005vooxl8g5rzkci"},{"name":"","_id":"cixlg9rbp0062ooxlfaygxjdl"},{"name":"TJOI","_id":"cixlg9rbz006booxlc2aoef6x"},{"name":" DP","_id":"cixlg9rbz006cooxlo6c2fj1p"},{"name":"","_id":"cixlg9rc3006jooxljttx1uit"},{"name":"AC ","_id":"cixlg9rc4006kooxl1xded5ep"},{"name":"","_id":"cixlg9rc7006rooxl1vs8rdyg"},{"name":"Splay","_id":"cixlg9rc8006sooxl8iyr5nub"},{"name":"","_id":"cixlg9rc9006tooxlt4hpqc8m"},{"name":"","_id":"cixlg9rcl0074ooxl5pv0t1yh"},{"name":"","_id":"cixlg9rcm0075ooxlzl3dcu1u"},{"name":"","_id":"cixlg9rcn0076ooxl3h88991m"},{"name":"","_id":"cixlg9rcs007eooxljl4cr6fp"},{"name":"","_id":"cixlg9rcv007mooxl2rcb6kfa"},{"name":"","_id":"cixlg9rcy007uooxlgxy1ji5a"},{"name":"","_id":"cixlg9rd40082ooxlb1eovlp3"},{"name":"","_id":"cixlg9rd50083ooxlpmj401g3"},{"name":"C++","_id":"cixlg9rd9008booxlvhckog1m"},{"name":"STL","_id":"cixlg9rd9008cooxlorh78wc9"},{"name":"SPOJ","_id":"cixlg9rdi008hooxly39dpt5q"},{"name":"SHOI","_id":"cixlg9rdz009dooxl0667i3py"},{"name":"","_id":"cixlg9re1009jooxl17lu709s"},{"name":"","_id":"cixlg9reb00a0ooxlhez8iqr8"},{"name":"CDQ","_id":"cixlg9rej00afooxlb4lvl9wu"},{"name":"","_id":"cixlg9rej00agooxlg957oy88"},{"name":"SDOI","_id":"cixlg9ren00apooxlc77jnqlj"},{"name":"","_id":"cixlg9ren00aqooxlfsj277q8"},{"name":"","_id":"cixlg9reo00arooxleknn6uqx"},{"name":"","_id":"cixlg9reo00asooxlwj0nsdlc"},{"name":"","_id":"cixlg9ret00b3ooxllpne01jw"},{"name":"","_id":"cixlg9rex00bdooxlx8kdkklz"},{"name":"","_id":"cixlg9rex00beooxlwxao8570"},{"name":"","_id":"cixlg9rex00bfooxld9yilwth"},{"name":"RMQ","_id":"cixlg9rf600c0ooxlh79pc7t9"},{"name":"","_id":"cixlg9rfa00c9ooxl4findci1"},{"name":"","_id":"cixlg9rfl00ckooxl1t1ryhzn"},{"name":"NTT","_id":"cixlg9rfp00cuooxlb418ewkl"},{"name":"","_id":"cixlg9rfq00cvooxlscwpkhkd"},{"name":"","_id":"cixlg9rfr00cwooxl2taux3yw"},{"name":"","_id":"cixlg9rfr00cxooxldhdyuxmz"},{"name":"","_id":"cixlg9rfy00deooxl4rys2yhu"},{"name":"","_id":"cixlg9rfy00dfooxl3d9e7det"},{"name":"","_id":"cixlg9rfz00dgooxl7dflz7zw"},{"name":"EXGCD","_id":"cixlg9rg200dpooxlpxgfrm7a"},{"name":"BSGS","_id":"cixlg9rg300dqooxljoaconen"},{"name":"","_id":"cixlg9rgk00epooxlz9d136ps"},{"name":"Link-Cut Tree","_id":"cixlg9rgl00eqooxl6rx31ll9"},{"name":"SCOI","_id":"cixlg9rgq00f0ooxla2z4aqjo"},{"name":"set","_id":"cixlg9rgq00f1ooxljoqfe3j6"},{"name":"","_id":"cixlg9rgr00f2ooxl5h77j5xb"},{"name":"","_id":"cixlg9rh000fjooxlob9h9hrs"},{"name":" DP","_id":"cixlg9rh500ftooxliog0rt8q"},{"name":"","_id":"cixlg9rh900g1ooxlncu1qjx3"},{"name":"","_id":"cixlg9rhg00gfooxl7ajpt78z"},{"name":"","_id":"cixlg9rho00gpooxldpn403og"},{"name":"","_id":"cixlg9rhp00gqooxlwhqlb558"},{"name":"","_id":"cixlg9ri100hbooxlkoeo17fm"},{"name":"","_id":"cixlg9ri600hkooxlzzsveto4"},{"name":"DFS","_id":"cixlg9ri600hlooxlg6n4blh1"},{"name":"","_id":"cixlg9rih00i7ooxl65jx3w5z"},{"name":"","_id":"cixlg9rii00i8ooxlfaebte34"},{"name":"POJ","_id":"cixlg9rit00irooxlr95e0h0y"},{"name":"Trie","_id":"cixlg9riu00isooxlcigd4msu"},{"name":"KMP","_id":"cixlg9riy00iyooxlqp6j5wny"},{"name":"Prim","_id":"cixlg9rj200j5ooxl5hfu647a"},{"name":"","_id":"cixlg9rj300j6ooxlxbxwjitw"},{"name":"","_id":"cixlg9rj300j7ooxly5xcactb"},{"name":"POI","_id":"cixlg9rjb00joooxl7dpm24bd"},{"name":"NOIP","_id":"cixlg9rkb00kxooxledeoav11"},{"name":"","_id":"cixlg9rke00l2ooxl1uern1gg"},{"name":"","_id":"cixlg9rkx00leooxlh03treh7"},{"name":"Floyd","_id":"cixlg9rl200ljooxlseakivmj"},{"name":"","_id":"cixlg9rl600lqooxly4jhus6y"},{"name":"BFS","_id":"cixlg9rl600lrooxlwthjx2u0"},{"name":"Hash","_id":"cixlg9rlr00mfooxlmgoshp8r"},{"name":"SPFA","_id":"cixlg9rm000muooxlvx6kdpsq"},{"name":"","_id":"cixlg9rm700n3ooxlba6ej9bv"},{"name":"","_id":"cixlg9rmn00nsooxl0pr2me3j"},{"name":"","_id":"cixlg9rmq00ntooxl3yfmg7cc"},{"name":"Vijos","_id":"cixlg9rmz00o9ooxl61y81v7x"},{"name":"","_id":"cixlg9rn000oaooxlafm6tkz7"},{"name":"","_id":"cixlg9rn200obooxl8e4bkjz3"},{"name":" DP","_id":"cixlg9rn800olooxln9dpmyn1"},{"name":"NOI","_id":"cixlg9rnw00pnooxlb0nmeehc"},{"name":"","_id":"cixlg9rod00qdooxlha53ivln"},{"name":"","_id":"cixlg9roe00qeooxl9sfddbb5"},{"name":"map","_id":"cixlg9rof00qfooxlq93jumjl"},{"name":"","_id":"cixlg9roo00qxooxl28ecubjc"},{"name":"","_id":"cixlg9roz00r6ooxlo5iwgtep"},{"name":"","_id":"cixlg9rp000r7ooxlymu9fyh8"},{"name":"LCT","_id":"cixlg9rpk00ryooxl36numal7"},{"name":"","_id":"cixlg9rq500shooxlt5reslko"},{"name":"","_id":"cixlg9rq700siooxlrvcwf8av"},{"name":"","_id":"cixlg9rqz00sqooxl63n06e12"},{"name":"","_id":"cixlg9rrv00tlooxl6yjfntb3"},{"name":"","_id":"cixlg9rse00u6ooxlnjgn3lg4"},{"name":"Kruskal","_id":"cixlg9rsi00ucooxlwjr6ng4m"},{"name":"","_id":"cixlg9rsj00udooxl4sgwnk5b"},{"name":"Manacher","_id":"cixlg9rsq00upooxl3x7f7dd6"},{"name":"JSOI","_id":"cixlg9rtb00vbooxljymxu8cu"},{"name":"","_id":"cixlg9rtm00vpooxl0x4ha848"},{"name":"","_id":"cixlg9rts00vzooxl6iva4crz"},{"name":"","_id":"cixlg9rut00x9ooxlcdp781e3"},{"name":"IOI","_id":"cixlg9rv900xtooxla3ya2diu"},{"name":"","_id":"cixlg9rvf00y0ooxlaikb14ap"},{"name":"HNOI","_id":"cixlg9rvk00y8ooxljxtmuyiu"},{"name":"DFS ","_id":"cixlg9rvw00ynooxlewljezon"},{"name":"Prfer ","_id":"cixlg9rwk00zgooxl7mcitqah"},{"name":"","_id":"cixlg9rww00zxooxlxr3mjpwx"},{"name":"","_id":"cixlg9rwx00zyooxl7u22v0ag"},{"name":"Burnside ","_id":"cixlg9rx9010eooxlyuii46yp"},{"name":"HEOI","_id":"cixlg9rxx0111ooxl9cql4m0g"},{"name":"HDU","_id":"cixlg9ry20118ooxlv5uflbnw"},{"name":"Bestcoder","_id":"cixlg9ry40119ooxlwynjo53g"},{"name":"BestCoder","_id":"cixlg9ryb011jooxlj980a8it"},{"name":"HAOI","_id":"cixlg9ryp0120ooxlouxejw54"},{"name":"","_id":"cixlg9rz2012fooxlv35g1ywr"},{"name":"GDB","_id":"cixlg9s1i0152ooxla05m35n3"},{"name":"","_id":"cixlg9s1j0153ooxlrv98ovk8"},{"name":"","_id":"cixlg9s1o0159ooxl6hkwjn6q"},{"name":"FJOI","_id":"cixlg9s2g015gooxl90p0wbn7"},{"name":"","_id":"cixlg9s2l015mooxlkeheh0t2"},{"name":"","_id":"cixlg9s380169ooxl6lbbs2mr"},{"name":"Docker","_id":"cixlg9s3l016oooxlwjlyby5o"},{"name":"","_id":"cixlg9s3m016pooxlwg1c0auh"},{"name":"CTSC","_id":"cixlg9s440176ooxlcjm0iksp"},{"name":" 24 ","_id":"cixlg9s450177ooxl6o0v9ah2"},{"name":"CQOI","_id":"cixlg9s4m017pooxlba720hsh"},{"name":"","_id":"cixlg9s5g018hooxlgrq3o7qc"},{"name":"","_id":"cixlg9s8001axooxlyobic1zh"},{"name":"USACO","_id":"cixlg9s9f01ceooxl27qmc1ld"},{"name":"COCI","_id":"cixlg9s9v01csooxlmermlh5i"},{"name":"","_id":"cixlg9s9x01ctooxleb6zfw7h"},{"name":"Codeforces","_id":"cixlg9sab01d8ooxlzeyhdtns"},{"name":"CEOI","_id":"cixlg9sax01dsooxlao4x3j2t"},{"name":"Lucas ","_id":"cixlg9sb501e0ooxlvk8hqk17"},{"name":"","_id":"cixlg9sbv01eqooxlwg5rkdwl"},{"name":"","_id":"cixlg9sbw01erooxl4wqdz5la"},{"name":"","_id":"cixlg9see01h3ooxlcc3v1zyy"},{"name":"Dijkstra","_id":"cixlg9sh901jgooxlcbu0n7lg"},{"name":"","_id":"cixlg9sig01kiooxl0qora2h0"},{"name":"","_id":"cixlg9slj01mqooxldc9qajm0"},{"name":"APIO","_id":"cixlg9sm701n4ooxl7zlbu8l9"},{"name":"","_id":"cixlg9sm801n5ooxl8g1hv5ne"},{"name":"DAG","_id":"cixlg9smp01njooxlytyl9kii"},{"name":"","_id":"cixlg9smq01nkooxlrcpmhl1t"},{"name":"Bellman-Ford","_id":"cixlg9smr01nlooxlcaizbhnv"},{"name":"AHOI","_id":"cixlg9sn301nwooxlx3m2uyjt"},{"name":"","_id":"cixlg9sns01obooxlkc2bvkb3"},{"name":"","_id":"cixlg9sol01owooxlnsy6tr1f"},{"name":"","_id":"cixlg9som01oxooxlbyevypln"},{"name":"","_id":"cixlg9sou01p4ooxlnhjn2tly"},{"name":"","_id":"cixlg9sp401pdooxl8crfl9d2"},{"name":"","_id":"cixlg9spj01ppooxlwdbmdw83"}]}}